

Andrei Timo
Coding to Excellence
Foundations of Computer Science

Galaţi
2024
Description from the National Library
of Romania
TIMO, ANDREI
CODING TO EXCELLENCE / Andrei Timo.
– Galaţi, 2024
ISBN: 978-973-0-39716-1

Preface
Welcome to the world of programming – a realm often
perceived as both exhilarating and challenging. This
book is crafted with a dedicated focus on students who
find themselves grappling with the complexities of
coding, seeking a guiding light through the intricate
pathways of programming languages.
Programming is not just about writing lines of code; it
is about solving problems, thinking critically, and
fostering creativity. In these pages, I aim to demystify the
art of programming, providing a comprehensive and
accessible resource that caters specifically to the needs
of students navigating their way through the intricate
landscape of computer science.
The solutions presented in this book are not mere
templates to be mindlessly replicated. Instead, they are
adaptable tools, designed to be understood, dissected,
and reassembled according to your unique needs. We
encourage you to explore, experiment, and reimplement
the solutions using different approaches. After all,
programming is an art, and there is often more than one
way to create a masterpiece.
Whether you are a novice taking your first steps in
coding or an experienced learner seeking deeper

insights, this book is crafted to be your companion in the
journey of understanding programming. It is my sincere
hope that the knowledge and insights contained within
these pages will empower you to not only conquer the
challenges you face but also to flourish as a creative and
proficient programmer.
Remember, learning to code is a journey, not a
destination. Embrace the challenges, celebrate the
victories, and enjoy the process of becoming a proficient
programmer.
Happy coding!
Andrei Timo

TABLE OF CONTENTS
TABLE OF CONTENTS
Chapter 1 – Linear Structure
Chapter 2 – Conditional Structure
2.1 Problems of Minima/Maxima/Equality
2.2 Divisibility Problems
2.3 Determining the last digit of a power: xy
2.4 Geometry Problems
2.5 Calculating the values of expressions
2.6 Solving equations
Chapter 3 – Repetitive Structure
3.1 Processing the digits of a number
3.2 The Greatest Common Divisor. The Least
Common Multiple. Prime factorization.
3.3 Divisors of a number. Checking for the prime
number property.
3.4 Processing numbers in the interval [a, b]
3.5 Processing n integer numbers read from the
keyboard
3.6 Generating the first n numbers that satisfy a
given condition.

3.7 Generating the first n pairs of numbers (a, b)
that satisfy a given condition.
3.8 Generating the nearest number x to a given n
(number x satisfies a specified condition).
3.9 Decomposing a number into the sum/product of
two or three terms that satisfy a condition.
3.10 Fibonacci Sequence
3.11 Evaluating expressions
3.12 Patterns Display Problems
Chapter 4 – One-dimensional arrays
4.1 Iterating with Processing of Elements.
4.2 Sequential/Linear Search
4.3 Insertion of a New Component
4.4 Deletion of a New Component
4.5 Sorting of components
4.6 Binary Search
4.7 Changing the order of components according to
various criteria.
4.8 Merging of two arrays
4.9 Set Operations
4.10 Processing all pairs or triplets that satisfy a
given condition.
4.11 Processing sequences of adjacent values

4.12 Computation of Expressions
4.13 Generation Problems
4.14 Operations with Large Numbers
4.15 Processing numbers in Different Numeral
Systems
4.16 Frequency Vectors
Chapter 5 – Two-dimensional arrays
5.1 Iterating with Processing of Elements
5.2 Row(s) Processing
5.3 Column(s) Processing
5.4 Deleting a Row
5.5 Deleting a Column
5.6 Generation Problems
5.7 Rearranging Components According to Various
Criteria
5.8 Square Matrices
5.8.1 Diagonals Processing
5.8.2 Processing Areas Bounded By Diagonals
Chapter 6 – Character Strings
6.1 Iterating with processing of Elements
6.2 Characters Deletion
6.3 Displaying characters sorted by different
criteria

6.4 Splitting a text into “words”
6.5 Replacing Characters
6.6 Processing n strings of characters
6.7 Processing texts from file
Chapter 7 – Text files
Chapter 8 – Structure type
Chapter 9 – Subroutines/Methods
9.1 Numerical Processing
9.2 Processing One – Dimensional Arrays
9.3 Processing Two – Dimensional Arrays
9.4 Processing Characters Strings
Chapter 10 – Recursion
10.1 Numerical Processing
10.2 Calculating the value of recursive expressions
10.3 Processing One – Dimensional Arrays
10.4 Processing Two – Dimensional Arrays
10.5 Processing Character Strings
Chapter 11 – Backtracking
11.1 Permutations and Derived Problems
11.2 Arrangements and Derived Problems
11.3 Combinations and Derived Problems
11.4 Subsets and Derived Problems
11.5 Cartesian Product and Derived Problems

11.6 Set partitions and Derived Problems
11.7 Number partitions and Derived Problems
11.8 Problems with Variable Solution Length
11.9 Generalized Backtracking
Chapter 12 – Divide & Conquer
Chapter 13 – Greedy Technique
Chapter 14 – Dynamic Programming
Chapter 15 – Lists
15.1 Singly Linked Lists. Creation. Traversal
15.2 Singly Linked Lists. Insertion.
15.3 Singly Linked Lists. Deletion.
15.4 Singly Linked Lists. Sorting. Merging.
15.5 Doubly Linked Lists
15.6 Circular Lists
15.7 Stacks
15.8 Queues
Chapter 16 – Graphs
16.1 Undirected Graphs. Internal Memory
Representation.
16.2 Undirected Graphs. Traversal
16.3 Undirected Graphs. Connected Components
16.4 Directed Graphs. Storage. Traversal
16.5 Shortest Paths. Minimum Chains.

16.6 Minimum Cost Spanning Tree.
16.7 Hamiltonian Graphs. Eulerian Graphs
Chapter 17 – Trees and Arborescences
17.1 General Trees
17.2 Arborescences
17.3 Binary Trees. Binary Search Trees.
Chapter 18 – Fundamental Algorithms
Chapter 19 – Proposed Exercise to resolve
References

CHAPTER 1 – LINEAR STRUCTURE
The linear (sequential) structure represents a
sequence of instructions that are unconditionally
executed only once.
1. Variables declaration:
variable_type variable_name;
1. Assignment statement:
Logical
Diagram
Pseudocode
C++ language
x =
expression;
Effect: The variable 'x' is assigned the value of the
expression.
1. Data input statement:
Logical Diagram Pseudocode C++ Language

read a,b cin>>a>>b;
Effect: The variables 'a' and 'b' receive the values
provided by the user from the keyboard.
1. Data output/display statement:
Logical Diagram Pseudocode
C++ Language
write a,b cout<<a<<b;
Effect: The values stored in variables 'a' and 'b' will be
displayed to the user on the screen.

Applications:
1.  Variables 'a' and 'b' store values for two integers
from the keyboard. Swap the values of these variables.
Solution: The Glass Rule: Let's assume we have
two glasses filled with juice, one with Coca-Cola and
the other with Fanta, representing the variables 'a' and
'b'. We also have a third empty glass, representing the
auxiliary variable 'aux'. Using the third glass, we want
to transfer Fanta into the glass initially holding Coca-
Cola, and vice versa. To achieve this, we'll pour Coca-
Cola from glass 'a' into the empty glass 'aux', then
pour Fanta from glass 'b' into glass 'a' (where there
initially was Coca-Cola), and finally, pour Coca-Cola
from glass 'aux' into glass 'b', which originally held
Fanta.
The graphical representation of this example is as
follows:


Implementation:
#include <iostream>
using namespace std;
int main()
{
int a,b,aux;
///Reading data from keyboard
cout<<"a=";
cin>>a;
cout<<"b=";
cin>>b;
cout<<"Values before  swapping:"<<a<<","<<b<<endl;
///Swapping a and b
aux = a;
a = b;
b = aux;
cout<<"Values after swapping:"<<a<<","<<b;
return 0;
}
2.  Knowing the 3 marks obtained by a student in
the computer science subject throughout a semester
and the grade from the final exam, write a program to

display their average. The 4 values are read from the
keyboard.
Solution: To calculate the student's final average,
we consider the following formula:
Final_Average = (Average_Marks * 3 + Exam_Mark)
/ 4.
Implementation:
#include <iostream>
using namespace std;
int main()
{
int n1,n2,n3,exam;
float final_average,marks_average;
cin>>n1>>n2>>n3>exam;
///Calculating the average
marks_average = (n1+n2+n3) / 3;
final_average = (3 * marks_average + exam) / 4;
cout<<"The final average is: "<<final_average;
return 0;
}
3.  Let x be a number consisting of exactly 3 digits
read from the keyboard. Display the digits of the

number starting from the units digit with spaces
between them.
Solution: Let's take the example of the number
863. Its representation in base 10 is as follows:
863 = 8 × 102 + 6 × 101 + 3 × 100.
To access the last digit of this number, we need to
divide it by 10 and find the remainder:
863 : 10 = 86 remainder 3
To access the next digit, we use the same
procedure as above:
86 : 10 = 8 remainder 6
We continue this process until the initial number x
has no more digits (it becomes 0 through repeated
division by 10):
8 : 10 = 0 remainder 8
In programming, accessing the units digit is done
using the "%" (modulo) operator, which returns the
remainder of dividing a number x by y.
Using the example given above, with x = 863, the
digit 3 is obtained using the command x%10. To
access the tens digit, following the algorithm
explained earlier, we divide the number x by 10 and

extract the remainder when divided by 10 using
x/10%10.
Implementation:
#include <iostream>
using namespace std;
int main()
{
int x;
cout<<"Give the value of x ? (>=100 and <=999) ";
cin>>x;///863
cout<<"The units digit is "<<x%10<<endl;///3
cout<<"The tens digit is "<<(x/10)%10<<endl;///6
cout<<"The hundreds digit is "<<(x/100)%10;///8
return 0;
}
4.  Let x be a number composed of exactly three
digits read from the keyboard. Reverse the digit in the
units place with the digit in the hundreds place and
display the result.
Solution: To reverse the requested digits, it is
necessary to swap them. (See problem 1)
Implementation:

#include <iostream>
using namespace std;
int main()
{
int x,u,t,h,aux;
cout<<"x=";
cin>>x;
u=x%10; //units digit
t=(x/10)%10; //tens digit
h=(x/100)%10; //hundreds digit
//Swapping the digits
aux=u;
u=h;
h=aux;
//Make the new number with the new digits
x=100*h+10*t+u;
cout<<"The new number is: "<<x;
return 0;
}
5.  A number x composed of exactly 4 digits is read.
Replace the middle two digits with 8 and 9,
respectively, and display the result.

Implementation:
#include <iostream>
using namespace std;
int main()
{
int x; // x=1000*th+100*h+10*t+u
int th,u;
cout<<" x: ";cin>>x;
u=x%10;//units digit
th=(x/1000)%10; //thousands digit
x=th*1000+8*100+9*10+u;
cout<<"The new number is: "<<x;
return 0;
}
6.  A number x composed of exactly 4 digits is read.
Display the number obtained by removing the middle
digits.
Implementation:
#include <iostream>
using namespace std;
int main()
{

int x; // x=1000*th+100*h+10*t+u
int th,u;
cout<<" x: ";cin>>x;
u=x%10;//units digit
th=(x/1000)%10; //thousands digit
x=th*10+u;
cout<<"The new number is: "<<x;
return 0;
}
7.  A natural number x composed of 4 nonzero
digits is read. Display the numbers obtained in the
following ways:
a. By swapping the first digit with the last;
b. By swapping the middle digits with each other;
c. By replacing the middle digits with two "0" digits;
d. By decreasing each digit by one unit.
Implementation:
#include <iostream>
using namespace std;
int main()
{
int x,x1; // x=1000*th+100*h+10*t+u

int mii,sute,zeci,unitati,aux;
cout<<" x: ";cin>>x;
x1=x; //Save x to use it for other manipulations
u = x%10;
t = (x/10)%10;
h = (x/100)%10;
th = (x/1000)%10;
//a. Swap the first digit with the last
aux = u;
u = th;
th = aux;
//Make the new number
x = th*1000+h*100+t*10+u;
cout<<x<<endl;
// Save x to use it for other manipulations
x=x1;
u = x%10;
t = (x/10)%10;
h = (x/100)%10;
th= (x/1000)%10;
//b. Swap the middle digits with each other
aux = t;
t = h;

h = aux;
//Make the new number
x = th*1000+h*100+t*10+u;
cout<<"The new number is: "<<x<<endl;
// Save x to use it for other manipulations
x=x1;
//c. Replace the middle digits with 0
u = x%10;
th= (x/1000)%10;
//Make the new number
x = th*1000+u;
cout<<"The new number is: "<<x<<endl;
// Save x to use it for other manipulations
x=x1;
u = x%10-1;
t = (x/10)%10-1;
h = (x/100)%10-1;
th= (x/1000)%10-1;

//d. Decrease each digit by one unit
//Make the new number
x = th*1000+h*100+t*10+u;
cout<<"The new number is: "<<x<<endl;
8.  A natural number x composed of 4 digits is read.
Display the quotient and remainder of dividing the
number formed by the first two digits of x by the
number formed by the last two digits of x."
Implementation:
int main()
{
int x,nr1,nr2;
cout<<"x=";
cin>>x;
//nr1 first number
//nr2 second number
int th,t,h,u;
u = x%10;
t = x/10%10;
h = x/100%10;
th = x/1000%10;
nr1 = th*10+h;
nr2 = t*10+u;

cout<<"The numbers are: "<<nr1<<","<<nr2<<endl;
cout<<"The quotient is: "<<nr1/nr2<<endl;
cout<<"The remainder is: "<<nr1%nr2;
return 0;
}
9.  A natural number x composed of 4 digits is read.
Display the number obtained from the sum of the
numbers obtained by successively removing one of
the digits of x.
Example: If x=2347, the result is
347+247+237+234=1065.
Implementation:
int main()
{
int x,nr1,nr2,nr3,nr4;
cout<<"x=";//2347
cin>>x;
int m,s,z,u;
u = x%10;
z = x/10%10;
s = x/100%10;
m = x/1000%10;

nr1 = s*100+z*10+u;
nr2 = m*100+z*10+u;
nr3 = m*100+s*10+u;
nr4 = m*100+s*10+z;
cout<<nr1<<"+"<<nr2<<"+"<<nr3<<"+"<<nr4<<"="
<<nr1+nr2+nr3+nr4;
return 0;
}
10.  A natural number x composed of 4 digits is
read. Display the number obtained from the sum of
the numbers obtained by successively eliminating the
first digit of x, then the first two digits, and then the
first three digits.
Example. If x=2347, the result is 347+47+7=401.
Implementation:
#include <iostream>
using namespace std;
int main()
{
int x,nr1,nr2,nr3;
cout<<"x=";//2347
cin>>x;
int mii,sute,zeci,unitati;

unitati = x%10;
zeci = x/10%10;
sute = x/100%10;
mii = x/1000%10;
nr1 = sute*100+zeci*10+unitati; // 1st digit
nr2 = zeci*10+unitati; // 2 digits
nr3 = unitati; // 3 digits
cout<<nr1<<"+"<<nr2<<"+"<<nr3<<"="
<<nr1+nr2+nr3;
return 0;
}
11.  A natural number x composed of 4 digits is
read. Display the number obtained from the sum of
the numbers obtained by successively eliminating the
last digit of x, then the last two digits, and then the
last three digits.
Example. If x=2347, the result is 234+23+2=259.
Implementation:
#include <iostream>
using namespace std;
int main()
{
int x,nr1,nr2,nr3;

cout<<"x=";//2347
cin>>x;
int mii,sute,zeci,unitati;
unitati = x%10;
zeci = x/10%10;
sute = x/100%10;
mii = x/1000%10;
nr1 = mii*100+sute*10+zeci; // 1st digit
nr2 = mii*10+sute; // 2 digits
nr3 = mii; // 3 digits
cout<<nr1<<"+"<<nr2<<"+"<<nr3<<"="
<<nr1+nr2+nr3;
return 0;
}
12.  Let a be a natural number read from the
keyboard, composed of exactly 5 digits. Write a
program (algorithm) to determine and display the
number formed by the first, third, and fifth digits of the
number a.
Example. If a is 23479, the result is the number
249.
Implementation:
#include <iostream>

using namespace std;
int main()
{
int x,c1,c2,c3,nr;
cout<<"x=";//23479
cin>>x;
c3 = x%10;
c2 = x/100%10;
c1 = x/10000%10;
nr = c1*100 + c2*10 + c3;
cout<<nr;
return 0;
}
13.  Determine the last digit of the sum x+y+z,
where x, y, and z are natural numbers read from the
keyboard.
Implementation:
#include <iostream>
using namespace std;
int main()
{
int x,y,z;

cin>>x>>y>>z;
cout<<"The last digit of the sum is: "<<(x+y+z)%10;
return 0;
}
14.  Two natural numbers, x and y, each with 3
digits, are read. Generate the number a composed of
the digits of x and y taken alternately, starting with
the digits of x.
Example: x=246, y=357 we get a=234567.
Implementation:
int main()
{
int x,y,a;
cin>>x>>y;
int x1,x2,x3,y1,y2,y3;
x3=x%10;//last digit
x2=x/10%10;//tens digit of x
x1=x/100%10;//hundreds digit of x
y3=y%10;//last digit of y
y2=y/10%10;//tens digit of y
y1=y/100%10;//hundreds digit of y
a=x1*100000+y1*10000+x2*1000+y2*100+x3*10+y3;

cout<<a;
return 0;
}
15.  Two natural numbers, x and y, each with 3
digits, are read. Generate the real number a
composed of the digits of x for the integer part and
the digits of y for the decimal part.
Example. For x=246 and y=357, the result is
a=234.567.
Implementation:
#include <iostream>
using namespace std;
int main()
{
int x,y;
double a;
cout<<"x=";
cin>>x;
cout<<"y=";
cin>>y;
double y1 = (double)y/1000;
a = (double)x + y1;

cout<<a;
return 0;
}
16.  Determine the area of a triangle given the
lengths of its sides: a, b, c read from the keyboard. It
is assumed that the input data is valid.
Solution: We can apply Heron’s formula:
A = 
 , where 
.
Implementation:
#include <iostream>
#include <cmath>
using namespace std;
int main()
{
double a,b,c,p,A;
cout<<"a=";
cin>>a;
cout<<"b=";
cin>>b;
cout<<"c=";
cin>>c;
p=(a+b+c)/2;

A=sqrt(p*(p-a)*(p-b)*(p-c));
cout<<"Area: "<<A;
return 0;
}
17.  Determine the area of a trapezoid, given the
lengths of the bases b1 and b2, as well as the height
h. All three values will be read from the keyboard.
Solution: We can apply the following formula: A = 
Implementation:
#include <iostream>
#include <cmath>
using namespace std;
int main()
{
double b1,b2,h,A;
cout<<"b1=";
cin>>b1;
cout<<"b2=";
cin>>b2;
cout<<"h=";
cin>>h;

A = (b1+b2)/2 * h;
cout<<"Area: "<<A;
return 0;
}
18.  Determine the circumference and area of a
circle, given the length of the circle's radius, read from
the keyboard.
Solution: We will apply the following formulas: 
.
Implementation:
#include <iostream>
#include <cmath>
#define PI 3.1415
using namespace std;
int main()
{
double R,L,A;
cout<<"R=";
cin>>R;
L = 2*PI*R;
A = PI*R*R;
cout<<"Circumference: "<<L<<endl;

cout<<"Area: "<<A;
return 0;
}
19.  Determine the perimeter and area of a rectangle,
given the length and width of the rectangle.
Solution: We will apply the following formulas: 
.
Implementation:
#include <iostream>
using namespace std;
int main()
{
double L,l,P,A;
cout<<"L=";
cin>>L;
cout<<"l=";
cin>>l;
P = 2*(L+l);
A = L * l;
cout<<"Perimeter: "<<P<<endl;
cout<<"Area: "<<A;

return 0;
}
20.  A ship covers a distance d (in km) in a weeks
and b days (d, a, b are read from the keyboard). What
is the speed of the ship in m/s?
Solution: We will apply the formula for speed: 
. Conversion of kilometers to meters and weeks to
seconds will be necessary.
Implementation:
int main()
{
int d,a,b;
cout<<"Distance: ";
cin>>d;
cout<<"Weeks: ";
cin>>a;
cout<<"Days: ";
cin>>b;
float v;
d = d * 1000; //Convert km in m
b = b + a*7; //Convert weeks in days & sum up the days;
b = b * 24 * 60 * 60; //Convert days in seconds

v = (float) d/b;
cout<<"The speed is: "<<v<<" m/s";
return 0;
}
21.  Determine the distance between two Cartesian
points A and B, for which the coordinates are read
from the keyboard.
Solution: We will apply the mathematical formula: 
.
Implementation:
#include <iostream>
#include <cmath>
using namespace std;
int main()
{
double xa,xb,ya,yb;
cin>>xa;
cin>>ya;
cin>>xb;
cin>>yb;
double d = sqrt((xb-xa)*(xb-xa) + (yb-ya)*(yb-ya));

cout<<"The distance between A("<<xa<<","<<ya<<")
and B("<<xb<<","<<yb<<") is: "<<d;
return 0;
}
22.  Determine the coordinates of the midpoint of
the segment defined by the two Cartesian points A
and B. The coordinates will be read from the keyboard.
Solution: We will apply the formula 
.
Implementation:
#include <iostream>
#include <cmath>
using namespace std;
int main()
{
double xa,xb,ya,yb;
cin>>xa;
cin>>ya;
cin>>xb;
cin>>yb;
double xm,ym;
xm = (xa+xb)/2;
ym = (ya+yb)/2;

cout<<"M("<<xm<<","<<ym<<")";
return 0;
}
23.  Cartesian coordinates are read for 3 points A,
B, C. Determine the perimeter and area of the triangle
formed by these 3 points. It is assumed that the input
data is valid (the points are not collinear).
Solution: With the coordinates of the points
known, we will determine the lengths of the segments
formed by the 3 points (See problem 21) and apply
Heron's formula for area (See problem 16).
Implementation:
#include <iostream>
#include <cmath>
using namespace std;
int main()
{
double xa,xb,ya,yb,xc,yc;
cin>>xa;
cin>>ya;
cin>>xb;
cin>>yb;
cin>>xc;

cin>>yc;
double AB,AC,BC,P,A,p;
AB = sqrt((xb-xa)*(xb-xa) + (yb-ya)*(yb-ya));
AC = sqrt((xc-xa)*(xc-xa) + (yc-ya)*(yc-ya));
BC = sqrt((xb-xc)*(xb-xc) + (yb-yc)*(yb-yc));
p = (AB+AC+BC)/2;
A = sqrt(p*(p-AB)*(p-AC)*(p-BC));
P = (AB+AC+BC);
cout<<"Area: "<<A<<endl;
cout<<"Perimeter: "<<P<<endl;
return 0;
}
24.  Determine the value of the sum S = 1+2+3+
... + n, for n a natural number read from the keyboard.
Solution: For this sum, we will apply Gauss's
formula: 
.
Implementation:
#include <iostream>
using namespace std;
int main()
{
unsigned int n;

cout<<"n=";
cin>>n;
cout<<"Calculate the sum S = 1+2+3+...+"<<n<<endl;
unsigned int S = (n*(n+1))/2;
cout<<"The value of the sum is: "<<S;
return 0;
}
25.  John and Daniel live in the villages of Stanton
and Hope Cove, respectively. Knowing that there is a
distance d between the two villages (expressed in
km), and the two children plan to meet somewhere on
the road between the two villages by cycling as
follows: John at a speed of v1 (expressed in m/s), and
Daniel at a speed of v2 (expressed in m/s). After how
much time do the two friends meet? At what distances
from Stanton and Hope Cove did they meet?
Implementation:

CHAPTER 2 – CONDITIONAL
STRUCTURE
2.1 Problems of Minima/Maxima/Equality
2.2 Divisibility Problems
2.3 Determining the Last Digit of a Power: xy
2.4 Geometry Problems:
2.4.1 Determining the Type of a Geometric Figure
2.4.2 Problems that Determine the Relationship
between Two Geometric  Figures
2.5 Calculating the Value of Expressions
2.6 Solving Equations
2.7 Intervals
Conditional (Decision) Structure executes a
specific set of instructions if a condition is met;
otherwise, it executes another set of instructions. The
general form of the conditional structure is as follows:

The condition will always return a BOOLEAN result
(TRUE or FALSE).
Applications:

2.1 PROBLEMS OF
MINIMA/MAXIMA/EQUALITY
26.  Write a program that determines the largest
among the three integer numbers read from the
keyboard.
Implementation:
int main()
{
int a,b,c,max1,max2;
cin>>a>>b>>c;
if(a>b)
max1=a;
else
max1=b;
if(max1>c)
max2=max1;
else
max2=c;
cout<<"Maximum is: "<<max2;
return 0;
}

27.  Write a program that determines the largest
among the four integer numbers read from the
keyboard.
Implementation:
int main()
{
int a,b,c,d,max1,max2,max3;
cin>>a>>b>>c>>d;
//max(a,b)
if(a>b)
max1=a;
else
max1=b;
//max(c,d)
if(c>d)
max2=c;
else
max2=d;
//max(max1,max2)
if(max1>max2)
max3=max1;
else

max3=max2;
cout<<"Max is: "<<max3;
return 0;
}
28.  Determine whether 3 integer numbers x, y,
and z are equal. It will be displayed “YES” or “NO”.
Solution: We’ll use the mathematical identity as
follows: 
.
Implementation:
#include <iostream>
using namespace std;
int main()
{
int x,y,z;
cin>>x;
cin>>y;
cin>>z;
if(x==y && y==z)
cout<<"YES";
else
cout<<"NO";
return 0;

}
29.  Determine if three integer numbers x, y, and z
are distinct. "YES" will be displayed if they are distinct,
and "NO" will be displayed otherwise.
Solution: Negating the condition from problem 28,
with the addition of checking the first with the third
number.
Implementation:
int main()
{
int x,y,z;
cin>>x>>y>>z;
if(x!=y && y!=z && x!=z)
cout<<"YES";
else
cout<<"NO”;
return 0;
}
30.  Write a program that reads three numerical
values a, b, c from the keyboard and then displays on
the screen the largest difference between any two
values.

Example: a=100, b=15, c=105. The output will be
90.
Implementation:
#include <iostream>
#include <cmath>
using namespace std;
int main()
{
int a,b,c,max1,max2;
cin>>a>>b>>c;
int x,y,z;
x = abs(a-b); //abs difference a & b
y = abs(b-c); // abs difference c & b
z = abs(a-c); // abs difference a & c
if(x>y)
max1=x;
else
max1=y;
if(max1>z)
max2=max1;
else
max2=z;

cout<<"The largest difference is: "<<max2;
return 0;
}
31.  A natural number x with exactly 3 digits is
read. Generate the largest number that has the same
digits as x.
Example: x=192. The output will be 921.
x=244. The output will be 422.
Implementation:
int main()
{
int x,x1,x2,x3,max1,max2;
cout<<"x=";
cin>>x;
//save its digits
x1=x%10;
x2=x/10%10;
x3=x/100%10;
if(x1<x2)
{
if(x3<x1)
cout<<x2<<x1<<x3;

else if((x3>x1) && (x3<x2))
cout<<x2<<x3<<x1;
else
cout<<x3<<x2<<x1;
}
else
{
if(x3<x2)
cout<<x1<<x2<<x3;
else
if((x3>x2)&&(x3<x1))
cout<<x1<<x3<<x2;
else
cout<<x3<<x1<<x2;
}
return 0;
}
32.  A natural number x with exactly 3 digits is
read. Generate the smallest number that has the same
digits as x.
Example: x=192. The output will be 129.
x=242. The output will be 224.

x=801. The output will be 108.
Implementation:
int main()
{
int x,x1,x2,x3,max1,max2;
cout<<"x=";
cin>>x;
//save its digits
x1=x%10;
x2=x/10%10;
x3=x/100%10;
if(x1<x2)
{
if(x3<=x1)
cout<<x3<<x1<<x2;
else
if((x3>=x1) && (x3<=x2))
cout<<x1<<x3<<x2;
else
cout<<x1<<x2<<x3;
}
else

{
if(x3<=x2)
cout<<x3<<x2<<x1;
else
if((x3>=x2) && (x3<=x1))
cout<<x2<<x3<<x1;
else
cout<<x2<<x1<<x3;
}
return 0;
}
33.  Two numbers x and y, each with exactly 4
digits, are read. Display the number that has the
greater sum of its digits.
Example: x=1902 and y=8001. The output will be
1902.
Implementation:
int main()
{
int x,y;
int sx,sy;
cout<<"Dati valoarea lui x ";cin>>x;

cout<<"Dati valoarea lui y ";cin>>y;
//Sum up each digits for x and y
sx=x%10+x/10%10+x/100%10+x/1000%10;
sy=y%10+y/10%10+y/100%10+y/1000%10;
//Check the sums
if(sx==sy)
cout<<"The numbers have an equal sum of digits!";
else
if(sx<sy)
cout<<x<<" has the sum of digits less than "<<y;
else
cout<<x<<" has the sum of digits greater than "<<y;
return 0;
}
34.  Four non-zero integer numbers are read: a, b,
c, and d, representing the numerators and
denominators of two fractions, 
 Display the
fraction with the greater value.
Example: a=2, b=3, c=4, d=5. The output will be:
4/5.
Implementation:
int main()

{
int a,b,c,d;
cout<<"a=";cin>>a;
cout<<"b=";cin>>b;
cout<<"c=";cin>>c;
cout<<"d=";cin>>d;
if(a*d == b*c)
cout<<"Equal fractions ";
else
if(a*d<b*c)
cout<<c<<"/"<<d;
else
cout<<a<<"/"<<b;
return 0;
}
35.  Determine whether 3 numbers x, y, z read
from the keyboard are Pythagorean (a squared value is
equal to the sum of the squares of the other two
values). Display "YES" or "NO".
Implementation:
#include <iostream>
using namespace std;
int main()

{
int x,y,z;
cin>>x;
cin>>y;
cin>>z;
if((x*x==y*y+z*z) ||  (y*y==x*x+z*z) ||
(z*z==x*x+y*y))
cout<<"YES";
else
cout<<"NO";
return 0;
}
36.  Determine whether 3 natural numbers read
from the keyboard can represent a calendar date (in
the format: day, month, year).
Implementation:
int main()
{
int zi,luna, an;
cout<<"a day (>=1 si <=31) ";cin>>zi;
cout<<"a month (>=1 si <= 12) ";cin>>luna;
cout<<"a year (>=1000 si <9999) ";cin>>an;

if((zi>=1 && zi<=31) && (luna>=1 && luna<=12) &&
(an>=1000 && an<=9999))
cout<<"Date is correct!";
else
cout<<"Date is not correct. Try again!";
return 0;
}
37.  Three integer numbers x, y, z are read. Display
the numbers in ascending order.
Solution: Apply the solution from problem 32.
Implementation:
int main()
{
int x,y,z;
cin>>x>>y>>z;
if(x<y)
{
if(z<x)
cout<<z<<" "<<x<<" "<<y;
else
if((z>x) && (z<y))
cout<<x<<" "<<z<<" "<<y;

else cout<<x<<" "<<y<<" "<<z;
}
else
{
if(z<y)
cout<<z<<" "<<y<<" "<<x;
else
if((z>y) && (z<x))
cout<<y<<" "<<z<<" "<<x;
else cout<<y<<" "<<x<<" "<<z;
}
return 0;
}
38.  Four integer numbers x, y, z, w are read.
Determine if they can form a set. Display a message.
Solution: A set is formed by distinct elements.
Implementation:
int main()
{
int x,y,z,w;
cout<<"x=";cin>>x;
cout<<"y=";cin>>y;

cout<<"z=";cin>>z;
cout<<"w=";cin>>w;
if(x == y ||
x == z ||
x == w ||
y == z ||
y == w ||
z == w)
cout<<"NO";
else
cout<<"YES";
return 0;
}
39.  Four integer numbers x, y, z, w are read.
Determine if they can form a proportion. Display a
message.
Solution: Two fractions 
Implementation:
int main()
{
int x,y,z,w;
cin>>x>>y>>z>>w;

if(x*w == y*z)
cout<<"YES";
else
cout<<"NO";
return 0;
}

2.2 DIVISIBILITY PROBLEMS
40.  Check whether an integer number x read from the
keyboard is even or odd. Display a message.
Implementation:
int main()
{
int x;
cout<<"x=";
cin>>x;
if(x%2==0)
cout<<"Even number";
else
cout<<"Odd number";
return 0;
}
41.   Determine whether an integer number x is a
multiple of another integer number y, both read from
the keyboard. Display a message.
Implementation:
int main()
{
int x,y;

cout<<"x=";cin>>x;
cout<<"y=";cin>>y;
if(y%x==0)
cout<<x<<" is a multiple of "<<y;
else
cout<<"It’s not multiple";
return 0;
}
42.   Determine whether x is a multiple of the
numbers a, b, c.
Implementation:
int main()
{
int x,a,b,c;
cin>>x>>a>>b>>c;
if(x%a==0 && x%b==0 && x%c==0)
cout<<x<<" is multiple of "<<a<<","<<b<<","<<c;
else
cout<<"It’s not multiple";
return 0;
}

43.   Determine whether x is a divisor of the
numbers a, b, c.
Implementation:
int main()
{
int x,a,b,c;
cin>>x>>a>>b>>c;
if(a%x==0 && b%x==0 && c%x==0)
cout<<x<<" is divisor of "<<a<<","<<b<<","<<c;
else
cout<<"Not a multiple";
return 0;
}
44.   Two non-zero integers a and b are read,
representing the numerator and denominator of a
fraction , respectively, and a non-zero natural number
k is given. Determine whether the fraction  simplifies
by k. If so, display the fraction obtained after
simplification; otherwise, display the message 'NO'.
Example. a=24, b=40, k=8. Output: 3/5.
a=24, b=40, k=5. Output: NO.
Implementation:

int main()
{
int a,b,k;
cout<<"a=";cin>>a;
cout<<"b=";cin>>b;
cout<<"k=";cin>>k;
if(a%k==0 && b%k==0)
cout<<a/k<<"/"<<b/k;
else
cout<<"NO";
return 0;
}

2.3 DETERMINING THE LAST
DIGIT OF A POWER: XY
45.  Determine the last digit of 9x, where x is a natural
number read from the keyboard.
Solution:
91 = 9
92 = 81
93 = 729
94 = ...1
It can be observed that the last digit of powers of 9
repeats every 2 times, as follows: odd powers have the
last digit 9, while even powers have the last digit 1.
Implementation:
int main()
{
int x;
cout<<"Exponent, x=";
cin>>x;
if(x%2==0)
cout<<"Last digit of 9"<<"^"<<x<<" is "<<1;
else

cout<<"Last digit of 9"<<"^"<<x<<" este "<<9;
return 0;
}
46.  Determine the last digit of 2x, where x is a
natural number read from the keyboard.
Solution:
21 = 2
22 = 4
23 = 8
24 = 16
25 = 32
26 = 64
.........
It can be observed that the last digit of powers of 2
repeats every 4 times.
Implementation:
int main()
{
int x;
cout<<"Power, x=";
cin>>x;

if(x==0)
cout<<1;
else if(x%4==0)
cout<<6;
else if(x%4==1)
cout<<2;
else if(x%4==2)
cout<<4;
else if(x%4==3)
cout<<8;
return 0;
}
47.  Determine the last digit of xy, where x and y
are natural numbers read from the keyboard.
Solution:
Method 1: We calculate the value of xy using the
"pow" function, and then extract the last digit using
the modulo operator. This method can cause errors for
large values of x and y.
Method 2: We find the last digit of x and calculate
the value of the last digit raised to the power y modulo
10.

Implementation:
#include <iostream>
#include <bits/stdc++.h>
using namespace std;
int main()
{
int x,y;
cin>>x>>y;
//Method 1
int power = pow(x,y);
cout<<power%10<<endl;
//Method 2
power=1;
int i;
for(i=0;i<y;i++)
power = (power*x)%10;
cout<<power;
return 0;
}
48.  Determine the last digit of the expression 9x +
4y, where x and y are natural numbers read from the
keyboard.

Solution: According to problem 45, we know that
the powers of 9 repeat every 2 powers.
41 = 4
42 = 16
43 = 64
44 = 256
45 = 1024
Therefore, the powers of 4 also repeat every 2
powers.
Implementation:
int main()
{
int x,y;
cout<<"Exponent, x=";cin>>x;
cout<<"Exponent, y=";cin>>y;
if(x%2==0 && y%2==0)
cout<<7;//1 from 9^x and 6 from 4^y
else if(x%2==1 && y%2==1)
cout<<3;//9 from 9^x and 4 from 4^y => 13%10 => 3
else if(x%2==0 && y%2==1)
cout<<5;//1 from 9^x and 4 from 4^y

else if(x%2==1 && y%2==0)
cout<<5;//1 from 9^x and 4 from 4^y
return 0;
}
49.  Determine the last digit of the expression 7x *
8y, where x and y are natural numbers read from the
keyboard.
Solution:
71 = 7   81 = 8
72 = 49    82 = 64
73 = 343  83 = 512
74 = 2401  84 = 4096
75 = 16807  85 = 32768
We observe that the powers of both numbers
repeat every 4 powers.
Implementation:
int main()
{
int x,y,ux,uy;
cout<<"Exponent, x=";cin>>x;
cout<<"Exponent, y=";cin>>y;

//save last digit of 7^x
if(x%4==1)
ux = 7;
else if(x%4==2)
ux = 9;
else if(x%4==3)
ux = 3;
else if(x%4==0)
ux = 1;
//save last digit of 8^y
if(y%4==1)
uy = 8;
else if(y%4==2)
uy = 4;
else if(y%4==3)
uy = 2;
else if(y%4==0)
uy = 6;
cout<<(ux*uy)%10;
return 0;
}

2.4 GEOMETRY PROBLEMS
50.  Determine whether the point P(x1, y1) belongs to
the interior of the segment [AB], where A(x2, y2) and
B(x3, y3) are given points, the six real values: x1, x2,
x3, y1, y2, y3 are read from the keyboard.
Solution: One approach involves checking if AP +
PB = AB.
Implementation:
int main()
{
float x1,y1,x2,y2,x3,y3;
cout<<"x1=";cin>>x1;
cout<<"y1=";cin>>y1;
cout<<"x2=";cin>>x2;
cout<<"y2=";cin>>y2;
cout<<"x3=";cin>>x3;
cout<<"y3=";cin>>y3;
float AB,AP,PB;
AB = sqrt((x2-x3)*
(x2-x3) + (y2-  y3)*(y2-y3));
AP = sqrt((x1-x2)*
(x1-x2) + (y1-y2)*(y1-y2));

PB = sqrt((x1-x3)*(x1-x3) + (y1-y3)*(y1-y3));
if(AP + PB == AB)
cout<<"P("<<x1<<","<<y1<<") does belong to the
interior of AB";
else
cout<<"It does not belong";
return 0;
}

51.  Determine in which quadrant the point P(x, y)
is located, where x and y are read from the keyboard.
Solution:
Implementation:
int main()
{
float x,y;
cin>>x>>y;
if(x>0 && y>0)
cout<<"Quadrant I.";
else if(x<0 && y>0)
cout<<"Quadrant II.";

else if(x<0 && y<0)
cout<<"Quadrant III.";
else if(x>0 && y<0)
cout<<"Quadrant IV.";
return 0;
}

52.  Three real numbers a, b, c are read. Determine
if they can represent the lengths of the sides of a
triangle. If affirmative, display the type of triangle
(scalene, isosceles, or equilateral).
Solution: In mathematics, to determine if three
numbers represent the sides of a triangle, the
following formulas are used: a+b > c or a+c > b or
b+c > a.
Implementation:
#include <iostream>
using namespace std;
int main()
{
float a,b,c;
cout<<"a=";cin>>a;
cout<<"b=";cin>>b;
cout<<"c=";cin>>c;
if(a+b>c && a+c>b && b+c>a)
{
cout<<a<<","<<b<<","<<c<<" can be the lengths of
the sides of a triangle."<<endl;
if(a==b && b==c)
cout<<"Equilateral triangle "<<endl;

else if(a*a == b*b + c*c || b*b == a*a + c*c || c*c ==
a*a + b*b)
cout<<"Right-angled triangle."<<endl;
else if(a==b || a==c || b==c)
cout<<"Isosceles triangle."<<endl;
else if(a!=b && b!=c)
cout<<"Scalene triangle."<<endl;
}
else
cout<<"The numbers "<<a<<","<<b<<","<<c<<"
cannot be the lengths of the sides of a triangle."<<endl;
return 0;
}
53.  Cartesian coordinates x and y of the three
vertices of a triangle are read from the keyboard. Write
an algorithm that checks whether these can form the
vertices of a triangle. If affirmative, display the type of
triangle (scalene, isosceles, or equilateral). Note: If the
three points are collinear, they cannot form a triangle.
Implementation:
#include <iostream>
#include <cmath>
using namespace std;

int main()
{
//declare the coordinates
int x1, y1, x2, y2, x3, y3;
cin >> x1 >> y1;
cin >> x2 >> y2;
cin >> x3 >> y3;
double a,b,c;
a = sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));
b = sqrt((x1-x3)*(x1-x3) + (y1-y3)*(y1-y3));
c = sqrt((x3-x2)*(x3-x2) + (y3-y2)*(y3-y2));
if(a+b>c && a+c>b && b+c>a)
{
cout<<"The vertices determine a triangle."<<endl;
if(a!=b && b!=c && a!=c)
cout<<"Scalene triangle.";
else if(a==b || b==c || a==c)
cout<<"Isosceles triangle.";
else if(a*a == b*b + c*c || b*b == a*a + c*c || c*c ==
a*a + b*b)
cout<<"Right-angled triangle.";
}
else

cout<<"The vertices do not form a triangle.";
return 0;
}
54.  Determine whether the point P(x1, y1)
belongs to the line determined by the points A(x2,
y2) and B(x3, y3). The six values are read from the
keyboard.
Implementation:
#include <iostream>
#include <cmath>
using namespace std;
int main()
{
//declare and read coordinates
float x1, y1, x2, y2, x3, y3;
cout << "P: ";
cin >> x1 >> y1;
cout << "A: ";
cin >> x2 >> y2;
cout << "B: ";
cin >> x3 >> y3;
// calculate the slope of the line determined by points A
and B.

float panta;
panta = (y3-y2)/(x3-x2);
//display the equation
cout<<"Equation of AB: y+"<<y2<<"="<<panta<<"*(x-"
<<x2<<")"<<endl;
//Check if P belongs to AB
if(y1+y2 == panta*(x1+x2))
cout<<"P("<<x1<<","<<y1<<" belong to the interior of
AB.";
else
cout<<"The points does not belong.";
return 0;
}
55.  Determine whether two lines, d1 and d2,
determined by points A(x1, y1) and B(x2, y2),
respectively C(x3, y3) and D(x4, y4), intersect. The
eight values are read from the keyboard. Display YES
or NO.
Solution: In mathematics, given two lines, d1 and
d2. They do not intersect if and only if the two lines
have equal slopes, and the two lines are not
coincident.
Implementation:

int main()
{
float x1, y1, x2, y2, x3, y3, x4, y4;
cout << "A: ";cin >> x1 >> y1;
cout << "B: ";cin >> x2 >> y2;
cout << "C: ";cin >> x3 >> y3;
cout << "D: ";cin >> x4 >> y4;
//calculate the slopes for both lines
float m1,m2,b1,b2;
m1 = (y2-y1)/(x2-x1);
m2 = (y4-y3)/(x4-x3);
//check if the slopes are equal and the lines are different
b1 = m1 * x1
b2 = m2 * x3
if(m1 == m2 && b1 != b2)
cout<<"NO";
else
cout<<"YES";
return 0;
}
56.  Determine the relationship of point A(x1, y1)
with circle C, centered at O(x2, y2), with radius R. The

five values are read from the keyboard. Display
whether the point is inside, outside, or on the circle.
Solution: A point M0(x0, y0) belongs to the circle
C(O, R), where O(a, b), if and only if it satisfies the
relationship: 
. If the result of the left-
hand side is smaller than the square of the radius,
then point M0 is inside the circle. If the result is greater
than the square of the radius, then point M0 is outside
the circle.
Implementation:
int main()
{
float x1, y1, x2, y2, R;
cout << "A: ";cin >> x1 >> y1;
cout << "C: ";cin >> x2 >> y2;
cout << "R: ";cin >> R;
float result = (x1-x2) * (x1-x2) + (y1-y2)*(y1-y2);
if(result == R*R)
cout<<"A("<<x1<<","<<y1<<") is on the circle.";
else if(rezultat < R*R)
cout<<"A("<<x1<<","<<y1<<") is inside of the circle.";
else if(rezultat > R*R)

cout<<"A("<<x1<<","<<y1<<") is outside of the circle.";
return 0;
}
57.  Determine the relationship between the circles:
C1 with center O1(x1, y1) and radius R1, and C2 with
center O2(x2, y2) and radius R2. The six values are
read from the keyboard. Display whether the circles
are inner, outer, tangent, or intersecting.
Solution: To determine the relative position of the
two circles, we need to calculate the distance between
their centers, denoted as d.
If:
d = 0 and R1 ≠ R2, then the circles are concentric.
d = 0 and R1 = R2, then the circles are identical.
R1 = d + R2 or R2 = d + R1, then the circles are
internally tangent.
d > R1 + R2, then the circles are disjoint
(externally tangent or disjoint).
One circle is inside the other if R1 > d + R2.
d < R1 + R2 and R1 < d + R2 and R2 < d + R1,
then the circles are intersecting.
Implementation:
int main()

{
int x1,y1,R1,x2,y2,R2;
float d;
cout<<"1st circle:";cin>>x1>>y1>>R1;
cout<<"2nd circle:";cin>>x2>>y2>>R2;
d = sqrt((x1-x2) * (x1-x2) + (y1-y2) * (y1-y2));
if(d==0 && R1 != R2)
cout<<"Circles are concentric";
else if(d==0 && R1==R2)
cout<<"Circles are identical";
else if(R1 == d + R2 || R2 == d + R1)
cout<<"Circles are internally tangent";
else if(d > R1 + R2)
cout<<"Circles are externally tangent/disjoint";
else if(R1 > d + R2)
cout<<"Cercuri interioare";
else if(d < R1 + R2 && R1 < d + R2 && R2 < d + R1)
cout<<"Circles are intersecting";
return 0;
}
58.  Determine whether 4 points can form a square.
The coordinates in the plane of the 4 points are read
from the keyboard.

Solution: A square represents a rectangle with 2
consecutive congruent sides (and congruent
diagonals).
Implementation:
int main()
{
int x1,y1,x2,y2,x3,y3,x4,y4;
float l1,l2,l3,l4,d1,d2;
cin>>x1>>y1;
cin>>x2>>y2;
cin>>x3>>y3;
cin>>x4>>y4;
l1 = sqrt((x1-x2) * (x1-x2) + (y1-y2) * (y1-y2));
l2 = sqrt((x3-x2) * (x3-x2) + (y3-y2) * (y3-y2));
l3 = sqrt((x3-x4) * (x3-x4) + (y3-y4) * (y3-y4));
l4 = sqrt((x1-x4) * (x1-x4) + (y1-y4) * (y1-y4));
d1 = sqrt((x1-x3) * (x1-x3) + (y1-y3) * (y1-y3));
d2 = sqrt((x2-x4) * (x2-x4) + (y2-y4) * (y2-y4));
if(l1 == l2 && l2 == l3 && l3 == l4 && l4 == l1 && d1
== d2)
cout<<"It’s a square";
else
cout<<"It’s not a square";

return 0;
}
59.  The Cartesian coordinates of three non-
collinear points A, B, and C are read, as well as the
coordinates of a point M. Determine the relative
position of point M with respect to the triangle: inside
the triangle, outside the triangle, on one of the sides,
or on one of the vertices.
Solution: If point M belongs to the interior of the
triangle, then the sum of the areas determined by the
triangles that share the common point M is equal to
the area of triangle ABC.
Implementation:
#include <iostream>
#include <cmath>
using namespace std;
float area(int x1, int y1, int x2, int y2, int x3, int y3)
{
return abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 -
y2)) / 2.0);
}
float distance(int x1, int y1, int x2, int y2)
{

return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
}
int main()
{
int x1, y1, x2, y2, x3, y3, x, y;
float A1, A2, A3, At;
float AM, MB, MC, AB, AC, BC;
cout << "Coordinates of the first point:"; cin >> x1 >>
y1;
cout << "Coordinates of the second point:"; cin >> x2 >>
y2;
cout << "Coordinates of the third point:"; cin >> x3 >>
y3;
cout << "Coordinates of the fourth point:"; cin >> x >>
y;
// Calculate the lengths of the triangle sides and the sides
that can contain point M
AB = distance(x1, y1, x2, y2);
AC = distance(x1, y1, x3, y3);
BC = distance(x2, y2, x3, y3);
AM = distance(x1, y1, x, y);
MB = distance(x, y, x2, y2);
MC = distance(x, y, x2, y2);

// Area of triangle MBC
A1 = area(x, y, x2, y2, x3, y3);
// Area of triangle MAC
A2 = area(x1, y1, x, y, x3, y3);
// Area of triangle MAB
A3 = area(x1, y1, x2, y2, x, y);
// Area of triangle ABC
At = area(x1, y1, x2, y2, x3, y3);
// Check conditions:
if (A1 + A2 + A3 == At)
cout << "The point is inside the triangle.";
if (A1 + A2 + A3 != At)
cout << "The point is outside the triangle.";
if ((x == x1 && y == y1) || (x == x2 && y == y2) || (x
== x3 && y == y3))
cout << "The point belongs to one of the vertices.";
if (AM + MB == AB)
cout << "The point lies on line AB.";
if (MB + MC == BC)
cout << "The point lies on line BC.";
if (AM + MC == AC)
cout << "The point lies on line AC.";
return 0;

}
60.  The coordinates of four points A, B, C, and D in
a plane are read. Determine whether ABCD is a
parallelogram.
Implementation:
#include <iostream>
#include <cmath>
using namespace std;
float distance(int x1, int y1, int x2, int y2)
{
return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
}
int main()
{
int x1, y1, x2, y2, x3, y3, x4, y4;
cout << "Coordinates of the first point:"; cin >> x1 >>
y1;
cout << "Coordinates of the second point:"; cin >> x2 >>
y2;
cout << "Coordinates of the third point:"; cin >> x3 >>
y3;
cout << "Coordinates of the fourth point:"; cin >> x4 >>
y4;

// Check if the lengths of sides AB are equal to CD and BC
are equal to AD
if ((distance(x1, y1, x2, y2) == distance(x3, y3, x4, y4))
&&
(distance(x2, y2, x3, y3) == distance(x1, y1, x4, y4))
&&
(distance(x1, y1, x3, y3) != distance(x2, y2, x4, y4)))
{
cout << "It is a parallelogram";
}
else
{
cout << "It is not a parallelogram";
}
return 0;
}
61.  The coordinates of four points A, B, C, and D in
a plane are read. Determine whether ABCD is a
rectangle.
Solution: A rectangle is a parallelogram with
congruent diagonals. Additionally, to the previous
problem, we will check if the two diagonals are
congruent.

Implementation:
#include <iostream>
#include <cmath>
using namespace std;
float distance(int x1, int y1, int x2, int y2)
{
return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
}
int main()
{
int x1, y1, x2, y2, x3, y3, x4, y4;
cout << "Coordinates of the first point:"; cin >> x1 >>
y1;
cout << "Coordinates of the second point:"; cin >> x2 >>
y2;
cout << "Coordinates of the third point:"; cin >> x3 >>
y3;
cout << "Coordinates of the fourth point:"; cin >> x4 >>
y4;
// Check if the lengths of sides AB are equal to CD, BC is
equal to AD, and diagonals AC and BD are congruent
if ((distance(x1, y1, x2, y2) == distance(x3, y3, x4, y4))
&&

(distance(x2, y2, x3, y3) == distance(x1, y1, x4, y4))
&&
(distance(x1, y1, x3, y3) == distance(x2, y2, x4, y4)))
{
cout << "It is a rectangle";
}
else
{
cout << "It is not a rectangle";
}
return 0;
}
62.  The coordinates of four points A, B, C, and D in
a plane are read. Determine whether ABCD is a
rhombus.
Solution: Refer to problem 58. We check if all four
sides are congruent, while the diagonals are not
congruent.
Implementation:
#include <iostream>
#include <cmath>
using namespace std;
int main()

{
int x1, y1, x2, y2, x3, y3, x4, y4;
float l1, l2, l3, l4, d1, d2;
cout << "Coordinates of the first point:"; cin >> x1 >>
y1;
cout << "Coordinates of the second point:"; cin >> x2 >>
y2;
cout << "Coordinates of the third point:"; cin >> x3 >>
y3;
cout << "Coordinates of the fourth point:"; cin >> x4 >>
y4;
l1 = sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
l2 = sqrt((x3 - x2) * (x3 - x2) + (y3 - y2) * (y3 - y2));
l3 = sqrt((x3 - x4) * (x3 - x4) + (y3 - y4) * (y3 - y4));
l4 = sqrt((x1 - x4) * (x1 - x4) + (y1 - y4) * (y1 - y4));
d1 = sqrt((x1 - x3) * (x1 - x3) + (y1 - y3) * (y1 - y3));
d2 = sqrt((x2 - x4) * (x2 - x4) + (y2 - y4) * (y2 - y4));
if (l1 == l2 && l2 == l3 && l3 == l4 && l4 == l1 && d1
!= d2)
cout << "It is a rhombus";
else
cout << "It is not a rhombus";
return 0;

}
63.  The coordinates of four points A, B, C, and D in a
plane are read. Determine whether ABCD is a
trapezoid.
Implementation:
int main()
{
int x1, y1, x2, y2, x3, y3, x4, y4;
cout << "Coordinates of the first point:"; cin >> x1 >>
y1;
cout << "Coordinates of the second point:"; cin >> x2 >>
y2;
cout << "Coordinates of the third point:"; cin >> x3 >>
y3;
cout << "Coordinates of the fourth point:"; cin >> x4 >>
y4;
// Check if the slopes of the sides are parallel and non-
parallel
float mAB, mBC, mCD, mAD;
mAB = static_cast<float>(y2 - y1) / (x2 - x1);
mBC = static_cast<float>(y3 - y2) / (x3 - x2);

mCD = static_cast<float>(y4 - y3) / (x4 - x3);
mAD = static_cast<float>(y4 - y1) / (x4 - x1);
if (mAB == mCD && mBC != mAD)
cout << "It is a trapezoid";
else
cout << "It is not a trapezoid";
return 0;
}

2.5 CALCULATING THE VALUES OF
EXPRESSIONS
64.  Determine the value of the sum S = 1 – 2 + 3 – 4
+ 5 – 6 + 7 – 8 + ... ± n, for a natural number n read
from the keyboard.
Solution: A simple approach to solving the
problem is to find the general term of the series and
then calculate the sum up to the n-th term.
Calculating the sum using the formula will reduce the
execution time to O(1). 
sum(1) = 1
sum(2) = 1 - 2 = -1
sum(3) = 1 - 2 + 3 = 2
sum(4) = 1 - 2 + 3 - 4 = -2
sum(5) = 1 - 2 + 3 - 4 + 5 = 3
sum(6) = 1 - 2 + 3 - 4 + 5 - 6 = -3
sum(7) = 1 - 2 + 3 - 4 + 5 - 6 + 7 = 4
sum(8) = 1 - 2 + 3 - 4 + 5 - 6 + 7 - 8 = -4
From here, we can deduce that the sum can be
written in the following pattern:

Implementation:
#include <iostream>
using namespace std;
int main()
{
int n;
cout<<"n=";cin>>n;
if(n%2==0)
cout<<(-1)*(n/2);
else
cout<<(n+1)/2;
return 0;
}
65.  Determine the last digit of the product 1 * 2 *
3 * ... * n, for n read from the keyboard.
Solution: The last digit of a product of natural
numbers is equal to the last digit of the product of the
last digits of the factors in the product.
Last digit (1 * 2) = 2
Last digit (1 * 2 * 3) = 6

Last digit (1 * 2 * 3 * 4) = 4
Last digit (1 * 2 * 3 * 4 * 5) = 0
Last digit (1 * 2 * 3 * 4 * 5 * 6) = 0
...
This pattern continues for higher values of n.
Implementation:
#include <iostream>
using namespace std;
int main()
{
int n;
cout << "n="; cin >> n;
if (n == 1)
cout << "The last digit is 1";
else if (n == 2)
cout << "The last digit is 2";
else if (n == 3)
cout << "The last digit is 6";
else if (n == 4)
cout << "The last digit is 4";
else if (n >= 5)
cout << "The last digit is 0";

return 0;
}
66.  Determine the value of the following function
for x, a real number read from the keyboard:
Implementation:
#include <iostream>
using namespace std;
int main()
{
double x;
cout<<"x=";cin>>x;
if(x<=2)
cout<<5*x*x+1;
else if(x>2 && x<3)
cout<<x-1;
else if(x>=3)
cout<<x*x-4*x+5;
return 0;
}

67.  Determine the value of the following function
for x, a real number read from the keyboard:
Implementation:
#include <iostream>
using namespace std;
int main()
{
double x;
cout<<"x=";cin>>x;
if(x<=1)
cout<<x*x+1;
else if(x>1 && x<5)
cout<<x-1;
else if(x>=5)
cout<<x*x-x+5;
return 0;
}

2.6 SOLVING EQUATIONS
68.  Solve the first-degree equation with one unknown:
ax+b=0, where a and b are real coefficients read
from the keyboard. Consider all possible situations.
Solution:
Implementation:
#include <iostream>
using namespace std;
int main()
{
float a, b, x;
cout << "a="; cin >> a;
cout << "b="; cin >> b;
if (a != 0)
{
if (b != 0)
cout << "x=" << -b/a;

else
cout << "An infinite number of solutions";
}
if (a == 0)
{
if (b == 0)
cout << 0;
else
cout << "Empty set";
}
return 0;
}
69.  Solve the second-degree equation with two
unknowns: ax2+bc+c = 0, where a,b and c are real
coefficients read from the keyboard. Consider all
possible situations.
Implementation:
#include <iostream>
#include <cmath>
using namespace std;
int main()
{

float a, b, c, delta, x1, x2;
cout << "a="; cin >> a;
cout << "b="; cin >> b;
cout << "c="; cin >> c;
if (a != 0 && b != 0)
delta = b * b - 4 * a * c;
else if (a == 0 && b == 0)
cout << "Empty set";
else if (a == 0 && b == 0 && c == 0)
cout << "The equation has an infinite number of
solutions!";
if (a == 0)
{
if (c != 0)
{
x1 = -b / c;
cout << "x=" << x1;
}
else
cout << "The equation has no solutions!";
}
else if (b == 0)
{

if (-c / a >= 0 && c != 0)
{
x1 = sqrt(-c / a);
cout << "x=" << x1;
}
else if (c == 0)
{
cout << "x=0";
}
else
cout << "The equation has no solutions!";
}
if (delta > 0)
{
x1 = (-b + sqrt(delta)) / (2 * a);
x2 = (-b - sqrt(delta)) / (2 * a);
cout << "x1=" << x1;
cout << "x2=" << x2;
}
else if (delta == 0)
{
x1 = -b / (2 * a);
cout << "The unique solution is:" << x1;

}
70.  Solve the following system of equations:
where a,b,c,d,e,f are non-zero real numbers read
from the  keyboard.
Implementation:
#include <iostream>
#include <cmath>
using namespace std;
int main()
{
float a, b, c, d, e, f, ds, dx, dy, x, y;
cout << "a="; cin >> a;
cout << "b="; cin >> b;
cout << "c="; cin >> c;
cout << "d="; cin >> d;
cout << "e="; cin >> e;
cout << "f="; cin >> f;
ds = (a * e - b * d);

dx = (e * c - b * f);
dy = (a * f - d * c);
if (ds == 0)
{
if (dx == 0)
cout << "Undetermined system.";
else
cout << "Incompatible system.";
}
else
{
x = dx / ds;
y = dy / ds;
cout << "x=" << x << endl;
cout << "y=" << y;
}
return 0;
}
2.7 Intervals
71.  Determine whether the value of x belongs to
the interval [a, b], where x, a, and b are real numbers
read from the keyboard. Display YES or NO.

Implementation:
#include <iostream>
using namespace std;
int main()
{
float a, b, x;
cout << "a="; cin >> a;
cout << "b="; cin >> b;
cout << "x="; cin >> x;
if (a <= x && x <= b)
cout << "YES";
else
cout << "NO";
return 0;
}
72.  Four real numbers a, b, c, d are read,
representing the endpoints of two intervals of real
numbers [a, b] and [c, d], respectively. Determine
whether these two intervals intersect. If they do,
display the intersection interval; otherwise, display
"NO."
Implementation:
#include <iostream>

using namespace std;
int main()
{
float a, b, c, d, max_val, min_val;
cout << "a="; cin >> a;
cout << "b="; cin >> b;
cout << "c="; cin >> c;
cout << "d="; cin >> d;
max_val = a;
min_val = b;
if (c > max_val)
max_val = c;
if (d < min_val)
min_val = d;
if (max_val <= min_val)
cout << "The intersection is the interval [" << max_val
<< "," << min_val << "]";
else
cout << "The intersection is the empty set";
return 0;
}
73.  Six real numbers a, b, c, d, e, f are read,
representing the endpoints of three intervals of real

numbers [a, b], [c, d], and [e, f], respectively.
Determine whether these three intervals intersect. If
they do, display the intersection interval; otherwise,
display “Empty set”.
Implementation:
int main()
{
float a, b, c, d, e, f, max_val, min_val;
cout << "a="; cin >> a;
cout << "b="; cin >> b;
cout << "c="; cin >> c;
cout << "d="; cin >> d;
cout << "e="; cin >> e;
cout << "f="; cin >> f;
max_val = a;
if (c > max_val)
max_val = c;
if (e > max_val)
max_val = e;
min_val = b;
if (d < min_val)
min_val = d;
if (f < min_val)

min_val = f;
if (max_val <= min_val)
cout << "The intersection is the interval [" << max_val
<< "," << min_val << "]";
else
cout << "Empty set";
return 0;
}

CHAPTER 3 – REPETITIVE
STRUCTURE
3.1 Processing the Digits of a Number
3.2 Greatest Common Divisor. Least Common
Multiple. Prime Factorization
3.3 Divisors of a Number. Checking for Prime
Number Property
3.4 Processing Numbers in the Interval [a, b]
3.5 Processing n Integer Numbers Read from the
Keyboard
3.6 Generating the First n Numbers That Satisfy a
Given Condition
3.7 Generating the First n Pairs of Numbers (a, b)
That Satisfy a Given Condition
3.8 Generating the Nearest Number x to a Given n
(Number x Satisfies a Given   Condition)
3.9 Decomposing a Number into a Sum/Product of
Two or More Terms That Satisfy a   Condition
3.10 Fibonacci Sequence
3.11 Evaluating Expressions
3.12 Pattern Display Problems

The repetitive structure is a set of instructions that
repeats until a condition is no longer satisfied. The
repetitive structure can be:
Repetitive structure with initial test;
Repetitive structure with final test;
Repetitive structure with a known number of steps
(or repetitive structure with a counter)
The repetitive structure with an initial test
has the specificity of checking a condition before
executing the first cycle of instructions. The general
form of the repetitive structure with an initial test is:
In the C++ programming
language, the repetitive structure with an initial test is
structured as follows:

The repetitive structure with a final test
executes the set of instructions within the structure
once and then checks the validity of the condition. We
can say that the repetitive structure with a final test is
the opposite of the repetitive structure with an initial
test.
The general form of the repetitive structure with a
final test is:
In the C++ programming
language, the repetitive structure with an initial test is
structured as follows:

The repetitive structure with a known number
of steps (or the repetitive structure with a counter)
executes a set of instructions a fixed number of times.
For example, to determine the number of digits in a
number, we don't know the number of steps in
advance, but for finding the sum of the first n natural
numbers, we know the number of steps: n. A repetitive
structure with a known number of steps requires 3
parameters: the counter variable (usually denoted as
i), the loop termination condition, and the increment or
decrement step of the counter variable.
The general form of such a structure is:
execute ...
In C++, the structure with a known number of steps
is the "for" loop. It is structured as follows:
for(int i = a; i <= n; i++)
{
...
}
where:
a is the initial value of the counter variable i;

n is the final value of the counter variable i;
i is the counter variable itself;
The loop will execute as long as the condition i <=
n is true.
The loop iterates with the increment of i (you can
also use a decrement with “i—“ if needed).
Applications:

3.1 PROCESSING THE DIGITS OF A
NUMBER
74.  Determine the following for an integer number x
with at most 9 digits read from the keyboard:
a. Sum of the digits;
b. Product of the digits;
c. Number of its digits.
Implementation:
#include <iostream>
using namespace std;
int main()
{
int x, x1;
int s, p, nr;
cout << "Enter the value of x: ";
cin >> x;
x1 = x; // Save the value of x
s = 0;  // Sum of the digits
p = 1;  // Product of the digits
nr = 0; // Number of digits
if (x == 0)

nr = 1;
while (x1 != 0)
{
s = s + x1 % 10;
p = p * (x1 % 10);
nr++;
x1 = x1 / 10;
}
cout << "Sum of the digits of " << x << " is " << s <<
endl;
cout << "Product of the digits of " << x << " is " << p <<
endl;
cout << "Number of digits in " << x << " is " << nr;
return 0;
}
75.  Determine the reverse of an integer number x
with at most 9 digits read from the keyboard.
Implementation:
int main()
{
int x, x1;

cout << "Enter the value of x: ";
cin >> x;
x1 = 0; // Construct the new number
while (x != 0)
{
x1 = x1 * 10 + x % 10;
x = x / 10;
}
cout << "The reverse of the number is " << x1;
return 0;
}
76.  Determine whether an integer number x with at
most 9 digits, read from the keyboard, is a palindrome.
Solution: A number is a palindrome if and only if it
is equal to its reverse.
Implementation:
#include <iostream>
using namespace std;
int main()
{
int x, x1, t;

cout << "x= ";
cin >> x;
// Save a copy of x for comparison with its reverse
t = x;
// Construct the reverse
x1 = 0;
while (t != 0)
{
x1 = x1 * 10 + t % 10;
t = t / 10;
}
if (x == x1)
cout << "The number is a palindrome!";
else
cout << "The number is not a palindrome!";
return 0;
}
77.  Determine whether it is possible to construct a
palindrome number using the digits of an integer
number x with at most 9 digits, read from the
keyboard. If possible, construct and display the largest
palindrome number.

Example: For x=55566577, the generated
palindrome number is 765555567.
Implementation:
#include <iostream>
using namespace std;
int aparitii_cifre[10]; // introduce a vector to store the
frequency of each digit
int main()
{
long int x, result = 0;
int i, digit, nr_cifre = 0, odd_freq_digit = -1, nr_odd_freq =
0, aparitie_cifra;
cout << "Enter the number: ";
cin >> x;
// Calculate the number of digits in n and the frequency of
each digit
while (x > 0)
{
digit = x % 10;
aparitii_cifre[digit]++;
nr_cifre++;
x = x / 10;
}

// Determine the number of digits that appear an odd
number of times
for (i = 0; i < 10; i++)
{
cout << aparitii_cifre[i] << " ";
if (aparitii_cifre[i] % 2 == 1)
nr_odd_freq++;
}
cout << endl;
// Check the conditions for forming a palindrome
if ((nr_cifre % 2 == 0 && nr_odd_freq > 0) || (nr_cifre %
2 == 1 && nr_odd_freq != 1))
cout << "A palindrome cannot be formed.";
// Construct the palindrome by reading the digits in the
appropriate order
for (i = 9; i >= 0; i—)
{
if (aparitii_cifre[i] > 0)
{
aparitie_cifra = aparitii_cifre[i];
while (aparitie_cifra > 1)
{
result = result * 10 + i;

aparitie_cifra = aparitie_cifra / 2;
}
if (aparitii_cifre[i] % 2 == 1)
odd_freq_digit = i;
}
}
if (nr_odd_freq == 1)
result = result * 10 + odd_freq_digit;
for (i = 0; i <= 9; i++)
{
if (aparitii_cifre[i] > 0)
{
aparitie_cifra = aparitii_cifre[i];
while (aparitie_cifra > 1)
{
result = result * 10 + i;
aparitie_cifra = aparitie_cifra / 2;
}
}
}
cout << result;
return 0;
}

78.  Display the following for an integer number x
with at least 3 digits and at most 9 digits:
a. The units digit.
b. The tens digit.
c. The first digit from the left.
d. The number formed from the last two digits.
e. The number formed from the first two digits.
f. The number formed from the first, third, (fifth, if
applicable), etc. digits from the right.
Implementation:
#include <iostream>
using namespace std;
int main()
{
int x;
cout << "Enter the value of x: ";
cin >> x;
cout << "The units digit is " << x % 10 << endl;
cout << "The tens digit is " << (x / 10) % 10 << endl;
int x1;
x1 = x;
while (x1 > 10)

x1 = x1 / 10;
cout << "The first digit from the left is " << x1 << endl;
cout << "The number formed from the last two digits is "
<< x % 100 << endl;
x1 = x;
while (x1 > 100)
x1 = x1 / 10;
cout << "The number formed from the first two digits is "
<< x1 << endl;
x1 = x;
int x2 = 0;
while (x1 != 0)
{
x2 = x2 * 10 + x1 % 10;
x1 = x1 / 100;
}
x1 = 0;
while (x2 != 0)
{
x1 = x1 * 10 + x2 % 10;
x2 = x2 / 10;
}

cout << "The number formed from the first, third, fifth
digits ... is " << x1;
return 0;
}
79.  Determine the maximum digit of a natural
number x with a maximum of 9 digits, and find out
how many times this digit appears in the
representation of the number x.
Implementation:
#include <iostream>
using namespace std;
int main()
{
int x, x1;
int max_digit, occurrences;
cout << "Enter the value of x: ";
cin >> x;
x1 = x;
max_digit = x1 % 10;
while (x1 != 0)
{
if (max_digit < (x1 / 10) % 10)
max_digit = (x1 / 10) % 10;

x1 = x1 / 10;
}
x1 = x;
occurrences = 0;
while (x1 != 0)
{
if (x1 % 10 == max_digit)
occurrences = occurrences + 1;
x1 = x1 / 10;
}
cout << "The maximum digit is " << max_digit << " and
it appears " << occurrences << " times in the number!";
return 0;
}
80.  Determine whether an integer number xwith a
maximum of 9 digits, read from the keyboard, has all
its digits equal. Display "Yes" or "No".
Example: For x=5555, display "Yes".
For x=54455, display "No".
Implementation:
#include <iostream>
using namespace std;

int main()
{
int x;
bool equalDigits;
cout << "Enter the value of x: ";
cin >> x;
int x1 = x;
equalDigits = true; // Assume that the digits of number x
are equal
while ((x1 >= 10) && (equalDigits != false))
{
if (x1 % 10 != (x1 / 10) % 10)
equalDigits = false;
x1 = x1 / 10;
}
if (equalDigits == true)
cout << "Yes!";
else
cout << "No!";
return 0;
}
81.  Determine whether an integer number x with a
maximum of 9 digits, read from the keyboard, has all

its digits arranged in ascending order. Display "Yes" or
"No".
Example: For x=145589, display "Yes".
For x=2145389, display "No".
Implementation:
int main()
{
int x;
bool ascending;
cout << "Enter the value of x: ";
cin >> x;
ascending = true; // Assume that the digits of number x
are in ascending order
while ((x > 10) && (ascending != false))
{
if (x % 10 < (x / 10) % 10)
ascending = false;
x = x / 10;
}
if (ascending == true)
cout << "Yes";

else
cout << "No";
return 0;
}
82.  Determine the number obtained from an
integer number x with a maximum of 9 digits, read
from the keyboard, by removing the digit(s) from the
middle.
Example: For x=34567, the result is 3467.
For x=345678, the result is 3478.
Implementation:
int main()
{
int x;
int indice, x1, nr_cifre, poz, poz1, poz2, invers;
cout << "Enter the value of x: ";
cin >> x;
x1 = x;
nr_cifre = 0;
if ((x >= 0) && (x <= 9))
nr_cifre = 1;
while (x != 0)

{
x = x / 10;
nr_cifre++;
}
cout << "Number of digits: " << nr_cifre << endl;
if (nr_cifre % 2 != 0)
{
poz = (nr_cifre / 2) + 1;
x = x1;
invers = 0;
indice = 1;
while (x != 0)
{
if (indice != poz)
invers = invers * 10 + x % 10;
x = x / 10;
indice++;
}
x = 0;
while (invers != 0)
{
x = x * 10 + invers % 10;
invers = invers / 10;

}
}
else
{
poz1 = (nr_cifre / 2);
poz2 = poz1 + 1;
x = x1;
invers = 0;
indice = 1;
while (x != 0)
{
if ((indice != poz1) && (indice != poz2))
invers = invers * 10 + x % 10;
x = x / 10;
indice++;
}
x = 0;
while (invers != 0)
{
x = x * 10 + invers % 10;
invers = invers / 10;
}
}

cout << "Number obtained after removal: " << x;
return 0;
}
83. Determine the number obtained from the even-
positioned digits of an integer number x with a
maximum of 9 digits, read from the keyboard, in the
order they appear in the original number.
Example: For x=34567, the result is 46.
Implementation:
#include <iostream>
using namespace std;
int main()
{
int x, x1;
int p = 1; // will help in constructing the number and
maintaining the position of the digits
cout << "Enter the value of x: ";
cin >> x;
x1 = 0;
while (x != 0)
{
int last_digit = x % 10;
if (last_digit % 2 == 0)

{
x1 = x1 + last_digit * p;
p = p * 10;
}
x = x / 10;
}
cout << "Obtained number: " << x1;
return 0;
}
84.  Determine the largest number with the same
digits as an integer number x with a maximum of 9
digits, read from the keyboard.
Example: For x=88349984, the result is 99888443.
Implementation:
#include <iostream>
using namespace std;
int main()
{
int x, x1, i, x2;
cout << "x=";
cin >> x;
x2 = 0;

// Iterate in decreasing order through the digits
for (i = 9; i >= 0; i—)
{ 
// Construct the number if and only if digit i is found in x
x1 = x;
while (x1 != 0)
{
if (x1 % 10 == i)
x2 = x2 * 10 + x1 % 10;
x1 = x1 / 10;
}
}
cout << "The largest number obtained is " << x2;
return 0;
}
85.  Determine the smallest number with the same
digits as an integer number x with a maximum of 9
digits, read from the keyboard.
Example: For x=88349984, the result is 34488899.
For x=40404767, the result is 40044677.

Implementation:
#include <iostream>
#include <algorithm>
using namespace std;
int cifre[10]; // store digits and their frequency
int main()
{
int i;
long x;
cout << "x=";
cin >> x;
int numar_zerouri = 0;
i = 0;
// Separate the digits and count the number of zeros
while (x != 0)
{
if (x % 10 == 0)
numar_zerouri++;
else
cifre[i++] = x % 10;
x = x / 10;
}

// Sort the non-zero digits
sort(cifre, cifre + i);
for (i = 0; i < 10; i++)
{ 
// When reaching the second digit
if (i == 1)
{ 
// Check if there are any zeros in the number. If yes, add
them to the new constructed number
if (numar_zerouri != 0)
{
for (int j = 1; j <= numar_zerouri; j++)
x = x * 10;
}
}
// Construct the number with non-zero digits
x = x * 10 + cifre[i];
}
cout << x;
return 0;
}

86.  Display for an integer number x with a
maximum of 9 digits read from the keyboard:
a. The digits that appear in the number's
representation in ascending order and the
frequency of each digit in the number.
b. The digits that do not appear in the number's
representation in descending order.
Implementation:
#include <iostream>
using namespace std;
int main()
{
int x, x1, i, nr_ap;
cout << "x = ";
cin >> x;
for (i = 0; i <= 9; i++)
{
x1 = x;
nr_ap = 0;
while (x1 != 0)
{
if (x1 % 10 == i)

nr_ap++;
x1 = x1 / 10;
}
if (nr_ap != 0)
cout << " Digit " << i << " appears " << nr_ap << "
times!" << endl;
}
// Requirement b)
for (i = 9; i >= 0; i—)
{
x1 = x;
nr_ap = 0;
while (x1 != 0)
{
if (x1 % 10 == i)
nr_ap++;
x1 = x1 / 10;
}
if (nr_ap == 0)
cout << " Digit " << i << " does not appear" << endl;
}
return 0;
}

87.  For two integers x and y, each with at most 9
digits, display:
a. The common digits only once in ascending order;
b. The largest digit that appears in both numbers;
c. The digits that do not appear in either of the two
input numbers;
d. The message "Yes" if the two numbers have the
same digits but in a different order.
Implementation:
int main()
{
int x, y, x1, y1;
int i;
int max_digit;
int nr_apx, nr_apy;
cout << "Enter the value of x = ";
cin >> x;
cout << "Enter the value of y = ";
cin >> y;
// Requirement a)
for (i = 0; i <= 9; i++)
{

nr_apx = 0;
x1 = x;
while (x1 != 0)
{
if (x1 % 10 == i)
nr_apx++;
x1 = x1 / 10;
}
nr_apy = 0;
y1 = y;
while (y1 != 0)
{
if (y1 % 10 == i)
nr_apy++;
y1 = y1 / 10;
}
if ((nr_apx != 0) && (nr_apy != 0))
cout << "Common digit " << i << "!" << endl;
}
// Requirement b)
x1 = x;
max_digit = x1 % 10;
while (x1 != 0)

{
if (max_digit < (x1 / 10) % 10)
max_digit = (x1 / 10) % 10;
x1 = x1 / 10;
}
nr_apy = 0;
y1 = y;
while (y1 != 0)
{
if (y1 % 10 == max_digit)
nr_apy++;
y1 = y1 / 10;
}
if (nr_apy == 0)
cout << "Numbers " << x << " and " << y << " do not
have a common highest digit!" << endl;
else
cout << "The common highest digit in both numbers is "
<< max_digit << " and it appears " << nr_apy << " times!"
<< endl;
// Requirement c)
for (i = 0; i <= 9; i++)
{

x1 = x;
nr_apx = 0;
while (x1 != 0)
{
if (x1 % 10 == i)
nr_apx++;
x1 = x1 / 10;
}
y1 = y;
nr_apy = 0;
while (y1 != 0)
{
if (y1 % 10 == i)
nr_apy++;
y1 = y1 / 10;
}
if ((nr_apx == 0) && (nr_apy == 0))
cout << "Digit " << i << " does not appear in " << x <<
" or " << y << endl;
}
// Requirement d)
bool equal_digits = true;
for (i = 0; i <= 9; i++)

{
x1 = x;
nr_apx = 0;
while (x1 != 0)
{
if (x1 % 10 == i)
nr_apx++;
x1 = x1 / 10;
}
y1 = y;
nr_apy = 0;
while (y1 != 0)
{
if (y1 % 10 == i)
nr_apy++;
y1 = y1 / 10;
}
if (nr_apx != nr_apy)
{
equal_digits = false;
break;
}
}

if (equal_digits)
cout << "YES";
else
cout << "NO";
return 0;
}
88.  Display the control digit (the digit obtained by
adding the digits of the number until a single digit is
obtained) for an integer number x with at most 9 digits
read from the keyboard.
Example: For x=55566577, the sums obtained are
46, then 10, then 1. The control digit is 1.
Implementation:
int main()
{
int x;
cout << "Enter the value of x = ";
cin >> x;
while (x > 9)
{
int x1 = x, s = 0;
while (x1 != 0)

{
s = s + x1 % 10;
x1 = x1 / 10;
}
x = s;
}
cout << "The control digit of the number is " << x;
return 0;
}
89.  Display the number obtained by concatenating
the digits of two integer numbers, x and y, each with
at most 4 digits.
Example: For x=123 and y=5677, the result is
1235677.
Implementation:
#include <iostream>
using namespace std;
int main()
{
int x, y;
int y1;
cout << "Enter the value of x = ";

cin >> x;
cout << "Enter the value of y = ";
cin >> y;
y1 = 0;
while (y != 0)
{
y1 = y1 * 10 + y % 10;
y = y / 10;
}
// Reversing the digits of y and appending it to x
while (y1 != 0)
{
x = x * 10 + y1 % 10;
y1 = y1 / 10;
}
cout << "The number obtained by concatenation is " <<
x;
return 0;
}
90.  Display the largest number formed by the
digits of two integer numbers, x and y, each with at
most 4 digits.

Example: For x=123 and y=5677, the result is
77655321.
Implementation:
int main()
{
int x, y, y1 = 0;
cout << "x=";
cin >> x;
cout << "y=";
cin >> y;
while (y != 0)
{
y1 = y1 * 10 + y % 10;
y = y / 10;
}
y = y1;
while (y != 0)
{
x = x * 10 + y % 10;
y = y / 10;

}
for (int i = 9; i >= 0; i—)
{
int x1 = x;
while (x1 != 0)
{
if (x1 % 10 == i)
cout << i;
x1 = x1 / 10;
}
}
return 0;
}
91.  Display the number obtained by removing the
digit at position k from an integer number x with at
most 9 digits read from the keyboard.
a. Counting starts from the right to the left.
b. Counting starts from the left to the right.
Implementation:
#include <iostream>
using namespace std;

int main()
{
int x, k, t;
int pos = 0;
cout << "x="; cin >> x;
cout << "k="; cin >> k;
t = x;
int x1 = 0;
// Removing the digit by iterating from right to left!
while (x != 0)
{
if (pos != k)
{
x1 = x1 * 10 + x % 10;
}
pos++;
x = x / 10;
}
while (x1 != 0)
{
x = x * 10 + x1 % 10;
x1 = x1 / 10;
}

cout << "x=" << x << endl;
// Requirement b)
x = t;
int length = 0;
while (x != 0)
{
length++;
x = x / 10;
}
// Determining the length of number x
// Let this be 'length'
cout << "The length of the number is " << length <<
endl;
cout << "k=";
cin >> k;
x = t;
x1 = 0;
pos = 0;
while (x != 0)
{
x1 = x1 * 10 + x % 10;
x = x / 10;
}

while (x1 != 0)
{
if (pos != length - k - 1)
{
x = x * 10 + x1 % 10;
}
pos++;
x1 = x1 / 10;
}
cout << "x=" << x << endl;
return 0;
}
92.  Replace the digit 'a' with the digit 'b' in the
representation of the number x, where a, b, and x are
read from the keyboard.
Example: For x=45808, a=8, b=1, the result is
x=45101.
Implementation:
int main()
{
int x, a, b;
cout << "x=";

cin >> x;
cout << "The digit to be replaced in number x is ";
cin >> a;
cout << "The digit with which to replace in number x is ";
cin >> b;
int x1;
x1 = 0;
while (x != 0)
{
if (x % 10 == a) // If we encounter digit 'a', replace it with
'b'
x1 = x1 * 10 + b;
else
x1 = x1 * 10 + x % 10; // Otherwise, keep the digit
unchanged
x = x / 10;
}
while (x1 != 0) // Reverse the number x1 to obtain x
after replacements
{

x = x * 10 + x1 % 10;
x1 = x1 / 10;
}
cout << "The number x after replacements is " << x;
return 0;
}
93.  Given a natural number x with at most 9 digits,
decrease each non-zero digit by one.
Example: For x=567001, the result is 456000.
Implementation:
#include <iostream>
using namespace std;
int main()
{
int x, x1;
cout << "Enter the value of number x = ";
cin >> x;
x1 = 0;
// Construct the reverse of a number by decrementing non-
zero digits by one
while (x != 0)
{

if (x % 10 != 0)
x1 = x1 * 10 + (x % 10 - 1); // Digit is not zero, subtract
one and add to the reverse
else
x1 = x1 * 10; // Here, the last digit is zero, so no addition
is needed
x = x / 10;
}
// Reconstruct the reverse of the reverse to obtain the
result
while (x1 != 0)
{
x = x * 10 + x1 % 10;
x1 = x1 / 10;
}
cout << "The number obtained after decreasing each non-
zero digit by one is " << x;
return 0;
}
94.  Given a natural number x with at most 4 digits,
insert the next digit before each even digit.
Example: For x=5672, the result is 576732.
Implementation:

int main()
{
long x, x1;
cout << "x= ";
cin >> x;
x1 = 0;
while (x != 0)
{
if (x % 10 % 2 == 0)
x1 = (x1 * 10 + x % 10) * 10 + x % 10 + 1;
else
x1 = x1 * 10 + x % 10;
x = x / 10;
}
while (x1 != 0)
{
x = x * 10 + x1 % 10;
x1 = x1 / 10;
}
cout << "The newly obtained number is " << x;

return 0;
}
95.  Given a natural number x with at most 4 digits,
double the appearance of each even digit in the
number x.
Example: For x=5672, the result is 566722.
Implementation:
int main()
{
long x, x1;
cout << "x= ";
cin >> x;
x1 = 0;
while (x != 0)
{
if (x % 10 % 2 == 0)
x1 = (x1 * 10 + x % 10) * 10 + x % 10;
else
x1 = x1 * 10 + x % 10;
x = x / 10;

}
while (x1 != 0)
{
x = x * 10 + x1 % 10;
x1 = x1 / 10;
}
cout << "The newly obtained number is " << x;
return 0;
}
96.  Given a natural number x with at most 9 digits,
move the zeros to the end of x.
Example: For x=5607002, the result is 5672000.
Implementation:
#include <iostream>
using namespace std;
int main()
{
long x, x1;
int i, nr;
cout << "x=";
cin >> x;
x1 = 0;

nr = 0;
while (x != 0)
{
int u;
u = x % 10;
if (u != 0)
x1 = x1 * 10 + u;
else
nr++;
x = x / 10;
}
while (x1 != 0)
{
x = x * 10 + x1 % 10;
x1 = x1 / 10;
}
// Place the zeros at the end of the number
for (i = 1; i <= nr; i++)
x = x * 10;
cout << "The obtained number is: " << x;

return 0;
}
97.  Given two natural numbers x and y with at
most 4 digits, generate the number z formed by
alternating the digits of x and y, starting with the
digits of x, and appending the remaining digits at the
end.
Example: For x=2345 and y=77, the result is
z=273745.
Implementation:
#include <iostream>
using namespace std;
int main()
{
int x, x1, y, y1;
cout << "x=";
cin >> x;
cout << "y=";
cin >> y;
x1 = 0;
y1 = 0; 
// Reverse 'x' to take digits from left to right
while (x != 0)

{
x1 = x1 * 10 + x % 10;
x = x / 10;
}
// Reverse 'y' to take digits from left to right
while (y != 0)
{
y1 = y1 * 10 + y % 10;
y = y / 10;
}
while ((x1 != 0) && (y1 != 0))
{
x = (x * 10 + x1 % 10);
x = (x * 10 + y1 % 10);
x1 = x1 / 10;
y1 = y1 / 10;
}
if (x1 == 0)
while (y1 != 0)
{
x = x * 10 + y1 % 10;
y1 = y1 / 10;
}

if (y1 == 0)
while (x1 != 0)
{
x = x * 10 + x1 % 10;
x1 = x1 / 10;
}
cout << "x=" << x;
return 0;
}
98.  Determine whether a natural number n has only
an even digit in its unit's place. Display "Yes" or "No".
Example: For n=3456, "No" is displayed; for
n=1354, "Yes" is displayed; for n=13333, "No" is
displayed.
Implementation:
#include <iostream>
using namespace std;
int main()
{
int x;
bool found;

cout << "Enter the value of x=";
cin >> x;
if ((x % 10) % 2 == 0)
{
found = true; // Assume that the unit's digit is unique
x = x / 10; // Remove it from the number
while ((x != 0) && (found != 0))
{
if ((x % 10) % 2 == 0)
found = false; // The current digit is even, so our
assumption is false
x = x / 10;
}
}
else
found = false;
if (found == true)
cout << "Yes";
else
cout << "No";
return 0;
}

99.  Determine the sum of the digits of number a that
do not divide it by number b, where a and b are
integers with at most 9 digits each.
Example: For a=184465709 and b=18, the result
is 28, which is the sum of digits: 8+4+4+5+7.
Implementation:
int main()
{
long a, b;
int sum;
cout << "a=";
cin >> a;
cout << "b=";
cin >> b;
sum = 0;
while (a != 0)
{ 
int u = a % 10; // Last digit
if (b % u != 0)
sum = sum + u;
a = a / 10;

}
cout << "The sum of the digits is " << sum;
return 0;
}
100.  Two natural numbers n and k are read from
the keyboard. Display the number obtained by
removing the first k digits from number n. If the
number of digits to be removed is greater than the
number of digits in n, then display the message
"VOID" (empty).
Example: For n=3456789 and k=3, the result is
6789.
Implementation:
int main()
{
int x, x1, num_digits, k;
cout << "x = ";
cin >> x;
cout << "k = ";
cin >> k;
x1 = x;
num_digits = 0;
while (x1 != 0)

{
num_digits++;
x1 = x1 / 10;
}
if (k > num_digits)
cout << "VOID";
else
{
x1 = 0;
int pos = 1;
while (pos <= num_digits - k)
{
x1 = x1 * 10 + x % 10;
pos++;
x = x / 10;
}
x = 0;
while (x1 != 0)
{
x = x * 10 + x1 % 10;
x1 = x1 / 10;
}
cout << "x=" << x;

}
return 0;
}
101.  Let x be a natural number with at most 9
digits. Display the numbers obtained by successively
removing one odd digit from x.
Example: for x=52553, we obtain: 5255 (by
removing the digit 3) and 23 (by removing the digit 5).
Implementation:
int main()
{
int i, x, x1;
cout << "Enter the value of x = ";
cin >> x;
for (i = 1; i <= 9; i += 2) // considering all odd digits one
by one
{
x1 = x; // x1 is a duplicate of x, used to avoid direct
modification
bool found = false; // assuming that there are no odd
digits in the number x
int x2 = 0;
while (x1 != 0)

{
if (x1 % 10 == i) // encountering an odd digit, so the
assumption made is false
{
x1 = x1 / 10; // removing it from the number x1
found = true; // indicating that an odd digit has been
removed
}
else
{
x2 = x2 * 10 + x1 % 10; // placing even digits in a reverse
of the number x
x1 = x1 / 10; // removing the saved digit
}
}
// reversing the number x2, which is essentially x without
odd digits
x1 = 0;
while (x2 != 0)
{
x1 = x1 * 10 + x2 % 10;
x2 = x2 / 10;
}

if (found == true)
cout << "The number obtained after removing the digit "
<< i << " is " << x1 << endl;
}
return 0;
}
102.  Insert the two halves of a natural number n. If
the number has an odd number of digits, the middle
digit remains in place (n ≤ 1,000,000,000).
Example: for n = 1238456, the result is n =
4568123.
Implementation:
int main()
{
int x, l;
cout << "x = ";
cin >> x;
int x1, x2;
if ((x >= 0) && (x <= 9))
{
l = 1;
x1 = x2 = x;
cout << "The number obtained after inversion is " << x;

}
else
{
l = 0; // determine the length of the number x
int y = x;
while (y != 0)
{
l++;
y = y / 10;
}
if (l % 2 == 0) // if the length of the number is even
{
y = x; // save x in a copy and work with the copy
x2 = 0;
int poz = 1;
while (poz <= l / 2)
{
x2 = x2 * 10 + y % 10; // form the second half of the
number x
y = y / 10;
poz++;
}
x1 = 0;

while (poz <= l)
{
x1 = x1 * 10 + y % 10; // form the first half of the number
x
y = y / 10;
poz++;
}
y = 0; // form y as = |x2| x1|
while (x2 != 0)
{
y = y * 10 + x2 % 10; // first, input the reversed x2 into y
x2 = x2 / 10;
}
while (x1 != 0) // then input x1
{
y = y * 10 + x1 % 10;
x1 = x1 / 10;
}
cout << "The number obtained after inversion is " << y;
}
else
{

// The number x has an odd number of digits and is of the
form x = |x1| middle_digit |x2|
y = x;
x2 = 0;
int poz = 1;
while (poz <= l / 2) // form x2
{
x2 = x2 * 10 + y % 10;
y = y / 10;
poz++;
}
int middle_digit = y % 10; // save the middle digit
y = y / 10; // remove it from the number y to not save it in
x1
poz++; // increment the counter
x1 = 0;
while (poz <= l) // form x1
{
x1 = x1 * 10 + y % 10;
y = y / 10;
poz++;
}

y = 0; // similar to the first case, form y by first inputting
x2,
// then the middle digit, and finally x1
while (x2 != 0)
{
y = y * 10 + x2 % 10;
x2 = x2 / 10;
}
y = y * 10 + middle_digit; // include the middle digit in y
while (x1 != 0)
{
y = y * 10 + x1 % 10;
x1 = x1 / 10;
}
cout << "The number obtained after inversion is " << y;
}
}
return 0;
}
103.  A natural number n (n ≥ 100) is read from
the keyboard. Write a program that displays on the
screen the number formed by the first and last digits
of the number n.

Example: For n = 1238456, the output is 16.
Implementation:
#include <iostream>
using namespace std;
int main()
{
int x, p, u, y;
cout << "Enter the value of x = ";
cin >> x;
y = x;
if ((y >= 0) && (y <= 9))
cout << "The obtained number has a single digit and it is
" << y;
else
{
u = y % 10; // form the last digit, let this be u
while (y >= 10)
y = y / 10; // while y has at least 2 digits, remove the last
digit,
// this method is used to correctly position until the first
digit
p = y % 10; // form the first digit as well

cout << "The number obtained by concatenating the first
and last digits is " << p * 10 + u;
}
return 0;
}

3.2 THE GREATEST COMMON
DIVISOR. THE LEAST COMMON
MULTIPLE. PRIME FACTORIZATION.
104.  Determine the greatest common divisor of two
nonzero integer numbers x, y:
a. through repeated subtractions;
b. through repeated divisions (Euclidean algorithm);
c. determine if the two numbers are coprime (relatively
prime).
Implementation:
#include <iostream>
using namespace std;
int main() {
int x, y, x1, y1;
cout << "Enter the value of x = ";
cin >> x;
cout << "Enter the value of y = ";
cin >> y;
x1 = x;
y1 = y;
// Calculate GCD through repeated subtractions
while (x1 != y1) {
if (x1 > y1)

x1 = x1 - y1;
else
y1 = y1 - x1;
}
cout << "GCD using repeated subtractions is " << x1 <<
endl;
// Restore x1 and y1
x1 = x;
y1 = y;
// Swap values if x1 < y1
if (x1 < y1) {
int t = x1;
x1 = y1;
y1 = t;
}
int rest = x1 % y1; // The last non-zero remainder is the GCD
of x1 and y1
while (rest != 0) {
x1 = y1;
y1 = rest;
rest = x1 % y1;
}
cout << "GCD using Euclidean algorithm is = " << y1 <<
endl;

// Check if the numbers are coprime
if (y1 == 1)
cout << "The numbers are coprime (relatively prime).";
else
cout << "The numbers are not coprime.";
return 0;
}
105.  Determine the greatest common divisor of 3
nonzero integer numbers x, y, z read from the keyboard.
Implementation:
int main() {
int a, b, c, r;
cin >> a >> b >> c;
r = a % b;
while (r != 0) {
a = b;
b = r;
r = a % b;
}
r = b % c;
while (r != 0) {
b = c;
c = r;
r = b % c;

}
cout << "GCD is: " << c;
return 0;
}

106.  Determine the least common multiple of 2
nonzero integer numbers x, y read from the keyboard.
Solution: We will use the mathematical formula (a, b)
* [a, b] = a * b.
Implementation:

107.  Determine the least common multiple of three
nonzero integer numbers x, y, z read from the keyboard.
Implementation:

108.   Determine the greatest common divisor of n
nonzero integer numbers read from the keyboard.
Implementation:

109.   Display the prime factorization of the natural
number x with at most nine digits as a set of pairs a, b
where ab is a factor from the factorization.
Example: For x=9800 (23 × 52 × 72), the output will
be:
2 3
5 2
7 2

Implementation:

110.  
Determine how many factors are involved in the prime
factorization of the natural number x with at most 9
digits.
Example: For x=9800 (23 × 52 × 72), the output is
3.

Implementation:
111.   Determine the sum of the exponents of the
factors involved in the prime factorization of the natural
number x with at most 9 digits. Based on the result,
determine if the number x is a prime number.
Example: For x=9800 (23 × 52 × 72), the output is 7
(3+2+2). It's not a prime number. For x=23, the output is
1. It's a prime number.

Implementation:

3.3 DIVISORS OF A NUMBER.
CHECKING FOR THE PRIME
NUMBER PROPERTY.
112.  Display the divisors of a positive nonzero number x
read from the keyboard.
Example: For x=12, the output is: 1 2 3 4 6 12.
Implementation:

113. 
 
Display the proper divisors of a positive nonzero number
x read from the keyboard.
Example: For x=12, the output will be: 2 3 4 6.

Implementation:

114.  Count the divisors of a positive nonzero number
x read from the keyboard. Based on the result,
determine if the number x is a prime number.
Implementation:

115. 
 
Count the proper divisors of a positive nonzero number x
read from the keyboard. Based on the result, determine
if the number x is a prime number.
Implementation:


116. 
 
Calculate the sum of divisors of a positive nonzero
number x read from the keyboard. Based on the result,
determine if the number x is a prime number.
Implementation:

117.  Two numbers x and y are friends (amicable) if
one of them is equal to the sum of the divisors of the
other. Determine whether two nonzero natural numbers
with at most 9 digits each are friends.
Example: For x=18 and y=39, they are considered
friend numbers because the sum of divisors of x=18
(1+2+3+6+9+18) equals y=39.
Implementation:

118.   
A
number x is perfect if it is equal to the sum of its
divisors, excluding itself.
a. Determine if the given number x is perfect.
Example: For x=6, it's perfect because 1+2+3=6
(divisors of 6).
a. Generate the first n perfect numbers.

Implementation:

119.   
 A
number is superprime if all of its prefixes are prime
numbers. A natural number n with at most 9 digits is
read from the keyboard. Check if this number is a
superprime number. If it is, display its prefixes;
otherwise, display "0".
Example: For n=239, which is a superprime number,
the output would be: 239, 23, 2.
Implementation:


120. 
 
Display the numbers up to the given input n that are
perfect squares of prime numbers.
Example: For n=50, the output would be: 4, 9, 25,
49.

Implementation:

121.   Determine how many digits in a number x,
which is read from the keyboard, represent prime
numbers.
Example: For x=524789, the output would be 3.

Implementation:
122.   Read a real number x from the keyboard. Find
prime integers p and q such that p < x < q and the

difference q –  p is minimized.
Implementation:



123.  Read a natural number n with at most 9 digits from
the keyboard. Verify whether n is a powerful number. A
number is powerful if it has more divisors than any
number smaller than itself.
Example: 
For 
n=12, 
“a 
powerful 
number” 
is
displayed.

Implementation:

3.4 PROCESSING NUMBERS IN THE
INTERVAL [A, B]
124.   Display the prime numbers up to n, where n is a
natural number with at most 4 digits read from the
keyboard.
Implementation:
125.   Display the prime numbers within the interval
[a, b], where a and b are natural numbers with at most 4
digits read from the keyboard.

Implementation:

126.   Display the perfect squares within the interval
[a, b], where a and b are natural numbers with at most 9
digits read from the keyboard. If there are no perfect
squares in the interval [a, b], a corresponding message
will be displayed.
Implementation:

127.   
Display the palindrome numbers within the interval [a,
b], where a and b are natural numbers with at most 9
digits read from the keyboard. If there are no palindrome
numbers in the interval [a, b], a corresponding message
will be displayed.
Example: For a=100 and b=150, the displayed
numbers are 101, 111, 121, 131, 141.

Implementation:

128.   
Display the numbers within the interval [a, b] that are
powers of 2. The numbers a and b are natural numbers
with at most 9 digits read from the keyboard. If the
interval [a, b] does not contain numbers that are powers
of 2, a corresponding message will be displayed.
Example: For a=6 and b=50, the displayed numbers
are 8, 16, 32.
Implementation:


129.   Display the numbers within the interval [a, b]
that are either powers of 2 or powers of 3. The numbers a
and b are natural numbers with at most 9 digits read
from the keyboard. If the interval [a, b] does not contain
numbers that are powers of 2 or 3, a corresponding
message will be displayed.
Example: For a=6 and b=50, the displayed numbers
are 8, 9, 16, 27, 32.

Implementation:
130.   Display the numbers within the interval [a, b]
that contain at least one even digit. The numbers a and b
are natural numbers with at most 9 digits read from the
keyboard.

Implementation:
131.  
Display the numbers within the interval [a, b] that have
an equal number of even and odd digits. The numbers a
and b are natural numbers with at most 9 digits read
from the keyboard.

Implementation:
132.   Display the numbers within the interval [a, b]
that have the same count of digits 0 and 1 when
transcribed to base 2 (binary). The numbers a and b are
natural numbers with at most 9 digits read from the
keyboard.

Implementation:
133.   Display the numbers within the interval [a, b]
that have digits arranged in ascending order. The
numbers a and b are natural numbers with at most 9
digits read from the keyboard.
Implementation:


134.   Display the numbers within the interval [a, b]
that have at least two zeroes. If there are no such
numbers, a message will be displayed.
Implementation:

135.   Display the prime numbers within the interval
[a, b] that have at least one digit equal to the digit x. If
there are no such prime numbers, a message will be
displayed.
Implementation:

136.  
Display the numbers within the interval [a, b] that have a
digit sum that is a prime number. If there are no such
numbers, a message will be displayed.

Implementation:

3.5 PROCESSING N INTEGER
NUMBERS READ FROM THE
KEYBOARD
137.  
 
For
n (n≤100) integer numbers read from the keyboard,
determine:
a. The sum of even values;
b. The last digit of the product of odd values;
c. The arithmetic mean of the read numbers.

Implementation:
138.  
 
For
n (n≤100) integer numbers with at most 4 digits read
from the keyboard, determine:
a. The minimum value read;
b. The maximum value read and the number of times
this value appears in the sequence of read values.
c. The largest even number;

d. The value x with the highest sum of digits. If there
are multiple numbers with the same sum of digits,
display the one with the smallest value.
Implementation:

139.  For n (n≤100) integer numbers with at most 4
digits read from the keyboard, determine:
a. The last perfect square in the sequence of read
values;
b. The first perfect square in the sequence of read
values;
c. The second-to-last perfect square in the sequence of
read values;
d. The third-to-last perfect square in the sequence of
read values;

e. Perform the same calculations for prime numbers and
palindrome numbers.
Implementation:
140.  For n (n≤100) integer numbers x with at most 4
digits each, read from the keyboard, determine:

a. The number of prime numbers in the sequence of
read values;
b. The number of numbers that are powers of 3;
c. The number of numbers whose inverse represents a
prime number.
Implementation:

141.  
For n (n≤100) integer numbers x with at most 4 digits
each, read from the keyboard, determine the number
with the highest number of divisors. In case there are
multiple numbers with the same highest number of
divisors, the one with the smallest value will be
displayed.

Implementation:

142.  Determine whether n (n≤100) integer numbers
read from the keyboard are in ascending order.
Implementation:

143.   Determine whether n (n≤100) integer numbers
read from the keyboard all have the same value.
Implementation:
144.  
Determine if any two consecutive values, of n (n≤100)
integer numbers entered from the keyboard have distinct
values.
Example: For n=5 and the numbers 3, 4, 3, 7, 3,
"YES" is displayed.

For n=5 and the numbers 3, 4, 3, 3, 7, "NO" is
displayed.
Implementation:
145.   Determine the number of pairs of consecutive
numbers read that have equal values. n (n≤100)
integers with at most 4 digits each are read from the
keyboard.
Example: For n=12 and the sequence 3 4 5 5 6 7 7 7
8 8 8 9, the value 5 is displayed.

Implementation:
146.  Read n (n≤100) integers with at most 4 digits
each from the keyboard. Determine how many pairs of
consecutively read numbers have the sum of digits of
the first number equal to the sum of digits of the second
number.
Example: For n=7 and the sequence 45, 334, 1216,
23, 5, 50, 78, the value 3 is obtained.

Implementation:

147.  Read n (n≤100) integers with at most 4 digits
each from the keyboard. Determine how many pairs of
consecutively read numbers have the same number of
even digits.
Implementation:

148.  Read n (n≤100) integers with at most 4 digits
each from the keyboard. Determine how many triplets of
consecutively read numbers have one value equal to the
sum of the other two.
Example: For n=11 and the sequence 3 4 5 9 6 2 8 6
2 1 3, the value 5 is displayed.

Implementation:
149.  
Read n (n≤100) integers with at most 4 digits each from
the keyboard. Determine how many triplets of
consecutively read numbers are Pythagorean (the square

of one value is equal to the sum of the squares of the
other two values).
Implementation:
150.  Read n (n<100) integers with at most 4 digits
each from the keyboard. Determine how many numbers
contain the longest sequence of consecutive even
values.
Example: For n=11 and the sequence 5 3 6 4 12 16
3 1 2 4 3, the value 4 is displayed.

Implementation:
151.  n (n≤100) integer numbers of at most 4 digits
each are read from the keyboard. Determine how many

numbers contain the longest sequence of consecutive
prime values among those read.
Example. For n=11 and the sequence 5 34 61 43 29
19 32 1 2 4 3, the output is the value 4.
Implementation:

152.  
n
(n≤100) integer numbers of at most 4 digits each are
read from the keyboard.
a. Determine how many elements are in the longest
increasing sequence of consecutively read values.
b. If there are multiple such sequences, display the
count of them.

Example. For n=13 and the sequence 4, 5, 8, 2, 9,
10, 22, 11, 1, 2, 4, 8, 3, the output is the values 4 and 2.
Implementation:


3.6 GENERATING THE FIRST N
NUMBERS THAT SATISFY A GIVEN
CONDITION.
153.  Display the first n (n≤100) prime numbers, where
n is read from the keyboard.
Example. For n=7, the output is 2, 3, 5, 7, 11, 13, 17.
Implementation:

154.  Display the first n (n≤100) natural numbers that
have exactly 3 divisors, where n is read from the
keyboard.
Example. For n=5, the output is 4, 9, 25, 49, 121.
Implementation:

155.  Display the first n (n≤100) natural numbers that
are perfect squares, where n is read from the keyboard.
Implementation:

156.  
 Display the first
n (n≤100) natural numbers that, when expressed in
base 2, have an equal number of 0s and 1s.
Implementation:

157.  
Display the first n (n≤100) palindrome numbers with at
least 4 digits, where n is read from the keyboard.
Example. For n=5, the output is 1001, 1111, 1221,
1331, 1441.
Implementation:


158.  
Display the first n (n≤100) natural numbers that contain
at least two zeros.
Implementation:

159.  
Display the first n (n≤100) natural numbers that have an
equal count of even and odd digits.
Implementation:

160.  
Display the first n (n≤100) natural numbers whose
digits' sum is equal to a given input S.

Implementation:

161.  
Display the first n (n≤100) numbers that have the same
count of digits equal to digit a and digit b, where a and b
are read from the keyboard.
Example. For a=2 and b=4, the number 248462 is
such a number.

Implementation:

162.  
Generate all 4-digit numbers that are palindrome
numbers and have a digit sum equal to a given number
S.
Implementation:

163.  
 Generate all
5-digit numbers that are palindrome numbers and consist
only of even digits.
Implementation:

164.  Generate the first n numbers consisting of 5
digits that are palindrome numbers and consist only of
even digits. If there are no n such numbers, a message
will be displayed.
Implementation:
165.  Generate all 5-digit numbers whose sum of the
first two digits is equal to S1 and the sum of the last two
digits is equal to S2.

Implementation:
166.  Generate the palindrome numbers with exactly 6
digits that contain digits that appear no more than 2
times.

Implementation:

167.  Generate all numbers composed of 4 digits in
strictly ascending order.
Implementation:
168.  
 Generate all
numbers composed of 4 digits in strictly ascending order
and that do not contain more than one odd digit.

Implementation:


169.  Generate the first n numbers composed of 4
digits for which the first two digits form a prime number
and the last two digits form a perfect square.
Implementation:
170.  Generate the first n numbers with equal digits.
Example. For n=14, the generated sequence is: 0, 1,
2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44.
Implementation:


3.7 GENERATING THE FIRST N
PAIRS OF NUMBERS (A, B) THAT
SATISFY A GIVEN CONDITION.
171.  
 Display the
first n (n≤100) pairs of consecutive prime numbers,
where n is read from the keyboard.
Example. For n=5, the output is: 2 3, 3 5, 5 7, 7
11, 11 13.

Implementation:

172.  Display the first n (n≤100) pairs of consecutive
natural numbers for which the sum of the digits of the
two numbers is equal to a given x.
Example. For x=17, such a pair is 125, 126.
Implementation:

173.  Display the first n (n≤100) pairs of
consecutive natural numbers whose sum is a prime
number.
Example. For n=5, the generated pairs are 2 3, 3
4, 5 6, 6 7, 8 9.
Implementation:

174.  
 Two
numbers m and n are called amicable numbers if the
sum of the divisors of m (excluding m itself) is equal
to n and vice versa. For example, m=220 and n=284
are amicable because m=1+2+71+142 (sum of
divisors of 284) and n=1+2+4+5+104+110 (sum of
divisors of 220). Generate the first n pairs of amicable
numbers.
Implementation:


3.8 GENERATING THE NEAREST
NUMBER X TO A GIVEN N
(NUMBER X SATISFIES A
SPECIFIED CONDITION).
175.  Display the largest prime number x that is
strictly smaller than the input number n.
Example. For n=22, the result is 19.
For n=19, the result is 17.
Implementation:

176.  Display the smallest number x greater than or
equal to the input number n, where x is a perfect
square multiple of 3.
Example. For n=40, the result is 81.
Implementation:

177.  
 Display the
nearest prime number x to the input number n.
Example. For n=22, the result is 23.
For n=19, the result is 19.
Implementation:

178.  Display the smallest number x greater than or
equal to the input number n, where x has all digits
equal.
Example. For n=347, the result is 444.
For n=312, the result is 333.
Implementation:

179.  
 Display the
largest prime number x that is strictly smaller than the
input number n.
Example. For n=22, the result is 19.

Implementation:

180.  
Display
the smallest palindrome number x greater than or
equal to the input number n.
Example. For n=347, the result is 353.
Implementation:

181.  
 Display
the smallest perfect number x greater than or equal to
the input number n. A number is perfect if it is equal
to the sum of its divisors (excluding itself).
Example. For n=3, the result is 6. (6=1+2+3)
Implementation:

182.  
 Display
the nearest number x to the input number n that has
the same count of even and odd digits.

Implementation:

183.  
 Display
the smallest number x greater than or equal to the
input number n, where the sum of its digits is equal to
a given number S.
Example. For n=273 and S=15, the result is
x=276.
Implementation:

184.  Display the smallest number x greater than or
equal to the input number n, where the digits are in
ascending order.
Example. For n=273, the result is 277.
For n=219, the result is 222.
Implementation:

3.9 DECOMPOSING A NUMBER
INTO THE SUM/PRODUCT OF TWO
OR THREE TERMS THAT SATISFY A
CONDITION.
185.  
 Let n be a
natural number with at most 4 digits read from the
keyboard.
a. Decompose n into a sum of two numbers.
Example. For n=7, 1+6, 2+5, 3+4, etc.
a. Decompose n into a sum of three numbers.

Example. For n=10, 1+1+8, 1+2+7, 1+3+6, 1+4+5,
etc.
Implementation:

186.  Let n be a natural number with at most 4
digits read from the keyboard.
a. Decompose n into a sum of two prime numbers.
b. Decompose n into a sum of three prime numbers.
Implementation:
187.  Let n be a natural number with at most 9
digits read from the keyboard. Write n as the sum of
two perfect squares. If there is no solution, display a
message.

Example. For n=89, the result is 25+64.
Implementation:
188.  Let n be a natural number with at most 4
digits read from the keyboard. Express the number n as
the product of two numbers. Display all possibilities.
Implementation:

189.  A number is called almost prime if it can be
expressed as the product of two prime numbers.
Determine whether a natural number n with at most 4
digits, read from the keyboard, is almost prime.
Express n as the obtained product if applicable.
Example. For n=65, it is almost prime as it can be
expressed as the product 5x13.
Implementation:
190.  Determine whether the natural number x with
at most 4 digits, read from the keyboard, can be

expressed as the product of 3 numbers. Display all
possibilities.
Implementation:
191.  Determine whether the natural number x with
at most 4 digits, read from the keyboard, can be
expressed as the sum of 3 numbers that have the same
count of digits when represented in binary.
Example. For x=11, it can be written as 5+6, which
in binary is 101 and 110 (they have the same count of
digits).

Implementation:

3.10 FIBONACCI SEQUENCE
The Fibonacci sequence is a recursive sequence
defined as follows:
For example, for n=10, the first n terms of the
Fibonacci sequence are:
1, 1, 2, 3, 5, 8, 13, 21, 34, 55, ... 
192.  Display the first n terms of the Fibonacci
sequence, where n is a natural number read from the
keyboard.
Implementation:

193.  
 Display
the nth term of the Fibonacci sequence, where n is a
natural number read from the keyboard.
Implementation:

194.  
Display
the terms of the Fibonacci sequence that are smaller
than n, where n is a natural number read from the
keyboard.
Example. For n=20, the output is 1, 1, 2, 3, 5, 8,
13.
Implementation:

195.  Determine whether n, a natural number read
from the keyboard, is a term in the Fibonacci
sequence. Display Yes or No.
Example. For n=13, the output is Yes.
For n=15, the output is No.
Solution: A number k belongs to the Fibonacci
sequence if and only if one or both of the relationships
(5*n2 + 4) or (5*n2 – 4) is a perfect square.
Implementation:

196.  Display the nearest term in the Fibonacci
sequence to a given number n.
Example. For n=18, the output is the value 21.
Implementation:

3.11 EVALUATING EXPRESSIONS
For n (n≤100), a natural number read from the
keyboard, determine the value of the following
expressions:
197.  1*2*3*...*n.
Implementation:

198.  1+1*2+1*2*3+1*2*3*4+...+1*2*3*4*...*n.
Implementation:

199.  1*(1+2)*(1+2+3)*(1+2+3+4)*...*
(1+2+3+...+n).
Implementation:
200.  
1-
1*2+1*2*3-1*2*3*4+...±1*2*3*4*...n.
Implementation:

201.  
12+22+32+...n2.
Implementation:
202.  1-22+32-42+...±n2.
Implementation:


203.  1*2-2*3+3*4-4*5+...±n*(n+1).
Implementation:

204.  1*2*3+2*3*4+3*4*5+...+n*(n+1)*(n+2).
Implementation:

205.  1+3+5+7+...
Implementation:

206.  1*4*7*10*...
Implementation:

207.  2*4*6*8*...
Implementation:

208.  1/2+2/3+3/4+...+n/(n+1).
Implementation:

209.  (1+2)*(2+3)*(3+4)*...*(n+n+1).
Implementation:

210.  (1+22)+(2+32)+...+[n+(n+1)2].
Implementation:


3.12 PATTERNS DISPLAY
PROBLEMS
For n (n≤100) natural number read from the
keyboard, display:
211.  The given pattern as a pyramid sequence of
the type:
1
1 2
1 2 3
.......
1 2 3 ... n
Implementation:

212.  The given pattern as a pyramid sequence of
the type:
1
2 1
3 2 1
.......
n n-1 ... 3 2 1
Implementation:


213.  The given pattern as a pyramid sequence of
the type:
1
2 2
3 3 3
.......
n n n ... n (n times)
Implementation:

214.  The given pattern as a pyramid sequence of
the type:
n
n n-1
n n-1 n-2
.......
n n-1 n-2 ... 3 2 1
Implementation:

215.  The values from 1 to n as in the example:
For n=12
1
2 3
4 5 6
7 8 9 10
11 12
Implementation:

216.  A pyramidal sequence like in the following
example. The number of lines, n, is read from the
keyboard.
For n=4, the result is:
1
1 2 3
1 2 3 4 5
1 2 3 4 5 6 7
Implementation:

217.  A pyramidal sequence like in the following
example. The number of letters, n (n≤26), is read
from the keyboard.
For n=4, the result is:
A
BB
CCC
DDDD

Implementation: 

218.  A pyramidal sequence that displays the
character '*' as in the following example. The number
of levels, n, is read from the keyboard
For n=3, the result is:
*
**
***
Implementation:


219.  A pyramidal sequence that displays the
character '*' as in the following example. The number
of levels, n, is read from the keyboard.
For n=4, the result is:
*
***
*****
***
*
Implementation:

220.  Display the digits of a number n that contains
at most 9 non-zero digits on different rows, where
each digit will be displayed a number of times equal to
its value.
Example: For n=5362, it will be displayed:
22
666666
333
55555
Implementation:

221.  Display a sequence of 'squares' as in the
following example. The number of squares, n (n≤9), is
read from the keyboard.
For n=3, the result is:
111
111
111
222
222
222
333
333
333
Implementation:

222.  
 Display the
'multiplication table' up to n (n≤100) as read. Only
the multiplications with single-digit numbers will be
displayed.
Implementation:

CHAPTER 4 – ONE-DIMENSIONAL
ARRAYS
4.1 Iterating with Processing of Elements
4.2 Sequential/Linear Search
4.3 Insertion of a New Component
4.4 Deletion of a Component
4.5 Sorting of Components
4.6 Binary Search
4.7 Changing the Order of Components According to
Various Criteria
4.8 Merging of Two Vectors
4.9 Set Operations
4.10 Processing All Pairs or Triplets That Satisfy a
Given Condition
4.11 Processing Sequences of Adjacent Values
4.12 Computation of Expressions
4.13 Generation Problems
4.14 Operations with Large Numbers
4.15 Processing Numbers in Different Numeral
Systems
4.16 Frequency Vectors

A one-dimensional array is
declared in C++ as follows:
We can imagine the declared array above in the
following way (the values of the elements are random):

We say that each element has an index. The indices
of an array are between 0 and Size-1, so in our
example between 0 and 9.
Any C++ array physically has elements indexed
from 0 to Size-1. For example, if we need an array with
n ≤ 100 integer elements, we will declare it:
int V[100];
And the elements will have indices between 0 and
99. Thus, the first element of the array is V[0], the
second is V[1], ..., the last one is V[n-1].
If desired, we can ignore the element V[0] (simply
not use it, although it still exists), and then all
operations (reading, displaying, traversal) will use the
elements V[1] (first element), V[2] (second element),
..., V[n] (last element).
It is also important to handle the array declaration
carefully, where the physical size must be one greater
than the value specified in the problem. For example, if
n≤100, the declaration will be:
int V[101];
Applications:

4.1  ITERATING WITH PROCESSING
OF ELEMENTS.
223.  The elements of a one-dimensional array with n
(n≤100) components are read, integers up to 4 digits
each. Calculate the arithmetic mean of the array
components.
Implementation:

224.  The elements of a one-dimensional array with n
(n≤100) components are read, integers up to 4 digits
each. Determine the minimum and maximum values.
Implementation:

225.  The elements of a one-dimensional array with n
(n≤100) components, integers up to 4 digits each, are
read. Display the value of the component with the
maximum number of divisors. In case there are multiple
components with the same maximum number of
divisors, display the one with the smallest value.
Example: For v=(10, 49, 35, 25, 6, 3), the output is
6.
Implementation:
226.  The elements of a one-dimensional array with n
(n≤100) components, integers up to 4 digits each, are

read. Determine the maximum value and how many
times it appears in the array.
Implementation:

227.  
 The
elements of a one-dimensional array with n (n≤100)
components, integers up to 4 digits each, are read.
Check if the array is sorted (in ascending or descending
order).
Implementation:

228.  The elements of a one-dimensional array with n
(n≤100) components, integers up to 4 digits each, are
read. Perform the following processing:
a. Display and count the even elements at odd
positions in the vector.
b. Count the positive and even elements.
c. Calculate the product of the negative elements.
d. Calculate the arithmetic mean of the positive
elements.
Implementation:

229.  
The elements of a one-dimensional array v with n
(n≤100) components are read, where each element is
an integer with at most 4 digits. Determine if any two
adjacent elements in the array have different parity.
Display Yes or No.
Example: For n=5 and v=(3, 6, 1, 18, 13), Yes is
displayed.

Implementation:
230.  The elements of a one-dimensional array v with
n (n≤100) components are read, where each element is
an integer with at most 4 digits. Determine if any two
adjacent elements in the array have different signs.
Display Yes or No.
Example: For n=5 and v=(3, -6, 1, -8, 13), "Yes" is
displayed.
Implementation:

231.  
 The
elements of a one-dimensional array v with n (n≤100)
components are read, where each element is an integer
with at most 4 digits. Perform the following processing:
a. Display the prime values.
b. Display the prime numbers for which their inverse is
also a prime number.

Implementation:

232.  
 The
elements of two one-dimensional arrays, a and b, with
m and n (m, n≤100) components, respectively, are
read. These elements are integers with at most 4 digits
each. Determine how many elements from array a are
strictly less than all elements in array b.

Implementation:
233.  The elements of a one-dimensional array v with
n (n≤100) components, consisting of integer numbers
with at most 4 digits each, are read. Determine the
element with the ordinal number k from the array when
it's sorted in ascending order, without actually sorting
the array.
Example: For n=8, k=4, and v=(3, -6, 1, 0, 2, 6, -8,
13), the output is 0.

Implementation:

234.  The elements of a one-dimensional array v with
n (n≤100) components, consisting of integer numbers
with at most 4 digits each, are read. Determine the
position of the first element in the array after sorting it
in ascending order, without actually sorting the array.
Example: For n=8 and v=(3, -6, 1, 0, 2, 6, -8, 13),
the output is 6.
Implementation:
235.  The elements of a one-dimensional array v with
n (n≤100) components, consisting of integer numbers
with at most 4 digits each, are read. Count how many
elements are equal to the arithmetic mean of their
neighbors.
Implementation:

236.  Check if the elements of an array of n (n≤100)
integers can form:
a. an arithmetic progression;
b. a geometric progression. If the sequence is a
progression, display the the common ratio.
Implementation:

237.  
Determine whether a one-dimensional array of integers
has all equal elements. Display Yes or No.

Implementation:

238.  The elements of a one-dimensional array with at
most n integer components (n≤100) sorted in
ascending order are read from the keyboard. Display
each value and its frequency in the array.
Implementation:

239.  Write a program that reads a natural number n
from the keyboard within the range  [2, 10000], and
then reads n real numbers. The program should display
how many of these n real numbers are equal to the
arithmetic mean of the other n-1 real numbers.
Solution: A simple method to solve the problem is to
consider that the sum of the other n-1 numbers will
always be the sum of all elements excluding the one
being considered. We will calculate the total sum, then
iterate through the vector element by element and
check whether the number is equal to the arithmetic
mean of the others.
Implementation:

240.  Write a program that reads a natural number n
from the keyboard within the range   [2, 10000], and
then reads n integers. The program should display "YES"
if all odd numbers are in ascending order and all even
numbers are in descending order. Otherwise, it should
display "NO".
Example: For n=10 and v=(1, 10, 5, 8, 7, 9, 9, 6, 6,
2), the program should display YES.
Implementation:

241.  
Given an array with n positive real numbers (1≤n≤100)
sorted in ascending order. Write a program that
determines the minimum number of closed intervals of
the form [x,x+1], where x is a natural number, whose
union includes all the real numbers from the array.
Example: If the array contains: 2.3, 2.8, 5.1, 5.7, 5.9,
6.3, then the program should display 3 (the intervals
[2;3], [5;6], [6;7] are the 3 required intervals that
encompass numbers from the array).

Implementation:
242.  Write a program that reads two integer
numbers a and b, each with at most four digits, a
natural number n from the range [2, 10000], and then
reads n integer numbers, each with at most four digits.
The program should display on the screen those
numbers whose value is within the interval [a, b].
Implementation:

243.  
 Read a non-
zero natural number n (n≤100) from the keyboard,
followed by n non-zero integer numbers, each with a
maximum of 4 digits, representing the elements of a
one-dimensional array v. Write a program that displays
how many of the array's elements can be written as the
sum of the two adjacent elements. If there are no such
elements, the program should display the value 0.
Example: If the array contains the following
elements: 2 7 5 1 4 2 -2 5, the program should display 2.
Implementation:

244.  Elements of a one-dimensional array with n
(n≤100) real numbers, each with a maximum of six
decimal places, are being read from the keyboard. A
natural number x (x<6) is given. Determine how many
of the read numbers have more than x decimal places.
Implementation:

245.  
The elements
of a one-dimensional array with n (n≤100) integer
numbers, each with at most four digits, are being read
from the keyboard. Display the adjacent pairs of
elements whose sum has the highest value.
Implementation:

246.  Double the values equal to the minimum value
in a one-dimensional array with n (n≤100) integer
numbers, each with at most four digits, read from the
keyboard, and display the new array onto the screen.
Implementation:

247.  
 The elements of
a one-dimensional array a with n (n≤100) integer
numbers, each with at most four digits, are being read.
Generate array b in which each component stores the
first digit of the element from the same position in array
a.
Example: If a=(345, 61, 8, 900), then b=(3, 6, 8, 9).
Implementation:

248.  The elements of a one-dimensional array a with
n (n≤100) integer numbers, each with at most four
digits, are being read. Generate array b in which each
component stores the largest digit of the element from
the same position in array a.
Example: If a=(3485, 61, 182, 900), then b=(8, 6, 8,
9).
Implementation:

249.  
 The
elements of a one-dimensional array a with
n (n≤100) integer numbers, each with at
most four digits, are being read. Generate
array b in which each component stores the
number of divisors of the element from the
same position in array a.
Example: If a=(10, 49, 13, 12), then b=
(4, 3, 2, 6).
Implementation:

250.  The elements of a one-dimensional array a with
n (n≤100) integer numbers, each with at most four
digits, are being read. Generate array b in which each
component stores the number of digits of the element
from the same position in array a.
Example: If a=(345, 61, 8, 900), then b=(3, 2,  1, 3).
Implementation:

251.  
 The Key. In
order to breach the security system of a computer, a
hacker needs to write a program that will "crack" a
number n of security levels. A security level is
understood as a sequence of indexed numbers
containing the key to the next level. The number of
values in a security level is equal to the value of the key
found in the previous level. For the hacker's program to
find the key for the next security level, it must traverse
the entire sequence of numbers from the current level,
starting with an index value of one. The program then
advances within the same security level to the element
whose index is obtained by repeatedly adding the value
of the current element to the index held by that value.
The last traversed value from the current security level
is the key to access the next level. Knowing these
details, the hacker understands that they cannot reach
the final key, necessary to breach the security system,
without knowing the initial key and the number of
security levels. Therefore, the hacker further
investigated and managed to find these two values.

Task: Write a program that traverses the n security
levels and obtains the final key.
Input: The first line of the file KEY.IN will contain 2
natural numbers: n (representing the number of security
levels) 1≤n≤40 and k (representing the initial key of the
first security level) 2≤k≤40. The second line of the file
will contain the natural numbers from the n security
levels (the numbers will be within the interval [-40, 40] \
{0}).
Output: The first line of the file will display a single
number k, representing the key of the last security level.
Examples:
key.in     key.out
3 5     10
2 2 2 4 -3 3 1 4 -2 1 2 10 -1
Explanation:
The number of levels is 3. The initial key is 5, so
the first security level will be: 2 2 2 4 -3, traversing as
follows:
Security Level 2: 3 1 4 -2. The key is 4, so level 3 will
be 1 2 10 -1. By traversing the last level, the final key

will be obtained, namely: 10.
Implementation:


4.2 SEQUENTIAL/LINEAR SEARCH
252.  Let A be a set with n elements (n ≤ 100).
Determine whether the value x belongs to the set A.
Display YES or NO.
Implementation :

253.  Let v be a one-dimensional array with n
integers (n ≤ 100). Replace all values equal to the
minimum value with the maximum value in the array.
Implementation:

254.  The elements of a one-dimensional array with
n (n≤100) integers, each having at most four digits,
and an integer x are read. Determine the arithmetic
mean of the array elements that are different from x.
Implementation:

255.  Let v be a one-dimensional array with n integers
(n≤100). Determine how many of the array elements
are equal to the first or last value in the array.
Implementation:
256.  Let v be a one-dimensional array with n integers
(n≤100). Display the indices of the elements that are
equal to the second element in the array.
Implementation:


4.3 INSERTION OF A NEW
COMPONENT
257.  Let v be a one-dimensional array with n integers
(n≤100). Insert the value x at position p (p≤n),
where n, v, x, and p are read from the keyboard.
Implementation :

258.  The elements of a one-dimensional array with
n (n≤100) integers, each having at most four digits,
are read. Insert between any two elements the sum of
those elements.
Implementation :

259.  The elements of a one-dimensional array with
n (n≤100) integers, each having at most four digits,
are read. After each odd number in the array, insert its
double.
Implementation:

260.  The elements of a one-dimensional array with
n (n≤100) integers, each having at most four digits,
are read. After each even number in the array, insert
its reverse.
Implementation:

261.  The elements of a one-dimensional array v
with n (n≤100) integers, each having at most four
digits, are read. After each value equal to 0 in the
array, insert the values 1, 2, and 3.
Example: If v=(5, 0, 4, 0, 0, 7), the result will be:
v=(5, 0, 1, 2, 3, 4, 0, 1, 2, 3, 0, 1, 2, 3, 7).
Implementation:

262.  The elements of two one-dimensional arrays v
and w with m and n components respectively
(m,n≤100), each containing integers with at most
four digits, are read. Insert the values of array w
before the element at index p in array v.
Example: If v=(3,4,1,5,7), w=(8,9,10,11), p=4, the
result will be: v=(3,4,1,8,9,10,11,5,7).
Implementation:

263.  The elements of a one-dimensional array v
with n (n≤100) integers, each having at most four
digits, and a natural number x (x≤9) are read. Insert
between any two consecutive elements vi and vi+1
with a difference less than x, the values from vi to vi+1.
Example: If v=(8, 43, 1, 5, 128, 33, 29), x=7, the
result will be v=(8, 43, 1, 2, 3, 4, 5, 128, 33, 32, 31,
30, 29).
Implementation:


4.4 DELETION OF A NEW
COMPONENT
264.  Let v be a one-dimensional array with n integers
(n≤100). Remove the value at position p.
Implementation:

265.  Remove the value x from a one-dimensional
array v containing n distinct integers (n≤100).
Implementation:

266.  Remove all values equal to x from a one-
dimensional array v with n integers (n≤100).
Implementation:


267.  Let v be a one-dimensional array with n
integers (n≤100). Move the zeros to the end of the
array without changing the order of the non-zero
elements.

Implementation:

268.  Let v be a one-dimensional array with n
integers (n≤100). Remove the even values from the
array.
Implementation:

269.  Let v be a one-dimensional array with n
integers (n≤100). Remove the values from the array
that are not prime numbers.
Implementation:


270.  n (n≤100) integers are placed on the
circumference of a circle, so that the n-th number ends
up next to the first number. Starting with the number
at position p, the numbers are removed from k to k,
after each removal, the circle narrowing down. What
will be the remaining number?
Implementation:

271.  The elements of a one-dimensional array v
with n (n≤100) integers, each having at most four
digits, are being read. Remove elements from the
array in such a way that any two adjacent components
have different values.
Example: for v = (3, 4, 4, 4, 3, 3, 2, 6), the result
will be a = (3, 4, 3, 2, 6).
Implementation:

272.  
 The
elements of a one-dimensional array v with n
(n≤100) integers, each having at most four digits, are
being read. Remove elements from the array in such a
way that any two adjacent components have different
parity (one is even and the next is odd, or vice versa).
Example: for v = (3, 4, 6, 4, 3, 3, 2, 6, 1), the
result will be a = (3, 4, 3, 2, 1).

Implementation:

273.  The elements of a one-dimensional array with
n (n≤100) integers, each having at most four digits
and arranged in ascending order, are being read.
Remove duplicates from the array so that each value
appears only once.
Example: for v = (2, 3, 3, 3, 4, 7, 7, 8, 10), the
result will be v = (2, 3, 4, 7, 8, 10).
Implementation:

274.  Let v be a one-dimensional array with n integers
(n≤100). Remove values from the array in a way that
the sum of its components does not exceed a given
value S, while maximizing the number of remaining
components.
Implementation:

275.  It is said that long ago, in the region of the
Getae-Dacians, there existed a boy named Deceneu.
Over time, due to his great intelligence, he was named
by Burebista as the wise one of the Dacians. As time
passed, he solved various problems that Burebista
encountered. Thus, Burebista devised a method to
eliminate their enemy leader with a single thrown
spear. To achieve this, he only needed to determine
the leader's position. Burebista learned from Deceneu
that each enemy was associated with a digit and an
ordinal number, and to find the leader, they had to
traverse the sequence of enemies and eliminate them
one by one, moving from left to right in steps of p
fighters until only one remains. If they reached the end
of the sequence of fighters, the counting continued by
moving in the opposite direction from right to left, and
so on.
Task: Determine the digit associated with the
enemy leader and their ordinal number in the initial
sequence.
Input: In the file asd.in:
The first line contains the step p as described in
the problem.

The following line consists of n digits representing
the number of enemies. There are no spaces
between digits.
Output: The first line of the file asd.out should
contain the digit corresponding to the enemy tribe
leader and their ordinal number.
Constraints and Notes:
1 < p < 1000
The number of digits is greater than 15,000 and
less than 25,000.
Example 1:
Input asd.in:   Output asd.out:
3     8 1
82345
Explanation:
82345 – Starting from 8 and moving to the right,
the 3rd digit is eliminated. Resulting in 8245. 8245 –
From 4 to the right, it reaches the last digit (5), then
the direction is changed, and the 3rd digit is 4, which
is eliminated. Resulting in 825.

825 – Starting from 2 and moving to the left, the
first digit (8) is reached, and the direction changes.
The 3rd digit is 2. Resulting in 85.
85 – Continuing from 5, changing direction (since
it's the last digit), the first digit (8) is reached again.
Changing direction, the 3rd digit is 5, which is
eliminated. The remaining digit is 8. It has the ordinal
number 1 in the initial sequence.
Example 2:
Input asd.in:   Output asd.out
4     7 2
17438  
Note: The first digit from the left has the ordinal
number 1, the second digit has the ordinal number 2,
and so on.
Implementation:

4.5 SORTING OF COMPONENTS
The elements of a one-dimensional array with n
(n≤100) integers, each having at most four digits, are
being read. Perform the following processing:
276.  
 Sort
the elements of the array in ascending order.
Solution: In programming, there are several sorting
algorithms, such as Selection Sort, Bubble Sort,

QuickSort (Divide and Conquer), MergeSort, etc. We will
solve the problem using the Selection Sort algorithm.
Implementation:

277.  
 Sort the
elements at even positions in ascending order and the
elements at odd positions in descending order.

Implementation:

278.  Sort the first half in ascending order and the
second half in descending order.
Implementation:

279.  Sort the elements of the array in ascending
order based on the last digit.
Implementation:

280.  
Sort
the elements of the array in ascending order based on
the first digit.

Implementation:
281.  Display the even elements in ascending order
and the odd elements in descending order.

Implementation:

282.  Write a program that reads from the keyboard a
non-zero natural number n (n≤100), and then n non-
zero natural numbers, each with a maximum of 4 digits,
representing the elements of a one-dimensional array.
The program displays the message "Yes" if the array
elements represent a permutation of the set (1, 2, 3, ...,
n), and "No" otherwise.
Implementation:

4.6 BINARY SEARCH
283.  The elements of a one-dimensional array with n
(n≤100) integers, each with at most four digits,
sorted in ascending order, are read. Determine if the
value x read from the keyboard is present in the array.
If affirmative, display a position at which it is found;
otherwise, display a message.
Implementation :


284.  The elements of a one-dimensional array with
n (n≤100) integers, each with at most four digits,
sorted in ascending order, are read. Determine
whether the value x read from the keyboard is present
in the array. If it is present, display the smallest index
at which it is found in the array; otherwise, display a
message.
Implementation:

285.  The elements of two one-dimensional arrays,
v and w, with m (m≤100) and n (n≤100) integer
components each, with a maximum of four digits,
sorted in strictly ascending order, are read. Display the
common elements of the two arrays.
Implementation:


4.7 CHANGING THE ORDER OF
COMPONENTS ACCORDING TO
VARIOUS CRITERIA.
286.  The elements of a one-dimensional array with n
(n≤100) integers, each with at most four digits, are
read. Reverse the order of the components so that the
first element becomes the last, the second becomes
the second-to-last, and so on.
Implementation:

287.  
 Circular left
permutation.
a. Rearrange the components of an array of integers
so that the first element becomes the last, and all
other components shift one position to the left.
Example: If n=6, v=(2,4,5,7,8,9), the result is: v=
(4,5,7,8,9,2)
a. Display the components of the array after k
circular left permutations.
Example: If n=6, v=(2,4,5,7,8,9), k=3, the result
is: v=(7,8,9,2,4,5).

Implementation:

288.  Circular right permutation.
a. Rearrange the components of an array of integers
so that the last element becomes the first, and all
other components shift one position to the right.
Example: If n=6, v=(2,4,5,7,8,9), the result is: v=
(9,2,4,5,7,8).
a. Display the components of the array after k circular
right permutations.
Example: If n=6, v=(2,4,5,7,8,9), k=3, the result
is: v=(7,8,9,2,4,5).
Implementation:


289.  Move all zero elements to the end of an array
(without using deletion sequences).
Implementation:

290.  Rearrange the elements of a one-dimensional
array of integers so that even values are at the
beginning, followed by odd values at the end.
Implementation:

291.  Rearrange the elements of a one-dimensional
array of integers so that even values are at the
beginning in ascending order, followed by odd values
at the end in descending order.

Implementation:

292.  Rearrange the elements of a one-dimensional
array of integers so that the prime numbers are placed
at the beginning in ascending order, and the non-
prime numbers are grouped at the end in descending
order.
Implementation:


293.  Rearrange the elements of a one-dimensional
array of real numbers so that the real values come
first, followed by the integers.
Example: For n=7 and v=(7, 3, 4.21, 4, 10, 56.23,
0.9), a possible solution is: v=(4.21, 56.23, 0.9, 7, 3, 4,
10)
Implementation:

294.  Write a program that reads a non-zero natural
number n (n ≤ 100) from the keyboard, followed by n
natural numbers representing the elements of a one-
dimensional array. The program should display on the
screen all left-circular permutations of the array
elements. The elements of each permutation should
be displayed on separate lines, separated by a space.
Example: If n=4 and the one-dimensional array
contains the following elements:
10 20 30 49,
then the program should display:
10 20 30 49
20 30 49 10
30 49 10 20
49 10 20 30
Implementation:


4.8 MERGING OF TWO ARRAYS
295.  Consider two one-dimensional arrays, a and b,
each containing natural numbers with at most 4 digits,
sorted in ascending order. Array a contains n (1 < n <
100) even numbers, and array b contains m (1 < m <
100) odd numbers. Write a program that reads from
the keyboard the value of n and the n elements of
array a, then the value of m and the m elements of
array b. After that, write into the file named data.txt
the maximum number of elements from the given
arrays. The numbers should be written in ascending
order, separated by a space, and consecutive numbers
should have different parity.
Example: For n=6, m=5 and the arrays:
a=(2,4,8,10,14,16) and b=(3,5,7,11,15),
the data.txt file will have the following content: 2 3 4 5
8 11 14 15 16.
Implementation:

296.  
 Consider two
one-dimensional arrays, a and b, each containing
natural numbers with at most 4 digits. Each of these
arrays contains at most 100 values, sorted in strictly
ascending order. Display on the screen, in ascending
order, the numbers divisible by 5 that are found in
only one of the two arrays.
Example: For a=(1 2 3 4 7 20 60) and b=(3 5 7 8 9
10 12 20 24),
the values displayed on the screen will be: 5 10 60.
Implementation:



297.  Consider two one-dimensional arrays, a and
b, each containing at most 100 natural numbers with
at most 4 digits, sorted in strictly ascending order.
Display on the screen, in ascending order, the
numbers that are found in only one of the two arrays.
Example: For a=(1 2 3 4 7 20 24 60), and b=(1 3 4
7 8 9 10 20 24),
the values displayed on the screen will be: 2 8 9 10 60.
Implementation:


298.  Consider two one-dimensional arrays, a and
b, each containing at most 100 natural numbers with
at most 4 digits, sorted in strictly ascending order.
Display on the screen, in ascending order, the
numbers that are found in both arrays.
Example: For a=(1 2 3 4 7 20 24 60), and b=(1 3 4
7 8 9 10 20 24),
the values displayed on the screen will be: 1 3 4 7 20
24.
Implementation:

299.  
 Consider two
one-dimensional arrays, a and b, each containing at
most 100 natural numbers with at most 4 digits,
sorted in strictly ascending order. Display on the
screen, in ascending order, the prime numbers from
both arrays.
Example: For a=(1 2 3 4 7 20 24 60), and b=(1 3 4
7 8 9 10 20 24),
the values displayed on the screen will be: 2 3 3 7 7.

Implementation:

4.9 SET OPERATIONS
300.  
Integer values are
read until m distinct values are stored, respectively n
distinct values in the one-dimensional arrays a and b,
which represent two sets. Perform the following
operations:
a. Generate an array c that stores the intersection of
the two sets.
b. Generate an array da_b that stores the difference
of the two sets (a-b).
c. Generate an array e that stores the union of the
two sets.
Implementation:



301.  From the file data.in, n sets are read as
follows: the first line stores the number n (n≤100) of
sets. On the next n lines, each line stores a value p
(p≤200), followed by p integers of at most 5 digits
each, representing the components of a set. Generate
an array c that stores the intersection of the n sets.
Implementation:

4.10  PROCESSING ALL PAIRS OR
TRIPLETS THAT SATISFY A GIVEN
CONDITION.
The elements of a one-dimensional array with n (n≤100)
integers of up to four digits are read. Perform the
following operations:
302.  Determine if the elements of the array are
distinct.
Implementation:


303.  Determine how many pairs within the array are
prime to each other.
Implementation:

304.  Determine how many pairs in the array have
equal values.
Implementation:

305.  Determine how many pairs in the array have a
sum that is a prime number with the units digit equal to
3.
Implementation:


306.  Determine how many triplets in the array have
equal values.
Implementation:

307.  Determine how many triplets in the array have
the property that one of the values is equal to the sum of
the other two.
Implementation:

308.  Display each value from the array only once
along with its frequency in the array.
Implementation:
309.  Display the triplets whose sum is equal to the
given value s.
Example: For v=(3,5,1,2,4) and s=10. The triplets are
displayed, not necessarily in this order:
3, 5, 2
5, 1, 4

Implementation:
310.  The file intervals.txt contains on the first line a
nonzero natural number n (n≤1000), and on each of the
following n lines, two integer numbers a and b
(1≤a<b≤32000), each pair representing a closed
interval of the form [a, b]. Write a program that
determines the intervals which have the property that
their intersection with any of the other n-1 intervals is
empty, and displays on each line of the screen, separated
by a space, the numbers representing the endpoints of
the determined intervals.
Example: If the file intervals.txt contains the following
content:
4    the program will display on the screen:
17 20    2 6

2 6     17 20
10 15
8 16
Solution: We will construct two arrays, a[n] which will
contain the lower limits of the intervals (as in our
example: 17, 2, 10, 8) and b[n] which will contain all the
upper limits of the intervals (as in our example: 20, 6,
15, 16).
An interval does not intersect with others if both its
endpoints are smaller than the start of an interval OR if
both endpoints are larger than the end of an interval.
Additionally, we will use a characteristic array, indicator,
which will only contain values of 1 (assuming that the
read intervals do not intersect). If intervals intersect, we
will overwrite the value '0' in the indicator array.
Finally, we will display all intervals that have the value
1 in the indicator array.

Implementation:

4.11  PROCESSING SEQUENCES
OF ADJACENT VALUES
The elements of a one-dimensional array with n
(n≤100) integers, each having at most four digits, are
read. Perform the following processing steps:
311.  Determine the number of elements in the
longest sequence of adjacent values in the array that
are sorted in ascending order.
Implementation:

312.  Determine the number of elements in the
longest sequence of adjacent equal values in the array.
In case there are multiple sequences of maximum
length, display their count.
Implementation:

313.  
Determine the number of elements in the longest
sequence of adjacent values in the array that have
exactly 2 digits. In case there are multiple sequences
of maximum length that are in descending order, the
first one will be displayed.

Implementation:

314.  
Determine the number of elements in the longest
sequence of consecutive even numbers in the array. In
case there are multiple sequences of maximum length,
display their count.
Implementation:

315.  Display on the screen the maximum length of
a sequence in the array with the property that any two
elements in consecutive positions are coprime
(relatively prime) to each other.
Example: If the array contains values: 16 25 6 12
1045, the output will be 3, because the longest
sequence with the requested property is 16 25 6.

Implementation:

316.  Determine the longest palindromic sequence
in the array (of adjacent elements).
Example: For the array v=(3, 4, 7, 9, 2, 9, 7, 5), the
output is the value 5.
Implementation:


317.  Determine the sequence of adjacent elements
whose sum has the maximum value. Display the
sequence on the screen.
Implementation:


4.12  COMPUTATION OF
EXPRESSIONS
318.  Let there be two one-dimensional arrays, x and y,
which store n (n≤100) positive integers each with at
most 4 digits. Calculate the value of the following
expressions:
a.  E=(x1+y1)*(x2+y2)*...*(xn+yn);
b.  E=x1y1+x2y2+...+xnyn;
c.  E=min(x1,y1)+ min(x2,y2)+...+ min(xn,yn) ;
d.  E=min(x1,yn)+ min(x2,yn-1)+...+ min(xn,y1) ;
e.  Last digit of: E=x1y1+x2y2+...+xnyn.

Implementation:
319.  
Find the sum and
product of two polynomials. The coefficients of the
polynomials will be stored in two one-dimensional arrays.

Implementation:

320.  
 Calculate the
greatest common divisor and the least common multiple
of the elements in a one-dimensional array that stores n
(n≤100) non-zero natural numbers.
Implementation:

321.  
Display the
common divisors of all the elements in a one-
dimensional array with n (n≤100) non-zero integer
components, each having at most four digits.
Implementation:


322.  Consider a one-dimensional array that stores n
(n≤50) integers. Determine the prime factor that
appears to the highest power in the prime factorization
of the product of those n numbers.
Implementation:

323.  Fraction Operations
a.  Determine the sum and product of n (n≤100)
fractions. For each fraction, read the values of the
numerator and denominator as non-zero integers, each
having at most four digits. The results should be
expressed as irreducible fractions.
b.  Determine the smallest fraction among the n fractions
read.

Implementation:

324.  Determine whether the m-th root (m is a
natural number <10) of (x1*x2*x3*....*xn) is a natural
number, where xi are natural numbers with at most 4
digits each.
Implementation:

4.13  GENERATION PROBLEMS
325.  Generate and store the first n (n≤200) prime
numbers in a one-dimensional array.
Implementation:


326.  Store in a one-dimensional array the prime
numbers up to the given input n, for which the reverse of
the number is also prime. Here, n is a natural number
with at most 8 digits
Implementation:

327.  Generate and store the first n elements of the
Fibonacci sequence in a one-dimensional array (F[1]=1,
F[2]=1, F[n]=F[n-1]+F[n-2], n>2).
Implementation:

328.  Generate all the subsets of the set {1, 2, 3, ...,
n}.
Solution: This method is based on the observation
that for each subset of the given set, {1,2,...,n} , there
corresponds a sequence of n bits, denoted as x[], as
follows:
if bit x[k] = 0, element k does not belong to the
current subset;
if bit x[k] = 1, element k belongs to the current
subset.
Reminder: A set with n elements has 2n subsets.
Implementation:

329.  Generate all subsets of the set a[1], a[2], a[3],
..., a[n].
Implementation:
330.  Write a program that reads an odd natural number
n from the keyboard and builds in memory a one-

dimensional array A = (A1, A2, ..., An) with the
elements of the set {1, 2, 3, ..., n} such that the
elements at odd positions form the increasing sequence
1, 2, ..., [(n+1)/2], and the elements at even positions
form the decreasing sequence n, n-1, ..., [(n+1)/2]+1.
Example: for n=11, the array A=(1, 11, 2, 10, 3, 9, 4,
8, 5, 7, 6) will be constructed.
Implementation:

4.14  
OPERATIONS WITH LARGE
NUMBERS
331.  In the files nr1.txt and nr2.txt, two large
numbers are written (each with at most 1000 digits).
a.  Display the sum of the two numbers.
b.  Multiply the first number by a single-digit number
x, where the value of x is read from the keyboard.
c.  Determine the product of the two numbers.

d.  Determine the quotient and remainder of the
division of the two numbers.
Implementation:





4.15  PROCESSING NUMBERS IN
DIFFERENT NUMERAL SYSTEMS
332.  Convert a natural number x with at most 9 digits
from base 10 to base 2.
Implementation:
333.  Convert a natural number x with at most 9 digits
from base 10 to base b (2<=b<=9).

Implementation:
334.  Determine whether the natural number x written
in base 10 has in base 2 a number of 0 digits equal to
the number of 1 digits.

Implementation:
335.  The n digits of number x and the base b in which
number x is written are read. Display the number x in
base 10.

Implementation:

336.  
Two natural
numbers, x and y, are read. Determine whether one of
the numbers can represent the transcription of the other
number in a numbering system smaller than or equal to
9. If affirmative, display the numbering system.
Example: For x=68 and y=2112, the output is 3
because 2112(3)=68(10) .
Implementation:

4.16  FREQUENCY VECTORS
337.  The file digits.txt contains at most one million
digits separated by one or more spaces. Display, using
an efficient method in terms of memory space and
execution time, all the digits sorted in ascending order.
Implementation:


338.  The file digits.txt contains at most one million
digits separated by one or more spaces. Display, using
an efficient method in terms of memory space and
execution time, the unique digits sorted in ascending
order.
Implementation:

339.  The file cifre.txt contains at most one million
digits separated by one or more spaces. Display, using
an efficient method in terms of memory space and
execution time, the digits that are not found in the file.
Implementation:

340.  The file cifre.txt contains at most one million
digits separated by one or more spaces. Display, using
an efficient method in terms of memory space and
execution time, the digits with the lowest frequency.

Implementation:

341.  The file numbers.txt contains at most one
million natural numbers with at most four digits,
separated by one or more spaces. Display, using an
efficient method in terms of memory space and
execution time, the two largest two-digit numbers that
are not found in the file.
Implementation:

342.  
 The file
numbers.txt contains at most one million natural
numbers with at most four digits, separated by one or
more spaces. Display the count of numbers from the file
that have their first and last digits identical.
Implementation:

343.  
 The file
numbers.txt contains a maximum of 10000 natural
numbers, each with up to 9 digits. Each line of the file
contains one number. Display on the screen the largest
number that can be formed using the digits from all the
numbers in the file. Choose an algorithm for solving this
efficiently in terms of memory usage and execution
time.
Example: If the file numbers.txt contains:
267
39628
79
then the output will be 9987766322.

Implementation:

344.  The file numbers.txt contains a maximum of
10000 natural numbers, each with up to 9 digits. Each
line of the file contains one number. Display on the
screen the smallest number that can be formed using
the digits from all the numbers in the file. Choose an
algorithm for solving this efficiently in terms of memory
usage and execution time.
Example: If the file numbers.txt contains:
267
39608
79
then the output will be: 2036677899.
Implementation:

345.  The file numbers.txt contains at most one
million natural numbers, each with up to nine digits,
separated by one or more spaces. Display the digit (or
digits) that appears most frequently among the numbers
in the file.
Implementation:

346.  The file numbers.txt contains at most one
million natural numbers, each with up to three digits,
separated by one or more spaces. Display the numbers
from the file that appear only once in ascending order.
Implementation:

347.  The file marks.txt contains at most one million
marks (real numbers with two decimal places ranging
from 1 to 10). Display a statistics of the marks as
follows: the count of marks within the interval [1,2], the
count of marks within the interval (2,3], ..., the count of
marks within the interval (9,10].
Implementation:

348.  
The file numbers.txt contains a maximum of 10000
natural numbers, each with up to 9 digits. Display the
count of numbers that have equal digits.
Example: If the numbers 234, 333, 55, 56, 33, 5632
are written in the file, the output will be 3.
Implementation:

349.  Given a vector v with n elements of natural
numbers (n≤100) with up to 4 digits each. Display the
largest number formed by using the first digit of each
component from v.
Example: For v = (78, 567, 7122, 5, 123), the output
is: 77551.
Implementation:

350.  
 The
record of products sold by a commercial company is kept
in the file products.txt. For each product, the product
type is known (a natural number with at most 2 digits),
the quantity in kilograms (a natural number less than or
equal to 100), and the price per kilogram (a natural
number less than or equal to 100). Products of the same
type can be sold in different quantities, with each sale
recorded separately. The file products.txt has at most
2000 lines, and each line contains three natural numbers
separated by spaces, representing, in this order, the
type, quantity, and selling price of a product at a given
time. Write a program that calculates, for each product
type sold, the total amount obtained from sales. The
program will display on each line of the screen the
product type and the total amount obtained, separated
by a space, as shown in the example.

Example: If the file products.txt has the following
content:
3 1 5
1 20 5
2 10 3
1 10 5
the program will display the following numbers:
1 150
2 30
3 5
Implementation:

CHAPTER 5 – TWO-DIMENSIONAL
ARRAYS
5.1 Iterating with Processing of Elements
5.2 Row(s) Processing
5.3 Column(s) Processing
5.4 Deleting a Row
5.5 Deleting a Column
5.6 Generation Problems
5.7 Rearranging Components According to Various
Criteria
5.8 Square Matrix
5.8.1 Diagonal Processing
5.8.2 Processing Areas Bounded by Diagonals
Declaring two-
dimensional arrays (matrices) in C/C++ is done
similarly to declaring one-dimensional arrays, but two
physical dimensions need to be specified: the
maximum number of rows and the maximum number
of columns of the matrix:

For example:
Above, a two-
dimensional array (a matrix) with 5 rows and 10
columns has been declared. We can visualize it like
this (values are random):

The matrix has:
5 • 10 = 50 elements;
5 rows, indexed from 0 to 4 – the rows with indices
1 and 3 are highlighted below;
10 columns, indexed from 0 to 9 – the columns
with indices 0, 4, and 9 are highlighted below:


Referencing elements is done through the C++
indexing operator [], just like with vectors, but two
indices need to be specified – one for the row and one
for the column. Thus, A[2][4] represents the element
of the matrix located on row 2 and column 4 – at the
intersection of row 2 and column 4. Therefore, the first
index of an element corresponds to the row, and the
second index corresponds to the column.
Applications:

5.1 ITERATING WITH PROCESSING
OF ELEMENTS
351.  Write a program that reads a two-dimensional array
with m rows and n columns (m≤30, n≤30) storing
integers with up to four digits each. The program should
determine and display the maximum value and how
many times it appears in the array.
Implementation:

352.  
Write a program that reads a two-dimensional array with
m rows and n columns (m ≤ 30, n ≤ 30), which stores
integers of up to four digits each, and determines and
displays whether its values are stored in the array in
ascending order.

Implementation:

353.  Write a program that reads a two-dimensional
array with m rows and n columns (m≤30, n≤30), which
stores integers of up to four digits each. Display the array
obtained by replacing all minimum values with the
maximum value in the array.
Implementation:

354.  
 Write a
program that reads a two-dimensional array with m rows
and n columns (m≤30, n≤30), which stores integers of
up to four digits each. Calculate the percentage of prime
elements in the matrix.
Implementation:


355.  Write a program that reads a two-dimensional
array with m rows and n columns (m≤30, n≤30), which
stores integers of up to four digits each. Calculate and
display the last digit of the product of odd elements from
even columns.
Implementation:

356.  Write a program that reads a two-dimensional
array with m rows and n columns (m≤30, n≤30), which
stores integers of up to four digits each. Display the odd
rows from left to right and the even rows from right to
left.
Implementation:


357.  Write a program that reads a natural number n
(2≤n≤20) from the keyboard, followed by the elements
of a two-dimensional array with n rows and n columns.
The array stores non-zero natural numbers with at most 4
digits each. The program displays on the screen those
values from the array that are strictly smaller than all the
elements they are directly adjacent to (located on the
same row but in the adjacent column, or on the same
column but in the adjacent row), as in the example.
Example: For n=4 and the adjacent array, the
program displays the numbers: 2, 1.
5 4 7 9
6 2 3 4
1 9 8 5
2 3 8 6

Implementation:

358.  In the file date.in, a matrix with n rows and n
columns (n≤30) of integers with at most 4 digits each is
stored. The value of n is on the first line, followed by the
next n lines, each containing n numbers separated by
spaces.
a.  Determine the sum of values on the main diagonal
and the sum of values on the secondary diagonal, storing
the data in a two-dimensional array.
b.  Determine the sum of values on the main diagonal
and the sum of values on the secondary diagonal using
only simple variables.

Implementation:

359.  
Determine whether in a two-dimensional array with m
rows and n columns (m, n≤30), which stores integers,
there are components equal to the sum of their indices.

Implementation:

360.  Determine whether a two-dimensional array with
m rows and n columns (m, n≤30), which stores integers,
has distinct components. Display "Yes" or "No".
Implementation:

361.  Determine whether two matrices, a and b, with
m rows and n columns (m, n≤30) that store integers,
hold the same values but in a different order.
Implementation:

362.  
 In the
date.in file, a matrix a with m rows and n columns (m,
n≤30) of integers with at most 9 digits each is stored.
Generate two matrices b and c, where bij stores the sum
of digits of aij, and cij stores the number of digits in aij.

Implementation:

363.  
Determine the sum and product of two matrices a and b
with n rows and n columns that store integers with at
most 2 digits each.

Implementation:

5.2
ROW(S) PROCESSING
364.  Write a program that reads a two-dimensional
array with m rows and n columns (where m≤30 and
n≤30) storing integers with up to four digits each.
Display the minimum value from each row and the
maximum value among these obtained minimum
values.
Implementation:


365.  Write a program that reads a two-dimensional
array with m rows and n columns (where m≤30 and
n≤30) storing integers with up to four digits each.
Display the indices of the row or rows that have the
maximum sum of their components.
Implementation:

366.  Write a program that reads a two-dimensional
array A with m rows and n columns (m≤30, n≤30)
that stores integers with at most four digits each.
Border the matrix with the (m+l)th row and the
(n+l)th column, where A[m+1,j] represents the sum
of elements in column j, A[i, n+1] represents the sum
of elements in row i, and A[m+1][n+1] will store the
sum of all components.
Implementation:


367.  Write a program that reads a two-dimensional
array with m rows and n columns (m≤30, n≤30) that
stores integers with at most four digits each. Swap the
values on row p with the values on row q, where p and
q are read from the keyboard.
Implementation:

368.  Write a program that reads a two-dimensional
array with m rows and n columns (m≤30, n≤30),
numbered starting from 1, which stores integers with
at most four digits each. Display the line numbers that
have the same sum.
Example: For the matrix:
2 4 5 1
1 1 4 5
2 6 1 3
2 0 5 4
8 0 0 4
The output should be: (1,3), (1,5), (3,5), (2,4).

Implementation:

369.  Write a program that reads a two-dimensional
array with m rows and n columns (m≤30, n≤30) that
stores integers with at most four digits each. Display
the indices of the lines that have the same sum. The
numbering starts from 1.
Example: For the matrix:
2 4 5 1
1 1 4 5
2 6 1 3
2 0 5 4
8 0 0 4
The output should be: (1, 3, 5), (2, 4).
Implementation:


370.  Consider the two-dimensional array with n rows
and n columns containing natural numbers with at
most four digits each. Write a program that reads a
natural number n (2≤n≤24) and the n*n elements of
the array from the keyboard. Then, display the
maximum element from the first concentric square.
The first concentric square consists of the first and last
rows, as well as the first and last columns of the array.

Implementation:

371.  Write a program that reads a two-dimensional
array with m rows and n columns (m ≤ 30, n ≤ 30)
which stores integers of up to four digits each. Display
the row numbers that contain the value x, which is
read at least once.
Example: for m=3, n=4, x=5, and the array:
2 3 5 5
1 2 4 6
5 0 7 8
display 1 and 3.
Implementation:

372.  
 Write a
program that reads a two-dimensional array with m
rows and n columns (m ≤ 30, n ≤ 30) that stores

values equal to 1 or 0. Display pairs of rows that store
the same values, not necessarily in the same order.
Example: for m=5, n=3, and the array:
1 1 0
1 0 1
0 0 1
0 1 1
1 0 0
output: (1,2), (1,4), (2,4), (3,5).

Implementation:

373.  Write a program that reads a two-dimensional
array with m rows and n columns (m ≤ 30, n ≤ 30)
storing values equal to 1 or 0. Display the rows that
store the same values, not necessarily in the same
order.
Example: for m = 6, n = 3 and the array:
1 1 0
1 0 1
0 0 1
0 1 1
1 0 0
1 1 1 output: (1, 2, 4), (3, 5), (6).

Implementation:

374.  Write a program that reads a two-dimensional
array with m rows and n columns (m <= 30, n <=
30), which stores values equal to 1 or 0. Display the
highest value obtained by transcribing into base 10
the numbers determined by the digits of each row
expressed in base 2.
Example: for m = 5, n = 3 and the array:
0 1 0
0 0 1
1 0 1
0 1 1
1 0 0
the output is: 5 (because binary 101 represents the
value 5 in decimal).

Implementation:

375.  Write a program that reads a two-dimensional
array with m rows and n columns (m ≤ 30, n ≤ 30)
which stores integers. Determine whether there are
common elements in all rows.
Example: For m = 5, n = 3, and the array:
0 1 2
5 0 1
6 0 1
0 1 1
1 9 0
the output is: 0, 1.

Implementation:

376.  A matrix of real numbers with m rows and n
columns (m, n ≤ 40) is read. Display the count of
rows in the matrix that have all strictly positive
components.
Implementation:

377.  
Read a matrix of real numbers with m rows and n
columns (m, n ≤ 40). Display the indices of the
matrix rows that have their components ordered in
ascending order.

Implementation:

378.  
 THE
MATRIX. Andrew is passionate about science fiction
movies and programming. His favorite movie is The
Matrix. He even has programs for video file
processing using computers. He captures frames and
started to study the images from the screen in detail.
His favorite sequences are the ones that depict the
matrix represented as sequences of bits from the
famous movie. Radu even noticed certain similarities
among lines that load on the screen. Two lines are
considered similar if they are written with the same
binary digits, possibly in a different order. Excited by
his discovery, Andrew divided the matrix into groups
of similar lines. Moreover, he aimed to identify the
dominant group. A group is called dominant if it
contains the maximum number of similar lines. Before
proceeding to develop a program to determine how
many similar lines the dominant group of a matrix has,
Andrew realized that another problem could arise: a
matrix might have multiple dominant groups. Help
Andrew determine how many dominant groups a

matrix has and how many lines each dominant group
contains.
Input: The first line of the file matrix.in contains
two natural numbers, M and N (2≤M≤3000 and
2≤N≤1000). The next M lines contain N natural
numbers each with values 0 or 1, representing the
matrix.
Note: Binary digits are not separated by spaces.
Output: The first line of the file matrix.out will
contain two natural numbers representing the number
of dominant groups and the number of similar lines in
such a group.
Example 1:
matrix.in    matrix.out
6 5     1 3
11000
00110
11110
10001
11011
10000

Explanation: The matrix contains one dominant
group containing 3 similar lines. These 3 similar lines
have the same binary digits: two digits 1 and three
digits 0 each.
Example 2:
matrix.in    matrix.out
7 5     2 3
11000
00110
11110
10011
11011
01111
00110

Implementation:

5.3 COLUMN(S) PROCESSING
379.  Write a program that reads a two-dimensional array
with m rows and n columns (m ≤ 30, n ≤ 30) storing
integers of up to four digits each. Display the indices of
the column(s) that do not contain any zeros.
Implementation:

380.  
Write a program that
reads a two-dimensional array with m rows and n
columns (m ≤ 30, n ≤ 30) storing integers of up to four
digits each. Swap the columns of the array in such a way
that the elements in row k are arranged in ascending
order.
Implementation:


381.  
 Write a
program that reads a two-dimensional array with m rows
and n columns (m ≤ 30, n ≤ 30) storing integers of up
to four digits each. Swap the values in column p with the
values in column q, where the values of p and q are read
from the keyboard.

Implementation:

382.  Write a program that reads a two-dimensional
array with m rows and n columns (m ≤ 30, n ≤ 30)
storing integers of up to four digits each. Display the
elements in the array that are equal to the sum of the
other elements in their respective columns.
Example: for the matrix:
2 3 1 5
1 8 7 2
1 5 3 3
The output is: 2, 5, 8.

Implementation:

383.  
 Write a
program that reads a two-dimensional array with m rows
and n columns (m ≤ 30, n ≤ 30) storing only values
equal to 1 or 2. Display the indices of the columns that
have the maximum product of their elements.

Implementation:

384.  
 Write a
program that reads a two-dimensional array with m rows
and n columns (m ≤ 30, n ≤ 30) storing integers of up
to 4 digits each. Display the indices of the columns with
identical values throughout the entire column. If there are
no such columns, a message will be displayed.
Example: for m=3, n=5 and the matrix:
2 1 9 2 1
2 3 2 2 1
2 1 1 2 1
The output will be: 1, 4.

Implementation:

385.  Given a two-dimensional array with m rows and
n columns (m ≤ 30, n ≤ 30) storing integers, determine
whether the elements in column x are arranged in
ascending order.
Implementation:
386.  Given a two-dimensional array with m rows and
n columns (m ≤ 30, n ≤ 30) storing integers, arrange
the elements in column x in ascending order.

Implementation:


5.4 DELETING A ROW
387.  Write a program that reads a two-dimensional
array with m rows and n columns (m ≤ 30, n ≤ 30),
which stores integers with at most four digits each.
Display the array obtained by deleting the k-th row.
Implementation:

388.  
 Write a
program that reads a two-dimensional array with m
rows and n columns (m≤30, n≤30), which stores
integers with at most four digits each. Display the
array obtained by removing the elements from odd-
numbered rows.

Implementation:

389.  Write a program that reads a two-dimensional
array with m rows and n columns (m≤30, n≤30),
which stores integers with at most four digits each.
Display the array obtained by deleting the rows that
contain zeros.

Implementation:

390.  Write a program that reads a two-dimensional
array with m rows and n columns (m≤30, n≤30),
which stores distinct integers with at most four digits
each. Display the array obtained by deleting the row
and column that contain the minimum value.


Implementation:

391.  
Write a program that reads a two-dimensional array
with m rows and n columns (m≤30, n≤30), which
stores integers with at most four digits each. Display
the array obtained by deleting the rows that contain
duplicates.

Implementation:

392.  
Consider a two-dimensional array with m rows and n
columns (m≤30, n≤30) that stores integers with at
most four digits each. Remove rows from the matrix so
that there are no identical rows.
Example. For m=5, n=2, and the matrix:
2 3
4 5
2 3
2 3
4 5
the result is:
2 3
4 5

Implementation:


5.5 DELETING A COLUMN
393.  Write a program that reads a two-dimensional
array with m rows and n columns (m≤30, n≤30),
which stores integers with at most four digits each.
Display the array obtained by deleting column k.
Implementation:

394.  
 Write a
program that reads a two-dimensional array with m
rows and n columns (m≤30, n≤30), which stores
integers with at most four digits each. Display the
array obtained by removing the elements from even-
numbered columns.

Implementation:

395.  
 Write a
program that reads a two-dimensional array with m
rows and n columns (m≤30, n≤30), which stores
integers with at most four digits each. Display the
array obtained by removing the columns that contain
negative numbers.

Implementation:

396.  Write a program that reads a two-dimensional
array with m rows and n columns (m≤30, n≤30),
which stores integers with at most four digits each.
Remove the columns that have a sum of components
smaller than a given integer x.

Implementation:

Implementation:

397.  Write a program that reads a two-dimensional
array with m rows and n columns (m≤30, n≤30),
which stores integers with at most four digits each.
Remove the columns that store only numeric values
consisting of a single digit.

Implementation:

Implementation:

398.  Write a program that reads a two-dimensional
array with m rows and n columns (m≤30, n≤30),
which stores integers with at most four digits each.
Remove the column that stores the largest value found
in the first row. In case there are multiple values
equal to the maximum value, delete the column with
the smallest index.

Implementation:

5.6 GENERATION PROBLEMS
399.  A non-zero natural number x with exactly 5 digits is
read. Generate a square two-dimensional array that
stores the digit of the units place of x on the first row, the
digit of the tens place on the second row, and so on.
Implementation:

400.  A non-zero natural number x with at most nine
digits is read. Generate a square matrix that stores the
digit in the units place of x on the first row, the digit in
the tens place on the second row, and so on.
Implementation:

401.  
 A non-zero natural
number x with at most nine digits is read. Generate a
square matrix that stores the digit of the units of x on the
first column, the digit of the tens on the second column,
and so on.

Implementation:

402.  A non-zero natural number x with at most nine
digits is read. Generate a square matrix that, in order,
stores on rows the digits of the integer number x that was
read, as shown in the following example.
Example. For x=4562, the matrix is generated as
follows:
4 5 6 2
4 5 6 2
4 5 6 2
4 5 6 2
Implementation:

403.  
 Write a
program that reads two natural numbers n and p
(2≤n≤20, 1≤p≤20) from the keyboard and constructs a
two-dimensional array in memory with n rows and p
columns. The array should be constructed in such a way
that by traversing the array row by row from top to
bottom and each row from left to right, the sequence of
the first n*p odd perfect squares is obtained, strictly
increasing, as shown in the example.
Example: For n=2, p=3, the following array will be
displayed:
1 9 25

49 81 121
Implementation:

404.  
 Write a
program that reads a natural number n (2<n<20) from
the keyboard, constructs and displays on the screen a
matrix with n rows and n columns. In this matrix, each
element on the secondary diagonal has the value n, each
element above the secondary diagonal is one less than
the neighbor on the same row to its right, and each
element below the secondary diagonal is one more than
the neighbor on the same row to its left.
Example: For n=5, the following matrix will be
displayed.
1 2 3 4 5
2 3 4 5 6
3 4 5 6 7
4 5 6 7 8
5 6 7 8 9

Implementation:
405.  Write a program that reads a natural number n
(2<n<20) from the keyboard, constructs and displays on
the screen a matrix with n rows and n columns. The
matrix should store the values from 1 to n on the first
row, followed by the subsequent rows containing the left-
circular permutations of the sequence 1, 2, 3, ..., n, as
shown in the example.
Example: For n=5, the following matrix will be
displayed:
1 2 3 4 5
2 3 4 5 1
3 4 5 1 2
4 5 1 2 3

5 1 2 3 4
Implementation:

406.  Write a program that reads a natural number n
(2<n<20) from the keyboard and constructs in memory
a matrix with n rows and n columns, numbered from 1 to
n. In this matrix, each element located on the outer
border of the matrix is equal to the sum of its row and
column indices, while each of the other elements is equal
to the sum of its three "neighbors" situated in the matrix
on the previous row. Two elements in the matrix are
considered neighbors if they are adjacent on the same
row, column, or diagonal. The outer border of a matrix is
formed by the first row, last row, first column, and last
column.
Example: For n=5, the resulting matrix will be:
2 3 4 5 6
3 9 12 15 7
4 24 36 34 8
5 64 94 78 9
6 7 8 9 10

Implementation:
407.  Write a program that reads a natural number n
(2 < n < 10) from the keyboard and constructs in
memory, then displays on the screen, a two-dimensional
array with n rows and n columns. The array should be
constructed in such a way that by traversing it row by row
from top to bottom and each row from left to right, the
first n x n non-zero even prime numbers are obtained in
strictly increasing order, as shown in the example below. 
Example: For n=4, construct and display the following
array:

2 4 6 8
10 12 14 16
18 20 22 24
26 28 30 32
Implementation:

408.  
Write a program that
reads a natural number n (2 < n < 20) from the
keyboard, constructs in memory, and displays on the
screen a matrix with n rows and n columns. The matrix
should store the first n x n even numbers that are not
multiples of 3.
Example: For n=3, display the following matrix:
2 4 8
10 14 16
20 22 26

Implementation:

409.  Write a program that reads a natural number n
(0 ≤ n ≤ 24) from the keyboard and then constructs in
memory a matrix with n rows and n columns. The matrix
should be constructed such that the elements located on
the main diagonal are equal to 2, the elements above the
main diagonal are equal to 1, and the elements below the
main diagonal are equal to 3.
Example: If n is 4, then the program will construct
and display the following matrix:
2 1 1 1
3 2 1 1
3 3 2 1
3 3 3 2

Implementation:

410.  Write a program that reads three natural
numbers n, a, and b (2 < n < 25, 0 < p < n, 0 < q <
n) from the keyboard and constructs in memory a matrix
with n rows and n columns, numbered from 1 to n. The
matrix should only consist of values 0, 1, 2, 3, and 4,
following these rules: elements on row p or column q are
equal to 0, elements above row p and to the left of
column q are equal to 1, elements above row p and to
the right of column q are equal to 2, elements below row
p and to the left of column q are equal to 3, and
elements below row p and to the right of column q are
equal to 4, as shown in the example below.
Example: For n=5, p=4, q=3, construct in memory
and display the following matrix:
1 1 0 2 2
1 1 0 2 2
1 1 0 2 2
0 0 0 0 0
3 3 0 4 4
Implementation:

411.  
 Write a program that
reads two natural values, n and m (1 ≤ n ≤ 50, 1 ≤ m ≤
50), from the keyboard and constructs in memory a two-
dimensional array with n rows and m columns. The array
should be filled with all natural numbers from i to n * m.
The numbers should be stored by column traversal, as
shown in the example below.
Example: For n=5 and m=4, the output will be:
1 6 11 16
2 7 12 17
3 8 13 18
4 9 14 19

5 10 15 20
Implementation:

412.  
 Write a program that
reads two natural values, n and m (1 ≤ n ≤ 50, 1 ≤ m ≤
50), from the keyboard and constructs in memory a two-
dimensional array with n rows and m columns that stores
the first m x n terms of the Fibonacci sequence.
Implementation:

5.7 REARRANGING COMPONENTS
ACCORDING TO VARIOUS CRITERIA
413.  Write a program that reads a two-dimensional
array with m rows and n columns (m ≤ 30, n ≤ 30)
storing integers with at most four digits each. Modify the
order of the elements so that each row is arranged in
ascending order.
Example: For m=3 and n=4, given the matrix:
5 6 8 3   The modified matrix should be:
2 9 1 6   3 5 6 8
8 1 8 2   1 2 6 9
1 2 8 8
Implementation:

414.  
 Write a program
that reads a two-dimensional array with m rows and n
columns (m ≤ 30, n ≤ 30) storing integers with at most
four digits each. Modify the order of the elements so that
each column is arranged in ascending order.
Example: For m=3 and n=4, given the matrix:
5 6 8 3   The modified matrix should be:
2 9 1 6   2 1 1 2

8 1 8 2   5 6 8 3
8 9 8 6
Implementation:

415.  Write a program that reads a two-dimensional
array with m rows and n columns (m ≤ 30, n ≤ 30)
storing integers with at most four digits each. Modify the
order of the elements so that when traversing the matrix
from top to bottom and from left to right, it contains the
elements in ascending order.
Example: For m=4 and n=3, given the matrix:
5 6 8 3    The modified matrix should be:
2 9 1 6    1 1 2 2
8 1 8 2    3 5 6 6
8 8 8 9

Implementation:

416.  
 Write
a program that reads a two-dimensional array with m
rows and n columns (m ≤ 30, n ≤ 30) storing integers
with at most four digits each. Modify the order of the
elements so that it contains even elements at the
beginning, followed by odd elements.

Implementation:

417.  Write a program that reads a two-dimensional
array with m rows and n columns (m≤30, n≤30),
storing integers with at most four digits each. Display the
indices of the columns whose elements can be obtained
from the sum of two other columns.
Example: For m=3, n=5, and the given matrix,
display:
1 2 1 3 5  4 (from 1 and 2)
2 3 1 5 8  5 (from 2 and 4)
7 2 2 9 11

Implementation:
418.  Consider a two-dimensional array with n rows
and m columns (1≤n≤50, 1≤m≤50) that stores
integers with at most two digits each. Write a program
that reads from the keyboard the values of n, m, and the
elements of the array, and which reverses the order of
elements within each row, as shown in the example.

Example: For n=3, m=5, and the given matrix, the
output should be:
1 2 3 4 5  5 4 3 2 1
3 4 1 2 1  1 2 1 4 3
2 3 4 1 8  8 1 4 3 2

Implementation:

419.  Write a program that reads two natural
numbers, m and n (0≤m≤10, 0≤n≤10), from the
keyboard, and the elements of a two-dimensional array
with m rows and n columns, which stores natural
numbers less than 100. The program will construct and
display a new two-dimensional array with n rows and m
columns on the screen, obtained from the original array
by rotating it counterclockwise by 90 degrees, as shown
in the example.
Example: For m=4, n=5, and the array:
1 2 3 4 5       5 2 2 9
6 7 8 9 2     4 9 1 8
4 5 6 1 2    the result is:  3 8 6 7
2 5 7 8 9     2 7 5 5
1 6 4 2

Implementation:

5.8 SQUARE MATRICES

5.8.1 DIAGONALS PROCESSING
420.  Consider a square matrix with n rows and n
columns (1≤n≤30), storing integers with at most 4
digits each. Write a program that reads the value of n
and the elements of the matrix from the keyboard and
displays the following on the screen:
a.  The values located on the main diagonal
b.  The values located on the secondary diagonal
c.  The values located on diagonals in reverse order
d.  Prime values on the main diagonal
e.  The maximum value from the sequence of values
located on both diagonals
f.  The greatest common divisor for pairs of values
located on the same row and on both diagonals.


Implementation:

421.  
Consider a square matrix with n rows and n columns
(1≤n≤30), storing integers with at most 4 digits each.
Write a program that reads the value of n and the
elements of the matrix from the keyboard and displays
on the screen the sum of those elements on the main
diagonal that have the property of being the minimum
values on their respective rows. Example: For n=4 and
the following matrix, the program will display the
value 5 (2+3=5).
8 9 2 6
5 2 8 10

1 2 4 6
7 8 6 3
Implementation:


422.  Consider a square matrix with n rows and n
columns (1≤n≤30), storing integers with at most 4
digits each. Write a program that reads the value of n
and the elements of the matrix from the keyboard, and
sorts in ascending order the elements on the main
diagonal without changing the order of the other
elements in the matrix.
Implementation:

423.  Consider a square matrix with n rows and n
columns (1≤n≤30), storing integers with at most 4
digits each. Write a program that reads the value of n
and the elements of the matrix from the keyboard, and
sorts the elements on the secondary diagonal in
descending order (values on the same row will be
swapped).

Implementation:

424.  Consider a square matrix with n rows and n
columns (1≤n≤30), storing integers with at most 4
digits each. Write a program that reads the value of n
and the elements of the matrix from the keyboard, and
displays on the screen the matrix obtained by
swapping the elements on the main diagonal with the
elements on the secondary diagonal (values on the
same row will be swapped).
Implementation:

5.8.2  PROCESSING AREAS
BOUNDED BY DIAGONALS
425.  
 Consider a square
matrix with n rows and n columns (1≤n≤30), which
stores integers with at most 4 digits each. Write a
program that reads the value of n and the elements of
the matrix from the keyboard. The program should
calculate the sum of the elements below the main
diagonal and the sum of the elements above the main
diagonal (excluding the diagonal itself), and then display
the sum with the greater value.
Implementation:


426.  
 Consider a
square matrix with n rows and n columns (1≤n≤30),
which stores integers with at most 2 digits each. Write a
program that reads the value of n and the elements of
the matrix from the keyboard. The program should
calculate the product of the elements below the
secondary diagonal and the product of the elements
above the secondary diagonal (excluding the diagonal
itself), and then display the product with the greater
value.

Implementation:

427.  Read from the file mat.in: on the first line, a
natural number n (n≤50), and on the following n lines,
the elements of a square matrix.
a.  Verify whether all elements located strictly above the
secondary diagonal of the matrix have the same parity.
b.  Verify whether all elements located strictly below the
main diagonal of the matrix have the same sign."

Implementation:
428.  Generate a matrix with n rows and n columns
that stores the value 0 on the diagonals and the values 1,

2, 3, and 4 in the areas delimited by the diagonals, as in
the following example:
Example: for n=5
0 1 1 1 0
2 0 1 0 3
2 2 0 3 3
2 0 4 0 3
0 4 4 4 0
Implementation:

429.  Check if a square matrix is a magic square (the
sum of the elements in each row, column, and diagonal is
the same and equals to n*(n2+1)/2, and it stores all
values from 1 to n2).
Example: for n=3, matrix A is a magic square. 
 
.
Implementation:


430.  Maze. Despite the ongoing war with Aldor, the
Prince of Darkness, a new front has emerged right on
Azeroth. The island of Quel'Danas, located in the Eastern
Kingdoms, has become the latest target of the enemy.
Kael'Thas, the last leader of the elves, was discovered to
be the new formidable ally of Aldor. Cunning and highly

skilled, Kael'Thas managed to capture Arthas, the leader
of your army and the defender of the Eastern Kingdoms.
The fate of those captured is grim. They are thrown into
the Dark Labyrinth from which no one has ever escaped.
The Dark Labyrinth has a rectangular shape with m x n
chambers where the cries for help of the remaining
captives echo. Some chambers have traps that force the
prisoners to navigate the chambers in certain directions,
otherwise, they lose their lives. Once a trap is crossed, it
disappears, and no other trap appears in its place. There
are four types of traps: type one trap determines the NW
direction, type two trap determines the NE direction, type
three trap determines the SE direction, and type four trap
determines the SW direction. The traveler changes
direction in the labyrinth only after stepping on a new
trap. Chambers without traps are of type zero. A chamber
can have only one trap or none. The prisoner is always
placed at the beginning in a chamber with a trap that will
determine their direction in the labyrinth. Obviously,
there will also be situations where the prisoner will pass
through the same chamber multiple times. In a moment
of mercy, Aldor promised to spare the life of the prisoner
who continues their path without stopping, so as to reach
the edge of the labyrinth and exit it, knowing how many
chambers they have crossed and what is the maximum

number of passes through the same chamber (for a
prisoner). Your role is to help Arthas answer Aldor's
questions.
Input:
The input file date.in contains two natural numbers m
and n on the first line, representing the dimensions of the
labyrinth in terms of the number of chambers. Then, the
next m lines contain n values, each representing a
number from zero to four as described in the statement
(zero for a chamber without a trap, or values 1, 2, 3, or 4
for chambers with a trap). Finally, on the last line, there
are two natural numbers x and y representing the initial
location in the labyrinth where the prisoner is placed.
Output:
The output file date.out will contain a single line with
two numbers separated by a space, representing the
number of chambers traversed and the maximum
number of passes through the same chamber for a
prisoner.
Clarifications:
The first chamber, located in the upper left corner of
the labyrinth map, is identified by the pair (1,1), and the
last chamber, located in the lower right corner, is
identified by the pair (m,n).

Exiting the labyrinth is considered to be any chamber
on the edge of the labyrinth that does not contain a trap.
Constraints:
0 < m, n ≤ 50 (natural numbers)
Examples:
date.in   date.out explanation
6 6   10 2
4 0 0 4 0 1
0 0 0 0 0 0
0 3 0 0 0 1
0 0 0 0 0 0
0 0 0 2 0 0
0 0 0 0 0 0
6 4


6 6   11 2
0 3 0 0 0 0
0 0 0 0 2 0
0 0 0 1 0 1
0 0 0 0 2 0
0 2 0 0 0 0
0 0 0 0 0 0
5 2

Implementation:


CHAPTER 6 – CHARACTER
STRINGS
6.1 Iterating with processing of Elements
6.2 Characters Deletion
6.3 Displaying characters sorted by different
criteria
6.4 Splitting a text into "words"
6.5 Replacing characters
6.6 Processing n strings of characters
6.7 Processing texts from files
Applications:

6.1 ITERATING WITH PROCESSING
OF ELEMENTS
431.  Write a program that, upon execution, determines
whether a string of up to 100 characters, stored in the
variable s, is a palindrome or not, and displays the
message "Correct" if it is a palindrome, or the message
"Incorrect" if it is not. A string of characters is a
palindrome if it reads the same forwards as backwards.
Example: The string "madam" is a palindrome.
Implementation:

432.  Write a program that reads from the keyboard a
word consisting of at most 50 characters, using only
uppercase letters of the English alphabet. Calculate the
sum of the ASCII codes of the characters in the string.
Example: For the string "AAB", the program should
display: 196.
Implementation:

433.  Write a program that reads from the keyboard a
string of at most 40 characters, composed only of
lowercase letters of the English alphabet. The program
should display on the screen, in a single line, all the
vowels that appear in the input string. The vowels should
be displayed in the order of their appearance in the
string, separated by a space, as shown in the example.
The following letters are considered vowels: a, e, i, o, u. If
the input string does not contain any vowels, the
program should display the message no vowels.
Example: If the input string is informatics, then the
program should display: i o a i.
Implementation:

434.  Determine if a string of characters contains
distinct characters.
Implementation:

435.  
 Determine
whether a string of characters contains only letters.
Implementation:
436.  Write a program that reads from the keyboard a
string of up to 40 characters, consisting only of letters
from the English alphabet. The program should display
on the screen, in a single line, the word obtained by

replacing each letter with the next letter in the alphabet.
In place of the letter Z, the letter A should be displayed.
Example: If the input string is "ANA", the program
should display: "BOB".
Implementation:

437.  
 Consider a string s with
a maximum of 50 characters, containing only lowercase
letters of the English alphabet and digits. The first
character of the string is a digit, the last character is a
letter, and each lowercase letter in the string is preceded
by a non-zero digit. Write a program that reads the string
s from the keyboard and then constructs and displays a
new string on the screen. This new string should consist
only of lowercase letters of the English alphabet and it
should be built according to the following rule: each
lowercase letter should be repeated as many times as
indicated by the digit preceding it in the original string,
as shown in the example.
Example: If the input string is 2a5b3x, the required
string should be aabbbbbxxx.

Implementation:

438.  Consider a string s with a maximum of 50
characters, containing only lowercase letters of the
English alphabet, digits, and a character c. Determine
the frequency of occurrence of the character c in the
text.
Implementation:

439.  A text of up to 70 characters is read from the
keyboard, containing uppercase and lowercase letters of
the English alphabet, as well as spaces. Display all pairs
of consecutive vowels in the text, separated by spaces,
along with their count.
Implementation:
440.  Write a program that reads from the keyboard a
text of up to 255 characters, consisting of lowercase

letters and spaces, with at least one lowercase letter of
the English alphabet. The program should display on the
screen, in a single line and separated by spaces, all the
lowercase letters of the English alphabet that appear in
the text. Each letter should be displayed only once, in
the order of its first appearance in the text.
Example: For the text hello world, the program
should display: h e l o w r d.
Implementation:

441.  
 Write a
program that reads from the keyboard a text of up to 255
characters, consisting of lowercase letters and spaces,
with at least one lowercase letter of the English alphabet.
Words can be separated by one or more spaces.
Determine how many words of length q are in the text,
where q is read from the keyboard.
Example: For the text anne has  apples and 
oranges and q=3, the program should display 2.

Implementation:

442.  Consider a string s with a maximum of 50
characters, consisting of lowercase letters of the English
alphabet. The encoding in “bird language” of a word
involves: after each vowel, the letter p followed by that
vowel is added.
Example: If the input string is informatics, the
output should be ipinfopormapatipics.
Implementation:

443.  
 Write a program
that reads from the keyboard a word consisting of at
most 20 characters, containing only lowercase letters of
the English alphabet. The program should transform the
input word by replacing each vowel with a string
composed of two characters: the respective vowel
followed by its corresponding uppercase letter. The
program then displays the resulting word on the screen,
all in a single line. Vowels are considered to be the letters
from the set {a, e, i, o, u}.
Example: For the word informatics, the program
should display: iInfoOrmaAtiIcs.

Implementation:

444.  Write a program that reads from the keyboard a
word consisting of at most 20 characters, containing only
lowercase letters of the English alphabet. The program
transforms the input word by replacing each vowel with
the character *, while leaving the rest of the letters
unchanged. The resulting word is then displayed on the
screen in a single line. Vowels are considered to be the
letters from the set {a, e, i, o, u}.
Example: For the word informatics, the program
should display: *nf*rm*t*cs.
Implementation:

445.  
 Write a program
that reads a text from the keyboard, consisting of up to
100 characters. The program transforms the input text
by replacing each lowercase letter with its corresponding
uppercase letter, and vice versa, while leaving the rest of
the characters unchanged, as shown in the example. The
program displays the resulting text on the screen in a
single line.
Example: For the text Hello World! This is an
Example, the program should display: hELLO wORLD!
tHIS IS AN eXAMPLE.

Implementation:

446.  Consider a text with a maximum of 255
characters that stores letters of the English alphabet and
spaces. The words are separated by a single space.
Determine the number of words contained in the
sentence.
Implementation:

447.  
 Consider a text
with a maximum of 255 characters that stores letters of
the English alphabet and spaces. The words are
separated by one or more spaces. The text begins and
ends with a letter. Determine the number of words
contained in the sentence.
Implementation:

448.  Consider a text with a maximum of 255
characters in which words are separated by one or more
spaces. The first character in the read text is a letter, and
the words are formed only from lowercase letters of the
English alphabet. Write a program that reads the text
from the keyboard and transforms it by replacing the first
and last letter of each word with the corresponding
uppercase letter, leaving the rest of the characters
unchanged. The text thus transformed will be displayed
on the screen.
Example: If the input text from the keyboard is:
Processing string characters is mundane, the output
displayed on the screen will be: ProcessinG SrinG
CharacterS Is MundanE.
Implementation:

449.  
 Write
a program that reads a word from the keyboard,
consisting of at most 20 characters, using only lowercase
letters of the English alphabet. The program determines
the transformation of the input word by replacing the
first vowel of the word with the last vowel of the word,
while keeping the other letters unchanged, as shown in
the example. The program then displays the resulting
word on the screen, all on a single line. Vowels are
considered to be the letters from the set {a, e, i, o, u}.
Example: For the word geograph, the output
displayed on the screen will be: gaogreph.

Implementation:

450.  Write a program that reverses the first half of a
string of characters with the second half. If the string
holds an odd number of characters, the middle character
remains unchanged.
Example: For the string informatics, the output will
be: aticsminfor.
Implementation:

451.  Write a program that reads two strings of
characters from the keyboard, each consisting of a
maximum of 100 lowercase letters of the English
alphabet. The program then displays on the screen the
longest common prefix of the two character strings. If the
two strings do not share any common prefix, the
program will display the message no prefix.
Example: For the strings informatica and
infatuation, the output will be: inf.
Implementation:

452.  
 Write a program that
reads two strings of characters from the keyboard, each
consisting of a maximum of 100 lowercase letters of the
English alphabet. The program then displays on the
screen the longest common suffix of the two character
strings. If the two strings do not share any common
suffix, the program will display the message no suffix.
Example: For the strings apple and purple, the
output will be: ple.

Implementation:

453.  Write a program that reads a word from the
keyboard, consisting of at most 50 characters, using only
uppercase letters of the English alphabet. The program
should display on the screen, each on a separate line, all
the prefixes of the word in increasing order of their
lengths.
Example: If the word PROGRAM is read, the output
will be:
P
PR
PRO
PROG
PROGR
PROGRA
PROGRAM

Implementation:

454.  Write a program that reads a word from the
keyboard, consisting of at most 50 characters, using only
uppercase letters of the English alphabet. The program
should display on the screen, each on a separate line, all
the suffixes of the word in decreasing order of their
lengths.
Example: If the word PROGRAM is read, the output
will be:
PROGRAM
ROGRAM
OGRAM
GRAM
RAM
AM
M
Implementation:

455.  
 Write a program that
reads a “password” edited by a user in a way that for
each character edited on the screen, a * character will be
displayed (during editing). The password will be
“encrypted” in the following way: each alphabetic
character will be replaced with the next character in the
alphabet, the letter “z” will be replaced with the letter
“a”, and other characters will be replaced with
characters that have an ASCII code greater by 3.
a.  The encrypted password will be written to the file
pass.txt.
b.  Write a decryption sequence for the password from
the file and display it in clear text on the screen.

Implementation:

456.  Write a sequence that encrypts a text read
from the keyboard as follows:
Lowercase letters will be replaced with numbers from
1 to 26, separated by a space, corresponding to their
order in the alphabet: for a, the value is 1; for b, the
value is 2, and so on.
Uppercase letters will be replaced with numbers from
27 to 52, separated by a space, corresponding to
their order in the alphabet: for A, the value is 27; for
B, the value is 28, and so on.
Each digit will be replaced with one of the letters from
a to j, so 0 will be replaced with a, 1 with b, and so
on.
Other characters will be replaced with the next
character in the ASCII code table.
The result will be written to the file date.out.

Implementation:

457.  Hangman. Write a program that performs the
following tasks:
Reads a word composed only of uppercase letters of
the English alphabet from the file date.in, and display
for each letter the character *.
Reads a letter from the keyboard. If the letter is found
in the string, the text will be displayed again with the
* character replaced by the corresponding letter.
For each failed attempt, the user will be penalized
with one point.
The program ends when the user accumulates 6
errors or when all * characters have been replaced
with the corresponding letters.
Implementation:

458.  
Expression 1. Consider an expression that stores
natural numbers formed from a single digit, and the
operators + and -. Determine the value of the
expression. The expression begins with a number.

Example. For the expression 2+3+7-1+5-6, the value
10 is displayed.
Implementation:

459.  
Expression 2.
Consider an expression that stores natural numbers and
the operators + and -. Determine the value of the
expression.
Example. For the expression 20+31+7-1+50-6, the
value 101 is displayed.

Implementation:

460.  Expression 3. Consider an expression that
stores real numbers and the operators + and -.
Determine the value of the expression.
Example. For the expression 20.5+3.1+7-1, the
value 29.6 is displayed.
Implementation:

461.  
Determine if the letters of string a appear in string b in
the order they appear in a. Display Yes or No.
Example. For a = "B87$An6C200" and b =
"200B888A5n6C20", Yes is displayed.
Implementation:

6.2 CHARACTERS DELETION
462.  Write a program that reads from the keyboard a
word consisting of at most 20 characters, containing only
lowercase letters of the English alphabet. The program
displays the strings obtained by successively removing
the vowels from the word. Vowels are considered to be
the letters from the set {a,e,i,o,u}.
Example: For the word informatics, the program will
display on the screen:
informtcss
nformtcss
nfrmtcss
Implementation:


463.  Write a program that reads from the keyboard a
word consisting of at most 20 characters, containing only
lowercase letters of the English alphabet. The program
displays the string obtained by removing the letter with
the highest frequency in the word. In case there are
multiple letters with the maximum frequency, the letter
that appears earlier in the alphabet will be removed.
Example: For the word informatica, the program
will display on the screen: informtic (explanation: the
letters a and i appear twice in the word, but a comes
earlier in the alphabet).
Implementation:

464.  A text is read from the keyboard, with a
maximum of 255 characters, letters, and spaces, where
words are separated by one or more spaces. Remove the
extra spaces so that only one space remains between
words.
Implementation:

465.  Consider a text with a maximum of 255
characters, consisting of letters, digits, and spaces.
Remove the digits from the text.
Implementation:

466.  
 Remove a character x
read from a text t in such a way that it does not appear
more than p times.
Implementation:

467.  Consider a text with a maximum of 255
characters: letters, digits, the period character, and
spaces. Remove the numbers from the text.
Example: for the text I got 9.5 in the exam, the
result will be I got in the exam.
Implementation:
468.  
Write a program that reads from the keyboard a word
consisting of at most 40 characters, all lowercase letters
of the English alphabet. Remove characters in such a
way that there are no two identical consecutive
characters.
Example: For the word abbbmmbbcc, the result will
be abmbc.

Implementation:

469.  Decoding. For decoding a text that contains
only letters and the asterisk character (*), the first base
word is determined (the first sequence that consists only
of letters – one or more), and all occurrences of it in the
text are erased without altering other words (sequences
composed only of letters) if they contain the base word.
The procedure is repeated by traversing the text from
the beginning, considering the new base word from the
start of the text, until all words are emptied.
What is the last base word determined through this
procedure?
Input Data:
The first line of the input file date.in contains a text
with at most 8000 characters (only letters and the
asterisk character).
Output Data:
In the output file date.out a text representing the
“base word” defined in the statement will be displayed.
Restrictions and Clarifications:
The text contains at least one letter.
Example:
data.in      data.out

***ion*avion*pinion***ion**avion*ion**   pinion
Explanation:
The first base word is ion. After deletion, we get:
***tavion*pinion****avion
The second base word is avion. After deletion, we get:
*****pinion********
The last base word is pinion. After deletion, we are left
with an empty string.

Implementation:

6.3 DISPLAYING CHARACTERS
SORTED BY DIFFERENT CRITERIA
470.  Consider a text with a maximum of 255
characters consisting of letters and spaces, where
words are separated by one or more spaces. Display
the letters of the text only once in alphabetical order.
There will be no distinction between uppercase and
lowercase letters.
Example: For the text Anna has apples and
pears the output will be: A D E H L N P R S.
Implementation:

471.  Consider a text with a maximum of 255
characters consisting of letters and spaces, where
words are separated by one or more spaces. Display
the unique letters of the text in alphabetical order
along with their frequency in the text. There will be no
distinction between uppercase and lowercase letters.
Example: For the text Anna has apples and
pears the output will be:
A 6
D 1
E 2
H 1
L 1
N 3
P 3
R 1
S 3

Implementation:

472.  
 Consider a
text with a maximum of 255 characters consisting of
letters and spaces, where words are separated by one
or more spaces. Display the letters of the text sorted
in descending order by their frequency of occurrence.
If two letters have the same frequency, they will be
displayed in alphabetical order. There will be no
distinction between uppercase and lowercase letters.
Example: For the text Anna has apples and
pears, the output will be:
A 6
N 3
P 3
S 3
E 2

D 1
H 1
L 1
R 1
Implementation:

473.  
Write a program that reads two strings of characters
from the keyboard, composed of a maximum of 20
uppercase letters of the English alphabet, and displays
them on the screen. Check whether the two words are
anagrams (have the same characters but in a different
order).
Example: For DUSTY and STUDY the output will
be ANAGRAMS.

Implementation:

474.  Consider a text with a maximum of 20
characters consisting of letters. Display the text with
its letters sorted alphabetically: first the uppercase
letters, then the lowercase letters.
Example: For the input informAtIcs,the output
will be: AIcfimnorst.
Implementation:

475.  
Consider a text with
a maximum of 40 characters consisting of letters and
digits. Display the text with its letters sorted
alphabetically: first the lowercase letters, then the
uppercase letters, and finally the digits sorted in
descending order.
Example: For the input 738informAtica, the
output will be: aAcfilmnort873.

Implementation:

476.  Consider a text with a maximum of 40
lowercase letters. Display the consonants first, sorted
in alphabetical order, and on the next line, display the
vowels sorted in alphabetical order. Each letter should
appear only once.
Example: For the input informatica the output
will be:
cfmnrt
aio
Implementation:

6.4 SPLITTING A TEXT INTO
“WORDS”
477.  Consider a text with a maximum of 255 characters,
where words are separated by one or more spaces.
Display the text obtained by reversing the characters of
each word in the text.
Example: For the text Anna  has  apples, the output
will be: annA sah selppa.
Implementation:

478.  
 Consider a
text with a maximum of 255 characters, consisting of
lowercase letters and spaces, where words are separated
by one or more spaces. Determine whether the words in
the text are sorted lexicographically. Display sorted or not
sorted accordingly.
Example: For the text cube elephant  flower
hemisphere, the output will be sorted.

Implementation:

479.  Consider a text with a maximum of 255
characters, where words are separated by one or more
spaces and punctuation marks: , . ; ! ?. Display the words
from the text in alphabetical order. There will be no
distinction between uppercase and lowercase letters.
Example: For the text hello,! How are you? Fine,
thank you. the output will be: are Fine hello How
thank you you.
Implementation:

480.  
 A text of
maximum 255 characters is read, containing words
formed only from lowercase letters of the English
alphabet. The words are separated by one or more

spaces. Write a program that reads a word and displays
on the screen the text obtained by removing all
occurrences of the read word, as in the example.
Example: for the text: The text contains some
words and more words within the text words. And
the word words , the output displayed: The text
contains some and more within the text.
Implementation:
481.  A text of maximum 255 characters is read,
containing words formed only from lowercase letters of
the English alphabet. The words are separated by a single
space. Write a program that reads a word and displays on
the screen the text obtained by adding the character * at
the end of all occurrences of the read word, as in the
example.

Example: for the text: The text contains some
words and more words within the text words and
the word words, the output displayed: The text
contains some words* and more words* within the
text words*.
Implementation:

482.  A text of maximum 255 characters is read,
containing words formed only from lowercase letters of
the English alphabet. The words are separated by a single
space. Write a program that reads a word and displays
how many times the word appears in the text.
Example: for the text: The text contains some
words and more words within the text words and
the word words, the output is 3.
Implementation:

483.  Consider a text with a maximum of 255
characters in which words are separated by one or more
spaces and punctuation marks: , . ; ! ?. Display the
longest word in the text. In case there are multiple words
of maximum length, the first one that would appear in
lexicographic order (in the dictionary) will be displayed.
Example: for the text: ana,. has apples and;; two
pears?! the output will be: apples
Implementation:

484.  
 Consider a text
with a maximum of 255 characters consisting of letters,
digits, spaces, and punctuation marks: “.;!?. Determine
the sum of the numbers in the text. Note: leading zeros at
the beginning of a number are considered insignificant.
Example: for the text: ana,. has 25 apples and
023;; pears 2?! the output will be: 50.
Implementation:


485.  
Write a program
that reads a text from the keyboard, consisting of at most
200 letters of the English alphabet, where words are
separated by spaces. The program should display on the
screen the number of words in the input text that have a
vowel as their first and last letter. If there are no such
words in the text, the program should display the
message Does not exist. A vowel is considered any letter
from the set {a, A, e, E, i, I, o, O, u, U}.
Example: If the input text is Aardvark ants on
apples are unique the output will be 2.

Implementation:
486.  Write a program that reads from the keyboard
two strings, a and b, each consisting of at most 25
characters. The string a represents the first name and
last name of a person. There can be any number of space
characters (at least one) between the first and last name.
The string b represents the father's first name. The
strings are composed only of letters from the English
alphabet. The program constructs in memory and
displays on the screen a string c representing the full
name of the person. This c string should contain the last
name, the initial of the father's name followed by a
period, and then the first name.
Example: If the input strings are: Stewart Green and
Boris the program will construct and then display the
string on the screen: Stewart B. Green.

Implementation:

487.  Write a program that reads from the keyboard a
string of characters x, which can store at most 30 letters
of the English alphabet, and then a text t, consisting of at
most 200 letters of the English alphabet. In the text,
words are separated by spaces. The program should
display on the screen whether the string x can be
obtained by concatenating two words from the text t. The
order in which the two words are concatenated doesn't
matter.
Example: If x stores banana and t stores ana are a
ban, the program will display YES.
Implementation:

488.  
Consider the text file named data.in which contains
integer numbers separated by one or more spaces,
written on multiple lines. Determine how many numbers
are on each line. Display the results on the screen.
Implementation:

489.  Consider the text file named data.in which
contains real numbers separated by one or more spaces,
written on multiple lines. Determine how many numbers
are on each line. Display the results on the screen. What
is the maximum number of numbers contained in a line?
Implementation:

6.5 
REPLACING CHARACTERS
490.  Write a program that reads from the keyboard a
word consisting of at most 20 characters, only lowercase
letters of the English alphabet. The program displays the
string obtained by replacing the first vowel with the last
consonant from the word.
Example: For the word informatica, the program will
display on the screen: cnformatiia.
Implementation:


491.  
 Consider a text with
a maximum of 255 characters in which words can contain
both uppercase and lowercase letters, separated by one
or more spaces. Two letters, x and y, are read. Simulate
the REPLACE command so that x is replaced with y. The
difference in case is ignored.
Implementation:
492.  Consider a text with a maximum of 255
characters in which words can contain both uppercase
and lowercase letters, separated by one or more spaces.
Two words, x and y, with a maximum of 20 letters each,

are read. Simulate the REPLACE command so that x is
replaced with y. The difference in case is ignored.
Implementation:

493.  
 Read a text
with a maximum of 255 characters containing words
composed only of lowercase letters of the English
alphabet. Words are separated by a single space. Write a
program that reads a word and displays on the screen the
text obtained by replacing all occurrences of the read
word with a sequence of characters * of the same length
as the length of the read word, as shown in the example.
Example: For the text: The text contains some
words and more words within the text and the word
words, the program will display: The text contains
some ***** and more ***** within the text.

Implementation:

494.  
 Consider a
text with a maximum of 255 characters in which words
can contain lowercase letters and are separated by one
or more spaces. Replace the vowels with their
corresponding uppercase letters.
Implementation:

6.6 PROCESSING N STRINGS OF
CHARACTERS
495.  Read n (n≤100) words, each with a maximum of
20 letters. Display for each word the number of
characters, the first letter, and the last letter.
Implementation:

496.  Read n (n≤100) words, each with a maximum
of 20 letters. Display groups of words that rhyme (have
the same last two characters).
Example: If the following words are read:
n=6
ward cat leard dog hat log
Display:
log dog
hat cat
ward leard
Implementation:

497.  Read n (n≤100) words, each with a maximum
of 20 letters. Display groups of words that are
anagrams (have the same characters but in a different
order).
Example: If the following words are read:
n=7
listen top part silent trap pot elinst
Display:
listen silent elinst
top pot
part trap
Implementation:

498.  
 Read n
(n≤100) words, each with a maximum of 20 letters.
Sort the words in ascending order based on the number
of characters. Words with the same number of
characters should be sorted lexicographically.

Implementation:

499.  Read n (n≤100) strings, each with a
maximum of 20 characters. Display those strings that
do not contain digits. If no such strings are read,
display a message.
Example: If the following strings are read:
n=6
button23 rare la0ke airplane horse78 and
Display:
rare airplane and

Implementation:
500.  Read n (n≤100) strings, each with a
maximum of 20 characters. Display those strings that
have more than m characters. If no such strings are
read, display a message.
Implementation:



501.  Read n (n≤100) words, each with a maximum
of 20 letters. Determine whether each word has the
same first two letters as the last two letters of the
previously read word. If true, display: pheasant;
otherwise, display: parrot.
Example: If the following strings are read:
n=4
apple lemon ondoor orange
Display: pheasant
Implementation:

502.  Read n (n≤30) strings of characters that store
letters of the English alphabet and a single space, each
representing the first and last names of individuals. The
last name is separated from the first name by a space
character. Determine:
a.  How many pairs of individuals share the same last
name.
b.  How many pairs of individuals share the same first
name.
Implementation:

6.7 PROCESSING TEXTS FROM FILE
503.  Read a word from the keyboard, which can contain
at most 20 uppercase or lowercase letters. From the file
date.in read a text written on multiple lines. The text
contains only letters and spaces. Display the lines that
contain the read word. A line cannot exceed 100
characters. There is no distinction between uppercase
and lowercase letters.
Example: If the word read is Con and the file
contains:
Congruenta matematica
Geometrie con
Continent si convergent
Con sfera cub
geografie
The output would be: 2 4
Implementation:

504.  
Up to 100 strings, each with a maximum of 20
characters, representing the names of individuals written
on different lines, are read from a file. Modify the content
of the file so that all the names are written as follows:

the first letter will be uppercase, and the rest of the
letters will be lowercase.
Example: If the file contains:
PARFITT
JOHNson
lamerton
after modifying the content of the file, it will be:
Parfitt
Johnson
Lamerton

Implementation:

505.  From the file date.in a text is read, written on
multiple lines. A line cannot exceed 100 characters. The
text contains only letters and spaces. Display the line
that contains the longest text. In case there are multiple
lines of maximum length, the first one encountered will
be displayed.
Implementation:

506.  
 The
following code reads a word x from the keyboard, which
can contain a maximum of 20 uppercase or lowercase
letters. From the input file date.in a text is read, written
on multiple lines. A line cannot exceed 100 characters.
Determine whether x is found in the file. Display YES or
NO.

Implementation:

507.  From the input file date.in, a text is read, written
on multiple lines. A line cannot exceed 100 characters.
The text contains only letters and spaces. Display the
line that contains the most vowels. In case there are
multiple lines with the same maximum number of
vowels, the first one will be displayed.
Implementation:

508.  From the input file date.in, a text is read, written
on multiple lines. A line cannot exceed 100 characters.
The text contains only letters and spaces. Display the
line that contains the most words. Words can be
separated by one or more spaces. A word can contain at
least one letter. In case there are multiple lines with the
same maximum number of words, the last one will be
displayed.
Implementation:

509.  
 From the input
file date.in, a text is read with a maximum of 20 lines. A
line cannot exceed 100 characters. The text contains
only letters and spaces. Two strings, x and y, are read
from the keyboard, each having a maximum of 50
characters. Simulate the REPLACE command in order to
replace string x with string y, thereby modifying the
content of the file.
Implementation:


510.  
From the file date.in, a text is read with a maximum of
20 lines. A line cannot exceed 100 characters. The text
contains only letters and spaces. Display the letters that
appear in the file in alphabetical order. There will be no
distinction between uppercase and lowercase letters.

Implementation:

511.  
 Generate the
file date.out with the texts from the files date1.in and
date2.in, alternating one line from each file: first, the
first line from date1, then add the next line from
date2.in, and so on. Both files contain up to 20 lines that
can store a maximum of 20 characters: letters and
spaces.

Implementation:

CHAPTER 7 – TEXT FILES
Applications:
512.  In the file date.in, the following information is
read:
- The first line contains a natural number n (n ≤ 1000).
- The next line contains n integers, each with at most 4
digits.
a.  Determine the largest number in the file and how
many times this number appears in the file.
b.  Determine the largest prime number. If there are no
prime numbers in the file, display the message Does not
exist.
Implementation:


513.  In the file data.in, the following information is
read: The first line contains a natural number n (n ≤
1000). The next line contains n natural numbers, each
with at most 4 digits. Display the numbers from the file
with the “+” sign between them, and at the end, display
the “=” sign followed by the value of the sum of the
numbers.
Implementation:

514.  In the file data.in, up to n (n ≤ 1000) integer
values with at most 4 digits each are stored. Display the
squares of perfect numbers in ascending order. If there
are no perfect squares in the file, display the message
Does not exist.
Implementation:

515.  
Display the
two largest values from the data.in file which stores
integers with at most 4 digits each.
Implementation:

516.  Display the three largest values from the data.in
file which stores integers with at most 4 digits each.
Implementation:

517.  
 Display the
last prime number from the data.in file which stores
integers with at most 4 digits each.
Implementation:

518.  Display the first prime number from the data.in
file which stores integers with at most 4 digits each.
Implementation:

519.  
 Display the
last two palindrome numbers from the data.in file which
stores integers with at most 9 digits each.
Implementation:

520.  Display the second-to-last prime number from
the data.in file which stores integers with at most 4 digits
each.
Implementation:

521.  
 Display the
third-to-last prime number from the data.in file which
stores integers with at most 4 digits each.

Implementation:

522.  
 Display the first
and the last prime numbers from the data.in file which
stores integers with at most 4 digits each.
Implementation:

523.  Determine whether the numbers in the data.in
file are sorted in ascending order. Display Yes or No. The
file stores integers with at most 4 digits each.
Implementation:

524.  
Determine
whether the numbers in the data.in file are all equal.
Display Yes or No. The file stores integers with at most 4
digits each.
Implementation:

525.  In the numbers.in file, integers with a maximum
of 4 digits each are stored. You are requested to display
on the screen the position at which the first number
would be located if the numbers were sorted in
ascending order.
Example: If the numbers.in file contains:
250 13 45 600 7 79
the output will be 5, because the first element from
the original sequence, 250, would be located at the fifth
position in the sorted ascending sequence (7 13 45 79
250 600).
Implementation:

526.  
 The data.in
file stores integers with at most 4 digits each in
ascending order. Display each value only once.
Implementation:

527.  The data.in file stores integers with at most 4
digits each, in ascending order. Display the value that
appears most frequently in the file. In case there are
multiple values with the maximum frequency, the largest
among them will be displayed.
Implementation:


528.  The file data.in stores integers with at most 4
digits each.
a.  Display the number of values stored in the longest
increasing sequence.
b.  Display the number of such maximum-length
sequences.
Implementation:
529.  The file data.in stores integers with at most 4
digits each.
a.  Display the number of values that store the longest
sequence of consecutive numbers in the file, where each
number in the sequence has the same number of digits.

b.  Display the number of values that store the longest
sequence of consecutive perfect squares in the file.
c.  Display the number of values that store the longest
sequence of consecutive prime numbers in the file.
Implementation:


530.  The file data.in stores integers with at most 2
digits each,
a.  Display the unique numbers in ascending order.
b.  Display all the numbers in ascending order.
c.  Display the unique numbers in ascending order, and
for each value, also show the frequency of occurrence.
d.  Display the numbers with the highest frequency in the
file.
e.  Display the numbers that are not found in the file.
f.  Display the largest number in the file.
g.  Display the largest number that is not found in the
file.

Implementation:

531.  
 The file
data.in stores integers with at most 9 digits each. Display
the numbers formed by two digits each, sorted in
ascending order, and displayed only once.
Implementation:

532.  The file data.in stores integers with at most 9
digits each. Display the two largest natural values
composed of 3 digits each that are not found in the file. If
there are not two such numbers, display the value 0.
Implementation:

533.  
 The
file data.in stores integers with at most 9 digits each.
Display the largest 4-digit number and the number with
the value closest to it.

Implementation:
534.  From the file data.in, two integers a and b are
read from the first line, each with at most 4 digits. Then,
other integers x are read, each with at most 4 digits.
Display the largest number x that is read and belongs to
the interval [a, b].

Implementation:

535.  The record of products sold by a commercial
company is kept in the file products.txt. For each sale,
the following information is known: the product type (a
natural number with at most 2 digits), the quantity sold
in kilograms (a natural number less than or equal to
100), and the price per kilogram (a natural number less
than or equal to 100). The products.txt file has at most
200,000 lines, and each line contains three natural
numbers separated by spaces, representing, in this
order, the type, quantity, and selling price of a product at
the time of the respective sale. Write a program that
determines, for each product type sold, the total sum
obtained from the sales. The program will display, on
separate lines, the product type and the total sum
obtained, separated by a space.
Example: If the products.txt file has the following
content:
3 1 5
1 20 5
2 10 3
1 10 5

The program will display the following pairs, not
necessarily in this order:
1 150
2 30
3 5
Implementation:


536.  The text files date1.in and date2.in
contain integers, separated by spaces, with
at most 9 digits each. Each of the files
contains at most 100 values, and the
numbers in each file are strictly increasing.
The task is to display on the screen, in
ascending order, the numbers divisible by 3
that are found in only one of the two files.
Example: If the file date1.in contains the
numbers 1 2 3 4 6 7 12 15 20 60, and the file
date2.in contains the numbers 3 5 7 8 9 10
12 20 24, then the values 6 9 15 24 60 will
be displayed on the screen.

Implementation:

537.  The text files date1.in and date2.in contain,
separated by a space, integers with at most 9 digits
each. Each of the files contains at most 100 values, and
the numbers in each file are strictly arranged in
ascending order. The task is to display on the screen, in
ascending order, the numbers divisible by 3 that are
present in both files.
Example: if the file date1.in contains the numbers 1
2 3 4 6 7 12 15 20 60, and the file date2.in contains the
numbers 3 5 6 7 8 9 10 12 20 24, then the values 3 6 12
will be displayed on the screen.
Implementation:


538.  The file numbers.in stores a
maximum of 1000 natural numbers, each
with at most 9 digits. Each line in the file
contains a single number. Write the largest
possible number that can be formed using all
the digits present in the numbers from the
file numbers.in into the file numbers.out.
Example: if the file numbers.in contains:
267
39628
79
then the file numbers.out will contain:
9987766322.
Implementation:

539.  
 The
file numbers.in stores a maximum of 1000 natural
numbers, each with at most 4 digits. Generate the file
numbers.out which stores, for each number x read from
numbers.in, the smallest power of 2 that is greater than
or equal to x.
Example: If the file numbers.in contains 5, 20, 14, 1,
4, 10, then the file numbers.out will contain: 8, 32, 16, 1,
4, 16.
Implementation:


540.  
 The text file
date.in contains, on the first line, a non-zero natural
number n (1≤n≤1000). On each of the following n lines,
there are two integers a and b (1≤a≤b≤32000), each
pair representing a closed interval of the form [a,b].
Determine the intersection of these n intervals. In case
the intersection is an empty set, the value 0 will be
displayed.
Example: If the file date.in contains:
5
7 20
15 24
12 28
16 100
2 18
the output will be: 16 18.

Implementation:

541.  The text file date.in contains, on the first line, a
non-zero natural number n (1≤n≤1000). On each of the
following n lines, there are n digits of 0 or 1. Determine
the line numbers that have the same sum of digits. The
digits are not separated by spaces.
Example: If the file date.in contains the values:
5
11011
10010
00011
10001
11110
the output will be:
1 5
2 3 4

Implementation:
542.  The file numbers.in contains a maximum of
1000 natural numbers, each with at most 9 digits.
Generate the file numbers.out which stores, for each
number x read from numbers.in, the number obtained by
removing the even digits from x. If the number x does
not contain any odd digits, then nothing will be written.

Example: If the file numbers.in contains 2354, 20,
143, 1, 47532, 103, then the file numbers.out will
contain: 35, 13, 1, 753, 13.
Implementation:

543.  
 The file
numbers.in contains a maximum of 1000 natural
numbers, each with at most 9 digits. Display the number
with the highest sum of its digits. In case there are
multiple numbers with the same maximum sum of digits,
display the one with the smallest value.
Example: If the file numbers.in contains the values:
3001, 21222, 45081, 99, 1110011, the output will be 99.

Implementation:


544.  The file numbers.in contains a maximum of
1000 natural numbers, each with at most 9 digits.
Display the number that contains the highest digit value.
In case there are multiple numbers that contain the
same highest digit value, display the one with the
smallest value.
Example: If the file numbers.in contains the values:
3001, 21222, 45081, 72, 1710011, the output will be 72.
Implementation:

545.  The file numbers.in contains a maximum of
1000 pairs of natural numbers x, y, each with at most 9
digits. Display the pair with the highest number of
common divisors.
Example: If the file numbers.in contains the values:
18 10
35 210
48 240
25 45
8 24
The output will be the pair 48 240.

Implementation:
546.  The text file date.in contains, on the first line, a
non-zero natural number n (1≤n≤1000). On each of the
following n lines, there are n integers with at most two
digits each. Determine the line numbers (among the n
lines) that represent a permutation of the first sequence
of n numbers.
Example: If the file date.in contains the values:
5

4 5 1 2 3
3 4 5 1 8
2 1 5 4 3
1 2 3 5 4
5 6 7 1 2
the output will be: 3, 4.
Implementation:


CHAPTER 8 – STRUCTURE TYPE
547.  The Cartesian coordinates of n (n≤100) points in
the xOy plane are read.
a.  Display the coordinates of the points located on the Ox
axis.
b.  Display the segments parallel to the Oy axis.
c.  Display sets of segments with equal values.

Implementation:

548.  The data of n (n≤100) segments are read, given
by the Cartesian coordinates in the xOy plane of the
points that form them.
a.  Calculate the lengths of the segments.
b.  Display the coordinates of the segment with the
maximum length.
Implementation:


549.  
n
(n≤100) triples of positive real numbers are read.

a.  Display the triples that can form the side lengths of a
triangle.
b.  For the valid triples, determine the number of scalene,
isosceles, and equilateral triangles.
c.  Determine the number of right-angled triangles.
Implementation:


550.  n (n≤100) pairs of non-zero integers are read,
representing the numerator and denominator of fractions.
a.  Determine the fraction with the highest value.
b.  Determine the product of the n fractions. The result
should be expressed as an irreducible fraction.
Implementation:



551.  n (n≤100) triples of positive real numbers are
read, representing the Cartesian coordinates in the xOy
plane of the centers of n circles and their respective radii.
a.  Display pairs of circles that are externally tangent.
b.  Display pairs of circles that are internally tangent.
c.  Display circles with centers on one of the axes.
Implementation:


552.  For n (n≤100) rectangles, the values for length
and width are read as real numbers.
a.  Arrange the rectangles in descending order based on
their diagonal length.
b.  Display the index number of the rectangle in the initial
sequence that has the largest diagonal.

Implementation:


553.  Names of n (n≤100) countries and the colors of
their flags are read. Then, a specific color is read. Display
the names of the countries whose flags contain that color.
For each country, the number of flag colors will be
entered. The country names cannot exceed 40
characters, and the colors cannot exceed 20 characters.

Implementation:

554.  Two calendar dates are read. Each date is
represented by 3 numbers indicating day, month, year.

a.  Display the more recent date.
b.  Calculate the difference between the two dates in
terms of the number of days.

Implementation:

555.  For the n (n≤50) individuals in a company,
names are read as character strings with a maximum of
30 characters each, and their birthdates are represented
by 3 numbers indicating day, month, year.
a.  Display the birth year of person x.
b.  Display all individuals who celebrate their birthday in
the month of December.
c.  Display the youngest person in the company.

Implementation:

556.  Calculate the sum, difference, product, and
quotient of two complex numbers. The numbers and the
displayed results should be in the form of Re+Im i, where
Re and Im are real numbers.

Implementation:


557.  Calculate the sum and product of n (n≤100)
complex numbers. The numbers and the displayed results
should be in the form of Re+Im i, where Re and Im are
real numbers.

Implementation:

558.  In a library, there are n (n≤100) books. For each
book, the title, author, and price are read. The data will
be read from the file library.in.
a.  Display the books in order of their titles.
b.  Display all books written by a specific author, whose
name is read from the keyboard.
c.  Display the title and author of the most expensive
book (if there are multiple books with the maximum price,
all will be displayed).
d.  List the books in descending order of prices.

Implementation:


559.  In a store, there are n (n≤100) products. For
each product, the name of the product, unit price, and
the number of units sold are read.
a.  Display the name of the most expensive product.
b.  Display the products with the highest total value in
stock.
c.  Calculate the arithmetic mean of unit prices.
d.  Display the products sorted alphabetically by name.
e.  Display the products sorted in descending order by
price.
f.  Determine if a product, whose name is read from the
keyboard, has been sold in the store. If affirmative,
display the total revenue generated from the sales.

Implementation:


560.  
Read n (n≤100) natural numbers, each with at most four
digits. Display the numbers in decreasing order of the
number of proper divisors.

Implementation:

561.  
Data for n (n≤100) individuals is being read. For each
individual, the following information is being read: name,
profession (strings of characters with a maximum length
of 30 characters), date of birth as follows: day number,
month name, year number.
a.  Display the information about engineers.
b.  Display the individuals born in the year 1990.

c.  Display the youngest economist.
Implementation:


562.  The grades of n (n≤30) students in the
computer science subject are being read. For each

student, the following information is being read: name,
test grade, number of grades, and the grades
themselves.
a.  Determine the average grade for each student.
b.  Display the students in alphabetical order.
c.  Display the students with averages above 8.00.
d.  Display the grades of a student whose name is read
from the keyboard.
e.  Write the student data to the output.txt file, sorted in
descending order based on averages.

Implementation:



CHAPTER 9 –
SUBROUTINES/METHODS
9.1 Numerical Processing
9.2 Processing One-Dimensional Arrays
9.3 Processing Two-Dimensional Arrays
9.4 Processing Character Strings
Applications:

9.1 NUMERICAL PROCESSING
563.  Write the complete definition of a subroutine
named sub with one parameter, a subroutine that:
-  receives through the parameter a natural number
with at most 4 digits (a > 1)
-  returns the sum of the exponents of the prime
divisors from the prime factorization of the parameter
a.
Example: For a=180, the subroutine will return the
value 5, because a=22*32 *51 and 2+2+1=5.
Using useful calls to the sub subroutine, display the
prime numbers from the data.in file, which stores
integer numbers, each with at most 4 digits.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int sub(int a)
{
int d=2,s=0;
while(a!=1)
{

while(a%d==0)
{
a=a/d;
s++;
}
d++;
}
return s;
}
int main()
{
ifstream f("data.in");
cout<<sub(180)<<endl;
int x;
while(f>>x)
if(sub(x)==1)
cout<<x<<" ";
return 0;
}
564.  Write the complete definition of a subroutine
named sub, with one parameter, a subroutine that:

-  receives, through the parameter a, a natural
number with at most 4 digits (a > 1)
-  returns the sum of the divisors of the parameter
a's value.
Example: For a=6, the subroutine will return the
value 12.
Using useful calls to the sub subroutine, display the
prime numbers from the one-dimensional array v,
which stores integer numbers, each with at most 4
digits.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int sub(int a)
{
int s=0,i;
for(i=1; i<=a; i++)
if(a%i==0)
s=s+i;
return s;
}

int main()
{
ifstream f("data.in");
int v[100],n,i;
f>>n;
for(i=1; i<=n; i++)
{
f>>v[i];
cout<<v[i]<<" ";
}
cout<<endl;
for(i=1; i<=n; i++)
if(sub(v[i])==v[i]+1)
cout<<v[i]<<" ";
return 0;
}
565.  Write the complete definition of a subroutine
named "div," with one parameter, a subroutine that:
-  receives through the parameter a, a natural
number with at most 4 digits (a > 1)
-  returns the sum of the divisors of the parameter
a.

Example: For a=6, the subroutine will return the
value 12.
Using useful calls to the div subroutine, display the
numbers up to a given natural number n, where the
sum of divisors is a prime number.
Example: If n=17, then the output will be: 2 4 16.
Implementation:
#include <iostream>
using namespace std;
int div(int a)
{
int i,s=0;
for(i=1; i<=a; i++)
if(a%i==0)
s=s+i;
return s;
}
int main()
{
int i,n;
cout<<"n=";
cin>>n;

for(i=1;i<=n;i++)
if(div(div(i))==div(i)+1)
cout<<i<<" ";
return 0;
}
566.  The subroutine digit, with two parameters,
receives through the parameter a a natural number
with at most 8 digits, and through the parameter b, a
digit; the subroutine returns the number of
occurrences of digit b in the decimal representation of
number a.
Example: For a=123834 and b=3, the subroutine
will return the value 2.
Using useful calls to the digit subroutine,
determine:
a.  If the digit x is present in the number a.
b.  If a number a has distinct digits.
c.  The largest digit of a number.
d.  The largest number that has the same digits as a
given number a.
e.  If a number a has odd digits.

f.  If a number has all equal digits.
Implementation:
#include <iostream>
using namespace std;
int digit(int a,int b)
{
int k=0,aux;
aux=a;
while(aux!=0)
{
if(aux%10==b)
k++;
aux=aux/10;
}
return k;
}
int v[100],nr;
int main()
{ 
int a,x,aux2;
aux2=a;
///a)

cin>>a>>x;
if(digit(a,x)!=0)
cout<<x<<" is present in number "<<a;
else
cout<<x<<" was not found.";
cout<<endl;
///b)
int c,ok=1;
for(c=0; c<=9; c++)
if(digit(a,c)>1)
ok=0;
if(ok==1)
cout<<"Distinct digits.";
else
cout<<"No distinct digits.";
cout<<endl;
///c)
c=9;
while(digit(a,c)==0)
c—;
cout<<"Maximum digit is: "<<c;
cout<<endl;
///d)

int i;
for(i=0; i<=9; i++)
v[i]=digit(a,i);//frequency of each digit
for(i=9; i>=0; i—)
while(v[i]!=0)
{
nr=nr*10+i;
v[i]—;
}
cout<<"The largerst number is "<<nr<<endl;
cout<<endl;
///e)
ok=1;
for(i=0; i<=9; i++)
if(digit(a,i)%2!=1)
ok=0;
if(ok==1)
cout<<"Odd digits.";
else
cout<<"No odd digits.";
cout<<endl;
///f)
int z=digit(a,x);

ok=1;
for(c=0; c<=9; c++)
if(digit(a,c)==z)
ok=0;
if(ok==1)
cout<<"No equal digits.";
else
cout<<"Equal digits";
return 0;
}
567.  The subroutine digit, with two parameters,
receives through the parameter a a natural number
with at most 8 digits, and through the parameter b, a
digit. The subroutine returns, through parameter a, the
value of a with the digits equal to b removed.
Example: After calling the digit subroutine for
a=123834 and b=3, the value of a will be 1284. Using
useful calls to the digit subroutine, eliminate the even
digits from each of the components in a one-
dimensional array v, which stores n (n≤100) integer
numbers, each with up to 8 digits. If a number in v
contains only even digits, it should not be displayed
anymore.

Implementation:
#include <iostream>
#include <fstream>
using namespace std;
void digit(int &a,int b)
{
int nr=0,p=1;
while(a!=0)
{
if(a%10!=b)
{
nr=nr+a%10*p;
p=p*10;
}
a=a/10;
}
a=nr;
}
int v[100],n,i;
int main()
{
int a=123834,b=3;

digit(a,b);
cout<<a<<endl;
ifstream f("data.in");
f>>n;
for(i=1;i<=n;i++)
f>>v[i];
for(i=1;i<=n;i++)
{
for(int c=0;c<=8;c=c+2)
digit(v[i],c);
if(v[i]!=0)
cout<<v[i]<<" ";
}
return 0;
}
568.  Write the definition of the subroutine digit,
which receives two integer parameters, n and k
(1≤n≤1000000, 1≤k≤5), and returns the k-th digit
of the number n. The rank of a digit is its order
number, counting the digits from right to left; the digit
in the units place has a rank of 1. If the number k is
greater than the number of digits in n, the function
returns the value -l.

Example: After calling digit(9748, 3), it will return
7.
Write a program that reads two natural numbers, x
and y, both less than or equal to 100,000, and
determines whether they have a common prefix (a
sequence of identical digits starting from the left).
Example: For x=2794563 and y=279421, the
output is: 2794.
Implementation:
#include <iostream>
using namespace std;
int digits(int n,int k)
{
k—;
while(k!=0 && n!=0)
{
n=n/10;
k—;
}
if(k==0)
return n%10;
return -1;

}
int main()
{
cout<<digits(9748,3);
cout<<endl;
int x,y,aux1,aux2,nr1=0,nr2=0;
cin>>x>>y;
aux1=x;
aux2=y;
while(aux1!=0)//number of digits of x
{
nr1++;
aux1=aux1/10;
}
while(aux2!=0)//number of digits of y
{
nr2++;
aux2=aux2/10;
}
while(digits(x,nr1)==digits(y,nr2))
{
{
cout<<digits(x,nr1);

nr1—;
nr2—;
}
}
return 0;
}
569.  The subroutine power, with two parameters
received through the parameters a and b, takes two
natural numbers, each with at most 8 digits. The
subroutine returns the largest number less than or
equal to a that represents a power of the number b.
Example: After calling the power subroutine with
a=130 and b=5, the value returned by the subroutine
will be 125.
From the input file data.in, the following is read:
first, a natural number n (n≤100), and then on the
next n lines, 3 natural numbers x, y, z, each with at
most 8 digits. Using appropriate calls to the power
subroutine, for each set, the largest number of the
form zk within the interval [x, y] should be displayed.
In case there are no such numbers within an interval,
the value 0 should be displayed.
Example: For the values

4
10 36 2
100 130 5
40 50 6
7 83 9
The displayed values will be: 32 125 0 81.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int power(int a ,int b)
{
int c;
c=b;
while(c*b<a)
{
c=c*b;
}
return c;
}
int main()

{
ifstream f ("data.in");
int x,y,z,n,rez;
f>>n;
for(int i=1; i<=n; i++)
{
f>>x>>y>>z;
rez=power(y,z);
if(rez>x)
cout<<rez<<" ";
else
cout<<0<<" ";
}
return 0;
}
570.  The control digit of a number is defined as the
digit obtained by repeatedly summing the digits of a
number, then summing the digits of that sum, and so
on, until a number consisting of a single digit is
obtained. For example, for the number 589, the control
digit is 4: 5+8+9=22, then 2+2=4.
Define a subroutine digit_sum that receives a
natural number a as a parameter, with up to nine

digits, and returns the sum of the digits of number a.
Using appropriate calls of the digit_sum
subroutine:
a.  Determine the control digit of a read number x.
b.  Display the numbers from a one-dimensional array
v, which stores at most 100 integers with up to nine
digits each, in groups having the same control digit.
Example: For v=(23, 8, 98, 116, 5, 401, 96,
78783), the output will be:
23, 5, 401
8, 98, 116
96, 78783
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int u[100];
int digit_sum(int a)
{

int s=0;
while(a>0)
{
s=s+a%10;
a=a/10;
}
return s;
}
int control_digit (int a)
{
while(a>9)
a=digit_sum(a);
return a;
}
int main()
{
ifstream f ("date.in");
int v[100],n,i,x;
f>>n;
for(i=1; i<=n; i++)
{
f>>v[i];
cout<<v[i]<<" ";

}
cout<<endl;
for(i=1; i<=n; i++)
{
x=control_digit(v[i]);
cout<<v[i]<<" has the control digit: "<<x<<endl;
}
int c,found;
for(c=0; c<=9; c++)
{
found=0;
for(i=1; i<=n; i++)
if(control_digit(v[i])==c)
{
cout<<v[i]<<" ";
found=1;
}
if(found==1)
cout<<endl;
}
return 0;
}

571.  Define a subroutine divisors that returns the
number of divisors of the parameter x, a natural
number with at most four digits. Using calls to the
divisors subroutine, display the number with the most
divisors up to a given n.
Example: For n=100, display 60 (which has 12
divisors).
Implementation:
#include <iostream>
using namespace std;
int divisors(int x)
{
int k=0,i;
for(i=1; i<=x; i++)
if(x%i==0)
k++;
return k;
}
int main()
{
int n,rez,i,max=-10000;
cout<<"n=";
cin>>n;

for(i=1; i<=n; i++)
if(divisors(i)>max)
{
max=divisors(i);
rez=i;
}
cout<<"The required number is: "<<rez;
return 0;
}
572.  A natural number is called a palindrome if
reading its digits from left to right yields the same
number as reading the digits from right to left. For
example, the number 25152 is a palindrome. By
adding its reverse to a number and repeating the
operation a number of times, you always obtain a
palindrome. For instance, if a=78 and the operation of
repeated addition is applied, the palindrome number
4884 is obtained as shown below:
78
78+87= 165
165+561=726
726+627=1353

1353+3531=4884
Define a subroutine reverse that takes a natural
number with at most nine digits as its parameter a,
and returns the reverse of the number a through the
parameter x (the number obtained by reading the
digits of a from right to left). Using appropriate calls to
the reverse subroutine, generate a palindrome
number following the pattern above.
Implementation:
#include <iostream>
using namespace std;
void reverse(int a,int &x)
{
x=0;
while(a!=0)
{
x=x*10+a%10;
a=a/10;
}
}
int main()
{

int i,n,x,y;
cout<<"x=";
cin>>x;
reverse(x,y);
while(x!=y)
{
x=x+y;
reverse(x,y);
}
cout<<x;
return 0;
}
573.  Define a subprogram called prime that takes
a natural number parameter x of at most 4 digits and
returns the value 1 if x is a prime number, otherwise
returns the value 0. Using appropriate calls to the
prime subprogram, display:
a.  The prime numbers from a one-dimensional array v
that processes 100 natural numbers of at most four
digits each.
b.  The prime numbers from a two-dimensional array a
with 20 rows and 30 columns.

c.  The prime numbers from the file data.in
d.  The first and last prime numbers from the file
numbers.in. In case there are fewer than two prime
numbers in the file, display a message.
e.  The first n prime numbers.
f.  The largest prime number less than or equal to a
nonzero natural number x read from input.
g.  The nearest prime number to a nonzero natural
number x read from input.
Implementation:
#include <iostream>
#include <fstream>
#include <cmath>
using namespace std;
int prime(int x)
{
if(x==2)
return 1;

if(x<2 || x%2==0)
return 0;
int i;
for(i=3; i<=sqrt(x); i=i+2)
if(x%i==0)
return 0;
return 1;
}
int main()
{
///a)
ifstream f ("date.in");
int v[100],n,i,j,m;
bool ok=false;
f>>n;
for(i=1; i<=n; i++)
f>>v[i];
cout<<"Prime numbers from v:"<<endl;
for(i=1; i<=n; i++)
if(prime(v[i])==1)
{
cout<<v[i]<<" ";
ok=true;

}
if(ok==false)
cout<<"No prime numbers found!"<<endl;
///b)
ok=false;
int a[20][30];
f>>n>>m;
for(i=1; i<=n; i++)
for(j=1; j<=m; j++)
f>>a[i][j];
cout<<endl;
for(i=1; i<=n; i++)
for(j=1; j<=m; j++)
if(prime(a[i][j])==1)
{
cout<<a[i][j]<<" ";
ok=true;
}
if(ok==false)
cout<<"No prime numbers found!"<<endl;
///c)
int x;
while(f>>x)

if(prime(x)==1)
cout<<x<<" ";
///d)
int p=-1,u=-1;
while (f >> x)
{
if(prime(x)==1)
{
if (p==-1)
p = x; // Set the first prime number
u=x; // Update 'u' for each prime number encountered
}
}
if(p==-1)
cout<<"There is no prime number in the file";
else
cout<<"The 1st prime is: "<<p;
cout<<endl;
if(u==-1)
cout<<"There is no last prime number in the file";
else
cout<<"The last prime is: "<<u;
///e)

int n,i,x;
cout<<"n=";cin>>n;
i=1,x=2;
while(i<=n)
{
if(prime(x)==1)
{
cout<<x<<" ";
i++;
}
x++;
}
///f)
cout<<"x=";cin>>x;
while(prime(x)!=1)
x—;
cout<<x<<" ";
///g)
cout<<"x=";cin>>x;
i=2;
while(i<=x)
{
if(prime(x)==0)

i++;
if(i>x)
break;
}
cout<<i<<" ";
return 0;
}
574.  Two consecutive prime odd numbers are
called twin primes. Define a subprogram prime which
takes a natural number parameter x of at most 4 digits
and returns the value 1 if x is a prime number,
otherwise returns the value 0. Using appropriate calls
to the prime subprogram, display the first n pairs of
twin prime numbers.
Example: for n=4, display: (3,5), (5,7), (11,13),
(17,19).
Implementation:
#include <iostream>
#include <cmath>
using namespace std;
int prime(int x)
{
if(x==2)

return 1;
if(x<2 || x%2==0)
return 0;
int i;
for(i=3; i<=sqrt(x); i=i+2)
if(x%i==0)
return 0;
return 1;
}
int main()
{
int nr=1,i=3,n;
cout<<"n=";
cin>>n;
while(nr<=n)
{
if(prime(i)==1 && prime(i+2)==1)
{
cout<<"("<<i<<","<<i+2<<")"<<endl;
nr++;
}
i=i+2;
}

return 0;
}
575.  Define a subprogram sum_div that takes a
non-zero natural number with at most 8 digits as a
parameter. The subprogram returns the sum of the
divisors of the number n.
Two numbers m and n are called amicable numbers
if the sum of the divisors of m (excluding the value of
m itself) is equal to the value of n, and vice versa. For
example, m=220 and n=284 are amicable because
m=1+2+71+142 (sum of divisors of 284) and
n=1+2+4+5+10+11+20+22+44+55+110 (sum of
divisors of 220). Using calls to the sum_div
subprogram, display the first n pairs of amicable
numbers.
Implementation:
#include <iostream>
using namespace std;
int sum_div(int x)
{
int i,s=0;
for(i=1; i<x; i++)
if(x%i==0)

s=s+i;
return s;
}
int main()
{
int n,x,i=1;
cout<<"n=";cin>>n;
while(n>0)
{
i++;
x=sum_div(i);
if(sum_div(x)==i && x!=i)
{
n—;
cout<<x<<" and "<<i<<" are amicable numbers."
<<endl;
}
}
return 0;
}
576.  Define a subprogram reverse which takes a
natural number x of at most 9 digits as a parameter

and returns the reverse of x. Using appropriate calls to
the reverse subprogram, display:
a.  The palindrome numbers from a one-dimensional
array v that processes 100 natural numbers of at most
9 digits each.
b.  The palindrome numbers from a two-dimensional
array a with 20 rows and 30 columns.
c.  The palindrome numbers from the file data.in.
d.  The first and last palindrome numbers from the file
numbers.in. In case there are fewer than two
palindrome numbers in the file, display a message.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
ifstream f ("date.in");
int reverse(int x)
{
int y=0;

while(x!=0)
{
y=y*10+x%10;
x=x/10;
}
return y;
}
int main()
{
//a)
int v[100],n,i;
f>>n;
for(i=1; i<=n; i++)
{
f>>v[i];
cout<<v[i]<<" ";
}
cout<<endl;
for(i=1; i<=n; i++)
if(reverse(v[i])==v[i])
cout<<v[i]<<" ";
cout<<endl;
//b)

int a[20][30],j,m;
f>>n>>m;
for(i=1; i<=n; i++)
for(j=1; j<=m; j++)
f>>a[i][j];
for(i=1; i<=n; i++)
for(j=1; j<=m; j++)
if(reverse(a[i][j])==a[i][j])
cout<<a[i][j]<<" ";
cout<<endl;
//c)
int x;
while(f>>x)
if(reverse(x)==x)
cout<<x<<" ";
cout<<endl;
//d)
int p=-1,u=-1;
while(f>>x)
{
if(p==-1 && reverse(p)==p)
p=x;
if(u==-1 && reverse(u)==u)

u=x;
}
cout<<endl;
if(p==-1)
cout<<"There is no prime number in the file.";
else
cout<<"First prime is: "<<p;
if(u==-1)
cout<<"There is no prime number in the file.";
else
cout<<"The last prime is: "<<p;
return 0;
}
577.  Write the complete definition of a subroutine
called sub with one parameter. This subroutine
should:
- receive a natural number with at most 4 digits
through the parameter a (a>1)
- return the largest prime divisor of the parameter
value a.
Example: for a=26, the subroutine should return
the value 13.

Using appropriate calls to the subroutine sub,
display the prime numbers from the file data.in which
stores integer numbers, each with at most 4 digits.
Implementation:
#include <iostream>
#include <fstream>
#include <cmath>
using namespace std;
int prime(int x)
{
if(x==2)
return 1;
if(x<2 || x%2==0)
return 0;
int i;
for(i=3; i<=sqrt(x); i=i+2)
if(x%i==0)
return 0;
return 1;
}
int sub(int a)
{

int i,d;
for(i=2; i<=a; i++)
if(a%i==0 && prim(i)==1)
d=i;
return d;
}
int main()
{
ifstream f("date.in");
int x;
while(f>>x)
{
if(sub(x)==x)
cout<<x<<" ";
}
return 0;
}
578.  Define a subroutine calculate that receives a
natural number with at most nine digits through
parameter a and returns, through parameters x and z,
the largest and smallest digit of the number a
respectively. Using useful calls to the calculate
subroutine, determine:

a)  If a number a has all identical digits.
b)  For n numbers read, determine the range of
values that includes all the digits of the numbers read.
Example: for n=5 and the values: 6767, 56373,
45755, 333, 774, the pair 3, 7 is displayed.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
void calculate(int a, int &x, int &z)
{
int c;
x=-10000,z=10000;
while(a!=0)
{
c=a%10;
if(x<c)
x=c;
if(z>c)
z=c;
a=a/10;

}
}
int main()
{
///a)
int a,x,z;
cout<<"a=";
cin>>a;
calculate(a,x,z);
if(x==z)
cout<<"Number has all identical digits.;
else
cout<<"The number has different digits.";
cout<<endl;
///b)
ifstream f ("date.in");
int n,y,i,mini=9,maxi=0;
f>>n;
for(i=1; i<=n; i++)
{
f>>y;
calculate(y,x,z);
if(z<mini)

mini=z;
if(x>maxi)
maxi=x;
}
cout<<mini<<" "<<maxi;
return 0;
}

9.2 PROCESSING ONE –
DIMENSIONAL ARRAYS
579.  Define a subroutine called sub that takes the
following parameters: a one-dimensional array v that
stores 100 integer numbers, each with at most four
digits, a natural number n (n≤100) representing the
number of components in the array, and an integer x
with at most four digits. The subroutine returns the
number of components in v that are equal to x. Using
useful calls of the sub subroutine, determine:
a. If a value x is found in an array v using useful calls
of the sub subroutine.
b. If the array v has distinct components.
c. What are the values that appear with maximum
frequency in the array v.
d. Display each value in the array only once, and for
each value, display its frequency in the array.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int u[101];

int sub(int v[101],int n, int x)
{
int k=0,i;
for(i=1; i<=n; i++)
if(v[i]==x)
k++;
return k;
}
int main()
{
ifstream f("date.in");
int n,v[101],i,x;
f>>n;
for(i=1; i<=n; i++)
{
f>>v[i];
cout<<v[i]<<" ";
}
cout<<endl;
///——————————-
cout<<"x=";
cin>>x;
if(sub(v,n,x)>0)

cout<<x<<" is found in v.";
else
cout<<x<<" is not in v";
cout<<endl;
///———————-
int ok=1;
for(i=1; i<=n; i++)
if(sub(v,n,v[i])>1)
ok=0;
if(ok==1)
cout<<"Distinct values.";
else
cout<<"No distinct values.";
///—————————————
int fvmax=0,j;
for(i=1; i<=n; i++)
if(sub(v,n,v[i])>fvmax)
fvmax=sub(v,n,v[i]);
cout<<"Max frequency: "<<fvmax;
cout<<endl;
cout<<"The components with max frequency are: "
<<endl;
for(i=1; i<=n; i++)

if(u[i]==0 && sub(v,n,v[i])==fvmax)
{
cout<<v[i]<<" ";
for(j=i+1; j<=n; j++)
if(v[j]==v[i])
u[j]=1;
}
return 0;
}
580.  Define a subroutine sub which it receives as
parameters: a one-dimensional array v that stores 100
integers of at most four digits each, a natural number
n (n≤100) representing the number of components of
the array and an integer x of the four digits long. The
subroutine returns the number of components in v
equal to x . Using subroutine utility calls, determine
whether two one-dimensional arrays a and b with n
components (integers of at most four digits each)
store the same values.
Example: for a=(2,3,2,2,2,1,1) b=
(1,1,2,2,3,2,2) , n=7 displays YES .
Implementation:

#include <iostream>
#include <fstream>
using namespace std;
int sub(int v[101],int n,int x)
{
int i,k=0;
for(i=1; i<=n; i++)
if(v[i]==x)
k++;
return k;
}
int main()
{
ifstream f ("date.in");
int n,a[101],b[101],x,y,i;
f>>n;
for(i=1; i<=n; i++)
{
f>>a[i];
cout<<a[i]<<" ";
}
cout<<endl;
for(i=1; i<=n; i++)

{
f>>b[i];
cout<<b[i]<<" ";
}
cout<<endl;
int j,ok=1;
for(x=1; x<=9999; x++)
for(j=1; j<=n; j++)
if(sub(a,n,x)!=sub(b,n,x))
ok=0;
if(ok==1)
cout<<"Da";
else
cout<<"Nu";
return 0;
}
581.  Define a subprogram sub which it receives as
parameters: a one-dimensional array v that stores 100
integers of at most four digits each, a natural number
n (n≤100) representing the number of components of
the array and an integer x of at most four digits. The
subroutine returns the number of components in v

smaller than x . Using subroutine utility calls to
determine:
a. If an array v has distinct components.
b. What is the minimum value in the array.
c. What is the maximum value in the array.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int sub(int v[101],int n,int x)
{
int k=0,i;
for(i=1; i<=n; i++)
if(v[i]<x)
k++;
return k;
}
void order(int v[101],int n)
{
int i,j,aux;
for(i=1; i<n; i++)
for(j=i+1; j<=n; j++)

if(v[i]>v[j])
{
aux=v[i];
v[i]=v[j];
v[j]=aux;
}
}
int main()
{
ifstream f("date.in");
int v[101],n,i,ok=1;
f>>n;
for(i=1; i<=n; i++)
f>>v[i];
order(v,n);
for(i=2; i<=n; i++)
if(sub(v,n,v[i])!=i-1)
ok=0;
if(ok==1)
cout<<"Distinct values";
else
cout<<"No distinct values.";
///———————————-

cout<<endl;
int mini=10000;
for(i=1;i<=n;i++)
if(sub(v,n,v[i])==0)
mini=v[i];
cout<<"Minimum value is: "<<mini<<endl;
cout<<endl;
int maxi=-10000;
for(i=1;i<=n;i++)
if(sub(v,n,v[i])==n-1)
maxi=v[i];
cout<<"Maximum value is: "<<maxi<<endl;
return 0;
}
582.  Define:
a. A subroutine poz that receives as parameters: a
one-dimensional array v that stores 100 integers of
at most four digits each, a natural number n
(n≤100) representing the number of components
of the array and an integer x of at most four digits
. The subroutine returns the index of the first
component of v greater than x or -1 if all
components of v have values less than x .

b. An insertion subroutine that has as parameters:
a one-dimensional array v that stores 100 integers
of at most four digits each, a natural number n
(n≤100) representing the number of components
of the array, an integer p (p≤n) representing the
index of a component of v and an integer x of at
most four digits. The subroutine inserts the value x
at position p in the array v , updating the number
of components n.
Write a program that reads the n integers of at
most four digits each and that, using useful calls of the
subroutines poz and insert , stores them in ascending
order in the components of an array v.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int poz(int v[101],int n,int x)
{
int poz=-1,i;
for(i=1; i<=n; i++)
if(v[i]>x)
{

poz=i;
break;
}
return poz;
}
void insertion(int v[101],int &n,int p,int x)
{
int i;
n++;
for(i=n; i>=p+1; i—)
v[i]=v[i-1];
v[p]=x;
}
void display(int v[101],int n)
{
int i;
for(i=1; i<=n; i++)
cout<<v[i]<<" ";
cout<<endl;
}
int v[101];
int main()
{

ifstream f("date.in");
int n,i,p,a,nn=1;
f>>n;
f>>v[1];
for(i=2; i<=n; i++)
{
f>>a;
p=poz(v,nn,a);
if(p==-1)
insertion(v,nn,nn+1,a);
else
insertion(v,nn,p,a);
}
display(v,nn);
return 0;
}
583.  Define a subroutine sub that takes the
following parameters: a one-dimensional array v that
stores 100 integer numbers, each with at most four
digits, a natural number n (n≤100) representing the
number of components in the array, and an integer x
with at most four digits. The subroutine returns the
value 1 if the value x is found in the array v otherwise

it returns the value 0. Let a and b be two one-
dimensional arrays with m and n distinct components
respectively (integer numbers with at most four
digits). Using useful calls to the subroutine sub,
determine:
a) The intersection of two sets stored in arrays a and
b.
b) The difference of two sets stored in arrays a and b.
c) The union of two sets stored in arrays a and b.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int sub(int v[101],int n,int x)
{
int i;
for(i=1; i<=n; i++)
if(v[i]==x)
return 1;
return 0;
}

int main()
{
ifstream f("date.in");
int a[101],b[101],m,n,i,j;
f>>m>>n;
for(i=1; i<=m; i++)
{
f>>a[i];
cout<<a[i]<<" ";
}
cout<<endl;
for(i=1; i<=n; i++)
{
f>>b[i];
cout<<b[i]<<" ";
}
cout<<endl<<"Intersection: ";
for(i=1; i<=n; i++)
if(sub(a,m,b[i])==1)
cout<<b[i]<<" ";
cout<<endl<<"Difference: ";
for(i=1; i<=n; i++)
if(sub(a,m,b[i])==0)

cout<<b[i]<<" ";
cout<<endl<<"Union: ";
for(i=1; i<=m; i++)
cout<<a[i]<<" ";
for(i=1; i<=n; i++)
if(sub(a,m,b[i])==0)
cout<<b[i]<<" ";
return 0;
}
584.  Define:
a. A sub1 subprogram that receives as parameters: a
one-dimensional array v that stores 100 integers of
at most four digits each and a natural number n
(n≤100) representing the number of components
of the array. The subroutine performs the left
circular permutation of the array components.
Example: if v=(1,2,3,4,5,6) and n=6 after calling
v=(2,3,4,5,6,1).
a. A sub2 subprogram that receives as parameters:
two one-dimensional arrays a and b that store 100
integers of at most four digits each and a natural
number n (n≤100) representing the number of

components for each of the arrays. The subroutine
returns the value 1 if the two arrays store the same
values in the same order, otherwise it returns the
value 0.
Example: for a=(6, 9, 4), b=(6, 9, 4), n=3, sub2
returns the value 1.
Let a and b be two one-dimensional arrays with n
components each (integers of at most four digits).
Using useful calls of subroutines subl and sub2,
determine: if the array b can be obtained from the
array a by a sequence of circular permutations of the
elements of the array a.
Example: for a=(6, 9, 4, 3, 1), b=(3, 1, 6, 9, 4) it
displays YES.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
void sub1(int v[100],int n)
{
int aux,i;
aux=v[1];
for(i=1; i<n; i++)

v[i]=v[i+1];
v[n]=aux;
}
int sub2(int a[100],int b[100],int n)
{
int i,j;
for(i=1; i<=n; i++)
if(a[i]!=b[j])
return 0;
return 1;
}
int main()
{
ifstream f ("data.in");
int a[100],b[100],n,i,ok=0;
f>>n;
for(i=1; i<=n; i++)
{
f>>a[i];
cout<<a[i]<<" ";
}
cout<<endl;
for(i=1; i<=n; i++)

{
f>>b[i];
cout<<b[i]<<" ";
}
cout<<endl;
for(i=1;i<=n;i++)
{
sub1(a,n);
if(sub2(a,b,n)==1)
ok=1;
}
if(ok==0)
cout<<"Yes";
else
cout<<"No";
return 0;
}
585.  Define:
a. A sub1 subprogram that receives as parameters: a
one-dimensional array v that stores 100 integers of
at most four digits each and a natural number n
(n≤100) representing the number of components

of the array. The subroutine returns by parameter p
the index of the first even value in the array v .
Example: if v=(11,24,3,4,51,6) and n=6 after call
p=2.
a. a sub2 subroutine that receives as parameters: a
one-dimensional array v that stores 100 integers of
at most four digits each and a natural number n
(n≤100) representing the number of components
of the array. The subroutine returns by parameter q
the index of the last odd value in the array v .
Example: if v=(11,24,3,4,51,6) and n=6 after call
q=5.
Using utility calls of subroutines subl and sub2 ,
move to the beginning
of array v the odd numbers and at the end the even
values.
Example: for v=(11,24,3,4,51,6,8,33) a solution
can be: v=(11,33,3,51,6,8,4,24).
Implementation:
#include <iostream>
#include <fstream>
using namespace std;

void sub1(int v[101],int n,int &p)
{
p=1;
while(v[p]%2==1)
p++;
}
void sub2(int v[101],int n,int &q)
{
q=n;
while(v[q]%2==0)
q—;
}
int main()
{
ifstream f("data.in");
int v[101],n,i,p,q,aux;
f>>n;
for(i=1; i<=n; i++)
f>>v[i];
sub1(v,n,p);
cout<<p<<endl;
sub2(v,n,q);
cout<<q<<endl;

cout<<endl<<q<<endl;
sub1(v,n,p);
sub2(v,n,q);
while(p<q)
{
aux=v[p];
v[p]=v[q];
v[q]=aux;
sub1(v,n,p);
sub2(v,n,q);
}
for(i=1;i<=n;i++)
cout<<v[i]<<" ";
return 0;
}
586.  Write the complete definitions of the
subprograms
a. delete, which receives three parameters: v, n, p:
v, a one-dimensional array with a maximum of 100
integer elements in the range [-1000,1000].
n, a natural number representing the number of
elements in array v.

p, a natural value with 1≤p≤n.
And it removes the element at index p from array
v, updating the value of parameter n.
a. count, which receives three parameters: v, n, x:
v, a one-dimensional array with a maximum of 100
integer elements in the range [-1000;1000].
n, a natural number representing the number of
elements in array v.
x, an integer value within the range [-1000;1000].
And it returns the number of components in v with
a value equal to x.
Using useful calls to the delete and count
subprograms, eliminate duplicate values from an array
v so that each value appears in the array only once.
Example: For v=(1, 2, 7, 2, 3, 7, 2) after the calls,
it will store the values 1, 2, 3, 7 not necessarily in this
order.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;

void delete(int v[100],int &n,int p)
{
int i;
for(i=p; i<=n-1; i++)
v[i]=v[i+1];
n=n-1;
}
int count(int v[100],int n,int x)
{
int i,k=0;
for(i=1;i<=n;i++)
if(v[i]==x)
k++;
return k;
}
int main()
{
ifstream f ("date.in");
int v[100],n,i;
f>>n;
for(i=1;i<=n;i++)
{
f>>v[i];

cout<<v[i]<<" ";
}
cout<<endl;
for(i=n;i>=1;i—)
{
if(count(v,n,v[i])>1)
delete(v,n,i);
}
for(i=1;i<=n;i++)
cout<<v[i]<<" ";
return 0;
}
587.  Write the complete definition of the
subprogram processing, which receives the following
6 parameters: v, w, p1, p2, q1, q2:
v, w are two one-dimensional arrays with a
maximum of 100 integer elements each, within the
range (-1000;1000].
p1, p2, q1, q2 are natural numbers within the
range [1,100]. It returns the value 1 if the values of
the components in v with indices between p1 and
p2 are equal to the values of the components in w

with indices between q1 and q2, otherwise it
returns the value 0.
Using useful calls to the processing subprogram,
determine if there exists a sequence of consecutive
values in a one-dimensional array a with m
components (m≤100) that are equal to the elements
in a one-dimensional array b with n components
(n≤m). Display YES or NO.
Example: For a = (2, 4, 5, 1, 9, 7, 8, 2, 10) and b
= (5, 1, 9, 7), the output is YES.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int processing(int v[100],int w[100],int p1,int p2,int q1,int
q2)
{
int i,j,n,m,ok=1;
for(i=p1,j=q1; i<=p2; i++,j++)
if(v[i]!=w[j])
ok=0;
return ok;
}

int main()
{
ifstream f ("data.in");
int a[100],b[100],m,n,i,j,ok=0;
f>>m>>n;
for(i=1; i<=m; i++)
{
f>>a[i];
cout<<a[i]<<" ";
}
cout<<endl;
for(j=1; j<=n; j++)
{
f>>b[j];
cout<<b[j]<<" ";
}
cout<<endl;
for(i=1; i<=(m-n)+1; i++)
if(processing(a,b,i,m,j,n)==1)
ok=1;
if(ok==0)
cout<<"Yes";
else

cout<<"No";
return 0;
}
588.  Write the definition of the subprogram
delete, which receives the following 3 parameters v,
n, p:
v, a one-dimensional array with a maximum of 100
integer elements within the range [-1000;1000]
n, a natural number representing the number of
elements in array v.
p, a natural value with 1≤p≤n, and it removes the
element at index p from array v, updating the
value of parameter n.
Given a one-dimensional array a that stores a
maximum of 100 integer elements in the range
[-1000;1000], sorted in ascending order. Write a
program that uses useful calls to the delete
subprogram to remove the minimum number of
elements from the array so that no two adjacent
elements have the same value. Display the elements
of the resulting array on the screen, separated by a
space.

Example: For v=(1, 2, 2, 2, 7, 7, 8, 9, 9, 9), it will
display: 1, 2, 7, 8, 9.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
void delete(int v[100],int &n,int p)
{
int i;
for(i=p; i<=n-1; i++)
v[i]=v[i+1];
n=n-1;
}
int countElements(int v[100],int n,int x)
{
int i,k=0;
for(i=1;i<=n;i++)
if(v[i]==x)
k++;
return k;
}
int main()

{
ifstream f ("data.in");
int a[100],i,n;
f>>n;
for(i=1;i<=n;i++)
{
f>>a[i];
cout<<a[i]<<" ";
}
cout<<endl;
for(i=1;i<=n;i++)
if(countElements(a,n,a[i])>1)
delete(a,n,i);
for(i=1;i<=n;i++)
cout<<a[i]<<" ";
return 0;
}
589.  Define:
a. a calculation subroutine that takes a natural
number with at most nine digits as parameter a
and returns the largest and smallest digits of the
number through parameters x and z, respectively.

b. a modification subroutine that takes a natural
number with at most nine digits, and two digits c1
and c2 as parameters. The subroutine replaces the
digit c1 with the digit c2 and returns the result
through parameter a.
Let v be an array that can store up to 100 natural
numbers, each with at most 9 digits. Using appropriate
calls to the calculation and modification
subroutines, generate the array w obtained from the
components of array v such that for each component,
the digits with the smallest value are replaced with the
digit with the largest value.
Example: for n=5 and values: v =(16767,
5632273, 45755, 3313, 774) the resulting w=(76767,
5637773, 75755, 3333, 777).
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
void calculation(int a,int &x,int &z)
{
int c;

x=0,z=9;
while(a!=0)
{
c=a%10;
if(x<c)
x=c;
if(z>c)
z=c;
a=a/10;
}
}
void modification(int &a,int c1,int c2)
{
int p=1,x=0;
while(a>0)
{
if(a%10==c1)
x=x+c2*p;
else
x=x+(a%10)*p;
p=p*10;
a=a/10;
}

a=x;
}
int main()
{
ifstream f("data.in");
int v[100],w[100],i,n,x=0,z=9;
f>>n;
for(i=1; i<=n; i++)
{
f>>v[i];
cout<<v[i]<<" ";
}
cout<<endl;
for(i=1;i<=n;i++)
{
calculation(v[i],x,z);
w[i]=v[i];
modification(w[i],z,x);
}
for(i=1;i<=n;i++)
cout<<w[i]<<" ";
return 0;
}

590.  Define:
a. A subroutine gcd with parameters x and y, which
are non-zero natural numbers with at most 4 digits
each. The subroutine returns the greatest common
divisor of the values x and y.
b. b) A subroutine lcm with parameters `x` and `y`,
which are non-zero natural numbers with at most 4
digits each. The subroutine returns the least
common multiple of the values `x` and `y`.
Let `v` be a one-dimensional array that stores at
most 100 natural numbers, each with at most 4 digits.
Using useful calls to the `gcd` and `lcm` subroutines,
determine:
a) The greatest common divisor of the components
of the array `v`.
b) The least common multiple of the components of
the array `v`.
c) Display the pairs of prime numbers from the
array `v`.
Implementation:
#include <iostream>
#include <fstream>

using namespace std;
int gcd(int x,int y)
{
int r;
while(x%y!=0)
{
r=x%y;
x=y;
y=r;
}
return y;
}
int lcm(int x,int y)
{
return (x*y)/cmmdc(x,y);
}
int main()
{
ifstream f ("data.in");
int v[100],n,i,x,y;
f>>n;
for(i=1; i<=n; i++)
{

f>>v[i];
cout<<v[i]<<" ";
}
cout<<endl;
x=v[1];
for(i=2; i<=n; i++)
{
y=v[i];
x=gcd(x,y);
}
cout<<x<<" "<<endl;
x=v[1];
for(i=2; i<=n; i++)
{
y=v[i];
x=lcm(x,y);
}
cout<<x<<" "<<endl;
for(i=2;i<=n;i++)
{
if(gcd(v[i-1],v[i])==1)
cout<<v[i-1]<<" "<<v[i]<<endl;
}

return 0;
}
591.  Consider a one-dimensional array `v` with `n`
(n≤50) integer components. For a natural number `k`
read from the keyboard (k≤n), order the first `k`
components in ascending order and the remaining
components in descending order. Define a subroutine
for reading `v` and a subroutine that sorts the
components of a one-dimensional array delimited by
two indices `p` and `q` in ascending order.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
ifstream f ("data.in");
int v[100],k,j,i,n;
void read()
{
f>>n;
for(i=1; i<=n; i++)
f>>v[i];
}
void ord_asc(int v[100],int p,int q)

{
int aux;
for(i=p; i<q; i++)
for(j=i+1; j<=q; j++)
if(v[i]>v[j])
{
aux=v[i];
v[i]=v[j];
v[j]=aux;
}
}
int main()
{
read();
for(i=1; i<=n; i++)
cout<<v[i]<<" ";
cout<<endl;
cout<<"k=";
cin>>k;
ord_asc(v,1,k);
for(i=1; i<=n; i++)
cout<<v[i]<<" ";
return 0;

}
592.  Consider a one-dimensional array `v` with `n`
(n≤50) integer components. Determine the
components of the array with the most divisors. Define
a subroutine for reading the array and another one for
calculating the number of divisors of an integer `x`.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int v[50],i,n,maxi=-1;
ifstream f ("data.in");
void read()
{
f>>n;
for(i=1; i<=n; i++)
f>>v[i];
}
int countDivisors(int x)
{
int i;
int nr=0;
for(i=1; i<=x; i++)

if(x%i==0)
nr++;
return nr;
}
int main()
{
read();
for(i=1; i<=n; i++)
cout<<v[i]<<" ";
cout<<endl;
for(i=1; i<=n; i++)
if(countDivisors(v[i])>maxi)
maxi= countDivisors(v[i]);
for(i=1; i<=n; i++)
if(maxi== countDivisors(v[i]))
cout<<v[i]<<" ";
return 0;
}

9.3 PROCESSING TWO –
DIMENSIONAL ARRAYS
593.  Define a subroutine `sorting` which takes as
parameters a two-dimensional array `a` with 20 rows
and 30 columns storing integers, a number `n`
representing the number of columns, and a natural
number `L` (L≤20). The subroutine sorts the elements
on row `L` in ascending order. Using useful calls to the
`sorting` subroutine, sort the elements on each row of
a two-dimensional array with `m` (m≤20) rows and
`n` (n≤30) columns. Display the modified array.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
ifstream f ("data.in");
int a[20][30],i,j,m,n;
void sorting(int a[20][30],int n , int L)
{
int i,j,aux;
for(i=1; i<=n-1; i++)
for(j=i+1; j<=n; j++)

if(a[L][i]>a[L][j])
{
aux=a[L][i];
a[L][i]=a[L][j];
a[L][j]=aux;
}
}
int main()
{
f>>m>>n;
for(i=1; i<=m; i++)
for(j=1; j<=n; j++)
f>>a[i][j];
for(i=1; i<=m; i++)
{
for(j=1; j<=n; j++)
cout<<a[i][j]<<" ";
cout<<endl;
}
cout<<endl;
for(i=1; i<=m; i++)
sorting(a,n,i);
for(i=1; i<=m; i++)

{
for(j=1; j<=n; j++)
cout<<a[i][j]<<" ";
cout<<endl;
}
return 0;
}
594.  Define a subroutine `calculate` which takes
as parameters a two-dimensional array `a` with 20
rows and 30 columns storing integers, a number `n`
representing the number of columns, and a natural
number `L` (L≤20). The subroutine returns the
maximum value of the elements on row `L`. Using
useful calls to the `calculate` subroutine, display the
maximum value on each row of a two-dimensional
array with `m` (m≤20) rows and `n` (n≤30) columns.
Display the smallest of the values displayed earlier.
Implementation:
#include <iostream>
using namespace std;
int a[20][30];
int calculateMax(int a[20][30], int n, int L)
{

int maxi=-1;
for(int i=0; i<n; i++)
if(a[L][i]>maxi)
maxi=a[L][i];
return maxi;
}
int main()
{
int m,n;
cout<<"Enter the number of rows and columns: ";
cin>>m>>n;
cout<<"Enter the elements of the 2D array:"<<endl;
for(int i=0; i<m; i++)
for(int j=0; j<n; j++)
cin>>a[i][j];
cout<<"The 2D array:"<<endl;
for(int i=0; i<m; i++)
{
for(int j=0; j<n; j++)
{
cout<<a[i][j]<<" ";
}
cout<<endl;

}
int maxValues[m];
for(int i=0; i<m; i++)
maxValues[i]=calculateMax(a,n,i);
cout<<"Maximum values on each row:"<<endl;
for (int i=0; i<m; i++)
cout<<maxValues[i]<<" ";
cout<<endl;
int minValue=maxValues[0];
for(int i = 1; i < m; i++)
if(maxValues[i]<minValue)
minValue=maxValues[i];
cout<<"Smallest of the maximum values: "
<<minValue<<endl;
return 0;
}
595.  Define a subroutine `calculate` which takes
as parameters a two-dimensional array `a` with 20
rows and 30 columns storing numbers, a number `n`
representing the number of columns, and a natural
number `L` (L≤20). The subroutine returns the sum of
the elements on row `L`. Using useful calls to the
`calculate` subroutine, display the sum of the

elements on each row of a two-dimensional array with
`m` (m≤20) rows and `n` (n≤30) columns. Display the
indices of the rows with the maximum sum.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
ifstream f ("date.in");
int a[20][30],i,j,m,n,maxi=-1;
int calculate(int a[20][30],int n , int L)
{
int s=0,i;
for(i=1; i<=n; i++)
s=s+a[L][i];
return s;
}
int main()
{
f>>m>>n;
for(i=1; i<=m; i++)
for(j=1; j<=n; j++)
f>>a[i][j];
for(i=1; i<=m; i++)

{
for(j=1; j<=n; j++)
cout<<a[i][j]<<" ";
cout<<endl;
}
cout<<endl;
for(i=1; i<=m; i++)
cout<<calculate(a,n,i)<<" ";
cout<<endl;
for(i=1; i<=m; i++)
if(calculate(a,n,i)>maxi)
maxi=calculate(a,n,i);
for(i=1; i<=m; i++)
if(maxi==calculate(a,n,i))
cout<<i<<" ";
return 0;
}
596.  Define a subroutine `deleteL` which takes as
parameters a two-dimensional array `a` with 20 rows
and 30 columns storing integers, two numbers `m`
and `n` representing the number of rows and columns
respectively, and a natural number `L` (L≤20). The
subroutine deletes the elements on row `L` and

updates the number of rows. Using useful calls to the
`deleteL` subroutine, delete the elements on odd-
numbered rows of a two-dimensional array with `m`
(m≤20) rows and `n` (n≤30) columns.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
ifstream f ("data.in");
int a[20][30],i,j,m,n,k;
void deleteL(int a[20][30],int &m,int n,int L)
{
int i,j,k;
for(k=L; k<=m-1; k++)
for(j=1; j<=n; j++)
a[k][j]=a[k+1][j];
m—;
}
int main()
{
f>>m>>n;
for(i=1; i<=m; i++)
for(j=1; j<=n; j++)

f>>a[i][j];
for(i=m; i>=1; i—)
if(i%2==1)
deleteL(a,m,n,i);
for(i=1; i<=m; i++)
{
for(j=1; j<=n; j++)
cout<<a[i][j]<<" ";
cout<<endl;
}
return 0;
}
597.  Define a subroutine `calculate` which takes
as parameters a two-dimensional array `a` with 50
rows and 50 columns storing integers, a number `m`
representing the number of rows, an integer `x`, and a
natural number `C` (C≤20). The subroutine returns the
number of values on column C in the array a that are
equal to the value x. Using useful calls to the
`calculate` subroutine, display the indices of the
columns with the maximum product in a two-
dimensional array with `m` (m≤50) rows and `n`

(n≤50) columns that only stores values equal to 1 or
2.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
ifstream f("data.in");
int a[50][50],i,j,m,n,k,maxi=-1;
int calculate(int a[50][50],int m,int x,int C)
{
int i,j,k=0;
for(i=1; i<=m; i++)
if(a[i][C]==x)
k++;
return k;
}
int main()
{
f>>m>>n;
for(i=1; i<=m; i++)
for(j=1; j<=n; j++)
f>>a[i][j];
for(j=1; j<=n; j++)

if(calculate(a,m,2,j)>maxi)
maxi=calculate(a,m,2,j);
for(j=1; j<=n; j++)
if(maxi==calculate(a,m,2,j))
cout<<j<<" ";
return 0;
}
598.  Define a subroutine `sub` which takes as
parameters: a two-dimensional array `a` storing 20
rows and 20 columns, each with at most four digits,
two non-zero natural numbers `m` (m≤20) and `n`
(n≤20) representing the actual number of rows and
columns of array `a`, and an integer `x` with at most
four digits. The subroutine returns the number of
components in `a` that are equal to `x`. Using useful
calls to the `sub` subroutine, determine if two two-
dimensional arrays `a` and `b` with `m` rows and `n`
columns processing integers with at most four digits
each, store the same values.
Example: For 
Implementation:
#include <iostream>

#include <fstream>
using namespace std;
ifstream f("data.in");
int a[20][20],b[20][20],i,j,m,n,k,ok;
int sub(int a[20][20],int m,int n,int x)
{
int i,j,k=0;
for(i=1; i<=m; i++)
for(j=1; j<=n; j++)
if(a[i][j]==x)
k++;
return k;
}
int main()
{
f>>m>>n;
for(i=1; i<=m; i++)
for(j=1; j<=n; j++)
f>>a[i][j];
for(i=1; i<=m; i++)
for(j=1; j<=n; j++)
f>>b[i][j];
ok=1;

for(i=1;i<=m;i++)
for(j=1;j<=n;j++)
if(sub(a,m,n,a[i][j])!=sub(b,m,n,a[i][j]))
ok=0;
if(ok==1)
cout<<"YES";
else
cout<<"NO";
return 0;
}
599.  Define a subroutine `change` which takes as
parameters: a two-dimensional array `a` with 20 rows
and 20 columns storing integers with at most four
digits, three non-zero natural numbers `m` (m≤20),
`c1` (c1≤20), and `c2` (c2≤20) representing the
actual number of rows, and the order numbers of two
columns in array `a`. The subroutine swaps the values
of the components on column `c1` with the values on
column `c2`. Using useful calls to the `change`
subroutine, sort the elements in ascending order on
row `x` of a two-dimensional array `a` with `m` rows
and `n` columns processing integers with at most four

digits each, exchanging the values of the columns as
shown in the example.
Example:
For 
we get: 
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
ifstream f("date.in");
int a[20][20],i,j,m,x;
void change(int a[20][20],int m,int c1,int c2)
{
int aux;
for(i=1; i<=m; i++)
{
aux=a[i][c1];
a[i][c1]=a[i][c2];
a[i][c2]=aux;
}

}
int main()
{
f>>m;
for(i=1; i<=m; i++)
for(j=1; j<=m; j++)
f>>a[i][j];
cout<<"x=";
cin>>x;
for(i=x;i<=m;i++)
change(a,m,m,x);
for(i=1; i<=m; i++)
{
for(j=1; j<=m; j++)
cout<<a[i][j]<<" ";
cout<<endl;
}
return 0;
}
600.  Define a subroutine `square` which takes as
parameters: a square matrix `a` with 20 rows and 20
columns storing integers with at most four digits, and
a natural number `c` (c≤20) representing the order

number of a concentric square within the array. For
example, if c=1, then the concentric square stores the
elements from the first and last rows, as well as the
first and last columns. For c=2, it processes the
elements from the second row, second column,
penultimate row, and penultimate column, and so on.
The subroutine returns the sum of the values of the
components on column `c` of the concentric square.
Using useful calls to the `square` subroutine, display
the values of the components of the concentric square
with the highest sum from a square matrix `a` with
`n` rows and `n` columns processing integers with at
most four digits each. In case there are multiple
squares with the highest sum, display the one with the
smallest order number. Display the elements of the
concentric square in a clockwise direction, starting
from the top-left element.
Example:
For: 
, it displays: 9, 8, 9, 34 (values of
the 2nd concentric square).
Implementation:
#include <iostream>

#include <fstream>
using namespace std;
ifstream f("date.in");
int a[20][20],i,j,n,c;
int square(int a[20][20],int n,int c)
{
//1st concentric square
int concentric_square[400]={0};
int maxi=-1;
for(int k=1;k<=(n+1)/2;k++)
{
for(j=k;j<=n-k+1;j++) concentric_square[k]+=a[k]
[j];//1st line
for(i=k+1;i<=n-k+1;i++) concentric_square[k]+=a[i][n-
k+1]; //nth column
for(i=n-k;i>=k;i—) concentric_square[k]+=a[n-k+1]
[i];//nth line
for(i=n-k; i>k;i—) concentric_square[k]+=a[i][k]; //1st
column
}
for(i=1;i<=(n+1)/2;i++)
if(concentric_square[i]>maxi)
maxi=concentric_square[i];

for(i=1;i<=(n+1)/2;i++)
if(concentric_square[i]==maxi)
c=i;
return c;
}
int main()
{
f>>n;
for(i=1; i<=n; i++)
for(j=1; j<=n; j++)
f>>a[i][j];
cout<<square(a,n,c);
return 0;
}
601.  Consider a two-dimensional array `a` with
`m` rows and `n` columns (1≤m, n≤20) consisting of
binary components. Each row represents the binary
representation of a natural number. Display these
numbers, the largest number, and the index of the
row(s) that determine the number with the highest
value. Define a subroutine that takes as parameters: a
two-dimensional array `a` as described above, the

number of columns `n`, and the index of a row `L`,
and returns the associated decimal number.
Example:
For: 
5 11 3 4 – the four numbers
11 – the greatest value
2 – the line which contains the greatest value
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
ifstream f("date.in");
int a[20][20],i,j,n,L;
void sub(int a[20][20],int n,int &L)
{ 
int y,power,maxi=-1;
for(i=1;i<=n;i++)
{ 
y=0,power=1;
for(int j=1;j<=n;j++)
{

int c=a[i][j];
y+=c*power;
power*=2;
}
cout<<y<<" ";
if(y>maxi)
{
maxi=y;
L=i;
}
}
cout<<"Maximum: "<<maxi;
cout<<"The line which contains the max value: "<<L;
}
int main()
{
f>>n;
for(i=1; i<=n; i++)
for(j=1; j<=n; j++)
f>>a[i][j];
sub(a,n,L);
return 0;
}

602.  Write the definition of a subroutine `swapC`
which takes as parameters:
- a two-dimensional array `a` with `m` rows and `n`
columns (1≤m, n≤20) consisting of integer
components.
- the number `m` representing the actual number
of rows in array `a`.
- two non-zero natural numbers `c1` and `c2`
representing the indices of two columns.
The subroutine swaps the elements of column `c1`
with the elements of column `c2`.
Using useful calls to the `swapC` subroutine, transfer
the first `p` columns to the end of the array.
Example:
For 
Implementation:
#include <iostream>
#include <fstream>

using namespace std;
void swapC(int a[20][20],int m,int c1,int c2)
{ 
int aux,i;
for(i=1;i<=m;i++)
{
aux=a[i][c1];
a[i][c1]=a[i][c2];
a[i][c2]=aux;
}
}
void display(int a[20][20],int m,int n)
{ 
int i,j;
for(i=1; i<=m; i++)
{
for(j=1; j<=n; j++)
cout<<a[i][j]<<" ";
cout<<endl;
}
cout<<endl;
}
int main()

{ 
ifstream f("data.in");
int a[20][20],i,j,m,n,p;
f>>m>>n;
for(i=1; i<=m; i++)
for(j=1; j<=n; j++)
f>>a[i][j];
cout<<"p=";
cin>>p;
while(p!=0)
{ 
for(i=p; i<=m; i++)
swapC(a,m,i,i+1);
p—;
}
display(a,m,n);
return 0;
}
603.  Define:
a. a subroutine `calculate1` which takes as
parameters a two-dimensional array `a` with 20
rows and 30 columns storing integers, a number
`n` representing the actual number of columns,

and a natural number `L` (L≤20). The subroutine
returns the sum of the elements on row `L`.
b. a subroutine `calculate2` which takes as
parameters a two-dimensional array `a` with 20
rows and 30 columns storing integers, a number
`n` representing the actual number of rows, and a
natural number `C` (C≤20). The subroutine returns
the sum of the elements on column `C`.
Using useful calls to these two subroutines, extend
the matrix with row `m+1` and column `n+1` where
`a[m+1,j]` represents the sum of the elements in
column `j`, and `a[i,n+1]` represents the sum of the
elements in row `i` of a two-dimensional array with
`m` (m≤20) rows and `n` (n≤30) columns.
Example:
For 
.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int calculate1(int a[20][30],int n,int L)
{ 

int s=0;
for(int i=1;i<=n;i++)
s=s+a[L][i];
return s;
}
int calculate2(int a[20][30],int m,int C)
{ 
int s=0;
for(int i=1;i<=m;i++)
s=s+a[i][C];
return s;
}
void display(int a[20][30],int m,int n)
{ 
int i,j;
for(i=1; i<=m; i++)
{
for(j=1; j<=n; j++)
cout<<a[i][j]<<" ";
cout<<endl;
}
cout<<endl;
}

int main()
{ 
ifstream f("data.in");
int a[20][30],i,j,m,n,p;
f>>m>>n;
for(i=1; i<=m; i++)
for(j=1; j<=n; j++)
f>>a[i][j];
display(a,m,n);
m++;
for(i=1;i<=m;i++)
a[m][i]=calculate2(a,m,i);
n++;
for(i=1;i<=n;i++)
a[i][n]=calculate1(a,n,i);
display(a,m,n);
return 0;
}
604.  Define a subroutine `calculate` which takes
as parameters a two-dimensional array `a` with 20
rows and 20 columns storing integers, a number `n`
representing the actual number of columns, a natural
number `L` (L≤20), and an integer `x`. The subroutine

returns the number of values equal to `x` on row `L`.
Using calls to the `calculate` subroutine, display the
rows with the maximum number of non-zero values for
an array `a` with `m` rows and `n` columns (m,n≤20).
Example:
For : 
 the program displays 1 and 3.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int calculate(int a[21][21],int n,int L,int x)
{ 
int j,k=0;
for(j=1;j<=n;j++)
if(a[L][j]==x)
k++;
return k;
}
int main()
{
ifstream f("data.in");

int a[21][21],m,n,i,j;
int min[21]={21};
f>>m>>n;
for(i=1;i<=m;i++)
for(j=1;j<=n;j++)
f>>a[i][j];
for(i=1;i<=m;i++)
min[i]=calculate(a,n,i,0);
int minim=21;
for(i=1;i<=m;i++)
if(min[i]<minim)
minim=min[i];
for(i=1;i<=m;i++)
if(min[i]==minim)
cout<<i<<" ";
return 0;
}
605.  Define a subroutine `calculate` which takes
as parameters a two-dimensional array `a` with 20
rows and 20 columns storing integers, a number `n`
representing the actual number of columns, a natural
number `L` (L≤20), and an integer `x`. The subroutine
returns the number of values equal to `x` on row `L`.

Using calls to the `calculate` subroutine, display the
rows with the maximum number of distinct values
(values that occur only once) for an array `a` with `m`
rows and `n` columns (m,n≤20).
Example:
for 
 the program outputs 1 şi 3.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int calculate(int a[21][21],int n,int L,int x)
{ 
int j,k=0;
for(j=1;j<=n;j++)
if(a[L][j]==x)
k++;
return k;
}
int main()
{
ifstream f("data.in");

int a[21][21],m,n,i,j;
int s[21]={0};
f>>m>>n;
for(i=1;i<=m;i++)
for(j=1;j<=n;j++)
f>>a[i][j];
for(i=1;i<=m;i++)
{
for(j=1;j<=n;j++)
cout<<a[i][j]<<" ";
cout<<endl;
}
for(i=1;i<=m;i++)
for(j=1;j<=n;j++)
s[i]=m-calculate(a,n,i,a[i][j])+1;
int smax=-1;
for(i=1;i<=m;i++)
if(s[i]>smax)
smax=s[i];
for(i=1;i<=m;i++)
if(s[i]==smax)
cout<<i<<" ";
return 0;

}
606.  Let's consider a two-dimensional array `a`
with 20 rows and 30 columns that stores only binary
values (0 and 1). Two rows are called complementary if
the sum of values in the same column is equal to 1.
Define a subroutine `complementary` which takes as
parameters a two-dimensional array `a` with 20 rows
and 30 columns storing binary values, a number `n`
representing the actual number of columns, and two
natural numbers `L1` and `L2` (L1, L2≤20). The
subroutine returns 1 if rows `L1` and `L2` are
complementary.
Using useful calls to the `complementary`
subroutine, display the pairs of complementary rows of
an array `a` with `m` rows and `n` columns. In case
there are no complementary rows, display a message.
Example:
for 
 we get (1,3), (1,5), (2,4).
Implementation:
#include <iostream>
#include <fstream>

using namespace std;
bool complementary(int a[21][31],int n,int L1,int L2)
{ 
bool ok=true;
for(int j=1;j<=n;j++)
{
if(a[L1][j]+a[L2][j]!=1)
ok=false;
}
if(ok==true)
return true;
return false;
}
int main()
{
ifstream f("data.in");
int a[21][31],m,n,i,j;
f>>m>>n;
for(i=1;i<=m;i++)
for(j=1;j<=n;j++)
f>>a[i][j];
for(i=1;i<=m;i++)
{

for(j=1;j<=n;j++)
cout<<a[i][j]<<" ";
cout<<endl;
}
bool check=false;
for(i=1;i<n;i++)
for(j=i+1;j<=n;j++)
if(complementary(a,n,i,j)==true)
{
cout<<i<<" "<<j<<endl;
check=true;
}
if(check==false)
cout<<"Does not exists";
return 0;
}
607.  Write the complete definition of a subroutine
`sub`, which:
- receives, through the parameter `a`, a two-
dimensional array with 20 rows and 20 columns,
storing integers with at most 4 digits.

- two natural numbers `m` and `n` (m,n≤20)
representing the actual number of rows and columns.
- two numbers `L` and `C` (L,C≤20) representing the
indices of a row and a column, respectively.
- returns 1 if all values stored in `L` and `C` are equal,
otherwise it returns 0.
Write a program that reads a two-dimensional array
`a` with `m` rows and `n` columns and determines all
pairs (i,j) with the property that `a[i,j]` is located at
the intersection of a row and a column with all equal
values.
Example:
for 
, we get (2,2), (4,2).
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
bool sub(int a[21][21],int m,int n,int L,int C)
{ 

bool check=true;
for(int i=1;i<=m;i++)
{ 
int x=a[i][C];
for(int j=1;j<=n;j++)
{
int y=a[j][L];
if(x!=y)
check=false;
}
}
return check;
}
int main()
{
ifstream f("data.in");
int a[21][21],m,n,i,j;
f>>m>>n;
for(i=1;i<=m;i++)
for(j=1;j<=n;j++)
f>>a[i][j];
for(i=1;i<=m;i++)
{

for(j=1;j<=n;j++)
cout<<a[i][j]<<" ";
cout<<endl;
}
for(i=1;i<=m;i++)
{
for(j=1;j<=n;j++)
if(sub(a,m,n,i,j)==true)
cout<<"("<<i<<","<<j<<")"<<endl;
}
return 0;
}
608.  Consider a two-dimensional array with `m`
rows and `n` columns (m,n≤50) storing integers.
Display the columns representing ascending ordered
sequences and the rows representing descending
ordered sequences. Define two subroutines:
a. `sub1` which returns the value 1 if a column `C` is
ordered in ascending order (otherwise it returns
the value 0).
b. `sub2` which returns the value 1 if a row `L` is
ordered in descending order (otherwise it returns
the value 0).

Implementation:
#include <iostream>
#include <fstream>
using namespace std;
bool sub1(int a[51][51],int m,int C)
{ 
bool ok=true;
for(int i=1;i<=m-1;i++)
if(a[i][C]>a[i+1][C])
ok=false;
return ok;
}
bool sub2(int a[51][51],int n,int L)
{ 
bool ok=true;
for(int j=1;j<=n-1;j++)
if(a[L][j]<a[L][j+1])
ok=false;
return ok;
}
int main()
{

ifstream f("data.in");
int a[51][51],m,n,i,j;
f>>m>>n;
for(i=1;i<=m;i++)
for(j=1;j<=n;j++)
f>>a[i][j];
for(i=1;i<=m;i++)
{
for(j=1;j<=n;j++)
cout<<a[i][j]<<" ";
cout<<endl;
}
cout<<"Lines in descending order:";
for(i=1;i<=m;i++)
if(sub2(a,m,i)==true)
cout<<i<<" ";
cout<<endl<<"Columns in ascending order:";
for(j=1;j<=n;j++)
if(sub1(a,n,j)==true)
cout<<j<<" ";
return 0;
}

609.  Consider a two-dimensional array with `m`
rows and `n` columns (m,n≤50) storing integers.
Determine if the array has a "saddle point". A point is
called a saddle point if it is the minimum value in its
row and the maximum value in its column.
Example: for m=3, n=4 and the array:
5 6 1 2
8 8 7 9
4 5 3 2
the value 7 is displayed.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
bool findSaddlePoint(int a[51][51], int m, int n)
{ 
for(int i=0;i<m;i++)
{
//find minimum from row i
//find the index which contains the min
int min_row=a[i][0],indice_coloana=0;

for(int j=1;j<n;j++)
{
if(min_row>a[i][j])
{
min_row=a[i][j];
index_col=j;
}
}
//Check if the min is a max in the column
int k;
for(k=0;k<n;k++)
if(min_row<a[k][index_col])
break;
//If yes, display the saddle point
if(k==n)
{
cout<<"Saddle point is: "<<min_row<<endl;
return true;
}
}
return false;
}
int main()

{
ifstream f("data.in");
int a[51][51],m,n,i,j;
f>>m>>n;
for(i=0;i<m;i++)
for(j=0;j<n;j++)
f>>a[i][j];
for(i=0;i<m;i++)
{
for(j=0;j<n;j++)
cout<<a[i][j]<<" ";
cout<<endl;
}
cout<<findSaddlePoint(a,m,n);
return 0;
}

9.4 PROCESSING CHARACTERS
STRINGS
610.  Define a subroutine `count` which takes as
parameters `s` and `c`:
- a string of characters with a maximum of 1000
characters
- a character `c`
and returns the number of occurrences of character
`c` in the string `s`.
Using useful calls to the `count` subroutine,
determine if a string `s` contains digits. If so, display
the digit with the maximum frequency in the string
`s`. If there are multiple digits with the maximum
frequency, display the digit with the highest value.
Example: for s = "abm993m4330", the output will
be 3.
Implementation:
#include <iostream>
#include <cstring>
using namespace std;
int count(char s[1000],char c)

{
int i,n=strlen(s),k=0;
for(i=0;i<n;i++)
if(s[i]==c)
k++;
return k;
}
int fv[10];
int main()
{
char s[1000],c;
cout<<"String:";cin>>s;
cout<<"Character:";cin>>c;
cout<<count(s,c)<<endl;
int ok=0;
for(char ch='0';ch<='9';ch++)
{ 
if(count(s,ch)!=0)
{
ok=1;
fv[ch]=count(s,ch);
}
}

int fv_max=-1;
for(char ch='0';ch<='9';ch++)
{
if(fv[ch]>fv_max)
{
fv_max=fv[ch];
ch=c;
}
}
if(ok==1)
{
cout<<"The string contains digits."<<endl;
cout<<c<<" "<<fv[c]<<endl;
}
else
cout<<"Digits do not exist.";
return 0;
}
611.  Define a subroutine `anagrams` which takes
two strings `s1` and `s2`, each with at most 20
characters, consisting of uppercase English alphabet
letters. The subroutine returns the value 1 if `s1` and
`s2` are anagrams, otherwise it returns the value 0.

Two strings are considered anagrams if they have the
same characters but in a different order. Using useful
calls to the `anagrams` subroutine, write a program
that reads `n` (n≤50) strings, each containing at most
20 uppercase letters, and displays the sets of anagram
words.
Example: Pentru n=8 şi PARENTALI, PASTORALI,
PLANETARI,
CARUNTELI, PRENATALI, PLASATORI, LAUNTRICE,
NELUCRATI
The output is:
PARENTALI, PLANETARI, PRENATALI
PASTORALI, PLASATORI
CARUNTELI, LAUNTRICE, NELUCRATI
Implementation:
#include <iostream>
#include <cstring>
#include <fstream>
using namespace std;
int anagrams(char a[20], char b[20])
{
if(strlen(a) != strlen(b))

return 0;
else
{
int i,j;
for(i=0;i<strlen(a);i++)
for (j=i+1;j<strlen(a);j++)
if (a[i]>a[j])
{
char aux = a[i];
a[i] = a[j];
a[j] = aux;
}
for (i=0;i<strlen(b);i++)
for (j=i+1;j<strlen(b);j++)
if (b[i] > b[j])
{
char aux = b[i];
b[i] = b[j];
b[j] = aux;
}
}
if (strcmp(a,b) == 0)
return 1;

return 0;
}
int main()
{ 
ifstream f("data.in");
char s[50][20],copy[50][20];
int n,i;
f>>n;
f.get();
for(i=1;i<=n;i++)
{
f.get(s[i],20);
f.get();
}
for(i=1;i<=n;i++)
strcpy(copy[i],s[i]);
for(i=1;i<n;i++)
for(int j=i+1;j<=n;j++)
if(anagrams(s[i],s[j])==1)
cout<<copy[i]<<" "<<copy[j]<<endl;
return 0;
}

612.  Define a subroutine `character` which takes
as parameters a string `s` of characters with at most
1000 characters and a character `c`. The subroutine
returns the number of occurrences of character `c` in
the string `s`. Using useful calls to the subroutine,
solve the following tasks for a text with at most 1000
characters read from the keyboard:
a. Display the frequency of occurrence for each letter.
The display of letters will be in alphabetical order
and there will be no distinction between uppercase
and lowercase letters.
b. Display the letters with the highest frequency in
the text.
c. Display the digit with the highest frequency in the
text. In case there are multiple digits with the
maximum frequency, display the one with the
smaller value.
d. Display the first letter in the alphabet that does not
appear in the text.
Implementation:
#include <iostream>
#include <cstring>
using namespace std;
int character(char s[1000],char c)

{
int i,n=strlen(s),k=0;
for(i=0;i<n;i++)
if(s[i]==c)
k++;
return k;
}
int fv_letter[26];
int fv_digit[26];
int main()
{ 
char s[1000];
cout<<"String:";cin.get(s,1000);
///———————————————
for(int i=0;i<strlen(s);i++)
{ 
if(s[i]>='A' && s[i]<='Z')
s[i]=s[i]+32;
if(s[i]>='a' && s[i]<='z')
fv_letter[s[i]]=character(s,s[i]);
if(s[i]>='0' && s[i]<='9')
fv_digit[s[i]]=character(s,s[i]);
}

for(char ch='a';ch<='z';ch++)
if(fv_litera[ch]!=0)
cout<<"Letter "<<ch<<" occurrs "<<fv_letter[ch]<<"
times."<<endl;
///———————————————
int fv_max=-1;
cout<<"Letters with max frequency:"<<endl;
for(char ch='a';ch<='z';ch++)
if(fv_letter[ch]>fv_max)
fv_max=fv_letter[ch];
for(char ch='a';ch<='z';ch++)
if(fv_letter[ch]==fv_max)
cout<<ch<<" ";
cout<<endl;
///———————————————
cout<<"Digits with max frequency:"<<endl;
fv_max=-1;
for(char ch='0';ch<='9';ch++)
if(fv_digit[ch]>fv_max)
fv_max=fv_digit[ch];
for(char ch='0';ch<='9';ch++)
if(fv_digit[ch]==fv_max)
cout<<ch<<" ";

cout<<endl;
///———————————————
cout<<"1st digits which is not in the string: ";
for(char ch='a';ch<='z';ch++)
if(fv_letter[ch]==0)
{
cout<<ch;
break;
}
return 0;
}
613.  Define the following subroutines:
a. Search with parameters: two strings `s1` and `s2`
with 200 characters. The subroutine searches for
the string `s2` in the string `s1` and returns the
position of `s2` within `s1` or -1 if `s2` does not
appear in `s1`.
b. Delete with parameters: a string `s` with 200
characters, and two numbers `p` and `q` (p,q≤
200). The subroutine deletes `q` characters from
`s` starting from the character at position `p`.
c. Insert with parameters: two strings `s1` and `s2`
with 200 characters each, and a natural number

`p` (p≤ 200). The subroutine inserts `s2` into `s1`
starting from the character at position `p`.
Read from the keyboard a string `a` with at most
200 characters and two strings `s1` and `s2` with at
most 20 characters each. Replace all occurrences of
the string `s1` with the string `s2`.
Implementation:
#include <iostream>
#include <cstring>
using namespace std;
int search(char s1[200],char s2[20])
{ 
const char *p = strstr(s1, s2);
if (p)
return p - s1;
return -1;
}
void delete(char s[200],int p,int q)
{
for(int i=p;i<strlen(s);i++)
while(q!=0)
{

strcpy(s+i,s+i+1);
q—;
}
}
void insert(char s1[200],char s2[200],int p)
{ 
char temp[400]="";
int poz=0;
for(int i=0;i<p;i++)
{
temp[poz]=s1[i];
poz++;
}
for(int i=0;i<strlen(s2);i++)
{
temp[poz]=s2[i];
poz++;
}
for(int i=p;i<strlen(s1);i++)
{
temp[poz]=s1[i];
poz++;
}

strcpy(s1,temp);
}
int main()
{
char a[200],s1[20],s2[20];
cout<<"String:";cin.get(a,200);
cin.get();
cout<<"s1:";cin.get(s1,20);
cin.get();
cout<<"s2:";cin.get(s2,20);
if(search(a,s1)!=0)
{
delete(a,Cauta(a,s1),strlen(s2));
insert(a,s2);
}
cout<<a;
return 0;
}
614.  Define the subroutine `rhyme` with
parameters: two strings `s1` and `s2` with 20
characters each, lowercase letters of the English
alphabet. The subroutine returns the value 1 when the
two words stored in `s1` and `s2` rhyme, otherwise it

returns the value 0. Two words are considered to
rhyme when they have the last two letters identical.
Write a program that reads `n` (n≤30) strings of
characters consisting of at most 20 lowercase letters
each, and displays the sets of rhyming words.
Example: For n=6 and the words: floare, fina,
culoare, lina, boare, avion the output is:
floare, culoare, boare
fina, lina
avion
Implementation:
#include <iostream>
#include <cstring>
#include <fstream>
using namespace std;
int rhyme(char s1[20],char s2[20])
{
if(s1[strlen(s1)-1]==s2[strlen(s2)-1] &&
s1[strlen(s1)-2]==s2[strlen(s2)-2])
return 1;
return 0;
}

int fv[1000]={0};
int main()
{
ifstream f("date.in");
char s[50][20];
int n,i;
f>>n;
f.get();
for(i=1;i<=n;i++)
{
f.get(s[i],20);
f.get();
}
char copie[50][1000];
for(i=1;i<n;i++)
for(int j=i+1;j<=n;j++)
if(rhyme(s[i],s[j]) && fv[i]==0)
{
cout<<s[i]<<" "<<s[j]<<endl;
fv[i]++;
}
return 0;
}

CHAPTER 10 – RECURSION
10.1 Numerical Processing
10.2 Calculating the value of recursive expressions
10.3 Processing One-Dimensional Arrays
10.4 Processing Two-Dimensional Arrays
10.5 Processing Character Strings
Applications:

10.1  NUMERICAL PROCESSING
615.  Define the recursive subroutine display with the
parameter n, a non-zero natural number with at most
9 digits. The subroutine displays the values from n to
1.
Implementation:
#include <iostream>
using namespace std;
void display(int n)
{
if(n!=0)
{
cout<<n<<" ";
display(n-1);
}
}
int main()
{
int n=7;
display(n);
return 0;
}

616.  Define the recursive subroutine display with
the parameter n, a non-zero natural number with at
most 9 digits. The subroutine displays the values from
1 to n.
Implementation:
#include <iostream>
using namespace std;
void display(int n)
{
if(n!=0)
{ 
display(n-1);
cout<<n<<" ";
}
}
int main()
{
int n=7;
display(n);
return 0;
}

617.  Define the recursive subroutine display with
the parameter n, a non-zero natural number with at
most 9 digits. The subroutine displays on one line of
the screen, in descending order, the odd values from 1
to n, and on the next row, the even values in
ascending order.
Example: for n=7, it displays:
7 5 3 1
2 4 6
Implementation:
#include <iostream>
using namespace std;
void display(int n)
{
if(n!=0)
{ 
if(n%2==0)
{
display(n-1);
cout<<n<<" ";
}

else
{ 
cout<<n<<" ";
display(n-1);
}
}
else cout<<endl;//Print a new line when n reaches 0
}
int main()
{
int n=7;
display(n);
return 0;
}
618.  Define the recursive subroutine that, for a
natural number n (n≤100), displays a pyramid of the
following type:
n n-1 n-2 ..... 3 2 1
n-1 n-2 ..... 3 2 1
.....
3 2 1
2 1

1
Implementation:
#include <iostream>
using namespace std;
void afi(int n,int i)
{
if(n>=1)
{
cout<<i<<" ";
if(i==1)
{
cout<<endl;
afi(n-1,n-1);
}
else
afi(n,i-1);
}
}
int main()
{
int n;
cout<<"n=";

cin>>n;
afi(n,n);
return 0;
}
1. Define the recursive subroutine that, for a natural
number n, displays the first n perfect squares.
Example: for n=5, it displays: 1 4 9 16 25
Implementation:
#include <iostream>
using namespace std;
void displaySquares(int n)
{
if(n!=0)
{ 
displaySquares(n-1);
cout<<n*n<<" ";
}
}
int main()
{
int n=5;

displaySquares(n);
return 0;
}
1. Define the recursive subroutine that, for a natural
number n, displays the first n perfect squares of
even numbers.
Example: for n=5, it displays: 4 16 36 64 100.
Implementation:
#include <iostream>
using namespace std;
void displaySquares(int n,int i)
{ 
if(n!=0)
{ 
cout<<i*i<<" ";
displaySquares(n-1,i+2);
}
}
int main()
{
int n=5;
displaySquares(n,2);

return 0;
}
1. Define the recursive subroutine that, for a natural
number n (n≤100), displays a pyramid of the
following type:
1
1 2
1 2 3
.....
1 2 3 ... n-2 n-1 n
Implementation:
#include <iostream>
using namespace std;
int x,i;
void afi(int n)
{
if(n>0)
{
afi(n-1);
x=n;
for(i=1;i<=x;i++)

cout<<i<<" ";
cout<<endl;
}
}
int main()
{
cout<<"x=";
cin>>x;
afi(x);
return 0;
}
1. Define the recursive subroutine that, for a natural
number n (n≤100), displays a pyramid of the
following type:
1
2 2
3 3 3
.....
n n n n ... n ( n times )
Implementation:
#include <iostream>

using namespace std;
int x,i;
void afi(int n)
{
if(n>0)
{
afi(n-1);
x=n;
for(i=1; i<=x; i++)
cout<<n<<" ";
cout<<endl;
}
}
int main()
{
cout<<"x=";
cin>>x;
afi(x);
return 0;
}
1. Define the recursive subroutine display with the
parameter n, a non-zero natural number with at

most 9 digits. The subroutine displays the digits of
the number with a space between them, starting
from the units.
Implementation:
#include <iostream>
using namespace std;
void display(int n)
{
if(n>0)
{
cout<<n%10<<" ";
display(n/10);
}
}
int main()
{ 
int n;
cout<<"n=";cin>>n;
display(n);
return 0;
}

1. Define the recursive subroutine display with the
parameter n, a non-zero natural number with at
most 9 digits. The subroutine displays the even
digits of the number with a space between them,
starting from the units.
Implementation:
#include <iostream>
using namespace std;
void display(int n)
{
if(n>0)
{ 
if(n%2==0)
cout<<n%10<<" ";
display(n/10);
}
}
int main()
{ 
int n;
cout<<"n=";cin>>n;
display(n);
return 0;

}
1. Define the recursive subroutine display with the
parameter n, a non-zero natural number with at
most 9 digits. The subroutine displays on one line
of the screen, with spaces between them, the even
digits of the number starting from the units, and on
the next line, the odd digits of the number starting
from the leftmost digit.
Example: for n=2345678, it displays:
8 6 4 2
3 5 7
Implementation:
#include <iostream>
using namespace std;
void display(int n)
{
if(n>0)
{ 
if(n%2==0)
{ 
cout<<n%10<<" ";

display(n/10);
}
if(n%2==1)
{
display(n/10);
cout<<n%10<<" ";
}
}
else cout<<endl;
}
int main()
{ 
int n;
cout<<"n=";cin>>n;
display(n);
return 0;
}
1. Define the recursive subroutine reverse with the
parameter n, a non-zero natural number with at
most 9 digits. It returns through the parameter m
the reverse of n (the number obtained by
traversing the digits of n starting with the units
digit).

Example: for n=2345, after calling the reverse
subroutine, m will have the value 5432.
Implementation:
#include <iostream>
using namespace std;
int reverse(int m,int n)
{
if(n==0)
return m;
else
return reverse(m*10+n%10,n/10);
}
int main()
{ 
int n,m=0;
cout<<"n=";cin>>n;
m=reverse(m,n);
cout<<"reverse of n is: "<<m;
return 0;
}
1. Define the recursive subroutine repeat with
parameters a, b, and c, natural numbers, which

returns through the parameter c the product of the
values of a and b. The product will be determined
through repeated addition. The * operator will not
be used.
Implementation:
#include <iostream>
using namespace std;
void repeat(int a, int b,int &c)
{
if(b==0)
c=0;
else
{
repeat(a,b-1,c);
c += a;
}
}
int main()
{
int a,b,c=0;
cout<<"a=";cin>>a;
cout<<"b=";cin>>b;
repeat(a,b,c);

cout<<a<<"*"<<b<<"="<<c;
return 0;
}
1. Define the recursive subroutine repeat with
parameters a, b, and c, natural numbers, which
returns through the parameter c the value of the
expression: ab. The power will be calculated
through repeated multiplication. (Do not use a
power function).
Implementation:
#include <iostream>
using namespace std;
void repeat(int a,int b,int &c)
{
if(!b)
c=1;
else
{
repeat(a,b-1,c);
c *= a;
}
}

int main()
{
int a,b,c=0;
cout<<"a=";cin>>a;
cout<<"b=";cin>>b;
repeat(a,b,c);
cout<<"a^b= "<<c;
return 0;
}
1. Define the recursive subroutine repeat with
parameters a, b, and c, natural numbers, which
returns through parameter c the quotient of the
values of a and b, and through parameter a the
remainder of the division. The product will be
determined through repeated subtraction. The /
operator will not be used.
Implementation:
#include <iostream>
using namespace std;
void repeat(int a, int b, int &c)
{
if(a >=b)

{
c++;
repeat(a-b,b,c);
}
}
int main()
{
int a,b,c=0;
cout<<"a=";cin>>a;
cout<<"b=";cin>>b;
repeat(a, b, c);
cout<<"Quotient: "<<c<<endl;
cout<<"Remainder: "<<a-(c*b)<<endl;
return 0;
}
1. Define a recursive subroutine that decomposes a
non-zero natural number into a sum of two
numbers:
Example: for n=11, it will display: 1+10, 2+9, 3+8,
4+7, 5+6.
Implementation:
#include <iostream>

using namespace std;
int a,b,n;
void f(int n,int a,int b)
{
if(a<b)
{
cout<<n<<"="<<a<<"+"<<b<<endl;
f(n,a+1,b-1);
}
}
int main()
{
int n;
cout<<"n=";cin>>n;
a=1;
b=n-a;
f(n,a,b);
return 0;
}
1. Define a recursive subroutine that returns the n-th
term in the Fibonacci sequence where:

Implementation:
#include <iostream>
using namespace std;
int T(int n)
{
if(n==0)
return 0;
if(n==1)
return 1;
return T(n-1)+T(n-2);
}
int main()
{
int n;
cout<<"n=";
cin>>n;
cout<<"The "<<n<<"-th term of Fibonacci sequence is"
<<T(n)<<endl;
return 0;
}

1. Define a recursive subroutine that returns the
greatest common divisor of two non-zero natural
numbers, x and y.
Implementation:
#include <iostream>
using namespace std;
int GCD(int x,int y)
{
if(x==0 || y==0)
return 0;
if(x==y)
return x;
if(x>y)
return GCD(x-y,y);
else
return GCD(x,y-x);
}
int main()
{
int x,y;
cout<<"x=";cin>>x;
cout<<"y=";cin>>y;

cout<<"GCD is: "<<GCD(x,y);
return 0;
}
1. Define a recursive subroutine that displays the
natural number x represented in base b.
Example: for x=23 and b=2, it will display 10111.
Implementation:
#include <iostream>
using namespace std;
void representation(int x,int b)
{ 
int power=1;
if(x>0)
{
representation(x/b,b);
cout<<x%b*power;
power = power * 10;
}
}
int main()
{

int x,b;
cout<<"x=";cin>>x;
cout<<"b=";cin>>b;
representation(x,b);
return 0;
}
1. Define a recursive subroutine that takes a natural
number x as a parameter and returns, through the
parameter cm, the highest digit of the number x.
Implementation:
#include <iostream>
using namespace std;
int x,cm;
int maximDigit(int x,int cm)
{
if(x==0)
return cm;
else if(x%10>cm)
cm=x%10;
return maximDigit(x/10,cm);
}
int main()

{
cout<<"x=";cin>>x;
cm=0;
cout<<"Max digit is: "<<maximDigit(x,cm);
return 0;
}
1. Define a recursive subroutine that takes a natural
number x as a parameter and returns the highest
digit of the number x.
Implementation:
#include <iostream>
using namespace std;
int x,maxim;
int maximDigit(int x)
{
if(x==0)
return maxim;
else if(x%10>maxim)
maxim=x%10;
return maximDigit(x/10);
}
int main()

{
cout<<"x=";cin>>x;
maxim=0;
cout<<"Max digit:"<<maximDigit(x);
return 0;
}
1. Define a recursive subroutine that takes a natural
number x as a parameter and returns the number
of digits in the number x.
Implementation:
#include <iostream>
using namespace std;
int x;
int digits(int x)
{
if(x==0)
return 0;
else return 1+digits(x/10);
}
int main()
{
cout<<"x=";cin>>x;

cout<<"No. of digits: "<<digits(x);
return 0;
}
1. Define a recursive subroutine that takes a natural
number x as a parameter and returns the number
of even digits in the number x.
Implementation:
#include <iostream>
using namespace std;
int x;
int evenDigits(int x)
{
if(x<10)
{
if (x%2==0)
return 1;
else return 0;
}
else
{
if((x%10)%2==0)
return 1+ evenDigits(x/10);

else return evenDigits(x/10);
}
}
int main()
{
cout<<"x=";cin>>x;
cout<<"No. of even digits: "<< evenDigits(x);
return 0;
}
1. Define a recursive subroutine that takes as
parameters a natural number x with at most 9
digits and a digit c, and returns the number of
digits in the number x that are equal to the digit c.
Implementation:
#include <iostream>
using namespace std;
int nr,c,k;
int findDigit(int x,int c,int k)
{
if(x>0)
{
if(x%10==c)

return findDigit(x/10,c,k+1);
else
return findDigit(x/10,c,k);
}
return k;
}
int main()
{
cout<<"nr=";cin>>nr;
cout<<"Give a digit:";cin>>c;
cout<<c<<" occurs "<<findDigit(nr,c,k)<<" times.";
return 0;
}
1. Define a recursive subroutine that displays the
divisors of the natural number x.
Implementation:
#include <iostream>
using namespace std;
int n;
void divisors(int n,int d)
{
if(d>=1)

{
if(n%d==0)
{
divisors(n,d-1);
cout<<d<<" ";
}
else divisors(n,d-1);
}
}
int main()
{
cout<<"n=";cin>>n;
divisors(n,n);
return 0;
}
1. Define a recursive subroutine that returns 1 if the
natural number n (n≥2) is prime, otherwise
returns 0.
Implementation:
#include <iostream>
using namespace std;
int n;

int prime(int n,int d)
{
if(d==1)
return 1;
else if(n%d==0) return 0;
return prime(n,d-1);
}
int main()
{
cout<<"n=";cin>>n;
if(prime(n,n/2)==1)
cout<<"It’s a prime number.";
else cout<<"Not a prime.";
return 0;
}
1. Define a recursive subroutine that displays the
prime factorization of a natural number n.
Example: for n=360=23*32*51, the output is:
2 3
3 2
5 1

Implementation:
#include <iostream>
using namespace std;
int n;
void factorization(int n,int d)
{
if(n!=0)
{ 
if(n%d==0)
{ 
cout<<d<<" ";
factorization(n/d,d);
}
else factorization(n, d+1);
}
}
int main()
{
cout<<"n=";cin>>n;
factorization(n,2);
return 0;
}

1. From the number 4, any natural number n written
in base 10 can be obtained by applying the
following operations:
Write the digit 4 at the end;
Add the digit 0 at the end;
If the number is even, divide it by 2;
Write a program that produces a sequence of
numbers constructed according to the above rules,
where the first number is 4 and the last is n.
Example: for n=7024, the sequence is: 4, 2, 1, 14,
140, 1404, 702, 7024.
Note: The sequence will be generated in reverse
order, from n to 4, applying the transformations in
reverse order.
Implementation:
#include <iostream>
using namespace std;
void generateSequence(int n)
{ 
if(n>0)
{
if(n%10==4)

generateSequence(n/10);
else if(n%2==0 && n%10!=0)
generateSequence(n*2);
else if(n%10==0)
generateSequence(n/10);
if(n==1)
generateSequence(n*2);
cout<<n<<" ";
}
}
int main()
{
int n;
cin>>n;
generateSequence(n);
return 0;
}
1. Define a recursive subroutine that takes a natural
number x as a parameter and returns the largest
perfect square smaller than or equal to x.
Example: For x=27, the subroutine returns 25.
Implementation:

#include <iostream>
#include <cmath>
using namespace std;
int n;
int f(int n,int x)
{ 
if(x*x<n)
f(n,x+1);
else
return x*x;
}
int main()
{
cout<<"n=";cin>>n;
cout<<f(n,2);
return 0;
}
1. Define a recursive subroutine that takes a natural
number x as a parameter and returns the closest
number y less than or equal to x that is a power of
2.
Example: For x=35, the subroutine returns 32.

For x=32, the subroutine returns 32.
Implementation:
#include <iostream>
using namespace std;
int f(int x,int y)
{ 
if(y*2<=x)
{
y=y*2;
f(x,y);
}
else return y;
}
int main()
{
int x=70,y=1;
cout<<f(x,y);
return 0;
}
1. Define a recursive subroutine that displays the
perfect squares in the interval [a,b].

Implementation:
#include <iostream>
#include <cmath>
using namespace std;
void interval(int a,int b)
{
int i=a;
if(i<=b)
{
if(sqrt(i)==(int)sqrt(i))
cout<<i<<" ";
interval(i+1,b);
}
}
int main()
{
int a=5,b=30;
interval(a,b);
return 0;
}
1. Define a recursive subroutine that returns the
number of perfect squares in the interval [a,b].

Implementation:
#include <iostream>
#include <cmath>
using namespace std;
int countSquares(int a,int b)
{ 
int i=a;
if(a>b)
return 0;
if(i<=b)
if(sqrt(i)==(int)sqrt(i))
return 1+countSquares(i+1,b);
return countSquares(i+1,b);
}
int main()
{
int a=1,b=100;
cout<<countSquares(a,b);
return 0;
}
1. Define a recursive program that determines the
maximum digit of a number x and how many times

it appears in the number x.
Implementation:
#include <iostream>
using namespace std;
int freqMaxDigit(int x, int c)
{
if(x<10)
return x==c;
else if(x%10==c)
return 1 + freqMaxDigit(x/10,c);
else return freqMaxDigit(x/10,c);
}
int maxDigit(int x)
{ 
if (x<=9)
return x;
else
{
int n=maxDigit(x/10);
if(n>x%10)
return n;
else

return x%10;
}
}
int main()
{
int x=12385678;
cout<<"Max digit is: "<<maxDigit(x);
cout<<" and its frequency: "
<<freqMaxDigit(x,maxDigit(x));
return 0;
}

10.2  CALCULATING THE VALUE
OF RECURSIVE EXPRESSIONS
1. Define a recursive subroutine that calculates the
Gaussian sum of 1+2+3+...+n.
Implementation:
#include <iostream>
using namespace std;
int Gauss(int n)
{
if(n==0)
return 0;
else return n+Gauss(n-1);
}
int main()
{
int n;
cout<<"n=";cin>>n;
cout<<"1+2+3+...+"<<n<<" is: "<<Gauss(n);
return 0;
}

1. Define a recursive subroutine that calculates the
value of the sum: 1×2+2×3+3×4+...+n × (n+1).
Implementation:
#include <iostream>
using namespace std;
int sum(int n)
{
if (n==0)
return 0;
else return n*(n+1)+sum(n-1);
}
int main()
{
int n;
cout<<"n=";cin>>n;
cout<<"1*2+2*3+...+"<<n*(n+1)<<" is: "<<sum(n);
return 0;
}
1. Define a recursive subroutine that determines the
sum of natural odd numbers up to a given input n.
Implementation:

#include <iostream>
using namespace std;
int oddNumberSum(int n)
{
if(n==0)
return 0;
else if(n%2==1)
return oddNumberSum(n-1)+n;
else
return oddNumberSum(n-1);
}
int main()
{
int n;
cout<<"n=";cin>>n;
cout<<oddNumberSum(n);
return 0;
}
1. Define a recursive subroutine that determines the
value of the sum: (1+2) × (2+3) × (3+4) ×...×
(n+n+1).
Implementation:

#include <iostream>
using namespace std;
int sum(int n)
{
if (n==0)
return 1;
else return (n+n+1)*sum(n-1);
}
int main()
{
int n;
cout<<"n=";cin>>n;
cout<<"(1+2)*(2+3)+...+"<<(n+n+1)<<" is "<<sum(n);
return 0;
}
1. Define a recursive subroutine that determines the
value of the following expression: 12 – 22 + 32 – 42
+ ... ± n2.
Implementation:
#include <iostream>
using namespace std;
int sum(int n)

{
if(n==1)
return 1;
else if(n%2==1)
return n*n+sum(n-1);
else
return (-1)*n*n+sum(n-1);
}
int main()
{
int n;
cout<<"n=";cin>>n;
cout<<"(1^2)-(2^2)+(3^2)-... is "<<sum(n);
return 0;
}
1. Define a recursive subroutine that determines the
value of the following expression: 1×2 – 2×4 +
3×6 – ... ± n×2n.
Implementation:
#include <iostream>
using namespace std;
int sum(int n)

{
if(n==1)
return 2;
else if(n%2==1)
return n*n*2+sum(n-1);
else
return (-1)*n*n*2+sum(n-1);
}
int main()
{
int n;
cout<<"n=";cin>>n;
cout<<"1×2 – 2×4 + 3×6 – ... ± n×2n este:"<<sum(n);
return 0;
}
1. Define a recursive subroutine that takes as
parameters the natural numbers a, r, and n, and
displays the first n terms of an arithmetic
progression with the initial term a and the ratio r.
Example: for n=5, a=10, r=2, it displays: 10, 12,
14, 16, 18.
Implementation:

#include <iostream>
using namespace std;
void arithmeticProgression(int n,int a,int r)
{
if(n!=0)
{
cout<<a<<" ";
arithmeticProgression(n-1,a+r,r);
}
}
int main()
{
int n=5,a=10,r=2;
arithmeticProgression(n,a,r);
return 0;
}
1. Define a recursive subroutine that takes as
parameters the natural numbers a, r, and n, and
displays the first n terms of an geometric
progression with the initial term a and the ratio r.
Example: for n=5, a=10, r=2, it displays: 10, 20,
40, 80, 160.

Implementation:
#include <iostream>
using namespace std;
void geometricProgression(int n,int a,int r)
{
if(n!=0)
{
cout<<a<<" ";
geometricProgression(n-1,a*r,r);
}
}
int main()
{
int n=5,a=10,r=2;
geometricProgression(n,a,r);
return 0;
}

10.3  PROCESSING ONE –
DIMENSIONAL ARRAYS
1. Define a recursive subroutine that reads the
components of a one-dimensional array from a text
file.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
ifstream f("date.in");
void recursiveReading(int v[101],int n)
{
if(n==1)
f>>v[n];
else
{
recursiveReading(v,n-1);
f>>v[n];
}
}
int main()
{

int v[101],n;
f>>n;
recursiveReading(v,n);
for(int i=1;i<=n;i++)
cout<<v[i]<<" ";
return 0;
}
1. Define a recursive subroutine that displays the
components of a one-dimensional array onto the
screen.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
void recursiveDisplay(int v[101],int n)
{
if(n==1)
cout<<v[n]<<" ";
else
{ 
recursiveDisplay(v,n-1);
cout<<v[n]<<" ";

}
}
int main()
{ 
ifstream f("date.in");
int v[101],n;
f>>n;
for(int i=1;i<=n;i++)
f>>v[i];
recursiveDisplay(v,n);
return 0;
}
1. Define a recursive subroutine that returns the sum
of the components of a one-dimensional array.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int sum(int v[101],int n,int i)
{
if(i>n)
return 0;

return v[i]+sum(v,n,i+1);
}
int main()
{
ifstream f("date.in");
int n,v[101],i;
f>>n;
for(i=1;i<=n;i++)
f>>v[i];
for(i=1;i<=n;i++)
cout<<v[i]<<" ";
cout<<endl;
cout<<"The sum is: "<<sum(v,n,1);
return 0;
}
1. Define a recursive subroutine that returns the sum
of the even components of a one-dimensional
array.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;

int sum(int v[101],int n,int i)
{
if(i>n)
return 0;
if(v[i]%2==0)
return v[i]+sum(v,n,i+1);
else sum(v,n,i+1);
}
int main()
{
ifstream f("date.in");
int n,v[101],i;
f>>n;
for(i=1;i<=n;i++)
f>>v[i];
for(i=1;i<=n;i++)
cout<<v[i]<<" ";
cout<<endl;
cout<<"The sum of evens is: "<<sum(v,n,1);
return 0;
}

1. Define a recursive subroutine that determines the
maximum value from a one-dimensional array.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int maxValue(int v[101],int n,int max)
{
if(n==0)
return max;
else if(v[n]>max)
max=v[n];
return maxValue(v,n-1,max);
}
int main()
{
ifstream f("date.in");
int n,v[101],i;
f>>n;
for(i=1;i<=n;i++)
f>>v[i];
for(i=1;i<=n;i++)

cout<<v[i]<<" ";
cout<<endl;
cout<<"The maximum is: "<<maxValue(v,n,0);
return 0;
}
1. Define a recursive subroutine that returns 1 if the
value x is found in the one-dimensional array v,
otherwise it returns 0.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int search(int v[101],int n,int x)
{
if(n==0)
return 0;
if(v[n]==x)
return 1;
else search(v,n-1,x);
}
int main()
{

ifstream f("date.in");
int n,v[101],i,x;
f>>n;
for(i=1;i<=n;i++)
f>>v[i];
for(i=1;i<=n;i++)
cout<<v[i]<<" ";
cout<<endl;
cout<<"x=";cin>>x;
if(search(v,n,x)==1)
cout<<x<<" has been found in the array";
else
cout<<x<<" has not been found.";
return 0;
}
1. Define a recursive subroutine that returns the
number of components in a one-dimensional array
that are equal to the sum of their neighboring
elements.
Example: for v=(2, 7, 5, -2, 3, 5), the value
obtained is 3.
Implementation:

#include <iostream>
#include <fstream>
using namespace std;
int equalsSum(int v[101],int n)
{ 
if(n==0)
return 0;
else if(v[n]==v[n-1]+v[n+1])
return 1 + equalsSum(v,n-1);
else equalsSum(v,n-1);
}
int main()
{
ifstream f("date.in");
int n,v[101],i,x;
f>>n;
for(i=1;i<=n;i++)
f>>v[i];
for(i=1;i<=n;i++)
cout<<v[i]<<" ";
cout<<endl;
cout<<equalsSum(v,n);
return 0;

}
1. Define a recursive subroutine that returns the
number of components in a one-dimensional array
that are perfect squares.
Example: for v=(2, 16, 25, -2, 36, 5), the value
obtained is 3.
Implementation:
#include <iostream>
#include <fstream>
#include <cmath>
using namespace std;
int countSquares(int v[101],int n)
{ 
if(n==0)
return 0;
else if(sqrt(v[n])==(int)sqrt(v[n]))
return 1+countSquares(v,n-1);
else countSquares(v,n-1);
}
int main()
{
ifstream f("date.in");

int n,v[101],i,x;
f>>n;
for(i=1;i<=n;i++)
f>>v[i];
for(i=1;i<=n;i++)
cout<<v[i]<<" ";
cout<<endl;
cout<<countSquares(v,n);
return 0;
}

10.4  PROCESSING TWO –
DIMENSIONAL ARRAYS
1. Define a recursive subroutine that reads the values
of the components of a two-dimensional array.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
ifstream f("date.in");
void recursiveReading(int a[51][41], int m, int n)
{
if(m>1)
recursiveReading(a,m-1,n);
else if(n>1)
recursiveReading(a,m,n-1);
f>>a[m][n];
}
int main()
{
int a[51][41],m,n,i,j;
f>>m>>n;
recursiveReading(a,m,n);

for(i=1;i<=m;i++)
{
for(j=1;j<=n;j++)
cout<<a[i][j]<<" ";
cout<<endl;
}
return 0;
}
1. Define a recursive subroutine that displays on the
screen the values of the components of a two-
dimensional array.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
ifstream f("date.in");
void recursiveDisplay(int a[51][41], int m, int n)
{
if(m==1 && n==1)
cout<<a[m][n]<<" ";

else 
{
recursiveDisplay(a,m-1,n-1);
cout<<a[m][n]<<" ";
}
}
int main()
{
int a[51][41],m,n,i,j;
f>>m>>n;
for(i=1;i<=m;i++)
for(j=1;j<=n;j++)
f>>a[i][j];
recursiveDisplay(a,m,n);
return 0;
}
1. Define a recursive subroutine that returns the sum
of the values of the components of row x of a two-
dimensional array.
Implementation:
#include <iostream>
#include <fstream>

using namespace std;
ifstream f("date.in");
int sumRowX(int a[51][41], int L, int n)
{
if(n==0)
return 0;
else return a[L][n] + sumRowX(a,L,n-1);
}
int main()
{
int a[51][41],m,n,i,j;
f>>m>>n;
for(i=1;i<=m;i++)
for(j=1;j<=n;j++)
f>>a[i][j];
for(i=1;i<=m;i++)
cout<<"Row: "<<i<<" and sum: "<<sumRowX(a,i,n)
<<endl;
return 0;
}
1. Define a recursive subroutine that returns the sum
of the values of the components of column x of a
two-dimensional array.

Implementation:
#include <iostream>
#include <fstream>
using namespace std;
ifstream f("date.in");
int sumColX(int a[51][41], int m, int C)
{
if(m==0)
return 0;
else return a[m][C] + sumColX(a,m-1,C);
}
int main()
{
int a[51][41],m,n,i,j;
f>>m>>n;
for(i=1;i<=m;i++)
for(j=1;j<=n;j++)
f>>a[i][j];
for(i=1;i<=n;i++)
cout<<"Column: "<<i<<", sum: "<<sumColX(a,m,i)
<<endl;
return 0;
}

1. Define a recursive subroutine that returns the sum
of the values of the components on the main
diagonal of a square matrix.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
ifstream f("date.in");
int sum(int a[41][41], int n)
{
if(n==0)
return 0;
else return a[n][n]+sum(a,n-1);
}
int main()
{
int a[41][41],n,i,j;
f>>n;
for(i=1;i<=n;i++)
for(j=1;j<=n;j++)
f>>a[i][j];
cout<<"Sum from main diagonal: "<<sum(a,n);

return 0;
}
1. Define a recursive subroutine that returns the sum
of the values of the components on the secondary
diagonal of a square matrix.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
ifstream f("date.in");
int sum(int a[41][41], int n,int i)
{ 
i=1;
if(n==0)
return 0;
else
{
return a[n][n+1-i]+suma(a,n-1,i+1);
}
}
int main()
{

int a[41][41],n,i,j;
f>>n;
for(i=1;i<=n;i++)
for(j=1;j<=n;j++)
f>>a[i][j];
cout<<"Sum from secondary diagonal: "<<sum(a,n,1);
return 0;
}

10.5  PROCESSING CHARACTER
STRINGS
1. Define a recursive subroutine that removes extra
spaces from a string containing lowercase letters
and spaces, so that there is only one space
between words.
Implementation:
#include <iostream>
#include <cstring>
using namespace std;
int delChar(char s[255])
{
if(s[0]=='\0')
return 0;
delChar(s+1);
if(s[0]==' ' && !(s[1]>='a' && s[1]<='z'))
{
for(int i=1;i<=strlen(s);i++)
s[i-1]=s[i];
}
}
int main()

{
char s[255];
cin.getline(s,255);
delChar(s);
cout<<s;
return 0;
}
1. Define a recursive subroutine that displays the
characters from a string passed as parameters,
separated by a space. The string contains
lowercase letters.
Implementation:
#include <iostream>
#include <cstring>
using namespace std;
void display(char s[255])
{ 
if(strlen(s)!=0)
{
cout<<s[0]<<endl;
display(s+1);
}

}
int main()
{
char s[255];
cin.getline(s,255);
display(s);
return 0;
}
1. Define a recursive subroutine that displays the
characters from a string passed as parameters in
reverse order. The string contains lowercase
letters.
Implementation:
#include <iostream>
#include <cstring>
using namespace std;
void display(char s[255])
{ 
if(strlen(s)!=0)
{ 
display(s+1);
cout<<s[0]<<endl;

}
}
int main()
{
char s[255];
cin.getline(s,255);
display(s);
return 0;
}
1. Define a recursive subroutine that displays the
characters from a string passed as a parameter,
separated by a space. The vowels a e i o u are
displayed twice. The string contains lowercase
letters.
Example: for the string oana, it displays o o a a n
a a.
Implementation:
#include <iostream>
#include <cstring>
using namespace std;
void display(char s[255])
{ 

if(strlen(s)!=0)
{ 
if(s[0]=='a' || s[0]=='e' || s[0]=='i' || s[0]=='o' ||
s[0]=='u')
{
cout<<s[0]<<" "<<s[0]<<" ";
display(s+1);
}
else
{
cout<<s[0]<<" ";
display(s+1);
}
}
}
int main()
{
char s[255];
cin.getline(s,255);
display(s);
return 0;
}

1. Define a recursive subroutine that returns the
number of vowels in a string of characters passed
as a parameter. The string contains only lowercase
letters. Vowels are considered to be the characters:
a e i o u.
Example: for the string avion, the subroutine
returns 3.
Implementation:
#include <iostream>
#include <cstring>
using namespace std;
int countVowels(char s[255])
{ 
if(strlen(s)!=0)
{ 
if(s[0]=='a' || s[0]=='e' || s[0]=='i' || s[0]=='o' ||
s[0]=='u')
return 1+countVowels(s+1);
countVowels(s+1);
}
}
int main()
{

char s[255];
cin.getline(s,255);
cout<<countVowels(s);
return 0;
}
1. Define a recursive subroutine that returns 1 if a
string passed as a parameter is a palindrome,
otherwise returns the value 0. The string contains
only lowercase letters. A string is a palindrome if it
reads the same from left to right as from right to
left.
Example: for the string rotator, the subroutine
returns 1.
Implementation:
#include <iostream>
#include <cstring>
using namespace std;
int palindrome(char s[255],int a,int b)
{ 
if(a==b)
return 1;
if(s[a]!=s[b])

return 0;
if(a<b+1)
return palindrome(s,a+1,b-1);
return 1;
}
int main()
{
char s[255];
cin.getline(s,255);
if(palindrome(s,0,strlen(s)-1))
cout<<"It’s a palindrome";
else
cout<<"It’s not a palindrome";
return 0;
}
1. Define a recursive subroutine that displays the
digits of a string of characters passed as a
parameter. The string contains only letters and
digits.
Example: for the string avion23ABB567, the
subroutine displays 23567.
Implementation:

#include <iostream>
#include <cstring>
using namespace std;
void displayDigits(char s[255])
{ 
if(strlen(s)!=0)
{ 
if(isdigit(s[0]))
cout<<s[0];
displayDigits(s+1);
}
}
int main()
{
char s[255];
cin.getline(s,255);
displayDigits(s);
return 0;
}

CHAPTER 11 – BACKTRACKING
11.1 Permutations and Derived Problems
11.2 Arrangements and Derived Problems
11.3 Combinations and Derived Problems
11.4 Subsets and Derived Problems
11.5 Cartesian Product and Derived Problems
11.6 Set Partitions and Derived Problems
11.7 Number Partitions and Derived Problems
11.8 Problems with Variable Solution Length
11.9 Generalized Backtracking
Applications

11.1  PERMUTATIONS AND
DERIVED PROBLEMS
1. Let n be a non-zero natural number (n≤10).
Display all configurations of the elements in the set
A={1,2,3,...,n}.
Example: For n=3, the configurations are displayed in
the following order:
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
Implementation:
#include <iostream>
using namespace std;
int st[20],n;
void displayData()
{
int i;

for(i=1;i<=n;i++)
cout<<st[i]<<" ";
cout<<endl;
}
int Valid(int k)
{
int i;
for(i=1;i<=k-1;i++)
if(st[k]==st[i])
return 0;
return 1;
}
void Back(int k)
{
int i;
for(i=1;i<=n;i++)
{
st[k]=i;
if(Valid(k)==1)
if(k==n)
displayData();
else
Back(k+1);

}
}
int main()
{
cin>>n;
Back(1);
return 0;
}
1. Read from the keyboard n, a non-zero natural
number (n≤10), and the elements of a set A that
stores n integers. Display all configurations of the
elements in the set A={a1,a2,...,an}.
Example: For n=3 and A={7,9,5}, the
configurations are displayed in the following order:
7 9 5
7 5 9
9 7 5
9 5 7
5 7 9
5 9 7

Implementation:
#include <iostream>
using namespace std;
int v[20];
int st[20],n;
void displayData()
{
int i;
for(i=1;i<=n;i++)
cout<<v[st[i]]<<" ";
cout<<endl;
}
int Valid(int k)
{
int i;
for(i=1;i<=k-1;i++)
if(st[k]==st[i])
return 0;
return 1;
}
void Back(int k)
{

int i;
for(i=1;i<=n;i++)
{
st[k]=i;
if(Valid(k)==1)
if(k==n)
displayData();
else
Back(k+1);
}
}
int main()
{
int i;
cin>>n;
for(i=1;i<=n;i++)
cin>>v[i];
Back(1);
return 0;
}
1. Read from the keyboard n, a non-zero natural
number (n≤10), and the names of n children. Find

all possible arrangements of the n children in a
line.
Implementation:
#include <iostream>
#include <fstream>
#include <cstring>
using namespace std;
char a[20][30];
int st[20],n;
void readData()
{
ifstream f("date.in");
int i;
f>>n;
f.get();
for(i=1;i<=n;i++)
f.getline(a[i],30);
}
void displayData()
{
int i;
for(i=1;i<=n;i++)

cout<<a[st[i]]<<" ";
cout<<endl;
}
int Valid(int k)
{
int i;
for(i=1;i<=k-1;i++)
if(st[k]==st[i])
return 0;
return 1;
}
void Back(int k)
{
int i;
for(i=1;i<=n;i++)
{
st[k]=i;
if(Valid(k)==1)
if(k==n)
displayData();
else
Back(k+1);
}

}
int main()
{
readData();
Back(1);
return 0;
}
1. Read from the keyboard n, a non-zero natural
number (n≤10), and the elements of a set A that
stores n integers. Display all configurations of the
elements in the set A={a1,a2,...,an} that do not
contain two consecutive elements of the same
parity.
Example: For n=3 and A={7,8,9}, the
configurations are displayed in the following order:
7 8 9
9 8 7
Implementation:
#include <iostream>
using namespace std;
int st[20],v[20],n;

void displayData()
{
int i;
for(i=1; i<=n; i++)
cout<<v[st[i]]<<" ";
cout<<endl;
}
int Valid(int k)
{
if(k>1)
if(st[k-1]%2==st[k]%2)
return 0;
for(int i=1; i<=k-1; i++)
if(st[k]==st[i])
return 0;
return 1;
}
void Back(int k)
{
int i;
for(i=1; i<=n; i++)
{
st[k]=i;

if(Valid(k)==1)
if(k==n)
displayData();
else
Back(k+1);
}
}
int main()
{
int i;
cin>>n;
for(i=1; i<=n; i++)
{
cout<<"v["<<i<<"]=";
cin>>v[i];
}
Back(1);
return 0;
}
1. The Rocks Problem. On an nxn chessboard
(n≤10), place n rocks. Display all configurations of
the rocks on the chessboard such that no two rocks
attack each other. Solutions are expressed by the

coordinates of the rocks on the chessboard. Two
rocks attack each other when they are on the same
row or the same column.
Example: For n=3, the configurations are
displayed in the following order:
(1,1) (2,2) (3,3)
(1,1) (2,3) (3,2)
(1,2) (2,1) (3,3)
(1,2) (2,3) (3,1)
(1,3) (2,1) (3,2)
(1,3) (2,2) (3,1)
Implementation:
#include <iostream>
using namespace std;
int st[20],n;
int ns;
void displayData()
{
int i;
for(i=1; i<=n; i++)

cout<<st[i]<<" ";
cout<<endl;
ns++;
}
void displayData2()
{
int i,j;
for(i=1; i<=n; i++)
{
for(j=1; j<=n; j++)
if(st[i]==j)
cout<<"O ";
else
cout<<"- ";
cout<<endl;
}
cout<<endl;
}
void displayData3()
{
int i,j;
for(i=1; i<=n; i++)
cout<<"("<<i<<","<<st[i]<<") ";

cout<<endl;
}
int Valid(int k)
{
int i;
for(i=1; i<=k-1; i++)
if(st[k]==st[i])
return 0;
return 1;
}
void Back(int k)
{
int i;
for(i=1; i<=n; i++)
{
st[k]=i;
if(Valid(k)==1)
if(k==n)
{
displayData();
displayData2();
displayData3();
}

else
Back(k+1);
}
}
int main()
{
cin>>n;
Back(1);
cout<<"There are  "<<ns<<" solutions.";
return 0;
}
1. The N-Queens Problem. On an nxn chessboard
(4≤n≤10), place n queens. Display all
configurations of the queens on the chessboard
such that no two queens attack each other.
Solutions are expressed by the coordinates of the
queens on the chessboard. Two queens attack each
other when they are on the same row, the same
column, or the same diagonal.
Example: For n=4, the configurations are
displayed in the following order:
(1,2) (2,4) (3,1) (4,3)

(1,3) (2,1) (3,4) (4,2)
Implementation:
#include <iostream>
#include <cmath>
using namespace std;
int st[20],n;
int ns;
void DisplayData1()
{
int i;
for(i=1; i<=n; i++)
cout<<st[i]<<" ";
cout<<endl;
ns++;
}
void DisplayData2()
{
int i;
for(i=1; i<=n; i++)
cout <<"("<<i<<","<<st[i]<<") "<<" ";
cout << endl;
}

void DisplayData3()
{
int i,j;
for(i=1; i<=n; i++)
{
for(j=1; j<=n; j++)
if(st[i]==j)
cout<<"O ";
else
cout<<"- ";
cout<<endl;
}
cout << endl;
}
int Valid(int k)
{
for(int i=1; i<=k-1; i++)
if(st[k]==st[i] || abs(i-k)==abs(st[i]-st[k]))
return 0;
return 1;
}
void Back(int k)
{

int i;
for(i=1; i<=n; i++)
{
st[k]=i;
if(Valid(k)==1)
if(k==n)
{
DisplayData1();
DisplayData2();
DisplayData3();
}
else
Back(k+1);
}
}
int main()
{
cin>>n;
Back(1);
cout<<"There are  "<<ns<<" solutions.";
return 0;
}

1. The Camel Problem. n (n≤10) camels numbered
from 1 to n are arranged in a line. Rearrange the
camels so that each camel has a different camel in
front of it compared to the initial configuration.
Example: For n=3, the configurations are
displayed in the following order:
1 3 2
2 1 3
3 2 1
Implementation:
#include <iostream>
using namespace std;
int st[20],n;
void displayData()
{
int i;
for(i=1; i<=n; i++)
cout<<st[i]<<" ";
cout<<endl;
}
int Valid(int k)

{
if(k>1)
if(st[k]==st[k-1]+1)
return 0;
int i;
for(i=1; i<k; i++)
if(st[k]==st[i])
return 0;
return 1;
}
void Back(int k)
{
int i;
for(i=1; i<=n; i++)
{
st[k]=i;
if(Valid(k)==1)
if(k==n)
displayData();
else
Back(k+1);
}
}

int main()
{
cin>>n;
Back(1);
return 0;
}
1. A natural number n with at most 9 digits is read.
Generate all numbers having the same digits as n.
What is the largest one?
Example: For n=112, the generated numbers will
be:
121
211
where 211 is the largest.
Implementation:
#include <iostream>
using namespace std;
int st[20],n,x,maxi;
int v[20];
void descompunere()

{
while(x>0)
{
n++;
v[n]=x%10;
x=x/10;
}
}
void displayData()
{
int i,y=0;
for(i=1; i<=n; i++)
y=y*10+v[st[i]];
cout<<y<<" ";
if(y>maxi)
maxi=y;
//cout<<endl;
}
int Valid(int k)
{
if(k==1&&v[st[k]]==0)
return 0;
for(int i=1; i<=k-1; i++)

{
if(st[k]==st[i])
return 0;
if(v[st[k]]==v[st[i]]&&st[i]>st[k])
return 0;
}
return 1;
}
void Back(int k)
{
int i;
for(i=1; i<=n; i++)
{
st[k]=i;
if(Valid(k)==1)
{
if(k==n)
displayData();
else
Back(k+1);
}
}
}

int main()
{
cin>>x;
descompunere();
Back(1);
cout<<endl;
cout<<"The largest is: "<<maxi;
return 0;
}
1. Anagrams. A word is read from the keyboard. The
word can have at most 8 letters. Display all
anagrams of this word (words with the same
letters, but in a different order).
Implementation:
#include <iostream>
#include <cstring>
using namespace std;
int n,st[9];
char s[9];
void displayData()
{
int i;

for(i=1;i<=n;i++)
cout<<s[st[i]-1]<<" ";
cout<<endl;
}
int Valid(int k)
{
int i;
for(i=1;i<=k-1;i++)
if(st[k]==st[i])
return 0;
return 1;
}
void Back(int k)
{
int i;
for(i=1;i<=n;i++)
{
st[k]=i;
if(Valid(k)==1)
if(k==n)
displayData();
else
Back(k+1);

}
}
int main()
{
cout<<"Introduceti un cuvant: ";
cin.get(s,9);
n=strlen(s);
Back(1);
return 0;
}
1. Anagrams II. A word is read from the keyboard.
The word can have at most 8 letters. Display all
anagrams of this word (words with the same
letters, but in a different order) that do not contain
more than two consecutive consonants.
Implementation:
#include <iostream>
#include <cstring>
using namespace std;
int n, st[9];
char s[9];
void displayData()

{
int i;
for(i=1; i<=n; i++)
cout<<s[st[i]-1]<<" ";
cout<<endl;
}
int Valid(int k)
{
if(k>1)
if(strchr("bcdfghjklmnpqrstvwxyz",s[st[k]-1]) &&
strchr("bcdfghjklmnpqrstvwxyz",s[st[k-1]-1]))
return 0;
int i;
for(i=1; i<=k-1; i++)
if(st[k]==st[i])
return 0;
return 1;
}
void Back(int k)
{
int i;
for(i=1; i<=n; i++)
{

st[k]=i;
if(Valid(k)==1)
if(k==n)
displayData();
else
Back(k+1);
}
}
int main()
{
cout<<"A word: ";
cin.get(s,9);
n=strlen(s);
Back(1);
return 0;
}
1. Conflicts. The names of n people (n≤10) who are
seated at a round table are read. Conflicts have
arisen between any two adjacent people. Write a
program to display all possible ways to rearrange
the people so that no two conflicting individuals
are seated together.

Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int st[20],n,k,ns;
char s[20][30];
void read()
{
ifstream f("date.in");
f>>n;
int i;
for(i=1; i<=n; i++)
{
f>>s[i];
f.get();
}
}
void DisplayData()
{
int i;
for(i=1; i<=n; i++)
cout<<s[st[i]]<<" ";

cout<<endl;
ns++;
}
int Valid()
{
if(k>1)
if(st[k]==st[k-1]+1 || st[k]==st[k-1]-1)
return 0;
for(int i=1; i<=k-1; i++)
if(st[k]==st[i])
return 0;
return 1;
}
void Back()
{
k=1;
while(k>0)
{
if(st[k]<n)
{
st[k]=st[k]+1;
if(Valid()==1)
if(k==n)

DisplayData();
else
{
k++;
st[k]=0;
}
}
else
k—;
}
}
int main()
{
read();
Back();
cout<<ns<<" solutions!";
return 0;
}
1. There are 2*n children of different heights. The
height of each child is read. Arrange the children in
2 rows as follows:

-  In both rows, the children should be arranged in
ascending order of height.
-  The children in the second row should be taller than
the ones in front of them.
Implementation:
#include <fstream>
using namespace std;
ifstream fin("children.in");
ofstream fout("children.out");
int X[20],P[20],A[20],n;
void displayData()
{
for(int i=1;i<=n/2;i++) //row 1
fout<<A[X[i]]<<" ";
fout<<endl;
for(int i=n/2+1;i<=n;i++) //row 2
fout<<A[X[i]]<<" ";
fout<<endl;
fout<<endl;
}
int verif(int k)

{
if(k!=1 && k!=n/2+1)
if(A[X[k]]>=A[X[k-1]]) return 0;//left
if(k>n/2)
if(A[X[k]]>=A[X[k-n/2]]) return 0;//front
return 1;
}
void back(int k)
{
for(int i=1;i<=n;i++)
if(P[i]==0)
{
X[k]=i;
P[i]=1;
if(verif(k))
if(k==n) displayData();
else back(k+1);
P[i]=0;
}
}
int main()
{
fin>>n;

n=n*2;
for(int i=1;i<=n;i++)
fin>>A[i];
for(int i=1;i<n;i++)
for(int j=i+1;j<=n;j++)
if(A[i]<A[j])
{
int aux=A[i]; A[i]=A[j]; A[j]=aux;
}
back(1);
return 0;
}
1. The Traveling Salesman Problem. A traveling
salesman needs to visit a total of n cities, starting
from city 1. Given the connections between cities,
expressed as m pairs of cities, the task is to find all
possible routes that the traveling salesman can
take.
Implementation:
#include <fstream>
using namespace std;
const int DMAX = 100;

ifstream fin("tsp.in");
ofstream fout("tsp.out");
int n,m,ad[DMAX][DMAX];
int lgMin = 1e9,trMin[DMAX],lg;
int tr[DMAX];
bool vis[DMAX];
void bkt(int pos) {
if (lg >= lgMin)
return;
if (pos == n + 1) {
if (!ad[tr[n]][1])
return;
lg += ad[tr[n]][1];
if (lg < lgMin) {
lgMin = lg;
for (int i = 1; i <= n; i++)
trMin[i] = tr[i];
}
lg -= ad[tr[n]][1];
return;
}
for (int i = 2; i <= n; i++)
if (!vis[i] && ad[tr[pos - 1]][i]) {

vis[tr[pos] = i] = true;
lg += ad[tr[pos - 1]][i];
bkt(pos + 1);
vis[i] = false;
lg -= ad[tr[pos - 1]][i];
}
}
int main()
{
fin>>n>>m;
for (int i = 0; i < m; i++) {
int x, y, z; fin >> x >> y >> z;
ad[x][y] = ad[y][x] = z;
}
vis[tr[1] = 1] = true;
bkt(2);
fout << lgMin << '\n';
for (int i = 1; i <= n; i++)
fout << trMin[i] << ' ';
fout << '\n';
return 0;
}

1. The Traveling Salesman Problem II. A traveling
salesman needs to visit a total of n cities, starting
from city 1. Given the connections between cities,
expressed as m pairs of cities, the task is to find all
possible routes that the traveling salesman can
take.
Implementation:
#include <fstream>
using namespace std;
const int DMAX = 100;
ifstream fin("tsp.in");
ofstream fout("tsp.out");
int n,m,ad[DMAX][DMAX];
int lgMin = 1e9,trMin[DMAX],lg;
int tr[DMAX];
bool vis[DMAX];
void bkt(int pos) {
if (lg >= lgMin)
return;
if (pos == n + 1) {
if (!ad[tr[n]][1])
return;
lg += ad[tr[n]][1];

if (lg < lgMin) {
lgMin = lg;
for (int i = 1; i <= n; i++)
trMin[i] = tr[i];
}
lg -= ad[tr[n]][1];
return;
}
for (int i = 2; i <= n; i++)
if (!vis[i] && ad[tr[pos - 1]][i]) {
vis[tr[pos] = i] = true;
lg += ad[tr[pos - 1]][i];
bkt(pos + 1);
vis[i] = false;
lg -= ad[tr[pos - 1]][i];
}
}
int main()
{
fin>>n>>m;
for (int i = 0; i < m; i++) {
int x, y, z; fin >> x >> y >> z;
ad[x][y] = ad[y][x] = z;

}
vis[tr[1] = 1] = true;
bkt(2);
fout << lgMin << '\n';
for (int i = 1; i <= n; i++)
fout << trMin[i] << ' ';
fout << '\n';
return 0;
}
1. Given a matrix with n x n (n≤10) components,
find the largest sum that can be obtained by
summing n values taken from different rows and
columns.
Example. For n=3 and the matrix:
.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int st[20],n,k;

int a[20][20],smax,v[20];
void read()
{
ifstream f("date.in");
int i,j;
f>>n;
for(i=1; i<=n; i++)
for(j=1; j<=n; j++)
f>>a[i][j];
}
void display()
{
int i,s=0;
for(i=1; i<=n; i++)
{
//cout<<a[i][st[i]]<<" ";
s=s+a[i][st[i]];
}
if(s>smax)
{
smax=s;
for(i=1; i<=n; i++)
v[i]=a[i][st[i]];

}
}
int valid()
{
for(int i=1; i<=k-1; i++)
if(st[k]==st[i])
return 0;
return 1;
}
void backt()
{
k=1;
while(k>0)
if(st[k]<n)
{
st[k]=st[k]+1;
if(valid()==1)
if(k==n)
display();
else
{
k++;
st[k]=0;

}
}
else k—;
}
int main()
{
read();
backt();
cout<<"The largest sum is "<<smax<<endl;
cout<<"The numbers are: ";
for(int i=1;i<=n;i++)
cout<<v[i]<<" ";
return 0;
}
1. Read 2n integers from the keyboard/text file.
Generate the configuration:
x1× x2 +x3 × x4 + ... + x2n-1 × x2n with the maximum
value.
Implementation:
#include <iostream>

#include <fstream>
using namespace std;
int n,x[100],v[100],smax=0,k,s,i;
void readData()
{ 
ifstream f("date.in");
f>>n;
for(i=1;i<=2*n;i++)
f>>v[i];
}
void init(int k)
{
x[k]=0;
}
int exista(int k)
{
if(x[k]<n)
return 1;
return 0;
}
int cont(int k)
{
for(i=1;i<k;i++)

if(x[k]==x[i])
return 0;
return 1;
}
int solutie(int k)
{
if(k==n)
return 1;
return 0;
}
void maxim(int s)
{
if(smax<s)
smax=s;
}
int suma()
{
s=0;
for(i=1;i<=n;i++)
s=s+v[2*x[i]-1]*v[2*x[i]];
return s;
}
void back()

{
k=1;
init(k);
while(k>0)
{
if(exista(k))
{
x[k]=x[k]+1;
if(cont(k))
if(solutie(k))
maxim(suma());
else
{
k++;
init(k);
}
}
else
k—;
}
}
int main()
{

readData();
back();
cout<<smax;
}
1. Cartesian coordinates of n points are read. Display
a configuration of those n points whose order
determines the broken line with the greatest
length.
Implementation:
#include <iostream>
#include <cmath>
#include <fstream>
using namespace std;
int a[100],k,i,n;
float s,smax=0;
struct punct
{
float x,y;
};
punct v[100],b[100];
void readData()
{

ifstream f("date.in");
f>>n;
for(i=1;i<=n;i++)
{
f>>v[i].x;
f>>v[i].y;
}
}
void init(int k)
{
a[k]=0;
}
int exista(int k)
{
if(a[k]<n)
return 1;
return 0;
}
int cont(int k)
{
for(i=1;i<k;i++)
if(a[i]==a[k])
return 0;

return 1;
}
int solutie(int k)
{
if(k==n)
return 1;
return 0;
}
float linie()
{
s=0;
for(i=1;i<n;i++)
s=s+sqrt((v[a[i]].x*v[a[i+1]].x)*(v[a[i]].x*v[a[i+1]].x)+
(v[a[i]].y*v[a[i+1]].y)*(v[a[i]].y*v[a[i+1]].y));
return s;
}
void maxim(float s)
{
if(smax<s)
{
smax=s;
for(i=1;i<=n;i++)
b[i]=v[a[i]];

}
}
void tip()
{
cout<<"max="<<smax<<endl;
for(i=1;i<=n;i++)
cout<<b[i].x<<" "<<b[i].y<<endl;
}
void back()
{
k=1;
init(k);
while(k>0)
{
if(exista(k))
{
a[k]=a[k]+1;
if(cont(k))
if(solutie(k))
maxim(linie());
else
{
k++;

init(k);
}
}
else
k—;
}
}
int main()
{
readData();
back();
tip();
}

11.2  ARRANGEMENTS AND
DERIVED PROBLEMS
1. Let n and m be non-zero natural numbers (n≤10,
m<n). Display all configurations formed from m
elements of the set A={1,2,3,...,n}.
Example. For n=3 and m=2, the configurations are
displayed in the following order:
1 2
1 3
2 1
2 3
3 1
3 2
Implementation:
#include <iostream>
using namespace std;
int st[20],n,k,m;
void DisplayData()
{
int i;

for(i=1; i<=m; i++)
cout<<st[i]<<" ";
cout<<endl;
}
int Valid()
{
for(int i=1; i<=k-1; i++)
if(st[k]==st[i])
return 0;
return 1;
}
void Back()
{
k=1;
while(k>0)
{
if(st[k]<n)
{
st[k]=st[k]+1;
if(Valid()==1)
if(k==m)
DisplayData();
else

{
k++;
st[k]=0;
}
}
else
k—;
}
}
int main()
{
cout<<"n=";
cin>>n;
cout<<"m=";
cin>>m;
int i;
Back();
return 0;
}
1. Read from the keyboard n and m, non-zero natural
numbers (n≤10, m<n), and the elements of a set
A that stores n integers. Display all configurations

formed from m elements of the set A=
{a1,a2,...,an}.
Example. For n=3, m=2, and A={7,9,5}, the
configurations are displayed in the following order:
7 9
7 5
9 7
9 5 
5 7
5 9
Implementation:
#include <iostream>
using namespace std;
int st[20],n,k,m,v[20];
void DisplayData()
{
int i;
for(i=1; i<=m; i++)
cout<<v[st[i]]<<" ";
cout<<endl;

}
int Valid()
{
for(int i=1; i<=k-1; i++)
if(v[st[k]]==v[st[i]])
return 0;
return 1;
}
void Back()
{
k=1;
while(k>0)
{
if(st[k]<n)
{
st[k]=st[k]+1;
if(Valid()==1)
if(k==m)
DisplayData();
else
{
k++;
st[k]=0;

}
}
else
k—;
}
}
int main()
{
cout<<"n=";
cin>>n;
cout<<"m=";
cin>>m;
int i;
for(i=1; i<=n; i++)
{
cout<<"v["<<i<<"]=";
cin>>v[i];
}
Back();
return 0;
}

1. Write a program to display all n-digit numbers
(n≤10) composed only of distinct digits and
divisible by 4.
Implementation:
#include <iostream>
using namespace std;
int x[100],i,k,n,n1;
void init(int k)
{
x[k]=-1;
}
int exista(int k)
{
if(x[k]<9)
return 1;
return 0;
}
int cont(int k)
{
for(i=1;i<k;i++)
if(x[k]==x[i])
return 0;

return 1;
}
int solutie(int k)
{
if(k==n && (x[n1]*10+x[n])%4==0 &&x[1]!=0)
return 1;
return 0;
}
void tip()
{
for(i=1;i<=n;i++)
cout<<x[i];
cout<<endl;
}
void back()
{
k=1;
init(k);
while(k>0)
if(exista(k))
{
x[k]=x[k]+1;
if(cont(k))

if(solutie(k))
tip();
else
{
k++;
init(k);
}
}
else
k—;
}
int main()
{
cout<<"n=";cin>>n;
back();
return 0;
}
1. Given a set of n cubes, each cube being
characterized by its side length and color, write a
program that generates all the towers that can be
constructed with p cubes, such that two adjacent
cubes do not have the same color, and a cube with

a larger side cannot be placed on top of a cube
with a smaller side.
Implementation:
#include <iostream>
#include <fstream>
#include <cstring>
using namespace std;
int x[100],k,n,i,p;
struct cub
{
char cul[10];
float l;
};
cub v[100];
void readData()
{
ifstream f("date.in");
f>>n>>p;
for(i=1;i<=n;i++)
{
f>>v[i].cul;
f>>v[i].l;

}
}
void init(int k)
{
x[k]=0;
}
int exista(int k)
{
if(x[k]<p)
return 1;
return 0;
}
int cont(int k)
{
for(i=1;i<k;i++)
if(x[i]==x[k])
return 0;
return 1;
}
int cond()
{
for(i=1;i<n;i++)

if(strcmp(v[x[i]].cul,v[x[i+1]].cul)==0 ||
v[x[i]].l<v[x[i+1]].l)
return 0;
return 1;
}
int solutie(int k)
{
if(k==p)
return 1;
return 0;
}
void tip()
{
for(i=n;i>=1;i—)
{
cout<<v[x[i]].l<<" "<<v[x[i]].cul;
cout<<endl;
}
cout<<endl;
}
void back()
{
k=1;

init(k);
while(k>0)
if(exista(k))
{
x[k]=x[k]+1;
if(cont(k))
if(solutie(k) && cond())
tip();
else
{
k++;
init(k);
}
}
else
k—;
}
int main()
{
readData();
back();
return 0;
}

1. A number x is read from the keyboard. Generate
the largest number that can be obtained from x by
removing n digits from it.
Implementation:
#include <iostream>
using namespace std;
int maxi=0,m=0,n,i,k,v[100],x[100],a,nr;
void readData()
{
cin>>a>>n;
while(a!=0)
{
m++;
v[m]=a%10;
a=a/10;
}
}
void init(int k)
{
x[k]=0;
}
int exista(int k)

{
if(x[k]<m)
return 1;
return 0;
}
int cont(int k)
{
for(i=1;i<k;i++)
if(x[k]==x[i])
return 0;
return 1;
}
int solutie(int k)
{
if(k==m-n)
return 1;
return 0;
}
void maxim()
{
nr=0;
for(i=1;i<=m-n;i++)
nr=nr*10+v[x[i]];

if(maxi<nr)
maxi=nr;
}
void back()
{
k=1;
init(k);
while(k>0)
if(exista(k))
{
x[k]=x[k]+1;
if(cont(k))
if(solutie(k))
maxim();
else
{
k++;
init(k);
}
}
else
k—;
}

int main()
{
readData();
back();
cout<<maxi;
return 0;
}
1. The Flag Problem. n colors (strings with a
maximum of 15 characters) are read from the
keyboard. Generate all flags using three distinct
colors, where the middle color can only be the first
or last color.
Implementation:
#include <iostream>
#include <fstream>
#include <cstring>
using namespace std;
int d=200;
int st[20], n, m=3, k;
char v[20][30],c[20],p[20];
void readData()
{

ifstream f("date.in");
f>>n;
for(int i=1; i<=n; i++)
{
f.get();
f.get(v[i],20);
strcpy(c,v[1]);
strcpy(p,v[n]);
}
}
void DisplayData()
{
int i;
for(i=1; i<=m; i++)
cout<<v[st[i]]<<" ";
cout<<endl;
}
int Valid()
{
if(k>=2)
if(stricmp(v[2],c)==0 || stricmp(v[2],p)==0)
return 0;
else

return 1;
for(int i=1; i<=k-1; i++)
if(st[k]==st[i])
return 0;
return 1;
}
void Back()
{
k=1;
while(k>0)
{
if(st[k]<n)
{
st[k]=st[k]+1;
if(Valid()==1)
if(k==m)
DisplayData();
else
{
k++;
st[k]=0;
}
}

else
k—;
}
}
int main()
{
readData();
Back();
cout<<endl;
cout<<c<<" "<<p;
return 0;
}
1. n words are read from the keyboard. For each
word, its type is also read, expressed by a
character: s for noun, v for verb, a for adjective, or
adverb. Generate all sentences formed from 3
words, one from each category.
Implementation:
#include <iostream>
#include <fstream>
#include <cstring>
using namespace std;

int x[100],k,i,n;
struct cuvant
{
char cuv[100];
char t[2];
};
cuvant v[100];
void readData()
{ 
ifstream f("date.in");
f>>n;
for(i=1;i<=n;i++)
f>>v[i].cuv>>v[i].t;
}
void init(int k)
{
x[k]=0;
}
int exista(int k)
{
if(x[k]<n)
return 1;
return 0;

}
int cont(int k)
{
for(i=1;i<k;i++)
if(x[k]==x[i])
return 0;
return 1;
}
int solutie(int k)
{
if(k==3)
return 1;
return 0;
}
int cond()
{
for(i=1;i<n;i++)
if(strcmp(v[x[i]].t,v[x[i+1]].t)==0)
return 0;
return 1;
}
void tip()
{

for(i=1;i<=3;i++)
cout<<v[x[i]].cuv<<" ";
cout<<endl;
}
void back()
{
k=1;
init(k);
while(k>0)
{ 
if(exista(k))
{
x[k]=x[k]+1;
if(cont(k))
if(solutie(k) && cond())
tip();
else
{
k++;
init(k);
}
}
else

k—;
}
}
int main()
{
readData();
back();
return 0;
}
1. n (n≤10) words are read from the keyboard,
where each word can be a string of up to 15
lowercase English alphabet letters. Display all
sequences formed by p words where each word
starts with a letter identical to the last letter of the
previous word.
Example: For n=5, p=2 and the apple, egg,
elephant, giraffe, gyroscope, the following
sequences are displayed, not necessarily in this order:
egg giraffe
egg gyroscope
apple egg
apple elephant

giraffe egg
giraffe elephant
gyroscope egg
gyroscope elephant
Implementation:
#include <iostream>
#include <fstream>
#include <cstring>
using namespace std;
int st[20],n,k,m;
char v[20][15];
void readData()
{
ifstream f("date.in");
int i;
f>>n;
for(i=1;i<=n;i++)
{
f.get();
f.get(v[i],15);
}
}

void DisplayData()
{
int i;
for(i=1; i<=m; i++)
cout<<v[st[i]]<<" ";
cout<<endl;
}
int verific1(char a[15],char b[15])
{
int n=strlen(a);
if(a[n-1]==b[0])
return 1;
return 0;
}
int Valid()
{
if(k>1)
if(verific1(v[st[k-1]],v[st[k]])==0)
return 0;
for(int i=1; i<=k-1; i++)
if(st[k]==st[i])
return 0;
return 1;

}
void Back()
{
k=1;
while(k>0)
{
if(st[k]<n)
{
st[k]=st[k]+1;
if(Valid()==1)
if(k==m)
DisplayData();
else
{
k++;
st[k]=0;
}
}
else
k—;
}
}
int main()

{
readData();
cout<<"m=";
cin>>m;
Back();
return 0;
}

11.3  COMBINATIONS AND
DERIVED PROBLEMS
1. Let n and m be non-zero natural numbers (n≤10,
m<n). Display all subsets formed from m elements
of the set A={1,2,3,...,n}.
Example. For n=4 and m=3, the configurations are
displayed in the following order:
1 2 3
1 2 4
1 3 4
2 3 4
Implementation:
#include <iostream>
using namespace std;
int st[20],n,k,ns,m;
void displayData()
{
for(int i=1; i<=m; i++)
cout<<st[i]<<" ";
cout<<endl;

ns++;
}
int valid()
{
if(k>1)
if(st[k]<=st[k-1])
return 0;
return 1;
}
void backt()
{
k=1;
while(k>0)
if(st[k]<n)
{
st[k]=st[k]+1;
if(valid()==1)
if(k==m)
{
displayData();
}
else
{

k++;
st[k]=0;
}
}
else k—;
}
int main()
{
cout<<"n=";
cin>>n;
cout<<"m=";
cin>>m;
backt();
cout<<endl;
cout<<ns<<" solutions.";
return 0;
}
1. Read from the keyboard n and m, non-zero natural
numbers (n≤10, m<n), and the elements of a set
A that stores n integers. Display all subsets formed
from m elements of the set A={a1,a2,a3,..,an}.

Example. For n=4, m=3, and A={7,9,5,6}, the
configurations are displayed in the following order:
7 9 5
7 9 6
7 5 6
9 5 6
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int st[20],v[20],n,k,ns,m;
void readData()
{
ifstream f("date.in");
f>>n>>m;
for(int i=1;i<=n;i++)
f>>v[i];
}
void displayData()
{
for(int i=1; i<=m; i++)

cout<<v[st[i]]<<" ";
cout<<endl;
ns++;
}
int valid()
{
if(k>1)
if(st[k]<=st[k-1])
return 0;
return 1;
}
void backt()
{
k=1;
while(k>0)
if(st[k]<n)
{
st[k]=st[k]+1;
if(valid()==1)
if(k==m)
{
displayData();
}

else
{
k++;
st[k]=0;
}
}
else k—;
}
int main()
{
readData();
backt();
cout<<endl;
cout<<"Sunt "<<ns<<" solutii ";
return 0;
}
1. The names and genders of n individuals are read
(n≤10). Display all the ways a group of p (p<n)
individuals can be formed from the group, where
each group will contain at least one woman and at
least one man.
Implementation:

#include <iostream>
#include <cstring>
#include <fstream>
using namespace std;
struct copii
{
char nume[100];
int sex;
};
copii v[100];
int x[100],i,k,n,p;
void readData()
{ 
ifstream f("date.in");
f>>n>>p;
for(i=1;i<=n;i++)
f>>v[i].nume>>v[i].sex;
}
void init(int k)
{
x[k]=0;
}
int exista(int k)

{
if(x[k]<n)
return 1;
return 0;
}
int cont(int k)
{
for(i=1;i<k;i++)
if(x[k]<=x[i])
return 0;
return 1;
}
int solutie(int k)
{
if(k==p)
for(i=1;i<p;i++)
if(v[x[i]].sex!=v[x[i+1]].sex)
return 1;
return 0;
}
void tip()
{
for(i=1;i<=p;i++)

cout<<v[x[i]].nume<<" ";
cout<<endl;
}
void back()
{
k=1;
init(k);
while(k>0)
{
if(exista(k))
{
x[k]=x[k]+1;
if(cont(k))
if(solutie(k))
tip();
else
{
k++;
init(k);
}
}
else
k—;

}
}
int main()
{
readData();
for(i=1;i<=n;i++)
cout<<v[i].nume<<" "<<v[i].sex<<endl;
back();
return 0;
}
1. Expression Optimization: Given two sets of
integers, A with m elements and B with n
elements (m, n≤10 and m<n), determine the
value of all expressions: 
that include all
elements from A and some of the elements from B.
Display the expression with the maximum value.
Example: For m=3, A={1, -5, 4} and n=4, B=
{-10, 100,10, 2}, one possible solution is:
-5 * 10 + 1 * 2 + 4 * 100 = 352. The expression
with the maximum value is:
1 * 10 + (-5) * (-10) + 4 * 100 = 460.
Implementation:

#include <iostream>
#include <fstream>
using namespace std;
int x[100],i,n,k,m,a[100],b[100],maxi=0,s;
void readData()
{ 
ifstream f("date.in");
f>>m;
for(i=1;i<=m;i++)
f>>a[i];
f>>n;
for(i=1;i<=n;i++)
f>>b[i];
}
void init(int k)
{
x[k]=0;
}
int exista(int k)
{
if(x[k]<n)
return 1;
return 0;

}
int cont(int k)
{
for(i=1;i<k;i++)
if(x[k]==x[i])
return 0;
return 1;
}
int solutie(int k)
{
if(k==m)
return 1;
return 0;
}
void maxim()
{
s=0;
for(i=1;i<=m;i++)
s=s+a[i]*b[x[i]];
cout<<s<<endl;
if(maxi<s)
maxi=s;
}

void back()
{
k=1;
init(k);
while(k>0)
{
if(exista(k))
{
x[k]=x[k]+1;
if(cont(k))
if(solutie(k))
maxim();
else
{
k++;
init(k);
}
}
else
k—;
}
}
int main()

{
readData();
back();
cout<<"Valoarea maxima: "<<maxi;
return 0;
}
1. Generate all numbers consisting of n strictly
increasing digits.
Example: For n=4, the output will be:
1234, 1235, 1236, ..., 6789
Implementation:
#include <iostream>
using namespace std;
int x[100],i,n,k,nr;
void readData()
{ 
cout<<"n=";
cin>>n;
}
void init(int k)

{
x[k]=0;
}
int exista(int k)
{
if(x[k]<9)
return 1;
return 0;
}
int cont(int k)
{
for(i=1;i<k;i++)
if(x[k]<=x[i])
return 0;
return 1;
}
int solutie(int k)
{
if(k==n)
return 1;
return 0;
}
void tip()

{
nr=0;
for(i=1;i<=n;i++)
nr=nr*10+x[i];
cout<<nr<<endl;
}
void back()
{
k=1;
init(k);
while(k>0)
{
if(exista(k))
{
x[k]=x[k]+1;
if(cont(k))
if(solutie(k))
tip();
else
{
k++;
init(k);
}

}
else
k—;
}
}
int main()
{
readData();
back();
return 0;
}
1. Generate all numbers consisting of n digits in
strictly increasing order, where the first digit is p.
Example: For n=4, p=3, the output will be:
3456, 3457, ..., 3789.
Implementation:
#include <iostream>
using namespace std;
int x[100],i,n,k,nr,p;
void readData()

{
cout<<"n=";cin>>n;
cout<<"p=";cin>>p;
}
void init(int k)
{
x[k]=0;
}
int exista(int k)
{
if(x[k]<9)
return 1;
return 0;
}
int cont(int k)
{
for(i=1;i<k;i++)
if(x[k]<=x[i])
return 0;
return 1;
}
int solutie(int k)
{

if(k==n-1)
return 1;
return 0;
}
void tip()
{
nr=p;
for(i=1;i<n;i++)
nr=nr*10+x[i];
cout<<nr<<endl;
}
void back()
{
k=1;
init(k);
while(k>0)
{
if(exista(k))
{
x[k]=x[k]+1;
if(cont(k))
if(solutie(k))
tip();

else
{
k++;
init(k);
}
}
else
k—;
}
}
int main()
{
readData();
back();
return 0;
}
1. Generate all numbers consisting of n digits in
strictly increasing order, where the first digit is p1
and the last digit is p2.
Example: For n=4, p1=3, p2=8, the output will be:
3458, 3468, ..., 3678

Implementation:
#include <iostream>
using namespace std;
int x[100],i,n,k,nr,p1,p2;
void readData()
{ 
cout<<"n=";cin>>n;
cout<<"p1=";cin>>p1;
cout<<"p2=";cin>>p2;
}
void init(int k)
{
x[k]=p1;
}
int exista(int k)
{
if(x[k]<9)
return 1;
return 0;
}
int cont(int k)
{

for(i=1;i<k;i++)
if(x[k]<=x[i]||x[k]>=p2)
return 0;
return 1;
}
int solutie(int k)
{
if(k==n-2)
return 1;
return 0;
}
void tip()
{
nr=p1;
for(i=1;i<n-1;i++)
nr=nr*10+x[i];
nr=nr*10+p2;
cout<<nr<<endl;
}
void back()
{
k=1;
init(k);

while(k>0)
{
if(exista(k))
{
x[k]=x[k]+1;
if(cont(k))
if(solutie(k))
tip();
else
{
k++;
init(k);
}
}
else
k—;
}
}
int main()
{
readData();
back();
return 0;

}

11.4  SUBSETS AND DERIVED
PROBLEMS
1. Let n be a non-zero natural number (n≤10).
Display all subsets of the elements of the set A=
{1,2,3,...,n}.
Example: For n=3, the subsets are displayed in the
following order:
1
1 2
1 2 3
1 3
2
2 3
3
Implementation:
#include <iostream>
using namespace std;
int x[100],i,n,k;
int exista(int k)
{

if(x[k]<n)
return 1;
return 0;
}
void tiparire(int k)
{
for(i=1;i<=k;i++)
cout<<x[i]<<" ";
cout<<endl;
}
void bkt()
{
k=1;
x[k]=0;
while(k>0)
{
if(exista(k))
{
x[k]=x[k]+1;
tiparire(k);
if(k<n)
{
k++;

x[k]=x[k-1];
}
}
else
k—;
}
}
int main()
{
cin>>n;
bkt();
return 0;
}
1. Read from the keyboard n, a non-zero natural
number (n≤10), and the elements of a set A that
stores n integers. Display all subsets of the set A=
{a1,a2,a3,..,an}.
Example: For n=3 and A={7,9,5}, the subsets
are displayed in the following order:
7
7 9

7 9 5
7 5
9
9 5
5
Implementation:
#include <iostream>
using namespace std;
int x[100],i,n,k,v[100];
void readData()
{ 
cin>>n;
for(i=1;i<=n;i++)
cin>>v[i];
}
int exista(int k)
{
if(x[k]<n)
return 1;
return 0;
}

void tiparire(int k)
{
for(i=1;i<=k;i++)
cout<<v[x[i]]<<" ";
cout<<endl;
}
void bkt()
{
k=1;
x[k]=0;
while(k>0)
{
if(exista(k))
{
x[k]=x[k]+1;
tiparire(k);
if(k<n)
{
k++;
x[k]=x[k-1];
}
}
else

k—;
}
}
int main()
{
readData();
bkt();
return 0;
}
1. Ports. On a sea, there are n (n≤10) ports. The
names of the ports and the cost of docking at each
port are known. Display all the possibilities of
docking in ports in such a way that no port is
visited more than once and the total cost falls
within a given interval: [s1, s2]. Display the
solution with the most dockings.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
struct porturi
{

char nume[100];
float pret;
}v[100];
int x[100],m,i,k,p=0,a[100],b[100],s1,s2,c[100]
[100],maxi=0,max1=0,o,n;
void readData()
{ 
ifstream f("date.in");
f>>n>>s1>>s2;
for(i=1;i<=n;i++)
{
f>>v[i].nume;
f>>v[i].pret;
}
}
int exista(int k)
{
if(x[k]<n)
return 1;
return 0;
}
void calcul(int k)
{

int s=0;
for(i=1;i<=k;i++)
s=s+v[x[i]].pret;
if(s1<=s && s2>=s)
{
p++;
a[p]=s;
b[p]=k;
for(i=1;i<=k;i++)
c[p][i]=x[i];
}
if(maxi<=a[p])
{
if(max1<b[p])
{
maxi=a[p];
max1=b[p];
o=p;
}
}
}
void back()
{

k=1;
x[k]=0;
while(k>0)
{
if(exista(k))
{
x[k]=x[k]+1;
calcul(k);
if(k<n)
{
k++;
x[k]=x[k-1];
}
}
else
k—;
}
}
void compare()
{
for(i=1;i<=b[o];i++)
cout<<v[c[o][i]].nume<<" ";
}

int main()
{
readData();
back();
compare();
return 0;
}
1. Increasing Subsequence. n (n≤15) integer
numbers are read. Display a non-necessarily
consecutive increasing subsequence that
maintains the original order and has maximum
length. In case there are multiple solutions, display
their number.
Example. For n=7, if the values are read: 6 7 8 5 3 1
10 9, the maximum-length increasing subsequences
are:
6 7 8 10
6 7 8 9
Implementation:
#include <iostream>

#include <fstream>
using namespace std;
int x[100],i,n,k,p,q=0,v[100],ns;
void readData()
{ 
ifstream f("date.in");
f>>n;
for(i=1;i<=n;i++)
f>>v[i];
}
int exista (int k)
{
if(x[k]<n)
return 1;
return 0;
}
int cond(int k)
{
for(i=1;i<k;i++)
if(v[x[i]]>v[x[i+1]])
return 0;
return 1;
} int solutie (int k)

{
if(k==p)
return 1;
return 0;
}
void back()
{
k=1;
x[k]=0;
while(k>0)
{
if(exista(k))
{
x[k]=x[k]+1;
if(solutie(k) && cond (k))
{
q=1;
for(i=1;i<=p;i++)
cout<<v[x[i]]<<" ";
ns++;
cout<<endl;
}
if(k<p)

{
k++;
x[k]=x[k-1];
}
}
else
k—;
}
}
int main()
{
readData();
for(p=n; p>=0 &&q==0;p—)
back();
cout<<ns<<" solutions";
return 0;
}
1. A natural number n, with at most 10 digits, is read.
Display the largest number that can be obtained by
removing p digits while preserving.
Implementation:
#include <iostream>

using namespace std;
int x[100],b[100],n,i,k,maxi=0,p,q=0,l=1,s[100];
void readData()
{
cout<<"n=";cin>>n;
cout<<"p=";cin>>p;
while(n!=0)
{
q++;
b[q]=n%10;
n=n/10;
}
}
int exista (int k)
{
if(x[k]<q)
return 1;
return 0;
}
int solutie(int k)
{
if(k==q-p)
return 1;

return 0;
}
void tiparire()
{
int u=1;
for(i=1;i<=k;i++)
{
s[l]=s[l]+b[x[i]]*u;
u=u*10;
}
l++;
}
void bkt()
{
k=1;
x[k]=0;
while(k>0)
{
if(exista(k))
{
x[k]=x[k]+1;
if(solutie(k))
tiparire();

if(k<q)
{
k++;
x[k]=x[k-1];
}
}
else
k—;
}
}
void smax()
{
int max=0;
for(i=1;i<=l;i++)
if(maxi<s[i])
maxi=s[i];
cout<<maxi;
}
int main()
{
readData();
bkt();
smax();

return 0;
}
1. Display all the numbers formed by distinct odd
digits. They will be displayed as follows: 1, 3, 5, ...,
13, 15, ..., 97, ..., 97531.
Implementation:
#include<iostream>
using namespace std;
int x[100],pus[100],n,p,nr=0;
void displayData(int p)
{
for(int i=1;i<=p;i++)
cout<<x[i];
cout<<endl;
nr++;
}
void Backtracking(int k, int p)
{ 
for(int i=1;i<=9;i=i+2)
if(!pus[i])
{
x[k]=i;

pus[i]=1;
if(k==p)
displayData(p);
else
Backtracking(k+1,p);
pus[i]=0;
}
}
int main()
{
n=5;
for(p=1;p<=5;p++) 
Backtracking(1,p);
cout<<nr<<" numbers.";
return 0;
} 

11.5  CARTESIAN PRODUCT AND
DERIVED PROBLEMS
1. Let n and m be non-zero natural numbers (n≤10,
m≤10). Display all the elements of the Cartesian
product 
, where A={1,2,3,...,n},
repeated m times.
m times
Example: for n=3, m=4, the configurations are
displayed in this order:
1 1 1 1
1 1 1 2
1 1 2 1
1 1 2 2
.........
3 3 3 2
3 3 3 3
Implementation:
#include <iostream>
using namespace std;

int x[100],i,n,k,p[100],m;
void readData()
{
cout<<"n=";cin>>n;
cout<<"m=";cin>>m;
}
void init(int k)
{
x[k]=0;
}
int exista(int k)
{
if(x[k]<n)
return 1;
return 0;
}
int solutie(int k)
{
if(k==m)
return 1;
return 0;
}
void tiparire()

{
for(i=1;i<=k;i++)
cout<<x[i]<<" ";
cout<<endl;
}
void back()
{
k=1;
init(k);
while(k>0)
{
if(exista(k))
{
x[k]=x[k]+1;
if(solutie(k))
tiparire();
else
{
k++;
init(k);
} 
}
else

k—;
}
}
int main()
{
readData();
back();
return 0;
}
1. We read from the keyboard n and m, positive
natural numbers (n≤10, m≤10), and the elements
of a set A={a1,a2,a3,..,an} which stores n integer
numbers. Display all the elements of the Cartesian
product 
.
m times
Example: for n=3, m=4, and A={7,9,5}, the
configurations are displayed in this order:
7 7 7 7
7 7 7 9
7 7 9 7

7 7 9 9
.........
5 5 5 9
5 5 5 5
Implementation:
#include <iostream>
using namespace std;
int x[100],i,n,k,v[100],m;
void readData()
{
cin>>n>>m;
for(i=1;i<=n;i++)
cin>>v[i];
}
void init(int k)
{
x[k]=0;
}
int exista(int k)
{
if(x[k]<n)

return 1;
return 0;
}
int solutie(int k)
{
if(k==m)
return 1;
return 0;
}
void tiparire()
{
for(i=1;i<=k;i++)
cout<<v[x[i]]<<" ";
cout<<endl;
}
void back()
{
k=1;
init(k);
while(k>0)
{
if(exista(k))
{

x[k]=x[k]+1;
if(solutie(k))
tiparire();
else
{
k++;
init(k);
}
}
else
k—;
}
}
int main()
{
readData();
back();
return 0;
}
1. Generate the Cartesian product of n sets. For each
set, the number of elements is known. Each set ai

contains pi elements, respectively values from 1 to
pi.
Example: for n=4, p1=2, p2=3, p3=3, p4=4,
the elements of the product {1,2} × {1,2,3} ×
{1,2,3} × {1,2,3,4} are:
(1 1 1 1)(1 1 1 2)(1 1 1 3)(1 1 1 4)(1 1 2 1)(1 1 2 2)(1 1
2 3)(1 1 2 4)
(1 1 3 1)(1 1 3 2)(1 1 3 3)(1 1 3 4)
(1 2 1 1)(1 2 1 2)(1 2 1 3)(1 2 1 4)(1 2 2 1)(1 2 2 2)(1 2
2 3)(1 2 2 4)
(1 2 3 1)(1 2 3 2)(1 2 3 3)(1 2 3 4)
(1 3 1 1)(1 3 1 2)(1 3 1 3)(1 3 1 4)(1 3 2 1)(1 3 2 2)(1 3
2 3)(1 3 2 4)
(1 3 3 1)(1 3 3 2)(1 3 3 3)(1 3 3 4)
(2 1 1 1)(2 1 1 2)(2 1 1 3)(2 1 1 4)(2 1 2 1)(2 1 2 2)(2 1
2 3)(2 1 2 4)
(2 1 3 1)(2 1 3 2)(2 1 3 3)(2 1 3 4)
(2 2 1 1)(2 2 1 2)(2 2 1 3)(2 2 1 4)(2 2 2 1)(2 2 2 2)(2 2
2 3)(2 2 2 4)
(2 2 3 1)(2 2 3 2)(2 2 3 3)(2 2 3 4)

(2 3 1 1)(2 3 1 2)(2 3 1 3)(2 3 1 4)(2 3 2 1)(2 3 2 2)(2 3
2 3)(2 3 2 4)
(2 3 3 1)(2 3 3 2)(2 3 3 3)(2 3 3 4)
Implementation:
#include <iostream>
const int MAX_N = 4; // Maximum number of sets
const int p[MAX_N] = {2, 3, 3, 4}; // Number of elements
in each set
int n = 4; // Number of sets
int product[MAX_N];
void generateProduct(int setIndex) {
if (setIndex == n) {
// Base case: reached the last set, print the combination
for (int i = 0; i < n; i++) {
std::cout << product[i] << " ";
}
std::cout << std::endl;
return;
}
// Recursive case: try all elements in the current set
for (int i = 1; i <= p[setIndex]; i++) {
product[setIndex] = i;

generateProduct(setIndex + 1);
}
}
int main() {
generateProduct(0);
return 0;
}
1. Daniel has n cards (n≤9). On each card, a number
from 1 to 9 is written in ascending order. Using two
types of cards with the operators + and – , he
wants to generate:
a. All possible expressions and their values.
b. All possible expressions that yield the result 2.
Implementation:
a. 
#include <iostream>
using namespace std;
int st[10],n;
int ns;
void afi()
{ 

int s=0;
for(int i=1;i<=n;i++)
if(st[i]==1)
{
cout<<'+'<<i;
s=s+i;
}
else
{
cout<<'-'<<i;
s=s-i;
}
cout<<"="<<s<<endl;
ns++;
}
void bkt(int k)
{
for(int i=1;i<=2;i++)
{
st[k]=i;
///if(valid(k)==1)
if(k==n)
afi();

else
bkt(k+1);
}
}
int main()
{
cin>>n;
bkt(1);
cout<<ns<<" solutions.";
return 0;
}
a. 
#include <iostream>
using namespace std;
int st[10],n,x,s;
int ns;
void afi()
{
for(int i=1;i<=n;i++)
if(st[i]==1)
cout<<"+"<<i;
else

cout<<"-"<<i;
cout<<"="<<s<<endl;
ns++;
}
int valid(int k)
{
if(k==n)
{
s=0;///!!!!!
for(int i=1;i<=n;i++)
if(st[i]==1)
s=s+i;
else
s=s-i;
if(s!=x)
return 0;
}
return 1;
}
void bkt(int k)
{
for(int i=1;i<=2;i++)
{

st[k]=i;
if(valid(k)==1)
if(k==n)
afi();
else
bkt(k+1);
}
}
int main()
{ 
cout<<"n=";
cin>>n;
cout<<"Expressions with value x, x=";
cin>>x;
bkt(1);
cout<<ns<<" solutions.";
return 0;
}
1. Generate n pairs of correctly closed parentheses.
Example: for n=3, the following combinations are
obtained:

( ( ( ) ) ),
( ( ) ) ( ),
( ( ) ( ) ),
( ) ( ( ) ),
( ) ( ) ( ).
Implementation:
#include <iostream>
using namespace std;
int x[25],n;
void displayData()
{
int i;
for(i=1;i<=n;i++)
if(x[i]==1)
cout<<")";
else
cout<<"(";
cout<<endl;
}
int verif(int k)
{

int i,pi=0,pd=0;
for(i=1;i<=k;i++)
if(x[i]==0)
pd++;
else
pi++;
return (pd<=n/2 && pi<=pd);
}
void back(int k)
{
int i;
if(k==n+1)
displayData();
else
for(i=0;i<=1;i++)
{
x[k]=i;
if(verif(k))
back(k+1);
}
}
int main()
{

cout<<"n=";cin>>n;
n*=2;
back(1);
return 0;
}
1. All solutions are requested for arranging m dogs
and n cats in a line in such a way that there is no
cat between two dogs.
Implementation:
#include <iostream>
using namespace std;
int v[100],i,j,k,n,m;
void displayData()
{
int i;
for(i=1;i<=n+m;i++)
if(v[i]==1)
cout<<"Dog";
else
cout<<"Cat";
cout<<endl;
}

int cont(int k)
{
int s,t;
s=0;
t=0;
for(i=1;i<=k;i++)
if(v[i]==1)
s++;
else
t++;
if(k==n+m)
if(s>n && t>m)
return 0;
if(k>2 && v[k-2]==1 && v[k-1]==2 && v[k]==1)
return 0;
return 1;
}
void back(int k)
{
int i;
for(i=1;i<=2;i++)
{
v[k]=i;

if(cont(k)==1)
if(k==n+m)
displayData();
else
back(k+1);
}
}
int main()
{
cout<<"n=";cin>>n;
cout<<"m=";cin>>m;
back(1);
return 0;
}
1. Generate all palindrome numbers with n digits.
Example: for n=5, the following numbers are
generated:
10001
10101
10201

...
99999
Implementation:
#include <iostream>
#include <cmath>
using namespace std;
int isPalindrome(int x)
{
int y=0,x1=x;
while(x!=0)
{
y=y*10+x%10;
x=x/10;
}
if(x1==y)
return 1;
return 0;
}
int main()
{
int n,p1,p2;
cout<<"n=";cin>>n;

p1=pow(10,n-1);
p2=pow(10,n)-1;
cout<<p1<<" "<<p2<<endl;
for(int i=p1;i<=p2;i++)
if(isPalindrome(i)==1)
cout<<i<<endl;
return 0;
}
1. Generate all numbers composed of n (n≤9) even
digits.
Example: For n=3, display:
200 202 204, ..., 888.
Implementation:
#include <iostream>
using namespace std;
int X[11],n;
void afis()
{
for(int i=1;i<=n;i++)
cout<<X[i];

cout<<endl;
}
void back(int k,int sp)
{
for(int i=0;i<=8;i=i+2)
{
X[k]=i;
sp=sp+X[k];
if(X[1]!=0)
if(k==n)
afis();
else
back(k+1,sp);
sp=sp-X[k];
}
}
int main()
{
cout<<"n=";cin>>n;
back(1,0);
return 0;
}

1. Generate all numbers composed of n digits (n≤10)
in which each digit appears at most twice.
Implementation:
#include <iostream>
#include <cmath>
using namespace std;
bool digitFreq(int x)
{ 
bool ok=true;
int fv[10]={0};
while(x!=0)
{
fv[x%10]++;
x=x/10;
}
for(int i=0;i<=9;i++)
if(fv[i]>2)
ok=false;
return ok;
}
int main()
{ 

int n,p1,p2;
cout<<"n=";cin>>n;
p1=pow(10,n-1);
p2=pow(10,n)-1;
cout<<p1<<" "<<p2<<endl;
for(int i=p1;i<=p2;i++)
if(digitFreq(i)==true)
cout<<i<<endl;
return 0;
}
1. Generate all words of length p that can be formed
with the alphabet letters from a given set, where
each letter appears at most twice.
Implementation:
#include <iostream>
#include <string>
#include <vector>
using namespace std;
void displayData(vector<char> v)
{
for(int i=0; i<v.size(); i++)
cout<<v[i];

cout<<endl;
}
void back(vector<char> v, int k, int n,int p)
{
if (k == p)
displayData(v);
else
{
for(int i = 0; i < n; i++)
{
v[k]='a'+i;
back(v,k+1,n,p);
}
}
}
int main()
{
int n,p;
cout<<"n=";cin>>n;
cout<<"p=";cin>>p;
vector<char> v(n);
back(v,0,n,p);
return 0;

}
1. Generate all words of length p that can be formed
with the alphabet letters from a given set, where
there are no more than two consecutive
consonants.
Implementation:
#include <iostream>
#include <string>
#include <vector>
using namespace std;
void displayData(vector<char> v)
{
for(int i=0; i<v.size(); i++)
cout<<v[i];
cout<<endl;
}
int cond(vector<char> v)
{ 
vector<char> cons=
{'b','c','d','f','g','h','j','k','l','m','n','p','q','r','s',
't','v','w','x','y','z'};
for(int j=0;j<cons.size();j++)

for(int i=0; i<v.size()-1; i++)
if(v[i]==cons[j] && v[i+1]==cons[j])
return 0;
return 1;
}
void back(vector<char> v, int k, int n,int p)
{
if(k==p && cond(v)==1)
displayData(v);
else
{
for(int i = 0; i < n; i++)
{
v[k]='a'+i;
back(v,k+1,n,p);
}
}
}
int main()
{
int n,p;
cout<<"n=";cin>>n;
cout<<"p=";cin>>p;

vector<char> v(n);
back(v,0,n,p);
return 0;
}
1. A person has forgotten a friend's phone number.
They only know that the number has 10 digits,
starts with 074, contains exactly 3 zeroes, of which
only two are consecutive, and ends in 65. Display
all the possible combinations they should try to
reach their friend.
Example: One solution is: 0740030165.
#include <iostream>
#include <fstream>
using namespace std;
void generateNumbers(int n, int consecutiveZeros, string
current, ofstream& output)
{
if(n==0)
{
if (consecutiveZeros==2 && current[current.length()-1]
== '0' && current[current.length()-2] == '0')
output<<"074"<<current<<"65"<<endl;
return;

}
for(int i=0; i<=9; i++)
{
if(i == 0)
generateNumbers(n - 1, consecutiveZeros + 1, current +
char(i + '0'), output);
else
generateNumbers(n - 1, 0, current + char(i + '0'),
output);
}
}
int main()
{
ofstream g("date.out");
generateNumbers(3, 0, "", g);
return 0;
}
1. Generate all numbers that have the same binary
digits as the conversion to base two of a given
natural number x. Representations in base 2 that
start with the digit 0 are considered invalid.

Example: For x=14, i.e., 11102, the numbers 11
and 13 are generated because:
1110 is 10112, and
1310 is 11012, both share the same binary digits but
in a different order.
Implementation:
#include <iostream>
#include <vector>
#include <algorithm>
// Function to convert a decimal number to binary
std::vector<int> decimalToBinary(int x) {
std::vector<int> binary;
while (x > 0) {
binary.push_back(x % 2);
x /= 2;
}
std::reverse(binary.begin(), binary.end());
return binary;
}
// Function to check if two vectors have the same elements
bool haveSameElements(const std::vector<int>& a, const
std::vector<int>& b) {

if (a.size() != b.size()) return false;
std::vector<int> tempA = a;
std::vector<int> tempB = b;
std::sort(tempA.begin(), tempA.end());
std::sort(tempB.begin(), tempB.end());
return tempA == tempB;
}
// Function to generate numbers with the same binary
digits
void generateNumbers(int x) {
std::vector<int> binary = decimalToBinary(x);
for (int i = 1; i < x; i++) {
std::vector<int> binary_i = decimalToBinary(i);
if (haveSameElements(binary, binary_i)) {
std::cout << i << " ";
}
}
std::cout << std::endl;
}
int main() {
int x = 14;
generateNumbers(x);
return 0;

}
1. Generate all natural numbers with p (p ≤ 9)
significant binary digits (they do not start with a 0
in binary) for which the absolute difference
between the count of 0 digits and the count of 1
digits is at most 1. The solutions will be displayed
in both binary and decimal.
Example: For p=3, the pairs may be displayed (but
not necessarily in this order):
100 4
101 5
110 6
Implementation:
#include <iostream>
#include <cmath>
#include <vector>
using namespace std;
int conversie_2_la_10(int n)
{
int dec=0,i=0,rem;
while (n!=0)

{
rem=n%10;
n/=10;
dec+=rem*pow(2,i);
++i;
}
return dec;
}
bool diferenta_0_1(long x)
{
int nr_zero=0,nr_unu=0,x1=x;
while(x!=0)
{
if(x%10==0)
nr_zero++;
else
nr_unu++;
x=x/10;
}
if((nr_unu-nr_zero)<=1 || (nr_zero-nr_unu)<=1)
return true;
return false;
}

void displayData(int n, string s, vector<int> &v)
{
if(n==0)
v.push_back(stoi(s));
else
{
displayData(n-1,s+"0",v);
displayData(n-1,s+"1",v);
}
}
bool numara_cifre(int x,int p)
{
int nr=0;
while(x>0)
{
nr++;
x=x/10;
}
if(nr==p)
return true;
return false;
}
int main()

{
vector<int> v;
int p,p1,p2;
long x;
cout<<"p=";cin>>p;
displayData(3,"",v);
for(int i=0;i<v.size();i++)
{
if(diferenta_0_1(v[i]) && numara_cifre(v[i],p)==true)
cout<<v[i]<<" "<<conversie_2_la_10(v[i])<<endl;
}
return 0;
}
1. Generate all numbers with n digits that do not
contain digits that appear more than twice.
Example: For n=7, a first solution could be:
1001223.
Implementation:
#include <iostream>
#include <cmath>
#include <vector>
using namespace std;

int verif_frecventa(long x)
{
int fv[10]={0};
while(x>0)
{
fv[x%10]++;
x=x/10;
}
for(int i=0;i<=9;i++)
if(fv[i]>2)
return 0;
return 1;
}
int main()
{
int n,p1,p2;
cout<<"n=";cin>>n;
p1=pow(10,n-1);
p2=pow(10,n)-1;
for(long i=p1;i<=p2;i++)
if(verif_frecventa(i)==1)
cout<<i<<endl;
return 0;

}
1. Computer Science Tests. For the exam, the
computer science teacher has prepared n (where
n≤4) tests. There are p students in the class
(p≤10, p>n). Generate all possibilities for
distributing the tests to the p students in such a
way that each test is solved by at least one
student. Display the solutions considering that the
order of students is from 1 to p.
Example: If n=3 and p=5, one solution could be:
1 1 1 2 3, which means that students 1, 2, and 3
take test 1, student 4 takes test 2, and student 5 takes
test 3.
Implementation:
#include <iostream>
using namespace std;
int n, p;
int test[100], sol[100];
void backtrack(int k) {
if (k == p + 1) {
for (int i = 1; i <= p; i++)
cout << sol[i] << " ";

cout << endl;
} else {
for (int i = 1; i <= n; i++) {
if (test[i] < 2) {
sol[k] = i;
test[i]++;
backtrack(k + 1);
test[i]—;
sol[k] = 0; // Unassign the test for backtracking
}
}
}
}
int main() {
cin >> n >> p;
backtrack(1);
return 0;
}
1. Map Coloring. Given a map with n (n≤10)
countries, each country is identified by a number
from 1 to n. There are M pairs of neighboring
countries. The pairs of neighboring countries on
the map are known. Color the map in such a way

that any two adjacent countries are colored
differently. The colors are represented by natural
numbers from 1 to 4. (It is known that any map can
be colored under these conditions with at most 4
colors). The solutions will be expressed as a
sequence xi of n values where xi represents the
color of country i.
Example: If n=4, m=4, and the neighboring
countries are:
1 2
1 3
1 4
2 3
One possible solution is: 1 2 3 2, which means:
(country 1, color 1); (country 2, color 2); (country 3,
color 3); (country 4, color 2);
Implementation:
#include <iostream>
using namespace std;
int n,m;

int color[20],sol[20];
bool graph[20][20];
bool isSafe(int v, int c)
{
for(int i=1; i<=n; i++)
{
if (graph[v][i] && color[i]==c)
return false;
}
return true;
}
void display()
{
for (int i=1; i<=n; i++)
cout<<color[i]<< " ";
cout<<endl;
}
bool graphColoring(int v)
{
if (v==n+1)
{
display();
return true;

}
for (int c=1; c<=4; c++)
{
if (isSafe(v,c))
{
color[v]=c;
if(graphColoring(v+1))
return true;
color[v]=0;
}
}
return false;
}
int main()
{
cin>>n>>m;
int x,y;
for (int i=0; i <m; i++)
{
cin>>x>>y;
graph[x][y]=true;
graph[y][x]=true;
}

graphColoring(1);
return 0;
}
1. Coloring a Map - II. Consider a map with n
(n≤10) countries. For each of the n countries, the
name is read. M pairs of countries are neighbors.
The pairs of neighboring countries on the map are
known. Color the map in such a way that any two
adjacent countries are colored differently. The
colors are expressed as 4 colors read from the
keyboard as a string of characters. (It is known that
any map can be colored under the specified
conditions with at most 4 colors). The solutions will
be expressed as a string of n pairs xi yi values
where xi represents the name of the country and yi
represents the color of country xi.
Example. If n=4, the countries: tr1, tr2, tr3, tr4.
For m=4 if the neighboring countries are:
tr1 tr2
tr1 tr3
tr1 tr4
tr2 tr3

and the colors are: red, yellow, blue, green.
A first solution is:
tr1 – red, tr2 – yellow, tr3 – blue, tr4 – yellow.
Implementation:
#include <iostream>
#include <string>
#include <fstream>
using namespace std;
const int MAX_N = 10;
int n, m;
string countries[MAX_N], colors[4];
bool graph[MAX_N][MAX_N], colorUsed[4];
string solution[MAX_N];
bool isSafe(int v, int c) {
for (int i = 0; i < n; i++) {
if (graph[v][i] && solution[i] == colors[c]) {
return false;
}
}
return true;
}
bool graphColoring(int v) {

if (v == n) {
for (int i = 0; i < n; i++) {
cout << countries[i] << " - " << solution[i] << endl;
}
cout << endl;
return true;
}
for (int c = 0; c < 4; c++) {
if (colorUsed[c]) continue;  // Skip colors that are already
used
if (isSafe(v, c)) {
solution[v] = colors[c];
colorUsed[c] = true;  // Mark the color as used
if (graphColoring(v + 1)) {
return true;
}
solution[v] = "";
colorUsed[c] = false;  // Unmark the color
}
}
return false;
}
int main()

{ 
ifstream f("date.in");
f>>n>>m;
for (int i = 0; i < n; i++)
f>>countries[i];
for (int i = 0; i < 4; i++)
f>>colors[i];
int x,y;
for (int i = 0; i < m; i++)
{
f>>x>>y;
graph[x][y]=true;
graph[y][x]=true;
}
graphColoring(0);
return 0;
}
1. Interval Coloring. Given n (n≤10) intervals [a,
b] with a < b on the real number line. Color the n
intervals in such a way that any two intersecting
intervals are colored differently.

Example. For n=5 if the intervals are: [1, 5], [4, 7],
[6, 8], [7, 8], [9,15]
A solution is:
[1, 5] color 1
[4, 7] color 2
[6, 8] color 1
[7, 8] color 3
[9, 15] color 1
Implementation:
#include <iostream>
using namespace std;
const int MAX_N=10;
int n;
pair<int, int> intervals[MAX_N];
int color[MAX_N], sol[MAX_N];
bool isSafe(int k, int c)
{
for (int i = 0; i < k; i++)
{
if (color[i] == c)
{

if ((intervals[i].first <= intervals[k].first &&
intervals[i].second >= intervals[k].first) ||
(intervals[i].first <= intervals[k].second &&
intervals[i].second >= intervals[k].second) ||
(intervals[i].first >= intervals[k].first &&
intervals[i].second <= intervals[k].second))
return false;
}
}
return true;
}
bool backtrack(int k)
{
if (k == n)
{
for (int i = 0; i < n; i++)
cout << "[" << intervals[i].first << ", " <<
intervals[i].second << "] color: " << color[i] << endl;
return true;
}
for (int c = 1; c <= 3; c++)
{
if (isSafe(k, c))

{
color[k] = c;
if (backtrack(k + 1))
return true;
color[k] = 0;
}
}
return false;
}
int main()
{
cin >> n;
for (int i = 0; i < n; i++)
{
cin >> intervals[i].first >> intervals[i].second;
}
backtrack(0);
return 0;
}
1. Display all solutions of the equation: x + 2y + 3z +
4w = a, where a (a≤30) is a natural number read
from the keyboard.

Implementation:
#include <iostream>
using namespace std;
int main()
{
int a,x,y,z,w;
cin>>a;
for(x=0; x<=a; x++)
for(y=0; y<=a; y++)
for(z=0; z<=a; z++)
for(w=0; w<=a; w++)
if (x+2*y+3*z+4*w==a)
cout<<x<<" "<<y<<" "<<z<<" "<<w<<endl;
return 0;
}
1. Display the number of ways a bus ticket can be
punched. A ticket has 9 possible punch points
arranged as follows:
* * *
* * *

* * *
Example: A solution could be:
* . *
* * .
. . * where the punched points are expressed
through * character.
Implementation:
#include <iostream>
using namespace std;
int n;
void backtrack(int ticket[3][3], int row, int col)
{
if (row==3)
{
n++;
return;
}
if (col==3)
{
backtrack(ticket,row+1,0);
return;

}
backtrack(ticket,row,col+1);
ticket[row][col]=1;
backtrack(ticket,row,col+1);
ticket[row][col]=0;
}
int main() {
int ticket[3][3] = { { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 } };
backtrack(ticket, 0, 0);
cout<<"Number of ways: "<<n<<endl;
return 0;
}
1. Display the number of ways to place n (n≤10)
knights on a chessboard with dimensions n × n
such that no two knights are on the same row and
no two knights attack each other.
Example. If n=5, one solution is:
- - - * -
* - - - -
* - - - -

- - - * -
- - - - * where * represents the position of a knight on
the chessboard.
Implementation:
#include <iostream>
#include <vector>
using namespace std;
const int MAX_N=10;
int n,solutions;
vector<vector<int>> board(MAX_N, vector<int>(MAX_N,
0));
int dx[] = {-2, -2, -1, -1, 1, 1, 2, 2};
int dy[] = {-1, 1, -2, 2, -2, 2, -1, 1};
bool isSafe(int x, int y)
{
return (x >= 0 && x < n && y >= 0
&& y < n && board[x][y] == 0);
}
void printBoard()
{
for (int i = 0; i < n; ++i)

{
for (int j = 0; j < n; ++j)
{
if (board[i][j] == 0)
cout << "- ";
else
cout << "* ";
}
cout << endl;
}
cout << endl;
}
void solve(int x, int y, int placedKnights) {
if (placedKnights == n) {
printBoard();
solutions++;
return;
}
for (int i = 0; i < 8; ++i) {
int newX = x + dx[i];
int newY = y + dy[i];
if (isSafe(newX, newY)) {
board[newX][newY] = 1;

solve(newX, newY, placedKnights + 1);
board[newX][newY] = 0;
}
}
}
int main() {
cout << "Enter the value of n (<= 10): ";
cin >> n;
solve(0, 0, 0);
cout << "Total number of solutions: " << solutions <<
endl;
return 0;
}
1. Display the number of ways a king can move from
the first row of a chessboard with dimensions n ×
n (n≤10) to reach the last row. The initial position
column c1 and the final position column c2 are
known. The king can only move to a row greater
and an adjacent column.
Example. For n=5, c1=2, and c2=5, one solution
is:
- * - - -

- * - - -
- - * - -
- - - * -
- - - - * where * represents the king's position on the
chessboard.
Implementation:
#include <iostream>
using namespace std;
const int MAX_N = 10;
int n, c1, c2;
int solutions = 0;
void displayBoard(int board[MAX_N][MAX_N]) {
for (int i = 0; i < n; i++) {
for (int j = 0; j < n; j++) {
if (j == board[i][j]) {
cout << "* ";
} else {
cout << "- ";
}
}

cout << endl;
}
cout << endl;
}
void moveKing(int row, int col, int board[MAX_N][MAX_N])
{
if (row == n - 1) {
solutions++;
displayBoard(board);
return;
}
if (col > 0) {
board[row + 1][col - 1] = row + 2;
moveKing(row + 1, col - 1, board);
board[row + 1][col - 1] = 0;
}
board[row + 1][col] = row + 2;
moveKing(row + 1, col, board);
board[row + 1][col] = 0;
if (col < n - 1) {
board[row + 1][col + 1] = row + 2;
moveKing(row + 1, col + 1, board);
board[row + 1][col + 1] = 0;

}
}
int main() {
cout << "Enter the value of n (<= 10): ";
cin >> n;
cout << "Enter the initial column (c1): ";
cin >> c1;
cout << "Enter the final column (c2): ";
cin >> c2;
int board[MAX_N][MAX_N] = {0};
board[0][c1 - 1] = 1;
moveKing(0, c1 - 1, board);
cout << "Total number of solutions: " << solutions <<
endl;
return 0
}
1. Exam. In an exam, there are 3 tests. In order to
pass the exam, a candidate must score at least t
points across all the tests. For each test pi, the
minimum score ai required to pass the exam and
the maximum score bi that can be achieved are

known (10≤ai, bi≤50). What score combinations
are possible for a candidate to pass the exam?
Example. For n=3, t=70, and 15-25, 20-30, 20-40
as the minimum-maximum score ranges for each test,
a solution could be: 20, 25, 25.
Implementation:
#include <iostream>
#include <vector>
using namespace std;
const int MAX_TESTS = 3;
int minScores[MAX_TESTS];
int maxScores[MAX_TESTS],totalPoints,ns;
vector<int> currentScores(MAX_TESTS);
void generateScores(int testIndex, int remainingPoints) {
if (testIndex == MAX_TESTS)
{ 
if (remainingPoints == 0) {
ns++;
for (int i = 0; i < MAX_TESTS; i++) {
cout << currentScores[i] << " ";
}
cout << endl;

}
return;
}
for (int score = minScores[testIndex]; score <=
maxScores[testIndex]; score++) {
if (remainingPoints >= score) {
currentScores[testIndex] = score;
generateScores(testIndex + 1, remainingPoints - score);
currentScores[testIndex] = 0; // Backtrack
}
}
}
int main() {
cout << "Enter the number of tests (n): ";
int n;
cin >> n;
if (n != MAX_TESTS) {
cout << "Invalid number of tests. Please provide exactly "
<< MAX_TESTS << " tests." << endl;
return 1;
}
cout << "Enter the total points required to pass (t): ";
cin >> totalPoints;

cout << "Enter the minimum and maximum scores for
each test:" << endl;
for (int i = 0; i < MAX_TESTS; i++) {
cin >> minScores[i] >> maxScores[i];
}
cout << "Possible score combinations to pass the exam:"
<< endl;
generateScores(0, totalPoints);
cout << ns << " solutions.";
return 0;
}
1. Generate all sequences composed of n (n≤9)
digits that start and end with the digit 1, and where
the absolute difference between any two adjacent
digits is equal to 1.
Example: For n=5, the generated sequences will
be: 10101, 10121, 12101, ..., 12321.
Implementation:
#include <iostream>
#include <cmath>
using namespace std;
int prima_cifra(long x)

{
while(x>9)
{
x=x/10;
}
return x;
}
bool diferenta(long x)
{ 
bool ok=true;
while(x>0)
{
int u=x%10;
int an=x/10%10;
if(abs(u-an)!=1)
ok=false;
x=x/10;
}
return ok;
}
int main()
{
int n;

cout<<"n=";cin>>n;
long p1,p2;
p1=pow(10,n-1);
p2=pow(10,n)-1;
cout<<p1<<" "<<p2<<endl;
for(long i=p1;i<=p2;i++)
if(diferenta(i)==true && prima_cifra(i)==1)
cout<<i<<endl;
return 0;
}
1. The Magic Number. Count Predefined_Type heard
news that the Emperor offers his daughter's hand,
Princess Digit, and half of the kingdom to whoever
can find the Magic Number: the largest number
with exactly n digits that meets the following
requirements: it has exactly p occurrences of the
digit y (starting from the most significant digit), or
y doesn't appear at all in the number. The rest of
the digits are distinct. And because the emperor is
not easily satisfied, he also wants to know how
many such numbers can be generated. Help Tip
meet the Emperor's demands.

Input: The file data.in will contain, on the first line
and separated by spaces, the values of n, p, and y.
Output: The file data.out will contain: On the first
line, the requested number. On the second line, the
number of such numbers that can be generated. If
there is no such number, output 0.
Constraints and clarifications:
1 ≤ p ≤ 9
p ≤ n
1 ≤ y ≤ 9
1 ≤ n ≤ 18
p can only be equal to y if p = 1
Input data is considered correct and does not require
validation.
Examples:
Data.in Data.out
3 2 3
922 25
15 3 9
0
Implementation:

#include <iostream>
#include <cmath>
using namespace std;
int main() {
int n, p, y;
cin >> n >> p >> y;
long long count = 0;
long long requestedNumber = 0;
// Generate the requested number
requestedNumber += pow(10, n - p) * 9;
requestedNumber += y;
for (int i = 0; i < p - 1; i++) {
requestedNumber *= 10;
}
// Count how many such numbers can be generated
for (int i = pow(10, n - 1); i < pow(10, n); i++) {
int digits[10] = {0};
int temp = i;
bool valid = true;
for (int j = 0; j < n; j++) {
int digit = temp % 10;
if (digits[digit] != 0 || (j == 0 && digit == 0)) {
valid = false;

break;
}
digits[digit] = 1;
temp /= 10;
}
if (valid && (digits[y] == 1 || y == 0)) {
count++;
}
}
if (count > 0) {
cout << "Requested number: " << requestedNumber <<
endl;
cout << "How many such numbers can be generated: "
<< count << endl;
} else {
cout << "0" << endl;
}
return 0;
}

11.6  SET PARTITIONS AND
DERIVED PROBLEMS
1. Let n be a non-zero natural number (n≤10).
Display all partitions of elements of set A=
{1,2,3..n} in two non-empty disjoint subsets
which union equals set A.
Example: for n=3 it is displayed not necessarily in
this order:
{1,2}, {3}
{1,3}, {2}
{2,3}, {1}
Implementation:
#include <iostream>
#include <cmath>
using namespace std;
int st[20], n;
int ns;
void afi()
{
ns++;
for(int i=1;i<=n;i++)

if(st[i]==1)
cout<<i<<" ";
if(ns!=1 && ns!=pow(2,n))
cout<<" and ";
for(int i=1;i<=n;i++)
if(st[i]==2)
cout<<i<<" ";
cout<<endl;
}
void bkt(int k)
{
for(int i=1;i<=2;i++)
{
st[k]=i;
if(k==n)
AFI();
else
bkt(k+1);
}
}
int main()
{ cout<<"Partitions of the set A={1,2...,"<<n<<"} in 2
subsets.";

cout<<endl<<"n=";
cin>>n;
bkt(1);
cout<<ns<<" solutions";
return 0;
}
1. Read from the keyboard n, a non-zero natural
number (n≤10) and elements of a set A=
{a1,a2,...,an}. Display all partitions of elements of
set A in two non-empty disjoint subsets which
union is equal to set A.
Example: n=3 and A={7,9,5} display not
necessarily in this order:
{7,9}, {5}
{7,5}, {9}
{9,5}, {7}
Implementation:
#include <iostream>
#include <cmath>
using namespace std;
int st[20],v[20],n;

int ns;
void afi()
{
ns++;
for(int i=1;i<=n;i++)
if(st[i]==1)
cout<<v[i]<<" ";
if(ns!=1 && ns!=pow(2,n))
cout<<" si ";
for(int i=1;i<=n;i++)
if(st[i]==2)
cout<<v[i]<<" ";
cout<<endl;
}
void bkt(int k)
{
for(int i=1;i<=2;i++)
{
st[k]=i;
///if(valid(k)==1)
if(k==n)
afi();
else

bkt(k+1);
}
}
int main()
{ 
cout<<endl<<"n=";
cin>>n;
for(int i=1;i<=n;i++)
{
cout<<"v["<<i<<"]=";
cin>>v[i];
}
bkt(1);
cout<<ns<<" solutions";
return 0;
}
1. Let n natural number be nonzero (3≤n≤10).
Display all partitions of elements of the  set A=
{1,2,3..n} in three non-empty disjoint subsets
which reunion is equal to set A.
Example: for n=4 it is displayed not necessarily in
this order:

{1,2}, {3}, {4}
{1,3}, {2}, {4}
{1,4}, {2}, {3}
{2,3}, {1}, {4}
{2,4}, {1}, {3}
{3,4}, {1}, {2}
Implementation:
#include <iostream>
#include <cmath>
using namespace std;
int st[20], n;
int ns;
void afi()
{ 
ns++;
int v[4]={0};
for(int i=1; i<=n; i++)
v[st[i]]++;
if(v[1]!=0)
{for(int i=1; i<=n; i++)
if(st[i]==1)

cout<<i<<" ";
}
else
cout<<(char)237;//empty set
cout<<" si ";
if(v[2]!=0)
{for(int i=1; i<=n; i++)
if(st[i]==2)
cout<<i<<" ";
}
else
cout<<(char)237;//empty set
cout<<" si ";
if(v[3]!=0)
{for ( int i=1; i<=n; i++ )
if ( st[ i ] == 3 )
cout<<i<<" ";
}
else
cout<<(char)237;//empty set
cout<<endl;
}
void bkt(int k)

{
for(int i=1; i<=3; i++)
{
st[k]=i;
if(k==n)
afi();
else
bkt(k+1);
}
}
int main()
{
cout<<"Partitions of the set A={1,2...,"<<n<<"} in 3
subsets.";
cout<<endl<<"n=";
cin>>n;
bkt(1);
cout<<ns<<" solutions";
return 0;
}
1. Let n be a non-zero natural number (n≤10).
Display all partitions of elements of set A=

{1,2,3..n} in non-empty disjoint subsets which
union equals set A.
Example: for n=3 it is displayed not necessarily in
this order:
{1,2,3}
{1,2}, {3}
{1,3}, {2}
{1}, {2,3}
{1}, {2}, {3}
Implementation:
#include<iostream>
using namespace std;
int x[20],n,nrsol=0,max[20],maxim;
int DeterminareMaxim(int k)
{
int maxim=0,i;
for(i=1;i<=k;i++)
if (x[i]>maxim)
maxim=x[i];
return maxim;

}
void DisplayData()
{
int i,j;
maxim=DeterminareMaxim(n);
for(j=1;j<=maxim;j++)
{
cout<<"{";
for(i=1;i<=n;i++)
if (x[i]==j)
cout<<i<<" ";
cout<<"}  ";
}
cout<<endl;
nrsol++;
}
void BackRec(int k)
{
int i;
for(i=1;i<=DeterminareMaxim(k-1)+1;i++)
{
x[k]=i;
if (k==n)

DisplayData();
else
BackRec(k+1);
}
}
int main()
{
cout<<"n=";cin>>n;
BackRec(1);
cout<<"No. Of solutions: "<<nrsol;
return 0;
}
1. Read from the keyboard n, non-zero natural
number (n≤10) and elements of a set A=
{a1,a2,...,an}. Display all partitions of elements of
the set A in disjoint subsets which union is equal to
the set A.
Example. for n=3 and A={7,9,5} is displayed not
necessarily in this order:
{7,9,5}
{7,9}, {5}

{7,5}, {9}
{7}, {9,5}
{7}, {9}, {5}
Implementation:
#include<iostream>
using namespace std;
int x[20],n,nrsol=0,max[20],maxim;
int v[20];
int DeterminareMaxim(int k)
{
int maxim=0,i;
for(i=1;i<=k;i++)
if (x[i]>maxim)
maxim=x[i];
return maxim;
}
void DisplayData()
{
int i,j;
maxim=DeterminareMaxim(n);
for(j=1;j<=maxim;j++)
{

cout<<"{";
for(i=1;i<=n;i++)
if (x[i]==j)
cout<<v[i]<<" ";
cout<<"}  ";
}
cout<<endl;
nrsol++;
}
void BackRec(int k)
{
int i;
for(i=1;i<=DeterminareMaxim(k-1)+1;i++)
{
x[k]=i;
if (k==n)
DisplayData();
else
BackRec(k+1);
}
}
int main()
{

cout<<"n=";cin>>n;
for(int i=1;i<=n;i++)
{
cout<<"v["<<i<<"]=";
cin>>v[i];
}
BackRec(1);
cout<<"No. of solutions: "<<nrsol;
return 0;
}

11.7  NUMBER PARTITIONS AND
DERIVED PROBLEMS
1. Let n be a non-zero natural number (n≤10). Let n
be decomposed into a sum of natural numbers.
The terms will be displayed in ascending order.
Example. For n=4 will be displayed in this order:
1 1 1 1
1 1 2
1 3
2 2
4
Implementation:
#include<iostream>
using namespace std;
int n, ns,sol[20];
void afis(int k)
{
int i;
ns++;
cout<<"Solution no. "<<ns<<": ";

for(i=1;i<=k;i++)
cout<<sol[i]<<" ";
cout<<endl;
}
void back(int i, int k)
{
int j;
if (k==n)
afis(i-1);
else
for(j=1;j<=n-k;j++)
if (j>=sol[i-1])
{
sol[i]=j;
back(i+1, k+j);
}
}
int main()
{
cin>>n;
ns=0;
back(1,0);
cout<<ns<<" solutions.";

return 0;
}
1. Let n natural number be non-zero (2≤n≤50). Let n
be decomposed into the sum of prime numbers.
The terms will be displayed in ascending order.
Example. for n=10 will be displayed in this order:
2 2 2 2 2
2 2 3 3
2 3 5
3 7
5 5
Implementation:
#include <iostream>
#include <vector>
#include <cmath>
using namespace std;
bool isPrime(int n)
{
if(n<=1)
return false;

if(n<=3)
return true;
if (n%2==0 || n%3==0)
return false;
for(int i=5; i*i<=n; i=i + 6)
if (n%i==0 || n%(i+2)==0)
return false;
return true;
}
void backtracking(int n, int current, vector<int>& subset)
{
if (n==0)
{
for (auto i : subset)
cout<<i<< " ";
cout<<endl;
}
else if (n < 0)
{
return;
}
else
{

for (int i = current; i <= n; i++)
{
if (isPrime(i))
{
subset.push_back(i);
backtracking(n-i, i, subset);
subset.pop_back();
}
}
}
}
int main()
{
int n;
cout<<"n=";cin>>n;
vector<int> subset;
backtracking(n, 2, subset);
return 0;
}
1. Let n be a non-zero natural number (n≤50). Let n
be decomposed into the sum of non-prime
numbers with each other (numbers will have the
greatest common divisor other than the value 1).

For each solution, the greatest common divisor will
be displayed. The solution with the greatest
common divisor will be displayed at the end.
Example: For n=48 a solution is 24,15,9 with the
greatest common divisor 3. The solution with the
greatest common divisor is: 24, 24.
Implementation:
#include <iostream>
int gcd(int a, int b)
{
while(b!=0)
{
int temp=b;
b=a%b;
a=temp;
}
return a;
}
void decompose(int n)
{
int max_gcd=0;
int a=0,b=0,c=0;

// Iterate through all possible combinations
for(int i=2; i<=n/3; ++i)
{
for(int j=i; j<=(n-i)/2; ++j)
{
int k=n-i-j;
//Check if i, j, and k are non-prime
if(i>1 && j>1 && k>1 && i*j*k!=n)
{
int current_gcd=gcd(gcd(i,j),k);
// Update max_gcd and corresponding values if
current_gcd is greater
if(current_gcd>max_gcd)
{
max_gcd=current_gcd;
a=i;
b=j;
c=k;
}
}
}
}
//Output the solution with the greatest common divisor

std::cout<<" a solution is "<<a<<", "<<b<<", "<<c
<< " with the gcd "<<max_gcd
<<". The solution with the max gcd is: "
<<max_gcd<<", "<<max_gcd<<"."<<std::endl;
}
int main()
{
int n;
std::cout<<"Enter a non-zero natural number (n<=50): ";
std::cin>>n;
decompose(n);
return 0;
}
1. Display all numbers with no more than p digits
(p≤9) with the property that they have the sum of
digits equal to x given.
Implementation:
#include <iostream>
using namespace std;
int p,x;
void backtrack(int x, int sum, int n, int num)
{

if(sum>x || n>p)
return;
if (sum == x)
{
cout<<num<<endl;
}
for(int i = 0; i <= 9; i++)
backtrack(x,sum+i,n+1,num*10+i);
}
int main()
{
cin>>x>>p;
backtrack(x,0,0,0);
return 0;
}
1. Payment of an amount in n types of
banknotes I. A person has to pay an amount s in
banknotes of n types. For each type of banknote,
read: the value of the banknote and the number of
banknotes of this type available as an x-y pair.
Display all possibilities and, at the end, the solution
involving the fewest banknotes.

Example. For s=5, n=3 and banknotes: 1 3, 2 5, 3
4, the solution with the fewest banknotes is: 2×1,3×1.
Implementation:
#include <iostream>
using namespace std;
int x5[20], n, nrsol5=0, nr[20], val[20], sum[20], s;
int Valid5(int k)
{ 
sum[k]=sum[k-1]+val[k]*x5[k];
if (sum[k]>s)
return 0;
if (k==n && sum[k]!=s)
return 0;
return 1;
}
void DisplayData5()
{
int i,j;
int p=0,q=0;
for(i=1;i<=n;i++)
{ 
if(x5[i]!=0)

{
cout<<x5[i]<<"*"<<val[i]<<" ";
p++;
q++;
}
if(p==2)
{
cout<<"="<<s;
p=0;
}
}
cout<<endl;
nrsol5++;
}
void Back5()
{ 
int k=1, cand;
x5[1]=-1;
while (k>0)
{
cand=0;
while (cand==0 && x5[k]<nr[k])
{

x5[k]++;
cand=Valid5(k);
}
if (cand==0)
k—;
else if (k==n)
DisplayData5();
else
{
k=k+1;
x5[k]=-1;
}
}
}
int main()
{
int i;
cout<<"n=";cin>>n;
cout<<"s="; cin>>s;
cout<<endl;
for(i=1;i<=n;i++)
{
cout<<"Baknote "<<i<<": "; cin>>val[i];

cout<<"How many of banknote "<<i<<"  : "; cin>>nr[i];
}
cout<<endl<<"Solutions: "<<endl; 
Back5();
cout<<"No. of solutions: "<<nrsol5;
return 0;
}
1. Payment of an amount in n types of
banknotes II. A person needs to pay a sum s in
banknotes of n types. For each type of banknote,
the value of the banknote and the number of
banknotes of that type available are read as a pair
x - y. Display all possibilities for paying that sum
so that each banknote appears at least once.
Example. For s=23, n=5, and banknotes: (1 5, 2
5, 3 2, 5 3, 8 2), a solution is: 1×1 + 3×2 + 1×3 +
1×5 + 1×8.
Implementation:
#include <iostream>
using namespace std;
const int MAX_N = 20;
int
x5[MAX_N],n,nrsol5=0,nr[MAX_N],val[MAX_N],sum[MAX_N],

s;
int Valid5(int k)
{
sum[k]=sum[k-1]+val[k]*x5[k];
if(sum[k]>s)
return 0;
return 1;
}
void DisplayData5()
{
int i,j;
for(i=0; i<n; i++)
for(j=0; j<x5[i]; j++)
cout<<val[i]<<"*";
cout<<endl;
nrsol5++;
}
void Back5()
{
int k=0,cand;
x5[0]=0;
while(k>=0)
{

cand=0;
while(x5[k]<=nr[k])
{
if(Valid5(k))
{
if(k==n-1)
DisplayData5();
else
{
k++;
x5[k]=0;
}
cand=1;
break;
}
x5[k]++;
}
if (!cand)
{
k—;
if(k>=0)
x5[k]++;
}

}
}
int main()
{
int i;
cin>>n>>s;
for(i=0; i<n; i++)
{
cout<<"Value of banknote "<<i+1<<": ";
cin>>val[i];
cout<<"Number of banknotes "<<i+1<<": ";
cin>>nr[i];
}
cout<<endl
<<"The solutions are: "<<endl;
Back5();
cout<<"Number of solutions: "<<nrsol5;
return 0;
}
1. Generate in lexicographical order the first n strings
formed by p lowercase letters of the English
alphabet that do not contain more than two
consecutive vowels or two consecutive consonants.

Example. For p=4, n=5, the output will be:
aaba, aabb, aabc, aabd, aabe
Implementation:
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool isValid(string str)
{
int vowel=0, consonant=0;
for(int i=0; i<str.length(); i++)
{
if(str[i]=='a' || str[i]=='e' || str[i]=='i' || str[i]=='o' ||
str[i]=='u')
{
vowel++;
consonant=0;
}
else
{
consonant++;

vowel =0;
}
if (vowel>2 || consonant>2)
return false;
}
return true;
}
void generateStrings(int p, int n, string str,
vector<string> &result)
{
if (result.size()==n)
return;
if (str.length()==p)
{
if (isValid(str))
result.push_back(str);
return;
}
for (char ch = 'a'; ch <= 'z'; ch++)
{
string newStr=str+ch;
generateStrings(p,n,newStr,result);
}

}
int main()
{
int p,n;
cout<<"n=";cin>>n;
cout<<"p=";cin>>p;
vector<string> result;
generateStrings(p, n, "aa", result);
for (int i=0; i<result.size(); i++)
cout<<result[i]<<endl;
return 0;
}

11.8  PROBLEMS WITH VARIABLE
SOLUTION LENGTH
1. Pheasant. A group of n (n≤10) children has n
cards with n distinct words for the game
“Pheasant”. In this game, a child must say a word
that has the first two letters identical to the last
two letters of the word spoken by their
predecessor. Given an initial word for the game,
display the version with the most words that can
be obtained using the given cards. A sequence of
words constructed according to the previous rule
will not contain a word more than once.
Example. For n=7, if the words are: deal, repede,
floare, onorific, neon, alune, cal and the starting
word is floare, the longest sequence that can be
obtained is:
floare, repede, deal, alune, neon, onorific
Implementation:
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

using namespace std;
vector<string> words;
vector<string> current_chain;
vector<string> longest_chain;
bool is_valid(string word)
{
if(current_chain.empty())
return true;
string last=current_chain[current_chain.size() - 1];
return (last[last.size() - 2]==word[0] &&
last[last.size()-1]==word[1]);
}
void dfs(vector<bool> visited)
{
//if the current chain is longest than the actual longest
if(current_chain.size()>longest_chain.size())
longest_chain=current_chain;
for (int i=0; i<words.size(); i++)
{
if (!visited[i] && is_valid(words[i]))
{
visited[i]=true;
current_chain.push_back(words[i]);

dfs(visited);
current_chain.pop_back();
visited[i]=false;
}
}
}
int main()
{
int n;
cin>>n;
for (int i = 0; i < n; i++)
{
string word;
cin>>word;
words.push_back(word);
}
string starting_word;
cin>>starting_word;
words.erase(remove(words.begin(), words.end(),
starting_word), words.end());
current_chain.push_back(starting_word);
vector<bool>
visited(words.size(), false);

dfs(visited);
for (auto it=longest_chain.begin();
it!=longest_chain.end(); it++)
cout<<*it<< " ";
return 0;
}
1. Domino. Given a number of n (n≤15) distinct
domino pieces. Each domino piece contains two
numbers from the set {1,2,3,4,5,6}. Generate the
longest chain of distinct domino pieces, knowing
that a piece can be placed in the chain only if the
second number on the previous piece matches the
first number on the current piece. The pieces can
be rotated.
Implementation:
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
const int MAXN = 20;
int n;
int domino[MAXN][2];
vector<int> currentChain;

vector<int> longestChain;
bool used[MAXN];
void findLongestChain(int last)
{
if(currentChain.size()>longestChain.size())
longestChain = currentChain;
for(int i=0; i<n; i++)
{
if (used[i])
{
continue;
}
if (last==-1 || domino[i][0]==domino[last][1] ||
domino[i][1]==domino[last][1])
{
used[i] = true;
currentChain.push_back(i);
findLongestChain(i);
currentChain.pop_back();
used[i] = false;
}
}
}

int main()
{
cin>>n;
for(int i = 0; i < n; i++)
cin>>domino[i][0]>>domino[i][1];
findLongestChain(-1);
for (int i = 0; i < longestChain.size(); i++)
cout<<"("<<domino[longestChain[i]][0]<<","
<<domino[longestChain[i]][1]<<")";
return 0;
}
1. A group of n (n≤10) children numbered from 1 to
n need to read a book. Friendships have been
established among the n children, and the m pairs
of friends are known, expressed by the ordinal
numbers of the two friends. The teacher can lend
the book to any child on the condition that it is
read by the most children. Knowing that a child can
only borrow the book once and that only friends
lend each other the book, display the ordinal
numbers of the children who form the longest
sequence of children reading the book.
Implementation:

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
const int MAX_N = 10;
int n, m, maxCount;
vector<int> friendship[MAX_N];
vector<int> currentPath, bestPath;
bool visited[MAX_N];
void Backtrack(int node, int count) {
visited[node] = true;
currentPath.push_back(node);
for (int i = 0; i < friendship[node].size(); ++i) {
int friendNode = friendship[node][i];
if (!visited[friendNode]) {
Backtrack(friendNode, count + 1);
}
}
if (count > maxCount) {
maxCount = count;
bestPath = currentPath;
}
visited[node] = false;

currentPath.pop_back();
}
int main() {
cout << "Enter the number of children (n): ";
cin >> n;
cout << "Enter the number of pairs of friends (m): ";
cin >> m;
cout << "Enter the friendships (pairs of friends):" <<
endl;
for (int i = 0; i < m; ++i) {
int friend1, friend2;
cin >> friend1 >> friend2;
friendship[friend1].push_back(friend2);
friendship[friend2].push_back(friend1);
}
maxCount = 0;
for (int i = 1; i <= n; ++i) {
fill(visited, visited + MAX_N, false);
currentPath.clear();
Backtrack(i, 1);
}
cout << "The longest sequence of children reading the
book is:" << endl;

for (int i = 0; i < bestPath.size(); ++i) {
cout << bestPath[i] << " ";
}
return 0;
}
1. Generate all numbers with distinct digits whose
sum of digits is equal to S.
Implementation:
#include <iostream>
using namespace std;
void backtrack(long currNum, int sum, int S)
{
if(sum==S)
{
cout<<currNum<<endl;
return;
}
if (sum>S)
return;
for (int i=0; i<=9; i++)
{
if (currNum%10==i)

continue;
backtrack((long)currNum*10+i,sum+i,S);
}
}
int main()
{
int S;
cin>>S;
for (long i=1; i<=9; i++)
backtrack(i,i,S);
return 0;
}
1. Generate all numbers that contain only even digits
in strictly increasing order.
Implementation:
#include <iostream>
using namespace std;
void backtrack(int num, int len)
{
if(len==0)
{
cout<<num<<endl;

return;
}
for(int i=num % 10; i<=8; i+=2)
backtrack(num*10+i,len-1);
}
int main()
{
int len;
cin>>len;
backtrack(0, len);
return 0;
}
1. Generate all numbers with digits in strictly
increasing order, where the first digit is c1, and the
second digit is c2.
Implementation:
#include <iostream>
using namespace std;
int main()
{
int c1,c2;
cin>>c1>>c2;

long num=c1*10+c2;
for(long i=c2+1;i<=9;i++)
{
num=num*10+i;
cout<<num<<endl;
}
return 0;
}
1. How many numbers with distinct digits are there?
What is the largest number with a digit sum equal
to a given S?
Implementation:
#include <iostream>
#include <vector>
// Function to check if a number has distinct digits
bool hasDistinctDigits(int num) {
std::vector<bool> digits(10, false);
while(num>0) {
int digit=num%10;
if(digits[digit])
return false; // Digit repeated
digits[digit]=true;

num/=10;
}
return true; // All digits are distinct
}
// Function to count the numbers with distinct digits up to
a given limit
void countDistinctDigitNumbersHelper(int current, int
limit, int &count, std::vector<bool> &used) {
if(current>limit)
return;
if(hasDistinctDigits(current))
++count;
// Explore all possibilities by appending unused digits to
the current number
for(int digit=1; digit<=9; ++digit) {
if(!used[digit]) {
used[digit]=true;
countDistinctDigitNumbersHelper(current*10+digit,limit,c
ount,used);
used[digit]=false;
}
}
}

// Function to count the numbers with distinct digits up to
a given limit
int countDistinctDigitNumbers(int limit) {
int count=0;
std::vector<bool> used(10, false);
countDistinctDigitNumbersHelper(0, limit, count, used);
return count;
}
// Backtracking function to find the largest number with a
given digit sum
void findLargestNumberWithDigitSumHelper(long long
current, int remainingSum, long long &largest,
std::vector<bool> &used) {
if(remainingSum<0)
return;
if (remainingSum==0) {
largest=std::max(largest, current);
return;
}
// Explore all possibilities by appending unused digits to
the current number
for(int digit=9; digit>=0;—digit) {
if(!used[digit]) {

used[digit]=true;
findLargestNumberWithDigitSumHelper(current*10+digit,
remainingSum-digit, largest, used);
used[digit]=false;
}
}
}
// Function to find the largest number with a given digit
sum
long long findLargestNumberWithDigitSum(int digitSum) {
long long largest=-1;
std::vector<bool> used(10, false);
findLargestNumberWithDigitSumHelper(0, digitSum,
largest, used);
return largest;
}
int main() {
// Example usage
int limit = 10000;
int distinctCount = countDistinctDigitNumbers(limit);
std::cout << "Number of distinct digit numbers up to " <<
limit << ": " << distinctCount << std::endl;
int targetSum = 15;

long long largestNum =
findLargestNumberWithDigitSum(targetSum);
std::cout << "Largest number with digit sum " <<
targetSum << ": " << largestNum << std::endl;
return 0;
}
1. Cubes. For n (n≤10) cubes, the length of the side
and the color of each cube are known, which can
be either red or white. Build the tallest tower
possible with these cubes, while respecting the
following conditions: there should be no two
adjacent cubes with the same color, and a cube
with a larger side cannot be placed over any other
cube.
Implementation:
#include <cstring>
#include <iostream>
#include <fstream>
using namespace std;
int x[50],k,valid,n,m;
int dim[50];char cul[50][20];
void read() //read data
{ 

ifstream f("data.in");
f>>n;
for(int i=1;i<=n;i++)
{
f>>dim[i];
f>>cul[i];
}
}
void posibil(int k,int &valid)
{
valid=1;
for (int i=1;i<k;i++)
if(x[i]==x[k])
valid=0; //only one cube at once
if(k>1)
if(strcmp(cul[x[k-1]],cul[x[k]])==0)
valid=0;// no same color
if(k>1)
if(dim[x[k-1]]<dim[x[k]])
valid=0;// highest length has priority
}
int solutie(int k)
{

/*we found a solution*/
if(k==n)
return 1;
else
return 0;
}
void displayData(int k)
{
/*display solution*/
for(int i=1;i<=k;i++)
cout<<x[i]<<"("<<dim[x[i]]<<" "<<cul[x[i]]<<") ";
cout<<endl;
}
void back()
{
k=1;
x[k]=0;
while(k>0)
{
valid=0;
while(!valid && x[k]<n)
{
x[k]=x[k]+1;

posibil(k,valid);
}
if(!valid)
k—;
else if(solutie(k))
displayData(k);
else
{
k++;
x[k]=0;
}
}
}
int main()
{
read();
back();
displayData(k);
return 0;
}
1. Parallelepipeds. For n (n≤10) parallelepipeds,
the three dimensions a, b, c are known. Build the

tallest tower possible with these parallelepipeds,
ensuring that a parallelepiped with a larger face
cannot be placed over a smaller face of the
previous parallelepiped. The parallelepipeds can be
rotated.
Implementation:
#include <iostream>
#include <algorithm>
#include <vector>
#include <fstream>
using namespace std;
ifstream f("date.in");
struct Box
{
int a,b,c;
bool used; 
};
// store the data
vector<Box> boxes;
// max height of the tower
int maxHeight = 0;
vector<int> maxStack;
void findHeight(vector<int>& stack, int height)

{
if (height>maxHeight)
{
maxHeight=height;
maxStack=stack;
}
for (int i=0; i<boxes.size(); i++)
{
if (!boxes[i].used)
{
for (int j=0; j<3; j++)
{
int a=boxes[i].a;
int b=boxes[i].b;
int c=boxes[i].c;
// check if we can add it up to the tower
if (stack.size() == 0 || (a <= boxes[stack.back()].a && b
<= boxes[stack.back()].b)  ||
(a <= boxes[stack.back()].b && b <=
boxes[stack.back()].a) ||
(b <= boxes[stack.back()].a && c <=
boxes[stack.back()].b) ||

(b <= boxes[stack.back()].b && c <=
boxes[stack.back()].a) ||
(c <= boxes[stack.back()].a && a <=
boxes[stack.back()].b) ||
(c <= boxes[stack.back()].b && a <=
boxes[stack.back()].a)) {
boxes[i].used = true;
stack.push_back(i);
findHeight(stack, height + c);
stack.pop_back();
boxes[i].used = false;
}
swap(a,b);
swap(b,c);
}
}
}
}
int main()
{
int n;
f>> n;
// read data

for (int i = 0; i < n; i++)
{
int a, b, c;
f>>a>>b>>c;
boxes.push_back({a, b, c, false});
}
// sort based on the max area
sort(boxes.begin(), boxes.end(), [](const Box& b1, const
Box& b2)
{
return max(b1.a, max(b1.b, b1.c)) > max(b2.a,
max(b2.b, b2.c));
});
vector<int> stack;
findHeight(stack, 0);
// display max height
cout << "Max height of the tower: " << maxHeight <<
endl;
cout << "The order is: ";
for (int i : maxStack)
cout << i+1 << " ";
cout << endl;
return 0;

}
1. Math - Computer Science. Andrei is passionate
about both mathematics and computer science. He
knows that every natural number n can be
expressed as the sum of other numbers x1 + x2 +
x3 + ... + xn (1≤k≤n) whose product p can be
determined. Andrei aims to decompose a natural
number n into a sequence of numbers whose sum
is n, considering all possibilities. For each
sequence of numbers, he will also determine their
product p = x1 · x2 · x3 · ...· xk, where n = x1 + x2 +
x3 + ... + xk. For a non-zero natural number n,
Andrei will write a program to determine the
largest possible product p.
Requirements:
a. Write a program that finds the largest product
calculated in this way for all possible
decompositions of a non-zero natural number n
into the sum of other numbers. Determine the
product p.
b. Find a solution for determining the value of p
without generating all decompositions.
Input:

The input file math.in contains a natural number n
on the first line.
Output:
The output file math.out will contain a natural
number p as described in the problem statement.
Example:
math.in math.out
Explanations
2
2
There are two decompositions of
number 2:
2 for which: p=2
1+1 for which: p=1*1=1
The maximul value of p is 2.
4
4
There are five decompositions of
number 4:
4 for which: p=4
1+3 for which: p=1*3=3
2+2 for which: p=2*2=4
1+1+2 for which: p=1*1*2=2
1+1+1+1 for which: p=1*1*1*1=1
Maximum value of p is 4.

Implementation:
a. 
#include <iostream>
#include <vector>
#include <fstream>
using namespace std;
//store the max value of p
int maxProduct = 0;
//generate all combos
void findProduct(vector<int>& numbers, int n, int
product)
{
//if the sum is equal to n
if (n == 0)
{
//check if the product is greater than max p
if (product > maxProduct)
{
maxProduct = product;
}
return;
}

//add the rest of the numbers
if (n > 0) {
for (int i = 1; i <= n; i++)
{
//add the number to the array
numbers.push_back(i);
findProduct(numbers, n - i, product * i);
numbers.pop_back();
}
}
}
int main()
{ 
ifstream f("math.in");
ofstream g("math.out");
int n;
f>>n;
vector<int> numbers;
findProduct(numbers,n,1);
g<<"The greatest value of p is: "<<maxProduct<<endl;
return 0;
}

a. Explanations: An efficient method to determine
the largest possible product without generating all
possible decompositions of the number n is based
on the observation that, to maximize the product,
it is beneficial to have as many factors with the
value 2 as possible.
To obtain the largest possible product, the following
steps can be followed:
Divide n by 2 as many times as possible until it is
no longer divisible. This will leave an odd number,
denoted as n'.
Calculate 2 raised to the power of the number of
divisions performed and multiply it by n' (which is
the maximum possible for an odd number).
This method relies on the fact that multiplying by 2
brings an exponential gain to the product, while
multiplying by any odd number only brings a linear
gain. Therefore, maximizing the number of factors of 2
will also maximize the product.
#include <iostream>
#include <cmath>
using namespace std;

int main() {
int n;
cin>>n;
int product=1;
int div=0;
while(n%2==0)
{
div++;
n /= 2;
}
product = (int)pow(2, div) * n;
cout << "The greatest product is: "<<product<<endl;
return 0;
}
1. The Fellowship of the Ring. All coexisting tribes
– hobbits, dwarves, humans, elves, wizards, trolls –
on Earth have decided that hobbits should be the
keepers of the Power Ring, which should reach the
peaceful land called The Shire. The Ring has been
taken for some time by the Uruk-Hai scouts on
their way to the malevolent Saruman. The old and
powerful wizard Gandalf knows that the only one
who can fulfill the challenging adventure of
recovering the ring is the hobbit Frodo. After a

series of adventures, Frodo climbs a number n of
steps and reaches the Ah-Karus cave, which
houses the precious ring. The rock covering the
entrance can only be moved aside after uttering
the magic number. The magic number is the
largest prime number that can be obtained by
removing some digits from the number n without
permuting the remaining digits. Help Frodo
discover the magic number and enter the
Fellowship of the Ring.
Input:
From the file “number.in”, natural numbers are read,
each number n on a separate line (n representing the
number of steps), until reading the number 0.
Output:
The requested numbers are written to the file
“number.out”, each number on a separate line. If there
is no such number, write 0.
Constraints and clarifications:
1 ≤ n ≤ 2,000,000,000

number.in number.out
2341  2341
448  0
723452 73
0
Implementation:
#include <iostream>
#include <string>
#include <fstream>
using namespace std;
int maxPrime;
// function to check if a number is prime
bool isPrime(int num)
{
if (num <= 1) return false;
if (num <= 3) return true;
if (num % 2 == 0 || num % 3 == 0) return false;
for (int i = 5; i * i <= num; i += 6)

if (num % i == 0 || num % (i + 2) == 0)
return false;
return true;
}
void findMaxPrime(int n)
{
// if the number is prime and greater than maxPrime
if (isPrime(n) && n > maxPrime)
maxPrime = n;
string num = to_string(n);
// remove each digit one by one and recursively call the
function
for (int i = 0; i < num.length(); i++)
{
string temp = num.substr(0, i) + num.substr(i + 1);
if(temp.size()>0)
findMaxPrime(stoi(temp));
}
}
int main()
{ 
ifstream f("number.in");
ofstream g("number.out");

int n;
while(f>>n)
{
if(n==0)
break;
maxPrime=0;
findMaxPrime(n);
g<<"The Magic Number: "<<maxPrime<<endl;
}
return 0;
}

11.9  GENERALIZED
BACKTRACKING
1. On a chessboard of size nxn (n≤10), there is a
knight in the top-left corner. Display all possibilities
of traversing the entire chessboard without passing
through the same position twice.
Example: for n=5, a solution could be:
1 14 9 20 3
24 19 2 15 10
13 8 25 4 21
18 23 6 11 16
7 12 17 22 5
Implementation:
#include <iostream>
using namespace std;
int n,ib,jb,a[11][11],cnt;
const int dic[]={-2,-1,1,2,2,1,-1,-2};
const int djc[]={1,2,2,1,-1,-2,-2,-1};
int inside(int i , int j)

{
return i>=1 && i<=n && j>=1 && j<=n;
}
void afis()
{
for(int i=1; i<=n; i++)
{
for(int j=1; j<=n; j++)
cout<<a[i][j]<<" ";
cout<<endl;
}
}
void back(int i,int j,int pas)
{
for(int d=0; d<8; d++)
{
int inou=i+dic[d];
int jnou=j+djc[d];
if(inside(inou,jnou) && a[inou][jnou]==0)
{
a[inou][jnou]=pas;
if(pas==n*n)
{

afis();
exit(0);
}
else back(inou, jnou, pas+1);
a[inou][jnou]=0;
}
}
}
int main()
{
cin>>n;
a[1][1]=1;
back(1,1,2);
return 0;
}
1. On a chessboard of size nxn (n≤10), there is a
knight in position x1, y1. Display all possibilities
for a knight to traverse the entire chessboard
without passing through the same position twice,
such that it reaches position x2, y2.
Implementation:
#include <iostream>

using namespace std;
const int MAX_N=10;
int n;
int x1, y1, x2, y2;
int sol[MAX_N][MAX_N];
int xMove[8] = {2, 1, -1, -2, -2, -1, 1, 2};
int yMove[8] = {1, 2, 2, 1, -1, -2, -2, -1};
bool isValid(int x, int y) {
return (x >= 0 && x < n && y >= 0 && y < n && sol[x]
[y] == -1);
}
bool solve(int x, int y, int move) {
sol[x][y]=move;
if (move==n*n) {
return true; // Knight has visited all cells
}
for (int i = 0; i < 8; i++) {
int newX = x + xMove[i];
int newY = y + yMove[i];
if (isValid(newX, newY)) {
if (solve(newX, newY, move + 1)) {
return true;
}

sol[newX][newY] = -1; // Backtracking
}
}
return false;
}
int main() {
// Read chessboard size
cout << "Enter the chessboard size (n): ";
cin >> n;
// Read knight's initial and final positions
cout << "Enter the initial position (x1 y1): ";
cin >> x1 >> y1;
cout << "Enter the final position (x2 y2): ";
cin >> x2 >> y2;
// Initialize the solution matrix with -1
for (int i = 0; i < n; i++)
for (int j = 0; j < n; j++)
sol[i][j] = -1;
// Call the recursive function
if (solve(x1, y1, 1)) {
cout << "Knight's tour is possible:" << endl;
for (int i = 0; i < n; i++) {
for (int j = 0; j < n; j++)

cout << sol[i][j] << "\t";
cout << endl;
}
} else {
cout << "Knight's tour is not possible." << endl;
}
return 0;
}
1. Given a chessboard of size nxn (n≤10) with a
knight in position x1, y1, and a matrix A with n
rows and n columns where aij stores the number of
passes of a knight through that square. Display all
possibilities for a knight to traverse the entire
chessboard, reaching position x2, y2, and ensuring
that each square is traversed the specified number
of times.
Implementation:
#include <iostream>
#include <vector>
using namespace std;
const int MAX_N = 10;
int n;

int x1, y1, x2, y2;
vector<vector<int>> A;
vector<vector<int>> sol;
// Possible moves for the knight
int xMove[8] = {2, 1, -1, -2, -2, -1, 1, 2};
int yMove[8] = {1, 2, 2, 1, -1, -2, -2, -1};
bool isValid(int x, int y) {
return (x >= 0 && x < n && y >= 0 && y < n && sol[x]
[y] == 0);
}
bool solve(int x, int y, int move) {
sol[x][y] = move;
if (move == n * n) {
return true; // Knight has visited all cells
}
for (int i = 0; i < 8; i++) {
int newX = x + xMove[i];
int newY = y + yMove[i];
if (isValid(newX, newY) && sol[newX][newY] < A[newX]
[newY]) {
if (solve(newX, newY, move + 1)) {
return true;
}

sol[newX][newY] = 0; // Backtracking
}
}
sol[x][y] = 0;
return false;
}
int main() {
// Read chessboard size
cout << "Enter the chessboard size (n): ";
cin >> n;
// Read knight's initial and final positions
cout << "Enter the initial position (x1 y1): ";
cin >> x1 >> y1;
cout << "Enter the final position (x2 y2): ";
cin >> x2 >> y2;
// Read matrix A
cout << "Enter the matrix A with desired number of
passes:" << endl;
A.resize(n, vector<int>(n));
for (int i = 0; i < n; i++)
for (int j = 0; j < n; j++)
cin >> A[i][j];
// Initialize the solution matrix with 0

sol.resize(n, vector<int>(n, 0));
// Call the recursive function
if (solve(x1, y1, 1)) {
cout << "Knight's tour is possible:" << endl;
for (int i = 0; i < n; i++) {
for (int j = 0; j < n; j++)
cout << sol[i][j] << "\t";
cout << endl;
}
} else {
cout << "Knight's tour is not possible." << endl;
}
return 0;
}
1. Given a chessboard of size nxn (n≤10) with a
knight in position x1, y1, and a matrix A with n
rows and n columns where aij stores the value 0 if
it can be traversed and the value 1 if it cannot be
traversed. Display all possibilities for a knight to
traverse the entire chessboard, excluding squares
that cannot be traversed, in such a way that it
reaches position x2, y2.
Implementation:

#include <iostream>
#include <fstream>
using namespace std;
const int N=10;
int n;
int x1, y1, x2, y2,ns;
int A[N][N], visited[N][N];
bool isValid(int x, int y)
{
return (x >= 0 && x < n && y >= 0 && y < n && A[x]
[y] == 0 && visited[x][y] == 0);
}
void printSolution()
{ 
ns++;
cout<<"Solutia "<<ns<<":"<<endl;
for(int i=0; i<n; i++)
{
for(int j=0; j<n; j++)
{
cout<<visited[i][j]<<" ";
}
cout<<endl;

}
}
void solve(int x, int y, int step)
{
// check if current position is the final position
if (x==x2 && y==y2)
{
printSolution();
return;
}
// check if current position is valid
if (!isValid(x, y))
{
return;
}
// mark current position as visited
visited[x][y] = step;
// move to next position
int dx[] = {-2, -1, 1, 2, 2, 1, -1, -2};
int dy[] = {1, 2, 2, 1, -1, -2, -2, -1};
for (int i=0; i<8; i++)
{
int newX=x+dx[i];

int newY=y+dy[i];
solve(newX, newY, step+1);
}
// backtrack
visited[x][y] = 0;
}
int main()
{
ifstream f("date.in");
f>>n>>x1>>y1>>x2>>y2;
for(int i=0; i<n; i++)
for(int j=0; j<n; j++)
f>>A[i][j];
solve(x1, y1, 1);
return 0;
}
1. A mouse is in a rectangular-shaped maze with m
rows and n columns. The walls are marked with 1,
and the corridors are marked with 0. The initial
coordinates of the mouse are known: Li, Ci.
Determine all the possibilities the mouse has to
exit the maze. The mouse can move in all four
directions by one cell (up, right, down, left).

Example: For m=5, n=10, Li=4, Ci=3
1111000011
1101000011
1000111111
1000000001
1111011011
Solutions: (4,3), (4,4), (4,5), (5,5) and (4,3), (4,4),
(4,5), (4,6), (4,7), (4,8), (5,8).
Implementation:
#include <iostream>
#include <vector>
#include <fstream>
using namespace std;
const int dx[4] = {0, 1, 0, -1};
const int dy[4] = {1, 0, -1, 0};
int m, n;
vector<vector<int>> maze;
vector<vector<bool>> visited;
void printSolution() {
for (int i = 1; i <= m; ++i) {
for (int j = 1; j <= n; ++j) {
if (visited[i][j]) {

cout << "(" << i << "," << j << ") ";
}
}
}
cout << endl;
}
void backtracking(int x, int y) {
if (x < 1 || x > m || y < 1 || y > n || maze[x][y] == 1 ||
visited[x][y]) {
return;
}
visited[x][y] = true;
if (x == 1 || x == m || y == 1 || y == n) {
printSolution();
} else {
for (int i = 0; i < 4; ++i) {
int newX = x + dx[i];
int newY = y + dy[i];
backtracking(newX, newY);
}
}
visited[x][y] = false;
}

int main() {
ifstream f("data.in");
f >> m >> n;
maze.resize(m + 1, vector<int>(n + 1));
visited.resize(m + 1, vector<bool>(n + 1, false));
for (int i = 1; i <= m; ++i) {
for (int j = 1; j <= n; ++j) {
f >> maze[i][j];
}
}
int Li, Ci;
f >> Li >> Ci;
backtracking(Li, Ci);
return 0;
}
1. In a maze of size mxn, a mouse is located at
position x1, y1. Each cell can have 4 exits to
adjacent cells in the 4 directions: N, W, S, E. The
exits are encoded by numbers in the range [0, 15],
and their binary representation has the meaning: 1
for an open door (exit) and 0 for a closed door. For
example, 13 in decimal is represented as 1101 in
binary, indicating that one can exit in the directions

N, W, and E while the exit to the S is blocked.
Display a solution for the mouse to exit the maze.
Example: For m=3, n=3, and the maze map: 
A solution to exit the maze is: (1,1) , (2,1) , (3,1) ,
(3,2) , (3,3) with the exit to East.
Implementation:
#include <iostream>
#include <vector>
#include <fstream>
using namespace std;
const int dx[] = {-1, 0, 1, 0};
const int dy[] = {0, 1, 0, -1};
// functia verifica daca pozitia (x,y) este valida
bool isValid(int x, int y, int m, int n)
{
return x >= 1 && x <= m && y >= 1 && y <= n;
}
// functia verifica daca pozitia (x,y) poate fi folosita pentru
a iesi din labirint
bool canMove(int x, int y, vector<vector<int>> &map)
{

return map[x][y] != 0;
}
// functia backtracking pentru a gasi o solutie
bool findExit(int x, int y, vector<vector<int>> &map,
vector<pair<int, int>> &path)
{
if (!isValid(x, y, map.size() - 1, map[0].size() - 1))
return false;
// daca am ajuns la pozitia de iesire din labirint
if (x == map.size() - 1 && y == map[0].size() - 1)
{
path.push_back({x, y});
return true;
}
// marcheaza pozitia curenta ca fiind vizitata
map[x][y] = 0;
path.push_back({x, y});
// incerc fiecare directie posibila
for (int i = 0; i < 4; i++)
{
int newX = x + dx[i];
int newY = y + dy[i];
if (canMove(newX, newY, map))

{
if (findExit(newX, newY, map, path))
return true;
}
}
// daca nu am gasit nicio solutie, marcheaza pozitia ca
fiind nevizitata si iese din recursivitate
path.pop_back();
map[x][y] = 1;
return false;
}
int main() {
ifstream f("date.in");
int m, n;
f >> m >> n;
vector<vector<int>> map(m + 1, vector<int>(n + 1));
for (int i = 1; i <= m; i++)
for (int j = 1; j <= n; j++)
f>> map[i][j];
vector<pair<int, int>> path;
if (findExit(1, 1, map, path))
{
cout << "Solutie: ";

for (auto p : path) {
cout << "(" << p.second << ", " << p.first << ") ";
}
cout <<endl;
}
return 0;
}
1. A map of size mxn (m,n≤10) stores the altitudes
of locations expressed by natural numbers. The
coordinates x1, y1 of a tourist on the map are
given. Display all the possibilities for a tourist to
reach from x1, y1 to x2, y2 in such a way that the
tourist descends to an altitude lower or equal to
the current one. The tourist can only advance to an
adjacent location on the map in the four directions:
E, W, S, N.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
const int MAX_N = 10;
const int MAX_M = 10;
int harta[MAX_N + 1][MAX_M + 1];

bool vizitat[MAX_N + 1][MAX_M + 1];
int x1, y1, x2, y2, m, n;
bool valid(int x, int y)
{
if (x<1 || x>m || y<1 || y>n)
return false;
if (harta[x][y]>=harta[x1][y1])
return false;
if (vizitat[x][y])
return false;
return true;
}
void afiseaza(int x, int y)
{
cout<<"("<<x<<","<<y<<")";
}
void backtracking(int x, int y)
{
if (x==x2 && y==y2)
{
afiseaza(x, y);
cout<<endl;
return;

}
vizitat[x][y]=true;
afiseaza(x, y);
if(valid(x-1,y)) // N
backtracking(x-1,y);
if(valid(x,y-1))  // V
backtracking(x,y-1);
if(valid(x + 1, y)) // S
backtracking(x+1,y);
if(valid(x, y + 1))  // E
backtracking(x,y+1);
vizitat[x][y]=false;
}
int main()
{
ifstream f("data.in");
f>>m>>n;
for (int i = 1; i <= m; i++)
for (int j = 1; j <= n; j++)
f>>harta[i][j];
f>>x1>>y1>>x2>>y2;
backtracking(x1,y1);
return 0;

}
1. On a lake, there is a frog and p lily pads. The lake
has a rectangular shape with dimensions m x n.
The coordinates (xb, yb) represent the frog's
position, and the coordinates (xi, yi) represent the
positions of the lily pads. Display all the
possibilities for the frog to exit the lake, knowing
that the frog can only jump in the manner of a
knight's move on a chessboard.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
const int dx[] = {-2, -2, 2, 2, -1, -1, 1, 1};
const int dy[] = {-1, 1, -1, 1, -2, 2, -2, 2};
int n, m, xb, yb, xf, yf;
int path[10][10];
bool leaf[10][10];
bool visited[10][10];
void backtracking(int x, int y, int step)
{
if (x == xf && y == yf)
{

cout << "Found solution" << endl;
for (int i = 1; i <= step; i++)
cout << "(" << path[i][0] << "," << path[i][1] << ") ";
return;
}
for (int i = 0; i < 8; i++)
{
int newX = x + dx[i];
int newY = y + dy[i];
if (newX >= 1 && newX <= n && newY >= 1 && newY
<= m && !visited[newX][newY])
{
path[step][0] = newX;
path[step][1] = newY;
visited[newX][newY] = true;
if (leaf[newX][newY]) {
leaf[newX][newY] = false;
backtracking(newX, newY, step + 1);
leaf[newX][newY] = true;
}
else
backtracking(newX, newY, step + 1);

visited[newX][newY] = false;
}
}
}
int main()
{ 
ifstream f("date.in");
f>>n>>m>>xb>>yb>>xf>>yf;
for (int i=1; i<=n; i++)
{
for (int j=1; j<=m; j++)
{
char ch;
f>>ch;
if (ch=='f')
leaf[i][j]=true;
}
}
visited[xb][yb]=true;
backtracking(xb, yb, 0);
return 0;
}

1. On a lake, there is a frog and p lily pads. The lake
has a rectangular shape with dimensions m x n.
The coordinates (x1, y1) represent the frog's
position, and the coordinates (xi, yi) represent the
positions of the lily pads. Display all the
possibilities for the frog to reach the position x2,
y2, knowing that the frog can only jump in the
manner of a knight's move on a chessboard.
Implementation:
#include <iostream>
#include <fstream>
#include <list>
using namespace std;
const int dx[] = {-2, -2, 2, 2, -1, -1, 1, 1};
const int dy[] = {-1, 1, -1, 1, -2, 2, -2, 2};
int n, m, x1, y1, x2, y2;
bool leaf[10][10];
bool visited[10][10];
list<pair<int, int>> path;
void backtracking(int x, int y)
{
path.push_back({x, y});
if (x == x2 && y == y2)

{
cout<<"Found solution: ";
for (auto [x, y] : path)
cout << "(" << x << ", " << y << ") ";
cout << endl;
return;
}
for (int i = 0; i < 8; i++)
{
int newX = x + dx[i];
int newY = y + dy[i];
if (newX >= 1 && newX <= n && newY >= 1 && newY
<= m && !visited[newX][newY])
{
visited[newX][newY] = true;
backtracking(newX, newY);
visited[newX][newY] = false;
}
}
path.pop_back();
}
int main()
{ 

ifstream f("date.in");
int p;
f>>n>>m>>p>>x1>>y1>>x2>>y2;
for (int i = 1; i <= p; i++)
{
int x, y;
f>>x>>y;
leaf[x][y] = true;
}
backtracking(x1, y1);
return 0; 
}
1. Photography problem. A black and white
photograph is encoded by a binary matrix with n
rows and m columns (n, m ≤ 20). An object
consists of elements with a value of 1 that are
adjacent horizontally, vertically, or diagonally.
a. Determine the number of objects in the
photograph.
b. How many elements does the largest object have?
Example. For n=5, m=8:

00100000
01110010
00111011
10000000
11100011
a. Display 4 (objects).
b. Display the value 7 (the maximum number of
elements contained in an object).
Implementation:
#include <iostream>
#include <fstream>
#include <cmath>
using namespace std;
const int dx[]={-1, -1, -1, 0, 0, 1, 1, 1};
const int dy[]={-1, 0, 1, -1, 1, -1, 0, 1};
int n, m;
int mat[20][20];
bool visited[20][20];
int countObjects;
int maxElements;
int DFS(int x, int y)

{
visited[x][y]=true;
int currentElements=1;
for(int i=0; i<8; i++)
{
int newX=x+dx[i];
int newY=y+dy[i];
if(newX>=0 && newX<n && newY>=0 && newY<m &&
mat[newX][newY]==1 && !visited[newX][newY])
currentElements+=DFS(newX, newY);
}
return currentElements;
}
int main()
{
ifstream f("data.in");
f >>n>>m;
for(int i=0; i<n; i++)
for(int j=0; j<m; j++)
f>>mat[i][j];
for(int i=0; i<n; i++)
{
for(int j=0; j<m; j++)

{
if(mat[i][j]==1 && !visited[i][j])
{
countObjects++;
int objectSize=DFS(i, j);
maxElements=max(maxElements, objectSize);
}
}
}
cout<<"Number of objects: "<<countObjects<<endl;
cout<<"Max number of elements: "
<<maxElements<<endl;
return 0;
}
1. A rectangular garden contains mxn plots, where
each plot contains a variety of flowers encoded by
a number from 1 to 9. Several adjacent plots in one
of the four directions containing the same type of
flower form a roundel. Given the map of the garden
and a flower variety p, determine:
a) how many roundels of type p exist

b) how many plots the largest roundel of variety p
contains.
Example: For m=5, n=8, p=1
22133455
31113415
44111411
15555777
11177711
a. Display 4 (roundels).
b. Display the value 7 (the maximum number of plots
contained in a roundel).
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
const int dx[]={-1, 0, 1, 0, -1, -1, 1, 1};
const int dy[]={0, 1, 0, -1, -1, 1, -1, 1};
int n, m, p, countRondels, maxPlots;
int garden[20][20];
bool visited[20][20];
void backtracking(int x, int y, int count) {

if(x<0 || x>=n || y<0 || y>=m)
return;
if (visited[x][y] || garden[x][y]!=p)
return;
visited[x][y]=true;
count++;
for(int i=0; i<8; i++)
backtracking(x+dx[i], y+dy[i], count);
// Move this line outside of the for loop
maxPlots=max(maxPlots, count);
}
int main()
{ 
ifstream f("data.in");
countRondels=0;
maxPlots=0;
f>>n>>m>>p;
for(int i=0; i<n; i++)
for(int j=0; j<m; j++)
f>>garden[i][j];
for(int i=0; i<n; i++) {
for(int j=0; j<m; j++) {
if(!visited[i][j] && garden[i][j]==p) {

backtracking(i,j,0);
countRondels++;
}
}
}
cout<<"The number of rondels is: "
<<countRondels<<endl;
cout<<"The largest rondel contains "<<maxPlots+1<<"
plots."<<endl;
return 0;
}
1. A rectangular garden contains mxn plots, where
each plot contains a variety of flowers encoded by
a number from 1 to 9. Several adjacent plots in one
of the four directions containing the same type of
flower form a roundel. Given the map of the
garden, determine:
a. how many roundels exist.
b. how many plots the largest flower roundel
contains.
Example: For m=5, n=8
22133355

21113315
22111311
15555777
11177711
a. Display 9 because the garden contains:
- 4 roundels of type 1
- 1 roundel of type 2
- 1 roundel of type 3
- 2 roundels of type 5
- 3 roundels of type 7
a. Display the value 7, the maximum number of plots
contained in a roundel, which is roundel 1.
Implementation:
#include <iostream>
#include <fstream>
#include <vector>
using namespace std;
const int dx[] = {-1, 0, 1, 0};
const int dy[] = {0, 1, 0, -1};

int m, n;
vector<vector<int>> garden;
int total_count = 0, max_count;
void dfs(int x, int y, int type, int &count) {
if (x < 0 || x >= m || y < 0 || y >= n || garden[x][y] !=
type)
return;
garden[x][y] = -1; // mark as visited
count++;
for (int i = 0; i < 4; i++) {
int new_x = x + dx[i];
int new_y = y + dy[i];
dfs(new_x, new_y, type, count);
}
}
int main() { 
ifstream f("data.in");
f >> m >> n;
garden.resize(m);
for (int i = 0; i < m; i++) {
garden[i].resize(n);
for (int j = 0; j < n; j++)
f >> garden[i][j];

}
// traverse each cell in the garden
for (int i = 0; i < m; i++) {
for (int j = 0; j < n; j++) {
if (garden[i][j] != -1) {
// if the cell has not been visited
int count = 0;
dfs(i, j, garden[i][j], count);
max_count = max(max_count, count);
total_count++;
}
}
}
cout << "The total number of rondels: " << total_count
<< endl;
cout << "The maximum number of plots: " << max_count
<< endl;
return 0;
}
1. Urbanism. For an urban planning project, a
construction company evaluates the streets and
buildings in the city. For this, the city is divided into
plots. The plots are rectangular-shaped with

dimensions m x n meters and are composed of
multiple cells. It is considered that each cell of a
plot represents one square meter. Naturally, a plot
can contain streets and constructions (of any other
type). If a cell belongs to a street, it is marked with
0 (zero), and if it belongs to a construction, it is
marked with a nonzero natural number
representing the order number of that specific
construction. Obviously, the same construction can
occupy one or more cells, and all cells will have the
same order number (of the construction). Some
institutions in the city may have multiple
constructions, but all constructions belonging to
the same institution have the same order number.
One of the study objectives of the urban planning
project is to determine the construction with the
largest area for a given plot. It is considered that
adjacent cells with the same order number belong
to the same construction (adjacency is expressed
in the 8 directions: E, W, N, S, NE, NW, SE, SW).
Requirement: Determine how many constructions
are in a given plot, how many cells the largest
construction has, and what is the order number of that
construction.

Input: The input file urban.in contains, on the first
line, two natural numbers M and N representing the
length and width of the plot, followed by M x N natural
numbers. The numbers are written in the file on M
rows, with N values on a single row, separated by a
space. Each number represents the order number of
the cell it represents.
Output: The output file urban.out will contain, on a
single line, three numbers separated by a space
representing: the number of constructions, the
maximum number of cells occupied by a single
construction (the construction with the largest area),
and the order number of that construction.
Details: The order numbers of constructions are
nonzero natural numbers with at most four digits. If
there are multiple constructions that occupy the
maximum number of cells, the order number of the
construction with the smallest order number will be
displayed.
Streets are represented by the value 0 and are not
considered a construction of interest.
Restrictions:

0 < N ≤ 100 (integer)
< M ≤ 100 (integer)
Example:
urban.in
urban.out
explanation
9 13
1 1 0 0 0
0 0 0 0 0 0
9 9
0 1 0 0 0
0 0 0 0 0 0
0 0
0 0 0 0 0
2 2 0 0 0 0
0 0
0 0 3 0 0
2 2 0 0 2 0
0 0
0 0 0 3 0
0 0 0 0 0 0
0 0
4 0 3 3 0
0 0 0 0 3 3
9 8 3
There are 9 constructions
in the plot.
The maximum number of
cells occupied by a
construction is equal to 8.
The construction with the
maximum number of cells
has the order number 3.

3 3
4 4 3 4
0 0 0 0 0 0
0 0 0
4 4 3 3 0
0 0 0 0 1 1
1 1
4 4 4 3
0 0 0 0 0 1
1 1 0
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
const int dx[] = {-1, 0, 1, 0, -1, -1, 1, 1};
const int dy[] = {0, 1, 0, -1, 1, -1, 1, -1};
int m, n;
int max_size = 0;
int max_num = 0;
int building_count = 0;
int building_num = 0;
int parcel[101][101];

bool visited[101][101];
void dfs(int x, int y, int num)
{
visited[x][y]=true;
building_num++;
for(int i=0; i<8; i++)
{
int newx=x+dx[i];
int newy=y+dy[i];
if (newx>=1 && newx<=m && newy>=1 && newy<=n
&& !visited[newx][newy] && parcel[newx][newy]==num)
dfs(newx, newy, num);
}
}
int main()
{
ifstream f("urban.in");
ofstream g("urban.out");
f>>m>>n;
for(int i=1; i<=m; i++)
for(int j=1; j<=n; j++)
f>>parcel[i][j];
for (int i=1; i<=m; i++)

{
for (int j=1; j<=n; j++)
{
if (parcel[i][j] != 0 && !visited[i][j])
{
building_count++;
building_num=0;
dfs(i, j, parcel[i][j]);
if (building_num>max_size)
{
max_size=building_num;
max_num=parcel[i][j];
}
}
}
}
g<<building_count<<" "<<max_size<<" "
<<max_num<<endl;
return 0;
}

CHAPTER 12 – DIVIDE & CONQUER
1. Consider a one-dimensional array storing n
nonzero natural numbers (n≤100). Using the
Divide and Conquer method, perform the following
operations:
a) Sum of the components
b) Product of the components
c) Sum of the odd components
d) Greatest common divisor of the components
e) Minimum value
f) Sum of the digits of all components
g) Number of palindrome components
h) Number of components that are prime numbers
Implementation:
#include <iostream>
#include <cmath>
using namespace std;
int v[100],n,i;
///sum of components
int sum(int st,int dr)

{
int m,a,b;
if(st<dr)
{
m=(st+dr)/2;
a=sum(st,m);
b=sum(m+1,dr);
return a+b;
}
else
return v[st];
}
///product of components
int product(int st,int dr)
{
int m,a,b;
if(st<dr)
{
m=(st+dr)/2;
a=product(st,m);
b=product(m+1,dr);
return a*b;
}

else
return v[st];
}
///sum of odds
int sumOdds(int st,int dr)
{
int m,a,b;
if(st<dr)
{
m=(st+dr)/2;
a=sumOdds(st,m);
b=sumOdds(m+1,dr);
return a+b;
}
else if(v[st]%2==1)
return v[st];
else
return 0;
}
///GCD
int GCD(int st,int dr)
{
int m,x,y;

if(st<dr)
{
m=(st+dr)/2;
x=GCD(st,m);
y=GCD(m+1,dr);
while(x!=y)
if(x>y)
x=x-y;
else
y=y-x;
return x;
}
else
return v[st];
}
///min value
int minim(int st,int dr)
{
int m,a,b;
if(st<dr)
{
m=(st+dr)/2;
a=minim(st,m);

b=minim(m+1,dr);
if(a>b)
return b;
else
return a;
}
else return v[st];
}
///Suma of digits for each component
int sumacif(int x)
{
if(x==0)
return 0;
return x%10+sumacif(x/10);
}
int suma_cifre(int st,int dr)
{
int a,b,m;
if(st<dr)
{
m=(st+dr)/2;
a=suma_cifre(st,m);
b=suma_cifre(m+1,dr);

return a+b;
}
else return sumacif(v[st]);
}
///Count palindromes
int palindrom(int x)
{
int y=0;
while(x!=0)
{
y=y*10+x%10;
x=x/10;
}
return y;
}
int numara_palindrome(int st,int dr)
{
int a,b,m;
if(st<dr)
{
m=(st+dr)/2;
a=numara_palindrome(st,m);
b=numara_palindrome(m+1,dr);

return a+b;
}
else if(v[st]==palindrom(v[st]))
return 1;
else
return 0;
}
///Count Primes
int isPrime(int x)
{
if(x==2)
return 1;
if(x%2==0 || x<2)
return 0;
for(i=3; i<=sqrt(x); i++)
if(x%i==0)
return 0;
return 1;
}
int numara_prime(int st,int dr)
{
int a,b,m;
if(st<dr)

{
m=(st+dr)/2;
a=numara_prime(st,m);
b=numara_prime(m+1,dr);
return a+b;
}
else if(isPrime(v[st])==1)
return 1;
else
return 0;
}
int main()
{
cout<<"n=";
cin>>n;
for(i=1; i<=n; i++)
cin>>v[i];
cout<<"Sum:"<<sum(1,n);
cout<<endl;
cout<<"Product "<<product(1,n);
cout<<endl;
cout<<"Sum of odds "<<sumOdds(1,n);
cout<<endl;

cout<<"GCD: "<<GCD(1,n);
cout<<endl;
cout<<"Minimum value: "<<minim(1,n);
cout<<endl;
cout<<"Sum of digits "<<suma_cifre(1,n);
cout<<endl;
cout<<"No. of palindromes: "<<numara_palindrome(1,n);
cout<<endl;
cout<<"No. of primes "<<numara_prime(1,n);
return 0;
}
1. Consider a one-dimensional array v storing n
nonzero natural numbers (n≤100). Using the
Divide and Conquer method, reverse the
components of the array.
Example: For n=7, v=(4,7,8,1,2,3,4), the result is
v=(4,3,2,1,8,7,4).
Implementation:
#include <iostream>
using namespace std;
int v[100],n,i;
void inversare(int st,int dr)

{
int m;
if(st<dr)
{
m=(st+dr)/2;
inversare(m+1,dr);
inversare(st,m);
}
else cout<<v[st]<<" ";
}
int main()
{
cout<<"n=";
cin>>n;
for(i=1;i<=n;i++)
cin>>v[i];
inversare(1,n);
return 0;
}
1. Consider a one-dimensional array v storing n
nonzero natural numbers (n≤100). Using the
Divide and Conquer method, determine if the value
x is present in the array. Display YES or NO.

Implementation:
#include <iostream>
using namespace std;
int v[100],n,i,z;
int found(int st,int dr)
{
int m,x,y;
if(st<dr)
{
m=(st+dr)/2;
x=found(st,m);
y=found(m+1,dr);
return x+y;
}
else if(z==v[st])
return 1;
else
return 0;
}
int main()
{
cout<<"n=";

cin>>n;
cout<<"z=";
cin>>z;
for(i=1;i<=n;i++)
cin>>v[i];
if(found(1,n)==1)
cout<<"Yes";
else
cout<<"No";
return 0;
}
1. Consider a one-dimensional array v storing n
nonzero natural numbers (n≤100). Using the
Divide and Conquer method, determine how many
times the value x is present in the array.
Implementation:
#include <iostream>
using namespace std;
int v[100],n,i,z;
int numara_aparitii(int st,int dr)
{
int m,x,y;

if(st<dr)
{
m=(st+dr)/2;
x=numara_aparitii(st,m);
y=numara_aparitii(m+1,dr);
return x+y;
}
else if(z==v[st])
return 1;
else
return 0;
}
int main()
{
cout<<"n=";
cin>>n;
cout<<"z=";
cin>>z;
for(i=1;i<=n;i++)
cin>>v[i];
cout<<z<<" occurrs "<<numara_aparitii(1,n)<<"
times.";
return 0;

}
1. Consider a one-dimensional array v storing n
nonzero natural numbers (n≤100). Using the
Divide and Conquer method, display the
components of the array in reverse order.
Implementation:
#include <iostream>
using namespace std;
int v[100],n,i;
void vector_invers(int st,int dr)
{
int m,a,b;
if(st<dr)
{
m=(st+dr)/2;
vector_invers(m+1,dr);
vector_invers(st,m);
}
else
cout<<v[st]<<" ";
}
int main()

{
cout<<"n=";
cin>>n;
for(i=1;i<=n;i++)
cin>>v[i];
vector_invers(1,n);
return 0;
}
1. Consider a one-dimensional array v storing n
nonzero natural numbers (n≤100). Using the
Divide and Conquer method, determine whether
the array is sorted in ascending order.
Implementation:
#include <iostream>
using namespace std;
int v[100],n,i;
int vector_ordonat(int st,int dr)
{
int m,a,b;
if(st<dr)
{
m=(st+dr)/2;

a=vector_ordonat(st,m);
b=vector_ordonat(m+1,dr);
return a+b;
}
else if(v[st]<v[st+1])
return 1;
else return 0;
}
int main()
{
cout<<"n=";
cin>>n;
for(i=1;i<=n;i++)
cin>>v[i];
if(vector_ordonat(1,n)==n-1)
cout<<"Yes, it is ordered.";
else
cout<<"NOT Ordered.";
return 0;
}
1. Consider a one-dimensional array v storing n
nonzero natural numbers (n≤100). Display the

method of calculating their product using the
Divide and Conquer method.
Example: For n=5, v=(2,3,4,5,6), display
((2*3)*4)*(5*6) = 720.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int v[100],n,i,p,k;
int dei(int st,int dr,int &k)
{
int x,y,m;
k++;
if(st==dr)
{
cout<<v[st]<<" ";
return v[st];
}
else if(k>1)
{
m=(st+dr)/2;
cout<<"(";

x=dei(st,m,k);
cout<<"*";
y=dei(m+1,dr,k);
cout<<")";
return x*y;
}
else
{
m=(st+dr)/2;
x=dei(st,m,k);
cout<<"*";
y=dei(m+1,dr,k);
return x*y;
}
}
int main()
{
ifstream f("date.in");
f>>n;
for(i=1; i<=n; i++)
f>>v[i];
p=dei(1,n,k);
cout<<"="<<p;

return 0;
}
1. Consider a one-dimensional array v storing n
nonzero natural numbers (n≤100). We define
folding the array as the operation of overlapping
the two halves. If n is odd, the element in the
middle is eliminated. The obtained halves are
folded again until sequences of length 1, called
final elements, are reached. Display all possible
final elements.
Example: For v=(1,2,3,4,5,6,7), the final elements
will be 1, 3, 5, 7 as a result of the folding operations
represented in the diagram below:
(1, 2, 3, 4, 5, 6, 7)
(1, 2, 3)     (5, 6, 7)
(1)      (3)  (5)   (7)
Implementation:
#include <iostream>
using namespace std;

void divide_and_conquer(int v[], int start, int end)
{
if(start>end)
return;
int mid=(start+end)/2;
if((end-start+1)%2==1)
{
cout<<v[mid]<<" ";
divide_and_conquer(v,start,mid-1);
divide_and_conquer(v,mid+1, end);
}
else
{
divide_and_conquer(v,start,mid);
divide_and_conquer(v,mid+1,end);
}
}
int main()
{
int n;
cout<<"n=";cin>>n;
int v[101];
for(int i=0; i<n; i++)

cin>>v[i];
divide_and_conquer(v,0,n-1);
return 0;
}
1. Consider a one-dimensional array storing n
nonzero natural numbers (n≤100). Using the
Divide and Conquer method, calculate the value of
the following expressions:
a. v12 + v22 + ... + vn-12 + vn2
b. v1 · v2 + v2 · v3 + ... + vn-1 · vn
c. (v1 + v2) · (v2 + v3) · ... (vn-1 + vn)
d. v12 – v22 + v32 – v42 ... ± vn2.
Implementation:
#include <iostream>
using namespace std;
int v[100],n,i;
int suma1(int st,int dr)
{
int m,a,b;
if(st<dr)
{
m=(st+dr)/2;

a=suma1(st,m);
b=suma1(m+1,dr);
return a+b;
}
else return (v[st]*v[st]);
}
int suma2(int st,int dr)
{
int m,a,b;
if(st<dr)
{
m=(st+dr)/2;
a=suma2(st,m);
b=suma2(m+1,dr);
return a+b;
}
else return (v[st]*v[st+1]);
}
int suma3(int st,int dr)
{
int a,b,m;
if(st<dr)
{

m=(st+dr)/2;
a=suma3(st,m);
b=suma3(m+1,dr);
return a*b;
}
else return (v[st]+v[st+1]);
}
int suma4(int st,int dr)
{
int a,b,m;
if(st<dr)
{
m=(st+dr)/2;
a=suma4(st,m);
b=suma4(m+1,dr);
return a+b;
}
else if(st%2==1)
return v[st]*v[st];
else
return -v[st]*v[st];
}
int main()

{
cout<<"n=";
cin>>n;
for(i=1;i<=n;i++)
cin>>v[i];
cout<<suma1(1,n);
cout<<endl;
cout<<suma2(1,n);
cout<<endl;
cout<<suma3(1,n);
cout<<endl;
cout<<suma4(1,n);
return 0;
}
1. Write a program in which the computer
determines, in as few attempts as possible, a
natural number x that a user has in mind. The
value of x will be a number in the range [1, n],
where the value of n is read from the keyboard.
When the computer suggests a number, the user
will enter one of the characters: < if the number
chosen by the user is smaller than the number
suggested by the computer, > if the number
chosen by the user is larger than the number

suggested by the computer, = if the number has
been determined. Finally, the computer will display
the number of “attempts”.
Implementation:
#include <iostream>
using namespace std;
void Divide_et_Impera(int st,int dr)
{ 
int determine,attempts=0;
while(true)
{
determine=(st+dr)/2;
cout<<"Your number is "<<determine<<" ? (Click <, > or
= )";
char an;
cin>>an;
attempts++;
if(an=='<')
dr=attempts-1;
else if(an=='>')
st=attempts+1;
else if(an=='=')
{

cout<<"Attempts: "<<attempts<<endl;
break;
}
else cout<<"Invalid response. Choose <, > or =";
}
}
int main()
{
int n;
cout<<"n=";cin>>n;
cout<<"Think of a number between 1 and "<<n<<" and I
will try to guess it"<<endl;
Divide_et_Impera(1,n);
return 0;
}
1. Order a one-dimensional array using the following
methods:
a) Quick Sort
b) Merge Sort
Implementation:
Quicksort

#include <iostream>
using namespace std;
int v[1001], n;
///generate an array with random values in range [1,1000]
void generateVector()
{
cout<<"n=";
cin>>n;
for(int i=1; i<=n; i++)
v[i]=rand()%1000+1;
}
///——————————————-
void display()
{
for(int i=1; i<=n; i++)
cout<<v[i]<<" ";
cout<<endl;
}
///————————————
int pivot(int p, int u)
{ 
int piv=v[p],x;
while(p<u)

{
if(v[p]>v[u])
{
x=v[p];
v[p]=v[u];
v[u]=x;
}
if(piv==v[p])
u—;
else
p++;
}
return p;
}
///——————————————-
void QS(int p, int u)
{
if(p<u)
{
int k=pivot(p,u);
QS(p,k-1);
QS(k+1, u);
}

}
///——————————————-
int main()
{
srand(time(NULL));
generateVector();
display();
QS(1,n);
display();
return 0;
}
Merge-Sort is a “Divide and Conquer” algorithm
used to sort a list or an array of elements. The
fundamental idea of the algorithm is to divide the
input array into two subarrays, sort each subarray
separately, and then merge them to obtain the sorted
input array.
The algorithm operates as follows:
Divide the input array into two equal subarrays.
Recursively sort each subarray using the Merge-
Sort algorithm.
Merge the two sorted subarrays back into a single
sorted array.

This process continues until the subarrays are
small enough to be sorted or until a single element
is considered sorted.
The efficiency of this algorithm is O(n*log(n)), and it
is considered a stable sorting algorithm.
#include <iostream>
#include <time.h>
#include <stdlib.h>
using namespace std;
int a[1000],n;
void interclasare(int st,int dr)
{
int b[1000];
int m=(st+dr)/2;
int x=st,y=m+1,k=1;
while(x<=m && y<=dr)
if(a[x]<a[y])
b[k++]=a[x++];
else
b[k++]=a[y++];
while (x<=m)
b[k++]=a[x++];

while (y<=dr)
b[k++]=a[y++];
int t=st;
for(k=1;k<=(dr-st)+1;k++)
a[t++]=b[k];
}
void DI(int st,int dr)
{
int m=(st+dr)/2;
if(st<dr)
{
DI(st,m);
DI(m+1,dr);
interclasare(st,dr);
}
}
int main()
{
srand(time(NULL));
cout<<"n=";
cin>>n;
for(int i=1; i<=n; i++)
{

a[i]=rand()%1000;
cout<<a[i]<<" ";
}
cout<<endl;
DI(1,n);
cout<<"Array in ascending order!"<<endl;
for(int i=1;i<=n;i++)
cout<<a[i]<<" ";
return 0;
}
1. For the n students in a class (n≤30), their names
and exam grades are read. Using the Divide et
Impera method, perform the following processing
tasks:
a. Determine the number of students with grades
above 9.00.
b. Display the grade of a student whose name is read
from the keyboard.
c. Determine the class average.
d. Determine the highest and lowest class averages.
e. Sort the students in descending order based on
their grades.
Implementation:

#include <iostream>
#include <fstream>
#include <cstring>
using namespace std;
int n, i, ok;
struct student
{
char name[30];
float grade;
} v[100];
void readData()
{
ifstream f("data.in");
f >> n;
for (i = 1; i <= n; i++)
{
f.get();
f.get(v[i].name, 30);
f >> v[i].grade;
}
}
void displayData()
{

for (i = 1; i <= n; i++)
cout << "Student " << v[i].name << " with grade " <<
v[i].grade << endl;
}
int countStudents(int left, int right)
{
int mid, a, b;
if (left < right)
{
mid = (left + right) / 2;
a = countStudents(left, mid);
b = countStudents(mid + 1, right);
return a + b;
}
else if (v[left].grade > 9.0)
return 1;
else
return 0;
}
int position(int left, int right)
{
int p, u;
float pivot;

student temp;
p = left, u = right;
pivot = v[p].grade;
while (p < u)
{
if (v[p].grade < v[u].grade)
{
temp = v[p];
v[p] = v[u];
v[u] = temp;
}
if (v[p].grade == pivot)
u—;
else
p++;
}
return p;
}
void quickSort(int left, int right)
{
if (left < right)
{
int k = position(left, right);

quickSort(left, k - 1);
quickSort(k + 1, right);
}
}
void search(int left, int right, char name[30])
{
if (left < right)
{
int mid = (left + right) / 2;
search(left, mid, name);
search(mid + 1, right, name);
}
else if (stricmp(name, v[left].name) == 0)
{
cout << v[left].name << " has a grade of " <<
v[left].grade << endl;
ok = 1;
}
}
float classAverage(int left, int right)
{
float a, b;
if (left < right)

{
int mid = (left + right) / 2;
a = classAverage(left, mid);
b = classAverage(mid + 1, right);
return a + b;
}
else
return v[left].grade;
}
float maxGrade(int left, int right)
{
float a, b;
if (left < right)
{
int mid = (left + right) / 2;
a = maxGrade(left, mid);
b = maxGrade(mid + 1, right);
if (a > b)
return a;
else
return b;
}
else

return v[left].grade;
}
float minGrade(int left, int right)
{
float a, b;
if (left < right)
{
int mid = (left + right) / 2;
a = minGrade(left, mid);
b = minGrade(mid + 1, right);
if (a < b)
return a;
else
return b;
}
else
return v[left].grade;
}
int main()
{
readData();
displayData();
cout << endl;

cout << "The number of students with a grade above 9.00
is " << countStudents(1, n) << endl;
cout << endl;
quickSort(1, n);
cout << endl;
char name[30];
cout << "Enter the name of a student: ";
cin.get(name, 30);
search(1, n, name);
if (ok == 0)
cout << "The student is not found." << endl;
cout << endl;
cout << "The class average is " << classAverage(1, n) / n
<< endl;
cout << endl;
cout << "The maximum grade is " << maxGrade(1, n)
<< endl;
cout << endl;
cout << "The minimum grade is " << minGrade(1, n) <<
endl;
cout << endl;
cout << "SORTING STUDENTS IN DESCENDING ORDER BY
GRADE" << endl;

quickSort(1, n);
displayData();
return 0;
}
1. Determine the value of a polynomial at a point
using the Divide and Conquer method.
Implementation:
#include <iostream>
using namespace std;
// Evaluates the value of the given polynomial at a point
double Polynomial(int coefficients[101], int n, double x)
{
if(n==0)
return coefficients[0];
int mid=(n+1)/2;
int power=1;
for(int i=1; i<=mid; i++)
power*=x;
if(n%2==0)
return Polynomial(coefficients,mid-1,x)*power+
Polynomial(coefficients+mid,mid-1,x)*power+
coefficients[n];

else
return Polynomial(coefficients,mid-1,x)*power+
Polynomial(coefficients+mid,mid,x);
}
int main()
{
int n,coefficients[101];
cout<<"Polynomial degree: ";
cin>>n;
//Coefficients of the polynomial
for(int i=0; i<=n; i++)
{
cout<<"Enter the coefficient of x^"<<i<<": ";
cin>>coefficients[i];
}
double x;
cout<<"Value of x: ";
cin>>x;
double result=Polynomial(coefficients, n, x);
cout<<"The value of the polynomial at x = "<<x<<" is "
<<result;
return 0;
}

1. Determine the sum of two polynomials using the
Divide and Conquer method.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
void addPolynomials(int A[], int B[], int n, int C[])
{
if (n==1)
C[0]=A[0]+B[0];
else
{
int nBy2=n/2;
int *AL=new int[nBy2];
int *AR=new int[n-nBy2];
int *BL=new int[nBy2];
int *BR=new int[n-nBy2];
int *CL=new int[n];
int *CR=new int[n];
//divide the polynomials into halves
for(int i=0; i<nBy2; i++)
{

AL[i]=A[i];
BL[i]=B[i];
}
for(int i=nBy2; i<n; i++)
{
AR[i-nBy2]=A[i];
BR[i-nBy2]=B[i];
}
//first half
addPolynomials(AL,BL,nBy2,CL);
//second half
addPolynomials(AR,BR,n-nBy2,CR);
//combination of the halves
for(int i=0; i<nBy2; i++)
C[i]=CL[i];
for(int i=nBy2; i<n; i++)
C[i]=CR[i-nBy2];
//delete the arrays
delete[] AL;
delete[] AR;
delete[] BL;
delete[] BR;
delete[] CL;

delete[] CR;
}
}
int main()
{ 
ifstream f("date.in");
int A[101],B[101],C[101],m;
f>>m;
for(int i=0;i<m;i++)
f>>A[i];
for(int i=0;i<m;i++)
f>>B[i];
addPolynomials(A, B, m, C);
cout<<endl<<"The polynomial sum is: ";
for (int i=0; i<m; i++)
{
if(C[i]>0)
cout<<C[i]<<"*x^"<<i<<"+";
else if(C[i]==0)
cout<<C[i]<<"*x^"<<i<<"+";
else if(C[i]<0)
cout<<C[i]<<"*x^"<<i<<" ";
if(i==m-1)

cout<<C[i]<<"*x^"<<i<<" ";
}
return 0;
}
1. Determine whether a string is a palindrome using
the Divide and Conquer method.
Implementation:
#include <iostream>
#include <cstring>
using namespace std;
bool isPalindrome(char s[255], int st, int dr)
{
if (st>=dr)
return true;
//check the first and last character
if (s[st]!=s[dr])
return false;
//check substring without the 1st and last character
return isPalindrome(s,st+1,dr-1);
}
int main()
{ 

char s[255];
cout<<"String: ";
cin.get(s,255);
if(isPalindrome(s,0,strlen(s)-1))
cout<<"The string is palindrome.";
else
cout<<"NOT palindrome. ";
return 0;
}
1. Determine the value of n! (n factorial) using the
Divide and Conquer method.
Implementation:
#include <iostream>
using namespace std;
long long int factorial(int n)
{ 
if(n==0)
return 1;
return n*factorial(n-1);
}
int main()
{ 

int n;
cout<<"n=";cin>>n;
cout<<n<<"! is equal to: "<<factorial(n);
return 0;
}
1. The length and width of a rectangle are read. The
rectangle is cut perpendicular to the longer side in
half. Then the resulting rectangle is cut in half
along the longer side, and so on. Determine
whether, through successive cuts of the obtained
rectangles, it is possible to reach a square with a
side longer than a given real number x.
Example: for L=10, W=1.25, x=0.1, a square with
a side of 1.25 is obtained.
Implementation:
#include <iostream>
using namespace std;
bool getSquare(double Length, double Width, double x)
{
if(Length<x || Width<x)
return false;
if(Length==Width)

{
if (Length>x)
{
cout<<"the length of the square is: "<<Length<<endl;
return true;
}
}
if(Length>Width)
return getSquare(Length-Width,Width, x);
else
return getSquare(Length,Width-Length, x);
}
int main()
{ 
double L,l,x;
cout<<"Length: ";cin>>L;
cout<<"Width: ";cin>>l;
cout<<"x=";cin>>x;
bool res=getSquare(L,l,x);
if(!res)
cout<<"IMPOSIBLE.";
return 0;
}

1. Cutting Problem. Given a rectangular piece of
board with length L and height H, with n
negligible-diameter holes located at integer
coordinates (relative to the bottom-left corner of
the board). The task is to cut out a piece from the
board with the maximum possible area that does
not contain any holes. Only horizontal and vertical
cuts are allowed. Read the number of perforations,
their coordinates relative to the bottom-left corner
of the board, and the length and width of the
board.
Example: for the following data set
7
2 17
4 7
31 2
14 20
25 13
31 24

14 1
L=40 H=30
The largest non-perforated area has coordinates (4,1)
to (25,20). It has an area of 399.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int L, H, n, xst, yst, xdr, ydr;
int maxArea;
int x[21], y[21]; // Maximum of 20 holes
ifstream f("data.in");
void readInput()
{
f>>n;
for(int i=1; i<=n; i++)
f>>x[i]>>y[i];
f>>L>>H;
}
void findMaxRectangle(int x1, int y1, int x2, int y2)

{
int i, found = 0;
for (i = 1; i <= n && found == 0; i++)
{
if (x[i] > x1 && x[i] < x2 && y[i] > y1 && y[i] < y2 && !
(x1 == x[i] && y1 == y[i]))
{
findMaxRectangle(x1, y[i], x2, y2);
findMaxRectangle(x1, y1, x2, y[i]);
findMaxRectangle(x1, y1, x[i], y2);
findMaxRectangle(x[i], y1, x2, y2);
found = 1;
}
}
if (found == 0)
{
int currentArea = (x2 - x1) * (y2 - y1);
if (currentArea > maxArea)
{
maxArea = currentArea;
xst = x1;
yst = y1;
xdr = x2;

ydr = y2;
}
}
}
int main()
{
readInput();
findMaxRectangle(0, 0, L, H);
cout<<"The maximum area is: " << maxArea << endl;
cou <<"Coordinates of the rectangle with maximum area:
"
<< "(" << xst << "," << yst << ") and (" << xdr << ","
<< ydr << ")" << endl;
return 0;

CHAPTER 13 – GREEDY
TECHNIQUE
1. Consider a set of n real numbers (n≤100). A
subset is required, such that the sum of its
elements is maximum.
Example: n=7 and the numbers are -7.8, 7, -89, 3, -4,
10, -78.7, the subset obtained is: 7, 3, 10 with a sum
of 20.
Implementation:
#include <iostream>
#include <vector>
#include <fstream>
using namespace std;
int main()
{ 
ifstream f("data.in");
int n,k=0;
f>>n;
double a[101];
for (int i=1; i<=n; i++)
f>>a[i];
double suma=0;

double submultime[101];
for (int i=1; i<=n; i++) 
{
if (a[i]>=0)
{ 
k++;
suma+=a[i];
submultime[k]=a[i];
}
}
cout<<"The subset is: ";
for(int i=1;i<=k;i++)
cout<<submultime[i]<< " ";
cout<<endl<<"Maximum sum is: "<<suma<<endl;
return 0;
}
1. Consider two sets of integers A={a1,a2, ..., an} and
B={b1,b2, ..., bn}, where m≤n. Determine a subset
X={x1,x2,..., xn} of B in order to maximize the
value of the expression:
a1x1+a2x2+a3x3 + ... + amxm

Example: m=6, n=9,
A=(2,-2,1,-1, 3, 10)
B=(-2, 3, 4, -10, 1, 2, 3, 4, 5)
The subset that maximizes the expression is:
-2*(-10) + (-1)*(-2) + 1*3 + 2*4 + 3*4 + 10*5 = 95
Implementation:
#include <iostream>
#include <fstream>
#include <algorithm>
using namespace std;
int a[21],b[21],m,n;
int k;
void read()
{
ifstream f("data.in");
f>>m>>n;
for(int i=1; i<=m; i++)
{
f>>a[i];
cout<<a[i]<<" ";

if(a[i]<0)
k++;
}
cout<<endl;
for(int i=1; i<=n; i++)
{
f>>b[i];
cout<<b[i]<<" ";
}
}
void display(int v[21],int n)
{
for(int i=1;i<=n;i++)
cout<<v[i]<<" ";
cout<<endl;
}
int main()
{
read();
cout<<endl;
sort(a+1,a+m+1);
display(a,m);
sort(b+1,b+n+1);

display(b,n);
int s=0;
cout<<"s=";
for(int i=1;i<=k;i++)
{
s+=a[i]*b[i];
cout<<a[i]<<"*"<<b[i]<<" ";
}
k=m-k;
for(int i=1;i<=k;i++)
{
s+=a[m-k+i]*b[n-k+i];
cout<<a[m-k+i]<<"*"<<b[n-k+i]<<" ";
}
cout<<endl<<"Sum is:"<<s;
return 0;
}
1. A word is read from the keyboard. The word is
written in lowercase letters. Replace the letters
with the first natural numbers in such a way that
the total sum of the numbers corresponding to the
word is maximized. Different letters will have
different corresponding numbers.

Example: For the word titirez, a solution could be
4, 5, 4, 5, 3, 2, 1.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int v['z'+1],n;
char u[27];
void read()
{
char x;
ifstream f("data.in");
while (f>>x)
v[x]++;
}
void letters()
{
char x;
for(x='a'; x<='z'; x++)
if(v[x]>0)
{
n++;

u[n]=x;
}
}
void sortation()
{
char aux;
for(int i=1; i<=n-1; i++)
for(int j=i+1; j<=n; j++)
if(v[u[i]]>v[u[j]])
{
aux=u[i];
u[i]=u[j];
u[j]=aux;
}
int totalSum=0;
// Replace letters with their corresponding assigned values
and calculate the total sum
for(int i=1; i<=n; i++)
{
cout<<u[i]<<" occurs "<<v[u[i]]<<" times, associate
number "<<i<<endl;
totalSum+=i*v[u[i]];
}

cout<<"Total sum: "<<totalSum<<endl;
}
int main()
{
read();
letters();
sortation();
return 0;
}
1. Given a sequence of n points in the plane, connect
the given points pairwise to form a closed broken
line such that the total length of the sides is
maximized.
Implementation:
#include <bits/stdc++.h>
#include <iostream>
#include <fstream>
using namespace std;
struct Point
{
int x, y;
};

int n;
Point points[101],hull[101];
int crossProduct(Point A, Point B)
{
return A.x * B.y - A.y * B.x;
}
int orientation(Point p, Point q, Point r)
{
int val=crossProduct({q.x-p.x, q.y-p.y},
{r.x-q.x, r.y-q.y});
if (val==0)
return 0;
return (val>0) ? 1:2;
}
bool compare(Point p1, Point p2)
{
int o=orientation({0,0},p1,p2);
if (o==0)
return p1.x>p2.x;
return o==2;
}
int convexHull(Point points[], int n, Point hull[])
{

sort(points,points+n,compare);
int top=0;
for(int i=0; i<2; i++)
{
while(top>=2 && orientation(hull[top-2],points[i],
hull[top-1])!=2) 
top—;
hull[top++]=points[i];
}
for(int i=2; i<n; i++)
{
while (top>=2 && orientation(hull[top-2],points[i],
hull[top-1])!=2)
top—;
hull[top++]=points[i];
}
return top;
}
int main()
{ 
ifstream f("date.in");
f>>n;
for (int i=0; i<n; i++)

f>>points[i].x>>points[i].y;
int m=convexHull(points, n, hull);
double length=0;
for (int i=0; i<m-1; i++)
{
length+=sqrt(pow(hull[i].x-hull[i+1].x,2)+
pow(hull[i].y-hull[i+1].y,2));
}
length+=sqrt(pow(hull[m-1].x-hull[0].x,2)+
pow(hull[m-1].y-hull[0].y,2));
cout<<length<<endl;
return 0;
}
1. At an interview, n individuals (n≤20) are
presented. For each person, their name, the
number of specializations, and age are known.
Knowing that the company is hiring 3 individuals,
those individuals will be hired who have the
highest number of specializations and are younger.
Display their names.
Implementation:
#include <iostream>

#include <fstream>
#include <bits/stdc++.h>
using namespace std;
struct Person
{
string name;
int specializations;
int age;
};
int n;
Person people[1001];
bool compare(Person p1, Person p2)
{
if (p1.specializations==p2.specializations)
return p1.age<p2.age;
return p1.specializations>p2.specializations;
}
int main()
{ 
ifstream f("data.in");
f>>n;
for (int i = 0; i < n; i++)
{

f>>people[i].name;
f>>people[i].specializations;
f>>people[i].age;
}
sort(people, people+n, compare);
for (int i = 0; i < 3; i++)
cout<<people[i].name<<endl;
return 0;
1. In the file story.in, a text is written on multiple
lines. Display the first k lines that have the
minimum number of letters and the maximum
number of words. Words are separated by a single
space.
Implementation:
#include <iostream>
#include <fstream>
#include <bits/stdc++.h>
using namespace std;
struct Line
{
string text;
int numWords;

int numLetters;
};
int k;
Line lines[10000];
bool compare(Line l1, Line l2)
{
if (l1.numWords==l2.numWords)
return l1.numLetters<l2.numLetters;
return l1.numWords>l2.numWords;
}
int main()
{ 
ifstream f("story.in");
f>>k;
string line;
int lineIndex = 0;
while (getline(f, line))
{
int numWords=count(line.begin(),line.end(),' ')+1;
int numLetters=line.length();
lines[lineIndex].text=line;
lines[lineIndex].numWords=numWords;
lines[lineIndex].numLetters=numLetters;

lineIndex++;
}
sort(lines,lines+lineIndex,compare);
for(int i=0; i<k; i++)
cout<<lines[i].text<<endl;
return 0;
}
1. The Problem of Shows. In a theater, n shows
need to be scheduled in a day. For each show, the
interval during which it takes place is known (start
time: hi:mi - end time: ht:mt). The task is to
schedule a maximum number of shows without any
overlap.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
struct show
{
int x,y;
char name[100];
int h1,m1,h2,m2;

} v[101];
int n;
///—————————————
void read()
{
char c;
ifstream f("data.in");
f>>n;
for(int i=1; i<=n; i++)
{
f>>v[i].h1;
f>>c;
f>>v[i].m1;
f>>v[i].h2;
f>>c;
f>>v[i].m2;
f>>v[i].name;
v[i].x=60*v[i].h1+v[i].m1;
v[i].y=60*v[i].h2+v[i].m2;
}
}
///———————————————-
void order()

{
show a;
int i,j;
for(i=1; i<=n-1; i++)
for(j=i+1; j<=n; j++)
if(v[i].y>v[j].y)
{
a=v[i];
v[i]=v[j];
v[j]=a;
}
}
///—————————————————
void greedy ()
{
int u=v[1].y;
cout<<v[1].name<<" "<<v[1].h1<<":"<<v[1].m1<<"-"
<<v[1].h2<<":"<<v[1].m2;
cout<<endl;
for (int i=2; i<=n; i++)
if(v[i].x>=u)
{

cout<<v[i].name<<" "<<v[i].h1<<":"<<v[i].m1<<"-"
<<v[i].h2<<":"<<v[i].m2;
cout<<endl;
u=v[i].y;
}
}
///————————————————
int main()
{
read();
order();
greedy();
return 0;
}
1. The Knapsack Problem. A person has a
backpack that can carry a maximum weight of G.
The person has n (n≤30) objects at their disposal,
and for each object, they know its name, weight,
and the value obtained from transporting it to the
destination. The task is to determine which objects
the person should carry to maximize their gain.
Implementation:
#include <iostream>

#include <fstream>
using namespace std;
const int MAX_N=31;
struct Item
{
string name;
int weight;
int value;
};
int n,G;
Item items[MAX_N];
void readData()
{
ifstream fin("data.in");
fin>>n>>G;
for(int i=0; i<n; i++)
fin>>items[i].name>>items[i].weight>>items[i].value;
fin.close();
}
void computeValue()
{
int value=0;
int weight=0;

for(int i=0; i<n; i++)
{
if (weight+items[i].weight<=G)
{ 
cout<<items[i].name<<" "<<items[i].weight<<endl;
value+=items[i].value;
weight+=items[i].weight;
}
}
cout<<"Total value: "<<value<<endl;
}
int main()
{
readData();
computeValue();
return 0;
}
1. At a sports competition, n (n≤30) athletes have
participated. For each athlete, their name and the
score obtained are known. Display the top 6
athletes (having the highest scores). In case there
are multiple athletes with the same score, display
them in alphabetical order.

Implementation:
#include <fstream>
#include <bits/stdc++.h>
using namespace std;
struct athlete
{
string name;
int score;
};
bool compareAthletes(athlete a, athlete b)
{
if (a.score!=b.score)
return a.score>b.score;
return a.name<b.name;
}
int main()
{ 
ifstream f("data.in");
int n;
f>>n;
athlete athletes[n];
for(int i=0; i<n; i++)

f>>athletes[i].name>>athletes[i].score;
sort(athletes,athletes+n,compareAthletes);
cout<<"The first 6 athletes are: "<<endl;
for (int i = 0; i < 6 && i < n; i++)
cout<<athletes[i].name<<" "<<athletes[i].score<<endl;
return 0;
}
1. Given a sequence of n (n≤100) natural numbers,
determine a maximum group of numbers from the
sequence with the property that they are prime
numbers, and their sum is at most M.
Implementation:
#include <iostream>
#include <cmath>
#include <algorithm>
#include <fstream>
using namespace std;
bool isPrime(int num)
{
if(num==2)
return true;
if(num%2==0 || num <2)

return false;
for(int i=3;i<=sqrt(num);i++)
if(num%i==0)
return false;
return true;
}
int main()
{ 
ifstream f("data.in");
int n,m,k=0;
f>>n>>m;
int a[n],prime[n];
for(int i=0; i<n; i++)
f>>a[i];
sort(a, a+n, greater<int>());
int sum=0;
for(int i=0; i<n; i++)
{
if (sum+a[i]<=m && isPrime(a[i]))
{ 
k++;
sum+=a[i];
prime[k]=a[i];

}
}
cout<<"The primes are: ";
for (int i=1; i<=k; i++)
cout<<prime[i]<<" ";
cout<<endl;
cout<<"The sum is: "<<sum<<endl;
return 0;
}
1. The problem of paying an amount. Consider n
(n≤30) types of coins with values o1, o2, ..., on.
Use the minimum number of coins to pay the sum
S.
Implementation:
#include <fstream>
#include <bits/stdc++.h>
using namespace std;
ifstream f("date.in");
const int N=101;
int n,s,a[N];
int main()
{

f>>n>>s;
for(int i=0; i<n; i++)
f>>a[i];
sort(a, a+n, greater<int>());
int cnt=0,sum=0;
for (int i=0; i<n; i++)
{
while (sum+a[i]<=s)
{
sum+=a[i];
cnt++;
cout<<"The value of the coin used: "<<a[i]<<endl;
}
}
cout<<"Minimum number of coins: "<<cnt<<endl;
return 0;
}
1. The balloon problem. Given n (n≤30) round
balloons (for each balloon, the coordinates of its
center and its radius are known) that move
vertically. It is required to choose as many of them
as possible in a way that they do not collide with
each other.

Implementation:
#include <iostream>
#include <fstream>
using namespace std;
struct balloon
{
int x,y;
int d,R;
} v[100];
int n;
void readData()
{
ifstream f("data.in");
int i;
f>>n;
for(i=1; i<=n; i++)
{
f>>v[i].d>>v[i].R;
v[i].x=v[i].d-v[i].R;
v[i].y=v[i].d+v[i].R;
}
f.close();

}
void order()
{
int i,j;
balloon aux;
for(i=1; i<n; i++)
for(j=i+1; j<=n; j++)
if(v[i].y>v[j].y)
{
aux=v[i];
v[i]=v[j];
v[j]=aux;
}
}
void greedy()
{
int i,u;
u=v[1].y;
cout<<"Balloon with Radius "<<v[1].R<<" at distance "
<<v[1].d<<endl;
for(i=2; i<=n; i++)
{
if(v[i].x>=u)

{
cout<<"Balloon with Radius "<<v[i].R<<" at distance "
<<v[i].d<<endl;
u=v[i].y;
}
}
}
int main()
{
readData();
order();
greedy();
return 0;
}

CHAPTER 14 – DYNAMIC
PROGRAMMING
1. Consider a sequence of n (n≤1000) integers, each
with at most 4 digits.
a. Determine the length of the longest increasing
subsequence of values in the sequence, not
necessarily consecutive, but maintaining the order
from the original sequence.
b. Display the increasing subsequence.
c. How many such subsequences of maximum length
exist?
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
const int N=1001;
int n,dp[N],parent[N],a[N];
int lis()
{
int length=0;
for (int i=0; i<n; i++)
{

dp[i]=1;
parent[i]=-1;
for (int j=0; j<i; j++)
{
if (a[j]<a[i] && dp[j]+1>dp[i])
{
dp[i]=dp[j]+1;
parent[i]=j;
}
}
length=max(length, dp[i]);
}
return length;
}
void printLIS(int id)
{
if (parent[id]==-1)
{
cout<<a[id]<<" ";
return;
}
printLIS(parent[id]);
cout<<a[id]<<" ";

}
int countLIS()
{
int length=lis();
int cnt=0;
for (int i=0; i<n; i++)
{
if (dp[i]==length)
cnt++;
}
return cnt;
}
int main()
{ 
ifstream f("data.in");
f>>n;
for(int i=0; i<n; i++)
f>>a[i];
int length = lis();
cout<<"Longest length: "<<length<<endl;
cout<<"Increasing sequence: ";
for(int i=0; i<n; i++)
{

if(dp[i]==length)
{
printLIS(i);
break;
}
}
cout<<endl;
int cnt=countLIS();
cout<<"Number of subsequences: "<<cnt<<endl;
return 0;
}
1. Financial Analysis. Daniel has set out to conduct
a profit analysis of his company over a period of n
days. For each of the n consecutive days, he notes
the recorded profit. Daniel wants to determine if
the company has made financial progress and
during which periods. He considers financial
progress to be a number Q of days out of the
initially established n days, not necessarily
consecutive, for which the recorded profit is
greater than a previously recorded profit. Daniel
wants to determine the maximum value recorded
for Q over the n days. After a closer analysis,

Daniel noticed that there are several periods that
determine a maximum value for Q.
Task
Knowing the financial profit value for each of the n
days (in chronological order), help Daniel determine
the maximum value of financial progress, Q, and the
number of periods, np, that could determine this
value.
Input
The input file, company.in contains on the first line
a natural number n representing the number of days
for which the financial analysis is performed. On the
second line, there are n distinct natural numbers pfi
(1≤i≤n), each representing the profit for day i.
Numbers are separated by a space.
Output
The output file, company.out will contain on a single
line two numbers separated by a space representing
the maximum value of financial progress and the
number of periods that determine this value.
Note

The values for financial progress are considered to
be stored in the company.in file in chronological order.
Constraints
0<n≤100 (natural number)
0<pfi≤10000 (natural number)
Example:
company.in company.out
explanation
11
10 15 3
16 18
20 4 5 11
1 2
5 1
There are multiple periods of
financial progress:
10 15 16 18 20,
3 16 18 20,
3 4 5 11,
1 2 etc.
The maximum value Q of
financial progress is
determined by a period of 5
days. There is only one

period of 5 days of financial
progress.
12
10
15
3
16
18
20 4 5 11
12 1
2
5 2
There are multiple periods of
financial progress:
10 15 16 18 20,
3 16 18 20,
3 4 5 11 12
1 2 etc.
The maximum value Q of
financial progress is
determined by a period of 5
days. There is only one
period of 5 days of financial
progress.
Implementation:
#include <iostream>
#include <fstream>

using namespace std;
const int N=10001;
int n,dp[N],a[N];
int lis()
{
int length=0;
for (int i=0; i<n; i++)
{
dp[i]=1;
for (int j=0; j<i; j++)
{
if (a[j]<a[i] && dp[j]+1>dp[i])
{
dp[i]=dp[j]+1;
}
}
length=max(length, dp[i]);
}
return length;
}
int countLIS()
{
int length=lis();

int cnt=0;
for (int i=0; i<n; i++)
{
if (dp[i]==length)
cnt++;
}
return cnt;
}
int main()
{ 
ifstream f("data.in");
f>>n;
for(int i=0; i<n; i++)
f>>a[i];
int length = lis();
cout<<" Q: "<<length<<endl;
cout<<" np: "<<countLIS()<<endl;
return 0;
}
1. Consider a triangle of natural numbers consisting
of n rows (n≤50). The first row contains one
element, the second row two elements, and the n-
th row n elements. Using this triangle, sums of n

natural numbers can be formed, with one number
selected from each row, so that for the element on
row i and column j, its successor can be found in
column j or j+1 of the next row.
a. What is the largest sum that can be formed?
b. What are the values that determine this sum?
Example: For this triangle:
2
3 5
6 3 4
5 6 1 4
The maximum sum is 2+3+6+6=17.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
const int N=110;
int a[N][N],matr[N][N],sol[N][N];
int n;
int dp(int i, int j)
{
if(matr[i][j]!=-1)

return matr[i][j];
if(i==n)
return matr[i][j]=a[i][j];
return matr[i][j]=a[i][j]+max(dp(i+1,j),dp(i+1,j+1));
}
void print_path(int i, int j)
{
cout<<a[i][j]<<"+";
if(i==n)
return;
if(dp(i+1,j)>dp(i+1,j+1))
print_path(i+1,j);
else
print_path(i+1,j+1);
}
int main()
{ 
ifstream f("data.in");
f>>n;
for(int i=1;i<=n;i++)
for(int j=1;j<=i;j++)
{
f>>a[i][j];

matr[i][j]=-1;
}
print_path(1,1);
cout<<"="<<dp(1,1)<<endl;
return 0;
}
1. The same problem (as the previous one), with the
difference that instead of a triangle, a square
matrix is processed.
Example: For the following matrix:
1 2 3 4
2 3 4 1
4 5 6 1
2 3 4 6 the maximum sum is 19, and the values: 3
4 6 6
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
const int N=110;
int a[N][N],matr[N][N],sol[N][N];

int n;
int dp(int i, int j)
{
if(matr[i][j]!=-1)
return matr[i][j];
if(i==n)
return matr[i][j]=a[i][j];
return matr[i][j]=a[i][j]+max(dp(i+1,j),dp(i+1,j+1));
}
void print_path(int i, int j)
{
cout<<a[i][j]<<"+";
if(i==n)
return;
if(dp(i+1,j)>dp(i+1,j+1))
print_path(i+1,j);
else
print_path(i+1,j+1);
}
int main()
{ 
ifstream f("date.in");
f>>n;

for(int i=1;i<=n;i++)
for(int j=1;j<=n;j++)
{
f>>a[i][j];
matr[i][j]=-1;
}
print_path(1,1);
cout<<"="<<dp(1,1)<<endl;
return 0;
}
1. The same problem (as the previous one), with the
difference that the element on the next row can be
below, to the left, or to the right.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
const int N=110;
int a[N][N], matr[N][N];
int maxSum, maxSumRowIndex;
int n;
int dp(int i, int j)

{
if(matr[i][j]!=-1)
return matr[i][j];
if(i==n)
return matr[i][j]=a[i][j];
int left=dp(i+1,j);
int right=dp(i+1,j+1);
int below=dp(i+1,j-1);
return matr[i][j]=a[i][j]+max(left,max(right, below));
}
void findMaxSumRowIndex(int i, int j)
{
if(i==n)
return;
int left=dp(i+1,j);
int right=dp(i+1,j+1);
int below=dp(i+1,j-1);
if(max(left,max(right,below))==left)
findMaxSumRowIndex(i+1,j);
else if(max(left,max(right,below))==right)
findMaxSumRowIndex(i+1,j+1);
else
findMaxSumRowIndex(i+1,j-1);

}
int main()
{
ifstream f("data.in");
f>>n;
for(int i=1; i<=n; i++)
for(int j=1; j<=i; j++)
{
f>>a[i][j];
matr[i][j]=-1;
}
maxSum=dp(1,1);
findMaxSumRowIndex(1,1);
cout<<"a) The largest sum that can be formed is: "
<<maxSum<<endl;
cout<<"b) The values that determine this sum are: ";
print_path(1, maxSumRowIndex);
cout<<endl;
return 0;
}
1. In a rectangular-shaped labyrinth with m rows and
n columns (m, n ≤ 50), the walls are marked with
1, and the corridors with 0. The initial coordinates

(Li, Ci) in the labyrinth and the final coordinates
(Lf, Cf) are known. In the labyrinth, one can only
move in the directions E (East), W (West), N
(North), and S (South) along adjacent cells. What is
the length of the shortest path? The data is read
from the file labyrinth.in.
Example: For the text file:
5 6
1 1 0 1 1 1
1 0 0 0 0 1
1 0 1 1 0 1
1 0 0 0 0 1
1 1 1 1 1 1
4 2
1 3, the length of the shortest path is 5.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int m, n;
int a[51][51];
bool visited[51][51];

int dist[51][51];
struct Node
{
int x, y;
};
int dx[]={-1, 0, 1, 0};
int dy[]={0, 1, 0, -1};
bool isValid(int x, int y)
{
if (x>=1 && x<=m && y>=1 && y<=n && a[x][y]==0
&& !visited[x][y])
return true;
return false;
}
int bfs(int sx, int sy, int ex, int ey)
{
Node start, end;
start.x=sx;
start.y=sy;
end.x=ex;
end.y=ey;
for (int i=1; i<=m; i++)
for (int j=1; j<=n; j++)

dist[i][j]=-1;
dist[sx][sy]=0;
Node queue[2601];
int head=0,tail=0;
queue[tail++]=start;
while (head<tail)
{
Node u=queue[head++];
for (int i = 0; i < 4; i++)
{
int nx=u.x+dx[i];
int ny=u.y+dy[i];
if (isValid(nx, ny))
{
Node v;
v.x=nx;
v.y=ny;
queue[tail++]=v;
visited[nx][ny]=true;
dist[nx][ny]=dist[u.x][u.y]+1;
}
}
}

return dist[ex][ey]+1;
}
int main()
{
ifstream f("data.in");
f>>m>>n;
for (int i=1; i<=m; i++)
for (int j=1; j<=n; j++)
f>>a[i][j];
int Li,Ci,Lf,Cf;
f>>Li>>Ci>>Lf>>Cf;
cout<<"Max length is: "<<bfs(Li,Ci,Lf,Cf);
return 0;
}
1. The same problem as problem 812, with the
difference that one can advance according to the
knight's move (from the chess piece).
Implementation:
#include <iostream>
#include <fstream>
#include <cmath>
using namespace std;

const int dx[8]={-2,-2,-1,-1,1,1,2,2};
const int dy[8]={-1,1,-2,2,-2,2,-1,1};
int m,n,Li,Ci,Lf,Cf;
int a[51][51];
bool vis[51][51];
struct node
{
int x,y,step;
};
bool check(int x, int y)
{
if (x>=1 && x<=m && y>=1 && y<=n && a[x][y]==0
&& !vis[x][y])
return true;
return false;
}
int BFS(int Li,int Ci,int Lf,int Cf)
{
node q[51*51];
int l=0,r=0;
node temp, next;
temp.x=Li;
temp.y=Ci;

temp.step=0;
q[r++]=temp;
vis[Li][Ci]=true;
while (l<r)
{
temp=q[l++];
if (temp.x==Lf && temp.y==Cf)
return temp.step;
for (int i = 0; i < 8; i++)
{
int nx=temp.x+dx[i];
int ny=temp.y+dy[i];
if (check(nx, ny))
{
next.x=nx;
next.y=ny;
next.step=temp.step+1;
q[r++]=next;
vis[nx][ny]=true;
}
}
}
return -1;

}
int main()
{
ifstream f("data.in");
f>>m>>n;
for (int i=1; i<=m; i++)
for (int j=1; j<=n; j++)
{
f>>a[i][j];
vis[i][j]=false;
}
int Li,Ci,Lf,Cf;
f>>Li>>Ci>>Lf>>Cf;
int result=BFS(Li,Ci,Lf,Cf);
if(result==-1)
cout<<"There’s no path from start to finish"<<endl;
else
cout<<"Max length is: "<<result<<endl;
return 0;
}
1. In a rectangular-shaped labyrinth with m rows and
n columns (m, n ≤ 50), walls are marked with 1,

and corridors with 0. The initial coordinates in the
labyrinth for two individuals are known: L1, C1,
and L2, C2. At each moment, both individuals
advance one cell simultaneously and follow the
shortest path until they meet. It is considered that
individuals have met when they are in the same
cell or in adjacent cells. In the labyrinth, one can
only move in the directions E (East), W (West), N
(North), and S (South) along adjacent cells. The
data is read from the file labyrinth.in.
a. What is the length of the shortest path?
b. Where do the two individuals meet?
c. Reconstruct the path for the two individuals.
Example: For a file with the content:
5 6
1 1 0 1 1 1
1 0 0 0 0 1
1 0 1 1 0 1
1 0 0 0 0 1
1 1 1 1 1 1
4 2
1 3

The shortest path length is 2 (for each person).
They meet in cell 2,2. The first person follows the path:
4-2, 3-2, 2-2. The second person follows the path: 1-3,
2-3, 2-2.
Implementation:
#include <iostream>
#include <fstream>
#include <vector>
#include <queue>
#include <algorithm>
using namespace std;
const int INF = 1e9;
// Define directions: North, South, East, West
const int dx[] = {-1, 1, 0, 0};
const int dy[] = {0, 0, 1, -1};
// Function to check if a cell is valid
bool isValid(int x, int y, int m, int n) {
return x >= 1 && x <= m && y >= 1 && y <= n;
}
// Function to find the shortest path using BFS
int shortestPath(vector<vector<int>>& labyrinth, int
startX, int startY, int endX, int endY) {
int m=labyrinth.size();

int n=labyrinth[0].size();
vector<vector<int>> dist(m+1, vector<int>(n+1, INF));
queue<pair<int, int>> q;
dist[startX][startY]=0;
q.push({startX, startY});
while(!q.empty()) {
int x=q.front().first;
int y=q.front().second;
q.pop();
for(int i=0; i<4; ++i) {
int nx=x+dx[i];
int ny=y+dy[i];
if (isValid(nx,ny,m,n) && labyrinth[nx][ny]==0 &&
dist[nx][ny]==INF) {
dist[nx][ny]=dist[x][y]+1;
q.push({nx, ny});
}
}
}
return dist[endX][endY];
}
// Function to reconstruct the path

vector<pair<int, int>>
reconstructPath(vector<vector<int>>& labyrinth, int startX,
int startY, int endX, int endY) {
int m = labyrinth.size();
int n = labyrinth[0].size();
vector<vector<int>> dist(m + 1, vector<int>(n + 1,
INF));
vector<vector<pair<int, int>>> parent(m + 1,
vector<pair<int, int>>(n + 1, {-1, -1}));
queue<pair<int, int>> q;
dist[startX][startY] = 0;
q.push({startX, startY});
while (!q.empty()) {
int x = q.front().first;
int y = q.front().second;
q.pop();
for (int i = 0; i < 4; ++i) {
int nx = x + dx[i];
int ny = y + dy[i];
if (isValid(nx, ny, m, n) && labyrinth[nx][ny] == 0 &&
dist[nx][ny] == INF) {
dist[nx][ny] = dist[x][y] + 1;
parent[nx][ny] = {x, y};

q.push({nx, ny});
}
}
}
// Reconstruct path
vector<pair<int, int>> path;
int cx = endX, cy = endY;
while (cx != -1 && cy != -1) {
path.push_back({cx, cy});
int px = parent[cx][cy].first;
int py = parent[cx][cy].second;
cx = px;
cy = py;
}
reverse(path.begin(), path.end());
return path;
}
int main() {
ifstream infile("labyrinth.in");
int m, n;
infile >> m >> n;
vector<vector<int>> labyrinth(m + 1, vector<int>(n +
1));

for (int i = 1; i <= m; ++i) {
for (int j = 1; j <= n; ++j) {
infile >> labyrinth[i][j];
}
}
int startX1, startY1, startX2, startY2;
infile >> startX1 >> startY1 >> startX2 >> startY2;
int endX1 = 2, endY1 = 2, endX2 = 2, endY2 = 2;
int shortestPath1 = shortestPath(labyrinth, startX1,
startY1, endX1, endY1);
int shortestPath2 = shortestPath(labyrinth, startX2,
startY2, endX2, endY2);
cout << "a) The shortest path length is: " <<
shortestPath1 << " (for each person)." << endl;
if (shortestPath1 == shortestPath2) {
cout << "b) They meet in cell " << endX1 << "," <<
endY1 << "." << endl;
cout << "c) The first person follows the path: ";
auto path1 = reconstructPath(labyrinth, startX1, startY1,
endX1, endY1);
for (auto p : path1) {
cout << p.first << "-" << p.second << ", ";
}

cout << endl;
cout << "  The second person follows the path: ";
auto path2 = reconstructPath(labyrinth, startX2, startY2,
endX2, endY2);
for (auto p : path2) {
cout << p.first << "-" << p.second << ", ";
}
cout << endl;
} else
cout << "b) They do not meet." << endl;
infile.close();
return 0;
}
1. Consider a sentence formed from the lowercase
letters of the English alphabet. Spaces between
words have been removed from the sentence.
Given a dictionary of words, the task is to
reconstruct the sentence using a minimal number
of words (if a word appears multiple times in the
sentence, it should be counted each time). From
the file phrase.in read the number n of words from
the first line, followed by the next n lines
containing n (n≤100) words as strings consisting
of a maximum of 20 characters from the English

alphabet. Finally, read a line with a string of up to
2000 characters representing the sentence.
Display the requested data in the phrase.out file.
Example:
Fraza.in
Fraza.out
6
ana
anne
are
apples
mere
has
pears
many
10
annehasapples
Implementation:
#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>
using namespace std;
const int INF = 1e9;

pair<int, vector<string>> minWordsToReconstruct(const
vector<string>& words, const string& sentence) {
int n=sentence.size();
vector<int>dp(n+1,INF);
dp[0]=0;
for(int i=1; i<=n; ++i) {
for(const string& word : words) {
int len=word.size();
if(i>=len && sentence.substr(i - len, len) == word) {
dp[i] = min(dp[i], dp[i - len] + 1);
}
}
}
int minWords = dp[n];
vector<string> reconstructedWords;
if (minWords != INF) {
int i = n;
while (i > 0) {
for (const string& word : words) {
int len = word.size();
if (i >= len && sentence.substr(i - len, len) == word &&
dp[i - len] == dp[i] - 1) {
reconstructedWords.push_back(word);

i -= len;
break;
}
}
}
reverse(reconstructedWords.begin(),
reconstructedWords.end());
}
return {minWords, reconstructedWords};
}
int main() {
ifstream input("phrase.in");
ofstream output("phrase.out");
int n;
input >> n;
vector<string> words(n);
for (int i = 0; i < n; ++i) {
input >> words[i];
}
string sentence;
input.ignore(); // Ignore newline
getline(input, sentence);
auto result = minWordsToReconstruct(words, sentence);

output<<result.first<<endl;
if (result.first != INF) {
for (const string& word : result.second) {
output << word << " ";
}
output << endl;
}
input.close();
output.close();
return 0;
}
1. In the file data.in, read from the first line a number
n (n≤100), followed by n words, each consisting
of a maximum of 20 characters from the English
alphabet. Determine the longest sequence of
words that has the property that each word in the
sequence, except the first one, begins with the
letter with which the previous word ends, and the
words in the determined sequence are in the same
order as they are in the original sequence.
Example: n=12
abecedar radio orb rata binoclu adi ancora barza
icre sanie elefant turban

The solution is:
abecedar rata adi icre elefant turban.
Implementation:
#include <bits/stdc++.h>
#include <fstream>
using namespace std;
int n;
string cuvinte[105];
int dp[105];
int maxi, pozitie;
int main()
{
ifstream f("data.in");
f>>n;
for (int i=0; i<n; i++)
f>>cuvinte[i];
for (int i=0; i<n; i++)
{
dp[i]=1;
for (int j=0; j<i; j++)
if(cuvinte[j][cuvinte[j].size()-1]==cuvinte[i][0])
dp[i]=max(dp[i],dp[j]+1);

if (dp[i]>maxi)
{
maxi=dp[i];
pozitie=i;
}
}
cout<<maxi<<endl;
vector<string>solutie;
while(pozitie!=-1)
{
solutie.push_back(cuvinte[pozitie]);
int temp=-1;
for(int i=0; i<pozitie; i++)
if(cuvinte[i][cuvinte[i].size()-1]==cuvinte[pozitie][0] &&
dp[i]==dp[pozitie]-1)
{
temp=i;
break;
}
pozitie=temp;
}
reverse(solutie.begin(), solutie.end());
for(int i=0; i<solutie.size(); i++)

cout<<solutie[i]<<" ";
return 0;
}
1. Determine the length of the longest common
subsequence of two strings. The elements of the
determined subsequence are in the same order as
they were in the original strings.
Example: For the strings:
B D C A B A
A B C B D A B
It is generated: B C B A.
Implementation:
#include <iostream>
#include <cstring>
#include <fstream>
using namespace std;
int m, n;
char sir1[100];
char sir2[100];
int dp[100][100];

int LCS(int i, int j)
{
if (i==0 || j==0)
return 0;
if (dp[i][j]!=-1)
return dp[i][j];
if (sir1[i-1]==sir2[j-1])
dp[i][j]=LCS(i-1,j-1)+1;
else
dp[i][j]=max(LCS(i-1,j),LCS(i,j-1));
return dp[i][j];
}
void displayDataLCS(string X, string Y, int m, int n, int
L[100][100])
{
int index=L[m][n];
char lcs[index+1];
lcs[index] = '\0';
int i=m, j=n;
while (i>0 && j>0)
{
if (X[i-1]==Y[j-1])
{

lcs[index-1]=X[i-1];
i—;
j—;
index—;
}
else if (L[i-1][j]>L[i][j-1])
i—;
else
j—;
}
cout<<"Substring of max length: "<<lcs<<endl;
}
int main()
{ 
ifstream f("data.in");
f>>sir1>>sir2;
m=strlen(sir1);
n=strlen(sir2);
memset(dp, -1, sizeof(dp));
cout<<"The max length of the substring: "<<LCS(m,n)
<<endl;
displayDataLCS(sir1,sir2,m,n,dp);
return 0;

}
1. Password. Andrew and Daniel are passionate
about computer science. They have even learned
web design. Andrew creates the graphics, and
Daniel researches the backend. They are so excited
about their first website that they want to post it
on the internet. They have even created an
administration section so that the site can be
updated more easily by either of them. However,
each of them has a specific preference regarding
the password, and as a small dispute cannot harm
a great friendship, the two friends have found the
following solution: to compare the two passwords
and generate a new password of the maximum
possible length that contains all the common
characters from the two initial passwords, in the
exact same order, but not necessarily
consecutively.
Input: The first line of the pass.in file contains two
natural numbers, M and N (2≤M≤150 and
2≤N≤150). The next two lines contain M and N
alphanumeric characters representing the two
passwords.

Output: The first line of the pass.out file will
contain a natural number representing the number of
characters in the generated password, and the next
line will contain the password.
Notes: If it is not possible to generate a password
that meets all the conditions in the statement, the
pass.out file should display 0. If there are multiple
solutions of maximum length, one of them will be
displayed in the pass.out file.
Example:
pass.in     pass.out
MNMZUVZ12347aaabbbbuuu6AaaaBccc   5
Z99N555dd7rrr6iiiiiiiAB1    N76AB
Explanation: The exemple has 2 solutions: N76AB
and Z76AB, but only one has been displayed.
Implementation:
#include <iostream>
#include <cstring>
#include <fstream>
using namespace std;
int m, n;

char sir1[150];
char sir2[150];
int dp[150][150];
ifstream f("pass.in");
ofstream g("pass.out");
int LCS(int i, int j)
{
if (i==0 || j==0)
return 0;
if (dp[i][j]!=-1)
return dp[i][j];
if (sir1[i-1]==sir2[j-1])
dp[i][j]=LCS(i-1,j-1)+1;
else
dp[i][j]=max(LCS(i-1,j),LCS(i,j-1));
return dp[i][j];
}
void displayDataLCS(string X, string Y, int m, int n, int
L[100][100])
{
int index=L[m][n];
char lcs[index+1];
lcs[index] = '\0';

int i=m, j=n;
while (i>0 && j>0)
{
if (X[i-1]==Y[j-1])
{
lcs[index-1]=X[i-1];
i—;
j—;
index—;
}
else if (L[i-1][j]>L[i][j-1])
i—;
else
j—;
}
g<<"The substring with max length: "<<lcs<<endl;
}
int main()
{ 
f>>sir1>>sir2;
m=strlen(sir1);
n=strlen(sir2);
memset(dp, -1, sizeof(dp));

g<<"Length of substring: "<<LCS(m,n)<<endl;
displayDataLCS(sir1,sir2,m,n,dp);
return 0;
}
1. A mountaineer is in a mountainous region encoded
as a square matrix of size n×n, where each
element of the matrix represents the altitude of the
corresponding terrain. The mountaineer can start
the trail from any point in the region (any element
of the matrix) and can finish the trail anywhere.
They can move in any of the directions {N, S, E,
W} as long as they do not leave the region.
Additionally, they must always ascend, meaning
the altitude of the current region must be strictly
less than the altitude of the next region on the
trail. The first line of the input file alpin.in contains
the number n, the size of the region. The next n
lines each contain n positive integers separated by
exactly one space, describing the matrix encoding
of the region. Determine the longest trail the
mountaineer can take. The first line of the output
file alpin.out contains LMAX, the maximum length
of the trail traversed. The following LMAX lines
describe the trail taken through its squares, in
order from the first to the last, inclusive.

Example:
alpin.in    alpin.out
6    16
29 10 8 9 8 10   4 3
22 11 7 3 7 20   3 3
17 15 3 14 45 30   2 3
19 5 2 41 19 17   1 3
23 8 90 39 20 18   1 2
27 30 32 35 70 19   2 2
3 2
3 1
4 1
5 1
6 1
6 2
6 3
6 4
5 4
5 3

Implementation:
#include <iostream>
#include <vector>
#include <fstream>
using namespace std;
// Function to find the longest ascending trail starting from
a given position
int findLongestTrail(vector<vector<int>>& matrix,
vector<vector<int>>& dp, int i, int j, int n) {
if (dp[i][j] != -1) {
return dp[i][j];
}
int directions[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1,
0}};
int maxLength = 1;
for (int d = 0; d < 4; ++d) {
int ni = i + directions[d][0];
int nj = j + directions[d][1];
if (ni >= 0 && ni < n && nj >= 0 && nj < n &&
matrix[ni][nj] > matrix[i][j]) {
int length = 1 + findLongestTrail(matrix, dp, ni, nj, n);
maxLength = max(maxLength, length);
}

}
dp[i][j] = maxLength;
return maxLength;
}
int main() {
ifstream f("alpin.in");
// Read input
int n;
f >> n;
vector<vector<int>> matrix(n, vector<int>(n));
vector<vector<int>> dp(n, vector<int>(n, -1));
for (int i = 0; i < n; ++i) {
for (int j = 0; j < n; ++j) {
f >> matrix[i][j];
}
}
// Find the longest trail starting from each position
int maxLength = 0;
pair<int, int> startingPosition;
for (int i = 0; i < n; ++i) {
for (int j = 0; j < n; ++j) {
int length = findLongestTrail(matrix, dp, i, j, n);
if (length > maxLength) {

maxLength = length;
startingPosition = {i, j};
}
}
}
// Output the result
cout << maxLength << endl;
int originalMaxLength = maxLength; // Save the original
maxLength
for (int i = 0; i < originalMaxLength; ++i) {
cout << startingPosition.first + 1 << " " <<
startingPosition.second + 1 << endl;
int nextDirection[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1,
0}};
for (int d = 0; d < 4; ++d) {
int ni = startingPosition.first + nextDirection[d][0];
int nj = startingPosition.second + nextDirection[d][1];
if (ni >= 0 && ni < n && nj >= 0 && nj < n &&
matrix[ni][nj] > matrix[startingPosition.first]
[startingPosition.second] && dp[ni][nj] == maxLength - 1) {
startingPosition = {ni, nj};
break;
}

}
—maxLength;
}
return 0;
}
1. Alex is a great enthusiast when it comes to
numbers. He spends any free moment playing with
numbers. While playing in this manner, one day he
wrote down 10 distinct two-digit numbers and
noticed that among them there are two disjoint
subsets with equal sums. Of course, Alex thought it
was a coincidence and wrote down another 10
distinct two-digit numbers. To his surprise, after
some time, he found two disjoint subsets with
equal sums again. Given 10 distinct two-digit
numbers, determine the number of pairs of disjoint
subsets with equal sums that can be formed with
the given numbers. Also, find one such pair for
which the sum of the numbers in each subset is
maximum. The input file numbers.in contains on
the first line 10 distinct natural numbers separated
by spaces: x1, x2,...,x10. The output file
numbers.out contains three lines. On the first line,
there is the number of pairs of subsets with equal
sums and the maximum sum obtained, separated

by a space. On the second line are the elements of
the first subset, and on the third line are the
elements of the second subset, separated by
spaces.
Example:
Numbers.in Numbers.out
Meaning
60 49 86 78
23 97 69 71
32 10
65 276
78 97 69 32
60 49 86 71
10
65 solutions; the
maximum sum is 276, 9
out of 10 numbers have
been used; the first
subset has 4 elements,
and the second has 5.
Implementation:
#include <bits/stdc++.h>
using namespace std;
ifstream fin("numbers.in");
ofstream fout("numbers.out");
int n, v[12], a[12], sol[12];
int main()
{
int i,s1,s2,nrSubm=0,smax=0;
n=10;

for(i=1; i<=n; i++)
fin>>v[i];
while (a[0]==0)
{
///calcul sume
s1=s2=0;
for (i=1; i<=n; i++)
if (a[i]==1)
s1+=v[i];
else if (a[i]==2)
s2+=v[i];
if (s1==s2)
{
nrSubm++;
if (s1>smax)
{
smax=s1;
for (i=1; i<=n; i++)
sol[i]=a[i];
}
}
///urmatorul sir de 0,1,2:
for (i=n; a[i]==2; i—)

a[i]=0;
a[i]++;
}
nrSubm/=2;
fout<<nrSubm<<" "<<smax<<endl;
for (i=1; i<=n; i++)
if(sol[i]==1)
fout<<v[i]<<" ";
fout<<endl;
for (i=1; i<=n; i++)
if(sol[i]==2)
fout<<v[i]<<" ";
fout<<endl;
fin.close();
fout.close();
return 0;
}
1. Consider a matrix with n (n≤50) rows and
columns that stores only lowercase letters of the
English alphabet, and a word formed by distinct
letters of the English alphabet. Find the total
number of occurrences of this word within the
matrix, knowing that it can appear in any form

(from left to right, from top to bottom, from right to
left, from bottom to top, in a spiral form, etc.).
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
const int MAXN = 55;
const int dx[] = {-1, 0, 1, 0};
const int dy[] = {0, 1, 0, -1};
char board[MAXN][MAXN];
bool dp[MAXN][MAXN];
int n, m;
bool searchWord(string word, int x, int y, int idx) {
if (idx == word.length()) return true;
if (x < 0 || x >= n || y < 0 || y >= m || dp[x][y] ||
board[x][y] != word[idx])
return false;
dp[x][y] = true;
for (int i = 0; i < 4; i++) {
int a = x + dx[i], b = y + dy[i];
if (searchWord(word, a, b, idx + 1))
return true;

}
dp[x][y] = false;
return false;
}
int countWord(string word) {
int cnt = 0;
for (int i = 0; i < n; i++) {
for (int j = 0; j < m; j++) {
for (int k = 0; k < n; k++) {
for (int l = 0; l < m; l++) {
dp[k][l] = false;
}
}
if (searchWord(word, i, j, 0))
cnt++;
}
}
return cnt;
}
int main()
{
ifstream fin("data.in");
fin>>n>>m;

for (int i = 0; i < n; i++)
for (int j = 0; j < m; j++)
fin >> board[i][j];
string word;
fin >> word;
fin.close();
cout << countWord(word) << endl;
return 0;
}
1. Given an increasing sequence of n (n≤100)
positive integers, each with at most 9 digits,
determine the longest subsequence for which the
difference between any two consecutive values is
greater than or equal to the given value X.
Implementation:
#include <iostream>
#include <fstream>
#include <vector>
using namespace std;
const int N=105;
int n,X,a[N],dp[N];
vector<int>ans;

int main()
{
ifstream f("data.in");
f>>n>>X;
for(int i=0; i<n; i++)
f>>a[i];
int maxLen=0, endIndex=-1;
for(int i=0; i<n; i++)
{
dp[i]=1;
for(int j=0; j<i; j++)
{
if(a[i]-a[j]>=X)
{
dp[i]=max(dp[i],dp[j]+1);
if(dp[i]>maxLen)
{
maxLen=dp[i];
endIndex=i;
}
}
}
}

cout<<maxLen<<endl;
int i=endIndex;
while (i>=0)
{
if(dp[i]==maxLen)
{
ans.push_back(a[i]);
maxLen—;
}
i—;
}
for(int i=ans.size()-1; i>=0; i—)
cout<<ans[i]<<" ";
return 0;
}
1. Decompose a number S into a sum of numbers
raised to the power of n. The sum should be
expressed with the minimum number of terms. The
values for S and n are known (1 < n < 10, 1 < S
< 1000).
Example:

sum.in   sum.out   Meaning
29 3   3    29=33+13+13, k=3
being the requested number.
79 2  2   72=62+62
Implementation:
#include <iostream>
#include<bits/stdc++.h>
using namespace std;
int s, n;
int dp[1000];
int pow(int x, int y)
{
int res=1;
for (int i=0; i<y; i++)
res*=x;
return res;
}
int main()
{
cout<<"s=";cin>>s;
cout<<"n=";cin>>n;

for (int i=0; i<=s; i++)
dp[i]=0;
for(int i=1; i<=s; i++)
{
for(int j=1; j<=n; j++)
{
if (i>=pow(j,n))
dp[i]++;
}
}
cout<<dp[s]<<endl;
return 0;
}

CHAPTER 15 – LISTS
15.1 Singly Linked Lists. Creation. Traversal.
15.2 Singly Linked Lists. Insertion.
15.3 Singly Linked Lists. Deletion.
15.4 Singly Linked Lists. Sorting. Merging.
15.5 Doubly Linked Lists.
15.6 Circular Lists.
15.7 Stacks.
15.8 Queues.

15.1  SINGLY LINKED LISTS.
CREATION. TRAVERSAL
1. For a singly linked list whose integer elements are
read from the keyboard, perform the following
operations:
a. Display the content of the list.
b. Display the perfect squares from the list.
c. Count how many prime numbers are in the list. In
case the list does not contain prime numbers,
display a message.
d. Determine if the list is sorted in ascending order.
e. Determine the maximum value in the list and how
many times it appears in the list.
f. Double the elements for which the sum of digits is
less than 10.
Implementation:
#include <iostream>
#include <fstream>
#include <cmath>
using namespace std;
struct nod
{
int info;

nod *next;
};
void AddData(nod *&p,nod *&u,int x)
{
nod *q;
q=new nod;
q->info=x;
q->next=NULL;
if(p==0)
p=u=q;
else
{
u->next=q;
u=q;
}
}
void displayData(nod *q)
{
while(q)
{
cout<<q->info<<" ";
q=q->next;
}

cout<<endl;
}
void readData(nod *&p,nod *&u)
{
ifstream f("date.in");
int x;
while(f>>x)
AddData(p,u,x);
}
void DisplayDataPatratePerfecte(nod *q)
{
while(q)
{
if(sqrt(q->info)==(int)sqrt(q->info))
cout<<q->info<<" ";
q=q->next;
}
cout<<endl;
}
int Prim(int x)
{
if(x==2)
return 1;

if(x%2==0 || x<2)
return 0;
for(int i=3; i<=sqrt(x); i++)
if(x%i==0)
return 0;
return 1;
}
int ok;
int NumaraNumerePrime(nod *q)
{
int k=0;
while(q)
{
if(Prim(q->info)==1)
{
k++;
///cout<<q->info<<" ";
ok=1;
}
q=q->next;
}
if(k==0)
cout<<"Nu sunt numere prime in lista.";

return k;
}
int ordonare_crescator(nod *p)
{
ok=1;
while(p->next!=NULL)
{
if(p->info>p->next->info)
ok=0;
p=p->next;
}
if(ok==1)
return 1;
return 0;
}
int maxim(nod *q)
{
int maxi=q->info;
while(q!=NULL)
{
if(q->info>maxi)
maxi=q->info;
q=q->next;

}
return maxi;
}
int SumaCifrelor(int x)
{
int s=0;
while(x!=0)
{
s=s+x%10;
x=x/10;
}
return s;
}
void dublare(nod *q)
{
while(q)
{
if(SumaCifrelor(q->info)<10)
q->info=q->info*2;
q=q->next;
}
}
int main()

{
nod *p=0,*u;
readData(p,u);
///———————————-
displayData(p);
///———————————-
cout<<"Square numbers from the list: "<<endl;
DisplayDataPatratePerfecte(p);
///———————————-
int raspuns=NumaraNumerePrime(p);
if(raspuns!=0)
{
cout<<"There are "<<raspuns<<" prime numbers.";
cout<<endl;
}
else cout<<"No primes."<<endl;
///———————————-
if(ordonare_crescator(p)==1)
cout<<"In ascending order ";
else
cout<<"NOT ordered ";
cout<<endl;
///———————————-

int y=maxim(p),k=0;
while(p!=0)
{
if(p->info==y)
k++;
p=p->next;
}
cout<<"Max value: "<<y<<" it occurrs "<<k<<" times.";
///———————————-
cout<<endl;
dublare(p);
displayData(p);
return 0;
}
1. For a singly linked list whose integer elements are
read from the keyboard, perform the following
operations:
a. Double the value of the last even number in the
list.
b. Triple the value of the first even number in the list.
c. Decrease by one the value of the penultimate even
number in the list.

Implementation:
#include <iostream>
#include <fstream>
using namespace std;
struct nod
{
int info;
nod *next;
};
void addData(nod *&p,nod *&u,int x)
{
nod *q;
q=new nod;
q->info=x;
q->next=NULL;
if(p==0)
p=u=q;
else
{
u->next=q;
u=q;
}

}
void displayData(nod *p)
{
nod *q;
q=p;
while(q!=NULL)
{
cout<<q->info<<" ";
q=q->next;
}
cout<<endl;
}
void dublare_nr_par(nod *p,nod *u)
{
nod *s;
for(nod *c=p; c!=NULL; c=c->next)
if(c->info%2==0)
s=c;
for(nod *c=p; c!=NULL; c=c->next)
if(s==c)
c->info=2*c->info;
}
void triplare_nr_par(nod *p,nod *u)

{
nod *s;
for(nod *c=p; c!=NULL; c=c->next)
if(s!=NULL &&c->info%2==0)
{
s=c;
break;
}
for(nod *c=p; c!=NULL; c=c->next)
if(s==c)
c->info=3*c->info;
}
void micsorare_nr_par(nod *p,nod *u)
{
nod *s,*w;
for(nod *c=p; c!=NULL; c=c->next)
if(s!=NULL &&c->info%2==0)
{
s=w;
w=c;
}
for(nod *c=p; c!=NULL; c=c->next)
if(s==c)

c->info=c->info-1;
}
int main()
{
ifstream f("date.in");
nod *p=0,*u;
int n,x,i;
while(f>>x)
addData(p,u,x);
displayData(p);
//a)
cout<<"The list after doubling the last even: "<<endl;
dublare_nr_par(p,u);
displayData(p);
//b)
cout<<"The list after tripling the first even number "
<<endl;
triplare_nr_par(p,u);
displayData(p);
///Cerinta c)
cout<<"The list after decreasing the penultimate even "
<<endl;
micsorare_nr_par(p,u);

displayData(p);
return 0;
}
1. For a singly linked list that stores at least 4 integer
elements, read from the keyboard, perform the
following operations: move the first two elements
to the end of the list, with the second element
becoming the last, and move the last two elements
to the beginning of the list, with the last element
becoming the second.
Example: If the list initially stores the values 1, 2,
3, 4, 5, 6 in this order, the result will be:
5, 6, 3, 4, 1, 2.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
struct nod
{
int info;
nod *next;
};

void addData(nod *&p,nod *&u,int x)
{
nod *q;
q=new nod;
q->info=x;
q->next=NULL;
if(p==0)
p=u=q;
else
{
u->next=q;
u=q;
}
}
void displayData(nod *p)
{
nod *q;
q=p;
while(q!=NULL)
{
cout<<q->info<<" ";
q=q->next;
}

cout<<endl;
}
int main()
{
ifstream f("date.in");
nod *p=0,*u;
int x,i;
while(f>>x)
addData(p,u,x);
displayData(p);
nod *c;
int aux1,aux2,aux3,aux4;
aux1=p->info;
aux2=p->next->info;
for(c=p; c->next->next!=NULL; c=c->next);
aux3=c->info;
aux4=c->next->info;
c->info=aux1;
c->next->info=aux2;
p->info=aux3;
p->next->info=aux4;
displayData(p);
return 0;

}
1. For a singly linked list that stores at least 4 integer
elements, read from the keyboard, perform the
following operation: move the first half of the list to
the end. If the list contains an odd number of
elements, the middle element will become the first.
Example: If the list initially stores the values 1, 2,
3, 4, 5, 6, 7, 8, 9 in this order, the result will be: 5, 6,
7, 8, 9, 1, 2, 3, 4.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
struct nod
{
int info;
nod *next;
};
void addData(nod *&p,nod *&u,int x)
{
nod *q;
q=new nod;

q->info=x;
q->next=NULL;
if(p==0)
p=u=q;
else
{
u->next=q;
u=q;
}
}
void displayData(nod *p)
{
nod *q;
q=p;
while(q!=NULL)
{
cout<<q->info<<" ";
q=q->next;
}
cout<<endl;
}
int main()
{

ifstream f("data.in");
nod *p=0,*u;
int n,x,i;
f>>n;
for(i=1; i<=n; i++)
{
f>>x;
addData(p,u,x);
}
displayData(p);
nod *c,*q;
int aux;
for(i=1,c=p;i<n/2+1;i++,c=c->next);///!!!!!!!!!!!!!!!!!!
for(q=p;c!=NULL;c=c->next,q=q->next)
{
aux=q->info;
q->info=c->info;
c->info=aux;
}
displayData(p);
return 0;
}

1. Store the integer numbers from the file data.in into
a singly linked list.
a. Display the content of the list and the number of
components in the list.
b. Generate two lists: one that stores the prime
numbers from the first list, and the other that
stores the non-prime numbers.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
struct nod
{
int info;
nod *next;
};
void addData(nod *&p, nod *&u, int x)
{
nod *q=new nod;
q->info=x;
q->next=NULL;
if (p==0)

p=u=q;
else
{
u->next=q;
u=q;
}
}
bool este_prim(int x)
{
if(x<2)
return false;
for(int i=2; i*i<=x; i++)
if(x%i==0)
return false;
return true;
}
void displayData(nod *p)
{
nod *q=p;
int contor=0;
while (q!=NULL)
{
cout<<q->info<<" ";

q=q->next;
contor++;
}
cout<<endl;
cout<<"Total elements: "<<contor<<endl;
}
int main()
{
ifstream f("data.in");
nod
*p=0,*u=0,*prim=0,*u_prim=0,*neprim=0,*u_neprim=0;
int n,x,i;
f>>n;
for(i=1; i<=n; i++)
{
f>>x;
addData(p, u, x);
}
cout<<"Initial list: ";
displayData(p);
nod *c=p;
while(c!=NULL)
{

if (este_prim(c->info))
addData(prim, u_prim, c->info);
else
addData(neprim, u_neprim, c->info);
c=c->next;
}
cout<<"List with prime numbers: ";
displayData(prim);
cout<<"List with non-prime numbers: ";
displayData(neprim);
return 0;
}
1. Store the integer numbers from a one-dimensional
array into a singly linked list.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
struct nod
{
int info;
nod *next;

};
void addData(nod *&p, nod *&u, int x)
{
nod *q=new nod;
q->info=x;
q->next=NULL;
if (p==0)
p=u=q;
else
{
u->next=q;
u=q;
}
}
void displayData(nod *p)
{
nod *q=p;
while (q!=NULL)
{
cout<<q->info<<" ";
q=q->next;
}
cout<<endl;

}
int main()
{
ifstream f("data.in");
int n,i,arr[100];
f>>n;
for(i=1;i<=n;i++)
f>>arr[i];
nod *p=NULL,*u;
for(i=1;i<=n;i++)
addData(p,u,arr[i]);
cout<<"Initial list: ";
displayData(p);
return 0;
}
1. Store the integer numbers from a two-dimensional
array into a singly linked list.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
struct nod

{
int info;
nod *next;
};
void addData(nod *&p, nod *&u, int x)
{
nod *q=new nod;
q->info=x;
q->next=NULL;
if (p==0)
p=u=q;
else
{
u->next=q;
u=q;
}
}
void displayData(nod *p)
{
nod *q=p;
while (q!=NULL)
{
cout<<q->info<<" ";

q=q->next;
}
cout<<endl;
}
int main()
{
ifstream f("date.in");
int n,j,m,i,a[101][101];
f>>n>>m;
for(i=1;i<=n;i++)
for(j=1;j<=m;j++)
f>>a[i][j];
nod *p=NULL,*u;
for(i=1;i<=n;i++)
{
for(j=1;j<=m;j++)
addData(p,u,a[i][j]);
}
cout<<"Displaying the list: ";
displayData(p);
return 0;
}

1. A sparse matrix is a matrix with many zero values.
The values of such a matrix will be stored in a
singly linked list. The number of rows m and the
number of columns n for a matrix are read from
the keyboard. Each element of the list will store a
non-zero value, the row, and the column of that
value in the matrix.
a. Display the content of the list in linear format.
b. Display the content of the list in matrix format.
c. Determine the sum of two sparse matrices stored
in two lists. The sum will be stored in a list as well.
Display the result in matrix format. The matrices
have m rows and n columns.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int m,n,a[51][51],b[51][51];
struct nod
{
int info,i,j;
nod* next;
};

nod *p1=0,*u1;
nod *p2=0,*u2;
nod *rezultat=0,*ur;
void addData(nod *&p, nod *&u, int val,int linie,int
coloana)
{
nod *q=new nod;
q->info=val;
q->i=linie;
q->j=coloana;
q->next=NULL;
if (p==0)
p=u=q;
else
{
u->next=q;
u=q;
}
}
void readData()
{
ifstream f("date.in");
f>>m>>n;

for(int i=1;i<=m;i++)
for(int j=1;j<=n;j++)
{
f>>a[i][j];
addData(p1,u1,a[i][j],i,j);
}
for(int i=1;i<=m;i++)
for(int j=1;j<=n;j++)
{
f>>b[i][j];
addData(p2,u2,b[i][j],i,j);
}
f.close();
}
void displayData_matrice(int matrice[51][51],int m,int n)
{
for(int i=1;i<=m;i++)
{
for(int j=1;j<=n;j++)
cout<<matrice[i][j]<<" ";
cout<<endl;
}
}

void displayData_matriceal(nod *p, int m, int n)
{
int matrice[51][51];
for(int i=1;i<=m;i++)
for(int j=1;j<=n;j++)
matrice[i][j]=0;
nod *q=p;
while (q != NULL)
{
matrice[q->i][q->j]=q->info;
q=q->next;
}
displayData_matrice(matrice,m,n);
}
void displayDataList(nod *p)
{
nod *q=p;
while (q!=NULL)
{
cout<<q->info<<" ";
q=q->next;
}
cout<<endl;

}
nod *suma_matrici(nod *p1,nod *p2, int m, int n)
{ 
nod *q1=p1,*q2=p2;
while(q1!=NULL && q2!=NULL)
{
if(q1->i < q2->i)
{
addData(rezultat,ur,q1->info,q1->i,q1->j);
q1=q1->next;
}
else if(q2->i < q1->i)
{
addData(rezultat,ur,q2->info,q2->i,q2->j);
q2=q2->next;
}
else if(q1->j < q2->j)
{
addData(rezultat,ur,q1->info,q1->i,q1->j);
q1=q1->next;
}
else if(q2->j < q1->j) 
{

addData(rezultat,ur,q2->info,q2->i,q2->j);
q2=q2->next;
}
else
{
addData(rezultat,ur,q1->info+q2->info,q1->i,q1->j);
q1=q1->next;
q2=q2->next;
}
}
while(q1!=NULL)
{
addData(rezultat,ur,q1->info,q1->i,q1->j);
q1=q1->next;
}
while(q2!=NULL)
{
addData(rezultat,ur,q2->info,q2->i,q2->j);
q2=q2->next;
}
return rezultat;
}
int main()

{
readData();
cout<<"Linear format: "<<endl;
displayDataList(p1);
cout<<"Matrix format: "<<endl;
displayData_matriceal(p1,m,n);
cout<<"Linear format: "<<endl;
displayDataList(p2);
cout<<"Matrix format: "<<endl;
displayData_matriceal(p2,m,n);
nod *r=suma_matrici(p1,p2,m,n);
cout<<"Sum matrix in linear format: "<<endl;
displayDataList(r);
cout<<"Sum matrix in matrix format: "<<endl;
displayData_matriceal(r,m,n);
return 0;
}
1. From the file data.in read a natural number n
(n≤100) from the first line. Then, on the next n
lines, read a natural number m at the beginning of
each line, followed by m integer numbers. The
content of each line will be stored in a singly linked
list.

a. Display the lists on the screen, each on a new line.
b. Display the list that stores the most perfect
squares. In case there are multiple lists with the
same number of perfect squares, display the first
one.
c. Determine how many lists store only non-zero
values.
Implementation:
#include <iostream>
#include <fstream>
#include <cmath>
using namespace std;
struct nod
{
int info;
nod* next;
};
nod *p[101],*u[101];
int m[101],n,x;
void addData(nod *&p, nod *&u, int val)
{
nod *q=new nod;
q->info=val;

q->next=NULL;
if (p==0)
p=u=q;
else
{
u->next=q;
u=q;
}
}
void readData()
{
ifstream f("data.in");
f>>n;
for(int i=1;i<=n;i++)
{
f>>m[i];
for(int j=1;j<=m[i];j++)
{
f>>x;
addData(p[i],u[i],x);
}
}
f.close();

}
void displayDataList(nod *p)
{
nod *q=p;
while (q!=NULL)
{
cout<<q->info<<" ";
q=q->next;
}
cout<<endl;
}
int numara_pp(nod *p)
{ 
int k=0;
while(p!=NULL)
{
if(sqrt(p->info)==(int)sqrt(p->info))
k++;
p=p->next;
}
return k;
}
void task_b(nod *p[101],int m[101],int n)

{
int max_pp=0,index=0;
for(int i=1;i<=n;i++)
{ 
for(int j=1;j<=m[i];j++)
{
int pp=numara_pp(p[i]);
if(pp>max_pp)
{
max_pp=pp;
index=i;
}
}
}
cout<<"The list with the most square numbers: "
<<index<<": ";
displayDataList(p[index]);
}
int numara_valori_nenule(nod *p)
{
int nr=0;
while(p!=NULL)
{

if(p->info==0)
nr++;
p=p->next;
}
return nr;
}
int task_c(nod *p[101],int m[101],int n)
{
int k=0;
for(int i=1;i<=n;i++)
{ 
int counter=numara_valori_nenule(p[i]);
if(counter==0)
k++;
}
return k;
}
int main()
{
readData();
//Display the list onto the screen
for(int i=1;i<=n;i++)
{

cout<<"Lista "<<i<<": ";
displayDataList(p[i]);
}
cout<<endl;
task_b(p,m,n);
cout<<endl;
int rezultat=task_c(p,m,n);
if(rezultat==0)
cout<<"No lists contains non-zero numbers";
else
cout<<"Number of lists which contains nonzeros: "
<<rezultat;
return 0;
}
1. Generate a singly linked list that stores the natural
numbers from the file data.in, and after each
number, store in the list the count of its digits.
Example: If the file has the following content:
-45, 235, 89, 2345, 4, -78, -2, 44
the content of the list will be: 235, 3, 89, 2, 2345, 4, 4,
1, 44, 2.

Implementation:
#include <iostream>
#include <fstream>
#include <cmath>
using namespace std;
struct nod
{
int info;
nod* next;
};
nod *p=NULL,*u;
int nr_cifre(int x)
{
int k=0;
while(x>0)
{
k++;
x=x/10;
}
return k;
}
void addData(nod *&p, nod *&u, int val)

{
nod *q=new nod;
q->info=val;
q->next=NULL;
if (p==0)
p=u=q;
else
{
u->next=q;
u=q;
}
}
void readData()
{
ifstream f("date.in");
int x;
while(f>>x)
{
if(x>0)
{
addData(p,u,x);
addData(p,u,nr_cifre(x));
}

}
f.close();
}
void displayDataList(nod *p)
{
nod *q=p;
while (q!=NULL)
{
cout<<q->info<<" ";
q=q->next;
}
cout<<endl;
}
int main()
{
readData();
displayDataList(p);
return 0;
}
1. Define a recursive subroutine that displays the
content of a singly linked list.
Implementation:

#include <iostream>
#include <fstream>
#include <cmath>
using namespace std;
struct nod
{
int info;
nod* next;
};
nod *p=NULL,*u;
void addData(nod *&p, nod *&u, int val)
{
nod *q=new nod;
q->info=val;
q->next=NULL;
if (p==0)
p=u=q;
else
{
u->next=q;
u=q;
}
}

void readData()
{
ifstream f("date.in");
int x;
while(f>>x)
addData(p,u,x);
f.close();
}
void displayDataList(nod *p)
{
if(p!=NULL)
{
cout<<p->info<<" ";
displayDataList(p->next);
}
}
int main()
{
readData();
displayDataList(p);
return 0;
}

1. Define a recursive subroutine that displays the
content of a singly linked list in reverse order.
Implementation:
#include <iostream>
#include <fstream>
#include <cmath>
using namespace std;
struct nod
{
int info;
nod* next;
};
nod *p=NULL,*u;
void addData(nod *&p, nod *&u, int val)
{
nod *q=new nod;
q->info=val;
q->next=NULL;
if (p==0)
p=u=q;
else
{

u->next=q;
u=q;
}
}
void readData()
{
ifstream f("date.in");
int x;
while(f>>x)
addData(p,u,x);
f.close();
}
void displayDataList(nod *p)
{
if(p!=NULL)
{
displayDataList(p->next);
cout<<p->info<<" ";
}
}
int main()
{
readData();

displayDataList(p);
return 0;
}
1. Two singly linked lists store distinct integer
numbers representing the elements of two sets.
Generate simple lists representing the intersection,
difference, and union of the two sets.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
struct nod
{
int info;
nod* next;
};
int m,n;
nod *p1=NULL,*u1;
nod *p2=NULL,*u2;
void addData(nod *&p, nod *&u, int val)
{
nod *q=new nod;

q->info=val;
q->next=NULL;
if (p==0)
p=u=q;
else
{
u->next=q;
u=q;
}
}
void readData()
{
ifstream f("date.in");
int x;
f>>m>>n;
for(int i=1;i<=m;i++)
{
f>>x;
addData(p1,u1,x);
}
for(int i=1;i<=n;i++)
{
f>>x;

addData(p2,u2,x);
}
f.close();
}
void displayDataList(nod *p)
{
while(p!=NULL)
{
cout<<p->info<<" ";
p=p->next;
}
cout<<endl;
}
bool este_in_lista(nod *p,int x)
{
while(p!=NULL)
{
if(p->info==x)
return true;
p=p->next;
}
return false;
}

nod* reuniune(nod *p1,nod *p2)
{
nod *rezultat=NULL,*ul;
nod *q=p1;
while(q!=NULL)
{
addData(rezultat,ul,q->info);
q=q->next;
}
nod *r=p2;
while(r!=NULL)
{
if (!este_in_lista(p1,r->info))
addData(rezultat,ul,r->info);
r=r->next;
}
return rezultat;
}
nod* intersectie(nod *p1,nod *p2)
{
nod *rezultat=NULL,*ul;
nod *q=p1;
while(q!=NULL)

{ 
if(este_in_lista(p2,q->info))
addData(rezultat,ul,q->info);
q=q->next;
}
return rezultat;
}
nod* diferenta(nod *p1,nod *p2)
{
nod *rezultat=NULL,*ul;
nod *q=p1;
while(q!=NULL)
{
if(!este_in_lista(p2,q->info))
addData(rezultat,ul,q->info);
q=q->next;
}
return rezultat;
}
int main()
{
readData();
cout<<"First set: ";

displayDataList(p1);
cout<<"Second set: ";
displayDataList(p2);
nod* reun=reuniune(p1,p2);
cout<<"Reunion: ";
displayDataList(reun);
nod *inter=intersectie(p1,p2);
cout<<"Intersection: ";
displayDataList(inter);
nod *dif=diferenta(p1,p2);
cout<<"Difference A - B: ";
displayDataList(dif);
return 0;
}
1. Given a list with integer elements, create a second
list that contains each unique element from the
given list followed by its frequency of occurrence.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
struct nod

{
int info;
nod* next;
};
nod *p=NULL,*u;
void addData(nod *&p, nod *&u, int val)
{
nod *q=new nod;
q->info=val;
q->next=NULL;
if (p==0)
p=u=q;
else
{
u->next=q;
u=q;
}
}
void readData()
{
ifstream f("data.in");
int x;
while(f>>x)

adaugare(p,u,x);
f.close();
}
void displayData(nod *p)
{
while(p!=NULL)
{
cout<<p->info<<" ";
p=p->next;
}
cout<<endl;
}
int frequencies(nod *p,int x)
{ 
int k=0;
while(p!=NULL)
{
if(p->info==x)
k++;
p=p->next;
}
return k;
}

bool isInList(nod *p,int x)
{
while(p!=NULL)
{
if(p->info==x)
return true;
p=p->next;
}
return false;
}
nod *construction(nod *p)
{
nod *result=NULL,*ul;
while(p!=NULL)
{ 
if(!isInList(rezultat,p->info))
{
addData(result,ul,p->info);
addData(result,ul,frequencies(p,p->info));
}
p=p->next;
}
return result;

}
int main()
{
readData();
displayData(p);
cout<<frequencies(p,10);
cout<<endl;
nod *list=construction(p);
displayData(list);
return 0;
}
1. Store the terms of a polynomial in a list, where
each component will store the coefficient and
degree of a term in the polynomial.
a. Display the value of the polynomial at a point.
b. Determine the sum of two polynomials.
c. Determine the product of two polynomials.
Implementation:
#include <iostream>
#include <fstream>
#include <cmath>
using namespace std;

struct nod
{
int coeficient,grad;
nod* next;
};
nod *p1=NULL,*u1;
nod *p2=NULL,*u2;
int n;
void adaugare(nod *&p,nod *&u,int coeficient,int grad)
{
nod *q=new nod;
q->coeficient=coeficient;
q->grad=grad;
q->next=NULL;
if (p==0)
p=u=q;
else
{
u->next=q;
u=q;
}
}
void citire()

{
ifstream f("data.in");
int x,y;
f>>n;
for(int i=1;i<=n;i++)
{
f>>x>>y;
adaugare(p1,u1,x,y);
}
for(int i=1;i<=n;i++)
{
f>>x>>y;
adaugare(p2,u2,x,y);
}
f.close();
}
void afisare(nod *p)
{
while(p!=NULL)
{ 
cout<<p->coeficient<<"* X^"<<p->grad<<" ";
p=p->next;
}

cout<<endl;
}
int valoare(nod *p,int x)
{
int rezultat=0;
nod*q=p;
while(q!=NULL)
{
rezultat+=q->coeficient*pow(x,q->grad);
q=q->next;
}
return rezultat;
}
nod *suma_polinoame(nod *p1,nod *p2)
{ 
nod *rezultat=NULL,*ul;
while(p1!=NULL && p2!=NULL)
{
if(p1->grad > p2->grad)
{
adaugare(rezultat,ul,p1->coeficient,p1->grad);
p1=p1->next;
}

else if(p1->grad < p2->grad)
{
adaugare(rezultat,ul,p2->coeficient,p2->grad);
p2=p2->next;
}
else
{
adaugare(rezultat,ul,p1->coeficient+p2->coeficient,p1-
>grad);
p1=p1->next;
p2=p2->next;
}
}
while(p1!=NULL)
{
adaugare(rezultat,ul,p1->coeficient,p1->grad);
p1=p1->next;
}
while(p2!=NULL)
{
adaugare(rezultat,ul,p2->coeficient,p2->grad);
p2=p2->next;
}

return rezultat;
}
nod* produs_polinoame(nod *p1,nod *p2)
{
nod *rezultat=NULL,*ul;
while(p1!=NULL)
{
nod*q=p2;
while(q!=NULL)
{
adaugare(rezultat,ul,p1->coeficient * q->coeficient,p1-
>grad+q->grad);
q=q->next;
}
p1=p1->next;
}
return rezultat;
}
int main()
{ 
int x0;
citire();
cout<<"1st polynomial: ";

afisare(p1);
cout<<"2nd polynomial: ";
afisare(p2);
cout<<"Value in a point: ";
cin>>x0;
cout<<"1st polynomial in "<<x0<<" is: "
<<valoare(p1,x0)<<endl;
cout<<"2nd polynomial in "<<x0<<" is: "
<<valoare(p2,x0)<<endl;
nod*suma=suma_polinoame(p1,p2);
cout<<"Sum of polynomials is: ";
afisare(suma);
nod *produs=produs_polinoame(p1,p2);
cout<<"Product of polynomials is: ";
afisare(produs);
return 0;
}
1. Modify the content of a list that stores natural
numbers so that each number is replaced with the
nearest perfect square greater than or equal to it.
Example: If the list initially stores the values 5, 7,
10, 23, 25, 34, the resulting list will be: 4, 9, 9, 25, 25,

36.
Implementation:
#include <iostream>
#include <fstream>
#include <cmath>
using namespace std;
struct nod
{
int info;
nod* next;
};
nod *p1=NULL,*u1;
void adaugare(nod *&p,nod *&u,int x)
{
nod *q=new nod;
q->info=x;
q->next=NULL;
if (p==0)
p=u=q;
else
{
u->next=q;

u=q;
}
}
void citire()
{
ifstream f("data.in");
int x;
while(f>>x)
adaugare(p1,u1,x);
f.close();
}
void afisare(nod *p)
{
while(p!=NULL)
{ 
cout<<p->info<<" ";
p=p->next;
}
cout<<endl;
}
void inlocuire(nod *p)
{ 
nod*rezultat=NULL,*ul;

nod *q=p;
while(q!=NULL)
{
int num=q->info;
int sqrtNum=sqrt(num);
int perfectSquare=sqrtNum*sqrtNum;
if(perfectSquare==num)
{
q=q->next;
continue;
}
int nextPerfectSquare=(sqrtNum+1)*(sqrtNum+1);
if(num-perfectSquare-1<nextPerfectSquare-num)
q->info=perfectSquare;
else
q->info=nextPerfectSquare;
q=q->next;
}
}
int main()
{ 
citire();
afisare(p1);

cout<<"After modification: ";
inlocuire(p1);
afisare(p1);
return 0;
}
1. Given a singly linked list that stores integer
numbers, generate a new singly linked list that
stores the elements of the first list in reverse order.
Example: If the first list stores the values: 3, 5, 4,
7, 2, the second list will store the values: 2, 7, 4, 5, 3.
Implementation:
#include <iostream>
#include <fstream>
#include <cmath>
using namespace std;
struct nod
{
int info;
nod* next;
};
nod *p1=NULL,*u1;
void adaugare(nod *&p,nod *&u,int x)

{
nod *q=new nod;
q->info=x;
q->next=NULL;
if (p==0)
p=u=q;
else
{
u->next=q;
u=q;
}
}
void citire()
{
ifstream f("data.in");
int x;
while(f>>x)
adaugare(p1,u1,x);
f.close();
}
void afisare(nod *p)
{
while(p!=NULL)

{ 
cout<<p->info<<" ";
p=p->next;
}
cout<<endl;
}
nod *invers(nod *p)
{ 
nod* curent=p;
nod* prev=NULL;
nod* next=NULL;
while(curent!=NULL)
{
next=curent->next;
curent->next=prev;
prev=curent;
curent=next;
}
return prev;
}
int main()
{
citire();

cout<<"Initial list: ";
afisare(p1);
cout<<"The list after modification: ";
nod*reversed=invers(p1);
afisare(reversed);
return 0;
}
1. Determine whether two lists have the same
content but not necessarily in the same order.
Display YES or NO. The lists store integer numbers.
Example: If the lists store the values 4, 6, 7, 5, and
6, 7, 4, 5, the output will be YES.
Implementation:
#include <iostream>
#include <fstream>
#include <cmath>
using namespace std;
struct nod
{
int info;
nod* next;
};

nod *p1=NULL,*u1;
nod *p2=NULL,*u2;
int n;
void adaugare(nod *&p,nod *&u,int x)
{
nod *q=new nod;
q->info=x;
q->next=NULL;
if (p==0)
p=u=q;
else
{
u->next=q;
u=q;
}
}
void citire()
{
ifstream f("data.in");
int x;
f>>n;
for(int i=1;i<=n;i++)
{ 

f>>x;
adaugare(p1,u1,x);
}
for(int i=1;i<=n;i++)
{
f>>x;
adaugare(p2,u2,x);
}
f.close();
}
void afisare(nod *p)
{
while(p!=NULL)
{ 
cout<<p->info<<" ";
p=p->next;
}
cout<<endl;
}
bool aceleasi_elemente(nod *p1,nod *p2)
{
nod *q1=p1;
while(q1!=NULL)

{
int k1=0;
nod *q2=p2;
while(q2!=NULL)
{
if(q1->info == q2->info)
{ 
k1++;
break;
}
q2=q2->next;
}
if(k1==0)
return false;
q1=q1->next;
}
nod *q2=p2;
while(q2!=NULL)
{
int k2=0;
nod *q1=p1;
while(q1!=NULL)
{

if(q1->info == q2->info)
{
k2++;
break;
}
q1=q1->next;
}
if(k2==0)
return false;
q2=q2->next;
}
return true;
}
int main()
{
citire();
cout<<"List1: ";
afisare(p1);
cout<<"List2: ";
afisare(p2);
bool ok=aceleasi_elemente(p1,p2);
if(ok)
cout<<"Yes";

else
cout<<"No";
return 0;
}
1. Given a singly linked list that stores at least 3
integer numbers:
a. Invert the content of the second component with
the penultimate one.
b. Invert the content of the last component with the
penultimate one.
c. Display the element/elements in the middle of the
list.
d. Generate a new list that stores the digits of the
numbers from the first list.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
struct nod
{
int info;
nod* next;

};
nod *p=NULL,*u;
void adaugare(nod *&p,nod *&u,int x)
{
nod *q=new nod;
q->info=x;
q->next=NULL;
if (p==0)
p=u=q;
else
{
u->next=q;
u=q;
}
}
void citire()
{
ifstream f("data.in");
int x;
while(f>>x)
adaugare(p,u,x);
f.close();
}

void afisare(nod *p)
{
while(p!=NULL)
{ 
cout<<p->info<<" ";
p=p->next;
}
cout<<endl;
}
// Reverse 2 nodes from the list
void swapNodes(nod** head_ref, int x, int y)
{
if(x==y)
return;
// Look up after x and y nodes
nod *prevX=NULL, *currX=*head_ref;
while(currX && currX->info!=x)
{
prevX=currX;
currX=currX->next;
}
nod *prevY=NULL, *currY=*head_ref;
while(currY && currY->info!=y)

{
prevY=currY;
currY=currY->next;
}
// If one of the nodes hasn’t been found
if (currX==NULL || currY==NULL)
return;
// reverse the connections
if (prevX!=NULL)
prevX->next=currY;
else
*head_ref=currY;
if (prevY!=NULL)
prevY->next=currX;
else
*head_ref=currX;
nod* temp=currY->next;
currY->next=currX->next;
currX->next=temp;
}
int obtine_doua_valoare(nod *p)
{
nod* curr=p;

int second_element=-1;
if (curr!=NULL && curr->next!=NULL)
second_element=curr->next->info;
return second_element;
}
int obtine_penultima(nod *p)
{
nod* curr=p;
int penultimate_element=-1;
if (curr!=NULL && curr->next!=NULL)
{
while(curr->next->next!=NULL)
curr=curr->next;
penultimate_element=curr->info;
}
return penultimate_element;
}
int obtine_ultima(nod *p)
{ 
int u=-1;
while(p!=NULL && p->next!=NULL)
{ 
p=p->next;

if(p!=NULL)
u=p->info;
}
return u;
}
void afisare_mijloc(nod *p)
{
nod* slow=p;
nod* fast=p;
int lungime=0;
while (fast!=NULL && fast->next!=NULL)
{
slow=slow->next;
fast=fast->next->next;
lungime++;
}
if(lungime%2==0)
cout<<"Mid elements: "<<slow->info<<" "<<slow-
>next->info<<endl;
else
cout<<"Mid element: "<<slow->info<<endl;
}
nod* createDigitList(nod* head)

{
nod *digitHead=NULL;
nod *digitTail=NULL;
nod *current=head;
while (current != NULL)
{
int number=current->info;
while (number>0)
{
int digit=number%10;
if (digitHead==NULL)
{
digitHead=new nod;
digitTail=digitHead;
}
else
{
digitTail->next=new nod;
digitTail=digitTail->next;
}
number/=10;
}
current=current->next;

}
return digitHead;
}
int main()
{
citire();
afisare(p);
//2nd component becomes the last 2nd
cout<<"Initial list: ";
int doua=obtine_doua_valoare(p);
int an=obtine_penultima(p);
swapNodes(&p,doua,an);
afisare(p);
//Last component becomes the last 2nd
int u=obtine_ultima(p);
an=obtine_penultima(p);
swapNodes(&p,u,an);
cout<<"The list after modification: ";
afisare(p);
//Element(s) from mid
afisare_mijloc(p);
//Generate the new list
nod* digitHead=createDigitList(p); // Digits list

afisare(digitHead);
return 0;
}
1. For the n students in a class (n≤30), read their
names and grades in an exam. The data will be
stored in a singly linked list. Perform the following
operations:
a. Determine the number of students with grades
above 9.00.
b. Display the grade of a student whose name is read
from the keyboard.
c. Determine the class average.
d. Determine the highest and lowest averages.
e. Display the students whose names start with a
letter read from the keyboard.
Implementation:
#include <iostream>
#include <fstream>
#include <cstring>
using namespace std;
struct student
{
char name[50];

float grade;
};
struct node
{
student info;
node *next;
};
void add(node *&first, node *&last, student x)
{
node *newNode = new node;
newNode->info = x;
newNode->next = nullptr;
if (first == nullptr)
first = last = newNode;
else
{
last->next = newNode;
last = newNode;
}
}
void display(node *first)
{
node *current = first;

while (current != nullptr)
{
cout << "Student " << current->info.name << " has a
grade of " << current->info.grade << endl;
current = current->next;
}
cout << endl;
}
int n, i, ok;
void read(node *&first, node *&last)
{
student x;
ifstream file("data.in");
file >> n;
for (i = 1; i <= n; i++)
{
file.get();
file.get(x.name, 50);
file.get();
file >> x.grade;
add(first, last, x);
}
}

int grades_above_9(node *first)
{
int counter = 0;
node *current = first;
while (current != nullptr)
{
if (current->info.grade >= 9)
counter++;
current = current->next;
}
return counter;
}
void display_grade(node *first, char name[50])
{
while (first != nullptr)
{
if (stricmp(first->info.name, name) == 0)
{
ok = 1;
cout << "Student " << name << " has a grade of: " <<
first->info.grade;
}
first = first->next;

}
cout << endl;
}
float class_average(node *first)
{
int sum = 0;
while (first != nullptr)
{
sum += first->info.grade;
first = first->next;
}
return (float)sum / n;
}
void max_min_grade(node *first, float &max_grade, float
&min_grade)
{
while (first != nullptr)
{
if (first->info.grade > max_grade)
max_grade = first->info.grade;
if (first->info.grade < min_grade)
min_grade = first->info.grade;
first = first->next;

}
}
void display_students_letter(node *first, char ch)
{
char ch1;
if (ch >= 'a' && ch <= 'z')
ch1 = toupper(ch);
if (ch >= 'A' && ch <= 'Z')
ch1 = tolower(ch);
while (first != nullptr)
{
if (first->info.name[0] == ch || first->info.name[0] ==
ch1)
cout << first->info.name << " ";
first = first->next;
}
}
int main()
{
node *first = nullptr, *last;
read(first, last);
cout << "Students: " << endl;
display(first);

///————————————
cout << "Number of grades above 9: " <<
grades_above_9(first) << endl;
///————————————
char name[50];
cout << "Student name: ";
cin.get(name, 50);
display_grade(first, name);
if (ok == 0)
cout << "Student not found in the list." << endl;
///————————————
cout << "Class average: " << class_average(first) <<
endl;
///————————————
float max_grade = 0, min_grade = 10;
max_min_grade(first, max_grade, min_grade);
cout << "The highest grade is " << max_grade << " and
the lowest grade is " << min_grade << endl;
///————————————
char ch;
cout << "A character: ";
cin >> ch;
display_students_letter(first, ch);

return 0;
}
1. In the file data.in, integers with at most four digits
each are stored. Write a program that generates a
singly linked list with the numbers from the file,
each appearing only once, along with their
frequency of occurrence in the file. Display the
result in the file data.out.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
struct nod
{
int info;
nod* next;
};
nod *p=NULL,*u;
void adaugare(nod *&p, nod *&u, int val)
{
nod *q=new nod;
q->info=val;

q->next=NULL;
if (p==0)
p=u=q;
else
{
u->next=q;
u=q;
}
}
void citire()
{
ifstream f("data.in");
int x;
while(f>>x)
adaugare(p,u,x);
f.close();
}
void afisare(nod *p)
{ 
ofstream g("data.out");
while(p!=NULL)
{
g<<p->info<<" ";

p=p->next;
}
cout<<endl;
}
int frecvente(nod *p,int x)
{ 
int k=0;
while(p!=NULL)
{
if(p->info==x)
k++;
p=p->next;
}
return k;
}
bool este_in_lista(nod *p,int x)
{
while(p!=NULL)
{
if(p->info==x)
return true;
p=p->next;
}

return false;
}
nod *construire(nod *p)
{
nod *rezultat=NULL,*ul;
while(p!=NULL)
{ 
if(!este_in_lista(rezultat,p->info))
{
adaugare(rezultat,ul,p->info);
adaugare(rezultat,ul,frecvente(p,p->info));
}
p=p->next;
}
return rezultat;
}
int main()
{
citire();
nod *lista=construire(p);
afisare(lista);
return 0;
}

1. In the file data.in, integers with at most four digits
each are stored. Write a program that generates a
singly linked list that stores the digits of the
numbers from the file. Display the resulting list in
the file data.out.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
struct nod
{
int info;
nod* next;
};
nod *p=NULL,*u;
void adaugare(nod *&p, nod *&u, int val)
{
nod *q=new nod;
q->info=val;
q->next=NULL;
if (p==0)
p=u=q;
else

{
u->next=q;
u=q;
}
}
void citire()
{
ifstream f("data.in");
int x;
while(f>>x)
adaugare(p,u,x);
f.close();
}
void afisare(nod *p)
{ 
ofstream g("data.out");
while(p!=NULL)
{
g<<p->info<<" ";
p=p->next;
}
cout<<endl;
}

int inversare(int x)
{
int y=0;
while(x>0)
{
y=y*10+x%10;
x=x/10;
}
return y;
}
nod *construire(nod *p)
{
nod *rezultat=NULL,*ul;
int counter=0;
while(p!=NULL)
{ 
int nr=inversare(p->info);
while(nr>0)
{
adaugare(rezultat,ul,nr%10);
nr=nr/10;
}
p=p->next;

}
return rezultat;
}
int main()
{
citire();
nod *lista=construire(p);
afisare(lista);
return 0;
}
1. The data of products from a store with n (n≤100)
products is read from the file data.in. The first line
contains the number n, and for each of the n
products, the following information is stored on
separate lines: the name of the product, the
category of the product (groceries, household,
etc.), the price, and the quantity of the product.
Store the data in a linear list.
a. For a product whose name is read from the
keyboard, display the stock value.
b. Knowing that for a product whose name is read, p
pieces are sold, update the content of the list.
c. Display the most expensive product from a
category whose name is read from the keyboard.

Implementation:
#include <iostream>
#include <fstream>
#include <cstring>
using namespace std;
struct product
{
char name[30];
char category[30];
float price;
int stock;
};
struct node
{
product info;
node* next;
};
node *head = NULL, *tail;
int n;
void add(node *&head, node *&tail, product value)
{
node *newNode = new node;

newNode->info = value;
newNode->next = NULL;
if (head == nullptr)
head = tail = newNode;
else
{
tail->next = newNode;
tail = newNode;
}
}
void read()
{
ifstream file("data.in");
product x;
file >> n;
for(int i = 1; i <= n; i++)
{
file.get();
file.get(x.name, 30);
file.get();
file.get(x.category, 30);
file.get();
file >> x.price >> x.stock;

add(head, tail, x);
}
file.close();
}
void display(node *head)
{
while (head != NULL)
{
cout << "Product: " << head->info.name << " in
category: " << head->info.category << " ";
cout << "has a price of: " << head->info.price << "
stock: " << head->info.stock << endl;
head = head->next;
}
cout << endl;
}
bool found = false;
void checkProduct(node *head, char productName[30])
{
while (head != NULL)
{
if (stricmp(head->info.name, productName) == 0)
{

found = true;
cout << "The product " << productName << " has a stock
of: " << head->info.stock << endl;
}
head = head->next;
}
}
void update(node *head, char name[30], int soldQuantity)
{
while (head != NULL)
{
if (stricmp(head->info.name, name) == 0)
{
found = true;
head->info.stock -= soldQuantity;
}
head = head->next;
}
}
float mostExpensive(node *head, char category[30])
{
int maxPrice = -1;
while (head != NULL)

{
if (stricmp(head->info.category, category) == 0)
{
if (head->info.price > maxPrice)
maxPrice = head->info.price;
}
head = head->next;
}
return maxPrice;
}
int main()
{
read();
display(head);
char productName[30];
cout << "Name: ";
cin.get(productName, 30);
checkProduct(head, productName);
if (!found)
cout << "The product is not found in the store." << endl;
int soldQuantity;
cin.get();
found = false;

cout << "Product name:";
cin.get(productName, 30);
cout << "How many sold? ";
cin >> soldQuantity;
update(head, productName, soldQuantity);
if (!found)
cout << "The product is not found in the store." << endl;
else
{
cout << "The product was found in the store, here is the
update" << endl;
display(head);
}
cin.get();
char productCategory[30];
cout << "Category: ";
cin.get(productCategory, 30);
float maxValue = mostExpensive(head, productCategory);
if (maxValue == -1)
cout << "No maximum price found";
else
cout << maxValue;
return 0;

}
1. A list stores n (n≤100) fractions, where for each
fraction, the numerator and denominator are non-
zero integers.
a. Determine the sum of the fractions.
b. Determine the product of the fractions.
c. Display the fraction with the highest value.
d. Determine if the first and last fractions are equal.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
struct fraction
{
int numerator, denominator;
};
struct node
{
fraction info;
node* next;
};
node *head = NULL, *tail;

int n;
void add(node *&head, node *&tail, fraction value)
{
node *newNode = new node;
newNode->info = value;
newNode->next = NULL;
if (head == 0)
head = tail = newNode;
else
{
tail->next = newNode;
tail = newNode;
}
}
void read(node* &head, node* &tail)
{
ifstream file("data.in");
fraction fr;
file >> n;
for(int i = 1; i <= n; i++)
{
file >> fr.numerator >> fr.denominator;
add(head, tail, fr);

}
file.close();
}
int gcd(int x, int y)
{
while (x != y)
if (x > y)
x = x - y;
else y = y - x;
return x;
}
void displayFraction(fraction fr)
{
cout << fr.numerator << "/" << fr.denominator << endl;
}
void display(node *head)
{
while (head != NULL)
{
displayFraction(head->info);
head = head->next;
}
cout << endl;

}
fraction sum(node *head)
{
fraction sum;
sum.numerator = 0, sum.denominator = 1;
while (head != NULL)
{
sum.numerator = sum.numerator * head-
>info.denominator + sum.denominator * head-
>info.numerator;
sum.denominator *= head->info.denominator;
head = head->next;
}
int divisor = gcd(sum.numerator, sum.denominator);
sum.numerator = sum.numerator / divisor;
sum.denominator = sum.denominator / divisor;
return sum;
}
fraction product(node *head)
{
fraction product;
product.numerator = 1, product.denominator = 1;
while (head != NULL)

{
product.numerator = product.numerator * head-
>info.numerator;
product.denominator = product.denominator * head-
>info.denominator;
head = head->next;
}
bool sign_numerator = false, sign_denominator = false;
if (product.numerator < 0)
{
product.numerator = (-1) * product.numerator;
sign_numerator = true;
}
if (product.denominator < 0)
{
product.denominator = (-1) * product.denominator;
sign_denominator = true;
}
int divisor = gcd(product.numerator,
product.denominator);
product.numerator = product.numerator / divisor;
product.denominator = product.denominator / divisor;
if (sign_numerator == true)

{
product.numerator = (-1) * product.numerator;
return product;
}
if (sign_denominator == true)
{
product.denominator = product.denominator / divisor;
return product;
}
}
fraction maxFractionValue(node *head)
{
float maxValue = -1;
fraction maxFraction;
while (head != NULL)
{
float value = (float)head->info.numerator / head-
>info.denominator;
if (value > maxValue)
{
maxValue = value;
maxFraction.numerator = head->info.numerator;
maxFraction.denominator = head->info.denominator;

}
head = head->next;
}
return maxFraction;
}
bool equality(fraction a, fraction b)
{
if (a.numerator * b.denominator == a.denominator *
b.numerator)
return true;
return false;
}
int main()
{
node *head = NULL, *tail;
read(head, tail);
cout << "Fractions:" << endl;
display(head);
cout << "Sum of fractions is:";
fraction sumResult = sum(head);
displayFraction(sumResult);
cout << "Product of fractions is:";
fraction productResult = product(head);

displayFraction(productResult);
cout << "Fraction with the maximum value is:";
fraction maxFraction = maxFractionValue(head);
displayFraction(maxFraction);
bool isEqual = equality(head->info, tail->info);
if (isEqual == true)
cout << "Fractions are equal.";
else
cout << "Fractions are not equal.";
return 0;
}
1. Store in a list the first n terms of the Fibonacci
sequence in order.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
struct nod
{
int info;
nod* next;
};

int n;
nod *p=NULL,*u;
void adaugare(nod *&p, nod *&u,int val)
{
nod *q=new nod;
q->info=val;
q->next=NULL;
if (p==0)
p=u=q;
else
{
u->next=q;
u=q;
}
}
void afisare(nod *p)
{
while(p!=NULL)
{
cout<<p->info<<" ";
p=p->next;
}
cout<<endl;

}
void generare_Fibo(int n,int a,int b)
{
int c;
adaugare(p,u,a);
adaugare(p,u,b);
for(int i=3;i<=n;i++)
{
c=a+b;
adaugare(p,u,c);
a=b;
b=c;
}
afisare(p);
}
int main()
{
cout<<"n=";cin>>n;
generare_Fibo(n,1,1);
return 0;
}

1. Determine if a list stores terms of the Fibonacci
sequence in order.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
struct nod
{
int info;
nod* next;
};
int n;
nod *p=NULL,*u;
void adaugare(nod *&p, nod *&u,int val)
{
nod *q=new nod;
q->info=val;
q->next=NULL;
if (p==0)
p=u=q;
else
{

u->next=q;
u=q;
}
}
void afisare(nod *p)
{
while(p!=NULL)
{
cout<<p->info<<" ";
p=p->next;
}
cout<<endl;
}
void citire()
{
ifstream f("data.in");
int x;
while(f>>x)
adaugare(p,u,x);
f.close();
}
bool serie_fibo(nod *p)
{

if(p==NULL || p->info!=1 || p->next->info!=1)
return false;
nod *q=p;
nod *r=p->next->next;
int a=1,b=1,c;
while(r!=NULL)
{
if(r->info!=a+b)
return false;
c=b;
b=a+b;
a=c;
q=r;
r=r->next;
}
return true;
}
int main()
{
citire();
afisare(p);
bool ok=serie_fibo(p);
if(ok==true)

cout<<"Does contain terms of Fibonacci sequence";
else
cout<<"No";
return 0;
}
1. Store in a list the first n terms of an arithmetic
progression in order, where the first term and the
common difference are read.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
struct nod
{
int info;
nod* next;
};
int n,a1,r;
nod *p=NULL,*u;
void adaugare(nod *&p, nod *&u,int val)
{
nod *q=new nod;

q->info=val;
q->next=NULL;
if (p==0)
p=u=q;
else
{
u->next=q;
u=q;
}
}
void afisare(nod *p)
{
while(p!=NULL)
{
cout<<p->info<<" ";
p=p->next;
}
cout<<endl;
}
void generare(int n,int a1,int r)
{
adaugare(p,u,a1);
for(int i=2;i<=n;i++)

{
int an=a1+r;
adaugare(p,u,an);
a1=an;
}
afisare(p);
}
int main()
{
cout<<"n=";cin>>n;
cout<<"a1=";cin>>a1;
cout<<"Common difference:";cin>>r;
generare(n,a1,r);
return 0;
}
1. Determine if a list stores the terms of an arithmetic
progression in order.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
struct nod

{
int info;
nod* next;
};
nod *p=NULL,*u;
void adaugare(nod *&p, nod *&u,int val)
{
nod *q=new nod;
q->info=val;
q->next=NULL;
if (p==0)
p=u=q;
else
{
u->next=q;
u=q;
}
}
void afisare(nod *p)
{
while(p!=NULL)
{
cout<<p->info<<" ";

p=p->next;
}
cout<<endl;
}
void citire()
{
ifstream f("data.in");
int x;
while(f>>x)
adaugare(p,u,x);
f.close();
}
bool verif(nod *p)
{
if(p==NULL || p->next==NULL)
return false;
int dif=p->next->info - p->info;
nod *q=p->next;
while(q->next!=NULL)
{
if (q->next->info - q->info != dif)
return false;
q=q->next;

}
return true;
}
int main()
{
citire();
afisare(p);
if(verif(p))
cout<<"Arithmetic progression!!!";
else
cout<<"No, it is not an arithmetic progression.";
return 0;
}
1. Determine how many values are stored in the
longest increasing ordered sequence in a list of
integers.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
struct node
{

int info;
node* next;
};
node *head = NULL, *tail;
void add(node *&head, node *&tail, int value)
{
node *newNode = new node;
newNode->info = value;
newNode->next = NULL;
if (head == 0)
head = tail = newNode;
else
{
tail->next = newNode;
tail = newNode;
}
}
void display(node *head)
{
while (head != NULL)
{
cout << head->info << " ";
head = head->next;

}
cout << endl;
}
void read()
{
ifstream file("data.in");
int x;
while (file >> x)
add(head, tail, x);
file.close();
}
int longest_increasing_sequence(node *head)
{
if (head == NULL || head->next == NULL)
return 0;
node *current = head;
int count = 1, maxCount = 1;
while (current->next != NULL)
{
if (current->next->info > current->info)
count++;
else
{

maxCount = max(maxCount, count);
count = 1;
}
current = current->next;
}
return max(maxCount, count);
}
int main()
{
read();
display(head);
cout<<"The longest sequence has: " <<
longest_increasing_sequence(head) <<" numbers."<<endl;
return 0;
}
1. Determine whether any two adjacent values in a
list of integers have different signs. Display Yes or
No.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;

struct nod
{
int info;
nod* next;
};
nod *p=NULL,*u;
void adaugare(nod *&p, nod *&u,int val)
{
nod *q=new nod;
q->info=val;
q->next=NULL;
if (p==0)
p=u=q;
else
{
u->next=q;
u=q;
}
}
void afisare(nod *p)
{
while(p!=NULL)
{

cout<<p->info<<" ";
p=p->next;
}
cout<<endl;
}
void citire()
{
ifstream f("data.in");
int x;
while(f>>x)
adaugare(p,u,x);
f.close();
}
bool semne(nod *p)
{
nod *q=p;
while(q!=NULL && q->next!=NULL)
{
int a=q->info;
int b=q->next->info;
if((a>0 && b>0) || (a<0 && b<0))
return false;
q=q->next;

}
return true;
}
int main()
{
citire();
afisare(p);
if(semne(p)==true)
cout<<"Yes";
else
cout<<"No";
return 0;
}
1. Determine how many triplets of consecutive values
in a list of integers have the property that one is
equal to the sum of the other two.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
struct nod
{

int info;
nod* next;
};
nod *p=NULL,*u;
void adaugare(nod *&p, nod *&u,int val)
{
nod *q=new nod;
q->info=val;
q->next=NULL;
if (p==0)
p=u=q;
else
{
u->next=q;
u=q;
}
}
void afisare(nod *p)
{
while(p!=NULL)
{
cout<<p->info<<" ";
p=p->next;

}
cout<<endl;
}
void citire()
{
ifstream f("data.in");
int x;
while(f>>x)
adaugare(p,u,x);
f.close();
}
int triplete(nod *p)
{
nod *q=p;
int k=0;
while(q!=NULL && q->next!=NULL && q->next-
>next!=NULL)
{
int a=q->info;
int b=q->next->info;
int c=q->next->next->info;
if (a==b+c || b==a+c || c==a+b)
k++;

q=q->next;
}
return k;
}
int main()
{
citire();
afisare(p);
cout<<triplete(p)<<" triplets.";
return 0;
}
1. Store in a linear list the grades of the n (n≤30)
students in a computer science class. The list will
contain the students' names, the number of
grades, and the average will be calculated.
a. Determine the student/students with the highest
average.
b. Display the students with averages between 9 and
10.
c. Display the grades and the average of a student
whose name is read from the keyboard.
Implementation:

#include <iostream>
#include <fstream>
#include <cstring>
using namespace std;
struct student
{
char name[30];
int number_of_grades;
int grades[5];
float average;
};
struct node
{
student info;
node* next;
};
node *head = NULL, *tail;
int n;
void add(node *&head, node *&tail, student value)
{
node *newNode = new node;
newNode->info = value;
newNode->next = NULL;

if (head == 0)
head = tail = newNode;
else
{
tail->next = newNode;
tail = newNode;
}
}
void display(node *head)
{
while (head != NULL)
{
cout << "Student: " << head->info.name << " has " <<
head->info.number_of_grades;
cout << " and the grades: ";
for (int i = 1; i <= head->info.number_of_grades; i++)
cout << head->info.grades[i] << " ";
cout << "and the average is: " << head->info.average
<< endl;
head = head->next;
}
cout << endl;
}

void read()
{
ifstream file("data.in");
student x;
file >> n;
file.get();
for (int i = 1; i <= n; i++)
{
file.get(x.name, 30);
file.get();
file >> x.number_of_grades;
int sum = 0;
for (int j = 1; j <= x.number_of_grades; j++)
{
file >> x.grades[j];
sum += x.grades[j];
}
x.average = float(sum) / x.number_of_grades;
file.get();
add(head, tail, x);
}
file.close();
}

void student_highest_average(node *head)
{
float highest_average = -1;
node *current = head;
while (head != NULL)
{
if (head->info.average > highest_average)
highest_average = head->info.average;
head = head->next;
}
while (current != NULL)
{
if (current->info.average == highest_average)
cout << current->info.name << endl;
current = current->next;
}
}
void students_9_10(node *head)
{
while (head != NULL)
{
if (head->info.average >= 9 && head->info.average <=
10)

cout << head->info.name << endl;
head = head->next;
}
}
void display_details(node *head, char name[30], bool
&ok)
{
while (head != NULL)
{
if (stricmp(head->info.name, name) == 0)
{
cout << "Student: " << name << " has the grades: ";
for (int i = 1; i <= head->info.number_of_grades; i++)
cout << head->info.grades[i] << " ";
cout << "and the average: " << head->info.average;
ok = true;
}
head = head->next;
}
}
int main()
{
read();

display(head);
///—————————
cout << "Student/Students with the highest average: " <<
endl;
student_highest_average(head);
///—————————
cout << "Students with an average in [9,10]: " << endl;
students_9_10(head);
///—————————
char name[30];
bool ok = false;
cout << "Name:"; cin.get(name, 30);
display_details(head, name, ok);
if (ok == false)
cout << "The student is not found";
return 0;
}
1. Store in a linear list the data of n (n≤300) cars in
an underground parking lot. For each car, the
following information is stored: brand, license plate
number (the format: CC-XX-LLL, where CC
represents the first 2 letters from a town/city – e.g.
for Bristol is BR; XX – represents a number in the

range [00,99]; and LLL represents random letters),
parking space (expressed as a number from 1 to
n), and the owner's name.
a. Display all owners who have a Ford car.
b. Determine which car is parked by a person whose
number is read from the keyboard.
c. Determine if there are people with more than one
car in the parking lot.
d. Display the names of car owners who are not from
Bristol.
Implementation:
#include <iostream>
#include <fstream>
#include <cstring>
using namespace std;
struct car
{
char brand[30];
char license_plate[30];
int parking_spot;
char owner[30];
};
struct node

{
car info;
node* next;
};
node *head = NULL, *tail;
int n;
void add(node *&head, node *&tail, car value)
{
node *newNode = new node;
newNode->info = value;
newNode->next = NULL;
if (head == 0)
head = tail = newNode;
else
{
tail->next = newNode;
tail = newNode;
}
}
void display(node *head)
{
while (head != NULL)
{

cout << "Car: " << head->info.brand << " license plate
number " << head->info.license_plate;
cout << " with parking spot: " << head-
>info.parking_spot;
cout << " and owner: " << head->info.owner << endl;
head = head->next;
}
cout << endl;
}
void read()
{
ifstream file("data.in");
car x;
file >> n;
file.get();
for (int i = 1; i <= n; i++)
{
file.get(x.brand, 30);
file.get();
file.get(x.license_plate, 30);
file.get();
file >> x.parking_spot;
file.get();

file.get(x.owner, 30);
file.get();
add(head, tail, x);
}
file.close();
}
void display_ford_owners(node *head, bool &ok)
{
node *current = head;
while (current != NULL)
{
if (strstr(current->info.brand, "Ford") || strstr(current-
>info.brand, "ford"))
{
cout << current->info.owner << " ";
ok = true;
}
current = current->next;
}
}
void display_owner_by_parking_spot(node *head, int spot,
bool &ok)
{

node *current = head;
while (current != NULL)
{
if (current->info.parking_spot == spot)
{
cout << "Owner: " << current->info.owner << " ";
cout << "has a car: " << current->info.brand << endl;
ok = true;
}
current = current->next;
}
}
int count_cars(node *head)
{
int counter = 0;
node *current = head;
while (current != NULL)
{
int k = 0;
node *runner = head;
while (runner != NULL)
{

if (stricmp(current->info.owner, runner->info.owner) ==
0)
k++;
runner = runner->next;
}
if (k > 1)
counter++;
current = current->next;
}
return counter;
}
void display_non_Bristol_owners(node *head, bool &ok)
{
node *current = head;
while (current != NULL)
{
if ((current->info.license_plate[0] != 'B' && current-
>info.license_plate[1] != 'R'))
{
cout << current->info.owner << " ";
ok = true;
}
current = current->next;

}
}
int main()
{
read();
display(head);
///————————
bool ok = false;
cout << "Owners who own a Ford are: ";
display_ford_owners(head, ok);
if (ok == false)
cout << "There are no Fords." << endl;
///————————
cout << endl;
int parking_spot;
cout << "Parking spot number:"; cin >> parking_spot;
ok = false;
display_owner_by_parking_spot(head, parking_spot, ok);
if (ok == false)
cout << "The spot is not assigned" << endl;
///————————
if (count_cars(head) > 1)

cout << "There are owners with more than one car in the
parking lot" << endl;
else
cout << "There are no owners with more than one car"
<< endl;
///————————
ok = false;
cout << "Owners who are not from Bristol are: ";
display_non_Bristol_owners(head, ok);
if (ok == false)
cout << "There are no owners from outside Bristol.";
return 0;
}

15.2  SINGLY LINKED LISTS.
INSERTION.
In an effort to streamline the declaration of recurring
methods and optimize time utilization, the ensuing set
of methods is designated for application in upcoming
exercises:
Declaring the structure for a node:
struct nod
{
int info;
nod*next;
};
The method to add a new node into the list:
void adaugare(nod *&p, nod*&u, int x)
{
nod * q;
q=new nod;
q->info=x;
q->next=NULL;
if(p==0)
p=u=q;
else

{
u->next=q;
u=q;
}
}
The method to display the data onto the
screen/text file:
void afisare(nod *p)
{
nod *q=p;
while(q!=NULL)
{
cout<<q->info<<" ";
q=q->next;
}
cout<<endl;
}
1. Consider a simple linear list that stores integers
with at most 4 digits each. Perform the following
operations:

a. Insert the number y after the first component that
stores the value x.
b. Insert the number y after all components that store
the value x.
c. Insert the number y before the first component
that stores the value x.
d. Insert the number y before all components that
store the value x.
e. Insert the value x after the n-th component.
f. Insert the value x before the n-th component.
Implementation:
void ReadData(nod* &p, nod* &u)
{
ifstream f("data.in");
int x;
while(f>>x)
adaugare(p,u,x);
}
//insert y after x
void inserare(nod *p, nod *&u, int x, int y)
{
nod *a,*q;
q=p;
while(q!=NULL  && q->info!=y)

q=q->next;
if(q!=NULL)
{
a=new nod;
a->info=x;
a->next=q->next;
q->next=a;
if(u==q)
u=a;
}
}
void insertAfterAllX(nod *p,int x, int y)
{
nod *q=p;
while(q!=NULL)
{
if(q->info==x)
{
nod *nodNou=new nod;
nodNou->info=y;
nodNou->next=q->next;
q->next=nodNou;
}

q=q->next;
}
}
void insertBeforeX(nod* &p, int x, int y)
{
if (p->info==x)
{
nod *nodNou=new nod;
nodNou->info=y;
nodNou->next=p;
p=nodNou;
}
else
{
nod *q = p;
while (q->next!=NULL && q->next->info!=x)
q=q->next;
if (q->next!=NULL)
{
nod *nodNou=new nod;
nodNou->info=y;
nodNou->next=q->next;
q->next=nodNou;

}
}
}
void insertBeforeAllX(nod*p, int x, int y)
{
nod *q=p,*prev=NULL;
while(q!=NULL)
{
if(q->info==x)
{
nod *nodNou=new nod;
nodNou->info=y;
nodNou->next=q;
if (prev==NULL)
p=nodNou;
else
prev->next=nodNou;
}
prev=q;
q=q->next;
}
}
void insertAfterNthNode(nod*p, int n, int x)

{
nod *temp=p;
for(int i=0; i<n && temp!=NULL; i++)
temp=temp->next;
if (temp!=NULL)
{
nod *nodNou=new nod;
nodNou->info=x;
nodNou->next=temp->next;
temp->next=nodNou;
}
}
void insertBeforeNth(nod* &p, int n, int y)
{
nod *q=p,*prev=NULL;
int k=1;
while (q!=NULL && k<n)
{
prev=q;
q=q->next;
k++;
}
if (q!=NULL)

{
nod *nodNou=new nod;
nodNou->info=y;
nodNou->next=q;
if (prev==NULL)
p=nodNou;
else
prev->next=nodNou;
}
}
int main()
{
int x,y,n;
nod *p=0, *u;
readData(p,u);
cout<<"Initial List:";
afisare(p);
///———————————————————-
cout<<"Insert y after x "<<endl;
cout<<"x=";cin>>x;
cout<<"y=";cin>>y;
inserare(p,u,y,x);
afisare(p);

///———————————————————-
cout<<"Insert y after all x"<<endl;
cout<<"x=";cin>>x;
cout<<"y=";cin>>y;
insertAfterAllX(p,x,y);
afisare(p);
///———————————————————-
cout<<"Insert y before first x"<<endl;
cout<<"x=";cin>>x;
cout<<"y=";cin>>y;
insertBeforeX(p,x,y);
afisare(p);
///———————————————————-
cout<<"Insert y after all x"<<endl;
cout<<"x=";cin>>x;
cout<<"y=";cin>>y;
insertBeforeAllX(p,x,y);
afisare(p);
///———————————————————-
cout<<"Insert x after the n-th component "<<endl;
cout<<"x=";cin>>x;
cout<<"n=";cin>>n;
insertAfterNthNode(p,n,x);

afisare(p);
///———————————————————-
cout<<"Insert x before n-th component"<<endl;
cout<<"x=";cin>>x;
cout<<"n=";cin>>n;
insertBeforeNth(p,n,x);
afisare(p);
return 0;
}
1. Consider a simple linear list that stores integers.
Insert the double of each value in the list after
each respective value.
Implementation:
void readData(nod* &p, nod* &u)
{
ifstream f("data.in");
int x;
while(f>>x)
adaugare(p,u,x);
}
void insertDouble(nod* &p)
{

nod *q=p,*prev=NULL;
while(q!=NULL)
{
prev=q;
q=q->next;
nod *nodNou=new nod;
nodNou->info=2*prev->info;
nodNou->next=q;
prev->next=nodNou;
}
}
int main()
{
nod *p=0, *u;
readData(p,u);
cout<<"Initial list:";
afisare(p);
///———————————————————-
insertDouble(p);
cout<<"Updated list:";
afisare(p);
return 0;
}

1. Consider a simple linear list that stores natural
numbers. Insert after each value in the list the
number of digits in that respective value.
Implementation:
void readData(nod* &p, nod* &u)
{
ifstream f("data.in");
int x;
while(f>>x)
adaugare(p,u,x);
}
int nr_cifre(int x)
{
int k=0;
while(x>0)
{
k++;
x/=10;
}
return k;
}
void insertDigits(nod* &p)

{
nod *q=p,*prev=NULL;
while(q!=NULL)
{
prev=q;
q=q->next;
nod *nodNou=new nod;
nodNou->info=nr_cifre(prev->info);
nodNou->next=q;
prev->next=nodNou;
}
}
int main()
{
nod *p=0, *u;
citire(p,u);
cout<<"Initial list:";
afisare(p);
///———————————————————-
insertDigits(p);
cout<<"Updated list:";
afisare(p);
return 0;

}
1. Consider a simple linear list that stores integers.
Insert the value 10 after each even number in the
list.
Implementation:
void readData(nod* &p, nod* &u)
{
ifstream f("data.in");
int x;
while(f>>x)
adaugare(p,u,x);
}
void insert10(nod* &p)
{
nod *q=p,*prev=NULL;
while (q != NULL)
{
if (q->info%2==0)
{
prev=q;
q=q->next;
nod *nodNou=new nod;

nodNou->info=10;
nodNou->next=q;
prev->next=nodNou;
}
else
{
prev=q;
q=q->next;
}
}
}
int main()
{
nod *p=0, *u;
citire(p,u);
cout<<"Initial list:";
afisare(p);
///———————————————————-
insert10(p);
cout<<"Updated list:";
afisare(p);
return 0;
}

1. Consider a simple linear list that stores integers.
Insert the sum of any two consecutive numbers
between them.
Example: If the initial list stores: 5, 3, 6, 7, it will
subsequently store: 5, 8, 3, 9, 6, 13, 7.
Implementation:
void readData(nod* &p, nod* &u)
{
ifstream f("data.in");
int x;
while(f>>x)
adaugare(p,u,x);
}
void insertSum(nod *&p)
{
nod *q=p;
while(q && q->next)
{
nod *nodNou=new nod;
nodNou->info=q->info+q->next->info;
nodNou->next=q->next;
q->next=nodNou;

q=nodNou->next;
}
}
int main()
{
nod *p=0, *u;
citire(p,u);
cout<<"Initial list:";
afisare(p);
///———————————————————-
insertSum(p);
cout<<"Updated list:";
afisare(p);
return 0;
}
1. Read n integers from the keyboard. Generate a
sorted ascending list without changing the order of
the component values later on.
Implementation:
void insertOrdered(nod* &p, int x)
{
if (p==NULL || p->info>=x)

{
nod *nodNou=new nod;
nodNou->info=x;
nodNou->next=p;
p=nodNou;
}
else
{
nod *q=p;
while(q->next!=NULL && q->next->info<x)
q=q->next;
nod *nodNou=new nod;
nodNou->info=x;
nodNou->next=q->next;
q->next=nodNou;
}
}
int main()
{
ifstream f("data.in");
int n,i,x;
nod *p=NULL;
f>>n;

for(i=1;i<=n;i++)
{
f>>x;
insertOrdered(p,x);
}
afisare(p);
return 0;
}
1. Insert the contents of a list L1 into list L2. The
insertion will be done after the first half of the list
L2.
Example: If L1 is: 2, 4, 10, 2, 3, and L2 is 5, 6, 7, 8,
then L2 will become: 5, 6, 2, 4, 10, 2, 3, 7, 8.
Implementation:
void insertList1IntoList2(nod *&list1, nod *&list2)
{
int lengthList2=0;
nod *temp=list2;
while (temp!=NULL)
{
lengthList2++;
temp=temp->next;

}
int halfList2=lengthList2/2-1;
temp=list2;
for (int i=0; i<halfList2; i++)
temp=temp->next;
nod *temp2=temp->next;
temp->next=list1;
while (temp->next != NULL)
temp=temp->next;
temp->next=temp2;
}
int main()
{
ifstream f1("data1.in");
ifstream f2("data2.in");
int i,x;
nod *p1=NULL,*u1,*p2=NULL,*u2;
while(f1>>x)
adaugare(p1,u1,x);
while(f2>>x)
adaugare(p2,u2,x);
cout<<"List 1:";
afisare(p1);

cout<<"List 2:";
afisare(p2);
insertList1IntoList2(p1,p2);
cout<<"After modification:";
afisare(p2);
return 0;
}
1. Consider a list that stores data from a library: title,
author, publication year, and the number of copies.
Insert, after each book with a publication year
earlier than the current year, an additional 10
copies from the current year.
Implementation:
#include <iostream>
#include <fstream>
#include <ctime>
using namespace std;
struct book
{
char title[30];
char author[30];
int year;

int stock;
};
struct node
{
book info;
node* next;
};
struct time
{
int year; // starting from 1900
};
int n;
void add(node*& p, node*& u, book x)
{
node* q;
q=new node;
q->info=x;
q->next=NULL;
if(p==0)
p=u=q;
else
{
u->next=q;

u=q;
}
}
void display(node* p)
{
node* q=p;
while(q!=NULL)
{
cout<<"Book '"<<q->info.title<<"' written by "<<q-
>info.author;
cout<<" published in year "<<q->info.year<<" with stock
quantity "<<q->info.stock<<endl;
q=q->next;
}
cout<<endl;
}
void read(node*& p, node*& u)
{
ifstream file("data.in");
book x;
file>>n;
for(int i=1; i<=n; i++)
{

file.get();
file.get(x.title,30);
file.get();
file.get(x.author,30);
file.get();
file>>x.year>>x.stock;
add(p,u,x);
}
}
void insert(node* p, int currentYear)
{
while(p!=NULL)
{
if(p->info.year<currentYear)
p->info.stock+=10;
p=p->next;
}
}
int main()
{
node* p = NULL, *u;
int currentYear;
read(p, u);

cout<<"List before insertion:"<<endl;
display(p);
// current date/time based on the current system
time_t now=time(0);
tm* ltm=localtime(&now);
// print various components of tm structure
currentYear=1900+ltm->tm_year;
cout<<"Current year: "<<currentYear;
insert(p, currentYear);
cout<<"After insertion:"<<endl;
display(p);
return 0;
}

15.3  SINGLY LINKED LISTS.
DELETION.
1. Consider a simple linear list that stores integers.
a. Remove the first component in the list that stores
the value x.
b. Remove from the list all components that store the
value x.
c. Remove the n-th component from the list.
Implementation:
void readData(nod *&p, nod *&u)
{
ifstream f("data.in");
int x;
while(f>>x)
adaugare(p,u,x);
}
void stergere(nod *&p,nod *&u,int x)
{
nod *a,*q;
if(p->info==x)
{
a=p;

p=p->next;
delete a;
}
else
{
q=p;
while(q->next!=NULL && q->next->info!=x)
q=q->next;
if(q->next!=NULL)
{
a=q->next;
q->next=q->next->next;
if(u==a)
u=q;
delete a;
}
else
cout<<"Value of "<<x<<" is not found!"<<endl;
}
}
void stergere_toate(nod *&p,nod *&u,int x)
{
nod *a,*q;

bool ok=false;
if(p->info==x)
{
a=p;
p=p->next;
delete a;
ok=true;
}
else
{
q=p;
while(q!=NULL && q->next!=NULL)
{
if(q->next->info==x)
{
a=q->next;
q->next=q->next->next;
if(u==a)
u=q;
delete a;
ok=true;
}
else

q=q->next;
}
}
if(ok==false)
cout<<"Value of "<<x<<" is not found!"<<endl;
}
void stergere_an_a_componenta(nod *&p,nod *&u,int n)
{
nod *q,*a;
if(p==NULL)
cout<<"Empty List";
if(n==1)
{
a=p;
p=p->next;
if(p==NULL)
u=NULL;
delete a;
}
else
{
int k=1;
q=p;

while(q->next!=NULL && k<n-1)
{
q=q->next;
k++;
}
if(q->next==NULL)
cout << "There is no component of index "<<n<<endl;
else
{
a=q->next;
q->next=a->next;
if (a==u)
u=q;
delete a;
}
}
}
int main()
{
nod*p=NULL,*u;
readData(p,u);
afisare(p);
int x;

cout<<"Delete x from the list"<<endl;
cout<<"x=";cin>>x;
stergere(p,u,x);
afisare(p);
///——————————————————————
cout<<"Delete all x from the list: "<<endl;
cout<<"x=";cin>>x;
stergere_toate(p,u,x);
afisare(p);
///——————————————————————
cout<<"Delete the n-th component "<<endl;
int n;
cout<<"n=";cin>>n;
stergere_an_a_componenta(p,u,n);
afisare(p);
return 0;
}
1. Consider a simple linear list that stores integers.
Remove all even values from the list.
Implementation:
void readData(nod *&p, nod *&u)
{

ifstream f("date.in");
int x;
while(f>>x)
adaugare(p,u,x);
}
void stergere_pare(nod *&p,nod *&u)
{
nod *q=p,*a;
while(q!=NULL)
{
if(q->info%2==0)
{
if (q==p)
{
p=q->next;
delete q;
q=p;
}
else
{
a->next=q->next;
delete q;
q=a->next;

}
}
else
{
a=q;
q=q->next;
}
}
}
int main()
{
nod*p=NULL,*u;
readData(p,u);
afisare(p);
stergere_pare(p,u);
cout<<"List after deletion: ";
afisare(p);
return 0;
}
1. Consider a simple linear list that stores integers.
Remove all non-prime values from the list.
Implementation:

void readData(nod *&p, nod *&u)
{
ifstream f("data.in");
int x;
while(f>>x)
adaugare(p,u,x);
}
bool prim(int x)
{
if(x==2)
return true;
if(x<2 || x%2==0)
return false;
for(int i=3;i<=sqrt(x);i++)
if(x%i==0)
return false;
return true;
}
void stergere_pare(nod *&p,nod *&u)
{
nod *q=p,*a;
while(q!=NULL)
{

if(!prim(q->info))
{
if (q==p)
{
p=q->next;
delete q;
q=p;
}
else
{
a->next=q->next;
delete q;
q=a->next;
}
}
else
{
a=q;
q=q->next;
}
}
}
int main()

{
nod*p=NULL,*u;
readData(p,u);
afisare(p);
stergere_pare(p,u);
cout<<"List after deletion: ";
afisare(p);
return 0;
}
1. Consider a simple linear list that stores integers.
Move all zeros to the beginning of the list without
changing the order of the other values in the list.
Example: If the list contains: 3, 4, 0, 5, 0, 0, 8, the
result should be: 0, 0, 0, 3, 4, 5, 8.
Implementation:
void readData(nod *&p, nod *&u)
{
ifstream f("data.in");
int x;
while(f>>x)
adaugare(p,u,x);
}

void mutare_zerouri(nod *&p)
{
nod *q=p,*t,*pre=NULL;
while (q)
{
if (q->info==0)
{
t=q;
if(pre==NULL)
p=q->next;
else
pre->next=q->next;
q=q->next;
t->next=p;
p=t;
}
else
{
pre=q;
q=q->next;
}
}
}

int main()
{
nod*p=NULL,*u;
readData(p,u);
afisare(p);
cout<<"List after deletion: ";
mutare_zerouri(p);
afisare(p);
return 0;
}
1. Remove the middle element(s) from a singly linked
list that stores integers.
Implementation:
void readData(nod *&p, nod *&u)
{
ifstream f("data.in");
int x;
while(f>>x)
adaugare(p,u,x);
}
void stergere_mijloc(nod *p)
{

nod *q=p,*r=p;
nod *prev=NULL;
while(r!=NULL && r->next!=NULL)
{
r=r->next->next;
prev=q;
q=q->next;
}
prev->next=q->next;
delete q;
}
int main()
{
nod*p=NULL,*u;
readData(p,u);
afisare(p);
cout<<"List after deletion: ";
stergere_mijloc(p);
afisare(p);
return 0;
}

1. Remove the second, fourth, sixth, etc., element
from a singly linked list that stores integers.
Implementation:
void readData(nod *&p, nod *&u)
{
ifstream f("data.in");
int x;
while(f>>x)
adaugare(p,u,x);
}
void stergere(nod *p)
{
int i=1;
nod *q=p,*prev=NULL;
while(q!=NULL)
{
if (i%2==0)
{
prev->next=q->next;
delete q;
q=prev->next;
}

else
{
prev=q;
q=q->next;
}
i++;
}
}
int main()
{
nod*p=NULL,*u;
readData(p,u);
afisare(p);
cout<<"List after modification: ";
stergere(p);
afisare(p);
return 0;
}
1. Remove components from a singly linked list that
stores integers so that any two adjacent values
have distinct values.

Example: If the list contains: 2, 3, 3, 3, 4, 4, 3, 5, 5,
5, the result should be: 2, 3, 4, 3, 5.
Implementation:
void readData(nod *&p, nod *&u)
{
ifstream f("data.in");
int x;
while(f>>x)
adaugare(p,u,x);
}
void stergere(nod *p)
{
nod *q=p,*prev=NULL;
while(q!=NULL && q->next!=NULL)
{
if(q->info==q->next->info)
{
prev->next=q->next;
delete q;
q=prev->next;
}
else

{
prev=q;
q=q->next;
}
}
}
int main()
{
nod*p=NULL,*u;
readData(p,u);
afisare(p);
cout<<"List after modification: ";
stergere(p);
afisare(p);
return 0;
}
1. Determine the number of elements that make up
the longest increasing sequence of integers in a
list.
Example: If the list contains: 5, 6, 7, 1, 2, 6, 8, 9, 1,
2, the result should be the value 5.
Implementation:

void readData(nod *&p, nod *&u)
{
ifstream f("data.in");
int x;
while(f>>x)
adaugare(p,u,x);
}
int lungimeSecventaCrescatoare(nod *p)
{
int lungimeMaxima=0;
int lungimeCurenta=0;
nod *q=p;
while(q!=NULL && q->next!=NULL)
{
if(q->info<q->next->info)
{
lungimeCurenta++;
q=q->next;
}
else
{
if(lungimeCurenta>lungimeMaxima)
lungimeMaxima=lungimeCurenta;

lungimeCurenta=0;
q=q->next;
}
}
if(lungimeCurenta>lungimeMaxima)
lungimeMaxima=lungimeCurenta;
return lungimeMaxima+1;
}
int main()
{
nod*p=NULL,*u;
readData(p,u);
afisare(p);
cout<<"The longest sequence has the length: ";
cout<<lungimeSecventaCrescatoare(p);
return 0;
}
1. Generate a singly linked list that stores the longest
increasing sequence of integers from a given list of
integers. In case the initial list contains multiple
such sequences, one of them is extracted.

Example: If the initial list contains: 5, 6, 7, 1, 2, 6,
8, 9, 1, 2, then the generated list will store the values:
1, 2, 6, 8, 9.
Implementation:
void readData(nod *&p, nod *&u)
{
ifstream f("data.in");
int x;
while(f>>x)
adaugare(p,u,x);
}
void secventaMaxima(nod *p, nod *&startMax, nod
*&finalMax)
{
nod *start=p,*final=p,*q=p->next;
int lgMax=1,lg=1;
while(q!=NULL)
{
if(q->info>final->info)
{
final=q;
lg++;
if(lg>lgMax)

{
lgMax=lg;
startMax=start;
finalMax=final;
}
}
else
{
start=q;
final=q;
lg=1;
}
q=q->next;
}
}
void afisareSecventa(nod *startMax, nod *finalMax)
{
nod *q=startMax;
while(q!=finalMax->next)
{
cout<<q->info<<" ";
q=q->next;
}

}
int main()
{
nod *p=NULL,*u,*startMax=NULL,*finalMax=NULL;
readData(p,u);
afisare(p);
secventaMaxima(p,startMax,finalMax);
cout<<"Longest increasing sequence: ";
afisareSecventa(startMax, finalMax);
return 0;
}
1. Generate a singly linked list that stores the data of
students from a school: students' names, previous
year's average, and class. Remove students from
the twelfth grade from the list.
Implementation:
#include <iostream>
#include <fstream>
#include <cstring>
using namespace std;
struct student
{

char name[50];
float average;
char grade[5];
};
struct node
{
student info;
node* next;
};
int n;
void add(node*& p, node*& u, student x)
{
node* q;
q=new node;
q->info=x;
q->next=NULL;
if(p==0)
p=u=q;
else
{
u->next=q;
u=q;
}

}
void display(node* p)
{
node* q=p;
while(q!=NULL)
{
cout<<"Student: "<<q->info.name<<" has an average
of: ";
cout<<q->info.average<<" and is in grade: "<<q-
>info.grade<<endl;
q=q->next;
}
cout<<endl;
}
void read(node*& p, node*& u)
{
ifstream file("data.in");
student x;
file>>n;
for(int i=1; i<=n; i++)
{
file.get();
file.get(x.name,50);

file.get();
file>>x.average;
file.get();
file.get(x.grade,5);
add(p,u,x);
}
}
void removal(node*& p, node*& u)
{
node* a, * q;
bool found=false;
q=p;
while(q!=NULL)
{
if(strcmpi(q->info.grade,"XII")==0)
{
found=true;
if(q==p)
{
p=q->next;
a=q;
q=q->next;
delete a;

}
else
{
a=q;
q=q->next;
u->next=q;
delete a;
}
}
else
{
u=q;
q=q->next;
}
}
if(!found)
cout<<"No students found in the twelfth grade."<<endl;
}
int main()
{
node* p=NULL, *u;
read(p,u);
cout<<"List before removal:"<<endl;

display(p);
removal(p,u);
cout<<"List after removal:"<<endl;
display(p);
return 0;
}

15.4  SINGLY LINKED LISTS.
SORTING. MERGING.
1. Consider a singly linked list that stores integers.
Sort the values in the list in ascending order.
Implementation:
void readData(nod *&p, nod *&u)
{
ifstream f("data.in");
int x;
while(f>>x)
adaugare(p,u,x);
}
void interschimbare(int x,int y)
{
int aux=x;
x=y;
y=aux;
}
void ordonare(nod *p)
{
int ok;
nod *q;

nod *r=NULL;
do
{
ok=0;
q=p;
while(q->next!=r)
{
if (q->info > q->next->info)
{
swap(q->info,q->next->info);
ok=1;
}
q=q->next;
}
r=q;
}while(ok);
}
int main()
{
nod *p=NULL,*u;
readData(p,u);
afisare(p);
ordonare(p);

cout<<"The list in ascending order:";
afisare(p);
return 0;
}
1. Consider two singly linked lists that store integers.
Concatenate the two lists in a way that the second
list is added to the end of the first list. Sort the
values in the resulting list in ascending order.
Implementation:
void readData(nod *&p1, nod *&u1,nod *&p2,nod *&u2)
{
ifstream f("data.in");
ifstream g("data1.in");
int x;
while(f>>x)
adaugare(p1,u1,x);
while(g>>x)
adaugare(p2,u2,x);
f.close();
g.close();
}
nod *concatenare(nod *p1,nod *p2)

{
if(p1 == NULL)
return p2;
nod *p=p1;
while(p->next!=NULL)
p=p->next;
p->next=p2;
return p1;
}
nod *sortare(nod *p)
{
nod *p1,*p2,*p3;
p1=p;
while(p1!=NULL)
{
p2=p1->next;
while(p2!=NULL)
{
if(p2->info < p1->info)
{
int temp=p1->info;
p1->info=p2->info;
p2->info=temp;

}
p2=p2->next;
}
p1=p1->next;
}
return p;
}
int main()
{
nod *p1=NULL,*u1,*p2=NULL,*u2;
citire(p1,u1,p2,u2);
cout<<"1st list:";
afisare(p1);
cout<<"2nd list:";
afisare(p2);
cout<<"After concatenation:"<<endl;
p1=concatenare(p1, p2);
p1=sortare(p1);
afisare(p1);
return 0;
}

1. Consider a singly linked list that stores the names
of products and their prices.
a. Sort the contents of the list alphabetically based on
the product names.
b. Sort the contents of the list in descending order
based on the prices.
Implementation:
#include <iostream>
#include <fstream>
#include <cstring>
using namespace std;
struct product
{
char name[30];
float price;
};
struct node
{
product info;
node* next;
};
void add(node*& p, node*& u, product x)

{
node* q=new node;
q->info=x;
q->next=NULL;
if(p==0)
p=u=q;
else
{
u->next=q;
u=q;
}
}
void display(node* p)
{
node* q=p;
while(q!=NULL)
{
cout<<"Product "<<q->info.name<<" has a price of "
<<q->info.price<<endl;
q=q->next;
}
cout<<endl;
}

int n;
void read(node*& p, node*& u)
{
ifstream file("data.in");
product x;
file>>n;
for(int i=1; i<=n; i++)
{
file.get();
file.get(x.name,30);
file.get();
file>>x.price;
add(p,u,x);
}
file.close();
}
void alphabetical_sort(node* p)
{
node* p1,*p2;
p1=p;
while(p1!=NULL)
{
p2=p1->next;

while(p2!=NULL)
{
if(stricmp(p1->info.name,p2->info.name)>0)
{
product temp=p1->info;
p1->info=p2->info;
p2->info=temp;
}
p2=p2->next;
}
p1=p1->next;
}
}
void descending_price_sort(node* p)
{
node* p1, *p2;
p1=p;
while(p1!=NULL)
{
p2=p1->next;
while(p2!=NULL)
{
if(p1->info.price < p2->info.price)

{
product temp=p1->info;
p1->info=p2->info;
p2->info=temp;
}
p2=p2->next;
}
p1=p1->next;
}
}
int main()
{
node* p=NULL, *u;
read(p,u);
display(p);
cout<<"Alphabetical sort by name: "<<endl;
alphabetical_sort(p);
display(p);
cout<<"Descending sort by price: "<<endl;
descending_price_sort(p);
display(p);
return 0;
}

1. Consider a singly linked list that stores strings of
characters (lowercase letters and spaces). Each
string cannot exceed 100 characters. Sort the list
in descending order based on the number of
characters in each string.
Implementation:
int n;
void readData(nod *&p, nod *&u)
{
ifstream f("data.in");
char x[100];
while(f.get(x,100))
{
adaugare(p,u,x);
f.get();
}
f.close();
}
void ordonare(nod *p)
{
nod *p1,*p2;
p1=p;
while(p1!=NULL)

{
p2=p1->next;
while(p2!=NULL)
{
if(strlen(p1->info) < strlen(p2->info))
{
char temp[100];
strcpy(temp,p1->info);
strcpy(p1->info,p2->info);
strcpy(p2->info,temp);
}
p2=p2->next;
}
p1=p1->next;
}
}
int main()
{
nod *p=NULL,*u;
readData(p,u);
afisare(p);
cout<<"List after modification:"<<endl;
ordonare(p);

afisare(p);
return 0;
}
1. Let there be two simple linear lists that store
ordered integers. Generate a third list that stores
the values from the two lists in ascending order.
Implementation:
void readData(nod *&p1, nod *&u1,nod *&p2,nod *&u2)
{
ifstream f("data.in");
ifstream g("data1.in");
int x;
while(f>>x)
adaugare(p1,u1,x);
while(g>>x)
adaugare(p2,u2,x);
f.close();
g.close();
}
void interclasare(nod *p1, nod *p2, nod *&p, nod *&u)
{
nod *q1=p1,*q2=p2;

while (q1!=NULL && q2!=NULL)
{
if (q1->info <= q2->info)
{
adaugare(p,u,q1->info);
q1=q1->next;
}
else
{
adaugare(p,u,q2->info);
q2=q2->next;
}
}
while (q1!=NULL)
{
adaugare(p,u,q1->info);
q1=q1->next;
}
while (q2 != NULL)
{
adaugare(p,u,q2->info);
q2=q2->next;
}

}
int main()
{
nod *p1=NULL,*u1,*p2=NULL,*u2;
readData(p1,u1,p2,u2);
cout<<"1st List:";
afisare(p1);
cout<<"2nd List:";
afisare(p2);
nod *pf=NULL,*uf;
cout<<"Obtained list after merging:"<<endl;
interclasare(p1,p2,pf,uf);
afisare(pf);
return 0;
}
1. Let there be two simple linear lists that store
distinct, ordered integers. Generate a third list that
stores values from the two lists in ascending order,
taken only once.
Implementation:
void readData(nod *&p1, nod *&u1,nod *&p2,nod *&u2)
{

ifstream f("data.in");
ifstream g("data1.in");
int x;
while(f>>x)
adaugare(p1,u1,x);
while(g>>x)
adaugare(p2,u2,x);
f.close();
g.close();
}
void interclasare(nod *p1, nod *p2, nod *&p, nod *&u)
{
p=u=NULL;
nod *q1=p1, *q2=p2;
while(q1!=NULL && q2!=NULL)
{
if(q1->info < q2->info)
{
// Check if the value is already in the new list
if(u==NULL || u->info != q1->info)
adaugare(p, u, q1->info);
q1 = q1->next;
}

else if(q2->info < q1->info)
{
// Check if the value is already in the new list
if(u==NULL || u->info != q2->info)
adaugare(p, u, q2->info);
q2=q2->next;
}
else
{
// Check if the value is already in the new list
if(u==NULL || u->info != q1->info)
adaugare(p, u, q1->info);
q1=q1->next;
q2=q2->next;
}
}
while(q1!=NULL)
{
//Check if the value is already in the new list
if(u==NULL || u->info != q1->info)
adaugare(p, u, q1->info);
q1=q1->next;
}

while(q2!=NULL)
{
// Check if the value is already in the new list
if(u==NULL || u->info != q2->info)
adaugare(p, u, q2->info);
q2 = q2->next;
}
}
int main()
{
nod *p1=NULL,*u1,*p2=NULL,*u2;
readData(p1,u1,p2,u2);
cout<<"1st list:";
afisare(p1);
cout<<"2nd list:";
afisare(p2);
nod *pf=NULL,*uf;
cout<<"Obtained list after merging:"<<endl;
interclasare(p1,p2,pf,uf);
afisare(pf);
return 0;
}

1. Let there be two simple linear lists that store
ordered integers. The first list stores even
numbers, while the second one stores odd
numbers. Generate a third list that stores values
from the two lists in ascending order, in such a way
that there are no two consecutive values with the
same parity, and the list is sorted in ascending
order.
Implementation:
void readData(nod *&p1, nod *&u1,nod *&p2,nod *&u2)
{
ifstream f("data.in");
ifstream g("data1.in");
int x;
while(f>>x)
adaugare(p1,u1,x);
while(g>>x)
adaugare(p2,u2,x);
f.close();
g.close();
}
nod* generare(nod *p1,nod *p2)
{

nod *p3=NULL,*u3=NULL;
nod *q1=p1,*q2=p2;
while (q1!=NULL && q2!=NULL)
{
if (q1->info < q2->info && q1->info%2!=q2->info%2)
{
adaugare(p3,u3,q1->info);
q1=q1->next;
}
else if(q1->info > q2->info && q1->info%2!=q2-
>info%2)
{
adaugare(p3,u3,q2->info);
q2 = q2->next;
}
else
{
q1=q1->next;
q2=q2->next;
}
}
return p3;
}

int main()
{
nod *p1=NULL,*u1,*p2=NULL,*u2;
readData(p1,u1,p2,u2);
cout<<"Obtained list:"<<endl;
nod *p3 = generare(p1,p2);
afisare(p3);
return 0;
}
1. Let there be a linear list L1 that stores integers
with at most 9 digits each. Generate the list L2 that
stores the digits of the numbers in L1 in ascending
order.
Implementation:
void readData(nod *&p, nod *&u)
{
ifstream f("data.in");
int x;
while(f>>x)
adaugare(p,u,x);
f.close();
}

void adauga_cifre(nod *&p, int n)
{
if(n<0)
n=n*(-1);
while(n>0)
{
int cifra=n%10;
nod *q=p;
nod *ant=NULL;
while(q!=NULL && q->info<cifra)
{
ant=q;
q=q->next;
}
nod *nou=new nod;
nou->info=cifra;
nou->next=q;
if (ant==NULL)
p=nou;
else
ant->next=nou;
n/=10;
}

}
void generare(nod *p1, nod *&p2)
{
nod *q=p1;
while(q!=NULL)
{
adauga_cifre(p2,q->info);
q=q->next;
}
}
int main()
{
nod *p=NULL,*u,*p2=NULL;
readData(p,u);
afisare(p);
generare(p,p2);
cout<<"The generated list: ";
afisare(p2);
return 0;
}

15.5  DOUBLY LINKED LISTS
In an effort to streamline the declaration of recurring
methods and optimize time utilization, the ensuing set
of methods is designated for application in upcoming
exercises:
Declaring the structure for a node:
struct nod
{
int info;
nod *next;
nod *back;
};
The method to add a new node into the list:
void adaugare(nod *&p,nod *&u,int x)
{
nod *q;
q=new nod;
q->info=x;
q->next=NULL;
if(p==0)
{
q->back=NULL;

p=u=q;
}
else
{
u->next=q;
q->back=u;
u=q;
}
}
void afisare(nod *p)
{
nod *q=p;
while(q!=NULL)
{
cout<<q->info<<" ";
q=q->next;
}
cout<<endl;
}
The method to display the data onto the
screen/text file:
void afisare(nod *p)
{

nod *q=p;
while(q!=NULL)
{
cout<<q->info<<" ";
q=q->next;
}
cout<<endl;
}
1. Store in a doubly linked linear list the non-zero
integers from the file data.in that contains
integers.
a. Display the numbers in the list in the order they
were read from the file.
b. Display the numbers in the list in reverse order of
reading from the file.
c. Display the first, third, fifth, etc. element from the
list.
d. Insert after each perfect square the next natural
number.
e. Insert before each odd number the value 1.
f. Remove from the list all values that have a units
digit equal to 0.
g. Insert between any two values their sum.

Implementation:
void readData(nod *&p,nod *&u)
{
ifstream f("data.in");
int x;
while(f>>x)
adaugare(p,u,x);
}
void afisare_inversa(nod *u)
{
nod *q=u;
while(q!=NULL)
{
cout<<q->info<<" ";
q=q->back;
}
cout<<endl;
}
void afisare_impare(nod *p)
{
nod *q=p;
int i=1;

while(q!=NULL)
{
if(i%2==1)
cout<<q->info<<" ";
i++;
q=q->next;
}
cout<<endl;
}
void inserare_dupa_patrat(nod *&p, nod *&u)
{
nod *q=p;
while (q!=NULL)
{
if (sqrt(q->info)==int(sqrt(q->info)))
{ // check if it’s a square number
nod *nou=new nod;
nou->info=q->info+1; // add next number
nou->next=q->next;
if (q->next != NULL)
q->next->back=nou;
else
u=nou;

q->next=nou;
nou->back=q;
q=nou->next;// skip the current number and check next
}
else
q=q->next;
}
}
void inserare_1(nod *&p)
{
nod *q=p;
while (q!=NULL)
{
if (q->info%2==1)
{
nod *nou=new nod;
nou->info=1;
nou->back=q->back;
nou->next=q;
if (q->back!=NULL)
q->back->next=nou;
else
p=nou;

q->back=nou;
}
q=q->next;
}
}
void stergere_uc0(nod *&p,nod *&u)
{
nod *q=p;
while(q!=NULL)
{
if(q->info%10==0)
{
if(q->back!=NULL)
q->back->next=q->next;
else
p=q->next;
if(q->next!=NULL)
q->next->back=q->back;
else
u=q->back;
nod *temp=q;
q=q->next;
delete temp;

}
else q=q->next;
}
}
void inserare_suma(nod *&p,nod *&u)
{
nod *q=p;
while(q!=NULL && q->next!=NULL)
{
nod *new_node=new nod;
new_node->info=q->info+q->next->info;
new_node->next=q->next;
q->next->back=new_node;
new_node->back=q;
q->next=new_node;
q=new_node->next;
if(q==NULL)
u=new_node;
}
}
int main()
{
nod *p=0,*u;

citire(p,u);
// a)
afisare(p);
// b)
afisare_inversa(u);
// c)
afisare_impare(p);
// d)
inserare_dupa_patrat(p,u);
afisare(p);
// e)
inserare_1(p);
afisare(p);
// f)
stergere_uc0(p,u);
afisare(p);
// g)
inserare_suma(p,u);
afisare(p);
return 0;
}

1. The books in a library, including title, author,
publisher, number of copies, and year of
publication, are stored in a doubly linked list.
a. Display all books from a publisher whose name is
entered from the keyboard.
b. Display the book with the maximum number of
copies.
c. Knowing that x books are received from publisher
y, authored by z, update the content of the list
accordingly.
d. Remove from the library those books with a
publication year earlier than 2000.
e. Display all titles of books by author x.
f. Display the last 3 books registered in the library.
Implementation:
#include <iostream>
#include <fstream>
#include <cstring>
using namespace std;
struct book
{
char title[30];
char author[30];
char publisher[30];

int num_pieces;
int year;
};
struct node
{
book info;
node *next;
node *prev;
};
void add(node *&head, node *&tail, book x)
{
node *newNode = new node;
newNode->info = x;
newNode->next = nullptr;
if (head == nullptr)
{
newNode->prev = nullptr;
head = tail = newNode;
}
else
{
tail->next = newNode;
newNode->prev = tail;

tail = newNode;
}
}
void display(node *head)
{
node *current = head;
while (current != nullptr)
{
cout << "Book '" << current->info.title << "' written by "
<< current->info.author;
cout << " belongs to the publisher " << current-
>info.publisher << " with available stock " << current-
>info.num_pieces;
cout << " published in the year " << current->info.year
<< endl;
current = current->next;
}
cout << endl;
}
int n;
void read(node *&head, node *&tail)
{
ifstream file("data.in");

book x;
file >> n;
file.ignore();
for (int i = 1; i <= n; i++)
{
file.get(x.title, 30);
file.ignore();
file.get(x.author, 30);
file.ignore();
file.get(x.publisher, 30);
file.ignore();
file >> x.num_pieces >> x.year;
add(head, tail, x);
}
}
bool ok = false;
void display_books_by_publisher(node *head, char
publisher[30])
{
node *current = head;
while (current != nullptr)
{
if (strcmp(current->info.publisher, publisher) == 0)

{
cout << current->info.title << " ";
ok = true;
}
current = current->next;
}
cout << endl;
}
void display_max_pieces(node *head)
{
int maxi = -1;
node *max_node = nullptr;
while (head != nullptr)
{
if (head->info.num_pieces > maxi)
{
maxi = head->info.num_pieces;
max_node = head;
}
head = head->next;
}
if (max_node != nullptr)

cout << "The book with the maximum stock is: " <<
max_node->info.title << endl;
else
cout << "There are no books in the library." << endl;
}
void update(node *head, int x, char publisher[30], char
author[30])
{
node *current = head;
while (current != nullptr)
{
if (strcmp(current->info.publisher, publisher) == 0 &&
strcmp(current->info.author, author) == 0)
{
current->info.num_pieces += x;
ok = true;
}
current = current->next;
}
}
void delete_books_before_year(node *&head, node *&tail)
{
node *current = head;

while (current != nullptr)
{
if (current->info.year < 2000)
{
if (current->prev != nullptr)
current->prev->next = current->next;
else
head = current->next;
if (current->next != nullptr)
current->next->prev = current->prev;
else
tail = current->prev;
node *temp = current;
current = current->next;
delete temp;
}
else
current = current->next;
}
}
void display_books_by_author(node *head, char
author[30])
{

node *current = head;
while (current != nullptr)
{
if (strcmp(current->info.author, author) == 0)
{
cout << current->info.title << " ";
ok = true;
}
current = current->next;
}
cout << endl;
}
void display_last_3(node *tail)
{
node *current = tail;
int counter = 0;
while (current != nullptr && counter < 3)
{
cout << "Book '" << current->info.title << "' written by "
<< current->info.author;
cout << " belongs to the publisher " << current-
>info.publisher << " with available stock " << current-
>info.num_pieces;

cout << " published in the year " << current->info.year
<< endl;
current = current->prev;
counter++;
}
}
int main()
{
node *head = nullptr, *tail = nullptr;
read(head, tail);
display(head);
char publisher[30];
cout << "Publisher: ";
cin.get(publisher, 30);
display_books_by_publisher(head, publisher);
if (!ok)
cout << "The publisher does not exist." << endl;
///————————————————-
display_max_pieces(head);
///————————————————-
int x;
ok = false;
char y[30], z[30];

cout << "Number of books: ";
cin >> x;
cin.ignore();
cout << "Publisher: ";
cin.get(y, 30);
cin.ignore();
cout << "Author: ";
cin.get(z, 30);
update(head, x, y, z);
if (!ok)
cout << "The publisher/author does not exist" << endl;
else
display(head);
///————————————————-
cout << endl
<< "Deleting books with the publication year < 2000" <<
endl;
delete_books_before_year(head, tail);
display(head);
///————————————————-
cin.ignore();
cout << "Author: ";
cin.get(z, 30);

ok = false;
display_books_by_author(head, z);
if (!ok)
cout << "The author was not found" << endl;
///————————————————-
display_last_3(tail);
return 0;
}
1. Read n (n≤100) character strings. Determine if
the n strings form a palindromic sequence. Display
Yes or No.
Example: If the following strings are read: n=5,
"ana", "are", "mere", "are", "ana", the output will be
Yes.
Implementation:
struct nod
{
char info[100];
nod *next;
nod *back;
};
void adaugare(nod *&p,nod *&u,char x[100])

{
nod *q;
q=new nod;
strcpy(q->info,x);
q->next=NULL;
if(p==0)
{
q->back=NULL;
p=u=q;
}
else
{
u->next=q;
q->back=u;
u=q;
}
}
int n;
void read(nod *&p,nod *&u)
{
ifstream f("data.in");
char sir[100];
f>>n;

for(int i=1;i<=n;i++)
{
f.get();
f.get(sir,100);
adaugare(p,u,sir);
}
}
bool estePalindrom(nod *p, nod *u)
{
// go through the list from start to end
while(p!=NULL && u!=NULL && p!=u && p->back!=u)
{
// if the elements are not the same
if(strcmp(p->info,u->info) != 0)
return false; // it’s not a palindrome
p=p->next;//go to the next element
u=u->back; // go to the preccedent element
}
return true;// list is a palindrome
}
int main()
{
nod *p=0,*u;

read(p,u);
afisare(p);
if(estePalindrom(p,u))
cout<<"Yes";
else
cout<<"No";
return 0;
}
1. Let there be a singly linked list that stores integers.
Generate three doubly linked lists as follows:
-  The first list stores numbers divisible by 3.
-  The second list stores numbers that leave a
remainder of 1 when divided by 3.
-  The third list stores numbers that leave a remainder
of 2 when divided by 3.
Implementation:
void readData(nod *&p,nod *&u)
{
ifstream f("data.in");
int x;

while(f>>x)
adaugare(p,u,x);
}
void adaugare_div3(nod *&p_div3,nod *&u_div3,nod
*&p,nod *&u)
{
nod *q=p;
while(q!=NULL)
{
if(q->info%3==0)
adaugare(p_div3,u_div3,q->info);
q=q->next;
}
}
void adaugare_rest1(nod *&p_rest1,nod *&u_rest1,nod
*&p,nod *&u)
{
nod *q=p;
while(q!=NULL)
{
if (q->info%3==1)
adaugare(p_rest1, u_rest1, q->info);
q=q->next;

}
}
void adaugare_rest2(nod *&p_rest2,nod *&u_rest2,nod
*&p,nod *&u)
{
nod *q=p;
while(q!=NULL)
{
if(q->info%3==2)
adaugare(p_rest2,u_rest2,q->info);
q = q->next;
}
}
int main()
{
nod *p=0,*u;
readData(p,u);
nod *p_div3=0,*u_div3=0;
adaugare_div3(p_div3,u_div3,p,u);
///————————————————————-
nod *p_rest1=0,*u_rest1=0;
adaugare_rest1(p_rest1,u_rest1,p,u);
///————————————————————-

nod *p_rest2=0,*u_rest2=0;
adaugare_rest2(p_rest2,u_rest2,p,u);
///————————————————————-
cout<<"Divisible numbers of 3: ";
afisare(p_div3);
///————————————————————-
cout<<"Numbers with remainder 1 by dividing them by 3:
";
afisare(p_rest1);
///————————————————————-
cout<<"Numbers with remainder 2 by dividing them by 3:
";
afisare(p_rest2);
return 0;
}
1. Let there be a doubly linked list that stores
integers. Generate another list to store the
elements at even positions without creating new
elements, and in the first list, keep only the
elements at odd positions.
Example: If the initial list stores: 3, 4, 5, 7, 2, 1, it
will subsequently retain the elements with values: 3, 5,

2, and the second list will contain the elements: 4, 7,
1.
Implementation:
void readData(nod *&p,nod *&u)
{
ifstream f("data.in");
int x;
while(f>>x)
adaugare(p,u,x);
}
void stergere(nod *&p, nod *&u, nod *q)
{
if (q==p)
{
p=p->next;
if(p)
p->back=NULL;
else
u=NULL;
delete q;
}
else if (q==u)
{

u=u->back;
if(u)
u->next=NULL;
else
p=NULL;
delete q;
}
else
{
q->back->next = q->next;
q->next->back = q->back;
delete q;
}
}
void separare(nod *&p1, nod *&u1, nod *&p2, nod *&u2)
{
nod *q1=p1,*q2;
int i=1;
while (q1!=NULL)
{
if (i%2==0)
{
q2=new nod;

q2->info=q1->info;
q2->next=NULL;
if (p2==NULL)
{
q2->back=NULL;
p2=u2=q2;
}
else
{
u2->next=q2;
q2->back=u2;
u2=q2;
}
nod *temp = q1;
q1=q1->next;
stergere(p1,u1,temp);
}
else
{
q1=q1->next;
}
i++;
}

}
int main()
{
nod *p=0,*u,*p2=0,*u2;;
readData(p,u);
separare(p, u, p2, u2);
cout<<"List without elements from even index: ";
afisare(p);
cout<<"Lists with nodes with even index: ";
afisare(p2);
return 0;
}
1. Generate a doubly linked list that stores: the
names of n students in a class, and for each
student, a value k representing the number of
grades in a subject, the grades, and the calculated
average. Determine:
a. The student with the highest average. If there are
multiple students, display all.
b. Display the data of a student whose name is read
from the keyboard.
c. Display the data in alphabetical order.

d. Remove a student from the list whose name is read
from the keyboard.
e. Display the data in descending order by average.
f. Write the data of students with averages above 9
to the file bursary.txt.
Implementation:
struct elev
{
char nume[30];
int n1,n2;
float medie;
};
struct nod
{
elev info;
nod *next;
nod *back;
};
void adaugare(nod *&p,nod *&u,elev x)
{
nod *q;
q=new nod;
q->info=x;

q->next=NULL;
if(p==0)
{
q->back=NULL;
p=u=q;
}
else
{
u->next=q;
q->back=u;
u=q;
}
}
void afisare(nod *p)
{
nod *q=p;
while(q!=NULL)
{
cout<<"Student "<<q->info.nume<<" has grades "<<q-
>info.n1<<" ";
cout<<q->info.n2<<" and final mark "<<q-
>info.medie<<endl;
q=q->next;

}
cout<<endl;
}
int n,i,ok;
void readData(nod *&p,nod *&u)
{
elev x;
ifstream f("data.in");
f>>n;
for(i=1; i<=n; i++)
{
f.get();
f.get(x.nume,30);
f.get();
f>>x.n1>>x.n2;
x.medie=(float)(x.n1+x.n2)/2;
adaugare(p,u,x);
}
}
void cautare_elev(nod *p,char s[30])
{
nod *q=p;
while(q!=NULL)

{
if(stricmp(s,q->info.nume)==0)
{
cout<<"Student "<<q->info.nume<<" has grades "<<q-
>info.n1<<" ";
cout<<q->info.n2<<" and final mark"<<q-
>info.medie<<endl;
ok=1;
}
q=q->next;
}
cout<<endl;
}
void cautare_corigenti(nod *p)
{
nod *q=p;
while(q!=NULL)
{
if(q->info.medie<5.0)
{
//Display info about student
}
q=q->next;

}
cout<<endl;
}
void inserare_elev_sfarsit(nod *p,elev x)
{
nod *a,*q;
a=new nod;
a->info=x;
a->next=NULL;
a->back=NULL;
if(p==0)
p=a;
else
{
nod *q=p;
while(q->next!=NULL)
q=q->next;
q->next=a;
a->back=q;
}
}
void stergere(nod *&p,nod *&u,nod *q)
{

nod *a;
if(p==q)
{
a=q;
p=p->next;
}
else if(u==q)
{
a=q;
u=u->back;
u->next=NULL;
}
else
{
q->back->next=q->next;
q->next->back=q->back;
}
delete a;
}
void stergere_elev_corigent(nod *&p,nod *&u)
{
nod *q=p;
while(q->next!=NULL)

if(q->info.medie<5.0)
{
q=q->next;
stergere(p,u,q->back);
ok=1;
}
else
q=q->next;
if(u->info.medie<5.0)
{
stergere(p,u,u);
ok=1;
}
}
void ordonare_crescator_medie(nod *p,nod *u)
{
nod *q;
int ok;
elev aux;
do
{
q=p;
ok=1;

while(q->next!=NULL)
{
if(q->info.medie>q->next->info.medie)
{
aux=q->info;
q->info=q->next->info;
q->next->info=aux;
ok=0;
}
q=q->next;
}
}
while(ok==0);
}
ofstream g("bursary.txt");
void burse(nod *p)
{
nod *q=p;
while(q!=NULL)
{
if(q->info.medie>=9.0)
g<<q->info.nume<<" has final mark "<<q-
>info.medie<<endl;

q=q->next;
}
cout<<endl;
}
int main()
{
nod *p=0,*u;
readData(p,u);
afisare(p);
///———
char s[30];
cout<<"Name of a student: ";
cin.get(s,30);
cautare_elev(p,s);
if(ok==0)
cout<<"No Student found!"<<endl;
///———
cout<<"Students who failed a subject!"<<endl;
ok=0;
cautare_corigenti(p);
if(ok==0)
cout<<"No students found!"<<endl;
///———

cout<<"Insert a new student onto the list!"<<endl;
cin.get();
elev x;
cout<<"Name of a student:";
cin.get(x.nume,30);
cin.get();
cout<<"1st mark: ";
cin>>x.n1;
cout<<"2nd mark: ";
cin>>x.n2;
x.medie=(float)(x.n1+x.n2)/2;
inserare_elev_sfarsit(p,x);
afisare(p);
///———
ok=0;
cout<<"Delete students who failed: "<<endl;
cout<<endl;
stergere_elev_corigent(p,u);
if(ok==0)
cout<<"Couldn’t perform deletion ";
else
afisare(p);
cout<<endl;

///———
cout<<"Order students in ascending order by mark!"
<<endl;
ordonare_crescator_medie(p,u);
afisare(p);
cout<<endl;
///———————
burse(p);
return 0;
}

15.6  CIRCULAR LISTS
In an effort to streamline the declaration of recurring
methods and optimize time utilization, the ensuing set
of methods is designated for application in upcoming
exercises:
Declaring the structure for a node:
struct nod
{
int info;
nod *next;
nod *back;
};
The method to add a new node into the list:
void adaugare(nod *&p,nod *&u,int x)
{
nod *q;
q=new nod;
q->info=x;
q->next=NULL;
if(p==0)
{
q->back=NULL;

p=u=q;
}
else
{
u->next=q;
q->back=u;
u=q;
}
}
The method to display the data onto the
screen/text file from left to right and from right
to left:
void afisare_stdr(nod *q)
{
nod *a;
a=q;
cout<<q->info<<" ";
q=q->next;
while(q!=a)
{
cout<<q->info<<" ";
q=q->next;
}

cout<<endl;
}
///—————————————
void afisare_drst(nod *q)
{
nod *a;
a=q;
cout<<q->info<<" ";
q=q->back;
while(q!=a)
{
cout<<q->info<<" ";
q=q->back;
}
cout<<endl;
}
1. Let there be a singly linked list that stores integers.
Modify the list to become a singly linked circular
list.
a. Display the content of the list starting from the first
element.

b. Display the content of the list starting from the
second element.
c. Display the content of the list starting from the last
element.
d. Display n components starting from the first
component.
e. Insert the value y after a value equal to x (first
occurrence).
f. Insert the value y after all values equal to x.
g. Remove all null values from the list.
h. Modify the list to become linear by removing the
third link in the list.
Implementation:
///—————————————
void afisare_primele_n(nod *q, int n)
{
nod *a;
a=q;
cout<<q->info << " ";
q=q->next;
int i=1;
while(q!=a && i<n)
{
cout<<q->info << " ";

q=q->next;
i++;
}
cout<<endl;
}
///—————————————
void inserare_dupa_valoare(nod *&p,nod *&u,int x,int y)
{
nod *q=p;
while(q->info!=x && q->next!=p)
q = q->next;
if (q->info==x)
{
nod *nou=new nod;
nou->info=y;
nou->next=q->next;
q->next=nou;
nou->back=q;
if (q==u)
u=nou;
else
nou->next->back=nou;
}

else
cout<<"Valoarea "<<x<<" nu a fost gasita in lista!"
<<endl;
}
///—————————————
void inserare_dupa_toate_valori(nod *&p, nod *&u, int x,
int y)
{
nod *q=p;
do
{
if (q->info==x)
{
nod *nou=new nod;
nou->info=y;
nou->next=q->next;
q->next=nou;
nou->back=q;
if (q==u)
u=nou;
else
nou->next->back=nou;
q=nou;

}
q=q->next;
}while (q!=p);
}
///—————————————
void eliminare_valori_nule(nod *&p, nod *&u)
{
nod *q=p;
do
{
if(q->info==0)
{
nod *st=q->back;
nod *dr=q->next;
st->next=dr;
dr->back=st;
if(q==p)
p=dr;
if (q==u)
u=st;
nod *aux=q;
q=q->back;
delete aux;

}
q=q->next;
} while (q!=p);
}
///—————————————
void eliminare_a_treia_legatura(nod *&p) {
int i = 1;
nod *q = p;
nod *prev_q = NULL;
while (q->next != p) {
if (i == 3) {
nod *temp = q;
prev_q->next = q->next;
q = q->next;
delete temp;
break;
}
prev_q = q;
q = q->next;
i++;
}
}
int main()

{
nod *p=0,*u;
citire(p,u);
u->next=p;
p->back=u;
///—————————-
afisare_stdr(p);
///—————————-
afisare_stdr(p->next);
///—————————-
afisare_stdr(u);
///—————————-
int n;
cout<<"n=";cin>>n;
afisare_primele_n(p,n);
///—————————-
int x,y;
cout<<"y: ";cin>>y;
cout<<"x: ";cin>>x;
inserare_dupa_valoare(p,u,x,y);
afisare_stdr(p);
///—————————-
cout<<"y: ";cin>>y;

cout<<"x: ";cin>>x;
inserare_dupa_toate_valori(p,u,x,y);
afisare_stdr(p);
///—————————-
eliminare_valori_nule(p,u);
afisare_stdr(p);
///—————————-
eliminare_a_treia_legatura(p);
afisare_stdr(p);
return 0;
}
1. The Cipher. A cipher contains n marks (values
from 1 to n). Pairs x y are read from the file
data.txt, representing the number of rotations and
the direction of rotation (clockwise or
counterclockwise, where y=1 for clockwise and
y=2 for counterclockwise). Display the resulting
code.
Example: For marks 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, and
pairs:
3 1
4 1

2 1
4 2
5 2
the code obtained is 3 6 7 4 10.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
struct nod
{
int info;
nod *next;
nod *back;
};
///—————————————
void adaugare(nod *&p,nod *&u,int x)
{
nod *q;
q=new nod;
q->info=x;
q->next=NULL;

if(p==0)
{
q->back=NULL;
p=u=q;
}
else
{
u->next=q;
q->back=u;
u=q;
}
}
///—————————————
void afisare(nod *q)
{
nod *a;
a=q;
cout<<q->info<<" ";
q=q->next;
while(q!=a)
{
cout<<q->info<<" ";
q=q->next;

}
cout<<endl;
}
///—————————————
void rotire(nod *&p,nod *&curent,int nr_rotatii, int sens)
{
if(p==NULL)
return;
nod *q=curent;
if(sens==1)
{
for(int i=1;i<nr_rotatii;i++)
q=q->next;
curent=q;
}
if(sens==2)
{
for(int i=1;i<nr_rotatii;i++)
q=q->back;
curent=q;
}
cout<<q->info<<" ";
}

int main()
{
nod *p=0,*u;
ifstream f("data.txt");
int n,x,y;
f>>n;
for(int i=1; i<=n; i++)
adaugare(p,u,i);
u->next=p;
p->back=u;
nod *curent=p;//where we start rotating
while(f>>x>>y)
rotire(p,curent,x,y);
return 0;
}
1. A number of n children are arranged in a circle,
and one by one, each child will exit the circle. The
value of n and the names of the n children are
read from the file kids.in. In the file song.in, a song
is written, separated into syllables. From the
keyboard, the name of a child is read, and the
“counting” begins from that child. The first child
following the initial one in the sequence, after a

number of children equal to the number of
syllables in the file, is eliminated. The process
continues from the next child who was not
eliminated, and so on, until only one child remains.
Determine the name of the child who is the last to
exit the circle.
Example:
kids.in    song.in
5     a la ba la por to ca la
adi    begins with dan, the last child will be dan.
dan
cristi
ana
alexandru
Implementation:
int n;
///—————————————
void readData(nod *&p,nod *&u)
{
ifstream f("kids.in");
f>>n;

char copil[100];
for(int i=1; i<=n; i++)
{
f.get();
f.get(copil,100);
adaugare(p,u,copil);
}
f.close();
}
///—————————————
nod* gaseste_nod(nod *p, char start[100])
{
nod* current=p;
do
{
if(stricmp(current->info, start)==0)
return current;
current=current->next;
} while (current!=p);
return NULL;
}
///—————————————

void sterge_fiecare(nod *&p, nod *&u, nod *start, char
silabe[100])
{
int num_silabe=strlen(silabe);
nod *current=start;
while(p!=u)
{
for (int i=1; i<num_silabe; i++)
current=current->next;
nod *eliminat=current->next;
current->next=eliminat->next;
eliminat->next->back=current;
if(eliminat==p)
p=eliminat->next;
else if(eliminat == u)
u=eliminat->back;
delete eliminat;
}
cout<<p->info<<endl;
}
///—————————————
int main()
{

nod *p=0,*u;
readData(p,u);
u->next=p;
p->back=u;
afisare(p);
///—————————————-
ifstream g("song.in");
char silabe[100];
g.get(silabe,100);
///—————————————-
char start[100];
cout<<"Start: ";
cin.get(start,100);
nod *start_node=gaseste_nod(p, start);
if(start_node==NULL)
cout<<"Node not found!"<<endl;
sterge_fiecare(p,u,start_node, silabe);
return 0;
}
1. Write a program that divides a circular list into two
circular lists with the closest possible number of
elements.

Implementation:
void readData(nod *&p,nod *&u)
{
ifstream f("data.in");
int x;
while(f>>x)
adaugare(p,u,x);
f.close();
}
///—————————————
void impartire(nod *p)
{
nod *p1,*u1;
int n=0;
nod *q=p;
do
{
n++;
q=q->next;
} while(q!=p);
// calculate the halves
int n1=n/2;

int n2=n-n1;
//move q at the beginning of 2nd list
q=p;
for(int i=1; i<=n1; i++)
q=q->next;
//update the connections for 1st list
p1=p;
u1=p->back;
u1->next=NULL;
p1->back=NULL;
// update the connections for 2nd list
nod* p2=q;
nod* u2=q->back;
u2->next=NULL;
p2->back=NULL;
//update the connections between the 2 lists
p1->back=u2;
u2->next=p1;
afisare(p1);
afisare(p2);
}
int main()
{

nod *p=0,*u;
readData(p,u);
u->next=p;
p->back=u;
///—————————————-
nod *p1=0,*u1=0;
impartire(p);
return 0;
}
1. Write a program which concatenates two circular
lists.
Implementation:
void readData(nod *&p,nod *&u,nod *&p1,nod *&u1)
{
ifstream f("data1.in");
ifstream g("data2.in");
int x;
while(f>>x)
adaugare(p,u,x);
while(g>>x)
adaugare(p1,u1,x);
f.close();

g.close();
}
///—————————————
void afisare(nod *q)
{
nod *p=q;
do
{
cout<<q->info<<" ";
q=q->next;
}while(q!=p);
cout<<endl;
}
///—————————————
void concatenare(nod *&p, nod *&u, nod *p1, nod *u1)
{
u->next=p1;
p1->back=u;
u1->next=p;
p->back=u1;
u=u1;
}
///—————————————

int main()
{
nod *p=0,*u,*p1=0,*u1;
readData(p,u,p1,u1);
u->next=p;
p->back=u;
u1->next=p1;
p1->back=u1;
cout<<"List 1:";
afisare(p);
cout<<"List 2:";
afisare(p1);
///—————————————-
concatenare(p, u, p1, u1);
cout<<"Concatenated list:";
afisare(p);
return 0;
}
1. Write a program that inserts a linear list into a
circular list. The result should still be a circular list.
Implementation:
struct nod

{
int info;
nod *next;
nod *back;
};
struct nod_simpla
{
int info;
nod_simpla *next;
};
void adaugare_simpla(nod_simpla *&p,nod_simpla *&u,int
x)
{
nod_simpla *q;
q=new nod_simpla;
q->info=x;
q->next=NULL;
if(p==0)
p=u=q;
else
{
u->next=q;
u=q;

}
}
///—————————————
void readData(nod *&p,nod *&u,nod_simpla
*&p1,nod_simpla *&u1)
{
ifstream f("data1.in");
ifstream g("data2.in");
int x;
///circular list
while(f>>x)
adaugare(p,u,x);
///singly linked list
while(g>>x)
adaugare_simpla(p1,u1,x);
f.close();
g.close();
}
///—————————————
void inserare_lista_simpla_in_lista_circulara(nod *&p, nod
*&ultim, nod_simpla *p1)
{
nod_simpla *q=p1;

while (q != NULL)
{
adaugare(p,ultim,q->info);
q=q->next;
}
}
///—————————————
int main()
{
nod *p=0,*u;
nod_simpla *p1=0,*u1;
citire(p,u,p1,u1);
u->next=p;
p->back=u;
///—————————————-
//Insertion of single list to circular
inserare_lista_simpla_in_lista_circulara(p,u,p1);
//Display the circular list
afisare(p);
return 0;
}

1. Determine whether the elements of a linear list
store, in order, the first p values of a circular list
starting from a given address. Display Yes or No.
Example: If the linear list stores the values: 3, 4, 5, 6,
3, 4, 5, 6, 3, 4, and the circular list stores the values 3,
4, 5, 6. If p=10 values of the circular list are traversed
starting from the address of the “first” component, the
output is YES.
Implementation:
struct nod
{
int info;
nod *next;
nod *back;
};
struct nod_simpla
{
int info;
nod_simpla *next;
};
void adaugare(nod *&p,nod *&u,int x)
{

nod *q;
q=new nod;
q->info=x;
q->next=NULL;
if(p==0)
{
q->back=NULL;
p=u=q;
}
else
{
u->next=q;
q->back=u;
u=q;
}
}
void adaugare_simpla(nod_simpla *&p,nod_simpla *&u,int
x)
{
nod_simpla *q;
q=new nod_simpla;
q->info=x;
q->next=NULL;

if(p==0)
p=u=q;
else
{
u->next=q;
u=q;
}
}
///—————————————
void citire(nod *&p,nod *&u,nod_simpla *&p1,nod_simpla
*&u1)
{
ifstream f("date1.in");
ifstream g("date2.in");
int x;
///citire lista circulara
while(f>>x)
adaugare(p,u,x);
///citire lista liniara
while(g>>x)
adaugare_simpla(p1,u1,x);
f.close();
g.close();

}
///—————————————
void afisare(nod *q)
{
nod *p=q;
do
{
cout<<q->info<<" ";
q=q->next;
}while(q!=p);
cout<<endl;
}
void afisare_simpla(nod_simpla *p)
{
while(p!=NULL)
{
cout<<p->info<<" ";
p=p->next;
}
cout<<endl;
}
///—————————————

void inserare_lista_simpla_in_lista_circulara(nod *&p, nod
*&ultim, nod_simpla *p1)
{
nod_simpla *q=p1;
while (q != NULL)
{
adaugare(p,ultim,q->info);
q=q->next;
}
}
///—————————————
bool verifica_ordine(nod_simpla *p, int p_valori, int
valori_circulare[])
{
for(int i=0; i< p_valori; i++)
{
if (p==nullptr || p->info!=valori_circulare[i])
return false;
p=p->next;
}
return true;
}
///—————————————

void verifica_lista_ordine(nod *p, nod_simpla *p1, int
p_valori)
{
int valori_circulare[p_valori];
nod *q=p;
for(int i=0; i<p_valori; i++)
{
valori_circulare[i]=q->info;
q=q->next;
}
nod_simpla *ultim=p1;
while(ultim->next!=NULL)
ultim=ultim->next;
if (verifica_ordine(p1, p_valori, valori_circulare))
cout<<"Da"<<endl;
else
cout<<"Nu"<<endl;
}
///—————————————
int main()
{
nod *p=0,*u;
nod_simpla *p1=0,*u1;

citire(p,u,p1,u1);
u->next=p;
p->back=u;
///—————————————-
int p_valori;
cout<<"p=";cin>>p_valori;
verifica_lista_ordine(p,p1,p_valori);
return 0;
}

15.7  STACKS
1. In the file data.in, n integers are stored. Store the
numbers from the file in a stack and perform the
following operations:
a. Display the stack's content.
b. Display the longest increasing sequence starting
from the top element of the stack.
c. Double the value of the number at the top of the
stack.
d. Add m more values to the top of the stack.
e. Remove p values from the top of the stack.
Implementation:
struct nod
{
int info;
nod*back;
};
int n;
void adaugare(nod *&vf, int x)
{
nod *q;
q=new nod;

q->info=x;
if(vf==0)
{
vf=q;
vf->back=NULL;
}
else
{
q->back=vf;
vf=q;
}
}
void afisare(nod *vf)
{
nod *q=vf;
while(q!=NULL)
{
cout<<q->info<<" ";
q=q->back;
}
cout<<endl;
}
void read(nod *&vf)

{
int x;
ifstream f("data.in");
f>>n;
for(int i=1;i<=n;i++)
{
f>>x;
adaugare(vf,x);
}
f.close();
}
void Stergere(nod *&vf)
{
nod *a;
if (vf!=NULL)
{
a=vf;
vf=vf->back;
delete a;
}
else
cout<<"Empty stack :(";
}

void ceaMaiLungaSecventaCrescatoare(nod* vf)
{
if (vf==NULL)
cout<<"Empty stack!\n";
int lungimeMaxima=1;
int lungimeCurenta=1;
int ultimulElement=vf->info;
nod* p=vf->back;
while(p!=NULL)
{
if (p->info<ultimulElement)
lungimeCurenta=1;
else
{
lungimeCurenta++;
if(lungimeCurenta>lungimeMaxima)
lungimeMaxima=lungimeCurenta;
}
ultimulElement=p->info;
p=p->back;
}
cout<<"Longest sequence starting with "<<vf->info<<"
has length of "<<lungimeMaxima<<endl;

}
void dublare(nod *&vf)
{
if(vf==NULL)
cout<<"Empty stack";
vf->info=vf->info*2;
}
int main()
{
nod *vf=0;
read(vf);
///a)——————
afisare(vf);
///b)——————
ceaMaiLungaSecventaCrescatoare(vf);
///c)——————
dublare(vf);
cout<<"Stack obtained:";
afisare(vf);
///d)——————
int m,x;
cout<<"How many values? ";
cin>>m;

for(int i=1;i<=m;i++)
{
cout<<"Value "<<i<<":";
cin>>x;
adaugare(vf,x);
}
cout<<"Stack obtained:";
afisare(vf);
///e)——————
int p;
cout<<"How many values? ";cin>>p;
for(int i=1;i<=p;i++)
Stergere(vf);
cout<<"Stack obtained:";
afisare(vf);
return 0;
}
1. On a rod, there are n balls numbered with natural
numbers. Knowing that the balls can only be
extracted from one of the ends, and after
extraction, they are placed on another free rod, but
only at one end. The operation is reversible, so the
balls can return from the second rod to the first

only in the order they were initially placed.
Knowing that k operations are performed,
expressed by a triplet of numbers a, b, c, express
the content of the rods after these k operations.
The triplet a, b, c has the meaning: move c balls
from rod a to rod b. For example, if the first rod
contains the values 2, 7, 8, 9, 5 at a certain
moment, and the second rod contains 6, 9, 1, 7,
the triplet: 1, 2, 3 will lead to the configuration: 9,
5 for the first rod and 8, 7, 2 for the second rod, as
three balls have moved from rod 1 to rod 2.
Example:
n=5,
2,7,8,9,5
k=4
1 2 3
2 1 2
1 2 4
2 1 3
Result: 8, 7, 2 for the first rod and 9, 5 for the second
rod.
Implementation:

struct nod
{
int info;
nod*back;
};
void adaugare(nod *&vf, int x)
{
nod *q;
q=new nod;
q->info=x;
if(vf==0)
{
vf=q;
vf->back=NULL;
}
else
{
q->back=vf;
vf=q;
}
}
void afisare(nod *vf)
{

nod *q=vf;
while(q!=NULL)
{
cout<<q->info<<" ";
q=q->back;
}
cout<<endl;
}
void Stergere(nod*& vf)
{
nod* a;
if (vf!=NULL)
{
a=vf;
vf=vf->back;
delete a;
}
else
cout<<"Empty stack :(";
}
void mutaBile(nod*& stivaA, nod*& stivaB, int c)
{
for (int i=0; i<c; i++)

{
adaugare(stivaB,stivaA->info);
Stergere(stivaA);
}
}
int main()
{
nod *stiva1=0; // first stack
nod *stiva2=0; // 2nd stack after moving
int n; //number of balls
ifstream f("data.in");
f>>n;
for(int i=1; i<=n; i++)
{
int x;
f>>x;
adaugare(stiva1,x);
}
afisare(stiva1);// initial stack
int k; // number of operations
f>>k;
for (int i=1; i<=k; i++)
{

int a,b,c;
f>>a>>b>>c;
if (a==1 && b==2)
mutaBile(stiva1,stiva2,c);
else if(a==2 && b==1)
mutaBile(stiva2,stiva1,c);
}
f.close();
cout<<"First rod: ";
afisare(stiva1); // final stack
cout<<"Second rod: ";
afisare(stiva2); // 2nd rod/intermediate stack
return 0;
}
1. At a newsstand, there is a stack of n promotional
magazines that are distributed for free. The names
of the magazines are read from the keyboard as
strings with a maximum of 40 characters each.
Knowing that the magazines are always distributed
to customers starting with the one on top, but that
new magazines are also received, display the
operations that take place at the newsstand. The
operations are read from the file magazines.in, and
are expressed as a set of k pairs a, b with the

meaning: a number of operations, b represents the
type of operation, where for the value 1, a new
magazines are added to the stack, and for 0, a free
distribution to customers is made. If new
magazines are added to the stack, the names of
the magazines are read from the next a lines.
Example:
n=5
rev1, rev2, rev3, rev4, rev5
k=4
magazines.in
3 1
Rev6
Rev7
Rev8
3 0

2 0
2 1
Rev9
Display:
Reception: rev6, rev7, rev8
Distribution: rev8, rev7, rev6
Distribution: rev5, rev4
Reception: rev9
The stack of magazines contains, starting with the first
magazine: rev9, rev3, rev2, rev1.
Implementation:
struct nod
{
char info[40];
nod*back;
};

void adaugare(nod *&vf,char x[40])
{
nod *q;
q=new nod;
strcpy(q->info,x);
if(vf==0)
{
vf=q;
vf->back=NULL;
}
else
{
q->back=vf;
vf=q;
}
}
void afisare(nod *vf)
{
nod *q=vf;
while(q!=NULL)
{
cout<<q->info<<" ";
q=q->back;

}
cout<<endl;
}
void afisare_op(bool receptie,nod* vf,int a)
{
int i=1;
if(receptie)
{
cout<<"Reception: ";
while(vf && i<=a)
{
cout<<vf->info<<" ";
vf=vf->back;
i++;
}
}
else
{
cout<<"Distribution: ";
while(vf && i<=a)
{
cout<<vf->info<<" ";
vf=vf->back;

i++;
}
}
cout<<endl;
}
void Stergere(nod *&vf, int a)
{
for(int i=1; i<=a; i++)
{
if(vf!=NULL)
{
nod *q=vf;
vf=vf->back;
delete q;
}
else cout<<"Empty stack"<<endl;
}
}
nod* inversare_stiva(nod* vf)
{
nod* vf_inversat=NULL;
while(vf!=nullptr)
{

nod* nod_nou=new nod;
strcpy(nod_nou->info,vf->info);
nod_nou->back=vf_inversat;
vf_inversat=nod_nou;
vf=vf->back;
}
return vf_inversat;
}
void copiere_stiva(nod* vf, nod *&vf_nou)
{
nod *q=vf;
vf_nou=NULL; // new stack is empty
while(q!=NULL)
{
//create a new node and store the info
nod* nod_nou=new nod;
//nod_nou->info=q->info;
strcpy(nod_nou->info,q->info);
nod_nou->back=vf_nou;
vf_nou=nod_nou; // set the new head
q=q->back; // next node from the old stack
}
// reverse the order

vf_nou=inversare_stiva(vf_nou);
}
int main()
{
nod *vf=0;
int n,k;
char x[40];
ifstream f("data.in");
ifstream g("magazines.in");
f>>n;
f.get();
for(int i=1;i<=n;i++)
{
f.getline(x,40);
adaugare(vf,x);
}
afisare(vf);
g>>k;
for(int i=1; i<=k; i++)
{
int a,b;
g>>a>>b;
if(b==1)//add new magazines

{
for(int j=1; j<=a; j++)
{
char revista[40];
g.get();
g.get(revista, 40);
adaugare(vf, revista);
}
afisare_op(true,vf,a); // display reception
}
else if(b==0) // distribution
{
nod *distribuite=0;
copiere_stiva(vf,distribuite);
Stergere(vf,a);
afisare_op(false,distribuite, a); // display distribution
}
}
cout<<"The final stack is: ";
afisare(vf);
return 0;
}

1. From the file data.in, natural numbers with at most
4 digits each are read. Generate a stack to store
numbers greater than 5, and for each value in the
file less than or equal to 5, remove from the stack
a number of values equal to the value of the read
number.
Implementation:
struct nod
{
int info;
nod*back;
};
void adaugare(nod *&vf,int x)
{
nod *q;
q=new nod;
q->info=x;
if(vf==0)
{
vf=q;
vf->back=NULL;
}
else

{
q->back=vf;
vf=q;
}
}
void afisare(nod *vf)
{
nod *q=vf;
while(q!=NULL)
{
cout<<q->info<<" ";
q=q->back;
}
cout<<endl;
}
void procesare_fisier()
{
nod *vf=NULL;
ifstream f("data.in");
int x;
while(f>>x)
{
if(x>5)

adaugare(vf,x);
else
{
nod *q=vf;
int cnt=x;
while (q != NULL && cnt>0)
{
nod *temp=q;
q=q->back;
delete temp;
cnt—;
}
vf=q;
}
}
afisare(vf);
}
int main()
{
procesare_fisier();
return 0;
}

1. From the file data.in, natural numbers with at most
4 digits each are read. Generate two stacks, one to
store prime numbers and another to store the
other numbers from the file. Display the
value/values from the middle of each stack.
Implementation:
struct nod
{
int info;
nod*back;
};
void adaugare(nod *&vf,int x)
{
nod *q;
q=new nod;
q->info=x;
if(vf==0)
{
vf=q;
vf->back=NULL;
}
else
{

q->back=vf;
vf=q;
}
}
void afisare(nod *vf)
{
nod *q=vf;
while(q!=NULL)
{
cout<<q->info<<" ";
q=q->back;
}
cout<<endl;
}
bool estePrim(int x)
{
if(x==2)
return true;
if(x<2 || x%2==0)
return false;
for(int i=3;i<=sqrt(x);i++)
if(x%i==0)
return false;

return true;
}
void procesare_fisier()
{
nod *vf1=NULL,*vf2=NULL;
ifstream f("data.in");
int x;
while(f>>x)
{
if(estePrim(x))
adaugare(vf1,x);
else
adaugare(vf2,x);
}
cout<<"List of primes: ";
afisare(vf1);
cout<<"List of non primes: ";
afisare(vf2);
///Find the mid element for each stack
nod *q=vf1;
int cnt=0;
while (q!=NULL)
{

cnt++;
q=q->back;
}
int mid=cnt/2;
cout<<"The mid’s of primes’ list is: ";
if (cnt%2==0)
{
///2 values
q=vf1;
for (int i=0; i<mid-1; i++)
q=q->back;
cout<<q->info<<" ";
q=q->back;
cout<<q->info<<endl;
}
else
{
///only one value
q=vf1;
for (int i=0; i<mid; i++)
q=q->back;
cout<<q->info<<endl;
}

q=vf2;
cnt=0;
while (q!=NULL)
{
cnt++;
q=q->back;
}
mid=cnt/2;
cout<<"The mid’s of non-primes’ list is: ";
if (cnt%2==0)
{
///2 values
q=vf2;
for(int i=0; i<mid-1; i++)
q=q->back;
cout<<q->info<<" ";
q=q->back;
cout<<q->info<<endl;
}
else
{
///only one value
q=vf1;

for (int i=0; i<mid; i++)
q=q->back;
cout<<q->info<<endl;
}
}
int main()
{
procesare_fisier();
return 0;
}
1. Natural numbers of at most 9 digits each are read
from the data file data.in. Two stacks are to be
generated: one that stores the numbers from the
file, and the second one that stores the number of
digits for each number. Display, for each number,
the number of digits by traversing the two stacks.
Implementation:
struct nod
{
int info;
nod*back;
};

void adaugare(nod *&vf,int x)
{
nod *q;
q=new nod;
q->info=x;
if(vf==0)
{
vf=q;
vf->back=NULL;
}
else
{
q->back=vf;
vf=q;
}
}
void afisare(nod *vf)
{
nod *q=vf;
while(q!=NULL)
{
cout<<q->info<<" ";
q=q->back;

}
cout<<endl;
}
int nr_cifre(int x)
{
int k=0;
while(x!=0)
{
k++;
x=x/10;
}
return k;
}
void procesare_fisier()
{
nod *vf1=NULL,*vf2=NULL;
ifstream f("data.in");
int x;
while(f>>x)
{
adaugare(vf1,x);
adaugare(vf2,nr_cifre(x));
}

cout<<"Stack of numbers: ";
afisare(vf1);
cout<<"Stack of digits: ";
afisare(vf2);
//go through both stacks
nod *q=vf1,*p=vf2;
while(q!=NULL && p!=NULL)
{
cout<<"Number "<<q->info<<" has "<<p->info<<"
digits."<<endl;
q=q->back;
p=p->back;
}
}
int main()
{
procesare_fisier();
return 0;
}
1. Natural numbers of at most 9 digits each are read
from the data file data.in. Non-zero values are to
be stored in the order they are read from the file,
while zeros will be added to the top of the stack.

Implementation:
struct nod
{
int info;
nod*back;
};
void adaugare(nod *&vf,int x)
{
nod *q;
q=new nod;
q->info=x;
if(vf==0)
{
vf=q;
vf->back=NULL;
}
else
{
q->back=vf;
vf=q;
}
}

void afisare(nod *vf)
{
nod *q=vf;
while(q!=NULL)
{
cout<<q->info<<" ";
q=q->back;
}
cout<<endl;
}
void procesare_fisier(nod *&vf)
{
ifstream f("data.in");
int x;
while (f>>x)
{
if(x==0)
adaugare(vf,x);
else
{
nod *q=vf;
while(q!=NULL && q->back!=NULL)
q=q->back;

nod *nou=new nod;
nou->info=x;
nou->back=q==NULL ? NULL:q->back;
if (q==NULL)
vf=nou;
else
q->back=nou;
}
}
afisare(vf);
}
int main()
{
nod *vf=NULL;
procesare_fisier(vf);
return 0;
}

15.8  QUEUES
1. At a medical office, patients are scheduled based
on an application that contains a menu with the
following meanings for characters:
a. S for the arrival of a new patient
b. U for urgency
c. L for listing
d. C for patient consultation
e. T for termination
Knowing that patients are consulted in the order of
their arrival, with the exception of emergencies, write
an application that operates based on the previous
menu, considering that the initial scheduling is read
from the file patients.txt, and upon termination, the
content of the file is updated.
Implementation:
struct nod
{
char info[30];
nod*next;
};

int n;
void afisare(nod *p)
{
nod *q=p;
cout<<"Patients:"<<endl;
while(q!=NULL)
{
cout<<q->info<<" ";
q=q->next;
}
cout<<endl;
}
void adaugare(nod *&p, nod *&u, char x[30])
{
nod *q;
q=new nod;
strcpy(q->info,x);
q->next=NULL;
if(p==0)
p=u=q;
else
{
u->next=q;

u=q;
}
}
void read(nod *&p,nod *&u)
{
ifstream f("patients.txt");
f>>n;
char x[30];
for(int i=1;i<=n;i++)
{
f.get();
f.get(x,30);
adaugare(p,u,x);
}
f.close();
}
void stergere(nod *&p)
{
nod *a;
if (p!=NULL)
{
a=p;
p=p->next;

delete a;
}
else
cout<<"Empty queue.";
}
int main()
{
nod*p=0,*u;
read(p,u);
char opt;
char x[30];
do
{
cout<<endl;
cout<<"Choose an option:"<<endl;
cout<<"S-arrival of a new patient."<<endl;
cout<<"U-for emergency."<<endl;
cout<<"L-display the patients."<<endl;
cout<<"C-for patient consultation."<<endl;
cout<<"T-for termination of program"<<endl;
cin>>opt;
if(opt=='S')//add a new patient
{

cout<<"Numele pacientului:";
cin>>x;
adaugare(p,u,x);
}
if(opt=='U')//add the patient to start of queue
{
cout<<"Numele pacientului:";
cin>>x;
nod *q;
q=new nod;
strcpy(q->info,x);
q->next=p;
p=q;
}
if(opt=='L')//print out patients
afisare(p);
if(opt=='C')//delete from the queue
stergere(p);
if(opt=='T')//end of program
break;
}while(opt!='T');
return 0;
}

1. At a fuel station, cars line up at two refueling
points. Data is read from two files, point1.txt and
point2.txt, where the following information is
specified: the number n of cars, and in the next n
lines, the data for each car: license plate number,
fuel type (1 for gasoline and 2 for gas), and the
number of liters. Knowing that cars are refueled
alternately at each point in the order of arrival, and
the prices for the two types of fuel are read from
the keyboard, display the list of costs for each car
(license plate number and price).
Implementation:
#include <iostream>
#include <fstream>
#include <cstring>
using namespace std;
struct masina
{
char nr_inmatr[30];
int combustibil;
float litri;
};
struct nod
{

masina info;
nod*next;
};
int n;
void afisare(nod *p,char punct)
{
nod *q=p;
cout<<"Cars from fuel station "<<punct<<endl;
while(q!=NULL)
{
cout<<"Car plate : "<<q->info.nr_inmatr<<" fuel type :
";
cout<<q->info.combustibil<<" no. of liters: "<<q-
>info.litri<<endl;
q=q->next;
}
cout<<endl;
}
void adaugare(nod *&p, nod *&u, masina x)
{
nod *q;
q=new nod;
q->info=x;

q->next=NULL;
if(p==0)
p=u=q;
else
{
u->next=q;
u=q;
}
}
void citire(nod *&p,nod *&u,nod *&p1,nod *&u1)
{
ifstream f("point1.txt");
ifstream g("point2.txt");
f>>n;
masina x;
for(int i=1;i<=n;i++)
{
f.get();
f.get(x.nr_inmatr,30);
f.get();
f>>x.combustibil>>x.litri;
adaugare(p,u,x);
}

g>>n;
for(int i=1;i<=n;i++)
{
g.get();
g.get(x.nr_inmatr,30);
g.get();
g>>x.combustibil>>x.litri;
adaugare(p1,u1,x);
}
f.close();
g.close();
}
void afisare_cost(nod *p,float pret_benzina,float
pret_gaz,char punct)
{
nod *q=p;
float cost;
cout<<"Cars from fuel station: "<<punct<<endl;
while(q!=NULL)
{
if(q->info.combustibil==1)
cost=q->info.litri*pret_benzina;
else if(q->info.combustibil==2)

cost=q->info.litri*pret_gaz;
cout<<"Car plate: "<<q->info.nr_inmatr<<" has cost of: "
<<cost<<endl;
q=q->next;
}
}
int main()
{
nod *p1=0,*u1,*p2=0,*u2;
citire(p1,u1,p2,u2);
afisare(p1,'1');
afisare(p2,'2');
float pret_benzina,pret_gaz;
cout<<"Price of gasoline: ";
cin>>pret_benzina;
cout<<"Price of gas: ";
cin>>pret_gaz;
// displays the costs for each car
afisare_cost(p1,pret_benzina,pret_gaz,'1');
afisare_cost(p2,pret_benzina,pret_gaz,'2');
return 0;
}

1. The values stored in two queues C1 and C2 are
read from two files c1.txt and c2.txt, which store
ascending integers. Generate the queue C3, which
stores in ascending order the values from the two
queues.
Implementation:
struct nod
{
int info;
nod*next;
};
int n;
void afisare(nod *p)
{
nod *q=p;
while(q!=NULL)
{
cout<<q->info<<" ";
q=q->next;
}
cout<<endl;
}
void adaugare(nod *&p, nod *&u, int x)

{
nod *q;
q=new nod;
q->info=x;
q->next=NULL;
if(p==0)
p=u=q;
else
{
u->next=q;
u=q;
}
}
void citire(nod *&p,nod *&u,nod *&p1,nod *&u1)
{
ifstream f("c1.txt");
ifstream g("c2.txt");
int x;
while(f>>x)
adaugare(p,u,x);
while(g>>x)
adaugare(p1,u1,x);
f.close();

g.close();
}
void interclasare(nod *p1, nod *p2, nod*& p3,nod*& u3)
{
while(p1!=NULL && p2!=NULL)
{
if (p1->info<=p2->info)
{
adaugare(p3,u3,p1->info);
p1=p1->next;
}
else
{
adaugare(p3,u3,p2->info);
p2=p2->next;
}
}
while(p1!=NULL)
{
adaugare(p3,u3,p1->info);
p1=p1->next;
}
while(p2!=NULL)

{
adaugare(p3,u3,p2->info);
p2=p2->next;
}
}
int main()
{
nod *p1=0,*u1,*p2=0,*u2;
citire(p1,u1,p2,u2);
cout<<"Queue 1: ";
afisare(p1);
cout<<"Queue 2: ";
afisare(p2);
nod *p3=0,*u3;
interclasare(p1,p2,p3,u3);
cout<<"Resulted queue: ";
afisare(p3);
return 0;
}
1. The values stored in two queues C1 and C2 are
read from two files c1.txt and c2.txt, which store
strictly increasing integers. Generate the queue
C3, which stores the values in ascending order

from the two queues, in such a way that each
value is stored only once.
Example:
C1: 1 2 6 7 9 10 18 20 25 29 30 40
C2: 3 6 7 9 12 18 25 29
C3: 1 2 3 6 7 9 10 12 18 20 25 29 30 40
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
struct nod
{
int info;
nod*next;
};
int n;
void afisare(nod *p)
{
nod *q=p;
while(q!=NULL)
{

cout<<q->info<<" ";
q=q->next;
}
cout<<endl;
}
void adaugare(nod *&p, nod *&u, int x)
{
nod *q;
q=new nod;
q->info=x;
q->next=NULL;
if(p==0)
p=u=q;
else
{
u->next=q;
u=q;
}
}
void citire(nod *&p,nod *&u,nod *&p1,nod *&u1)
{
ifstream f("c1.txt");
ifstream g("c2.txt");

int x;
while(f>>x)
adaugare(p,u,x);
while(g>>x)
adaugare(p1,u1,x);
f.close();
g.close();
}
void generare_c3(nod* p1, nod* p2, nod*& p3, nod*& u3)
{
nod *q1=p1;
nod *q2=p2;
int ultima_valoare_adaugata=-1;
while(q1!=NULL && q2!=NULL)
{
if (q1->info<q2->info)
{
if (q1->info!=ultima_valoare_adaugata)
{
adaugare(p3,u3,q1->info);
ultima_valoare_adaugata=q1->info;
}
q1=q1->next;

}
else
{
if(q2->info!=ultima_valoare_adaugata)
{
adaugare(p3,u3,q2->info);
ultima_valoare_adaugata=q2->info;
}
q2=q2->next;
}
}
while(q1 != NULL)
{
if (q1->info!=ultima_valoare_adaugata)
{
adaugare(p3,u3,q1->info);
ultima_valoare_adaugata=q1->info;
}
q1=q1->next;
}
while(q2 != NULL)
{
if (q2->info!=ultima_valoare_adaugata)

{
adaugare(p3,u3,q2->info);
ultima_valoare_adaugata=q2->info;
}
q2=q2->next;
}
}
int main()
{
nod *p1=0,*u1,*p2=0,*u2;
citire(p1,u1,p2,u2);
cout<<"Queue 1: ";
afisare(p1);
cout<<"Queue 2: ";
afisare(p2);
nod *p3=0,*u3;
generare_c3(p1,p2,p3,u3);
cout<<"Resulted queue: ";
afisare(p3);
return 0;
}

1. The values stored in two queues C1 and C2 are
read from two files c1.txt and c2.txt, which store
strictly increasing integers. Generate the queue
C3, which stores in ascending order the common
values from the two queues.
Example:
C1: 1 2 6 7 9 10 18 20 25 29 30 40
C2: 3 6 7 9 12 18 25 29
C3: 6 7 9 18 25 29
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
struct nod
{
int info;
nod*next;
};
int n;
void afisare(nod *p)
{
nod *q=p;

while(q!=NULL)
{
cout<<q->info<<" ";
q=q->next;
}
cout<<endl;
}
void adaugare(nod *&p, nod *&u, int x)
{
nod *q;
q=new nod;
q->info=x;
q->next=NULL;
if(p==0)
p=u=q;
else
{
u->next=q;
u=q;
}
}
void citire(nod *&p,nod *&u,nod *&p1,nod *&u1)
{

ifstream f("c1.txt");
ifstream g("c2.txt");
int x;
while(f>>x)
adaugare(p,u,x);
while(g>>x)
adaugare(p1,u1,x);
f.close();
g.close();
}
void generare_c3(nod* p, nod* p1, nod*& p2, nod*& u2)
{
while(p!=NULL && p1!=NULL)
{
if (p->info==p1->info)
{
adaugare(p2,u2,p->info);
p=p->next;
p1=p1->next;
}
else if(p->info<p1->info)
p=p->next;
else

p1=p1->next;
}
}
int main()
{
nod *p1=0,*u1,*p2=0,*u2;
citire(p1,u1,p2,u2);
cout<<"C1: ";
afisare(p1);
cout<<"C2: ";
afisare(p2);
nod *p3=0,*u3;
generare_c3(p1,p2,p3,u3);
cout<<"C3: ";
afisare(p3);
return 0;
}
1. The values stored in two queues C1 and C2 are
read from two files c1.txt and c2.txt, which store
strictly increasing integers. Generate the queue
C3, which stores in ascending order the values
divisible by 5 from the two queues, in such a way
that each value is stored only once.

Example:
C1: 1 2 6 7 9 10 18 20 25 29 30 40
C2: 3 6 7 9 12 18 25 29 30 32 35 41 42 45 89 90 92
C3: 10 20 25 30 40 45 90
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
struct nod
{
int info;
nod*next;
};
int n;
void afisare(nod *p)
{
nod *q=p;
while(q!=NULL)
{
cout<<q->info<<" ";
q=q->next;

}
cout<<endl;
}
void adaugare(nod *&p, nod *&u, int x)
{
nod *q;
q=new nod;
q->info=x;
q->next=NULL;
if(p==0)
p=u=q;
else
{
u->next=q;
u=q;
}
}
void citire(nod *&p,nod *&u,nod *&p1,nod *&u1)
{
ifstream f("c1.txt");
ifstream g("c2.txt");
int x;
while(f>>x)

adaugare(p,u,x);
while(g>>x)
adaugare(p1,u1,x);
f.close();
g.close();
}
void intersectie(nod *p1, nod *p2, nod *&p3, nod *&u3)
{
nod *q1=p1,*q2=p2;
int ultima_valoare_adaugata=-1;
while(q1!=NULL && q2!=NULL)
{
if (q1->info<q2->info)
{
if (q1->info!=ultima_valoare_adaugata && q1-
>info%5==0)
{
adaugare(p3,u3,q1->info);
ultima_valoare_adaugata=q1->info;
}
q1=q1->next;
}
else

{
if(q2->info!=ultima_valoare_adaugata && q2-
>info%5==0)
{
adaugare(p3,u3,q2->info);
ultima_valoare_adaugata=q2->info;
}
q2=q2->next;
}
}
while(q1!=NULL)
{
if (q1->info!=ultima_valoare_adaugata && q1-
>info%5==0)
{
adaugare(p3,u3,q1->info);
ultima_valoare_adaugata=q1->info;
}
q1=q1->next;
}
while(q2!=NULL)
{

if (q2->info!=ultima_valoare_adaugata && q2-
>info%5==0)
{
adaugare(p3,u3,q2->info);
ultima_valoare_adaugata=q2->info;
}
q2=q2->next;
}
}
int main()
{
nod *p1=0,*u1,*p2=0,*u2;
citire(p1,u1,p2,u2);
cout<<"C1: ";
afisare(p1);
cout<<"C2: ";
afisare(p2);
nod *p3=0,*u3;
intersectie(p1,p2,p3,u3);
cout<<"C3: ";
afisare(p3);
return 0;
}

CHAPTER 16 – GRAPHS
16.1 Undirected Graphs. Internal Memory
Representation.
16.2 Undirected Graphs. Traversal.
16.3 Undirected Graphs. Connected Components.
16.4 Directed Graphs. Storage. Traversal.
16.5 Shortest Paths. Minimum Chains.
16.6 Minimum Cost Spanning Tree.
16.7 Hamiltonian Graphs. Eulerian Graphs.
Applications:

16.1  UNDIRECTED GRAPHS.
INTERNAL MEMORY
REPRESENTATION.
1. A graph is read from the file graph.txt: the number
of nodes n (n≤30), the number of edges m, and
the m edges expressed as pairs of adjacent nodes.
a. Display the adjacency matrix associated with the
graph.
b. Determine the degree of a node read from the
keyboard.
c. Display the nodes adjacent to a node read from the
keyboard.
d. Display, for each node, its degree. Is the graph
complete?
e. Display nodes with the maximum degree.
f. Display isolated nodes.
g. Determine the minimum number of edges that
should be added for the graph to no longer contain
isolated nodes.
h. Determine if a sequence of p nodes read from the
keyboard forms a path in the graph. Display Yes or
No.
Implementation:
int a[51][51];

int g[51];
int n, m;
void readGraph()
{
ifstream file("graf.txt");
int i, x, y;
file >> n >> m;
for (i = 1; i <= m; i++)
{
file >> x >> y;
a[x][y] = a[y][x] = 1;
g[x]++;
g[y]++;
}
file.close();
}
void displayAdjacencyMatrix()
{
int i, j;
for (i = 1; i <= n; i++)
{
for (j = 1; j <= n; j++)
cout << a[i][j] << " ";

cout << endl;
}
cout << endl;
}
bool condition = false;
void displayDegree(int node)
{
int i;
for (i = 1; i <= n; i++)
{
if (node == i)
{
cout << "Node " << node << " has degree " << g[i] <<
endl;
condition = true;
}
}
}
void displayAdjacentNodes(int node)
{
int i, j;
bool ok = false;
for (i = 1; i <= n; i++)

if (node == i)
{
ok = true;
break;
}
if (ok == true)
{
for (i = 1; i <= n; i++)
{
if (a[node][i] == 1)
cout << i << " ";
else
{
cout << "The node has no adjacents";
break;
}
}
}
else
cout << "The node is not in the graph";
}
void displayDegrees()
{

for (int i = 1; i <= n; i++)
cout << "Node " << i << " has degree " << g[i] << endl;
}
void displayNodesWithMaxDegree()
{
int maxDegree = 0;
for (int i = 1; i <= n; i++)
if (g[i] > maxDegree)
maxDegree = g[i];
cout << "Nodes with the maximum degree are: ";
for (int i = 1; i <= n; i++)
if (g[i] == maxDegree)
cout << i << " ";
cout << endl;
}
void displayIsolatedNodes()
{
cout << "Isolated nodes are: ";
for (int i = 1; i <= n; i++)
if (g[i] == 0)
cout << i << " ";
cout << endl;
}

int countIsolatedNodes()
{
int k = 0;
for (int i = 1; i <= n; i++)
if (g[i] == 0)
k++;
return k;
}
void path()
{
int p, u[500], ok = 1, i;
cout << "p=";
cin >> p;
for (i = 1; i <= p; i++)
{
cout << "u[" << i << "]=";
cin >> u[i];
}
for (i = 1; i <= p - 1; i++)
if (a[u[i]][u[i + 1]] == 0)
ok = 0;
if (ok == 0)

cout << "The sequence of values does not represent a
path";
else
{
cout << "represents a path - " << endl;
for (i = 1; i <= p - 1; i++)
for (int j = i + 1; j <= p; j++)
if (u[i] == u[j])
ok = 0;
if (ok == 1)
cout << "Elementary path";
else
cout << "Non-elementary path";
}
}
int main()
{
int node;
readGraph();
///————————————————————-
cout << "Adjacency matrix:" << endl;
displayAdjacencyMatrix();
///————————————————————-

cout << "One node: ";
cin >> node;
displayDegree(node);
if (condition == false)
cout << "The node is not in the graph." << endl;
///————————————————————-
cout << "One node: ";
cin >> node;
displayAdjacentNodes(node);
cout << endl;
///————————————————————-
displayDegrees();
if (m == n * (n - 1) / 2)
cout << "The graph is complete." << endl;
else
cout << "The graph is not complete." << endl;
///————————————————————-
displayNodesWithMaxDegree();
///————————————————————-
displayIsolatedNodes();
///————————————————————-
cout << "The minimum number of edges that need to be
added to eliminate isolated nodes is: " <<

countIsolatedNodes() << endl;
///————————————————————-
path();
return 0;
}
1. Read a graph from the file graph.txt: the number of
nodes n (n≤30), the number of edges m, and the
m edges expressed as pairs of adjacent nodes.
a. Store the graph using adjacency lists.
b. Determine the degree of a node read from the
keyboard.
c. Display the nodes adjacent to a node read from the
keyboard.
d. Display, for each node, its degree. Is the graph
complete?
e. Display nodes with the maximum degree.
f. Display isolated nodes.
g. Determine if the pair x, y represents a pair of
adjacent nodes.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;

int n, m; // Number of nodes and edges
struct Node {
int info;
Node *next;
} *L[31]; // Array of linked lists representing the adjacency
list
void readGraph() {
Node *q;
int x, y;
ifstream file("graf.txt");
file >> n >> m;
for (int i = 1; i <= m; i++) {
file >> x >> y;
// Adding edges to the adjacency list
q = new Node;
q->info = x;
q->next = L[y];
L[y] = q;
q = new Node;
q->info = y;
q->next = L[x];
L[x] = q;
}

file.close();
}
void displayList(Node *q) {
if (q == nullptr)
cout << "empty!";
while (q != NULL) {
cout << q->info << " ";
q = q->next;
}
cout << endl;
}
int degree(int x) { // Calculates the degree of node x
Node *q;
q = L[x];
int k = 0;
while (q != NULL) {
k++;
q = q->next;
}
return k;
}
void displayMaxDegreeNodes() {
int maxDegree = -1;

int nodesWithMaxDegree[n];
for (int i = 1; i <= n; i++) {
int nodeDegree = degree(i);
if (nodeDegree > maxDegree)
maxDegree = nodeDegree;
}
for (int i = 1; i <= n; i++)
if (degree(i) == maxDegree)
cout << i << " ";
}
bool isolatedNodes(int x, int y) {
Node *q;
q = L[x];
while (q != NULL) {
if (q->info == y)
return true;
q = q->next;
}
return false;
}
int main() {
int x, y;
readGraph();

// Displaying adjacency lists
cout << "Adjacency lists are: " << endl;
for (int i = 1; i <= n; i++) {
cout << "node " << i << " has list ";
displayList(L[i]);
}
// Calculating and displaying the degree of a node
cout << "Node="; cin >> x;
cout << x << " has a degree of " << degree(x) << endl;
// Displaying nodes adjacent to a given node
cout << "Node adjacent to node x" << endl;
cout << "x="; cin >> x;
if (L[x] == nullptr)
cout << "isolated node";
else
displayList(L[x]);
cout << endl;
// Displaying the degree of all nodes
for (int i = 1; i <= n; i++)
cout << "Node " << i << " has a degree of " << degree(i)
<< endl;
// Checking if the graph is complete
if (m == (n * (n - 1)) / 2)

cout << "Complete graph" << endl;
else
cout << "The graph is not complete" << endl;
// Displaying nodes with maximum degree
cout << "Nodes with maximum degree: ";
displayMaxDegreeNodes();
cout << endl;
// Displaying isolated nodes
cout << "Isolated nodes are: ";
isolatedNodes();
if (!ok)
cout << "There are no isolated nodes" << endl;
// Checking adjacency of nodes
cout << "x="; cin >> x;
cout << "y="; cin >> y;
if (isolatedNodes(x, y))
cout << "Nodes are adjacent" << endl;
else
cout << "Nodes are NOT adjacent" << endl;
return 0;
}

1. Read a graph from the file graph.txt: the number of
nodes, n (n≤30), and then the adjacency matrix
associated with it. Generate the adjacency lists
corresponding to the graph.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int a[31][31];
int n;
struct node
{
int info;
nod *next;
}*L[31];
void readData()
{
ifstream f("graph.txt");
f>>n;
for(int i=1;i<=n;i++)
for(int j=1;j<=n;j++)
f>>a[i][j];
f.close();

}
void displayList()
{
for (int i=1; i<=n; i++)
{
cout<<"Adjacency list for node "<<i<<": ";
nod *q=L[i];
if(q==0)
cout<<"Empty list!";
while(q!=NULL)
{
cout<<q->info<<" ";
q=q->next;
}
cout<<endl;
}
cout<<endl;
}
void generate()
{
for (int i=1; i<=n; i++)
{
L[i]=NULL;

for (int j=1; j<=n; j++)
{
if (a[i][j]==1)
{
nod *q=new nod;
q->info=j;
q->next=L[i];
L[i]=q;
}
}
}
}
int main()
{
readData();
generate();
displayList();
return 0;
}
1. The file friends.in stores, on the first line, a natural
number n (n≤30) representing the number of
individuals, and a natural number m1 representing
the number of pairs of friends. The following m1

lines store the pairs of friends. Similarly, in the file
neighbors.in, a value m2 is stored, representing
the number of pairs of neighbors, and the next m2
lines store the pairs of neighbors for the same n
individuals. Display the pairs of individuals who are
both friends and neighbors.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
struct Node
{
int info;
Node *next;
};
int n, m1, m2;
Node *L[31], *P[31];
int pairs_displayed[31][31];
void readInput()
{
ifstream file_friends("friends.in");
file_friends >> n >> m1;
for (int i = 1; i <= m1; i++)

{
int x, y;
file_friends >> x >> y;
Node *q = new Node;
q->info = y;
q->next = L[x];
L[x] = q;
q = new Node;
q->info = x;
q->next = L[y];
L[y] = q;
q = new Node;
q->info = y;
q->next = P[x];
P[x] = q;
q = new Node;
q->info = x;
q->next = P[y];
P[y] = q;
}
file_friends.close();
ifstream file_neighbors("neighbors.in");
file_neighbors >> m2;

for (int i = 1; i <= m2; i++)
{
int x, y;
file_neighbors >> x >> y;
Node *q = new Node;
q->info = y;
q->next = L[x];
L[x] = q;
q = new Node;
q->info = x;
q->next = L[y];
L[y] = q;
}
file_neighbors.close();
}
bool areFriendsAndNeighbors(int x, int y)
{
Node *p = P[x];
while (p != NULL)
{
if (p->info == y)
{
Node *q = L[x];

while (q != NULL)
{
if (q->info == y)
return true;
q = q->next;
}
break;
}
p = p->next;
}
return false;
}
void displayFriendsAndNeighbors()
{
cout << "Friends and neighbors:" << endl;
for (int i = 1; i <= n; i++)
{
Node *p = L[i];
while (p != NULL)
{
if (areFriendsAndNeighbors(i, p->info) &&
pairs_displayed[i][p->info] == 0)
{

cout << "(" << i << ", " << p->info << ")" << endl;
pairs_displayed[i][p->info] = pairs_displayed[p->info][i]
= 1;
}
p = p->next;
}
}
}
int main()
{
readInput();
displayFriendsAndNeighbors();
return 0;
}
1. n (n≤30) athletes participate in a tennis
championship. The competition situation is known
at a given moment, expressed as the number m of
matches, each represented as a triplet (a, b, c),
where c can take one of the values 1, -1, or 0. The
meanings are as follows: 1 represents a victory for
player a, -1 represents a victory for player b, and 0
signifies a draw.

a. Display, for each player, the number of matches
played, the number of victories, defeats, and
draws.
b. Display the players who have played all possible
matches.
c. Who are the top three players with the best score?
d. Display, for each player, the players with whom
they still need to have matches.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int n, m, a, b, c;
int matr[31][31];
int victories[31]; // number of victories for each player
int defeats[31];  // number of defeats for each player
int draws[31];  // number of draws for each player
int matches[31];  // total number of matches played for
each player
void readInput()
{
ifstream file("data.in");
file >> n >> m;

for (int i = 1; i <= m; i++)
{
file >> a >> b >> c;
if (c == 1)
{
victories[a]++;
defeats[b]++;
}
else if (c == -1)
{
victories[b]++;
defeats[a]++;
}
else if (c == 0)
{
draws[a]++;
draws[b]++;
}
matches[a]++;
matches[b]++;
matr[a][b] = matr[b][a] = c * 10;
}
file.close();

}
void displayMatrix()
{
for (int i = 1; i <= n; i++)
{
for (int j = 1; j <= n; j++)
cout << matr[i][j] << " ";
cout << endl;
}
cout << endl;
}
void displayPlayerInfo()
{
// Display information about players
for (int i = 1; i <= n; i++)
{
cout << "Player " << i << ":" << endl;
cout << "Number of matches played: " << matches[i] <<
endl;
cout << "Number of victories: " << victories[i] << endl;
cout << "Number of defeats: " << defeats[i] << endl;
cout << "Number of draws: " << draws[i] << endl;
cout << endl;

}
}
void playersAllMatches()
{
for (int i = 1; i <= n; i++)
{
bool playedAll = true;
for (int j = 1; j <= n; j++)
{
if (i != j && matr[i][j] == 0)
{
playedAll = false;
break;
}
}
if (playedAll)
{
cout << "Player " << i << " has played all possible
matches." << endl;
}
}
}
void topThreePlayers()

{
// Calculate scores
int scores[31];
for (int i = 1; i <= n; i++)
scores[i] = victories[i] - defeats[i];
// Find the top three players
int displayedPlayers[3] = {0, 0, 0}; // initialize the vector
with 0
int maxScores[3] = {-100, -100, -100}; // initialize the
vector with a very low score
for (int i = 1; i <= n; i++)
{
// compare the current score with the top three scores
found so far
if (scores[i] > maxScores[0])
{
// move the player from position 2 to position 3
displayedPlayers[2] = displayedPlayers[1];
maxScores[2] = maxScores[1];
// move the player from position 1 to position 2
displayedPlayers[1] = displayedPlayers[0];
maxScores[1] = maxScores[0];
// add the new player to position 1

displayedPlayers[0] = i;
maxScores[0] = scores[i];
}
else if (scores[i] > maxScores[1])
{
// move the player from position 2 to position 3
displayedPlayers[2] = displayedPlayers[1];
maxScores[2] = maxScores[1];
// add the new player to position 2
displayedPlayers[1] = i;
maxScores[1] = scores[i];
}
else if (scores[i] > maxScores[2])
{
// add the new player to position 3
displayedPlayers[2] = i;
maxScores[2] = scores[i];
}
}
cout << "Top 3 players:" << endl;
// Display the top three players
for (int i = 0; i < 3; i++)
if (displayedPlayers[i] != 0)

cout << "Player " << displayedPlayers[i] << ": score "
<< maxScores[i] << endl;
}
void displayRemainingMatches()
{
for (int i = 1; i <= n; i++)
{
cout << "Player " << i << " against: ";
for (int j = 1; j <= n; j++)
if (matr[i][j] == 0 && i != j)
cout << j << " ";
cout << endl;
}
}
int main()
{
readInput();
displayMatrix();
displayPlayerInfo();
playersAllMatches();
topThreePlayers();
displayRemainingMatches();
return 0;

}
1. The n (n≤30) students in a class must work on
projects in teams of at least 2 and at most 4
students at the end of the year. The teacher takes
into account the preferences and working affinities
of the students. The m pairs of students who can
collaborate on a project are known. Display, if
possible, a solution for dividing the students into
groups, taking into account the students' affinities.
Each student in a group collaborates well with at
least one other student in the same group.
Example: n=8, m=7
1 4
1 8
4 8
4 5
2 5
3 6
6 7
A solution is: (1, 4, 8), (2, 5), (3, 6, 7)
Implementation:

#include <iostream>
#include <fstream>
using namespace std;
int n,m,a[31][31];
int grupe[31];
void citire()
{
ifstream f("data.in");
f>>n>>m;
for(int i=1;i<=m;i++)
{
int x,y;
f>>x>>y;
a[x][y]=a[y][x]=1;
}
}
void form_groups()
{
int grupa_curenta=1;
grupe[1]=1;//1st student in 1st group
//iterate through each student
for(int i=2; i<=n; i++)
{

bool found_group=false;
//find an existing group
for (int j=1; j<=grupa_curenta; j++)
{
bool can_collaborate=true;
//check if there is at least one student in the group
for (int k=1; k<i; k++)
{
if (a[i][k] && grupe[j]==k)
{
can_collaborate=true;
break;
}
else
can_collaborate=false;
}
//add the student and break loop
if(can_collaborate)
{
grupe[i]=j;
found_group=true;
break;
}

}
// if not group is found, create a new one
if (!found_group)
{
grupa_curenta++;
grupe[i]=grupa_curenta;
}
}
}
void afisare_grupe()
{
for(int i=1;i<=n;i++)
cout<<"Student "<<i<<" belongs to group: "<<grupe[i]
<<endl;
}
int main()
{
citire();
form_groups();
afisare_grupe();
return 0;
}

1. Determine whether a square matrix read from a file
can be associated with an undirected graph. If so,
determine the number of edges in the graph.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int n,m,a[31][31];
void readData()
{
ifstream f("data.in");
f>>n;
for(int i=1;i<=n;i++)
for(int j=1;j<=n;j++)
f>>a[i][j];
f.close();
}
bool esteAdiacenta()
{
bool este_graf=true;
for(int i=1;i<=n;i++)
{

// check if primary diagonal has 0s
if (a[i][i]!=0)
{
este_graf=false;
break;
}
for (int j=1; j<i; j++)
{
// check simetry of matrix
if (a[i][j]!=a[j][i])
{
este_graf=false;
break;
}
// count the edges
if (a[i][j]==1)
m++;
//check if the elements are only 0s and 1s
if (a[i][j] != 0 && a[i][j] != 1)
{
este_graf=false;
break;
}

}
if (!este_graf)
break;
}
return este_graf;
}
int main()
{
readData();
if(esteAdiacenta())
{
cout<<"True, adjacency matrix"<<endl;
cout<<"Number of edges is: "<<m;
}
else
cout<<"False";
return 0;
}
1. In a group of n (n≤30) individuals, there are
interpersonal relationships. The names of
individuals and the m pairs of acquaintances
expressed by their names are known. Display the

VIPs, meaning those individuals who have the most
acquaintances.
Implementation:
#include <iostream>
#include <fstream>
#include <cstring>
using namespace std;
int n,m,a[31][31];
char nume[31][31];
struct nod
{
char nume[21];
int num_stiut;
int vecini[31];
int num_vecini;
}noduri[31];
void dfs(int nod, bool vizitate[])
{
vizitate[nod]=true;
noduri[nod].num_stiut=noduri[nod].num_vecini;
for(int i=1; i<=noduri[nod].num_vecini; i++)
{

int vecin=noduri[nod].vecini[i];
if (!vizitate[vecin])
dfs(vecin,vizitate);
}
}
void citire()
{
ifstream f("date.in");
f>>n>>m;
for(int i=1;i<=m;i++)
{
f>>noduri[i].nume;
noduri[i].num_stiut=0;
noduri[i].num_vecini=0;
}
for(int i=1; i<=m; i++)
{
char nume1[31],nume2[31];
f>>nume1>>nume2;
int nod1=-1,nod2=-1;
for(int j=1; j<=n; j++)
{
if(strcmp(noduri[j].nume,nume1)==0)

nod1=j;
if(strcmp(noduri[j].nume,nume2)==0)
nod2=j;
}
a[nod1][nod2]=a[nod2][nod1]=1;
}
f.close();
}
void VIP()
{
//build the list of neighbours
for(int i=1; i<=n; i++)
{
for(int j=1; j<=n; j++)
{
if (a[i][j]==1)
{
noduri[i].vecini[noduri[i].num_vecini]=j;
noduri[i].num_vecini++;
}
}
}
//calculate the number of friends

bool vizitat[31];
for (int i=1; i<=n; i++)
vizitat[i]=false;
for(int i=1; i<=n; i++)
if(!vizitat[i])
dfs(i,vizitat);
// find VIPs
int max_known=-1;
for(int i=1; i<=n; i++)
{
if(noduri[i].num_stiut>max_known)
max_known=noduri[i].num_stiut;
}
for(int i=1; i<=n; i++)
if(noduri[i].num_stiut==max_known)
cout<<noduri[i].nume<<endl;
}
int main()
{
citire();
for(int i=1;i<=n;i++)
{
for(int j=1;j<=n;j++)

cout<<a[i][j]<<" ";
cout<<endl;
}
cout<<endl;
VIP();
return 0;
}
1. In the files g1.txt and g2.txt, two undirected graphs
are stored as follows: on the first line, a natural
number n (n≤30) representing the number of
nodes, and then, until the end of the file, pairs x, y
representing the edges. Determine whether G2 is a
partial graph of G1.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int n1,n2;
int a1[31][31],a2[31][31];
void citire()
{
ifstream f("g1.txt");

ifstream g("g2.txt");
int x,y;
f>>n1;
while(f>>x>>y)
a1[x][y]=a1[y][x]=1;
g>>n2;
while(g>>x>>y)
a2[x][y]=a2[y][x]=1;
f.close();
g.close();
}
bool graf_partial()
{
for(int i=1;i<=n1;i++)
for(int j=1;j<=n1;j++)
if(a2[i][j]==1 && a1[i][j]==0)
return false;
return true;
}
int main()
{
citire();
if(n1!=n2)

cout<<"G2 is not a partial graph of G1";
else
if(graf_partial())
cout<<"G2 is a partial graph of G1";
else
cout<<"Not a partial graph.";
return 0;
}
1. Consider a graph G1 for which the number of
nodes n (n≤30) and the m edges are known. The
graph G2 is the complement of graph G1 if it has
the same number of nodes, and nodes (i, j) in G2
are adjacent only if they are not adjacent in G1.
Build in memory and display the adjacency matrix
of graph G2.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int n,m;
int a1[31][31],a2[31][31];;
void readData()

{
ifstream f("g1.txt");
int x,y;
f>>n>>m;
for (int i=1; i<=m; i++)
{
f>>x>>y;
a1[x][y]=a1[y][x]=1;
}
f.close();
}
void buildComplement()
{
for(int i=1; i<=n; i++)
{
for(int j=1; j<=n; j++)
{
if (a1[i][j]==0)
a2[i][j]=a2[j][i]=1;
}
}
}
void display(int a[31][31],int n1)

{
for(int i=1; i<=n1; i++)
{
for (int j=1; j<=n1; j++)
cout<<a[i][j]<<" ";
cout<<endl;
}
cout<<endl;
}
int main()
{
readData();
buildComplement();
cout<<"Adjacency matrix of G1: "<<endl;
display(a1,n);
cout<<"Adjacency matrix of G2: "<<endl;
display(a2,n);
return 0;
}
1. Consider a graph G1 for which the number of
nodes n (n≤30) and the m edges are known. The
graph G2 is the complement of graph G1 if it has
the same number of nodes, and nodes (i, j) in G2

are adjacent only if they are not adjacent in G1.
Two undirected graphs are stored in the files g1.txt
and g2.txt as follows: on the first line, a natural
number n (n≤30) representing the number of
nodes, and then, until the end of the file, pairs x, y
representing the edges. Determine whether G2 is
the complement of G1.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int n;
int a1[31][31],a2[31][31];
void readData()
{
ifstream f("g1.txt");
ifstream g("g2.txt");
int x,y;
f>>n;
g>>n;
while(f>>x>>y)
a1[x][y]=a1[y][x]=1;
while(g>>x>>y)

a2[x][y]=a2[y][x]=1;
f.close();
g.close();
}
bool isComplement()
{
bool complement=true;
for(int i=1; i<=n; i++)
{
for (int j=i + 1; j<=n; j++)
{
// check if (i,j) is adjacent in G1 and not in G2
if (a1[i][j]==1 && a2[i][j]==0)
{
complement=false;
break;
}
//check if (i,j) is not adjacent in G1 but is in G2
if (a1[i][j]==0 && a2[i][j]==1)
{
complement=false;
break;
}

}
if (!complement)
break;
}
return complement;
}
int main()
{
readData();
if(isComplement())
cout<<"G2 is complement for G1.";
else
cout<<"G2 is not complement for G1.";
return 0;
}
1. Write a program to generate all graphs with n
nodes and m edges (n≤10).
Example: For n=3 and m=2, the generated graphs
are:
(1,2), (1,3)
(1,2), (2,3)

(1,3), (2,3)
Implementation:
#include <iostream>
using namespace std;
int n,m;
int st[31],top=-1;
bool muchii[31][31];
void afisare()
{
for (int i=1; i<=n; i++)
{
for (int j=1; j<=n; j++)
{
if (muchii[i][j])
cout<<"("<<i<<","<<j<<")";
}
}
cout<<endl;
}
bool esteAdiacenta()
{
bool viz[31];

for (int i=1; i<=n; i++)
viz[i]=false;
viz[st[1]]=true;
for(int i=1; i<=top; i++)
{
for(int j=1; j<=n; j++)
{
if (muchii[st[i]][j] && !viz[j])
viz[j]=true;
}
}
for(int i=1; i<=n; i++)
if (!viz[i])
return false;
return true;
}
void generateGraphs(int node, int edgesLeft)
{
if (edgesLeft==0)
if (esteAdiacenta())
afisare();
for(int i=node; i<=n; i++)
{

for(int j=i+1; j<=n; j++)
{
if (!muchii[i][j])
{
muchii[i][j]=muchii[j][i]=true;
top++;
st[top]=i;
generateGraphs(i,edgesLeft-1);
top—;
muchii[i][j]=muchii[j][i]=false;
}
}
}
}
int main()
{
cout<<"n=";cin>>n;
cout<<"m=";cin>>m;
generateGraphs(1,m);
return 0;
}

1. Determine whether a graph is Hamiltonian. If
affirmative, display a Hamiltonian cycle. The
number of nodes n (n≤30), the number of edges
m, and the edges are known.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int n,m;
int a[31][31],x[31],ok,p[31];
void readData()
{
ifstream f("g1.txt");
int x,y;
f>>n>>m;
for(int i=1;i<=m;i++)
{
f>>x>>y;
a[x][y]=a[y][x]=1;
}
}
void display()
{

for(int i=1; i<=n; i++)
cout<<x[i]<< " ";
cout<<x[1];
ok=1;
}
void back(int k)
{
for(int i=1 ; i<=n && !ok; i++)
if(!p[i])
{
p[i]=1;
x[k]=i;
if(k==1 || a[x[k-1]][x[k]]==1)
{
if(k==n && a[x[k]][x[1]]==1)
ok=1;
else
back(k+1);
}
p[i]=0;
}
}
int main()

{
readData();
back(1);
if(ok==0)
cout<<"Graph is not hamiltonian ";
else
{
cout<<"It is Hamiltonian, "<<endl;
cout<<"One cycle is: ";
display();
}
return 0;
}
1. Color a graph in such a way that any two edges
incident to the same node are colored differently.
What is the minimum number of colors required?
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int n;
int a[31][31];

void read()
{
ifstream f("g1.txt");
int x,y;
f>>n;
while(f>>x>>y)
a[x][y]=a[y][x]=1;
}
void det()
{
int cul[31]={0}; //vector of colors
int nr=0; //min number of edges
for(int i=1; i<=n; i++)
{
bool cul_fol[31]={false}; // used colors vector
for(int j=1; j<i; j++)
{
if (a[i][j] && cul[j]!=0)
cul_fol[cul[j]]=true;
}
int c;
for(c=1; c<=nr; c++)
{

if (!cul_fol[c])
break;
}
if (c>nr)
nr++;
cul[i]=c;
}
cout<<"Minimum number of colors is: "<<nr<<endl;
}
int main()
{
read();
det();
return 0;
}
1. Consider a group of n (n≤30) people. The names
of the individuals are known. Each person has at
least n/2 friends, and the friends are given as pairs
of names. One person in the group has a book that
everyone wants to read. Determine a way for the
book to circulate to each person exactly once, with
its transmission occurring only between two
friends. In the end, the book should return to its

original owner. If there is no such solution, display
a message.
Implementation:
#include <iostream>
#include <fstream>
#include <cstring>
using namespace std;
int n;
int a[31][31];
char nume[31][100];
bool visited[31]={false};
void read()
{
ifstream f("g1.txt");
int x,y;
char nume1[30],nume2[30];
f>>n;
for(int i=1;i<=n;i++)
f>>nume[i];
while(f>>nume1>>nume2)
{
x=y=-1;

for(int i=1;i<=n;i++)
{
if(strcmp(nume1,nume[i])==0)
x=i;
if(strcmp(nume2,nume[i])==0)
y=i;
if(x!=-1 && y!=-1)
{
a[x][y]=a[y][x]=1;
break;
}
}
}
}
void afi()
{
for(int i=1;i<=n;i++)
{
for(int j=1;j<=n;j++)
cout<<a[i][j]<<" ";
cout<<endl;
}
}

bool backtracking(int prop, int current, int step)
{
if(step ==n)
// go through all people and then ending at first person
return a[current][prop];
for(int i=1; i<=n; i++)
{
if(a[current][i] && !visited[i])
{
visited[i]=true;
if(backtracking(prop,i,step+1))
{
// found a solution
cout<<nume[i]<<" -> "<<nume[current]<<endl;
return true;
}
visited[i]=false;
}
}
// no solution found for current person
return false;
}
void solve()

{
for(int i=1; i<=n; i++)
{
visited[i]=true;
if(backtracking(i,i,1))
{
// found a solution starting from i person
return;
}
visited[i]=false;
}
cout<<"No solution found."<<endl;
}
int main()
{
read();
afi();
solve();
return 0;
}
1. Write a program that checks whether there is an
elementary cycle of length k in an undirected

graph, represented using an adjacency matrix. The
graph contains n nodes (n≤25), and k is input
from the keyboard.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int n;
int a[26][26];
bool visited[26];
int k;
void citire()
{
ifstream f("g1.txt");
int x,y;
f>>n;
while(f>>x>>y)
a[x][y]=a[y][x]=1;
f.close();
}
void afi()
{

for(int i=1;i<=n;i++)
{
for(int j=1;j<=n;j++)
cout<<a[i][j]<<" ";
cout<<endl;
}
}
bool esteCiclic(int node, int len, int start)
{
visited[node]=true;
if(len==k)
{
if(a[node][start])
return true;
else
return false;
}
for(int i=1; i<=n; i++)
{
if(a[node][i] && !visited[i])
{
if(esteCiclic(i,len+1,start))
return true;

}
}
visited[node]=false;
return false;
}
bool areCiclu(int len)
{
for(int i=1; i<=n; i++)
{
if (esteCiclic(i,1,i))
return true;
}
return false;
}
int main()
{
citire();
afi();
cout<<"k=";cin>>k;
if(areCiclu(k))
cout<<"We found a cycle of length "<<k<<endl;
else
cout<<"No cycle found for length: "<<k<<endl;

return 0;
}
1. Write a program that determines and displays the
longest chain and the longest cycle in an
undirected graph.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int n,xm[31],lm;
int a[31][31],x[31],viz[31];
void citire()
{
ifstream f("g1.txt");
int x,y;
f>>n;
while(f>>x>>y)
a[x][y]=a[y][x]=1;
f.close();
}
void lant(int k)
{

int j,cont;
cont=0;
for(j=1;j<=n;j++)
{
if(a[x[k-1]][j] && !viz[j])
{
cont=1;
x[k]=j;
viz[j]=1;
lant(k+1);
viz[j]=0;
}
if(!cont)
if(k-1>lm)
{
lm=k-1;
for(j=1;j<=lm;xm[j++]=x[j]);
}
}
}
void ciclu(int k, int nod_start)
{
int j,cont=0;

for(j=1; j<=n; j++)
{
if(a[x[k-1]][j] && !viz[j])
{
cont=1;
x[k]=j;
viz[j]=1;
if(k==n && a[x[n-1]][nod_start])
{
//We found a cycle
if(n>lm)
{
lm=n;
for(int i=1; i<=lm; i++)
xm[i]=x[i];
}
}
else
ciclu(k+1,nod_start);
viz[j]=0;
}
}
//cont=0;

}
void reset()
{
for(int i=1;i<=31;i++)
{
x[i]=0;
viz[i]=0;
xm[i]=0;
}
}
int main()
{
citire();
for(int i=1;i<=n;i++)
{
x[1]=i;
viz[i]=1;
lant(2);
viz[i]=0;
}
if(lm==1)
cout<<"No chains found.";
else

{
cout<<"One chain with max length: ";
for(int i=1;i<lm;i++)
cout<<xm[i]<<' ';
}
cout<<endl;
reset();
for(int i=1; i<=n; i++)
{
x[1]=i;
viz[i]=1;
ciclu(2,i);
viz[i]=0;
}
if(lm==1)
cout<<"No cycles found.";
else
{
cout<<"One cycle with max length: ";
for(int i=1;i<lm;i++)
cout<<xm[i]<<' ';
}
return 0;

}
1. Write a program that generates a text file to store
the data of an undirected graph. The following will
be generated: a random value for the number of
nodes n (n≤30), a value for m (the number of
edges), and m pairs of x, y representing edges
between x and y.
Implementation:
#include <iostream>
#include <fstream>
#include <cstdlib>
#include <ctime>
using namespace std;
int n,m;
int a[31][31];
void generate()
{
ofstream out("graf.txt"); // open output file
srand(time(NULL));// generate random numbers
int n=rand()%30+1;// generate numbers between 1-30
int m=rand()%(n*(n-1)/2+1);// generate edges from [0,n*
(n-1)/2]

out<<n<<" " <<m<<endl; // write the values in file
// write the values of edges in output
for(int i=1; i<=m; i++)
{
int x=rand()%n+1; // generate new random x node
int y=rand()%n+1; // generate new random y node
a[x][y]=a[y][x]=1;
out<<x<<" "<<y<<endl; // write out x,y in file
}
out<<endl<<"Adjacency matrix is: "<<endl;
for(int i=1;i<=n;i++)
{
for(int j=1;j<=n;j++)
out<<a[i][j]<<" ";
out<<endl;
}
out.close(); // close the output file
}
int main()
{
generate();
return 0;
}

1. Problem of coloring a map. Read 4 colors
(strings) and the names of n (n≤30) countries
(strings). Also known are pairs of neighboring
countries. Color the map so that no two adjacent
countries have the same color. Display a solution
such that for each country, specify the pair:
country-color.
Example:
6 countries
Ukraine, Romania, Hungary, Moldova, Bulgaria, Serbia
9 neighbors
Romania – Hungary
Romania – Ukraine
Romania – Moldova
Romania – Bulgaria
Romania – Serbia
Serbia – Hungary
Hungary – Ukraine
Ukraine – Moldova
Bulgaria – Serbia
If the 4 colors are: red, yellow, blue, green

A solution is:
Romania – red
Hungary – yellow
Ukraine – blue
Moldova – yellow
Bulgaria – yellow
Serbia – blue
Implementation:
#include <iostream>
#include <fstream>
#include <cstring>
using namespace std;
int n;
int a[31][31];
char tari[31][100];
char culori[4][10];
void citire()
{
ifstream f("g1.txt");
f>>n;
int x,y;

for(int i=1;i<=n;i++)
f>>tari[i];
for(int i=1;i<=4;i++)
f>>culori[i];
char tara1[31],tara2[31];
while(f>>tara1>>tara2)
{
x=y=-1;
for(int i=1;i<=n;i++)
{
if(stricmp(tara1,tari[i])==0)
x=i;
if(stricmp(tara2,tari[i])==0)
y=i;
if(x!=-1 && y!=-1)
{
a[x][y]=a[y][x]=1;
break;
}
}
}
f.close();
}

void afi()
{
cout<<"Available colors: ";
for(int i=1;i<=n;i++)
cout<<culori[i]<<" ";
cout<<endl;
cout<<"Adjacency matrix "<<endl;
for(int i=1;i<=n;i++)
{
for(int j=1;j<=n;j++)
cout<<a[i][j]<<" ";
cout<<endl;
}
cout<<endl;
}
void colorare()
{
char cul[31][10]={'\0'};
strcpy(cul[1],culori[1]);
for(int i=2; i<=n; i++)
{
bool culDisponibile[4]={true, true, true, true};
for(int j=1; j<i; j++)

if(a[i][j]==1)
culDisponibile[j]=false;
for(int j=1; j<=4; j++)
{
if(culDisponibile[j]==true)
{
strcpy(cul[i],culori[j]);
break;
}
}
}
cout<<"Countries and their color: "<<endl;
for(int i=1; i<=n; i++)
cout<<tari[i]<<" - "<<cul[i]<<endl;
}
int main()
{
citire();
afi();
colorare();
return 0;
}

16.2  UNDIRECTED GRAPHS.
TRAVERSAL
1. Consider a map that stores data about n (n≤30)
shopping centers and the streets representing
direct transportation possibilities, without
intermediate points, between m pairs of shopping
centers. From the file map.txt: read the number of
n centers, the number m of direct streets, and the
m streets expressed as pairs of shopping centers
with a direct connection.
a. Determine if there is a network of streets between
the pair of centers x, y entered from the keyboard.
b. Display all pairs x-y of centers between which
there is a transportation possibility.
Implementation:
#include <iostream>
#include <fstream>
#include <cstring>
using namespace std;
int n,m;
int a[31][31];
bool viz[31]; // save visited nodes
bool gasit=false; // if we found a path from x to y

void citire()
{
ifstream f("map.txt");
f>>n>>m;
int x,y;
for(int i=1;i<=m;i++)
{
f>>x>>y;
a[x][y]=a[y][x]=1;
}
f.close();
}
void afi()
{
cout<<"Adjacency matrix: "<<endl;
for(int i=1;i<=n;i++)
{
for(int j=1;j<=n;j++)
cout<<a[i][j]<<" ";
cout<<endl;
}
cout<<endl;
}

void dfs(int nod, int dest)
{
viz[nod]=true; // check node as visited
if(nod==dest)
// we reached our destination
gasit=true;
for(int i=1; i<=n; i++)
if(a[nod][i]==1 && !viz[i]) // we have an edge
dfs(i,dest); // adjacent node call
}
void afisare_perechi_drum()
{
cout<<"Edges with direct path: "<<endl;
for(int i=1;i<=n;i++)
{
for(int j=i+1;j<=n;j++)//only i<j edges
{
memset(viz, false, sizeof(viz)); //reset array
dfs(i,j); //check existence between I and j
if(viz[j])
{
cout<<i<<" "<<j<<endl;
}

}
}
}
int main()
{
citire();
afi();
int x,y;
cout<<"x=";cin>>x;
cout<<"y=";cin>>y;
dfs(x,y);
if(gasit)
cout<<"There is a path from x to y."<<endl;
else
cout<<"No path found."<<endl;
///——————————
afisare_perechi_drum();
return 0;
}
1. Consider an undirected graph. Determine whether
the graph contains cycles.
Implementation:

#include <iostream>
#include <fstream>
using namespace std;
int n;
int a[51][51];
bool vizitat[51*51];
bool ciclu=false;
void citire()
{
ifstream f("graph.txt");
f>>n;
int x,y;
while(f>>x>>y)
a[x][y]=a[y][x]=1;
f.close();
}
void afi()
{
cout<<"Adjacency matrix: "<<endl;
for(int i=1;i<=n;i++)
{
for(int j=1;j<=n;j++)
cout<<a[i][j]<<" ";

cout<<endl;
}
cout<<endl;
}
void DFS(int nod,int parinte)
{
vizitat[nod]=true;
for(int vecin=1; vecin<=n; vecin++)
{
if (a[nod][vecin] && vecin!=parinte)
{
if (vizitat[vecin])
ciclu=true;
else
DFS(vecin,nod);
}
}
}
int main()
{
citire();
afi();
for(int i=1; i<=n; i++)

if(!vizitat[i])
DFS(i,-1);
if(ciclu)
cout<<"We found cycles."<<endl;
else
cout<<"No cycles."<<endl;
return 0;
}
1. Let there be n computers (n≤30) operating in an
institution. Two computers are considered to be
part of a network if they are interconnected
directly or indirectly. The m pairs of directly
interconnected computers are known. Determine if
there is only one transmission path between two
computers, x and y. Display Yes or No.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int n,m;
int a[31][31];
bool vizitat[51];

int start,sfarsit;
void citire()
{
ifstream f("graph.txt");
f>>n>>m;
int x,y;
for(int i=1;i<=m;i++)
{
f>>x>>y;
a[x][y]=a[y][x]=1;
}
f.close();
}
void afi()
{
cout<<"Adjacency matrix: "<<endl;
for(int i=1;i<=n;i++)
{
for(int j=1;j<=n;j++)
cout<<a[i][j]<<" ";
cout<<endl;
}
cout<<endl;

}
bool DFS(int nod,int parinte)
{
vizitat[nod]=true;
if(nod==sfarsit)
return true;
for(int vecin=1; vecin<=n; vecin++)
{
if (a[nod][vecin] && vecin!=parinte)
{
if (vizitat[vecin])
return false;
if(DFS(vecin,nod))
return true;
}
}
return false;
}
int main()
{
citire();
afi();
cout<<"Nodes to check: ";

cin>>start>>sfarsit;
if(DFS(start,-1))
cout<<"Yes, there is a path from "<<start<<" to "
<<sfarsit<<endl;
else
cout<<"No path from " <<start<<" to "<<sfarsit<<endl;
return 0;
}
1. Among n (n≤30) companies, collaboration
relationships are established (pairs of companies
that collaborate are known). Determine the
minimum length of the intermediary chain for
company x to collaborate with company y.
Example:
n=9, m=10
1 3
1 4
2 3
2 4
2 6
3 5

4 6
4 7
6 7
8 9
x=6, y=3 results in a chain of length 2: 6, 2, 3.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int n,m;
int a[31][31];
void read()
{
ifstream f("graph.txt");
f>>n>>m;
int x,y;
for(int i=1;i<=m;i++)
{
f>>x>>y;
a[x][y]=a[y][x]=1;
}

f.close();
}
void dijkstra(int s, int dist[])
{
bool viz[31]={false};
for(int i=1; i<=n; i++)
dist[i]=10000;
dist[s]=0;
while(true)
{
int u=0;
for(int i=1; i<=n; i++)
if(!viz[i] && (u==0 || dist[i]<dist[u]))
u=i;
if(u==0 || dist[u]==10000)
break;
viz[u]=true;
for(int v=1; v<=n; v++)
{
if(a[u][v] && !viz[v])
{
int w=a[u][v]; // edge length
if(dist[u]+w<dist[v])

dist[v]=dist[u]+w;
}
}
}
}
int main()
{
read();
int x,y;
cout<<"x=";cin>>x;
cout<<"y=";cin>>y;
int dist[31];
dijkstra(x, dist);
if (dist[y]==10000)
cout<<"No path from "<<x<<" to "<<y<<endl;
else
cout<<"Min length is "<<dist[y]<<endl;
return 0;
}
1. Chain Matrix. Read an undirected graph with n
(n≤30) nodes and m edges. Construct the matrix
of chain existence (a[i][j] is 1 if there is a chain
from i to j, and 0 otherwise).

Example: For the graph:
6 5
1 4
4 3
4 6
6 3
6 5
The matrix obtained is:
0 0 1 1 1 1
0 0 0 0 0 0
1 0 0 1 1 1
1 0 1 0 1 1
1 0 1 1 0 1
1 0 1 1 1 0
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int n,m;
int a[31][31];

int md[31][31];
void read()
{
ifstream f("graph.txt");
f>>n>>m;
int x,y;
for(int i=1;i<=m;i++)
{
f>>x>>y;
a[x][y]=a[y][x]=1;
}
f.close();
}
void afi()
{
cout<<"Chain matrix: "<<endl;
for(int i=1;i<=n;i++)
{
for(int j=1;j<=n;j++)
cout<<md[i][j]<<" ";
cout<<endl;
}
cout<<endl;

}
void roy_warshall_floyd(int md[31][31])/*md chain
matrix*/
{
//copy elements from matrix a to md
int i,j,k;
for(i=1;i<=n;i++)
for(j=1;j<=n;j++)
md[i][j]=a[i][j];
for(k=1;k<=n;k++)
for(i=1;i<=n;i++)
for(j=1;j<=n;j++)
if(i!=j && md[i][j]==0 && md[i][k]==1 && md[k]
[j]==1)
md[i][j]=1;
}
int main()
{
read();
roy_warshall_floyd(md);
afi();
return 0;
}

1. The n (n≤30) squares in Venice are connected by
a system of canals. In Piazza San Marco, a
motorboat with a leaking fuel tank has polluted the
squares located at a distance less than or equal to
R from San Marco (assuming that the distance
between two squares is equal to the minimum
number of canals that must be traversed to reach
from one square to another). Determine the
number of polluted squares. The squares are
identified by numbers 1 to N, and the canals by
pairs of squares (i, j). Piazza San Marco is
numbered 1. The input data is read from a file in
the following format:
- On the first line: the number of squares (N), the
number of canals (C), and R.
- On the next C lines, each with a pair of numbers X Y
separated by a space, representing the existence of a
canal between X and Y.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int N,C,R;

int a[31][31];
int md[31][31];
void read()
{
ifstream f("graph.txt");
f>>N>>C>>R;
int x,y;
for(int i=1;i<=C;i++)
{
f>>x>>y;
a[x][y]=a[y][x]=1;
}
f.close();
}
void afi(int v[31][31],int n)
{
for(int i=1;i<=n;i++)
{
for(int j=1;j<=n;j++)
cout<<v[i][j]<<" ";
cout<<endl;
}
cout<<endl;

}
void roy_warshall_floyd(int md[31][31])/*md chain matrix
*/
{
//copy elements from a to md
int i,j,k;
for(i=1;i<=N;i++)
for(j=1;j<=N;j++)
md[i][j]=a[i][j];
for(k=1;k<=N;k++)
for(i=1;i<=N;i++)
for(j=1;j<=N;j++)
if(md[i][k] && md[k][j])
if (i!=j && (md[i][j]==0 || md[i][j]>md[i][k]+md[k][j]))
md[i][j]=md[i][k]+md[k][j];
// set 1s where chain length is <= R
for(i=1; i<=N; i++)
for(j=1; j<=N; j++)
if(md[i][j]<=R)
md[i][j]=1;
else
md[i][j]=0;
}

int countPolluted()
{
int count=0;
for(int i=2; i<=N; i++)
if(md[1][i]==1)
count++;
return count;
}
int main()
{
read();
cout<<"Adjacency matrix:"<<endl;
afi(a,N);
roy_warshall_floyd(md);
cout<<"No. of polluted piazzas: "<<countPolluted();
return 0;
}
1. Check if a graph is bipartite, and if so, display the
components of the two sets A and B. The graph is
represented by an adjacency matrix. The graph is
read from a file with the following format:

- On the first line: the number of nodes (N) and edges
(M), separated by a space.
- On the next M lines, each with a pair of numbers X Y
separated by a space, representing an edge between
X and Y.
Write a program that checks if a graph is bipartite,
and if so, prints sets A and B.
Example:
N=6, M=6
1 2
2 3
3 4
4 5
5 2
4 6
It is a bipartite graph. One solution is: A={1, 3, 5, 6},
B={2, 4}.
Implementation:
#include <iostream>

#include <fstream>
using namespace std;
int n,m;
int a[31][31];
void read()
{
ifstream f("graph.txt");
f>>n>>m;
int x,y;
for(int i=1;i<=m;i++)
{
f>>x>>y;
a[x][y]=a[y][x]=1;
}
f.close();
}
int c[1001];// queue to keep track of nodes
int cul[1001];// visited nodes – keep track
bool BFS(int start, int culoare)
{
// start from a starting point
int i=1;
int vf=0;

cul[start]=culoare;// check as visited
c[++vf]=start;// add to queue
while(i<=vf)
{
// still have elements in queue
int nod=c[i];// current node
for(int vecin=1; vecin<=n; vecin++)// loop through all
neighbours
if(a[nod][vecin]==1)
if(cul[vecin]==0)
{
// if it is not colored
cul[vecin]=-cul[nod]; //use different colour
c[++vf]=vecin;// add in queue
}
else if(cul[vecin]==cul[nod]) // we found a neighbour
with same color
return 0;// graph is not bipartite
i++;// next element from the queue
}
return 1;
}
int main()

{
read();
int p=1;
for(int i=1; i<=n; i++ )
if(cul[i]==0 && p)
p=(p && BFS(i,1));//call bfs for each conex component
if(p)
{
// we checked each component
cout<<"Yes, bipartite graph "<<endl;
for(int i=1; i<=n ;i++)// display the nodes from set A
if(cul[i]==1)
cout<<i<<" ";
cout<<"\n";
for(int i=1; i<=n ;i++)// display the nodes from set B
if(cul[i]==-1)
cout<<i<<" ";
}
else
cout<<"No, the graph is NOT bipartite.";
return 0;
}

1. The same requirements as the previous problem,
considering a graph represented by adjacency lists.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
struct nod
{
int info;
nod *next;
}*L[31];
int n,m;
void read()
{
nod *q;
int x,y;
ifstream f("graph.txt");
f>>n>>m;
for(int i=1;i<=m;i++)
{
f>>x>>y;
q=new nod;

q->info=x;
q->next=L[y];
L[y]=q;
q=new nod;
q->info=y;
q->next=L[x];
L[x]=q;
}
f.close();
}
void display(nod*q)
{
if(q==0)
cout<<"Empty!";
while(q!=NULL)
{
cout<<q->info<<" ";
q=q->next;
}
cout<<endl;
}
int c[1001];
int cul[1001];

bool BFS(int start, int culoare)
{
int i=1;
int vf=0;
cul[start]=culoare;
c[++vf]=start;
while(i<=vf)
{
int nodul=c[i];
nod *vecin;
for(vecin=L[nodul]; vecin!=NULL; vecin=vecin->next)
if(cul[vecin->info]==0)
{
cul[vecin->info]=-cul[nodul];
c[++vf]=vecin->info;
}
else if(cul[vecin->info]==cul[nodul])
return false;
i++;
}
return true;
}
int main()

{
int x,y;
read();
///————————————————————-
cout<<"Adjacency lists are: "<<endl;
for(int i=1; i<=n; i++)
{
cout<<"Node "<<i<<" has the following list: ";
display(L[i]);
}
int p=1;
for(int i=1; i<=n; i++ )
if(cul[i]==0 && p)
p=(p && BFS(i,1));// call bfs for each component
if(p)
{
cout<<"Bipartite graph."<<endl;
for(int i=1; i<=n ;i++)// display set A
if(cul[i]==1)
cout<<i<<" ";
cout<<endl;
for(int i=1; i<=n ;i++)// display set B
if(cul[i]==-1)

cout<<i<<" ";
}
else
cout<<"The graph is not bipartite.";
return 0;
}
1. From the file data.in, distinct natural numbers in
the range [2,50] are read. Generate an undirected
graph where the edges are determined by all pairs
of prime numbers among them. Store the graph
using an adjacency matrix.
a. Traverse the graph in breadth-first starting with the
first number read from the file.
b. Traverse the graph in depth-first starting with the
last number read from the file.
Example: If the file data.in stores the values 3, 8,
9, 4, 20, 6, 1, 2, the breadth-first traversal results in: 3,
2, 4, 8, 20, 9, and the depth-first traversal results in: 2,
3, 4, 9, 8, 20.
Implementation:
#include <iostream>
#include <fstream>

#include <cmath>
using namespace std;
int n;
int a[51][51];
int v[51],x[51];
int p,u;
int gcd(int x,int y)
{
while(x!=y)
if(x>y)
x=x-y;
else
y=y-x;
return x;
}
void reset()
{
for(int i=1;i<=n;i++)
v[i]=0;
}
void read()
{
ifstream f("data.in");

int x,y;
f>>x;
p=x;
int gcd1=-1;
int maxi=x;
while(f>>y)
{
if(y>maxi)
maxi=y;
if(y>=2 && y<=50)
{
gcd1=gcd(x,y);
if(gcd1==1)
a[x][y]=a[y][x]=1;
}
x=y;
u=y;///last value
}
n=maxi;
f.close();
}
void display()
{

int i,j;
for(i=1;i<=n;i++)
{
for(j=1;j<=n;j++)
cout<<a[i][j]<<" ";
cout<<endl;
}
cout<<endl;
}
void dfs(int k)
{
v[k]=1; //visit current node x
for(int i=1;i<=n;i++) // determine its neighbours
if(a[k][i]==1 && v[i]==0)
dfs(i); // continue with the neighbours
}
int bfs(int start)
{
int i,k,st,dr;
//queue
st=dr=1;
x[1]=start;
v[start]=1;//visit first node

while(st<=dr)//queue is not empty
{
k=x[st];//take an element
for(i=1;i<=n;i++)//traverse the queue
if(v[i]==0 && a[k][i]==1)//neighbour and not visited
{
v[i]=1;//visit it
x[++dr]=i;//add in the queue
}
st++;//delete from the queue
}
return dr;//return the number of visited nodes
}
int main()
{
read();
display();
dfs(u);
for(int i=1;i<=n;i++)
if(v[i]==1)
cout<<i<<" ";
cout<<endl;
reset();

bfs(p);
for(int i=1;i<=n;i++)
if(v[i]==1)
cout<<i<<" ";
return 0;
}
1. From the file data.in, distinct natural numbers in
the range [2,1000] are read. Generate an
undirected graph where the edges are determined
by all pairs of prime numbers among them. Store
the graph using adjacency lists.
a. Traverse the graph in breadth-first starting with the
first number read from the file.
b. Traverse the graph in depth-first starting with the
last number read from the file.
Example: If the file data.in stores the values 3, 8,
9, 4, 20, 6, 1, 2, the breadth-first traversal results in: 3,
2, 4, 8, 20, 9, and the depth-first traversal results in: 2,
3, 4, 9, 8, 20.
Implementation:
#include <iostream>
#include <fstream>

#include <cmath>
using namespace std;
int n;
int a[51][51];
int v[51],x[51];
int p,u;
int gcd(int x,int y)
{
while(x!=y)
if(x>y)
x=x-y;
else
y=y-x;
return x;
}
void reset()
{
for(int i=1;i<=n;i++)
v[i]=0;
}
void read()
{
ifstream f("data.in");

int x,y;
f>>x;
p=x;
int gcd1=-1;
int maxi=x;
while(f>>y)
{
if(y>maxi)
maxi=y;
if(y>=2 && y<=50)
{
gcd1=gcd(x,y);
if(gcd1==1)
a[x][y]=a[y][x]=1;
}
x=y;
u=y;///last value
}
n=maxi;
f.close();
}
void display()
{

int i,j;
for(i=1;i<=n;i++)
{
for(j=1;j<=n;j++)
cout<<a[i][j]<<" ";
cout<<endl;
}
cout<<endl;
}
void dfs(int k)
{
v[k]=1; //visit current node x
for(int i=1;i<=n;i++) // determine its neighbours
if(a[k][i]==1 && v[i]==0)
dfs(i); // continue with the neighbours
}
int bfs(int start)
{
int i,k,st,dr;
//queue
st=dr=1;
x[1]=start;
v[start]=1;//visit first node

while(st<=dr)//queue is not empty
{
k=x[st];//take an element
for(i=1;i<=n;i++)//traverse the queue
if(v[i]==0 && a[k][i]==1)//neighbour and not visited
{
v[i]=1;//visit it
x[++dr]=i;//add in the queue
}
st++;//delete from the queue
}
return dr;//return the number of visited nodes
}
int main()
{
read();
display();
dfs(u);
for(int i=1;i<=n;i++)
if(v[i]==1)
cout<<i<<" ";
cout<<endl;
reset();

bfs(p);
for(int i=1;i<=n;i++)
if(v[i]==1)
cout<<i<<" ";
return 0;
}
1. Matching in a Graph. Consider an undirected
graph with n nodes and m edges. A matching in
the graph is a subset of edges for which any two
edges in the subset are not adjacent. Determine:
a. If a subset p of edges represents a matching in the
graph.
b. The maximum matching in a graph.
Example: n=10, m=13
1 2
1 3
2 3
2 4
3 4
3 5

5 6
5 7
6 7
4 8
8 9
8 10
9 10
Subset p=3
1 2
3 5
9 10
Output: Yes
The maximum matching is: 1-2, 3-5, 6-7, 4-8, 9-10.
Implementation:
#include <iostream>
#include <fstream>
#include <cstring>
using namespace std;
const int MAXN = 31;
int n, m, p;

int a[MAXN][MAXN];
int cuplaj[MAXN];
bool viz[MAXN];
void read()
{
ifstream f("graph.txt");
int x,y;
f>>n>>m;
for(int i=1; i<=m; i++)
{
f>>x>>y;
a[x][y]=a[y][x]=1;
}
f>>p;
for(int i=1; i<=p*2; i++)
{
f>>x>>y;
a[x][y]=a[y][x]=2;
}
f.close();
}
bool DFS(int nod)
{

viz[nod]=true;
for(int i=1; i<=n; i++)
{
if(a[nod][i]==2 && !viz[i])
{
viz[i]=true;
if(cuplaj[i]==0 || (cuplaj[i]!=nod && DFS(cuplaj[i])))
{
cuplaj[nod]=i;
cuplaj[i]=nod;
return true;
}
}
}
return false;
}
bool este_cuplaj()
{
bool exista_cuplaj=false;
memset(cuplaj,0,sizeof(cuplaj));
for(int i=1; i<=n; i++)
{
if (cuplaj[i]==0)

{
memset(viz, false, sizeof(viz));
if (DFS(i))
exista_cuplaj = true;
}
}
return exista_cuplaj;
}
bool cuplaj_maxim()
{
bool exista_cuplaj=false;
memset(cuplaj,0,sizeof(cuplaj));
do {
int nr_cuplaje=0;
for(int i=1; i<=n; i++)
{
if (cuplaj[i]==0)
{
memset(viz, false, sizeof(viz));
if (DFS(i))
{
exista_cuplaj=true;
nr_cuplaje++;

}
}
}
} while (exista_cuplaj);
return true;
}
int main()
{
read();
if(este_cuplaj()==true)
{
cout<<"Yes, the subset is matching in graph\n";
for(int i=1; i<=n; i++)
{
if(cuplaj[i] != 0)
cout<<i<<" - "<<cuplaj[i]<<endl;
}
}
else
cout<<"There is no matching in the current graph.\n";
return 0;
}

16.3  UNDIRECTED GRAPHS.
CONNECTED COMPONENTS
1. Consider a map that stores data about n (n≤30)
shopping centers and the streets that represent
direct transport possibilities, without intermediate
points, between m pairs of shopping centers. From
the map.txt file: read the number of n centers, the
number m of direct streets, and the m streets
expressed as pairs of shopping centers with direct
connection.
a. Determine which shopping centers have streets
with the possibility of direct or indirect transport to
a shopping center x.
b. Determine the maximum number of shopping
centers with the possibility of direct or indirect
transport.
Implementation:
#include <iostream>
#include <fstream>
#include <queue>
using namespace std;
int a[31][31],n,m;
void read()

{
ifstream f("map.txt");
int x,y;
f>>n>>m;
for(int i=1; i<=m; i++)
{
f>>x>>y;
a[x][y]=a[y][x]=1;
}
f.close();
}
void connected_components(int x)
{
bool viz[31]={false};//visited array
for(int i=1; i<=n; i++)
if(a[x][i])// edge between x and i
viz[i]=true; // mark node i as visited
for(int i=1; i<=n; i++)
{
if(viz[i])
{
// if i was visited
for (int j=1; j<=n; j++)

{
if(a[i][j] && !viz[j])
viz[j]=true; // j is marked as visited
}
}
}
cout<<"There are paths, ";
cout<<"direct and indirect to "<<x<<" are: "<<endl;
for(int i=1; i<=n; i++)
{
if (viz[i])
cout<<i<<" ";
}
cout << endl;
}
int max_connected_components()
{
bool viz[31]={false};
int max_size=0;
for(int i=1; i<=n; i++)
{
if (!viz[i])
{

int size=0;
queue<int> q;//BFS
viz[i]=true;// node i as visited
q.push(i);  // add in the queue
while (!q.empty())
{
int node = q.front();
q.pop();
size++; // count no. Of connected components
for(int j=1; j<=n; j++)
{
if (a[node][j] && !viz[j])
{
viz[j]=true;// mark j as visited
q.push(j);  //add in the queue
}
}
}
if (size > max_size)
{
// we found a max length for a connected component
max_size=size;
}

}
}
return max_size;
}
int main()
{
read();
int x;
cout<<"x=";cin>>x;
connected_components(x);
cout<<endl;
cout<<"Max number is: "
<<max_connected_components();
return 0;
}
1. Consider n computers (n≤30) operating in an
institution. Two computers are considered part of a
network if they are interconnected directly or
indirectly. The m pairs of directly interconnected
computers are known. Determine:
a. Whether two computers, x and y, are part of the
same computer network.

b. The number of computer networks in the
institution.
c. The maximum number of computers in a network.
Display the computers in this network. If there are
multiple such networks, display all of them.
d. The minimum number of transmission media that
need to be added between pairs of computers to
obtain a single network. Display such a solution
expressed as pairs of computers that need to be
interconnected.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int a[31][31],n,m;
int v[31],nrc;
void dfs(int x , int val)
{
v[x]=val;
for(int i = 1 ; i <= n ; i++)
if(!v[i] && a[x][i]==1)
dfs(i , val) , v[i] = val;
}
void citire()

{
ifstream f("graph.txt");
int x,y;
f>>n>>m;
for(int i=1; i<=m; i++)
{
f>>x>>y;
a[x][y]=a[y][x]=1;
}
f.close();
}
void DFS(int x, bool visited[])
{
visited[x]=true;
for(int i=1; i<=n; i++)
{
if (a[x][i] && !visited[i])
DFS(i, visited);
}
}
bool este_conex(int x, int y)
{
bool visited[n+1];

for(int i=1; i<=n; i++)
visited[i]=false;
DFS(x,visited);
return visited[y];
}
int numara_retele()
{
bool visited[n+1];
int counter=0;
for(int i=1; i<=n; i++)
visited[i]=false;
for(int i = 1; i <= n; i++)
{
if(!visited[i])
{
counter++;
DFS(i, visited);
}
}
return counter;
}
void DFS1(int x, bool visited[], int& count)
{

visited[x]=true;
count++;
for(int i=1; i<=n; i++)
{
if (a[x][i] && !visited[i])
DFS1(i, visited, count);
}
}
void numar_maxim_calculatoare()
{
bool visited[n+1];
int max_count=0;
for (int i=1; i<=n; i++)
visited[i]=false;
for(int i=1; i<=n; i++)
{
if (!visited[i])
{
int count=0;
DFS1(i,visited,count);
if (count>max_count)
max_count=count;
}

}
cout<<"Max number of computers: "
<<max_count<<endl;
cout<<"Computers from same network: ";
for (int i=1; i<=n; i++)
visited[i] = false;
for(int i=1; i<=n; i++)
{
if (!visited[i])
{
int count=0;
DFS1(i,visited,count);
if (count==max_count)
{
cout<<i<<" ";
for(int j=1; j<=n; j++)
{
if(a[i][j] && visited[j])
cout<<j<<" ";
}
}
cout<<endl;
}

}
}
void afisare_muchii()
{
int nr_retele=numara_retele();
if(nr_retele==1)
cout<<"No edges needed.";
else
{
cout<<"Minimum number of edge is: "<<nr_retele-
1<<endl;
for(int i=1 ; i<=n ; i++)
if(v[i] == 0) dfs(i , nrc + 1) , nrc++;
bool visited[n+1];
for(int i=1; i<=n; i++)
visited[i]=false;
for(int i=2 ; i<=nr_retele-1; i++)
{
int rez=0;
for(int j=1 ; j<=n && rez==0; j++)
if(i==v[j]) rez=j;
cout << 1 << " " << rez << " ";
}

}
}
int main()
{
citire();
int x,y;
cout<<"x=";cin>>x;
cout<<"y=";cin>>y;
if(este_conex(x,y)==true)
cout<<"There is a network"<<endl;
else
cout<<"No network"<<endl;
cout<<numara_retele()<<" networks in the institution."
<<endl;
numar_maxim_calculatoare();
cout<<endl;
afisare_muchii();
return 0;
}
1. Consider a map that stores data about n (n≤30)
commercial buildings, residential buildings, and
streets that represent direct transport possibilities,
without intermediate points, between m pairs of

buildings. From the map.txt file: read the number
of n buildings, then from the next line, a sequence
of n values of 0 and 1 is read, assigning the
meaning of commercial building for the value 0 or
residential building for the value 1 to the buildings.
On the third line, the number m of direct streets
and those m streets expressed as pairs of buildings
with a direct link are stored.
a. Determine the commercial buildings for which
there are streets with the possibility of direct or
indirect transport to a residential building x.
b. Determine the number of areas with the possibility
of direct or indirect transport that include at least
one building of each type.
c. Determine if there are residential buildings without
the possibility of direct or indirect transport to
commercial buildings.
d. Determine the number of commercial buildings
without the possibility of direct or indirect transport
to residential buildings.
e. Add a minimum number of streets expressed as
pairs of buildings so that each residential building
has access to at least one commercial building,
and vice versa.
Implementation:

#include <iostream>
#include <fstream>
using namespace std;
int a[31][31],n,m;
int semnificatie[31];
bool viz[31];
int zone;
void read()
{
ifstream f("map.txt");
int x,y;
f>>n;
for(int i=1;i<=n;i++)
f>>semnificatie[i];
f>>m;
for(int i=1; i<=m; i++)
{
f>>x>>y;
a[x][y]=a[y][x]=1;
}
f.close();
}
void DFS(int nod)

{
viz[nod]=true;
for(int i=1; i<=n; i++)
if(a[nod][i]==1 && !viz[i] && semnificatie[i]==1)
DFS(i);
}
void setare()
{
for(int i=1;i<=n;i++)
viz[i]=false;
}
void direct(int x)
{
int rezultat[31],k=1;
setare();
DFS(x); // find all commercial buildings reachable from x
via direct or indirect street connections
for(int i=1; i<=n; i++)
{
if(semnificatie[i]==1 && viz[i]) // if i is a commercial
building and has been visited
{
rezultat[k]=i;

k++;
}
}
if(k==1)
cout<<"There’s no path."<<endl;
else
{
for(int i=1;i<=k-1;i++)
cout<<rezultat[i]<<" ";
}
}
void DFS1(int nod, int s, int c)
{
viz[nod]=true;
if(semnificatie[nod]==s || semnificatie[nod]==c)
{
//we found a building of type s or c
//in this component
zone++; // mark as valid
for(int i=1; i<=n; i++)
{
if(a[nod][i]==1 && !viz[i])
DFS1(i,s,c); // continue

}
}
else
{
// we didn’t find a building of type s or c
for(int i=1; i<=n; i++)
{
if(a[nod][i]==1 && !viz[i])
DFS1(i, s, c); //continue
}
}
}
void zone_direct_indirect(int s, int c)
{
for(int i=1; i<=n; i++)
{
if(semnificatie[i]==s)
{
// a building of type s
// find at least type c
setare(); // reset the array
DFS1(i, s, c); // start DFS from building s
}

}
cout<<"Number of zones is: "<<zone<<endl;
}
bool areTransport(int nod)
{
setare();
DFS(nod);
for (int i = 1; i <= n; i++) {
if (semnificatie[i] == 0 && !viz[i]) {
//no path
return false;
}
}
// no building
return true;
}
void verificaTransport()
{
bool exista = false;
for (int i = 1; i <= n; i++) {
if (semnificatie[i] == 1) {
// ignore commercial buildings
continue;

}
if (!areTransport(i)) {
cout << "There is at least a building." << endl;
exista = true;
break;
}
}
if (!exista) {
cout << "All buildings have possiblity of transport." <<
endl;
}
}
void DFS2(int nod, bool& are_posibilitate)
{
viz[nod] = true;
for (int i = 1; i <= n; i++)
{
if (a[nod][i] == 1 && !viz[i])
{
if (semnificatie[i] == 0)
{
// found a commercial building
DFS2(i, are_posibilitate);

}
else if (semnificatie[i] == 1)
{
// we found a resident building
are_posibilitate = true;
}
}
}
}
int nr_cladiri_fara_posibilitate()
{
int nr = 0;
for (int i = 1; i <= n; i++)
{
if (semnificatie[i] == 0)
{
bool are_posibilitate = false;
setare();
DFS2(i, are_posibilitate);
if (!are_posibilitate)
{
nr++;
}

}
}
return nr;
}
int main()
{
read();
int x;
cout<<"x=";cin>>x;
direct(x);
///—————————-
cout<<endl;
zone_direct_indirect(0,1);
///—————————-
cout<<endl;
verificaTransport();
///—————————-
cout<<endl;
cout<<"Nr de cladiri: "<<nr_cladiri_fara_posibilitate()
<<endl;
return 0;
}

1. A labyrinth is formed by n (n≤30) rooms
numbered from 1 to n. There are corridors of
connection between m pairs of rooms. The pairs of
rooms between which there is a direct corridor are
known.
a. Determine if there is any room with a direct
corridor to all the others.
b. Determine if there are isolated rooms.
c. Determine the groups of rooms that have direct or
indirect access to all the other rooms in the group.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int a[31][31],n,m,k;
bool viz[31];
int grup[31];
void read()
{
ifstream f("graph.txt");
int x,y;
f>>n>>m;
for(int i=1; i<=m; i++)

{
f>>x>>y;
a[x][y]=a[y][x]=1;
}
f.close();
}
void dfs(int node)
{
viz[node]=true;
for(int i=1;i<=n;i++)
{
if(a[node][i]==1 && viz[i]==false)
dfs(i);
}
}
bool acces()
{
for(int i=1;i<=n;i++)
{
// reset the viz array
for(int j=1;j<=n;j++)
viz[j]=false;
dfs(i);

// check if all nodes have been visited
bool ok=true;
for(int j=1;j<=n;j++)
{
if(viz[j]==false)
{
ok=false;
break;
}
}
if(ok)
return true;
}
return false;
}
bool este_izolat(int node)
{
for(int i=1; i<=n; i++)
if(a[node][i]==1)
return false;
return true;
}
void gaseste_izolate()

{
bool izolate_exista=false;
for(int i=1; i<=n; i++)
{
if(este_izolat(i))
{
cout<<"Room "<<i<<" is isolated.\n";
izolate_exista=true;
}
}
if(!izolate_exista)
cout<<"No isolated rooms.\n";
}
void dfs2(int node)
{
viz[node]=true;
grup[k++]=node;
for(int i=1;i<=n;i++)
if(a[node][i]==1 && viz[i]==false)
dfs2(i);
}
void gasesteGrupuri()
{

for(int i=1;i<=n;i++)
{
k=0;
dfs2(i);
bool accesTot=false;
for(int j=1; j<=n; j++)
if(!viz[j])
accesTot=false;
if (accesTot)
{
cout<<"Nodes {";
for (int j=1; j<k; j++)
cout<<grup[j]<<", ";
cout<<"\b\b} have access to all rooms."<<endl;
}
}
}
int main()
{
read();
if(acces())
cout<<"There’s a room with a corridor to all rooms.\n";
else

cout<<"No such room.\n";
///———————
gaseste_izolate();
///———————
gasesteGrupuri();
return 0;
}
1. In a city, n (n≤50) points of interest are marked
on a map, along with m routes using different
means of transportation between pairs of points of
interest. It is observed that there are several
separate zones in the city, areas where circulation
is not possible. Determine:
a. The number of separate zones in the city.
b. Display the points of interest for each zone.
c. Display all the direct routes contained in each
zone.
d. Identify the zones traversed by the maximum
number of routes (display the points of interest and
routes they contain).
Example: For n=10, m=8, and the routes:
1 2

1 5
1 4
2 5
4 5
6 8
7 8
9 10
There are 4 zones in the city.
Zone 1 has points of interest: 1, 2, 4, 5
Zone 2 has points of interest: 6, 7, 8
Zone 3 has points of interest: 9, 10
Zone 4 has the point of interest 3
Zone 1 has routes: 1-2, 1-5, 1-4, 2-5, 4-5

Zone 2 has routes: 6-8, 8-7
Zone 3 has the route: 9-10
Zone 4 does not contain routes
The zone with the most routes is the one containing
points: 1, 2, 4, 5 and the routes 1-2, 1-5, 1-4, 2-5, 4-5.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int a[31][31],n,m,nr_zone,p;
int viz[31];
void read()
{
ifstream f("graph.txt");
int x,y;
f>>n>>m;
for(int i=1; i<=m; i++)
{
f>>x>>y;
a[x][y]=a[y][x]=1;

}
f.close();
}
void dfs(int nod,int comp[31],int &k)
{
viz[nod]=1;
comp[k++]=nod;
for(int i=1;i<=n;i++)
if(a[nod][i]==1 && viz[i]==0)
dfs(i,comp,k);
}
void afisare_trasee(int comp[31], int nr_comp, int k)
{
cout<<"Zone "<<nr_comp<<" has the following routes: "
<<endl;
bool exista_traseu=false;
for (int i=1; i<=k-1; i++)
{
for(int j=i+1; j<=k-1; j++)
{
if (a[comp[i]][comp[j]]==1)
{
cout<<comp[i]<<"-"<<comp[j]<<"  ";

exista_traseu = true;
}
}
cout<<" ";
}
if(!exista_traseu)
cout<<"Does not have any routes ";
cout<<endl;
}
void afisare_interese(int nr_trasee[31])
{
int nr_comp=0,k;
p=1;
for (int i=1; i<=n; i++)
{
k=1;
if (viz[i]==0)
{
nr_comp++;
int comp[31];
dfs(i, comp, k);
cout<<"Zone "<<nr_comp<<" has the following interests:
";

for(int j=1; j<=k-1; j++)
cout<<comp[j]<<" ";
cout<<endl;
nr_zone++;
afisare_trasee(comp, nr_comp, k);
nr_trasee[p++]=k-1;
}
viz[i]=0;
}
}
int main()
{
citire();
int comp[31],nr_trasee[31];
afisare_interese(nr_trasee);
int max_trasee=0,index=-1;
for(int i=1;i<p;i++)
if(nr_trasee[i]>max_trasee)
{
max_trasee=nr_trasee[i];
index=i;
}
cout<<"There are "<<nr_zone<<" zones."<<endl;

if(index!=-1)
{
cout<<"Zone "<<index<<" has the max. routes."<<endl;
int comp[31];
int k=1;
dfs(index, comp, k);
cout<<"Points of interest for zone "<<index<<" are: ";
for (int i=1; i<k; i++)
cout<<comp[i]<<" ";
cout<<endl;
cout<<"Routes for zone "<<index<<" are: ";
bool exista_traseu=false;
for(int i=1; i<k; i++)
{
for (int j=i+1; j<k; j++)
{
if (a[comp[i]][comp[j]]==1)
{
cout<<comp[i]<<"-"<<comp[j]<<" ";
exista_traseu=true;
}
}
}

if(!exista_traseu)
cout<<"There are no routes.";
cout<<endl;
}
else
cout<<"Does not exist.";
return 0;
}
1. n (n≤30) individuals are participating in a NASA
project. Each person xi has a number ki of
specializations expressed by natural numbers from
1 to p (p≤10). Following tests, it was found that
only certain pairs of individuals have excellent
communication compatibilities. NASA needs to
form a team consisting of at most p individuals
who can cover the p specializations and for whom
there are communication compatibilities with at
least two other individuals in the group. Is it
possible to create such a team? The following
information is known: the number n of individuals,
the specializations of the n individuals (the number
and type of specializations), the number p of
required specializations, and the m pairs of
individuals with communication compatibilities.

Example:
n=10, m=10, p=3
Specializations of the n individuals in order
 Individuals with communication
from 1 to n (number and type of specializations):
compatibilities:
2 1 2          1 2
1 1        1 4
1 1        1 5
1 2        2 5
2 1 2        3 4
2 1 2        4 5
2 1 2          6 7
1 2        6 8
2 1 3        7 8
2 1 2        9 10
1 3        There is a solution: the group 6, 7, 8.
Implementation:
#include <iostream>
#include <fstream>

using namespace std;
int a[31][31],n,m,p;
int ki[31],spec[31][11];
void readData()
{
ifstream f("NASA.txt");
int x,y;
f>>n>>m>>p;
for(int i=1; i<=m; i++)
{
f>>x>>y;
a[x][y]=a[y][x]=1;
}
for(int i=1;i<=n;i++)
{
f>>ki[i];
for(int j=1;j<=ki[i];j++)
f>>spec[i][j];
}
f.close();
}
bool compatible(int x, int y)
{

return a[x][y]==1;
}
bool is_solution(int group[], int len)
{
if (len!=p)
return false;
int specializations_covered[p+1]={0};
for(int i=0; i<len; i++)
{
for (int j=1; j<=ki[group[i]]; j++)
{
int speci=spec[group[i]][j];
if (speci>=1 && speci<=p)
specializations_covered[speci]++;
}
}
for(int i=1; i <= p; i++)
if(specializations_covered[i]==0)
return false;
for(int i=0; i<len; i++)
{
int count=0;
for(int j=0; j<len; j++)

if (i!=j && compatible(group[i], group[j]))
count++;
if (count<2)
return false;
}
return true;
}
bool backtrack(int group[], int index, int start, int len)
{
if (len==p)
return is_solution(group, len);
bool found_solution=false;
for(int i=start; i <= n; i++)
{
group[len]=i;
if(backtrack(group,index+1,i+1,len + 1))
{
found_solution=true;
break;
}
}
return found_solution;
}

int main()
{
readData();
int group[p];
if(backtrack(group, 0, 1, 0))
{
cout<<"There’a solotion. Group: ";
for (int i=0; i<p; i++)
cout<<group[i]<<" ";
cout<<endl;
}
else
cout<<"There’s no solution for the input data."<<endl;
return 0;
}
1. n (n≤30) individuals are participating in a NASA
project. Following tests, it was found that only
certain pairs of individuals have excellent
communication compatibilities. The task is to
determine the largest group of individuals for
which there are communication capabilities
between any two individuals in the group. The
known information includes the number n of

individuals and the m pairs of individuals with
communication compatibilities.
Example:
n=9, m=11
1 3
1 4
1 7
3 4
3 7
4 7
3 5
3 2
6 8
6 9
8 9
The requested group is: 1, 3, 4, 7
Implementation:
One way to solve this problem is to use a modified
version of the DFS algorithm, where connected

components are identified, and their sizes are
determined. This can be achieved through the
following method:
Initialize a visitation array viz of size n with initial
values of 0 (all nodes are unvisited).
Initialize a variable max_size to 0 (maximum size
of a connected component).
Traverse the viz array, and for each unvisited node,
initiate a Depth-First Search (DFS) starting from
that node.
During the DFS traversal, mark all visited nodes
(set viz[i]=1).
At the end of the DFS traversal, calculate the size
of the current connected component (number of
visited nodes) and compare it with the maximum
size value so far (max_size). If the size is larger
than max_size, update max_size and retain the
starting node of the connected component.
Repeat the process until all nodes have been
visited.
Finally, display the maximum size of a connected
component and all nodes of the connected
component with this size.
#include <iostream>
#include <fstream>

using namespace std;
int a[31][31],n,m;
int viz[31];
void readData()
{
ifstream f("NASA.txt");
int x,y;
f>>n>>m;
for(int i=1; i<=m; i++)
{
f>>x>>y;
a[x][y]=a[y][x]=1;
}
f.close();
}
void dfs(int nod, int &lungime)
{
viz[nod]=1;
lungime++;
for(int i=1; i<=n; i++)
if(a[nod][i] && !viz[i])
dfs(i,lungime);
}

int main()
{
readData();
int max_size=0;
int start_node=-1;
for(int i=1; i<=n; i++)
{
if(!viz[i])
{
int lungime=0;
dfs(i,lungime);
if(lungime>max_size)
{
max_size=lungime;
start_node=i;
}
}
}
cout<<"The requested group is: ";
for(int i=1; i<=n; i++)
if (a[start_node][i])
cout<<i<<" ";
cout<<start_node<<endl;

return 0;
}
1. Given n points in a plane: pi(xi, yi). Each point is
connected by a line to its nearest neighbor. If there
are multiple points at the minimum distance, it is
connected to all of them. We call a region a set of
points for which there is a chain between any two
points in the region.
a) Determine the number of regions.
b) Determine the region with the maximum number of
points.
Implementation:
#include <iostream>
#include <fstream>
#include <cmath>
using namespace std;
struct point
{
float x,y;
}p[31];
int n;
float a[31][31];

void readData()
{
ifstream f("graph.txt");
f>>n;
for(int i=1; i<=n; i++)
{
f>>p[i].x>>p[i].y;
a[i][i]=0;
for(int j=1; j<i; j++)
{
// don’t check the checked points
float distanta=sqrt(pow(p[i].x-p[j].x,2)+pow(p[i].y-
p[j].y,2));
if(distanta==0) // if dist=0, same points
continue;
if (a[i][j]==0 || distanta<a[i][j])
a[i][j]=a[j][i]=distanta;
}
}
f.close();
}
void dfs(int nod, int componenta[31], int& k)
{

componenta[nod]=1;
k++;
for(int i=1; i<=n; i++)
if(a[nod][i]!=0 && componenta[i]==0) // check if the
point has been included in the current component
dfs(i,componenta,k);
}
int main()
{
readData();
int nr_regiuni = 0;
int componenta[31] = {0};  // keep the current
component
for(int i=1; i<=n; i++)
{
if(componenta[i]==0)
{
//if the point has not been included
nr_regiuni++;
dfs(i, componenta, componenta[i] = 1);
}
}
cout<<"Number of regions is: "<<nr_regiuni<<endl;

// find the region with max points included
int max_num_puncte=0;
int max_componenta_id;
for(int i=1; i<=n; i++)
{
int num_puncte=0;
if (componenta[i]==1)
{
// check only the included points
for(int j=1; j<=n; j++)
if (componenta[j]==componenta[i])
num_puncte++;
if (num_puncte>max_num_puncte)
{
max_num_puncte=num_puncte;
max_componenta_id=i;
}
}
}
cout<<"The region with the max points is: ";
for(int i=1; i<=n; i++)
if(componenta[i]==1 && a[i][max_componenta_id]!=0)
cout<<i<<" ";

return 0;
}
1. A tree is an acyclic and connected graph. Multiple
trees form a forest. Determine if an undirected
graph is a forest. If so, find:
a. The number of trees in the forest.
b. The tree with the most nodes.
c. The tree with the most leaves.
d. Whether nodes x and y belong to the same tree.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int a[31][31],n,m;
int viz[31];
void readData()
{
ifstream f("graph.txt");
int x,y;
f>>n>>m;
for(int i=1; i<=m; i++)
{

f>>x>>y;
a[x][y]=a[y][x]=1;
}
f.close();
}
// traverse the graph
void DFS(int nod, int& nrNoduri, int& nrFrunze)
{
viz[nod]=1;
nrNoduri++;
bool esteFrunza=true;
for(int i=1; i<=n; i++)
{
if (a[nod][i]==1 && viz[i]==0)
{
DFS(i,nrNoduri,nrFrunze);
esteFrunza=false;
}
}
if(esteFrunza)
nrFrunze++;
}
void dfs(int k)

{
viz[k]=1; //vis the current node k
for(int i=1;i<=n;i++) // find the unvisited neighbours
if(a[k][i]==1 && viz[i]==0)
dfs(i); // continue DFS
}
void reset()
{
for(int i=1;i<=n;i++)
viz[i]=0;
}
int main()
{
readData();
// check if it’s a forest
bool ok=false;
for(int i=1;i<=n;i++)
dfs(i);
for(int i=1;i<=n;i++)
if(viz[i]!=0)
ok=true;
if(ok==true)
{

cout<<"Graph is a forest."<<endl;
int nrArbori=0;
reset();
for(int i=1; i<=n; i++)
{
if (!viz[i])
{
nrArbori++;
int nrNoduri=0,nrFrunze=0;
DFS(i, nrNoduri, nrFrunze);
if (nrNoduri==nrFrunze+1)
cout<<"Tree "<<nrArbori<<" with "<<nrNoduri<<"
nodes and "<<nrFrunze<<" leaves.\n";
else
cout<<"Component "<<nrArbori<<" with "
<<nrNoduri<<" nodes and "<<nrFrunze<<" leaves.\n";
}
}
}
else
cout<<"The graphs is not a forest."<<endl;
// check if 2 nodes are in the same tree.
int x1,y1;

cout<<"x,y: ";
cin>>x1>>y1;
if (a[x1][y1])
cout<<"Nodes "<<x1<<" & "<<y1<<" are in the same
tree.\n";
else
cout<<"Nodes "<<x1<<" & "<<y1<<" arent in the same
tree.\n";
return 0;
}
1. Bridges in Graphs. In Venice, there are n (n≤30)
points of interest. Movement from one point of
interest to another can be done through non-
navigable paths using m bridges that connect pairs
of points of interest in such a way that at this
moment, it is possible to travel between any two
points of interest. The city hall has decided to
strengthen certain bridges. For economic reasons,
only those bridges will be strengthened in the
absence of which the points of interest would
become isolated. The values for n, m, and m pairs
of numbers x, y with the meaning bridge from x to
y are read from the data.in file. In the data.out file,
the number p of bridges that need to be
strengthened and those p bridges as pairs of

numbers x, y with the meaning bridge from x to y
will be displayed.
Example:
data.in  data.out
8 9    3
1 2    4 5
1 4  3 5
2 4    7 8
4 5 
5 3 
5 6 
6 7 
5 7 
7 8 
Implementation:
To find the bridges in the graph, Tarjan's algorithm
for finding articulation points can be used. In this case,
we will look for bridges in the graph, i.e., edges that do
not belong to a cycle and, if removed, would make the
graph disconnected. Thus, for each edge in the graph,

we will check if its removal makes the graph
disconnected and if it is an edge that does not belong
to a cycle. If both conditions are met, then that edge is
a bridge and will be displayed.
A possible solution could be the following:
#include <iostream>
#include <fstream>
using namespace std;
int a[31][31],n,m;
int viz[31];
int timp[31],low[31], t;
int punte[31][2],nr_punte;
void read()
{
ifstream f("data.in");
int x,y;
f>>n>>m;
for(int i=1; i<=m; i++)
{
f>>x>>y;
a[x][y]=a[y][x]=1;
}
f.close();

}
void tarjan(int nod, int parinte)
{
timp[nod]=low[nod]=++t;
viz[nod]=1;
for(int vecin=1; vecin<=n; vecin++)
{
if(a[nod][vecin]==0)
continue;
if(vecin==parinte)
continue;
if (!viz[vecin])
{
tarjan(vecin,nod);
low[nod]=min(low[nod],low[vecin]);
if (low[vecin]>timp[nod])
{
punte[nr_punte][0]=nod;
punte[nr_punte][1]=vecin;
nr_punte++;
}
}
else

low[nod]=min(low[nod],timp[vecin]);
}
}
void gaseste_punti()
{
for(int i=1; i<=n; i++)
timp[i]=low[i]=viz[i]=0;
nr_punte=0;
t=0;
for (int i=1; i<=n; i++)
if (!viz[i])
tarjan(i,-1);
}
bool este_conex(int nod, int parinte, int destinatie, int
blocat)
{
if(nod==destinatie)
return true;
viz[nod]=1;
for(int vecin = 1; vecin <= n; vecin++)
{
if(a[nod][vecin]==0)
continue;

if(viz[vecin] || vecin==parinte || (nod==blocat &&
vecin==destinatie))
continue;
if(este_conex(vecin, nod, destinatie, blocat))
return true;
}
return false;
}
void displayOutput()
{
ofstream g("data.out");
g<<nr_punte<<endl;
for(int i=0; i<nr_punte; i++)
g<<punte[i][0]<<" "<<punte[i][1]<<endl;
g.close();
}
int main()
{
read();
gaseste_punti();
displayOutput();
return 0;
}

1. Articulation Points. In the First World War,
information transmission on the front lines was
done through telegraphy, using Morse code.
Telegraphic communication systems were
interconnected by wire cables. In strategic points,
there were two telegraph operators, while in other
points, there was only one operator. A strategic
point was considered to be one through which
communication with other points on different
routes would be lost if it fell. Knowing the n
(n≤30) locations of the telegraphs numbered from
1 to n and the m connection cables that connect
pairs of transmission points, display the points
where only one operator will be stationed. The
values for n, m, and m pairs of numbers x, y with
the meaning connection cable from x to y are read
from the data.in file. In the data.out file, the first
line will display the number p of points where only
one telegraph operator should be stationed, and
the next line will display the p order numbers of
the corresponding telegraphs.
Example:
data.in    data.out
8 9    3

1 2    1 2 6
1 4 
2 4 
4 5 
5 3 
5 6 
6 7 
5 7   
7 8 
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int a[31][31],n,m;
int viz[31],nivel[31],nma[31];
void readData()
{
ifstream f("data.in");
int x,y;
f>>n>>m;
for(int i=1; i<=m; i++)

{
f>>x>>y;
a[x][y]=a[y][x]=1;
}
f.close();
}
void dfs(int k,int tata,int &p,int sol[31])
{
viz[k]=1;
nivel[k]=nivel[tata]+1;
nma[k]=nivel[k];
for(int x=1; x<=n; x++)
{
if(a[k][x]==1)
{
if(x!=tata)
{
if(viz[x]==1)
{
if(nma[k]>nivel[x])
nma[k]=nivel[x];
}
else

{
dfs(x,k,p,sol);
if(nma[k]>nma[x])
nma[k]=nma[x];
if(nivel[k]<=nma[x] && k!=-1)
{
p++;
sol[p]=k;
}
}
}
}
}
}
int main()
{
int p,sol[31];
ofstream g("data.out");
readData();
for(int i=1;i<=n;i++)
if(viz[i]==0)
dfs(i,-1,p,sol);
g<<p<<endl;

for(int i=1;i<=p;i++)
g<<sol[i]<<" ";
return 0;
}
1. Computer Networks. A company owns multiple
networks consisting of n computers. There is a
total of m direct links between them so that within
the same network, direct or indirect
communication is possible between any two
computers. An imminent hacker attack is
anticipated, intending to disrupt one of the direct
links between two computers in a network,
potentially causing the targeted network to no
longer operate optimally. A network is considered
vulnerable if there is at least one critical pair of
computers that can no longer communicate
directly or indirectly. The number of critical pairs in
a network is called CNumber. The role of the
network administrator is to determine how many
such networks, called vulnerable networks, the
company owns and what is the maximum value
that CNumber can have.
Input: The first line of the input file networks.in
contains the number n of computers in the networks

(each computer is identified by a natural number in
the interval [1, n]) and the number m of direct links
between computers. Each of the following m lines will
contain two integers x and y, indicating that there is a
direct link between the computers identified by x and
y.
Output: The output file networks.out will contain
two natural numbers representing the number of
vulnerable networks and the maximum value for
CNumber.
Constraints and details:
1. ≤ n ≤ 100
networks.in    networks.out
16 14    3  2
1 2 
1 4 
2 4 
4 5 
5 6 
5 7 

6 7 
6 15 
8 9 
8 10 
9 10 
11 12 
12 13 
3 14 
Implementation:
#include <iostream>
#include <fstream>
#include <cmath>
using namespace std;
int a[101][101];
int n, m;
int idx[101],low[101],cnt,cnumber,num_vulnerable;
void read()
{
ifstream f("networks.in");
int x,y;
f>>n>>m;

for(int i=1; i<=m; i++)
{
f>>x>>y;
a[x][y]=a[y][x]=1;
}
f.close();
}
void tarjan(int u, int p)
{
idx[u]=low[u]=++cnt;
for(int v=1; v<=n; v++)
{
if(a[u][v] && v!=p)
{
if (!idx[v])
{
tarjan(v,u);
low[u]=min(low[u],low[v]);
if(low[v]>=idx[u])
{
cnumber=1;
for(int i=1; i<=n; i++)
{

if(a[u][i] && a[v][i])
cnumber++;
}
if(cnumber>=2)
num_vulnerable++;
}
}
else
low[u]=min(low[u],idx[v]);
}
}
}
int main()
{
ofstream g("networks.out");
read();
for (int i=1; i<=n; i++)
{
if (!idx[i])
tarjan(i,0);
}
g<<num_vulnerable<<" "<<cnumber+1<<endl;
return 0;

}
1. Biconnected Graph. A graph is called
biconnected if it does not lose connectivity by
removing a node. Given a graph stored as an
adjacency matrix, determine if it is biconnected.
Display Yes or No. The number of nodes n (n≤30),
the number of edges m, and the edges are known.
Example: For n=6, m=7, and the edges:
1 6
1 3
3 4
1 4
3 5
5 2
4 2
the output is Yes.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;

int a[31][31],n,m;
int viz[31];
void readData()
{
ifstream f("data.in");
int x,y;
f>>n>>m;
for(int i=1; i<=m; i++)
{
f>>x>>y;
a[x][y]=a[y][x]=1;
}
f.close();
}
void dfs(int node, int parent, int root_children, int& index,
int lowlink[], bool& is_articulation_point)
{
viz[node]=1;
index+=1;
lowlink[node]=index;
int child_count=0;
bool is_node_articulation_point=false;
for(int neighbor=1; neighbor<=n; neighbor++)

{
if(a[node][neighbor])
{
if(!viz[neighbor])
{
child_count++;
dfs(neighbor,node,root_children,index,lowlink,is_node_arti
culation_point);
if(lowlink[neighbor]>=lowlink[node])
is_node_articulation_point=true;
lowlink[node]=min(lowlink[node],lowlink[neighbor]);
}
else if(neighbor!=parent)
lowlink[node]=min(lowlink[node],lowlink[neighbor]);
}
}
if(parent==0)
root_children=child_count;
if((parent!=0 && is_node_articulation_point) ||
(parent==0 && root_children>1))
is_articulation_point = true;
}
bool is_biconnected()

{
int index=0;
bool biconnected=true;
int lowlink[n+1];
int root_children=0;
for(int i=1; i<=n; i++)
{
viz[i]=0;
lowlink[i]=-1;
}
for(int i=1; i<=n; i++)
{
if(!viz[i])
{
bool is_articulation_point=false;
dfs(i,0,0,index,lowlink,is_articulation_point);
if(is_articulation_point)
{
biconnected=false;
break;
}
}
}

return biconnected;
}
int main()
{
readData();
bool biconnected=is_biconnected();
if(biconnected)
cout<<"Yes";
else
cout<<"No";
return 0;
}

16.4  DIRECTED GRAPHS.
STORAGE. TRAVERSAL
1. The math teacher assigned a chapter of algebra
problems as homework to the students in a class.
Some students borrow notebooks from other
classmates to complete part of the assignment.
Knowing the following information: the number n
(n≤30) of students, the names of the students
(strings with a maximum of 30 characters each),
and pairs of names a, b of students with the
meaning: student a borrows the notebook from
student b.
a. Display the number of students who have
borrowed notebooks from other students.
b. Display the number of students who have lent their
notebooks to other students.
c. Display the students who have not borrowed
notebooks from other students.
d. Display the students who have neither borrowed
nor lent their notebooks to any classmate.
e. Display, for each student, the number of students
they have lent their notebook to.
f. Display, for each student, the number of students
from whom they have borrowed a notebook.

g. Display the classmates (their names) who have
borrowed the notebook from student X.
h. Display the classmates (their names) from whom
student X has borrowed a notebook.
i. Whose homework has directly inspired the most
other assignments?
j. Which student has borrowed notebooks from the
most classmates?
k. Whose homework has inspired the most other
assignments directly or indirectly?
l. Are there students who have neither given nor
received a homework notebook?
m. Given a sequence of p (p≤30) students whose
names are read from the keyboard. Determine if
each student in the sequence has borrowed the
notebook from the next student in the sequence.
Display YES or NO.
Implementation:
#include <iostream>
#include <fstream>
#include <cstring>
using namespace std;
int a[31][31],n;
char elevi[31][30];
void verificare(char nume[30],int &pos)

{
for(int i=1;i<=n;i++)
if(stricmp(elevi[i],nume)==0)
{
pos=i;
break;
}
}
void readData()
{
ifstream f("students.in");
char nume1[30],nume2[30];
f>>n;
//f.get();
for(int i=1;i<=n;i++)
{
f.get();
f.get(elevi[i],30);
}
while(f>>nume1>>nume2)
{
int x=0,y=0;
//find the index of first student

verificare(nume1,x);
//find the index of second student
verificare(nume2,y);
//mark in the matrix the borrowing
a[x][y]=1;
}
f.close();
}
void calculare_grad_extern()
{
int ge[31]={0};
cout<<"Students who borrowed the notebook to other
students: ";
for(int i=1;i<=n;i++)
{
for(int j=1;j<=n;j++)
if(a[i][j]==1)
ge[i]++;
}
for(int i=1;i<=n;i++)
if(ge[i]>0)
cout<<elevi[i]<<" ";
cout<<endl;

}
void calculare_grad_intern()
{
int gi[31]={0};
cout<<"Students who lent the notebook from other
students: ";
for(int i=1;i<=n;i++)
{
for(int j=1;j<=n;j++)
if(a[j][i]==1) //check the matrix on column
gi[i]++;
}
for(int i=1;i<=n;i++)
if(gi[i]>0)
cout<<elevi[i]<<" ";
cout<<endl;
}
void afisare_elevi_neimprumutatori()
{
bool imprumut[31]={false};//mark the students who
borrowed
for(int i=1; i<=n; i++)
{

for(int j=1; j<=n; j++)
{
if(a[i][j]==1)
{
// there is a borrowing
imprumut[i]=true; // mark it
break;//stop the search
}
}
}
cout<<"Students who have not borrowed the notebook
are: ";
bool exista_neimprumutatori =false;
for(int i=1; i<=n; i++)
{
if(!imprumut[i])
{
cout<<elevi[i]<<" ";
exista_neimprumutatori=true;
}
}
if(!exista_neimprumutatori)
cout<<"There are no such students.";

cout<<endl;
}
void afisare_elevi_fara_imprumuturi()
{
int suma_grade_interne[31]={0};
for(int i=1; i<=n; i++)
{
for(int j=1; j<=n; j++)
{
if (a[j][i]==1)
suma_grade_interne[j]++;
}
}
bool exista_elevi_fara_imprumuturi=false;
for (int i=1; i<=n; i++)
{
if (suma_grade_interne[i]==0)
{
cout<<elevi[i]<<" ";
exista_elevi_fara_imprumuturi=true;
}
}
if (!exista_elevi_fara_imprumuturi)

cout<<" No students who have neither borrowed nor lent
their notebooks to any classmate "<<endl;
}
void afisare_nr_imprumuturi_per_elev()
{
for(int i=1; i<=n; i++)
{
int nr_imprumuturi=0;
for(int j=1; j<=n; j++)
{
if(a[i][j]==1)
nr_imprumuturi++;
}
cout<<"Student "<<elevi[i]<<" have borrowed to "
<<nr_imprumuturi<<" students."<<endl;
}
}
void calculare_nr_imprumutati()
{
for(int i=1; i<=n; i++)
{
int nr_imprumutati=0;
for(int j=1; j<=n; j++)

{
if(a[j][i]==1)
nr_imprumutati++;
}
cout<<"Student "<<elevi[i]<<" has borrowed the
notebook from "<<nr_imprumutati<<" classmates."<<endl;
}
}
void afisare_colegi_imprumutat(char X[30])
{
int pos_X=-1;
verificare(X,pos_X);
if(pos_X==-1)
cout<<"Student does not exist.";
else
{
cout<<"Students who borrowed the book from " <<X<<":
";
for(int i=1; i<=n; i++)
{
if(a[i][pos_X]==1)
cout<<elevi[i]<<" ";
}

}
cout<<endl;
}
void afisare_colegi_imprumutati(char X[30])
{
int pos_X=-1;
verificare(X,pos_X);
if(pos_X==-1)
cout<<"Student does not exist.";
else
{
cout<<"Students who borrowed the book to " <<X<<": ";
for(int i=1; i<=n; i++)
{
if(a[pos_X][i]==1)
cout<<elevi[i]<<" ";
}
}
cout<<endl;
}
void afisare_nod_grad_maxim_extern()
{
int ge[31]={0};

for(int i=1;i<=n;i++)
{
for(int j=1;j<=n;j++)
if(a[i][j]==1)
ge[i]++;
}
int maxi=-1;
for(int i=1;i<=n;i++)
if(ge[i]>maxi)
maxi=ge[i];
cout<<"The student who inspired the most assignment is:
";
for(int i=1;i<=n;i++)
if(ge[i]==maxi)
cout<<elevi[i]<<" ";
cout<<endl;
}
void afisare_nod_grad_maxim_intern()
{
int gi[31]={0};
for(int i=1;i<=n;i++)
{
for(int j=1;j<=n;j++)

if(a[j][i]==1)
gi[i]++;
}
int maxi=-1;
for(int i=1;i<=n;i++)
if(gi[i]>maxi)
maxi=gi[i];
cout<<"The student who lent the notebook the most is: ";
for(int i=1;i<=n;i++)
if(gi[i]==maxi)
cout<<elevi[i]<<" ";
cout<<endl;
}
int teme[31];
void calculare_teme_directe_indirecte()
{
for(int i=1; i<=n; i++)
{
for(int j=1; j<=n; j++)
{
if(a[i][j]==1)
{
teme[i]++;

for(int k=1; k<=n; k++)
{
if(a[j][k]==1)
teme[i]++;
}
}
}
}
int maxi=-1;
for(int i=1; i<=n; i++)
if(teme[i]>maxi)
maxi=teme[i];
cout<<"Student who inspired the most: ";
for(int i=1; i<=n; i++)
if(teme[i]==maxi)
cout<<elevi[i]<<" ";
cout<<endl;
}
void fara_caiet()
{
bool elev_fara_imprumut=false;
for(int i=1; i<=n; i++)
{

bool a_dat=false, a_primit=false;
for(int j=1; j<=n; j++)
{
if(a[i][j]==1)
a_dat=true;
if(a[j][i]==1)
a_primit=true;
}
if(!a_dat && !a_primit)
{
cout<<"Student "<<elevi[i]<<" did not lent/borrow at
all."<<endl;
elev_fara_imprumut=true;
}
}
if(!elev_fara_imprumut)
cout<<"No such students"<<endl;
}
void secventa()
{
int p;
cout<<"p=";cin>>p;
char nume[31][30];

int adj[31][31]={0};
for(int i=1;i<=p;i++)
{
cout<<"Name "<<i<<":";
cin>>nume[i];
}
for(int i=1;i<p;i++)
{
cout<<"Has "<<nume[i]<<" borrowed to "<<nume[i+1]
<<"? (1=Yes, 0=No): ";
cin>>adj[i][i+1];
}
bool isOk=true;
for(int i=1;i<p;i++)
{
if(a[i][i+1]==0)
{
isOk = false;
break;
}
}
if(isOk)
cout<<"Yes";

else
cout<<"No";
}
int main()
{
citire();
calculare_grad_extern();
calculare_grad_intern();
afisare_elevi_neimprumutatori();
afisare_elevi_fara_imprumuturi();
afisare_nr_imprumuturi_per_elev();
cout<<endl<<endl;
calculare_nr_imprumutati();
char X[30];
cout<<"A name: ";cin.get(X,30);
afisare_colegi_imprumutat(X);
cin.get();
cout<<"A name: ";cin.get(X,30);
afisare_colegi_imprumutati(X);
afisare_nod_grad_maxim_extern();
afisare_nod_grad_maxim_intern();
calculare_teme_directe_indirecte();
fara_caiet();

secventa();
return 0;
}
1. In a class, there are n (n≤30) students. Some of
them have the phone numbers of their classmates.
The students who have the phone numbers of
other classmates are known and expressed as
follows: in the file class.txt, the first line stores the
number of students, and the next n lines, in order,
represent each student from 1 to n. Each line
contains a value t representing the number of
phone numbers stored by the current student and
the order numbers of the students for whom they
have stored the phone numbers in their contacts.
For students who do not have phone numbers of
other classmates in their contacts, the value 0 is
stored. Determine if there is a student from whom
an announcement can be made to the entire class.
Example: If the class.txt file contains:
5
3 2 4 5 (meaning student 1 has 3 phone numbers
for students 2, 4, 5)
1 1

0
1 3
1 2
Starting from students 1, 2, and 5, announcements
can be made to the entire class.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int a[31][31],n,viz[31];
void read()
{
ifstream f("class.txt");
f>>n;
for (int i=1; i<=n; i++)
{
int t;
f>>t;
for (int j=1; j<=t; j++)
{
int x;
f>>x;

a[i][x]=1;
}
}
f.close();
}
void floyd_warshall()
{
for(int k=1; k<=n; k++)
{
for(int i=1; i<=n; i++)
{
for(int j=1; j<=n; j++)
a[i][j]=a[i][j] || (a[i][k] && a[k][j]);
}
}
}
int main()
{
read();
floyd_warshall();
for(int i=1; i<=n; i++)
{
bool all_connected=true;

for(int j=1; j<=n; j++)
{
if(!a[i][j])
{
all_connected=false;
break;
}
}
if(all_connected)
cout<<"Starting from "<<i<<", an announcement can be
made to entire class."<<endl;
}
return 0;
}
1. A kayaker has set a goal to navigate a network of
rivers. Knowing that there are n (n≤30)
intermediate resting points, and the athlete can
only cover the route in the downstream direction
but no more than 15 km without a break,
determine if the kayaker can reach point y from
point x. The m river segments are known and
given as triplets a, b, c, which can be navigated
without intermediate resting points, downstream
from a to b, and having a length of c.

Implementation:
#include <iostream>
#include <fstream>
#include <cstring>
using namespace std;
int adj[31][31],n,m,viz[31];
void readData()
{
ifstream f("data.in");
f>>n>>m;
int a,b,c;
for (int i=1; i<=m; i++)
{
f>>a>>b>>c;
adj[a][b]=(c<=15);
}
f.close();
}
void DFS(int v, int dest)
{
viz[v]=1;
if (v==dest)

return; // found the destination
for (int i=1; i<=n; i++)
{
if (adj[v][i] && !viz[i])
DFS(i,dest);
}
}
int main()
{
readData();
int x,y;
cout<<"x=";cin>>x;
cout<<"y=";cin>>y;
DFS(x,y);
if (viz[y])
cout<<"There is a way from "<<x<<" to "<<y<<"."
<<endl;
else
cout<<"No solution."<<endl;
return 0;
}

1. Topological Sorting 1. Daniel has many habits
when it comes to his outfit. Because he wants to
look impeccable, he wears certain clothing items
only after others. For an outfit consisting of n
articles (n≤30), the order is known for m pairs x,
y of clothing items, where x is always worn before
y. Display a solution for Daniel.
Example: For n=8, m=8 and the pairs:
2 1
1 3
1 4
3 4
3 7
4 7
5 8
5 6
A solution is: 2, 1, 3, 4, 5, 6, 7, 8.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;

int a[31][31],n,m;
int d[31],c[31];
void readData()
{
ifstream f("data.in");
int x,y;
f>>n>>m;
for (int i=1; i<=m; i++)
{
f>>x>>y;
a[x][y]=1;
d[y]++;
}
f.close();
}
void topSort()
{
int u=1,p=1;
for(int i=1;i<=n;i++)
if(d[i]==0)
{
c[u]=i; //add to the queue
u++;

}
while(p<=u)
{
int x=c[p];
for(int i=1;i<=n;i++)
if(a[x][i]==1)
{
d[i]—; //decrease the degree if is a neighbour
if(d[i]==0) //add to queue is the degree is 0
{
c[u]=i;
u++;
}
}
p++;
}
int gasit=0;
for(int i=1;i<=n;i++)
if(d[i]>0) gasit=1;
if(gasit==1) cout<<"The graph is not acyclic";
else
for(int i=1;i<=n;i++)
cout<<c[i]<<" ";

}
int main()
{
readData();
topSort();
return 0;
}
1. Topological Sorting 2. Among the N courses of
an analytical program, there are M conditions of
the form A-B, meaning “course A must precede
course B”. Create a curriculum and determine the
minimum number of semesters required. In one
semester, all independent courses will be placed,
which depend on knowledge from courses in
previous semesters.
Example: N=12, M=14
1-4, 1-7, 4-8, 2-6, 3-5, 3-11, 6-9, 9-12, 6-7, 5-8, 7-11,
8-10, 3-6, 5-12.
Answer: 4 semesters
Semester 1: courses 1, 2, 3

Semester 2: courses 4, 5, 6
Semester 3: courses 7, 8, 9
Semester 4: courses 10, 11, 12
One possible solution is to use topological sorting,
where all nodes (courses) with an in-degree of 0 at
that moment are placed on one level (semester), then
the nodes and incident arcs in the nodes are removed
from the graph, and the process continues for the next
level (semester). The number of levels represents the
number of semesters. The graph will be represented
using an adjacency matrix, and it will be read from a
file.
Implementation:
#include <iostream>
#include <fstream>
#include <queue>
using namespace std;
int a[31][31],N,M;
int gi[31],c[31];
void readData()

{
ifstream f("data.in");
int A,B;
f>>N>>M;
for (int i=1; i<=M; i++)
{
f>>A>>B;
a[A][B]=1;
gi[B]++;
}
f.close();
}
void topSort()
{
int u=1,p=1,cnt=0;
queue<int> q;
for(int i=1; i<=N; i++)
if(gi[i]==0)
q.push(i);
while(!q.empty())
{
int x=q.front();
q.pop();

cnt++;
c[cnt]=x;
for(int i=1; i<=N; i++)
if(a[x][i]==1)
{
gi[i]—;
if(gi[i]==0)
q.push(i);
}
}
if(cnt!=N)
cout<<"The graph is not acyclic.";
else
{
cout<<"Answer: "<<cnt/3<<" semesters.\n";
for(int i=1; i<=cnt/3; i++)
{
cout<<"sem."<<i<<" - courses: ";
for(int j=(i-1)*3+1; j<=i*3; j++)
cout<<c[j]<<" ";
cout<<endl;
}
}

}
int main()
{
readData();
topSort();
return 0;
}
1. Factory. In a factory, multiple raw materials are
received for the production of a product through
various reception points. The raw materials go
through several intermediate processing points
before finally reaching a single final point as the
finished product. Determine if a directed graph can
represent such a technological process. If
affirmative, display a sequence of processing the
raw materials until the finished product. A point will
be displayed only after all processed materials
have arrived at the previous steps. The number of
vertices n (n≤30), the number of edges m, and
the edges are known.
Example: n=10, m=9
1 3
3 7

7 10
2 4
4 7
8 10
6 5
5 8
9 8
The graph can represent such a technological process.
One possible sequence is: 1, 2, 3, 4, 6, 5, 7, 8, 9, 10.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int n,m,a[31][31];
int viz[31],top,stiva[31];
void readData()
{
ifstream f("data.in");
int x,y;
f>>n>>m;
for (int i=1; i<=m; i++)

{
f>>x>>y;
a[x][y]=1;
}
f.close();
}
void dfs(int u)
{
viz[u]=1;
for(int i=1; i<=n; i++)
{
if(a[u][i]==1)
{
if (!viz[i])
dfs(i);
else if(viz[i]==1)
{
cout<<"The graph is acyclic."<<endl;
exit(0);
}
}
}
viz[u]=2;

stiva[++top]=u;
}
void topSort()
{
for(int i=1; i<=n; i++)
if (!viz[i])
dfs(i);
cout<<"The sequence is: ";
while(top>0)
cout<<stiva[top—]<<" ";
cout<<endl;
}
int main()
{
readData();
topSort();
return 0;
}
1. Daniel is going to the mountains next summer. In
that area, there are n (n≤30) tourist spots. There
are m paths connecting pairs x, y of tourist spots.
Daniel plans to take multiple routes so that each

day he covers as many tourist spots as possible,
traveling only on paths on the same day.
How many days does Daniel need to travel in order
to visit all the tourist spots? Display, for each day, the
tourist spots Daniel visits.
Example: For n=11, m=8
1 2
1 4
2 4
4 5
3 6
3 8
7 9
10 11
Daniel makes 3 routes. One solution with the tourist
spots visited each day is:
Day 1: 1 2 4 5
Day 2: 3 6 8 9 7
Day 3: 10 11

Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int n,m,a[31][31],viz[31];
int trasee[31][31],nr_trasee;
void readData()
{
ifstream f("data.in");
int x,y;
f>>n>>m;
for (int i=1; i<=m; i++)
{
f>>x>>y;
a[x][y]=1;
}
f.close();
}
void resetare()
{
for(int i=1; i<=n; i++)
viz[i]=0;

}
void dfs(int nod, int traseu)
{
viz[nod]=1;
trasee[traseu][nod]=1;
cout<<nod<<" ";
for(int i=1; i<=n; i++)
if (a[nod][i] && !trasee[traseu][i])
dfs(i, traseu);
}
void displayRoutes()
{
for(int i=1; i<=n; i++)
{
if (!viz[i])
{
nr_trasee++;
cout<<endl
<<"Traseul "<<nr_trasee<<": "<<i<<" ";
dfs(i,nr_trasee);
}
}
cout<<endl

<<"Daniel does make "<<nr_trasee<<" routes. One
solution could be:"<<endl;
for(int t=1; t<=nr_trasee; t++)
{
cout<<"\t";
for(int i=1; i<=n; i++)
{
if(trasee[t][i])
cout<<i<<" ";
}
cout<<endl;
}
}
int main()
{
readData();
displayRoutes();
return 0;
}
1. Consider a directed graph with N vertices and M
edges. Given a node S, determine, for each node
X, the minimum number of edges to be traversed
to reach from the source node S to node X. The

input file bfs.in contains the first line with 3
integers N, M, S, representing the values from the
statement. The following M lines contain two
numbers each, x, y, indicating that there is a
directed edge from x to y. In the output file bfs.out,
there will be N numbers separated by spaces,
where the i-th number represents the minimum
number of edges to be traversed from node S to
node i. If it is not possible to reach from node S to
node i, then the number corresponding to i will be
-1.
Example:
bfs.in   bfs.out
5 7 2   1 0 2 -1 1
1 2
2 1
2 2
3 2
2 5
5 3
4 5

Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int N,M,S,a[31][31];
int viz[31];
void readData()
{
ifstream f("bfs.in");
int x,y;
f>>N>>M>>S;
for (int i=1; i<=M; i++)
{
f>>x>>y;
a[x][y]=1;
}
f.close();
}
void BFS()
{
int q[31],head=0,tail=0,qsize=0;
q[tail++]=S;

viz[S]=0;
qsize++;
while(qsize>0)
{
int u=q[head++];
qsize—;
for(int v=1; v<=N; v++)
{
if (a[u][v] && viz[v]==-1)
{
viz[v]=viz[u]+1;
q[tail++]=v;
qsize++;
}
}
}
}
int main()
{
readData();
for(int i=1; i<=N; i++)
viz[i]=-1;
// calculate distances

for (int i=1; i<=N; i++)
BFS();
// display data
ofstream g("bfs.out");
for(int i=1; i<=N; i++)
g<<viz[i]<<" ";
return 0;
}
1. Determining the center of a weighted
directed graph. Suppose a weighted directed
graph G=(N, A) is given, and the task is to
determine its most central node, i.e., the graph's
center. To define the term “most central node”, we
first introduce the concept of the eccentricity of a
node belonging to a weighted graph. The
eccentricity of a node x∈N is specified by the
formula:
eccentricity[x] = max{shortest paths from x to y}.
In other words, the eccentricity of a node in a
weighted graph is the maximum value among the
lengths of the shortest paths from that node to all

other nodes in the graph. The center of a graph G is
the node whose eccentricity is the minimum.
Hint:
- Use the Floyd-Warshall algorithm to determine the
matrix of shortest paths for all pairs of nodes.
- Determine the eccentricities of nodes i, (1≤i≤N) by
finding the maximum value in each column i of the
matrix.
- Search for the node with the minimum eccentricity.
This node is the center of the graph G.
Implementation:
#include <iostream>
#include <fstream>

using namespace std;
int n,a[50][50];
int excentricitate[50];
int infinit=99999;
void readData()
{
ifstream f("data.in");
int x,y,c;
f>>n;
for(int i=1; i<=n; i++)
{
for(int j=1; j<=n; j++)
{
if(i==j)
a[i][j]=0;
else
a[i][j]=infinit;
}
}
while(f>>x>>y>>c)
a[x][y]=c;
f.close();
}

int afi()
{
for(int i=1; i<=n; i++)
{
for(int j=1; j<=n; j++)
if(a[i][j]==infinit)
cout<<(char)(236)<<" ";
else
cout<<a[i][j]<<" ";
cout<<endl;
}
}
void RoyFloyd()
{
for(int k=1; k<=n; k++)
{
for(int i=1; i<=n; i++)
{
for(int j=1; j<=n; j++)
a[i][j]=min(a[i][j],a[i][k]+a[k][j]);
}
}
}

void findEccentricity()
{
for(int i=1; i<=n; i++)
{
excentricitate[i]=0;
for(int j=1; j<=n; j++)
excentricitate[i]=max(excentricitate[i], a[j][i]);
}
}
int findCenter()
{
int minim=infinit,poz=-1;
for(int i=1;i<=n;i++)
if(excentricitate[i]<minim)
poz=i;
return poz;
}
int main()
{
readData();
RoyFloyd();
afi();
findEccentricity();

int poz=findCenter();
if(poz!=-1)
cout<<"The center of graph is the node: "<<poz;
else
cout<<"No solution found. ";
return 0;
}
1. Strongly connected. In a city, there are n
(n≤30) commercial points numbered from 1 to n
and m streets that connect certain pairs of
commercial points. Initially, through the street
system, one could reach any commercial point
from any other point. Due to traffic congestion, the
city hall has decided to make each street one-way.
Determine if the city hall's project allows
circulation between any two commercial points.
The following information is known: the number n
of commercial points, the number m of streets, and
the streets expressed as pairs x-y, with the
meaning: one can travel from commercial point x
to commercial point y. In case it is not possible,
display a pair of commercial points x-y for which
one cannot travel from x to y or from y to x.
Example:

4 5 displays NO, 1 4
1 2
2 3
2 4
3 1
3 4
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int n,m,a[31][31];
void readData()
{
ifstream f("data.in");
f>>n>>m;
for(int i=1; i<=m; i++)
{
int x,y;
f>>x>>y;
a[x][y]=1;
}

}
bool check()
{
for(int i=1; i<=n; i++)
{
for(int j=1; j<=n; j++)
{
if(i!=j && !a[i][j])
{
for(int k=1; k<=n; k++)
{
if(k!=i && k!=j && a[i][k] && a[k][j])
break;
if(k==n)
return false;
}
}
}
}
return true;
}
int main()
{

readData();
if(check())
cout<<"All nodes are connected.\n";
else
{
cout<<"No, ";
for(int i=1; i<=n; i++)
{
for(int j=i+1; j<=n; j++)
{
if(!a[i][j] && !a[j][i])
cout<<i<<"-"<<j<<" ";
}
}
}
return 0;
}
1. Strongly connected components. In a class,
there are n (n≤30) students. Some of them have
the phone numbers of other classmates. The
information is expressed as follows: in the file
class.txt, the first line stores the number n of
students and a value m, and the next m lines each

contain a pair of numbers x-y, where x has the
phone number of y (y may not have the phone
number of x). Determine the minimum number of
students the teacher should call to make an
announcement to the entire class. For each group,
announce the student with the smallest order
number.
Example: Announce 2 students:
6 9  1 Announce group: 1 2 3
1 2  4 Announce group: 4 5 6
2 3
2 4
3 1
3 4
4 5
5 4
5 6
6 4
Implementation:
#include <iostream>
#include <fstream>

using namespace std;
int n,m,a[31][31];
int idx[31],lowlink[31],in_stack[31],indecs;
int comp[31],comp_count;
int S[31],top;
void readData()
{
ifstream f("class.in");
f >>n>>m;
for(int i=1; i<=m; i++)
{
int x,y;
f>>x>>y;
a[x][y]=1;
}
}
void tarjan(int u)
{
idx[u]=lowlink[u]=++indecs;// update index and lowlink
S[++top]=u;// add u to the stack
in_stack[u]=1;// mark as being in the stack
for(int v=1; v<=n; v++)
{

if(!a[u][v])// there’s no path, move to next node
continue;
if(idx[v]==0)// node v not visited
{
tarjan(v);// continue
lowlink[u]=min(lowlink[u],lowlink[v]);// update
}
else if(in_stack[v])// it’s in the stack
lowlink[u]=min(lowlink[u],idx[v]);//update
}
if(lowlink[u]==idx[u])// it’s a point of articulation
{
comp_count++;// add a new component
int v;
do
{
v=S[top—];// remove the node from the stack
in_stack[v]=0;// mark as removed
comp[v]=comp_count;// add to the new component
}while(u!=v);// continue until the u node is reached
}
}
int main()

{
readData();
for(int i=1; i<=n; i++)
{
if(idx[i]==0)
tarjan(i);
}
for(int i=1; i<=comp_count; i++)
{
cout<<"The strongly connected component "<<i<<" has
";
int count=0;
for(int j=1; j <= n; j++)
if(comp[j] == i)
count++;
cout<<count<<" studets, first student has index ";
for(int j=1; j<=n; j++)
{
if(comp[j]==i)
{
cout<<j<<endl;
break;
}

}
cout<<"The students from this component are: ";
for(int j=1; j<=n; j++)
{
if(comp[j]==i)
cout<<j<<" ";
}
cout<<endl;
}
return 0;
}

16.5  SHORTEST PATHS. MINIMUM
CHAINS.
1. Consider a map with n (n≤30) cities numbered
from 1 to n. There are m direct roads between the
n cities. The lengths of these m roads are known
and expressed as triplets x, y, d, where the
meaning is that the length of the road from city x
to city y is equal to d. It is possible to travel in both
directions on any road.
a. Determine whether city x and city y are neighbors
(have a direct road without passing through
intermediate cities).
b. Determine the minimum length of the road
between two locations x and y, read from the
keyboard.
c. Determine the minimum length of the road from a
location x to all other locations.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int n,m,a[31][31];
void readData()

{
ifstream f("data.in");
f>>n>>m;
for(int i=1; i<=m; i++)
{
int x,y,d;
f>>x>>y>>d;
a[x][y]=a[y][x]=d;
}
}
bool sunt_vecini(int x, int y)
{
return a[x][y]>0 || a[y][x]>0;
}
int dijkstra(int start, int stop)
{
const int INF=1e9;
int dist[31];
bool processed[31];
for(int i=1; i<=n; i++)
{
dist[i]=INF;
processed[i]=false;

}
dist[start]=0;
for(int i=1; i<=n; i++)
{
int u=-1;
for(int j=1; j<=n; j++)
{
if(!processed[j] && (u==-1 || dist[j]<dist[u]))
u=j;
}
if(dist[u]==INF)
break;
processed[u]=true;
for(int v=1; v<=n; v++)
{
if(a[u][v]>0)
{
int new_dist=dist[u]+a[u][v];
if(new_dist<dist[v])
dist[v]=new_dist;
}
}
}

return dist[stop];
}
int main()
{
readData();
int x,y;
cout<<"x=";cin>>x;
cout<<"y=";cin>>y;
///—————————————————
if(sunt_vecini(x,y)==true)
cout<<"Neighbours."<<endl;
else
cout<<"Not neighbours."<<endl;
///—————————————————
cout<<"x=";cin>>x;
cout<<"y=";cin>>y;
cout<<"The distance is: "<<dijkstra(x,y)<<endl;
///—————————————————
cout<<"x=";cin>>x;
for(int i=1; i<=n; i++)
{
if(i!=x)

cout<<"Min length from "<<x<<" to "<<i<<" is: "
<<dijkstra(x, i)<<endl;
}
return 0;
}
1. Stations. The infamous Overmind of the Zerg has
been destroyed, and the Protoss homeworld of
Shakuras now lies in ruins and smoke. As the
Executor and commander of the remaining Protoss
forces, you must now gather the helpless Protoss
population and save them from the Zerg, who still
occupy the lands of Shakuras with indifference.
Your objective is to take control of a main base of
the Tassadar civilization, and you will need to use
transmission-reception stations because only they
can indicate the main base. There are pairs of
transmission-reception stations that directly emit
and receive signals. Between two pairs of stations
x and y that communicate directly, the
transmission time is t. Signals between two
stations can either reach directly or indirectly
through other stations. Obviously, there may be
stations located in different bases that cannot
communicate signals. Stations that do not emit
and receive signals are strategically unimportant.

You can determine a main base by knowing that on
Day Q, all stations will start emitting, so each
station will transmit a message to all other stations
within the base it is in (two stations are within the
same base if they can transmit information directly
or indirectly). Signals between two stations will be
transmitted on communication routes that require
the least time and will be transmitted in both
directions. Due to interference, multiple signals will
not be emitted simultaneously within the same
base but successively, so to communicate
information between any two stations in a base, a
time period T will be consumed. A main base will
be indicated by a minimum value of T. You will
need to find this value.
Input: The file stations.in contains a natural
number n representing the number of transmission-
reception stations. Subsequently, on different lines,
triplets of natural numbers representing pairs of
stations x and y and the time t of transmission from x
to y or from y to x.
Output: The file stations.out will write the
requested number representing the minimum value of
T. If there is no such number, write 0.

Constraints and Clarifications:
1 ≤ n ≤ 100 (natural number)
1 ≤ t ≤ 3000 (natural number)
The number of bases can be at least 1 and at most
n.
stations.in    stations.out
8    24
1 2 10
1 3 5
2 4 20
3 4 3
1 4 2
2 3 4
5 6 1
6 7 2
7 8 4
6 8 1
7 5 3
Implementation:

#include <iostream>
#include <fstream>
using namespace std;
int n,dist[101][101];
const int INF=99999;
void FloydMarshall()
{
for(int k=1; k<=n; k++)
{
for(int i=1; i<=n; i++)
{
for(int j=1; j<=n; j++)
dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);
}
}
}
void readData()
{
ifstream f("stations.in");
f>>n;
for(int i=1; i<=n; i++)
{
for(int j=1; j<=n; j++)

{
if(i==j)
dist[i][j]=0;
else
dist[i][j]=INF;
}
}
int x,y,t;
while(f>>x>>y>>t)
dist[x][y]=dist[y][x]=t;
FloydMarshall();
f.close();
}
void solution()
{
int T=INF;
for(int i=1; i<=n; i++)
{
for(int j=i+1; j<=n; j++)
{
if(dist[i][j]==INF)
continue;
for(int k=1;k<=n;k++)

{
if(dist[i][k]==INF || dist[k][j]==INF)
continue;
if(dist[i][k]+dist[k][j]+dist[j][i]<=T)
T=dist[i][k]+dist[k][j]+dist[j][i];
}
}
}
ofstream g("statii.out");
if (T==INF)
g<<0<<endl;
else
g<<T<<endl;
}
int main()
{
readData();
//FloydMarshall();
solution();
return 0;
}

1. A tourist has at their disposal a sum of money S.
They are located at a point x on a map with n
(n≤30) tourist points. The tourist can only travel
by minibus. The cost of minibus travel is known
between m pairs of tourist points for which there is
transportation possibility (round trip). Knowing that
in one day the tourist can only take a single route
and can only get off at the destination without
visiting intermediate points, display a cost-
effective solution of tourist points that can be
visited without exceeding the sum S available.
Display the amount spent, the order numbers for
each of the visited tourist points, and the cost for
each journey.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int n,m,a[31][31],S;
int d[31],visited[31],parent[31];
void readData()
{
ifstream f("tourist.in");
int x,y,c;

f>>n>>m>>S;
for(int i=1;i<=n;i++)
for(int j=1;j<=n;j++)
a[i][j]=-1;
for(int i=1;i<=m;i++)
{
f>>x>>y>>c;
a[x][y]=a[y][x]=c;
}
f.close();
}
int min_distance(int x)
{
for(int i=1; i<=n; i++)
{
d[i]=127;
parent[i]=-1;
visited[i]=0;
}
d[x]=0;
for(int i=1; i<=n; i++)
{
int u=0;

for(int j=1; j<=n; j++)
{
if(!visited[j] && (u==0 || d[j]<d[u]))
u=j;
}
if (u==0 || d[u]>S)
break;
visited[u]=true;
for(int v=1; v<=n; v++)
{
if(a[u][v]!=-1 && !visited[v] && a[u][v]<=S-d[u] &&
a[u][v]<d[v])
{
d[v]=a[u][v];
parent[v]=u;
}
}
}
int sum=0;
for(int i=1; i<=n; i++)
if (i!=x)
sum+=a[i][parent[i]];
return sum;

}
void display(int node)
{
if(parent[node]!=-1)
{
display(parent[node]);
cout<<node<<" ";
}
}
int main()
{
readData();
int min_sum=127;
int best_node=-1;
int x;
cout<<"x=";cin>>x;
int sum=min_distance(x);
if(sum<min_sum)
min_sum=sum;
cout<<min_sum<<endl;
display(x);
for(int i=2; i<=n; i++)
cout<<parent[i]<<" "<<i<<" "<<a[i][parent[i]]<<endl;

return 0;
}
1. It is known that before being delivered to
customers, products go through an entire chain of
intermediaries. The n (n≤30) intermediary points
are numbered from 1 to n, and the m possible
transitions are known in the form of pairs a, b with
the meaning of transferring from intermediary a to
intermediary b. Display the shortest chain of
intermediaries to deliver a product from x to y.
Example: n=8, m=10
1 2
1 3
1 6
1 8
2 3
3 6
3 4
5 6
1. 5

7 8
for x=1, y=5, the result is: 1, 3, 4, 5
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int n,m,a[31][31];
int viz[31],tata[31];
void readData()
{
ifstream f("data.in");
int x,y;
f>>n>>m;
for(int i=1;i<=m;i++)
{
f>>x>>y;
a[x][y]=1;
}
f.close();
}
bool bfs(int x, int y)
{

int stiva[31],varf=0;
stiva[++varf]=x; //add node to stack
viz[x]=1;
while(varf)
{
int nod=stiva[varf—]; //delete the node from stack
for(int i=1; i<=n; i++)
{
if (a[nod][i] && !viz[i])
{
//we have an edge between i and node
viz[i]=1; //mark as visited node i
tata[i]=nod; //keep the father of node i
stiva[++varf]=i; //add i to stack
if(i==y)
return true; //we found a path
}
}
}
return false;//no path found
}
void printPath(int x, int y)
{

int p[31],k=0;
while (y!=x)
{
//go from y to x
p[++k]=y;
y=tata[y];
}
p[++k]=x;
cout<<"Minimum path is: ";
for(int i=k; i>=1; i—)
{
cout<<p[i];
if (i!=1)
cout<<" ->";
}
}
int main()
{
readData();
int x,y;
cout<<"x=";cin>>x;
cout<<"y=";cin>>y;
if (bfs(x,y)) printPath(x, y); //print out path

else cout<<"No path between "<<x<<" and "
<<y<<endl;
return 0;
}
1. In a mine, there are m galleries expressed by the
order numbers of the rooms that determine them.
There are n (n≤30) rooms in the mine. Knowing
that all galleries have the same length d, read from
the keyboard, determine:
a. The minimum length determined by the galleries
that connect room x with room y. Display the
galleries that determine this length.
b. The maximum length determined by the galleries
that connect room x with room y without passing
through the same room multiple times. Display the
galleries that determine this length.
Example: n=8, m=10, d=2
1 2
1 3
1 6
1 8
2 3

3 6
3 4
5 6
4 5
7 8
For x=1, y=5:
a. Result: L1=3 through galleries 1, 3, 4, 5
b. Result: L2=8 through galleries 1, 2, 3, 4, 5 (other
solutions are possible)
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int n,m,a[31][31],d;
int path[31];
int min_path[31],min_length =31*31*31,max_path[31];
void readData()
{
ifstream f("mine.in");
int x,y;
f>>n>>m>>d;

for(int i=1;i<=m;i++)
{
f>>x>>y;
a[x][y]=d;
}
f.close();
}
void dfs(int current, int target, int length, int
&min_length_so_far)
{
path[length]=current;
if(current==target && length<min_length_so_far)
{
min_length_so_far=length;
for (int i=0; i<=length; i++)
min_path[i]=path[i];
}
else if(length<min_length_so_far)
{
for (int i=1; i<=n; i++)
{
if (a[current][i])
{

a[current][i]=a[i][current]=0;
dfs(i,target,length+1,min_length_so_far);
a[current][i]=a[i][current]=d;
}
}
}
}
void dfs2(int current, int target, int length, int
&max_length_so_far)
{
path[length]=current;
if (current==target && length>max_length_so_far)
{
max_length_so_far=length;
for (int i=0; i<=length; i++)
max_path[i]=path[i];
}
else if(length>max_length_so_far)
{
for (int i=1; i<=n; i++)
{
if (a[current][i])
{

a[current][i]=a[i][current]=0;
dfs2(i,target,length+1,max_length_so_far);
a[current][i]=a[i][current]=d;
}
}
}
}
int main()
{
readData();
int x,y;
cout<<"x=";cin>>x;
cout<<"y=";cin>>y;
if (x==y)
{
cout<<"Min. length is: 0\n";
cout<<"Min. path is: "<<x;
}
else
{
int min_length_so_far=31*31*31;
dfs(x, y, 0, min_length_so_far);
if (min_length_so_far==31*31*31)

cout<<"No path from x to y.\n";
else
{
cout<<"Min. length is: "<<min_length_so_far<<'\n';
cout<<"Min. path is: ";
for(int i=0; i<min_length_so_far; i++)
cout<<min_path[i]<<' ';
cout<<y<<'\n';
}
}
cout<<endl;
///——————————————————
cout<<"x=";cin>>x;
cout<<"y=";cin>>y;
if (x==y)
{
cout<<"Max. length is: 0\n";
cout<<"Max. path is: " << x;
}
else
{
int max_length_so_far=0;
dfs2(x,y,0,max_length_so_far);

if (max_length_so_far==0)
cout << "No path between x & y.\n";
else
{
cout<<"Max length is: "<<max_length_so_far << '\n';
cout<<"Max path is: ";
for(int i=0; i<max_length_so_far; i++)
cout<<max_path[i]<<' ';
cout<<y<<'\n';
}
}
return 0;
}
1. Given an undirected graph with n (n≤30) vertices
and m edges (the edges are known), and then a
vertex k. Display on separate lines the minimum
distances from vertex k to the other vertices of the
graph and the corresponding chains of minimum
length for these distances. The distance from one
vertex to another is considered to be equal to the
number of edges in the shortest chain connecting
the two nodes. Values n, m, edges, and k are read
from a file. A breadth-first algorithm will be used.

Example:
input file: output file:
12 13
1 2 8 2 1
1 2
2 1 8 2
1 3
3 3 8 2 1 3
1 4
4 3 8 2 1 4
2 8
5 4 8 2 1 4 5
3 6
6 4 8 2 1 3 6
3 7
7 2 8 9 7
4 6
8 0 8
4 5
9 1 8 9
8 9
10 3 8 9 7 10
7 9
11 -
7 10
12 -
6 10
12 11
8
Implementation:
#include <iostream>

#include <fstream>
using namespace std;
ofstream g("data.out");
int n,m,a[31][31],k;
int p[31],d[31],x[31],T[31];
void readData()
{
ifstream f("data.in");
int x,y;
f>>n>>m;
for(int i=1;i<=m;i++)
{
f>>x>>y;
a[x][y]=a[y][x]=1;
}
f>>k;
f.close();
}
void bf(int k)
{
int st,dr,j;
st=dr=1;
x[1]=k;

p[k]=1;
d[k]=0;
while(st<=dr)
{
for(j=1;j<=n;j++)
if(a[x[st]][j]==1 && p[j]==0)
{
dr++;
x[dr]=j;
p[j]=1;
d[j]=d[x[st]]+1;
T[j]=x[st];
}
st++;
}
}
void lant(int k)
{
if(T[k]!=0) lant(T[k]);
g<<k<<" ";
}
void afis()
{

int i;
for(i=1;i<=n;i++)
if(d[i]!=31*31)
{
g<<i<<" "<<d[i]<<"  ";
lant(i);
g<<endl;
}
else g<<i<<" -\n";
}
int main()
{
readData();
for(int i=1;i<=n;i++) d[i]=31*31;
bf(k);
afis();
return 0;
}
1. A directed graph with n (n≤30) vertices and m
arcs is read. Then, a natural number k smaller than
n is read. Display the vertices that are at distance
k from vertex x. The distance from a vertex x to a

vertex y is equal to the number of arcs that make
up the shortest path from vertex x to vertex y.
Example: For the graph:
n=6, m=8 with arcs:
1 4
1 5
2 6
3 1
4 3
4 6
5 2
6 5
k=2, x=1
Display vertices 2, 3, and 6.
Implementation:
#include <iostream>
#include <fstream>
#include <vector>
#include <queue>
using namespace std;

using namespace std;
vector <int> G[101];
vector <int> H[101];
int n,m,x,y,k,c,cnt,d[101],v[101],ok,d2[101],v2[101];
void bfs1(int nod)
{
d[nod]=0;
v[nod]=1;
queue <int> Q;
Q.push(nod);
while(!Q.empty())
{
int x=Q.front();
for(auto i : G[x])
if(!v[i])
{
d[i]=d[x]+1;
v[i]=1;
Q.push(i);
}
Q.pop();
}
}

void bfs2(int nod)
{
d2[nod]=0;
v2[nod]=1;
queue <int> q;
q.push(nod);
while(!q.empty())
{
int x=q.front();
for(auto i : H[x])
if(!v2[i])
{
d2[i]=d2[x]+1;
v2[i]=1;
q.push(i);
}
q.pop();
}
}
int main()
{
ifstream f("date.in");
f>>n>>m;

for(int i=1; i<=m; i++)
{
f>>x>>y;
G[x].push_back(y);
H[y].push_back(x);
}
f>>k;
cout<<"x=";cin>>x;
bfs1(x);
bfs2(x);
for(int i=1 ; i<=n ; i++)
{
if(d[1]!=0 && d2[i]!=0)
{
if(min(d[i],d2[i])==k) cout<<i<<" ",ok++;
ok++;
}
else if(d[i]!=0 && d[i]==k) cout<<i<<" ",ok++;
else if(d2[i]!=0 && d2[i]==k) cout<<i<<" ",ok++;
}
if(ok==0) cout<<"Does not exist.";
}

1. It is known that in a connected undirected graph,
between any two vertices, there is at least one
chain, and the length of a chain is equal to the
number of edges that compose it. We define the
notion of an optimal chain between two vertices X
and Y as a chain of minimum length that has X and
Y as endpoints. It is evident that between any two
vertices of a connected graph, we will have one or
more optimal chains, depending on the
configuration of the graph. Given a connected
undirected graph with N vertices labeled with the
ordinal numbers 1, 2,...,N, and two of its vertices
marked as X and Y (1 ≤ X, Y ≤ N, X≠Y), you are
required to write a program that determines the
vertices belonging to all optimal chains between X
and Y. The data is read from the file graph.in,
which contains: on the first line, four natural
numbers representing N (the number of vertices in
the graph), M (the number of edges), X, and Y
(with the meanings from the statement). On the
next M lines, two non-zero natural numbers Ai, Bi
(1 ≤ Ai, Bi ≤ N, Ai ≠ Bi, for 1 ≤ i ≤ M), each of
these pairs of numbers representing an edge in the
graph. The results will be displayed as follows: on
the first line, the number of vertices common to all
optimal chains between X and Y, on the second
line, the numbers corresponding to the labels of

these vertices, arranged in ascending order;
between two consecutive numbers on this line,
there will be a space.
Example:
graph.in   graph.out
6 7 1 4   3
1 2    1 4 5
1 3
1 6
2 5
3 5
5 6
5 4
Implementation:
#include <bits/stdc++.h>
using namespace std;
ifstream f("graph.in");
ofstream g("graph.out");
vector <int> E[7505];

int
n,m,x,y,a,b,fr[7505],dist1[7505],dist2[7505],nr,rez[7505];
void bfs(int st, int dist[])
{
for(int i=1;i<=n;i++)dist[i]=(1<<30);
queue <int> Q;
Q.push(st);
dist[st]=0;
while(!Q.empty())
{
int nn=Q.front();
Q.pop();
for(int i:E[nn])
{
if(dist[i]==(1<<30))
{
dist[i]=dist[nn]+1;
Q.push(i);
}
}
}
}
int main()

{
f>>n>>m>>x>>y;
for(int i=1;i<=m;++i)
{
f>>a>>b;
E[a].push_back(b);
E[b].push_back(a);
}
bfs(x, dist1);
bfs(y, dist2);
for(int i=1;i<=n;i++)
{
if(dist1[i]+dist2[i]==dist1[y])++fr[dist1[i]];
}
for(int i=1;i<=n;i++)
{
if((dist1[i]!=(1<<30)) && (dist2[i]!=(1<<30)) &&
(dist1[y]!=(1<<30)))
if(dist1[i]+dist2[i]==dist1[y] && fr[dist1[i]]==1)
rez[++nr]=i;
}
g<<nr<<'\n';
for(int i=1;i<=nr;i++)

{
g<<rez[i]<<" ";
}
return 0;
}

16.6  MINIMUM COST SPANNING
TREE.
1. In Sussex, a project is being implemented to
connect all houses to the gas network. The
following information is known: the number n
(n≤30) of houses, the costs for installing gas pipes
between m pairs of houses expressed as triplets x,
y, c, with the meaning that a pipe between houses
x and y has the value c, and the maximum
allocated sum S for the project. Design a pipe
system that allows the entire locality to be supplied
with gas at the lowest possible cost. Is it possible
for this cost to fit within the sum S, or is additional
funding required?
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int n,m,S,a[31][31];
void readData()
{
ifstream f("data.in");
f>>n>>m>>S;

for(int i=1;i<=m;i++)
{
int x,y,c;
f>>x>>y>>c;
a[x][y]=c;
}
f.close();
}
bool isInTree(int node, bool treeSet[])
{
return treeSet[node];
}
void prim()
{
int parent[31]; // store the fathers of nodes
int key[31]; // store the min amount to reach every node
bool treeSet[31]; // check if a node is included in the tree
// initialise with the max value possible before calculating
for(int i=1; i<=n; i++)
{
key[i]=INT_MAX;
treeSet[i]=false;
}

// start node initialisations
key[1]=0;
parent[1]=-1; // the root of the tree
// find the spanning tree with n-1 nodes
for(int count=1; count<=n-1; count++)
{
// choose the node with minimum cost
int minKey=INT_MAX,minIndex;
for(int v=1; v<=n; v++)
{
if(!treeSet[v] && key[v]<minKey)
{
minKey=key[v];
minIndex=v;
}
}
int u=minIndex; // found the selected node
treeSet[u]=true; // add the node to the tree
// update cost and parents to all adjacent nodes
for(int v=1; v<=n; v++)
{
if(a[u][v] && !isInTree(v, treeSet) && a[u][v]<key[v])
{

parent[v]=u;
key[v]=a[u][v];
}
}
}
// display the spanning tree
int totalCost=0;
for(int i=2; i<=n; i++)
{
cout<<parent[i]<<" - "<<i<<" Cost: "<<a[parent[i]][i]
<<endl;
totalCost+=a[parent[i]][i];
}
// check if cost is less than initial sum
if(totalCost<=S)
cout<<"The cost is less/equal than S."<<endl;
else
cout<<"Additional funding is required. "<<endl;
}
int main()
{
readData();
prim();

return 0;
}
1. A new locality is represented on a map by a
Cartesian system of points for which the abscissa
and ordinate are known, and each point represents
a building in the locality. The intention is to create
an electrification system that includes a power
supply point for each building. Knowing that the
sum required for implementing the project is
determined by the number of power supply points,
and that each electrification line requires a cost
directly proportional to the length of the line,
specify the electrification lines that result in a
minimum cost. The following information is known:
the number n (n≤30) of buildings, the coordinates
of the buildings, the cost cl required for installing a
power supply point, and the cost c2 per unit
distance on the electrification line. The buildings
are numbered from 1 to n, and their coordinates
are stored in order in a file.
Example: n=4
The coordinates of the buildings are:
2 1 (building 1)

4 1 (building 2)
2 3 (building 3)
4 3 (building 4)
c1=100, c2=10
One solution consists of the electrification lines that
connect pairs of buildings: 1-3, 1-2, 2-4, requiring a
cost of 460.
Implementation:
#include <iostream>
#include <vector>
#include <cmath>
#include <climits>
#include <algorithm>
using namespace std;
struct Point
{
int x;
int y;
};

double calculateDistance(Point p1, Point p2)
{
return sqrt(pow(p1.x-p2.x,2)+pow(p1.y-p2.y,2));
}
vector<vector<double>>
buildAdjacencyMatrix(vector<Point>& buildings)
{
int n = buildings.size();
vector<vector<double>> adjacencyMatrix(n,
vector<double>(n, 0.0));
for(int i=0; i<n; i++)
{
for(int j=0; j<n; j++)
{
if (i!=j)
{
double distance=calculateDistance(buildings[i],
buildings[j]);
adjacencyMatrix[i][j]=distance;
}
}
}
return adjacencyMatrix;

}
void findMinCostElectrification(vector<Point>& buildings,
double c1, double c2) {
int n = buildings.size();
vector<vector<double>> adjacencyMatrix =
buildAdjacencyMatrix(buildings);
vector<bool> visited(n, false);
vector<double> minCost(n, INT_MAX);
vector<int> parent(n, -1);
minCost[0] = 0;
for (int count = 0; count < n - 1; count++) {
int minCostBuilding = -1;
double minCostValue = INT_MAX;
for (int i = 0; i < n; i++) {
if (!visited[i] && minCost[i] < minCostValue) {
minCostValue = minCost[i];
minCostBuilding = i;
}
}
visited[minCostBuilding] = true;
for (int i = 0; i < n; i++) {
if (!visited[i] && adjacencyMatrix[minCostBuilding][i] <
minCost[i]) {

minCost[i] = adjacencyMatrix[minCostBuilding][i];
parent[i] = minCostBuilding;
}
}
}
int totalCost = 0;
for (int i = 0; i < n; i++) {
totalCost += c1 + c2 * minCost[i];
}
cout << "Minimum cost is: " << totalCost << endl;
cout << "The electrification line is: " << endl;
for (int i = 1; i < n; i++) {
cout << parent[i] + 1 << "-" << i + 1 << endl;
}
}
int main()
{
int n;
double c1,c2;
cout<<"No. Of buildings (n): ";
cin>>n;
vector<Point> buildings(n);
cout<<"Coordinates of buildings (x y): "<<endl;

for (int i=0; i<n; i++)
cin>>buildings[i].x>>buildings[i].y;
cout<<"Min cost (c1): ";
cin>>c1;
cout<<"Cost per unit (c2): ";
cin>>c2;
findMinCostElectrification(buildings, c1, c2);
return 0;
}
1. The municipality of a rural locality has decided to
pave the roads in the locality so that it is possible
to travel between any two houses. The locality has
n (n≤30) houses numbered from 1 to n. The
lengths of the existing roads between m pairs of
houses (the order numbers of the houses) are
known. For economic reasons, only some of these
roads will be paved. The cost required for paving
each road that could be paved is known. The roads
are divided into priority categories: 1 or 2. Those in
category 2 will not be paved. Determine if there is
a solution to pave the locality according to the
previous conditions with the minimum cost. The file
village.in contains, on the first line, the values of n
and m, and on the next n lines, four values each:
a, b, c1, c2, where paving the road between

houses a and b requires c1 and belongs to
category c2. If there is a solution, the file
village.out will display the number q of paved
roads, the total cost value, and q pairs of values
representing the roads.
Example:
village.in    village.out
9 17    49
1 2 10 1    8
1 3 1 1    3 1
2 4 11 1    7 9
2 5 11 1    7 3
5 6 13 1    9 8
3 4 10 1    7 4
4 6 12 1    2 1
3 2 1 2    5 2
4 7 5 1    7 6
3 7 4 1
3 8 5 1
8 7 5 1

4 5 1 2
8 9 4 1
9 7 3 1
6 7 11 1
9 6 1 2
Implementation:
#include <iostream>
#include <fstream>
#include <vector>
#include <queue>
#include <limits>
using namespace std;
const int INF = numeric_limits<int>::max();
struct Edge {
int destination;
int cost;
int category;
};
typedef vector<vector<Edge>> Graph;
struct MinHeapNode {
int vertex;

int key;
};
void decreaseKey(vector<MinHeapNode>& heap,
vector<int>& position, int v, int key) {
int i = position[v];
heap[i].key = key;
while (i > 0 && heap[i].key < heap[(i - 1) / 2].key) {
position[heap[i].vertex] = (i - 1) / 2;
position[heap[(i - 1) / 2].vertex] = i;
swap(heap[i], heap[(i - 1) / 2]);
i = (i - 1) / 2;
}
}
void heapify(vector<MinHeapNode>& heap,
vector<int>& position, int i) {
int smallest = i;
int left = 2 * i + 1;
int right = 2 * i + 2;
if (left < heap.size() && heap[left].key <
heap[smallest].key)
smallest = left;
if (right < heap.size() && heap[right].key <
heap[smallest].key)

smallest = right;
if (smallest != i) {
position[heap[smallest].vertex] = i;
position[heap[i].vertex] = smallest;
swap(heap[i], heap[smallest]);
heapify(heap, position, smallest);
}
}
Graph readInput(const string& filename, int& n, int& m)
{
ifstream inputFile(filename);
if (!inputFile.is_open()) {
cerr << "Failed to open the input file." << endl;
exit(1);
}
inputFile >> n >> m;
Graph graph(n);
int a, b, c1, c2;
for (int i = 0; i < m; i++) {
inputFile >> a >> b >> c1 >> c2;
Edge edge1, edge2;
edge1.destination = b - 1;
edge1.cost = c1;

edge1.category = c2;
edge2.destination = a - 1;
edge2.cost = c1;
edge2.category = c2;
graph[a - 1].push_back(edge1);
graph[b - 1].push_back(edge2);
}
return graph;
}
void writeOutput(const string& filename, int q, int cost,
const vector<pair<int, int>>& edges) {
ofstream outputFile(filename);
if (!outputFile.is_open()) {
cerr << "Failed to open the output file." << endl;
exit(1);
}
outputFile << q << "\n";
outputFile << cost << "\n";
for (const auto& edge : edges) {
outputFile << edge.first + 1 << " " << edge.second + 1
<< "\n";
}
}

void findMinCostRoads(const Graph& graph, int n, int m)
{
vector<bool> visited(n, false);
vector<int> key(n, INF);
vector<int> parent(n, -1);
vector<int> position(n, -1);
vector<MinHeapNode> heap(n);
heap[0].vertex = 0;
heap[0].key = 0;
position[0] = 0;
for (int i = 1; i < n; i++) {
heap[i].vertex = i;
heap[i].key = INF;
position[i] = i;
}
while (!heap.empty()) {
MinHeapNode node = heap[0];
heap[0] = heap.back();
position[node.vertex] = -1;
heap.pop_back();
heapify(heap, position, 0);
int u = node.vertex;
visited[u] = true;

for (const Edge& edge : graph[u]) {
int v = edge.destination;
if (!visited[v] && edge.category == 1 && edge.cost <
key[v]) {
parent[v] = u;
key[v] = edge.cost;
decreaseKey(heap, position, v, key[v]);
}
}
}
int q = 0;
int totalCost = 0;
vector<pair<int, int>> selectedEdges;
for (int i = 1; i < n; i++) {
if (parent[i] != -1) {
q++;
totalCost += key[i];
selectedEdges.emplace_back(parent[i], i);
}
}
writeOutput("village.out", q, totalCost, selectedEdges);
}
int main() {

int n, m;
Graph graph = readInput("village.in", n, m);
findMinCostRoads(graph, n, m);
return 0;
}

16.7  HAMILTONIAN GRAPHS.
EULERIAN GRAPHS
1. In an amusement park, there are n (n≤30)
entertainment points numbered from 1 to n. There
are pathways between m pairs of points. The
administrators aim to mark a route that ensures
visitors can pass through each entertainment point
exactly once and return to the entrance (which
coincides with the exit). Display whether such a
route is possible. The entry point x is read from the
keyboard.
Example: n=6, m=9, x=1
1 2
1 3
1 6
2 3
2 4
3 4
3 6
3 5
4 5

Result: 1, 2, 3, 4, 5, 6, 1.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int n,m,a[31][31],st[31],k,ns;
void readData()
{
ifstream f("park.in");
f>>n>>m;
for(int i=1;i<=m;i++)
{
int x,y;
f>>x>>y;
a[x][y]=a[y][x]=1;
}
f.close();
}
int e_valid()
{
if(k>1)
if(!a[st[k-1]][st[k]])

return 0;
else
for(int i=1;i<=k-1;i++)
if(st[i]==st[k])
return 0;
if(k==n)
if(!a[st[1]][st[k]])
return 0;
return 1;
}
void afisare()
{
for(int i=1;i<=n;i++)
cout<<st[i]<<" ";
cout<<st[1];
k=0; //find the exist
ns++;
}
void back(int x)
{
k=2; //first level
st[1]=x;
while(k>0)//k=0, end of loop

if(st[k]<n)
{
st[k]++;
if(e_valid())//valid element
if(k==n)//have we found a solution?
afisare();
else  //go up onto stack
{
k++;
st[k]=0;
}
}
else
k—;
}
int main()
{
readData();
int x;
cout<<"x=";
cin>>x;
back(x);
if(ns==0)

cout<<"No solution found.";
return 0;
}
1. On a test track, there are multiple routes delimited
by pairs of exchange nodes. In order to organize a
rally-type competition, the track administrators
aim, if possible, to determine a circuit that passes
through all routes exactly once so that each car
returns to where it started. Display Yes or No
depending on whether such a circuit is possible or
not. The number n of exchange nodes and the m
routes in the form of pairs x, y, representing the
exchange nodes that delimit them, are known.
Example: n=8, m=12
1 2
1 3
2 3
2 5
2 6
3 4
3 8

4 8
5 8
5 6
5 7
7 8
Result: Yes.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int n,m,a[31][31];
bool visited[31];
void readData()
{
ifstream f("data.in");
f>>n>>m;
for(int i=1;i<=m;i++)
{
int x,y;
f>>x>>y;
a[x][y]=a[y][x]=1;

}
f.close();
}
void DFS(int node)
{
visited[node]=true;
for (int i=1; i<=n; i++)
if (a[node][i] && !visited[i])
DFS(i);
}
bool isConnected()
{
for (int i=1; i<=n; i++)
{
if (!visited[i])
return false;
}
return true;
}
bool isEulerianCycle()
{
if (!isConnected())
return false;

int oddDegreeCount=0;
for(int i=1; i<=n; i++)
{
int degree=0;
for(int j=1; j<=n; j++)
{
if(a[i][j])
degree++;
}
if (degree%2!=0)
oddDegreeCount++;
}
if (oddDegreeCount==0 || oddDegreeCount==2)
return true;
return false;
}
int main()
{
readData();
DFS(1);// starting DFS from first node
if(isEulerianCycle())
cout<<"Yes"<<endl;
else

cout<<"No"<<endl;
return 0;
}
1. On a test track, there are multiple routes delimited
by pairs of exchange nodes. In order to organize a
rally-type competition, the track administrators
aim, if possible, to determine a circuit that passes
through all routes exactly once so that each car
returns to where it started. Display whether such a
circuit is possible. The number n of exchange
nodes and the m routes in the form of pairs x, y,
representing the exchange nodes that delimit
them, are known.
Example:
n=6, m=8
1 2
1 6
2 6
2 3
3 5
5 6

3 4
4 5
Result: 1, 2, 3, 4, 5, 3, 6, 2, 5, 6, 1.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int n,m,a[31][31];
int circuit[31*31],p;
void readData()
{
ifstream f("graph.in");
f>>n>>m;
for(int i=1; i<=m; i++)
{
int x,y;
f>>x>>y;
a[x][y]=a[y][x]=1;
}
f.close();
}
void Euler(int node)

{
for(int i=1; i<=n; i++)
{
if(a[node][i]==1)
{
a[node][i]=a[i][node]=0;
Euler(i);
}
}
circuit[++p]=node;
}
int main()
{
readData();
Euler(1);
for(int i=p; i>=1; i—)
{
cout<<circuit[i];
if (i>1)
cout<<",";
}
cout<<endl;
return 0;

}
1. Given a directed graph with n (n≤10) vertices and
m edges, each arc having an associated cost. A
circuit in this graph is called Hamiltonian if each
vertex in the graph appears exactly once. A graph
that contains such a circuit is called a Hamiltonian
graph. The cost of a circuit is equal to the sum of
the costs of the edges on the circuit. Given a
directed graph with costs on edges, check if it is
Hamiltonian. If so, determine the Hamiltonian
circuit with the minimum cost. Input: The first line
of the input file hamilton.in contains two integers n
and m. On each of the next m lines, there is a
triplet of the form x y c, meaning that there is an
arc between vertices x and y with cost c. Vertices
are numbered from 0 to n-1.
Example: If the file hamilton.in contains the
values:
5 10
0 1 9
0 3 8

1 0 7
1 2 1
1 4 3
2 0 5
2 4 4
3 2 6
4 3 7
4 1 1
The minimum cost Hamiltonian cycle in the example
is: 0 3 2 4 1 0, and it has a cost of 26.
Implementation:
#include <iostream>
#include <fstream>
#include <vector>
using namespace std;
const int INF=100000000;

const int MAXN=10;
int N, M, Sol;
int P[MAXN],U[MAXN];
int C[MAXN][MAXN];
vector<int> hamiltonianCycle;
void back(int k)
{
if(k>N)
{
int res=C[P[N]][P[1]];
for(int i=1; i<N; ++i)
res+=C[P[i]][P[i+1]];
if(res<Sol)
{
Sol=res;
hamiltonianCycle.clear();
for (int i=1; i<=N; ++i)
hamiltonianCycle.push_back(P[i]);
}
return;
}
for (int i=0; i<N; ++i)
{

if (!U[i])
{
U[i]=1;
P[k]=i;
back(k+1);
U[i]=0;
}
}
}
int main()
{
ifstream fin("hamiltonian.in");
fin>>N>>M;
Sol=INF;
for(int i=0; i<N; ++i)
for(int j=0; j<N; ++j)
C[i][j]=INF;
for(int i=1; i<=M; ++i)
{
int x,y;
fin>>x>>y;
fin>>C[x][y];
}

back(1);
if(Sol==INF)
cout<<"No solution found."<<endl;
else
{
cout<<"Hamiltonian cycle with minimum cost: ";
for(int i=0; i<N; ++i)
cout<<hamiltonianCycle[i]<<" ";
cout<<hamiltonianCycle[0]<<endl;
cout<<"The minimum cost is: "<<Sol<<endl;
}
return 0;
}
1. Given an undirected graph with n (n≤30) nodes
and m edges, display all Eulerian circuits that the
graph has.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int a[50][50],n,m;
int viz[50],g[50];

void readData()
{
ifstream f("graph.in");
int x,y,i;
f>>n>>m;
for(i=1; i<=m; i++)
{
f>>x>>y;
a[x][y]=a[y][x]=1;
g[x]++;
g[y]++;
}
}
void DF(int nod)
{
cout<<nod<<" ";
viz[nod]=1;
int k;
for(k=1; k<=n; k++)
if(a[nod][k]==1 && viz[k]==0)
DF(k);
}
int EConex()

{
DF(1);
for(int i=1; i<=n; i++)
if(viz[i]==0)
return 0;
return 1;
}
int EEulerian()
{
if(EConex()==0)
return 0;
for(int i=1; i<=n; i++)
if(g[i]%2==0)
return 1;
return 0;
}
void CicluEulerian(int k)
{
int nmax=0,maxi=0;
cout<<k<<" ";
for(int i=1; i<=n; i++)
{
if(a[k][i]==1)

if(g[i]>maxi)
{
maxi=g[i];
nmax=i;
}
}
if(nmax!=0)
{
a[k][nmax]=a[nmax][k]=0;//delete the edge
g[k]—;//decrease the degrees
g[nmax]—;
CicluEulerian(nmax);//next node
}
}
int main()
{
readData();
if(EEulerian()==1)
{
for(int i=1; i<=n; i++)
{
for(int j=1; j<=n; j++)
viz[j]=0; // reset the array

CicluEulerian(i);
cout<<endl;
}
}
else
cout<<"Not an Eulerian Graph.";
return 0;
}
1. Given N domino pieces, determine a way to
construct a sequence that contains all domino
pieces, respecting the domino game rule. This rule
means that the numbers written on the
corresponding faces of two consecutive dominoes
must be equal. The dominoes can be chosen in any
order and rotated.
Input: The first line of the input file domino.in
contains the number N of domino pieces. The next N
lines each contain two numbers separated by a single
space, representing the two numbers written on the
respective domino piece.
Output: The first line of the domino.out file should
contain 1 if there is a solution and 0 if there is no
solution. If there is a solution, exactly N lines will

follow, describing the constructed sequence. These N
lines should contain the order numbers of the domino
pieces in the order they appear in the sequence. Each
order number will be followed by a space and a
number, which can be 0 or 1 and will be equal to 1 if
the corresponding domino piece has been rotated.
Example:
domino.in    domino.out
12      1
1 4     3 0
3 7     11 0
1 5     12 1
2 4     9 1
2 5     8 1
2 6     2 0
2 7     7 1
3 4     6 0
4 6     10 1
5 6     5 1
5 7     4 0

6 7     1 1
Implementation :
#include <bits/stdc++.h>
using namespace std;
ifstream fin("domino.in");
ofstream fout("domino.out");
#define cin fin
#define cout fout
int const N =50005;
int m;
struct info
{
int nod,pos;
bool intors = false;
info(int nod,int pos,bool
intors):nod(nod),pos(pos),intors(intors){}
bool operator==(const info a)const{
return a.pos == pos;}
};
class hashh
{
public:

int operator()(const info &val)const
{return hash<int>()(val.pos);}
};
unordered_multiset<info,hashh> v[22];
bool viz[22];
void dfs(int node,int pos=-1,bool type=false)
{
while(!v[node].empty())
{
info del = *(v[node].begin());
v[node].erase(del);
v[del.nod].erase(del);
dfs(del.nod,del.pos,!del.intors);
}
if(pos != -1)
cout << pos <<' '<< type <<'\n';
}
int main()
{
cin>>m;
int alfa = -1;
for(int i=0;i<m;i++)
{

int x,y;
cin >> x >> y;
v[x].emplace(y,i+1,false);
v[y].emplace(x,i+1,true);
alfa = x;
}
int nr1=-1,nr2=-1;
for(int i=0;i<20;i++)
if(v[i].size()%2)
{
if(nr1 == -1) nr1 = i;
else if(nr2 == -1)nr2 = i;
else{cout << 0;return 0;}
}
if(nr2 == -1 && nr1!= -1){cout << 0;return 0;}
cout << "1\n";
if(nr1==-1)
dfs(alfa);
else
dfs(nr1);
}

1. Daniel really enjoys hiking. The area he wants to
visit is organized into N localities, and there are
transport routes between certain pairs of localities.
Daniel wants to travel each route, so he decided to
spend a vacation with routes in a number of
stages. In each stage, Daniel starts from any
locality among those visited, travels certain routes,
and stops in any locality he desires. A route is
represented by a sequence of localities, such that
between any two consecutive localities in the
sequence, there is a route. During his stroll, Daniel
wants to traverse each route only once, but he can
pass through the same locality multiple times.
Given the number of localities and the routes
between them, determine the minimum number of
routes in which Daniel can travel all the routes.
Additionally, provide a way to traverse the routes
in stages. The first line of the input file holiday.in
contains the number N, representing the number
of localities, and M, representing the number of
stages. The next M lines contain pairs (i, j)
indicating the existence of a route from locality i to
locality j.
Example:
holiday.in   Result:

7 7    2 (stages)
1 2    7 localities: 1 4 5 3 2 1 3
1 3    2 localities: 6 7
1 4
2 3
3 5
4 5
6 7
Implementation:
#include <iostream>
#include <fstream>
#include <vector>
using namespace std;
const int MAX_N = 101;
int n, m, a[MAX_N][MAX_N];
bool visited[MAX_N];
void readData()
{
ifstream f("holiday.in");
f >> n >> m;
// Initialize adjacency matrix with 0

for (int i = 1; i <= n; i++)
{
for (int j = 1; j <= n; j++)
{
a[i][j] = 0;
}
}
for (int i = 1; i <= m; i++)
{
int x, y;
f >> x >> y;
a[x][y] = a[y][x] = 1;
}
f.close();
}
void printPath(const vector<int>& path)
{
for (int i = 0; i < path.size(); i++)
{
cout << path[i] << " ";
}
cout << endl;
}

void findEulerianChain(int start)
{
vector<int> chain;
chain.push_back(start);
visited[start] = true;
while (true)
{
int v = chain.back();
bool found = false;
for (int i = 1; i <= n; i++)
{
if (a[v][i] == 1 && !visited[i])
{
chain.push_back(i);
visited[i] = true;
a[v][i] = a[i][v] = 0;  // Remove the edge to avoid
repeating it in the chain
found = true;
break;
}
}
if (!found)
{

break;
}
}
cout << chain.size() << " localities: ";
printPath(chain);
}
void findEulerianChains()
{
int numComponents = 0;
for (int v = 1; v <= n; v++)
{
if (!visited[v])
{
numComponents++;
findEulerianChain(v);
}
}
cout << "Stages: " << numComponents << endl;
}
int main()
{
readData();
findEulerianChains();

return 0;
}

CHAPTER 17 – TREES AND
ARBORESCENCES
17.1 General Trees
17.2 Arborescences
17.3 Binary Trees. Binary Search Trees.
Applications:

17.1  GENERAL TREES
1. Starting from the definition of a tree: an undirected
graph that is connected and has no cycles,
determine if an undirected graph is a tree. The
graph is stored using an adjacency matrix. In the
data.in file, the number n (n≤30) of vertices and
the adjacency matrix are stored.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int n,a[31][31];
bool visited[31];
void readData()
{
ifstream f("data.in");
f>>n;
for (int i=1; i<=n; i++)
for (int j=1; j<=n; j++)
f>>a[i][j];
f.close();
}

bool esteCiclic(int v, int parent)
{
visited[v]=true;
for(int i=1; i<=n; i++)
{
if(a[v][i])
{
if (!visited[i])
if (esteCiclic(i,v))
return true;
else if (i!=parent)
return true;
}
}
return false;
}
bool esteArbore()
{
// check if the graph is connected
int source=0;
for(int i=1; i<=n; i++)
if(!visited[i])
{

source=i;
break;
}
if(esteCiclic(source,-1))
return false;
// check if the graph has no cycles
for(int i=1; i<=n; i++)
if (!visited[i])
return false;
return true;
}
int main()
{
readData();
if(esteArbore())
cout<<"It is a tree."<<endl;
else
cout<<"NOT a tree."<<endl;
return 0;
}
1. Knowing that an undirected graph with n nodes
that has n-1 edges and no cycles is a tree,

determine if an undirected graph stored using an
adjacency matrix can be a tree. In the data.in file,
the number n of vertices and the adjacency matrix
are stored.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int n,a[31][31];
bool visited[31];
void readData()
{
ifstream f("data.in");
f>>n;
for (int i=1; i<=n; i++)
for (int j=1; j<=n; j++)
f>>a[i][j];
f.close();
}
bool esteCiclic(int v,int parent)
{
visited[v]=true;
for(int i=1; i<=n; i++)

{
if(a[v][i])
{
if(!visited[i])
if(esteCiclic(i,v))
return true;
else if (i!=parent)
return true;
}
}
return false;
}
bool esteConex()
{
for (int i=1; i<=n; i++)
visited[i]=false;
// graph is connected
int source=1;
while(visited[source])
source++;
return !esteCiclic(source,-1);
}
bool esteArbore()

{
if(!esteConex())
return false;
int numEdges=0;
for(int i=1; i<=n; i++)
{
for (int j=i+1; j<=n; j++)
{
if (a[i][j])
numEdges++;
}
}
return numEdges==n-1;
}
int main()
{
citire();
if(esteArbore())
cout<<"It is a tree."<<endl;
else
cout<<"NOT a tree."<<endl;
return 0;
}

1. In the data.in file, the number n (n≤100) of
vertices of a tree is stored, and thereafter, until the
end of the file, the edges are stored as pairs (x, y)
with the meaning that x is the ancestor of y.
a. Store the tree using the parent array.
b. Store the tree using the adjacency matrix.
c. Store the tree using adjacency lists.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int n,a[31][31];
int tati[31];
struct nod
{
int info;
nod *next;
}*L[31];
void generare()
{
for (int i=1; i<=n; i++)
{

L[i]=NULL;
for (int j=1; j<=n; j++)
{
if (a[i][j]==1)
{
nod *q=new nod;
q->info=j;
q->next=L[i];
L[i]=q;
}
}
}
}
void readData()
{
ifstream f("data.in");
f>>n;
int x,y;
while(f>>x>>y)
{
tati[y]=x;//build the parents array
a[x][y]=1;//build the adjacency matrix
generare();

}
f.close();
}
void display()
{
for (int i=1; i<=n; i++)
{
cout<<"Adjacency list for node "<<i<<": ";
nod *q=L[i];
if(q==0)
cout<<"Empty!";
while(q!=NULL)
{
cout<<q->info<<" ";
q=q->next;
}
cout<<endl;
}
cout<<endl;
}
int main()
{
readData();

//parents array
cout<<"The parent’s array is: "<<endl;
for(int i=1;i<=n;i++)
cout<<tati[i]<<" ";
cout<<endl;
//Adjacency matrix
cout<<"The adjacency matrix is: "<<endl;
for(int i=1;i<=n;i++)
{
for(int j=1;j<=n;j++)
cout<<a[i][j]<<" ";
cout<<endl;
}
cout<<endl;
//display adjacency lists
cout<<"Adjacency lists: "<<endl;
afisare();
return 0;
}
1. In the data.in file, the number n (n≤100) of
vertices of a tree is stored, and thereafter, until the
end of the file, the edges are stored as pairs (x, y)
with the meaning that x is the ancestor of y.

a. Store the tree using the parent array.
b. Determine the root.
c. Display the leaves (terminal nodes).
d. For a given node, determine its children and direct
ancestor.
e. Determine the node with the most descendants.
f. Display the nodes with only one direct descendant.
g. Display the children of the root.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int n,tata[101];
void readData()
{
ifstream f("data.in");
f>>n;
int x,y;
while(f>>x>>y)
tata[y]=x;//parent array
f.close();
}
int afiRadacina()

{
for(int i=1;i<=n;i++)
if(tata[i]==0)
return i;
}
void afisareFrunze()
{
cout<<"The leaves are: ";
for(int i=1; i<=n; i++)
{
bool esteFrunza=true;
for (int j=1; j<=n; j++)
{
if(tata[j]==i)
{
esteFrunza=false;
break;
}
}
if(esteFrunza)
cout<<i<<" ";
}
cout<<endl;

}
void determinaFiiSiAscendent(int nodCitit)
{
cout<<"Sons of node "<<nodCitit<<" are: ";
for(int i=1; i<=n; i++)
if(tata[i]==nodCitit)
cout<<i<<" ";
cout<<endl;
int ascendent=tata[nodCitit];
cout<<"Direct ancestor of "<<nodCitit<<" is "
<<ascendent<<endl;
}
void determinaNodCuCeiMaiMultiDescendenti()
{
int nodMaxDescendenti=-1;
int numarMaxDescendenti=-1;
for(int i=1; i<=n; i++)
{
int numarDescendenti=0;
for(int j=1; j<=n; j++)
{
if (tata[j]==i)
numarDescendenti++;

}
if(numarDescendenti>numarMaxDescendenti)
{
numarMaxDescendenti=numarDescendenti;
nodMaxDescendenti=i;
}
}
cout<<"Node with max descendants: "
<<nodMaxDescendenti<<endl;
}
void afisareNoduriCuUnSingurDescendent()
{
cout<<"Nodes with only one descendant: ";
for (int i=1; i<=n; i++)
{
int numarDescendenti=0;
for (int j=1; j<=n; j++)
{
if (tata[j]==i)
numarDescendenti++;
}
if (numarDescendenti==1)
cout<<i<<" ";

}
cout<<endl;
}
void afisareFiiRadacina()
{
int radacina=afiRadacina();
cout<<"Sons of root: ";
for(int i=1; i<=n; i++)
{
if(tata[i]==radacina)
cout<<i<<" ";
}
cout<<endl;
}
int main()
{
readData();
///a)
cout<<"Parent array:"<<endl;
for(int i=1;i<=n;i++)
if(tata[i]!=0)
cout<<i<<" has father "<<tata[i]<<endl;
else cout<<i<<" is the root!"<<endl;

///b) root
cout<<"Root of tree: "<<afiRadacina()<<endl;
///c) display leaves
afisareFrunze();
///d) display sons and direct ancestor
int x;
cout<<"Un nod:";cin>>x;
determinaFiiSiAscendent(x);
///e) node with max descendants
determinaNodCuCeiMaiMultiDescendenti();
///f) nodes with only one descendant
afisareNoduriCuUnSingurDescendent();
///g) display the sons of root
afisareFiiRadacina();
return 0;
}
1. Genealogical Tree 1. From the data.in file, the
following information is read: the number n
(n≤100) of individuals in a genealogical tree,
numbered from 1 to n. Next, pairs of numbers x, y
are read, where x is the parent of y. Determine:
a. The common ancestor of all individuals in the tree.

b. Individuals without descendants.
c. The parent of an individual x.
d. The children of an individual x.
e. Whether two individuals x and y are siblings.
f. All ancestors of an individual.
g. All descendants (direct or indirect) of an individual.
h. The grandfather of an individual.
i. Whether x is the ancestor of y (direct or indirect).
j. In which generation does an individual x belong.
k. The number of generations in the tree.
l. The cousins of an individual.
m. Whether x is the common ancestor of y and z.
n. Whether x is the common descendant of y and z.
o. For two individuals x and y, display the first
common ancestor.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int n, tata[101];
///———————————————————
void readInput() {
ifstream file("input.txt");
file >> n;

int x, y;
while (file >> x >> y)
tata[y] = x; // Building the parent vector
file.close();
}
///———————————————————
int findRoot() {
for (int i = 1; i <= n; i++)
if (tata[i] == 0)
return i;
}
///———————————————————
void displayParents() {
cout << "The parent vector:" << endl;
for (int i = 1; i <= n; i++)
if (tata[i] != 0)
cout << i << " has parent " << tata[i] << endl;
else
cout << i << " is the root!" << endl;
}
///———————————————————
int findCommonAncestorForAll() {
// Finding the root of the tree

int root = findRoot();
// Checking if all other persons have the root as a common
ancestor
for (int i = 1; i <= n; i++) {
if (i != root && tata[i] != root) {
int person = i;
while (person != root) {
person = tata[person];
if (person == 0)
// Person i does not have the root as a common ancestor
return -1;
}
}
}
// All persons have the root as a common ancestor
return root;
}
///———————————————————
void displayPeopleWithoutDescendants() {
cout << "People without descendants are: ";
for (int i = 1; i <= n; i++) {
bool hasDescendants = false;
for (int j = 1; j <= n; j++) {

if (tata[j] == i) {
hasDescendants = true;
break;
}
}
if (!hasDescendants)
cout << i << " ";
}
cout << endl;
}
///———————————————————
int findParent(int x) {
if (x <= 0 || x > n)
return -1; // Person x does not exist in the tree
return tata[x];
}
///———————————————————
void displayChildren(int x) {
cout << "The children of person " << x << " are: ";
bool hasChildren = false;
for (int i = 1; i <= n; i++) {
if (tata[i] == x) {
cout << i << " ";

hasChildren = true;
}
}
if (!hasChildren)
cout << "Person " << x << " has no children.";
cout << endl;
}
///———————————————————
bool areSiblings(int x, int y) {
if (x <= 0 || x > n || y <= 0 || y > n)
return false; // Persons x and y do not exist in the tree
int parentX = findParent(x);
int parentY = findParent(y);
return parentX != -1 && parentX == parentY;
}
///———————————————————
void displayAncestors(int x) {
cout << "Ancestors of person " << x << " are: ";
int parent = findParent(x);
while (parent != -1 && parent != 0) {
cout << parent << " ";
parent = findParent(parent);
}

cout << endl;
}
///———————————————————
void displayDescendantsRecursively(int x) {
for (int i = 1; i <= n; i++) {
if (tata[i] == x) {
cout << i << " ";
displayDescendantsRecursively(i);
}
}
}
void displayDescendants(int x) {
cout << "Descendants of person " << x << " are: ";
displayDescendantsRecursively(x);
cout << endl;
}
///———————————————————
int findGrandparent(int x) {
if (x <= 0 || x > n)
return -1; // Person x does not exist in the tree
int parent = findParent(x);
if (parent != -1)
return findParent(parent); // Returns the parent's parent

return -1; // Person x has no grandparent
}
///———————————————————
bool isAncestor(int x, int y) {
if (x <= 0 || x > n || y <= 0 || y > n)
return false; // Persons x and y do not exist in the tree
if (x == y)
return true; // Person x is identical to person y
int parent = findParent(y);
while (parent != -1) {
if (parent == x)
return true; // Person x is the ancestor of y
parent = findParent(parent);
}
return false; // Person x is not the ancestor of y
}
///———————————————————
int determineGeneration(int x) {
if (x <= 0 || x > n)
return -1; // Person x does not exist in the tree
int generation = 0;
int parent = findParent(x);
while (parent != -1) {

generation++;
parent = findParent(parent);
}
return generation;
}
///———————————————————
int determineMaxGeneration() {
int maxGeneration = 0;
for (int i = 1; i <= n; i++) {
int generation = determineGeneration(i);
if (generation > maxGeneration)
maxGeneration = generation;
}
return maxGeneration;
}
///———————————————————
void determineCousins(int x) {
int parent = findParent(x);
int grandparent = findParent(parent);
if (x <= 0 || x > n) {
cout << "Person " << x << " does not exist in the tree."
<< endl;
return;

} else if (parent == -1) {
cout << "Person " << x << " has no known parents." <<
endl;
return;
} else if (grandparent == -1) {
cout << "Person " << x << " has no known cousins." <<
endl;
return;
} else {
cout << "Cousins of person " << x << " are: ";
for (int i = 1; i <= n; i++) {
if (i == x || findParent(i) == -1)
continue; // Ignore the current person and persons
without parents
int currentParent = findParent(i);
int currentGrandparent = findParent(currentParent);
if (currentGrandparent == grandparent && currentParent
!= parent)
cout << i << " ";
}
}
cout << endl;
}

///———————————————————
bool isCommonAncestor(int x, int y, int z) {
if (x <= 0 || x > n || y <= 0 || y > n || z <= 0 || z > n)
return false; // Persons do not exist in the tree
const int MAX = 101;
int pathY[MAX], pathZ[MAX];
int lengthPathY = 1, lengthPathZ = 1;
// Follow the path from y to the root
int nodeY = y;
while (nodeY != 0) {
pathY[lengthPathY] = nodeY;
lengthPathY++;
nodeY = tata[nodeY];
}
// Follow the path from z to the root
int nodeZ = z;
while (nodeZ != 0) {
pathZ[lengthPathZ] = nodeZ;
lengthPathZ++;
nodeZ = tata[nodeZ];
}
// Check if x is a common ancestor for y and z
for (int i = 1; i <= lengthPathY; i++)

for (int j = 1; j <= lengthPathZ; j++)
if (pathY[i] == pathZ[j] && pathY[i] == x)
return true; // x is a common ancestor for y and z
return false; // x is not a common ancestor for y and z
}
///———————————————————
bool isCommonDescendant(int x, int y, int z) {
if (x <= 0 || x > n || y <= 0 || y > n || z <= 0 || z > n)
return false; // Persons do not exist in the tree
// Check if x is a common descendant for y and z
bool isDescendantY = false;
int nodeY = y;
while (nodeY != 0) {
if (nodeY == x) {
isDescendantY = true;
break;
}
nodeY = tata[nodeY];
}
bool isDescendantZ = false;
int nodeZ = z;
while (nodeZ != 0) {
if (nodeZ == x) {

isDescendantZ = true;
break;
}
nodeZ = tata[nodeZ];
}
return isDescendantY && isDescendantZ;
}
///———————————————————
int findFirstCommonAncestor(int x, int y) {
if (x <= 0 || x > n || y <= 0 || y > n)
return -1; // Persons do not exist in the tree
const int MAX = 101;
int pathX[MAX], pathY[MAX];
int lengthPathX = 1, lengthPathY = 1;
// Follow the path from x to the root
int nodeX = x;
while (nodeX != 0) {
pathX[lengthPathX] = nodeX;
lengthPathX++;
nodeX = tata[nodeX];
}
// Follow the path from y to the root
int nodeY = y;

while (nodeY != 0) {
pathY[lengthPathY] = nodeY;
lengthPathY++;
nodeY = tata[nodeY];
}
// Find the first common ancestor
int commonAncestor = -1;
int i = lengthPathX - 1;
int j = lengthPathY - 1;
while (i >= 1 && j >= 1 && pathX[i] == pathY[j]) {
commonAncestor = pathX[i];
i—;
j—;
}
return commonAncestor;
}
///———————————————————
int main() {
readInput();
displayParents();
/// a) Finding the common ancestor for all persons in the
tree
int commonAncestor = findCommonAncestorForAll();

if (commonAncestor != -1)
cout << "The common ancestor for all persons in the tree
is: " << commonAncestor << endl;
else
cout << "There is no common ancestor for all persons in
the tree." << endl;
/// b) Displaying persons without descendants
displayPeopleWithoutDescendants();
/// c) Finding the parent for person x
int x; // Person for which we want to find the parent
cout << "Enter person x: ";
cin >> x;
int parent = findParent(x);
if (parent != -1)
cout << "The parent of person " << x << " is: " <<
parent << endl;
else
cout << "Person " << x << " does not exist in the tree."
<< endl;
/// d) Finding the children for person x
cout << "Enter person x: ";
cin >> x;
displayChildren(x);

/// e) Checking if x and y are siblings
int y;
cout << "Enter person x: ";
cin >> x;
cout << "Enter person y: ";
cin >> y;
bool siblings = areSiblings(x, y);
if (siblings)
cout << "Persons " << x << " and " << y << " are
siblings." << endl;
else
cout << "Persons " << x << " and " << y << " are not
siblings." << endl;
/// f) Finding the ancestors for person x
cout << "Enter person x: ";
cin >> x;
displayAncestors(x);
/// g) Finding the descendants for person x
cout << "Enter person x: ";
cin >> x;
displayDescendants(x);
/// h) Finding the grandparent for person x
cout << "Enter person x: ";

cin >> x;
int grandparent = findGrandparent(x);
if (grandparent != -1)
cout << "The grandparent of person " << x << " is " <<
grandparent << endl;
else
cout << "Person " << x << " has no grandparent." <<
endl;
/// i) Checking if x is the ancestor of y (directly or
indirectly)
cout << "Enter person x: ";
cin >> x;
cout << "Enter person y: ";
cin >> y;
if (isAncestor(x, y))
cout << "Person " << x << " is the ancestor of person "
<< y << endl;
else
cout << "Person " << x << " is not the ancestor of person
" << y << endl;
/// j) Finding which generation person x belongs to
cout << "Enter person x: ";
cin >> x;

int generation = determineGeneration(x);
if (generation != -1)
cout << "Person " << x << " belongs to generation " <<
generation << endl;
else
cout << "Person " << x << " does not exist in the tree."
<< endl;
/// k) Finding the number of generations in the tree
int numGenerations = determineMaxGeneration();
cout << "The genealogical tree has " << numGenerations
<< " generations." << endl;
/// l) Finding the cousins of person x
cout << "Enter person x: ";
cin >> x;
determineCousins(x);
/// m) Check if x is a common ancestor for y and z
int z;
cout << "Enter x, y, z: ";
cin >> x >> y >> z;
if (isCommonAncestor(x, y, z))
cout << "Person " << x << " is a common ancestor for
persons " << y << " and " << z << endl;
else

cout << "Person " << x << " is not a common ancestor
for persons " << y << " and " << z << endl;
/// n) Check if x is a common descendant for y and z
cout << "Enter persons x, y, and z: ";
cin >> x >> y >> z;
if (isCommonDescendant(x, y, z))
cout << "Person " << x << " is a common descendant for
persons " << y << " and " << z << endl;
else
cout << "Person " << x << " is not a common descendant
for persons " << y << " and " << z << endl;
/// o) Find the first common ancestor for persons x and y
cout << "Enter x and y: ";
cin >> x >> y;
int commonAncestor1 = findFirstCommonAncestor(x, y);
if (commonAncestor1 != -1)
cout << "The first common ancestor for persons " << x
<< " and " << y << " is: " << commonAncestor1 << endl;
else
cout << "There is no common ancestor for persons " << x
<< " and " << y << endl;
return 0;
}

1. Genealogical Tree 2. The same requirements as
in the previous problem, with the difference that
from the input.in file, the following are read: the
number n of individuals in a genealogical tree, the
names of the n individuals (as strings).
Subsequently, pairs of names are read as strings x
and y, where x is the parent of y.
Implementation:
The same logic as in the previous problem is
applicable to the implementation of methods for this
task, with the exception of the `readData` function,
where we read strings instead:
#include <iostream>
#include <fstream>
#include <cstring>
using namespace std;
int n,tata[101];
char name[31][101];
///———————————————————
int search(char x[31])
{
for(int i=1; i<=n; i++)
if(stricmp(nume[i],x)==0)

return i;
return 0;
}
///———————————————————
void readData()
{
ifstream f("input.in");
int i,j;
char x[31],y[31];
while(f>>x>>y)
{
i=search(x);
if(i==0)
{
n++;
i=n;
strcpy(name[n],x);
}
j=search(y);
if(j==0)
{
n++;
j=n;

strcpy(name[n],y);
}
tata[j]=i;
}
f.close();
}
1. Evidently, the number of levels in a tree depends
on the chosen root. Given a connected and acyclic
graph, determine a node to serve as the root in
such a way that the resulting tree has the
maximum depth. Display the parent vector for the
obtained tree.
Implementation:
#include <iostream>
#include <fstream>
#include <cstring>
#define MAX_NODES 1000
using namespace std;
// Structure to represent a node in the graph
struct Node {
int id;
int numNeighbors;

Node* neighbors[MAX_NODES];
Node(int _id) : id(_id), numNeighbors(0) {}
};
// Function to build the graph from the input file
void buildGraph(const string& filename, Node** nodes) {
ifstream inputFile(filename);
if (!inputFile) {
cerr << "Failed to open the input file." << endl;
return;
}
int numEdges;
inputFile >> numEdges;
for (int i = 1; i <= numEdges; i++) {
int x, y;
inputFile >> x >> y;
if (!nodes[x])
nodes[x] = new Node(x);
if (!nodes[y])
nodes[y] = new Node(y);
nodes[x]->neighbors[nodes[x]->numNeighbors++] =
nodes[y];
nodes[y]->neighbors[nodes[y]->numNeighbors++] =
nodes[x];

}
inputFile.close();
}
// Function to compute the maximum depth of the tree and
construct the fathers vector
void computeMaxDepth(Node* start, int* fathers) {
bool visited[MAX_NODES + 1];
memset(visited, false, sizeof(visited));
fathers[start->id] = 0;
Node* queue[MAX_NODES];
int front = 0, rear = 0;
queue[rear++] = start;
visited[start->id] = true;
while (front < rear) {
Node* current = queue[front++];
for (int i = 0; i < current->numNeighbors; i++) {
Node* neighbor = current->neighbors[i];
if (!visited[neighbor->id]) {
visited[neighbor->id] = true;
fathers[neighbor->id] = current->id;
queue[rear++] = neighbor;
}
}

}
}
int main() {
const string filename = "date.in";
Node* nodes[MAX_NODES + 1] = { nullptr };
int fathers[MAX_NODES + 1] = { 0 };
// Read the graph from the input file
buildGraph(filename, nodes);
int numNodes = sizeof(nodes) / sizeof(nodes[0]) - 1; //
Exclude the nullptr at index 0
// Find the optimal root and compute the maximum depth
Node* root = nullptr;
int maxDepth = 0;
for (int i = 1; i <= numNodes; i++) {
computeMaxDepth(nodes[i], fathers);
int depth = 0;
for (int j = 1; j <= numNodes; j++) {
int nodeDepth = 0;
int currentNode = j;
while (fathers[currentNode] != 0) {
currentNode = fathers[currentNode];
nodeDepth++;
}

depth = max(depth, nodeDepth);
}
if (depth > maxDepth) {
maxDepth = depth;
root = nodes[i];
}
}
// Print the maximum depth and the fathers vector for the
optimal root
cout << "Maximum Depth: " << maxDepth << endl;
cout << "Fathers Vector:\n";
for (int i = 1; i <= numNodes; i++) {
cout << "Father of Node " << i << ": " << fathers[i] <<
endl;
}
// Clean up the memory
for (int i = 1; i <= numNodes; i++) {
delete nodes[i];
}
return 0;
}
1. Two trees are stored in the files graphs1.in and
graphs2.in. The number of nodes, n (n≤100), is

read from the keyboard, and the edges,
represented as pairs x, y with the meaning x is the
ancestor of y, are stored in the two files for each of
the two trees. Determine whether the two trees
represent the same graph.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int n;
int a1[101][101],a2[101][101];
void readData()
{
ifstream f1("graphs1.in");
ifstream f2("graphs2.in");
f1>>n;
int x,y;
while(f1>>x>>y)
a1[x][y]=a1[y][x]=1;
while(f2>>x>>y)
a2[x][y]=a2[y][x]=1;
f1.close();
f2.close();

}
// Function to compare the graphs
bool compareGraphs()
{
for(int i=1; i<=n; i++)
{
for(int j=1; j<=n; j++)
if (a1[i][j]!=a2[i][j])
return false;
}
return true;
}
int main()
{
readData();
// Compare the graphs
bool areEqual=compareGraphs();
if(areEqual)
cout<<"The graphs are the same."<<endl;
else
cout<<"They’re not the same graph."<<endl;
return 0;
}

1. In the data.in file, the number of vertices, n
(n≤100), of a tree is stored, and subsequently,
until the end of the file, the edges are stored as
pairs x, y, with the meaning x is the ancestor of y.
a. Display the level of a node x read from the
keyboard.
b. Display all nodes on the same level as a node x
read from the keyboard.
c. Display the nodes of the tree by levels.
d. Display which level has the most nodes.
e. Display all nodes placed on a level lower than level
k.
f. Display all nodes placed on a level higher than
level k.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int n;
int tata[101];
void readData()
{
ifstream f("data.in");
f>>n;

int x,y;
while(f>>x>>y)
tata[y]=x;
f.close();
}
// level of a node
int getNodeLevel(int node)
{
int level=0;
while(node!=0)
{
level++;
node=tata[node];
}
return level;
}
// display the level
void printNodeLevel(int node)
{
int level=getNodeLevel(node);
cout<<"Level of node "<<node<<" is: "<<level<<endl;
}
// check if 2 nodes are on the same level

bool areSameLevel(int node1, int node2)
{
int level1=0,level2=0;
int temp1=node1,temp2=node2;
while(temp1!=0)
{
level1++;
temp1=tata[temp1];
}
while(temp2!=0)
{
level2++;
temp2=tata[temp2];
}
return level1==level2;
}
// check nodes at the same level with a given node
void printNodesOnSameLevel(int node)
{
cout<<"Nodes from the same level as "<<node<<":"
<<endl;
for(int i=1; i<=n; i++)
if (i!=node && areSameLevel(node,i))

cout<<i<<" ";
cout<<endl;
}
// Maximum level of the tree
int getMaxLevel()
{
int maxLevel =0;
for(int i=1; i<=n; i++)
{
int level=getNodeLevel(i);
if(level>maxLevel)
maxLevel=level;
}
return maxLevel;
}
// display nodes per level
void printNodesByLevel()
{
cout<<"Nodes of the tree per level:" << endl;
for(int level=1; level<=getMaxLevel(); level++)
{
cout<<"Level "<<level<<": ";
for(int i=1; i<=n; i++)

{
if (getNodeLevel(i)==level)
cout<<i<<" ";
}
cout<<endl;
}
}
// get the level with max nodes
void printLevelWithMostNodes()
{
int maxLevel=0;
int maxNodeCount=0;
for(int level=1; level<=getMaxLevel(); level++)
{
int nodeCount=0;
for(int i=1; i<=n; i++)
if (getNodeLevel(i)==level)
nodeCount++;
if (nodeCount>maxNodeCount)
{
maxNodeCount=nodeCount;
maxLevel=level;
}

}
cout<<"The level with max nodes is: "
<<maxLevel<<endl;
}
// display nodes from a lower level than k
void printNodesOnLowerLevel(int k)
{
for(int i=1; i<=n; i++)
{
int nodeLevel=getNodeLevel(i);
if(nodeLevel<k)
cout<<i<<" ";
}
cout<<endl;
}
// display nodes from an upper level than k
void printNodesOnUpperLevel(int k)
{
for(int i=1; i<=n; i++)
{
int nodeLevel=getNodeLevel(i);
if (nodeLevel>k)
cout<<i<<" ";

}
cout<<endl;
}
int main()
{
citire();
///a)
int x;
cout<<"x=";cin>>x;
printNodeLevel(x);
///b)
cout<<"x=";cin>>x;
printNodesOnSameLevel(x);
///c)
printNodesByLevel();
///d)
printLevelWithMostNodes();
///e)
int k;
cout<<"k=";cin>>k;
printNodesOnLowerLevel(k);
///f)
cout<<"k=";cin>>k;

printNodesOnUpperLevel(k);
return 0;
}

17.2  ARBORESCENCES
1. Determine whether a directed graph, for which the
number of vertices n (n≤30), the number of arcs
m, and the arcs are known, is an arborescence. If
affirmative, display the root of the arborescence.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int n,m;
int a[31][31];
void readData()
{
ifstream f("data.in");
f>>n>>m;
for(int i=1; i<=m; i++)
{
int x,y;
f>>x>>y;
a[x][y]=1;
}
f.close();

}
bool dfs(int v, bool visited[])
{
visited[v]=true;
for(int i=1; i<=n; i++)
{
if(a[v][i]==1)
{
if(visited[i])
return false; // we found a cycle
if(!dfs(i, visited))
return false;
}
}
return true;
}
bool isArborescence(int& root)
{
bool visited[31]={false};
// check if there’s only one root
int rootCount=0;
for(int i=1; i<=n; i++)
{

bool hasIncomingEdges=false;
for(int j=1; j<=n; j++)
{
if(a[j][i]==1)
{
hasIncomingEdges=true;
break;
}
}
if(!hasIncomingEdges)
{
rootCount++;
root=i;
}
}
if(rootCount!=1)
return false;
// check if there are any cycles
if(!dfs(root, visited))
return false;
for(int i=1; i<=n; i++)
if(!visited[i])
return false; // unvisited nodes

return true;
}
int main()
{
citire();
int root=0;
if (isArborescence(root))
cout<<"Graph is an arborescence. The root is "
<<root<<endl;
else
cout<<"NOT an arborescence."<<endl;
return 0;
}
1. Consider an arborescence stored as an adjacency
matrix. In the file data.in, the number n of vertices
and the adjacency matrix are stored.
a. Generate the parent vector for the arborescence.
b. Display the root of the arborescence.
c. Display the leaves.
d. Display the height of the arborescence.
Implementation:
#include <iostream>

#include <fstream>
using namespace std;
int n;
int a[31][31];
int tata[31];
void readData()
{
ifstream f("data.in");
f>>n;
for(int i=1;i<=n;i++)
for(int j=1;j<=n;j++)
f>>a[i][j];
f.close();
}
void construiesteVectorTati()
{
for(int v=1; v<=n; v++)
{
tata[v]=0; // initialisation
for(int u=1; u<=n; u++)
{
if (a[u][v]!=0) // edge (u,v)
{

tata[v]=u; // store u in parent’s array
break; // we found the father, break the loop
}
}
}
}
int afiRadacina()
{
for(int i=1;i<=n;i++)
if(tata[i]==0)
return i;
}
void afiFrunze()
{
cout<<"Leaves are: ";
for(int v=1; v<=n; v++)
{
bool esteFrunza=true;
for(int u=1; u<=n; u++)
{
if(a[v][u]!=0)
{
esteFrunza=false;

break;
}
}
if(esteFrunza)
cout<<v<<" ";
}
cout<<endl;
}
void DFS(int v,int inaltimeCurenta,int& inaltimeMaxima)
{
inaltimeCurenta++;
for(int u=1; u<=n; u++)
if (a[v][u]!=0)
DFS(u,inaltimeCurenta,inaltimeMaxima);
inaltimeMaxima=max(inaltimeMaxima,inaltimeCurenta);
}
int calculeazaInaltimeArborescenta()
{
int inaltimeMaxima=0;
for(int v=1; v<=n; v++)
{
if (tata[v]==0)
{

int inaltimeCurenta=0;
DFS(v,inaltimeCurenta,inaltimeMaxima);
}
}
return inaltimeMaxima;
}
int main()
{
readData();
construiesteVectorTati();
// display parent’s array
for(int v=1; v<=n; v++)
cout<<"Father of "<<v<<" is: "<<tata[v]<<endl;
//root
int radacina=afiRadacina();
cout<<"Root of arborescence is: "<<radacina<<endl;
//leaves
afiFrunze();
//height
int inaltime=calculeazaInaltimeArborescenta();
cout<<"The height: "<<inaltime<<endl;
return 0;
}

1. In the file data.in, the number n (n≤100) of
vertices of an arborescence A is stored, and
subsequently, until the end of the file, the arcs are
stored as pairs x, y, with the meaning that x is the
ancestor of y. Determine whether a set P of
vertices read from the keyboard represents an
arborescence included in arborescence A.
Example: for n=11
3 4
3 1
4 2
4 5
4 6
1 7
5 11
5 8
5 9
7 10
P=7, then 4, 2, 5, 6, 11, 8, 9
result: it is an arborescence included in the given
arborescence.

Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int n,p,multime[101];
int tata[101];
void readData()
{
ifstream f("data.in");
f>>n;
int x,y;
while(f>>x>>y)
tata[y]=x;
f.close();
}
bool isIncluded()
{
for(int i=1; i<=p; i++)
{
int v=multime[i];
while(v!=0)
{

if(v==multime[i])
break;
v=tata[v];
}
if(v!=multime[i])
return false;
}
return true;
}
int main()
{
readData ();
cout<<"p=";cin>>p;
for(int i=1;i<=p;i++)
{
cout<<"set["<<i<<"]=";
cin>>multime[i];
}
bool esteInclusa=isIncluded();
if(esteInclusa)
cout<<"It is included."<<endl;
else
cout<<"NOT included."<<endl;

return 0;
}
1. A company has n (n≤100) employees, among
whom one is the company's director. The
company's organizational chart allows for the
creation of a hierarchical structure. There are
subordinate relationships between pairs of
company employees. Knowing that the company's
data is stored in the file company.in as follows: on
the first line, the number n of company employees;
on the second line, the roles of the n employees
expressed as strings of up to 30 characters
(lowercase letters and the underscore character);
and subsequently, on different lines, pairs of
strings x, y, with the meaning that y is subordinate
to x. Determine:
a. Employees without subordinates.
b. How many levels of hierarchy the company has.
c. Direct subordinates of the director.
d. All subordinates of x (direct or indirect).
e. If x and y have the same direct hierarchical
superior.
f. All superiors of x (direct or indirect).
g. All employees at hierarchy level k.

h. Which of the employees x or y has more
subordinates (direct or indirect).
i. If x is the superior (direct or indirect) of both a and
b.
Implementation:
#include <iostream>
#include <fstream>
#include <cstring>
using namespace std;
int n, tata[101];
char nume[31][101];
///———————————
int Search(char x[31])
{
for(int i = 1; i <= n; i++)
if(stricmp(nume[i], x) == 0)
return i;
return 0;
}
///———————————
void readData()
{
ifstream file("company.in");

char x[31], y[31];
file >> n;
for(int i = 1; i <= n; i++)
{
file >> x;
strcpy(nume[i], x);
}
while(file >> x >> y)
{
int p1 = Search(x);
int p2 = Search(y);
tata[p2] = p1;
}
file.close();
}
///———————————
void employeesWithoutSubordinates()
{
cout << "Employees without subordinates:" << endl;
for(int i = 1; i <= n; i++)
{
bool hasSubordinates = false;
for(int j = 1; j <= n; j++)

{
if(tata[j] == i)
{
hasSubordinates = true;
break;
}
}
if(!hasSubordinates)
cout << nume[i] << " ";
}
cout << endl;
}
///———————————
int hierarchyLevels()
{
int maxLevel = 0;
for(int i = 1; i <= n; i++)
{
int currentLevel = 0;
int employee = i;
while(employee != 0)
{
currentLevel++;

employee = tata[employee];
}
if(currentLevel > maxLevel)
maxLevel = currentLevel;
}
return maxLevel;
}
///———————————
void displayDirectorSubordinates()
{
cout << "Direct subordinates of the director are: " <<
endl;
int root = -1;
for(int i = 1; i <= n; i++)
if(tata[i] == 0)
{
root = i;
break;
}
for(int i = 1; i <= n; i++)
if(tata[i] == root)
cout << nume[i] << " ";
cout << endl;

}
///———————————
void displaySubDirectIndirect(char x[31], bool &condition)
{
if(Search(x) == 0)
cout << "Person not found in the hierarchy, so ";
else
{
for(int i = 1; i <= n; i++)
{
if(tata[i] == Search(x))
{
cout << nume[i] << " ";
displaySubDirectIndirect(nume[i], condition); // Recursive
call to display direct subordinates of employee nume[i]
condition = true;
}
}
}
}
///———————————
bool haveSameHierarchicalSuperior(char x[31], char
y[31])

{
int superiorX = tata[Search(x)];
int superiorY = tata[Search(y)];
return superiorX != 0 && superiorX == superiorY;
}
///———————————
void displaySuperiors(char x[31])
{
cout << "Superiors of " << x << " are: ";
int employee = Search(x);
if(tata[employee] == 0)
cout << "The root has no superiors." << endl;
else
{
while(tata[employee] != 0)
{
cout << nume[tata[employee]] << " ";
employee = tata[employee];
}
}
cout << endl;
}
///———————————

void employeesAtLevel(int k)
{
cout << "Employees at hierarchy level " << k << " are: ";
bool found = false;
for(int i = 1; i <= n; i++)
{
int currentLevel = 0;
int employee = i;
// Calculate the level of the employee by tracing superiors
to the root
while(employee != 0)
{
currentLevel++;
employee = tata[employee];
}
if(currentLevel == k)
{
cout << nume[i] << " ";
found = true;
}
}
if(!found)
cout << "There are no employees at level " << k;

cout << endl;
}
///———————————
int numberOfSubordinates(char x[31])
{
int count = 0;
for(int i = 1; i <= n; i++)
{
if(tata[i] == Search(x))
{
count++;
count += numberOfSubordinates(nume[i]);
}
}
return count;
}
///———————————
bool hasMoreSubordinates(char x[31], char y[31])
{
int numSubordinatesX = 0;
int numSubordinatesY = 0;
// Count direct subordinates of x
for(int i = 1; i <= n; i++)

{
if(tata[i] == Search(x))
{
numSubordinatesX++;
// Add indirect subordinates of x
numSubordinatesX += numberOfSubordinates(nume[i]);
}
}
// Count direct subordinates of y
for(int i = 1; i <= n; i++)
{
if(tata[i] == Search(y))
{
numSubordinatesY++;
// Add indirect subordinates of y
numSubordinatesY += numberOfSubordinates(nume[i]);
}
}
// Check which employee has more subordinates
return numSubordinatesX > numSubordinatesY;
}
///———————————
bool isSuperior(char x[31], char a[31], char b[31])

{
int superiorA = tata[Search(a)];
int superiorB = tata[Search(b)];
// Base case: reached the root
if(superiorA == 0 && superiorB == 0)
return false;
// Check if x is a direct superior of either a or b
if(stricmp(x, a) == 0 || stricmp(x, b) == 0)
return true;
// Check if x is an indirect superior of both a and b
return isSuperior(x, nume[superiorA], nume[superiorB]);
}
int main()
{
readData();
///a) Employees without subordinates.
employeesWithoutSubordinates();
///b) Number of hierarchy levels in the company.
int numLevels = hierarchyLevels();
cout << "Number of hierarchy levels in the company: " <<
numLevels << endl;
///c) Direct subordinates of the director.
displayDirectorSubordinates();

///d) All subordinates of x (direct or indirect).
char x[31];
bool condition = false;
cout << "An employee: ";
cin >> x;
cout << "Subordinates of " << x << " are: ";
displaySubDirectIndirect(x, condition);
if(condition == false)
cout << "There are no subordinates." << endl;
cout << endl;
///e) Whether x and y have the same direct hierarchical
superior.
char y[31];
cout << "Two names: ";
cin >> x >> y;
if(haveSameHierarchicalSuperior(x, y))
cout << "Employees " << x << " and " << y << " have
the same direct hierarchical superior." << endl;
else
cout << "Employees " << x << " and " << y << " do not
have the same direct hierarchical superior." << endl;
///f) All superiors of x.
cout << "An employee: ";

cin >> x;
displaySuperiors(x);
///g) All employees at hierarchy level k.
int k;
cout << "k=";
cin >> k;
employeesAtLevel(k);
/// h) Which of the employees x or y has more
subordinates (direct or indirect).
cout << "x=";
cin >> x;
cout << "y=";
cin >> y;
if(hasMoreSubordinates(x, y))
cout << x << " has more subordinates than " << y <<
endl;
else if (hasMoreSubordinates(y, x))
cout << y << " has more subordinates than " << x <<
endl;
else
cout << x << " and " << y << " have the same number
of subordinates" << endl;

/// i) Whether x is a superior (direct or indirect) to both a
and b.
char a[31], b[31];
cout << "x=";
cin >> x;
cout << "a=";
cin >> a;
cout << "b=";
cin >> b;
if(isSuperior(x, a, b))
cout << "Yes, " << x << " is a superior to both." << endl;
else
cout << "Not a superior." << endl;
return 0;
}
1. My computer. Write a program that represents
the organization of information in a computer. The
directory names, file names, and hierarchical
relationships between two informational units x-y
are known, with the meaning that y is included in
x. Perform the following operations:
a. Determine in which directory a file x is located.

b. Determine if there are multiple files with the name
x.
c. Copy the file x from folder a to folder b.
d. Move the file x from folder a to folder b.
e. Delete the file x from folder a.
f. Display the entire content of folder a in levels.
Implementation:
#include <iostream>
#include <fstream>
#include <cstring>
using namespace std;
int n,tata[101];
char fisiere[101][101];
///———————————
int search(char x[31],char matrice[101][101],int dim)
{
for(int i=1; i<=dim; i++)
if(stricmp(matrice[i],x)==0)
return i;
return 0;
}
///———————————
void readData()

{
ifstream f("files.in");//name of directories and files
ifstream g("relations.in");//relations between directories
and files
char x[31],y[31];
int i=1;
while(f>>x)
{
strcpy(fisiere[i],x);
i++;
}
n=i;
while(g>>x>>y)
{
int p1=search(x,fisiere,n);
int p2=search(y,fisiere,n);
tata[p2]=p1;
}
f.close();
g.close();
}
///———————————
int GasesteDirectorul(const char *numeFisier)

{
if(stricmp(numeFisier,"MyComputer")==0)
{
cout<<"Root: MyComputer"<<endl;
return 0;
}
for(int i=1; i<=n; i++)
{
if(stricmp(fisiere[i],numeFisier)==0)
{
int tataIndex=tata[i];
while(tataIndex!=0)
{
cout<<fisiere[tataIndex] << " / ";
tataIndex=tata[tataIndex];
}
cout<<endl;
return tata[i];
}
}
return -1; // file not found
}
int NumarFisiere(const char *numeFisier)

{
int count=0;
for(int i=1; i<=n; i++)
{
if(stricmp(fisiere[i],numeFisier)==0)
count++;
}
return count;
}
void CopiazaFisier(char numeFisier[31],char
folderSursa[31],char folderDestinatie[31],int &n)
{
int indiceFisier=Cautare(numeFisier, fisiere, n);
int indiceFolderSursa=Cautare(folderSursa, fisiere, n);
int indiceFolderDestinatie=Cautare(folderDestinatie,
fisiere, n);
if(indiceFisier==0)
cout<<"Fisierul "<<numeFisier<<" doesnt exist!"<<endl;
if(indiceFolderSursa==0)
cout<<"Folderul "<<folderSursa<<" doesnt exist!"
<<endl;
if(indiceFolderDestinatie==0)

cout<<"Folderul "<<folderDestinatie<<" doesnt exist!"
<<endl;
if(tata[indiceFisier]!=indiceFolderSursa)
cout<<"Fisierul "<<numeFisier<<" is not in the folder "
<<folderSursa<<endl;
if(tata[indiceFolderDestinatie]!=indiceFolderSursa)
cout<<"Folderul "<<folderDestinatie<<" is not the
subfolder of "<<folderSursa<<endl;
// copy the file
strcpy(fisiere[n],numeFisier);
tata[n]=indiceFolderDestinatie;
n++;
cout<<"Fisierul "<<numeFisier<<" has been copied from
"<<folderSursa<<" to "<<folderDestinatie<<endl;
}
void StergeFisier(char numeFisier[31],char
numeFolder[31])
{
int indiceFisier=Cautare(numeFisier,fisiere,n);
int indiceFolder=Cautare(numeFolder,fisiere,n);
if(indiceFisier==0)
cout<<"Fisierul "<<numeFisier<<" does not exist!"
<<endl;
if(indiceFolder==0)

cout<<"Folderul "<<numeFolder<<" does not exist!"
<<endl;
if (tata[indiceFisier] != indiceFolder)
cout<<"Fisierul "<<numeFisier<<" is not in folder "
<<numeFolder<<endl;
// delete the file
tata[indiceFisier]=-1;
for(int i=indiceFisier; i<n-1; i++)
tata[i]=tata[i+1];
n—;
cout<<"Fisierul "<<numeFisier<<" has been deleted from
"<<numeFolder<<endl;
}
void AfisarePeNivele(int indiceFolder,int nivel)
{
for(int i=1; i<=n; i++)
{
if(tata[i]==indiceFolder)
{
for(int j=0; j<nivel; j++)
cout<<"  ";// indendation
cout<<fisiere[i]<<endl;
// check if is a folder or file

if(stricmp(fisiere[i], "")!=0)
AfisarePeNivele(i,nivel+1);
}
}
}
int main()
{
readData();
///a)
char x[31];
cout<<"x=";cin>>x;
int directorIndex=GasesteDirectorul(x);
if(directorIndex!=-1 && stricmp(x,"MyComputer")!=0)
cout<<"File is located in: "<<fisiere[directorIndex]
<<endl;
else
cout<<"File not found!"<<endl;
///b)
cout<<"x=";cin>>x;
int numarAparitii=NumarFisiere(x);
if(numarAparitii>1)
cout<<"There are many files "<<x<<endl;
else

cout<<"Does not exist."<<endl;
///c)
cout<<"Which file you want to copy? ";cin>>x;
char a[31],b[31];
cout<<"From which folder? ";cin>>a;
cout<<"To which folder? ";cin>>b;
CopiazaFisier(x,a,b,n);
///d)
cout<<"While folder you want to delete? ";cin>>x;
cout<<"From which folder? ";cin>>a;
StergeFisier(x,a);
///e)
cout<<"Which folder? ";cin>>a;
int indice=Cautare(a,fisiere,n);
AfisarePeNivele(indice,0);
return 0;
}
1. Factory. In a factory, a finished product is
obtained from n-1 components (raw materials or
intermediate products). Raw materials are not
obtained from other intermediate products but are
purchased at any price. All relationships x-y are
known, where x is obtained from y, along with the

costs of raw materials. The cost of a product
(intermediate or final) is obtained from the sum of
the squares of the costs of the products from which
it is obtained. The following are known: the number
n (n≤100), the relationships x-y with the above
meaning, and the costs for raw materials in
ascending order of the order numbers. Determine
the value of the finished product.
Example:
n=11
1 2
1 3
1 4
2 5
2 6
3 7
4 8
4 9
6 11
7 10
the cost for 5 is 2

the cost for 8 is 2
the cost for 9 is 1
the cost for 10 is 1
the cost for 11 is 1
A cost equal to the value of 50 is obtained.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int n,tata[101];
int cost[101];
///———————————
void readData()
{
ifstream f("factory.in");
f>>n;
int x,y;
while(f>>x>>y)
tata[y]=x;
//Set the costs
cost[5]=2;

cost[8]=2;
cost[9]=1;
cost[10]=1;
cost[11]=1;
f.close();
}
///———————————
int calculeazaCost(int nod)
{
if (cost[nod] != 0)
return cost[nod];
int sum=0;
bool isMateriePrima=true;
for(int i=1; i<=n; i++)
{
if(tata[i]==nod)
{
int costProdus=calculeazaCost(i);
sum+=costProdus*costProdus;
isMateriePrima=false;
}
}
if(isMateriePrima)

return cost[nod];
cost[nod]=sum;
return cost[nod];
}
///———————————
void afiTati()
{
cout<<"Parent’s array: "<<endl;
for(int i=1;i<=n;i++)
cout<<tata[i]<<" ";
cout<<endl;
}
int main()
{
readData();
afiTati();
int valoareProdusFinit=calculeazaCost(1);
cout<<"Total cost is: "<<valoareProdusFinit<<endl;
return 0;
}
1. A distribution company of cosmetic products is
hierarchically structured, where there are agents

who deliver products to subordinate
intermediaries. Each agent is remunerated based
on the number of agents they directly or indirectly
subordinate. The number n (n≤100) of agents and
the relationships of subordination between agents
are known. Knowing that an agent contributes 10
points to their direct hierarchical superior,
determine:
a) Which agents do not receive points from
subordinates.
b) How many points each agent receives.
c) Who is the subordinate of x that brings them the
most points.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int n,tata[101];
int punctaj[101];
///———————————
void readData()
{
ifstream f("data.in");

f>>n;
int x,y;
while(f>>x>>y)
tata[y]=x;
f.close();
}
///———————————
void afiTati()
{
cout<<"Parent’s array: "<<endl;
for(int i=1;i<=n;i++)
cout<<tata[i]<<" ";
cout<<endl;
}
///———————————
void calculeazaPunctaje(int agent)
{
int punctajAgent=0;
bool areSubordonati=false;
for(int i=1; i<=n; i++)
{
if(tata[i]==agent)
{

calculeazaPunctaje(i);
punctajAgent+=punctaj[i];
areSubordonati=true;
}
}
punctaj[agent]=punctajAgent+10;
// does not get any points
if(!areSubordonati)
cout<<agent<<" ";
}
///———————————
void afisareAgentiFaraPuncte()
{
cout<<"Agents who don’t get any points: ";
calculeazaPunctaje(0);// call the function
cout<<endl;
}
///———————————
void afisarePunctajeAgenti()
{
cout<<"Points received by every agent: "<<endl;
for(int i=1; i<=n; i++)

cout<<"Agent "<<i<<": "<<punctaj[i]<<" points."
<<endl;
}
///———————————
int subordonatCuCeleMaiMultePuncte(int agent)
{
int subordonatMaxim=0;
int maxPuncte=0;
for(int i=1; i<=n; i++)
{
if(tata[i]==agent && punctaj[i]>maxPuncte)
{
maxPuncte=punctaj[i];
subordonatMaxim=i;
}
}
return subordonatMaxim;
}
int main()
{
readData();
afiTati();
///a)

afisareAgentiFaraPuncte();
///b)
afisarePunctajeAgenti();
///c)
int x;
cout<<"x=";cin>>x;
int
subordonatMaxim=subordonatCuCeleMaiMultePuncte(x);
if(subordonatMaxim==0)
cout<<x<<" does not have any subordinates."<<endl;
else
cout<<"Subordinate of "<<x<<" who gets more points is
"<<subordonatMaxim<<endl;
return 0;
}

17.3  BINARY TREES. BINARY
SEARCH TREES.
1. Create a binary tree that stores integers. Perform
the following operations:
a. Inorder traversal
b. Preorder traversal
c. Postorder traversal
d. Display prime values
e. Sum of values at level k
f. Replace minimum values with maximum values
and vice versa
g. Display keys of nodes with a single successor
h. Display all left descendants
i. Display the k-th element during preorder traversal
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int n, tata[101], st[101], dr[101];
void readInput()
{
ifstream file("input.txt");
file >> n;

int x, y;
while (file >> x >> y)
tata[y] = x;
for (int i = 1; i <= n; i++)
{
if (tata[i] != 0)
{
if (st[tata[i]] == 0)
st[tata[i]] = i;
else
dr[tata[i]] = i;
}
}
file.close();
}
int getRoot()
{
int v[101] = {0};
for (int i = 1; i <= n; i++)
{
if (st[i] != 0)
v[st[i]] = 1;
if (dr[i] != 0)

v[dr[i]] = 1;
}
for (int i = 1; i <= n; i++)
if (v[i] == 0)
return i;
return 0;
}
void inorderTraversal(int x)
{
if (x != 0)
{
inorderTraversal(st[x]);
cout << x << " ";
inorderTraversal(dr[x]);
}
}
void preorderTraversal(int x)
{
if (x != 0)
{
cout << x << " ";
preorderTraversal(st[x]);
preorderTraversal(dr[x]);

}
}
void postorderTraversal(int x)
{
if (x != 0)
{
postorderTraversal(st[x]);
postorderTraversal(dr[x]);
cout << x << " ";
}
}
bool isPrime(int number)
{
if (number < 2)
return false;
for (int i = 2; i * i <= number; i++)
if (number % i == 0)
return false;
return true;
}
void displayPrimes(int x)
{
if (x != 0)

{
displayPrimes(st[x]);
if (isPrime(x))
cout << x << " ";
displayPrimes(dr[x]);
}
}
int sumAtLevel(int x, int level)
{
if (x == 0)
return 0;
if (level == 0)
return x;
return sumAtLevel(st[x], level - 1) + sumAtLevel(dr[x],
level - 1);
}
void findMinMax(int x, int &minVal, int &maxVal)
{
if (x != 0)
{
minVal = min(minVal, x);
maxVal = max(maxVal, x);
findMinMax(st[x], minVal, maxVal);

findMinMax(dr[x], minVal, maxVal);
}
}
void replaceMinMax(int x, int minVal, int maxVal)
{
if (x != 0)
{
if (st[x] == minVal)
st[x] = maxVal;
else if (st[x] == maxVal)
st[x] = minVal;
if (dr[x] == minVal)
dr[x] = maxVal;
else if (dr[x] == maxVal)
dr[x] = minVal;
replaceMinMax(st[x], minVal, maxVal);
replaceMinMax(dr[x], minVal, maxVal);
}
}
void displaySingleSuccessors(int x)
{
if (x != 0)
{

int numSuccessors = 0;
if (st[x] != 0)
numSuccessors++;
if (dr[x] != 0)
numSuccessors++;
if (numSuccessors == 1)
cout << x << " ";
displaySingleSuccessors(st[x]);
displaySingleSuccessors(dr[x]);
}
}
void displayLeftDescendants(int x)
{
if (x != 0)
{
if (st[x] != 0)
cout << st[x] << " ";
displayLeftDescendants(st[x]);
displayLeftDescendants(dr[x]);
}
}
int counter;
void displayKElementPreorder(int x, int k)

{
if (x != 0)
{
counter++;
if (counter == k)
cout << "The " << k << "-th element in preorder is: " <<
x << endl;
displayKElementPreorder(st[x], k);
displayKElementPreorder(dr[x], k);
}
}
int main()
{
readInput();
int root = getRoot();
cout << "The root of the tree is: " << root << endl;
cout << "Inorder traversal: ";
inorderTraversal(root);
cout << endl;
cout << "Preorder traversal: ";
preorderTraversal(root);
cout << endl;
cout << "Postorder traversal: ";

postorderTraversal(root);
cout << endl;
cout << "Prime values in the tree: ";
displayPrimes(root);
cout << endl;
int level;
cout << "Enter level (k): ";
cin >> level;
int sum = sumAtLevel(root, level);
cout << "Sum of values at level " << level << ": " <<
sum << endl;
int minValue = 9999, maxValue = 0;
findMinMax(root, minValue, maxValue);
cout << "Initial minimum value: " << minValue << endl;
cout << "Initial maximum value: " << maxValue << endl;
replaceMinMax(root, minValue, maxValue);
cout << "Nodes with a single successor: ";
displaySingleSuccessors(root);
cout << endl;
cout << "Left descendants are: ";
displayLeftDescendants(root);
cout << endl;
cout << "Enter k: ";

cin >> level;
counter = 0;
displayKElementPreorder(root, level);
return 0;
}
1. Create a dynamically allocated binary tree that
stores integers inputted from the keyboard.
Starting from the previously created tree, generate
the left and right vectors a and b, respectively,
where ai stores the order number of the left
subordinate node to node i, and bi stores the order
number of the right subordinate node.
Implementation:
#include <iostream>
using namespace std;
int a[101],b[101];
struct node
{
int info;
nod *st,*dr;
};
void create(node *&r, int val)

{
if(r!=NULL)
{
if(val<r->info)
Creare(r->st,val);
else if(val>r->info)
Creare(r->dr,val);
else
cout<<"Value exists!\n";
}
else
{
r=new node;
r->info=val;
r->st=NULL;
r->dr=NULL;
}
}
void display(node *r)
{
if(r!=NULL)
{
cout<<r->info<<" ";

display(r->st);
display(r->dr);
}
}
void createVectors(node *r, int a[], int b[], int &dim_a, int
&dim_b)
{
if (r!=NULL)
{
if (r->st!=NULL)
a[dim_a++]=r->st->info;  // add value from left
if (r->dr!=NULL)
b[dim_b++]=r->dr->info;  // add value from right
createVectors(r->st,a,b,dim_a,dim_b);  // left tree
createVectors(r->dr,a,b,dim_a,dim_b);  // right tree
}
}
int main()
{
nod *R=NULL;
int val;
int dim_a=0,dim_b=0;

cout<<"Input values (to end loop, input a negative
value):"<<endl;
while(true)
{
cin>>val;
if(val<0)
break;
create(R,val);
}
cout<<"Binary tree generated: ";
display(R);
cout<<endl;
createVectors(R, a, b, dim_a,dim_b);
cout<<"Left array: ";
for(int i=0; i<dim_a; i++)
cout<<a[i]<<" ";
cout<<endl;
cout<<"Right array: ";
for(int i=0; i<dim_b; i++)
cout<<b[i]<<" ";
cout<<endl;
return 0;
}

1. Consider a binary tree for which the following
information is known: the number n (n≤100) of
vertices numbered from 1 to n, and the edges. The
tree is stored using the parent vector. Determine:
a. The root of the binary tree.
b. The terminal nodes (leaves).
c. Nodes that have only one direct subordinate.
d. Nodes that have only one direct or indirect
subordinate.
e. Pairs of nodes that have the same ancestor.
f. The children of node x.
g. The siblings of node x.
h. Whether x is a descendant of y.
i. The “grandparent” of node x.
j. The “cousins” of node x.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int n, tata[101];
void readInput()
{
ifstream file("input.txt");
file >> n;

int x, y;
while (file >> x >> y)
tata[y] = x;
file.close();
}
void displayParents()
{
cout << "Parent vector: ";
for (int i = 1; i <= n; i++)
cout << tata[i] << " ";
cout << endl;
}
int Root()
{
for (int i = 1; i <= n; i++)
if (tata[i] == 0)
return i;
}
void displayLeaves()
{
cout << "Terminal nodes (leaves): ";
for (int i = 1; i <= n; i++)
{

bool isLeaf = true;
for (int j = 1; j <= n; j++)
{
if (tata[j] == i)
{
isLeaf = false;
break;
}
}
if (isLeaf == true)
cout << i << " ";
}
cout << endl;
}
void displayNodesWithOneDirectSubordinate()
{
cout<<"Nodes with only one direct subordinate: ";
for (int i = 1; i <= n; i++)
{
int count = 0;
for (int j = 1; j <= n; j++)
{
if (tata[j] == i)

count++;
}
if (count == 1)
cout << i << " ";
}
cout << endl;
}
void displayNodesWithOneDirectOrIndirectSubordinate()
{
cout << "Nodes with only one direct or indirect
subordinate: ";
for (int i = 1; i <= n; i++)
{
int count = 0;
for (int j = 1; j <= n; j++)
{
int current = j;
while (current != 0)
{
if (tata[current] == i)
{
count++;
break;

}
current = tata[current];
}
}
if (count == 1)
cout << i << " ";
}
cout << endl;
}
void displayPairsOfNodesWithSameAncestor()
{
cout << "Pairs of nodes with the same ancestor: ";
for (int i = 1; i <= n; i++)
{
int parentI = tata[i];
for (int j = i + 1; j <= n; j++)
{
if (tata[j] == parentI)
cout << "(" << i << ", " << j << ") ";
}
}
cout << endl;
}

void displayChildren(int x)
{
cout << "Children of node " << x << " are: ";
for (int i = 1; i <= n; i++)
if (tata[i] == x)
cout << i << " ";
cout << endl;
}
void displaySibling(int x)
{
int parentX = tata[x];
bool hasSibling = false;
cout << "Sibling of node " << x << " is: ";
for (int i = 1; i <= n; i++)
{
if (tata[i] == parentX && i != x)
{
cout << i << endl;
hasSibling = true;
}
}
if (hasSibling == false)
cout << "None" << endl;

}
bool isDescendant(int x, int y)
{
while (x != 0)
{
if (tata[x] == y)
return true;
x = tata[x];
}
return false;
}
int findGrandparent(int x)
{
int parentX = tata[x];
if (parentX != 0)
{
int grandparentX = tata[parentX];
if (grandparentX != 0)
return grandparentX;
}
return -1;
}
void displayCousins(int x)

{
int parentX = tata[x];
int parentGrandparent = tata[parentX];
bool hasCousins = false;
cout << "Cousins of node " << x << " are: ";
if (parentX == 0)
cout << "Node " << x << " is the root and has no
cousins." << endl;
for (int i = 1; i <= n; i++)
if (tata[i] == parentGrandparent && i != parentX)
{
cout << i << " ";
hasCousins = true;
}
if (hasCousins == false)
cout << x << " has no cousins." << endl;
cout << endl;
}
int main()
{
readInput();
displayParents();
int R = Root();

///a)  root of the binary tree.
cout << "The root of the tree is: " << R << endl;
///b)  terminal nodes (leaves).
displayLeaves();
///c)  nodes that have only one direct subordinate.
displayNodesWithOneDirectSubordinate();
///d)  nodes that have only one direct or indirect
subordinate.
displayNodesWithOneDirectOrIndirectSubordinate();
///e)  pairs of nodes that have the same ancestor.
displayPairsOfNodesWithSameAncestor();
///f)  children of x.
int x;
cout << "Enter x: ";
cin >> x;
displayChildren(x);
///g)  sibling of x.
cout << "Enter x: ";
cin >> x;
displaySibling(x);
///h)  whether x is a descendant of y.
int y;
cout << "Enter x: ";

cin >> x;
cout << "Enter y: ";
cin >> y;
bool descendant = isDescendant(x, y);
if (descendant == true)
cout << x << " is a descendant of " << y << endl;
else
cout << x << " is not a descendant of " << y << endl;
///i)  "grandparent" of x.
cout << "Enter x: ";
cin >> x;
if (findGrandparent(x) != -1)
cout << "The grandparent of " << x << " is " <<
findGrandparent(x) << endl;
else
cout << x << " has no grandparent." << endl;
///j)  "cousins" of x.
cout << "Enter x: ";
cin >> x;
displayCousins(x);
return 0;
}

1. Solve the same requirements as in the previous
problem, storing the tree using two vectors st and
dr, where sti stores the order number of the left
subordinate node to node i, and dri stores the
order number of the right subordinate node.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int n, st[101], dr[101];
void readInput()
{
ifstream file("input.txt");
file >> n;
for (int i = 1; i <= n; i++)
file >> st[i];
for (int i = 1; i <= n; i++)
file >> dr[i];
file.close();
}
int Root()
{
int v[101] = {0};

for (int i = 1; i <= n; i++)
{
if (st[i] != 0)
v[st[i]] = 1;
if (dr[i] != 0)
v[dr[i]] = 1;
}
for (int i = 1; i <= n; i++)
if (v[i] == 0)
return i;
return 0;
}
void displayLeaves()
{
cout << "Terminal nodes (leaves) are: ";
for (int i = 1; i <= n; i++)
{
if (st[i] == 0 && dr[i] == 0)
cout << i << " ";
}
cout << endl;
}
void displayNodesWithOneDirectSubordinate()

{
cout << "Nodes with only one direct subordinate are: ";
for (int i = 1; i <= n; i++)
{
if ((st[i] != 0 && dr[i] == 0) || (st[i] == 0 && dr[i] !=
0))
cout << i << " ";
}
cout << endl;
}
bool hasOneDirectOrIndirectSubordinate(int node, int st[],
int dr[])
{
int count = 0;
if (st[node] != 0)
{
count++;
if (!hasOneDirectOrIndirectSubordinate(st[node], st, dr))
return false;
}
if (dr[node] != 0)
{
count++;

if (!hasOneDirectOrIndirectSubordinate(dr[node], st, dr))
return false;
}
return count == 0 || count == 1;
}
void displayNodesWithOneDirectOrIndirectSubordinate()
{
cout << "Nodes with one direct or indirect subordinate
are: ";
for (int i = 1; i <= n; i++)
if (hasOneDirectOrIndirectSubordinate(i, st, dr))
cout << i << " ";
cout << endl;
}
void displayPairsNodesWithSameParent()
{
cout << "Pairs of nodes with the same parent are: ";
for (int i = 1; i <= n; i++)
{
if (st[i] != 0 || dr[i] != 0)
{
for (int j = i + 1; j <= n; j++)
{

if ((st[i] == st[j] || st[i] == dr[j]) && (st[i] != 0 || dr[j]
!= 0))
cout << "(" << i << ", " << j << ") ";
if ((dr[i] == st[j] || dr[i] == dr[j]) && (dr[i] != 0 || dr[j]
!= 0))
cout << "(" << i << ", " << j << ") ";
}
}
}
cout << endl;
}
void displayChildren(int x)
{
cout << "Children of node " << x << " are: ";
bool hasChildren = false;
for (int i = 1; i <= n; i++)
{
if (i == x)
{
if (st[i] != 0)
{
cout << st[i] << " ";
hasChildren = true;

}
if (dr[i] != 0)
{
cout << dr[i] << " ";
hasChildren = true;
}
}
}
if (!hasChildren)
cout << "Node " << x << " has no children.";
cout << endl;
}
void displaySibling(int x)
{
int parent[101] = {0};
// Build the parent vector
for (int i = 1; i <= n; i++)
{
if (st[i] != 0)
parent[st[i]] = i;
if (dr[i] != 0)
parent[dr[i]] = i;
}

// Find the sibling of node x
int par = parent[x];
int sibling = -1;
if (par != 0)
{
if (st[par] == x)
{
if (dr[par] != 0)
sibling = dr[par];
}
else if (dr[par] == x)
{
if (st[par] != 0)
sibling = st[par];
}
}
// Display the sibling of node x
if (sibling != -1)
cout << "The sibling of node " << x << " is: " << sibling
<< endl;
else
{
if (par != 0)

cout << "Node " << x << " has no sibling." << endl;
else
cout << "Node " << x << " is the root of the tree." <<
endl;
}
}
bool isDescendant(int x, int y)
{
// Base cases:
if (x == 0 || y == 0)
return false; // Null node cannot be a descendant
if (x == y)
return true; // Node x is identical to node y
// Check if x is a descendant of the left or right subtree of y
if (isDescendant(x, st[y]) || isDescendant(x, dr[y]))
return true;
return false; // Node x is not a descendant of node y
}
int findGrandparent(int x)
{
int parent[101] = {0};
// Build the parent vector
for (int i = 1; i <= n; i++)

{
if (st[i] != 0)
parent[st[i]] = i;
if (dr[i] != 0)
parent[dr[i]] = i;
}
int par = parent[x];
if (par != 0)
{
int grandparent = parent[par];
if (grandparent != 0)
return grandparent;
}
return -1; // Return -1 if node x has no grandparent
}
void displayCousins(int x)
{
int parent[101] = {0};
// Build the parent vector
for (int i = 1; i <= n; i++)
{
if (st[i] != 0)
parent[st[i]] = i;

if (dr[i] != 0)
parent[dr[i]] = i;
}
int parent_x = parent[x];
int grandparent = parent[parent_x];
cout << "Cousins of node " << x << " are: ";
bool hasCousins = false;
for (int i = 1; i <= n; i++)
{
if (parent[parent[i]] == grandparent && i != parent_x
&& i != x)
{
cout << i << " ";
hasCousins = true;
}
}
if (!hasCousins)
cout << "Node " << x << " has no cousins.";
cout << endl;
}
int main()
{
readInput();

int root = Root();
///a) Root of the binary tree.
cout << "Root of the tree is: " << root << endl;
///b) Terminal nodes (leaves).
displayLeaves();
///c) Nodes with only one direct subordinate.
displayNodesWithOneDirectSubordinate();
///d) Nodes with only one direct or indirect subordinate.
displayNodesWithOneDirectOrIndirectSubordinate();
///e) Pairs of nodes with the same parent.
displayPairsNodesWithSameParent();
///f) Children of node x.
int x;
cout << "Enter x: ";
cin >> x;
displayChildren(x);
///g) Sibling of node x.
cout << "Enter x: ";
cin >> x;
displaySibling(x);
///h) Check if x is a descendant of y.
int y;
cout << "Enter x: ";

cin >> x;
cout << "Enter y: ";
cin >> y;
bool descendant = isDescendant(x, y);
if (descendant)
cout << x << " is a descendant of " << y << endl;
else
cout << x << " is not a descendant of " << y << endl;
///i) Grandparent of node x.
cout << "Enter x: ";
cin >> x;
int grandparent_x = findGrandparent(x);
if (grandparent_x != -1)
cout << "The grandparent of node " << x << " is " <<
grandparent_x << endl;
else
cout << "Node " << x << " has no grandparent." <<
endl;
///j) Cousins of node x.
cout << "Enter x: ";
cin >> x;
displayCousins(x);
return 0;

}
1. Solve the same requirements as in the previous
problem by dynamically storing the tree.
Solution: Use the implementation from problem
998 to dynamically store the tree. Create the same
functions as in problems 999 and 1000 with the
necessary modifications.
1. In the file tree.in, natural numbers representing the
parent vector associated with a binary tree are
stored. Represent the tree using vectors a and b,
where ai stores the order number of the node
subordinate to the left of node i, and bi stores the
order number of the node subordinate to the right.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int n,a[101],b[101];
int tata[101];
void read()
{

ifstream f("tree.in");
f>>n;
for(int i=1;i<=n;i++)
f>>tata[i];
f.close();
}
void createVectors()
{
for(int i=1;i<=n;i++)
{
int t=tata[i];  // Parent of node i
if(t!=0)
{
if(a[t]==0)
a[t]=i;// node i is left son of parent t
else if(b[t]==0 && a[i]!=i)
b[t]=i;  // node i is right son of parent t
}
}
}
int main()
{
read();

cout<<"Parent array: ";
for(int i=1;i<=n;i++)
cout<<tata[i]<<" ";
cout<<endl;
createVectors ();
cout<<"Left array: ";
for(int i=1;i<=n;i++)
cout<<a[i]<<" ";
cout<<endl;
cout<<"Right array: ";
for(int i=1;i<=n;i++)
cout<<b[i]<<" ";
cout<<endl;
return 0;
}
1. Read a non-zero natural number n (n≤100).
Generate a binary tree in which values from 1 to n
will be loaded in order. Transition to a new level will
occur after completing the previous level. The root
is 1.
a. The tree will be stored using left and right vectors.
b. The tree will be stored using the parent vector.
Display the obtained vectors.

Implementation:
#include <iostream>
using namespace std;
void createTree(int nod,int n,int stang[],int drept[])
{
if(nod>n)
return;
int fiuStang=2*nod;
int fiuDrept=2*nod+1;
stang[nod]=fiuStang<=n ? fiuStang : 0;
drept[nod]=fiuDrept<=n ? fiuDrept : 0;
construiesteArbore(fiuStang,n,stang,drept);
construiesteArbore(fiuDrept,n,stang,drept);
}
void createParentArray(int n,int tata[],int Radacina)
{
for(int i=2; i<=n; i++)
tata[i]=i/2;
}
int main()
{
int n,Radacina=1;

int stang[101],drept[101];
cout<<"n=";cin>>n;
//a)
createTree(Radacina,n,stang,drept);
cout<<"Left array: ";
for(int i=1; i<=n; i++)
cout<<stang[i]<<" ";
cout<<endl;
cout<<"Right array: ";
for(int i=1; i<=n; i++)
cout<<drept[i]<<" ";
cout<<endl;
//b)
int tata[101]={0};
tata[Radacina]=0;
createParentArray(n,tata,Radacina);
cout<<"Parent array: ";
for(int i=1;i<=n;i++)
cout<<tata[i]<<" ";
return 0;
}

1. The same problem as in the previous one, with the
difference that the binary tree will be dynamically
stored.
Implementation:
a. 
#include <iostream>
#include <vector>
using namespace std;
struct Node {
int value;
Node* left;
Node* right;
};
Node* createNode(int value) {
Node* node = new Node;
node->value = value;
node->left = nullptr;
node->right = nullptr;
return node;
}
Node* buildTree(int n) {

if (n <= 0)
return nullptr;
Node* root = createNode(1);
vector<Node*> queue;
queue.push_back(root);
for (int i = 2; i <= n; i++) {
Node* parent = queue.front();
queue.erase(queue.begin());
parent->left = createNode(i);
queue.push_back(parent->left);
if (i < n) {
parent->right = createNode(i + 1);
queue.push_back(parent->right);
i++; // Skip the next number since it has been assigned to
the right child
}
}
return root;
}
void releaseTree(Node* root) {
if (root == nullptr)
return;
releaseTree(root->left);

releaseTree(root->right);
delete root;
}
void generateVectors(Node* root, vector<int>& left,
vector<int>& right) {
if (root == nullptr)
return;
if (root->left != nullptr)
left.push_back(root->left->value);
if (root->right != nullptr)
right.push_back(root->right->value);
generateVectors(root->left, left, right);
generateVectors(root->right, left, right);
}
int main() {
int n;
cout << "n = ";
cin >> n;
Node* root = buildTree(n);
vector<int> leftVector, rightVector;
generateVectors(root, leftVector, rightVector);
cout << "Left vector: ";
for(int num : leftVector)

cout<<num<<" ";
cout<<endl;
cout << "Right vector: ";
for (int num : rightVector)
cout << num << " ";
cout << endl;
releaseTree(root);
return 0;
}
a. 
#include <iostream>
using namespace std;
struct Node
{
int val;
Node* stang;
Node* drept;
};
Node* createNode(int val)
{
Nod* nod=new Nod;
nod->valoare=val;

nod->stang=nullptr;
nod->drept=nullptr;
return nod;
}
Node* buildTree(int n)
{
if(n<=0)
return nullptr;
Node* radacina=creazaNod(1);
Node* nodCurent=radacina;
for(int i=2; i<=n; i++)
{
nodCurent->drept=crateNode(i);
nodCurent=nodCurent->drept;
}
return radacina;
}
void displayArray(Node* radacina)
{
if(radacina==nullptr)
return;
cout<<"Parent’s array is: ";
while(radacina != nullptr)

{
cout<<(radacina->valoare!=1 ? radacina->valoare/2 : 0)
<<" ";
radacina=radacina->drept;
}
cout<<endl;
}
void releaseTree(Node* radacina)
{
if (radacina==nullptr)
return;
elibereazaArbore(radacina->stang);
elibereazaArbore(radacina->drept);
delete radacina;
}
int main()
{
int n;
cout<<"n=";cin>>n;
///a)
Node* radacina=buildTree(n);
displayTree(radacina);
releaseTree(radacina);

return 0;
}
1. A binary tree with n nodes (n≤100), numbered
from 1 to n, is stored using the left and right
vectors. The values of n and the two vectors are
read from the file tree.in.
a. Convert the tree into a parent vector.
b. Generate the adjacency matrix.
c. Generate the associated adjacency lists.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int n,st[101],dr[101],tata[101],a[101][101];
struct Node
{
int val;
Node* next;
//constructor
Node(int v) : val(v), next(nullptr) {}
};
Nod* L[101];//adjacency lists

void read()
{
ifstream f("tree.in");
f>>n;
for(int i=1;i<=n;i++)
f>>st[i];
for(int i=1;i<=n;i++)
f>>dr[i];
}
void buildParents()
{
int i;
for(i=1;i<=n;i++)
{
if(st[i]!=0)
tata[st[i]]=i;
if(dr[i]!=0)
tata[dr[i]]=i;
}
}
void generateMatrix()
{
for(int i=1; i<=n; i++)

{
if(st[i]!=0)
a[i][st[i]]=a[st[i]][i]=1;
if(dr[i]!=0)
a[i][dr[i]]=a[dr[i]][i]=1;
}
}
void addNode(Node*& cap, int val)
{
Node* nod=new Node(val);
nod->next=cap;
cap=nod;
}
void generateLists()
{
for(int i=1; i<=n; i++)
{
if(st[i]!=0)
addNode(L[i],st[i]);
if(dr[i]!=0)
addNode(L[i],dr[i]);
}
}

void displayLists()
{
for(int i=1; i<=n; i++)
{
cout<<"Node "<<i<<": ";
Node* nod=L[i];
if(nod==nullptr)
cout<<"Empty list!";
else
{
while(nod!=nullptr)
{
cout<<nod->val<<" ";
nod=nod->next;
}
}
cout<<endl;
}
}
int main()
{
read();
///Parents array

buildParents();
cout<<"Parents array: ";
for(int i=1;i<=n;i++)
cout<<tata[i]<<" ";
cout<<endl;
///Adjacency matrix
generateMatrix();
cout<<"The adjacency matrix is: "<<endl;
for(int i=1;i<=n;i++)
{
for(int j=1;j<=n;j++)
cout<<a[i][j]<<" ";
cout<<endl;
}
cout<<endl;
///Adjacency lists:
generateLists();
cout<<"Adjacency Lists are: "<<endl;
displayLists();
return 0;
}

1. Write a program that creates a singly linked list
with the keys of a binary tree taken level by level
(first level 1, then level 2, etc.).
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
int n, tata[101];
struct Node
{
int info;
Node* next;
};
void readInput()
{
ifstream file("input.txt");
file >> n;
for (int i = 1; i <= n; i++)
file >> tata[i];
file.close();
}
void addNode(Node*& head, Node*& tail, int x)

{
Node* newNode = new Node;
newNode->info = x;
newNode->next = NULL;
if (head == NULL)
head = tail = newNode;
else
{
tail->next = newNode;
tail = newNode;
}
}
void displayList(Node* node)
{
while (node)
{
cout << node->info << " ";
node = node->next;
}
cout << endl;
}
void createListByLevels(Node*& head, Node*& tail)
{

Node* root = new Node;
root->info = 1;
root->next = NULL;
head = tail = root;
int currentLevel = 1;
int previousLevel = 1;
int index = 1;
while (index <= n)
{
for (int i = 0; i < currentLevel && index <= n; i++)
{
if (tata[index] != 0)
addNode(head, tail, index);
index++;
}
previousLevel = currentLevel;
currentLevel *= 2;
}
index = 1;
while (index <= n)
{
for (int i = 0; i < currentLevel && index <= n; i++)
{

if (tata[index] == previousLevel + i)
addNode(head, tail, index);
index++;
}
}
}
int main()
{
readInput();
Node* head = NULL;
Node* tail = NULL;
createListByLevels(head, tail);
displayList(head);
return 0;
}
1. Determine if two dynamically allocated trees are
equal.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
struct node

{
int info;
node *left, *right;
};
void create(node *&root, int value)
{
if (root != NULL)
{
if (value < root->info)
create(root->left, value);
else if (value > root->info)
create(root->right, value);
else
{
cout << "Value already exists!\n";
return;
}
}
else
{
root = new node;
root->info = value;
root->left = NULL;

root->right = NULL;
}
}
void display(node *root)
{
if (root != NULL)
{
cout << root->info << " ";
display(root->left);
display(root->right);
}
}
bool areEqual(node *tree1, node *tree2)
{
// Check base cases
if (tree1 == nullptr && tree2 == nullptr)
return true;
if (tree1 == nullptr || tree2 == nullptr)
return false;
// Check equality of values and left and right subtrees
return (tree1->info == tree2->info) &&
areEqual(tree1->left, tree2->left) &&
areEqual(tree1->right, tree2->right);

}
int main()
{
ifstream file("input.txt");
node *root1 = NULL, *root2 = NULL;
int value;
while (true)
{
file >> value;
if (value < 0)
break;
create(root1, value);
}
while (true)
{
file >> value;
if (value < 0)
break;
create(root2, value);
}
cout << "Binary tree 1 created: ";
display(root1);
cout << endl;

cout << "Binary tree 2 created: ";
display(root2);
cout << endl;
cout << "Are the two trees equal? " << (areEqual(root1,
root2) ? "Yes" : "No") << endl;
return 0;
}
1. Determine whether two dynamically allocated
trees store the same values but in a different order.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
struct node
{
int info;
node *left, *right;
};
void Create(node *&root, int value)
{
if (root != NULL)
{

if (value < root->info)
Create(root->left, value);
else if (value > root->info)
Create(root->right, value);
else
{
cout << "Value already exists!\n";
return;
}
}
else
{
root = new node;
root->info = value;
root->left = NULL;
root->right = NULL;
}
}
void Display(node *root)
{
if (root != NULL)
{
cout << root->info << " ";

Display(root->left);
Display(root->right);
}
}
void InOrderTraversal(node *node, int values[101], int
&index)
{
if (node == nullptr)
return;
InOrderTraversal(node->left, values, index);
values[index++] = node->info;
InOrderTraversal(node->right, values, index);
}
bool AreEqual(node *tree1, node *tree2)
{
if (tree1 == nullptr && tree2 == nullptr)
return true;
if (tree1 == nullptr || tree2 == nullptr)
return false;
int values1[101];
int values2[101];
int index1 = 0;
int index2 = 0;

InOrderTraversal(tree1, values1, index1);
InOrderTraversal(tree2, values2, index2);
if (index1 != index2)
return false;
for (int i = 0; i < index1; i++)
if (values1[i] != values2[i])
return false;
return true;
}
int main()
{
ifstream file("input.in");
node *Tree1 = NULL, *Tree2 = NULL;
int value;
while (true)
{
file >> value;
if (value < 0)
break;
Create(Tree1, value);
}
while (true)
{

file >> value;
if (value < 0)
break;
Create(Tree2, value);
}
cout << "Binary Tree 1 created is: ";
Display(Tree1);
cout << endl;
cout << "Binary Tree 2 created is: ";
Display(Tree2);
cout << endl;
cout << "Are the two trees equal in a different order? "
<< (AreEqual(Tree1, Tree2) ? "Yes" : "No") << endl;
return 0;
}
1. Generate the “mirror” tree for a given binary tree.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
struct node
{

int info;
node *st,*dr;
};
void create(node *&r, int val)
{
if(r!=NULL)
{
if(val<r->info)
create(r->st,val);
else if(val>r->info)
create(r->dr,val);
else
{
cout<<"Value already exists!\n";
return;
}
}
else
{
r=new node;
r->info=val;
r->st=NULL;
r->dr=NULL;

}
}
void display(node *r)
{
if(r!=NULL)
{
cout<<r->info<<" ";
display(r->st);
display(r->dr);
}
}
void mirrorTree(node *&r)
{
if (r!=NULL)
{
// reverse the sub-trees left and right
node* temp=r->st;
r->st=r->dr;
r->dr=temp;
// recursive call of the function
mirrorTree(r->st);
mirrorTree(r->dr);
}

}
int main()
{
ifstream f("tree.in");
node *R=NULL;
int val;
while(f>>val)
create(R,val);
cout<<"The generated binary tree is: ";
display(R);
cout<<endl;
cout<<"The mirror tree is: ";
mirrorTree(R);
display(R);
return 0;
}
1. Determine if a tree is “symmetric”, meaning it is
identical to its mirror image.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;

struct nod
{
int info;
nod *st,*dr;
};
void addNode(nod *&r, int val)
{
if(r!=NULL)
{
if(val<r->info)
Creare(r->st,val);
else if(val>r->info)
Creare(r->dr,val);
else
{
cout<<"Value already exists!\n";
return;
}
}
else
{
r=new nod;
r->info=val;

r->st=NULL;
r->dr=NULL;
}
}
void display(nod *r)
{
if(r!=NULL)
{
cout<<r->info<<" ";
display(r->st);
display(r->dr);
}
}
void mirrorTree(nod *&r)
{
if (r!=NULL)
{
// reverse sub-trees left and right
nod* temp=r->st;
r->st=r->dr;
r->dr=temp;
// recursive call for left and right sub-trees
mirrorTree(r->st);

mirrorTree(r->dr);
}
}
bool isSymmetric(nod *r1, nod *r2)
{
if (r1==NULL && r2==NULL)
return true;
if(r1 && r2 && r1->info==r2->info)
return isSymmetric(r1->st,r2->dr) &&
isSymmetric(r1->dr,r2->st);
}
bool decideSymmetric(nod *r)
{
return isSymmetric(r,r);
}
int main()
{
ifstream f("tree.in");
nod *R=NULL;
int val;
while(f>>val)
addNode(R,val);
cout<<"The binary tree is: ";

Afisare(R);
cout<<endl;
cout<<"The mirror tree is: ";
inOglinda(R);
Afisare(R);
cout<<endl;
bool symmetric=decideSymmetric(R);
if (symmetric)
cout<<"It is a symmetric tree.\n";
else
cout<<"NOT symmetric.\n";
return 0;
}
1. The students of a class sit in desks either two by
two or alone. The form teacher has established a
system for making announcements that inform the
entire class. Thus, the form teacher informs two
students from the same desk, and they are then
supposed to announce two students from another
desk each, and so on. Obviously, there will be
students who announce only one student (those
sitting alone in a desk) or no other student. If a
student fails to announce the student from the
next desk on the left (or right), the value will be set

to 0. Knowing that there are n (n≤30) students in
the class numbered from 1 to n, the following
program is required to be written:
a. Store the data in a binary tree allocated in the
heap.
b. Count and display how many students the class is
composed of.
c. Display the students announced by the class
teacher.
d. Display the deskmates (pairs).
e. Display the students who have no one else to
announce.
f. Display the deskmate of student x.
g. Determine whether student x sits in the desk to
the left or right.
h. Display whom student x needs to announce. If
there is no one to announce, a message will be
given.
i. Determine who needs to announce student y.
j. Display the students sitting to the left in desks.
k. Students x and y exchange places in desks.
Display the tree after the exchange.
l. Display how many desks are occupied by only one
student and the students who sit alone in a desk.
m. Determine how many desks are occupied.

Implementation:
struct node {
int info;
node* left;
node* right;
};
// addNode and display methods are the same as previous
// problem
void read(node*& root) {
ifstream file("input.txt");
int value;
while (file >> value) {
if (value > 0)
create(root, value);
else
break;
}
file.close();
}
int countStudents(node* root) {
if (root == NULL)
return 0;

else
return 1 + countStudents(root->left) +
countStudents(root->right);
}
void displayTotalStudents(node* root) {
int totalStudents = countStudents(root);
cout << "Total number of students in the class: " <<
totalStudents << endl;
}
void displayInformedStudents(node* root) {
if (root == NULL)
return;
else
cout << root->left->info << " and " << root->right->info
<< " ";
}
void displayAnnouncedStudents(node* root) {
cout << "Students announced by the form teacher: ";
displayInformedStudents(root);
cout << endl;
}
void displayDeskMates(node* root) {
if (root == NULL)

return;
if (root->left != NULL && root->right != NULL)
cout << "(" << root->left->info << ", " << root->right-
>info << ") ";
displayDeskMates(root->left);
displayDeskMates(root->right);
}
void displayStudentsWithoutAnnouncements(node* root)
{
if (root == NULL)
return;
if (root->left == NULL && root->right == NULL)
cout << root->info << " ";
displayStudentsWithoutAnnouncements(root->left);
displayStudentsWithoutAnnouncements(root->right);
}
node* findDeskMate(node* root, int x) {
if (root == NULL)
return NULL;
if (root->left != NULL && root->left->info == x)
return root->right;
else if (root->right != NULL && root->right->info == x)
return root->left;

node* deskMate = findDeskMate(root->left, x);
if (deskMate != NULL)
return deskMate;
deskMate = findDeskMate(root->right, x);
return deskMate;
}
void displayDeskMate(node* root, int x) {
node* deskMate = findDeskMate(root, x);
if (deskMate != NULL)
cout << "Desk mate of student " << x << " is " <<
deskMate->info << "." << endl;
else
cout << "Student " << x << " does not have a desk
mate." << endl;
}
enum studentPosition { UNDETERMINED, ON_LEFT,
ON_RIGHT };
studentPosition findStudentDesk(node* root, int x) {
if (root == NULL)
return UNDETERMINED;
if (root->info == x)
return UNDETERMINED;
if (root->left != NULL && root->left->info == x)

return ON_LEFT;
else if (root->right != NULL && root->right->info == x)
return ON_RIGHT;
studentPosition positionLeft = findStudentDesk(root->left,
x);
if (positionLeft != UNDETERMINED)
return positionLeft;
studentPosition positionRight = findStudentDesk(root-
>right, x);
return positionRight;
}
void displayStudentPosition(node* root, int x) {
studentPosition position = findStudentDesk(root, x);
if (position == ON_LEFT)
cout << "Student " << x << " is in the desk on the left."
<< endl;
else if (position == ON_RIGHT)
cout << "Student " << x << " is in the desk on the right."
<< endl;
else
cout << "Student " << x << " is not in any desks." <<
endl;
}

node* findStudent(node* root, int x) {
if (root == NULL || root->info == x)
return root;
node* result = findStudent(root->left, x);
if (result != NULL)
return result;
result = findStudent(root->right, x);
return result;
}
void displayStudentsToNotify(node* root, int x) {
node* student = findStudent(root, x);
if (student != NULL) {
if (student->left != NULL)
cout << "Student " << x << " needs to notify student "
<< student->left->info << "." << endl;
if (student->right != NULL)
cout << "Student " << x << " needs to notify student "
<< student->right->info << "." << endl;
if (student->left == NULL && student->right == NULL)
cout << "Student " << x << " does not need to notify
anyone." << endl;
} else

cout << "Student " << x << " does not exist in the class."
<< endl;
}
node* findParent(node* root, int x) {
if (root == NULL || (root->left != NULL && root->left-
>info == x) || (root->right != NULL && root->right->info
== x))
return root;
node* parent = findParent(root->left, x);
if (parent != NULL)
return parent;
parent = findParent(root->right, x);
return parent;
}
void determineNotifier(node* root, int y) {
node* student = findStudent(root, y);
if (student != NULL) {
node* parent = NULL;
if (student != root)
parent = findParent(root, y);
if (parent != NULL) {
if (parent->left != NULL && parent->left->info == y)

cout << "Student " << y << " needs to be notified by
student " << parent->info << "." << endl;
else if (parent->right != NULL && parent->right->info
== y)
cout << "Student " << y << " needs to be notified by
student " << parent->info << "." << endl;
} else
cout << "Student " << y << " does not have a notifier."
<< endl;
} else
cout << "Student " << y << " does not exist in the class."
<< endl;
}
void displayLeftStudents(node* root) {
if (root != NULL) {
displayLeftStudents(root->left);
if (root->left != NULL)
cout << root->left->info << " ";
displayLeftStudents(root->right);
}
}
void swapPlaces(node* root, int x, int y) {
node* studentX = findStudent(root, x);

node* studentY = findStudent(root, y);
if (studentX != NULL && studentY != NULL)
swap(studentX->info, studentY->info);
}
int countSingleDesks(node* root) {
if (root == NULL)
return 0;
int singleDesksCount = 0;
if ((root->left == NULL && root->right != NULL) ||
(root->left != NULL && root->right == NULL))
singleDesksCount++;
singleDesksCount += countSingleDesks(root->left);
singleDesksCount += countSingleDesks(root->right);
return singleDesksCount;
}
bool hasDeskMate(node* root, int x) {
if (root == NULL)
return false;
if (root->left != NULL && root->left->info == x)
return true;
if (root->right != NULL && root->right->info == x)
return true;

return hasDeskMate(root->left, x) || hasDeskMate(root-
>right, x);
}
void displayLonelyStudents(node* root) {
if (root == NULL)
return;
if (root->left == NULL && root->right == NULL &&
!hasDeskMate(root, root->info))
cout << "Student " << root->info << " sits alone in a
desk." << endl;
displayLonelyStudents(root->left);
displayLonelyStudents(root->right);
}
int countOccupiedDesks(node* root) {
if (root == NULL)
return 0;
int deskCount = 0;
if (root->left != NULL || root->right != NULL)
deskCount++;
deskCount += countOccupiedDesks(root->left);
deskCount += countOccupiedDesks(root->right);
return deskCount;
}

int main() {
// Memory allocation for the tree in the heap
node* root = NULL;
read(root);
cout << "The created binary tree is: ";
display(root);
cout << endl;
// Total number of students in the class
displayTotalStudents(root);
// Students announced by the form teacher
displayAnnouncedStudents(root);
// Display desk mates (pairs)
cout << "Desk mates: " << endl;
displayDeskMates(root);
cout << endl;
// Display students who have no one else to announce
cout << "Students who have no one else to announce: ";
displayStudentsWithoutAnnouncements(root);
cout << endl;
// Display the desk mate of student x
int x;
cout << "x = "; cin >> x;
displayDeskMate(root, x);

// Determine whether student x sits in the desk to the left
or right
cout << "x = "; cin >> x;
displayStudentPosition(root, x);
// Display whom student x needs to announce
cout << "x = "; cin >> x;
displayStudentsToNotify(root, x);
// Determine who needs to announce student y
int y;
cout << "y = "; cin >> y;
determineNotifier(root, y);
// Display students who sit to the left in desks
cout << "Students who sit to the left in desks are: ";
displayLeftStudents(root);
cout << endl;
// Students x and y exchange places in desks
cout << "x = "; cin >> x;
cout << "y = "; cin >> y;
swapPlaces(root, x, y);
display(root);
// Display the number of desks occupied by a single
student and students who sit alone in a desk

cout << "Number of desks occupied by a single student: "
<< countSingleDesks(root) << endl;
displayLonelyStudents(root);
// Determine how many desks are occupied
cout << "Number of occupied desks: " <<
countOccupiedDesks(root) + 1; // Including the root
return 0;
}
1. Read n (n≤100) integers from the keyboard.
Generate a binary tree as follows: add odd
numbers to the left, and even numbers to the right.
Display the generated tree.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
struct nod
{
int info;
nod *st,*dr;
};
void addNode(nod *&r, int val)

{
if(r!=NULL)
{
if(val%2==0)
addNode(r->dr,val);
else
addNode(r->st,val);
}
else
{
r=new nod;
r->info=val;
r->st=NULL;
r->dr=NULL;
}
}
void display(nod *r)
{
if(r!=NULL)
{
cout<<r->info<<" ";
display(r->st);
display(r->dr);

}
}
int main()
{
nod *R=NULL;
int n,x;
cout<<"n=";cin>>n;
for(int i=1;i<=n;i++)
{
cout<<"x=";cin>>x;
addNode(R,x);
}
cout<<"Generated Binary Tree: ";
display(R);
return 0;
}
1. Read integers from the keyboard until
encountering 0. Generate a binary tree as follows:
add odd numbers to the left, and even numbers to
the right.
a. Display the generated tree.
b. Display the terminal nodes.

c. Display the height of the tree.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
struct nod
{
int info;
nod *st,*dr;
};
void addNode(nod *&r, int val)
{
if(r==NULL)
{
r=new nod;
r->info=val;
r->st=NULL;
r->dr=NULL;
}
else
{
if(val%2==0)

addNode(r->dr,val);
else
addNode(r->st,val);
}
}
void display(nod *r)
{
if(r!=NULL)
{
cout<<r->info<<" ";
display(r->st);
display(r->dr);
}
}
void displayLeaves(nod *r)
{
if(r==NULL)
return;
if(r->st==NULL && r->dr==NULL)
cout<<r->info<<" "; //terminal node
displayLeaves(r->st);
displayLeaves(r->dr);
}

int calculateHeight(nod *r)
{
if(r==NULL)
return 0;
int leftHeight=calculateHeight(r->st);
int rightHeight=calculateHeight(r->dr);
return max(leftHeight,rightHeight)+1;
}
int main()
{
nod *R=NULL;
int n,x;
cout<<"n=";cin>>n;
for(int i=1;i<=n;i++)
{
cout<<"x=";cin>>x;
addNode(R,x);
}
cout<<"Generated Binary Tree: ";
display(R);
cout<<endl;
cout<<"Terminal nodes are: ";
displayLeaves(R);

cout<<endl;
cout<<"The height of the tree is: "<<calculateHeight(R);
return 0;
}
1. Generate a binary search tree. Linearize the tree
by transforming it into a doubly linked sorted linear
list.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
struct nod
{
int info;
nod *st,*dr;
};
nod* createNode(int val)
{
nod* newNode=new nod;
newNode->info=val;
newNode->st=NULL;
newNode->dr=NULL;

return newNode;
}
nod* insertNode(nod *&r,int val)
{
if(r==NULL)
r=createNode(val);
else if(val<=r->info)
r->st=insertNode(r->st,val);
else r->dr=insertNode(r->dr,val);
return r;
}
void display(nod *r)
{
if(r!=NULL)
{
cout<<r->info<<" ";
display(r->st);
display(r->dr);
}
}
void inorder(nod* r, nod*& prev, nod*& lista)
{
if (r==NULL)

return;
inorder(r->st,prev,lista);
if(prev==NULL)
lista=r;
else
{
r->st=prev;
prev->dr=r;
}
prev=r;
inorder(r->dr,prev,lista);
}
void displayLinearList(nod* radacina)
{
nod* current=radacina;
while(current!=NULL)
{
cout<<current->info<<" ";
current=current->dr;
}
}
int main()
{

nod *R=NULL;
ifstream f("data.in");
int x;
while(f>>x)
insertNode(R,x);
cout<<"The Binary Tree is: ";
display(R);
cout<<endl;
nod* linearList=NULL;
nod* prev=NULL;
inorder(R,prev,linearList);
cout<<"Doubly-linked list: ";
displayLinearList(linearList);
cout<<endl;
return 0;
}
1. Generate a binary search tree that stores
lowercase letters from a text read from the
keyboard.
a. Display the letters in alphabetical order.
b. Display the vowels in the tree.

c. Display the consonants that are not found in the
tree.
d. Determine if the string formed by the leaves of the
tree is equal to a string read from the keyboard.
e. Delete a character x that is read from the
keyboard.
Implementation:
struct node
{
char info;
node *left, *right;
};
node* createNode(char value)
{
node* newNode = new node;
newNode->info = value;
newNode->left = NULL;
newNode->right = NULL;
return newNode;
}
node* insert(node *&root, char value)
{
if (root == NULL)

root = createNode(value);
else if (value <= root->info)
root->left = insert(root->left, value);
else
root->right = insert(root->right, value);
return root;
}
void display(node *root)
{
if (root != NULL)
{
cout << root->info << " ";
display(root->left);
display(root->right);
}
}
bool isVowel(char ch)
{
return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch
== 'u';
}
void displayVowels(node *root)
{

if (root != NULL)
{
displayVowels(root->left);
if (isVowel(root->info))
cout << root->info << " ";
displayVowels(root->right);
}
}
void displayNonexistentConsonants(node *root)
{
bool consonants[26] = {false};
for (char ch = 'a'; ch <= 'z'; ch++)
{
if (!isVowel(ch))
{
node *temp = root;
bool found = false;
while (temp != NULL)
{
if (temp->info == ch)
{
found = true;
break;

}
else if (temp->info > ch)
temp = temp->left;
else
temp = temp->right;
}
if (!found)
consonants[ch - 'a'] = true;
}
}
cout << "Consonants that are not found in the tree: ";
for (int i = 0; i < 26; i++)
{
if (consonants[i])
cout << static_cast<char>('a' + i) << " ";
}
}
void formLeafString(node *root, char *str, int &index)
{
if (root == NULL)
return;
if (root->left == NULL && root->right == NULL)
{

str[index] = root->info;
index++;
}
formLeafString(root->left, str, index);
formLeafString(root->right, str, index);
}
bool areStringsEqual(char *str1, char *str2)
{
return strcmp(str1, str2) == 0;
}
node* removeNode(node *root, char value)
{
if (root == NULL)
return root;
else if (value < root->info)
root->left = removeNode(root->left, value);
else if (value > root->info)
root->right = removeNode(root->right, value);
else
{
if (root->left == NULL && root->right == NULL)
{
delete root;

root = NULL;
}
else if (root->left == NULL)
{
node *temp = root;
root = root->right;
delete temp;
}
else if (root->right == NULL)
{
node *temp = root;
root = root->left;
delete temp;
}
else
{
node *successor = root->right;
while (successor->left != NULL)
successor = successor->left;
root->info = successor->info;
root->right = removeNode(root->right, successor->info);
}
}

return root;
}
int main()
{
node *root = NULL;
char inputString[101];
cout << "Enter a string of characters: ";
cin.get(inputString, 101);
for (int i = 0; i < strlen(inputString); i++)
if (islower(inputString[i]))
root = insert(root, inputString[i]);
// Display letters in alphabetical order
cout << "Letters in alphabetical order: ";
display(root);
cout << endl;
// Display vowels in the tree
cout << "Vowels in the tree are: ";
displayVowels(root);
cout << endl;
// Display consonants that are not in the tree
displayNonexistentConsonants(root);
cout << endl;
// Form a string from the leaves of the tree

cin.ignore();
char leafString[101];
int index = 0;
formLeafString(root, leafString, index);
leafString[index] = '\0';
cout << "String formed from the leaves of the tree: " <<
leafString << endl;
// Compare the leaf string with a user-input string
char userInputString[101];
cout << "Enter a string of characters: ";
cin.get(userInputString, 101);
if (areStringsEqual(leafString, userInputString))
cout << "The string formed from the leaves of the tree is
equal to the input string." << endl;
else
cout << "The string formed from the leaves of the tree is
not equal to the input string." << endl;
// Remove a character x
char x;
cout << "Which character to remove? ";
cin >> x;
root = removeNode(root, x)
cout << "Tree after removal: ";

display(root);
cout << endl;
return 0;
}
1. Generate a binary search tree which randomly
store values from 1 to 49. Display the first 6 values
by traversing the tree using both methods.
Implementation:
#include <iostream>
#include <ctime>
#include <cstdlib>
using namespace std;
struct node
{
int info;
node *st,*dr;
};
nod* createNode(int val)
{
node* newNode=new node;
newNode->info=val;
newNode->st=NULL;

newNode->dr=NULL;
return newNode;
}
nod* insertNode(node *&r,int val)
{
if(r==NULL)
r=createNode(val);
else if(val<=r->info)
r->st=insertNode(r->st,val);
else r->dr=insertNode(r->dr,val);
return r;
}
void inorder(node* r,int &count)
{
if(r!=NULL && count<6)
{
inorder(r->st,count);
if(count<6)
{
cout<<r->info<<" ";
count++;
}
inorder(r->dr,count);

}
}
void preorder(node* r,int &count)
{
if(r!=NULL && count<6)
{
if(count<6)
{
cout<<r->info<<" ";
count++;
}
preorder(r->st,count);
preorder(r->dr,count);
}
}
void randomly(int arr[], int n)
{
srand(time(NULL));
for(int i=n-1; i>0;—i)
{
int j=rand()%(i+1);
swap(arr[i],arr[j]);
}

}
int main()
{
node *R=NULL;
int valori[49];
for(int i=0;i<49;i++)
valori[i]=i+1;
randomly(valori,49);
int count=0;
for(int i=0; i<49 && count<6; ++i)
{
insertNode(R,valori[i]);
count++;
}
count=0;
cout<<"First 6 values (inorder): ";
inorder(R,count);
cout<<endl;
count=0;
cout<<"First 6 values (preorder): ";
preorder(R,count);
cout<<endl;
return 0;

}
1. Determine whether a binary tree is a search tree or
not.
Implementation:
struct Node
{
int info;
Node *left, *right;
};
void Create(Node *&root, int value)
{
if (root != NULL)
{
if (value < root->info)
Create(root->left, value);
else if (value > root->info)
Create(root->right, value);
else
{
cout << "The value already exists!\n";
return;
}

}
else
{
root = new Node;
root->info = value;
root->left = NULL;
root->right = NULL;
}
}
void Display(Node *root)
{
if (root != NULL)
{
cout << root->info << " ";
Display(root->left);
Display(root->right);
}
}
// Returns the maximum value in the tree
int MaxValue(Node *root)
{
if (root == NULL)
return INT16_MIN;

int value = root->info;
int leftMax = MaxValue(root->left);
int rightMax = MaxValue(root->right);
return max(value, max(leftMax, rightMax));
}
// Returns the minimum value in the tree
int MinValue(Node *root)
{
if (root == NULL)
return INT16_MAX;
int value = root->info;
int leftMin = MinValue(root->left);
int rightMin = MinValue(root->right);
return min(value, min(leftMin, rightMin));
}
// Checks if the tree is a binary search tree
bool IsSearchTree(Node *root)
{
if (root == NULL)
return true;
// False if the maximum value on the left is greater
if (root->left != NULL && MaxValue(root->left) > root-
>info)

return false;
// False if the minimum value on the right is less than or
equal to
if (root->right != NULL && MinValue(root->right) < root-
>info)
return false;
// False if recursively, either on the left or right, it's not a
search tree
if (!IsSearchTree(root->left) || !IsSearchTree(root->right))
return false;
// True otherwise if it's a search tree
return true;
}
int main()
{
Node *Root = NULL;
int value;
ifstream file("input.txt");
while (file >> value)
Create(Root, value);
cout << "The binary tree is: ";
Display(Root);
cout << endl;

if (IsSearchTree(Root) == true)
cout << "It is a binary search tree." << endl;
else
cout << "It is not a binary search tree." << endl;
return 0;
}
1. Construct a self-balancing binary search tree (each
node has a link to its predecessor). For a node with
a given key x, display:
a. the predecessor and successors.
b. the sibling.
c. check if x and y are siblings.
Implementation:
struct node
{
int info;
node *left, *right, *predecessor; // for the predecessor of
node x
};
node* createNode(int value, node* predecessor)
{
node* newNode = new node;

newNode->info = value;
newNode->left = NULL;
newNode->right = NULL;
newNode->predecessor = predecessor;
return newNode;
}
node* insert(node *&root, int value, node* predecessor)
{
if (root == NULL)
root = createNode(value, predecessor);
else if (value <= root->info)
root->left = insert(root->left, value, root);
else
root->right = insert(root->right, value, root);
return root;
}
void display(node *root)
{
if (root != NULL)
{
cout << root->info << " ";
display(root->left);
display(root->right);

}
}
node* minimum(node* root)
{
if (root == NULL)
return NULL;
while (root->left != NULL)
root = root->left;
return root;
}
node* maximum(node* root)
{
if (root == NULL)
return NULL;
while (root->right != NULL)
root = root->right;
return root;
}
// Search for the node with value in the tree
node* search(node* root, int value)
{
if (root == NULL || root->info == value)
return root;

if (value < root->info)
return search(root->left, value);
return search(root->right, value);
}
node* successor(node* root, int value)
{
node *currentNode = search(root, value);
if (currentNode == NULL)
return NULL;
// Case 1: There is a right subtree, the successor is the
minimum node in that subtree.
if (currentNode->right != NULL)
return minimum(currentNode->right);
// Case 2: There is no right subtree, the successor is an
ancestor of the current node.
node *succ = currentNode->predecessor;
while (succ != NULL && currentNode == succ->right)
{
currentNode = succ;
succ = succ->predecessor;
}
return succ;
}

node* predecessor(node* root, int value)
{
node *currentNode = search(root, value);
if (currentNode == NULL)
return NULL;
// Case 1: There is a left subtree, the predecessor is the
maximum node in that subtree.
if (currentNode->left != NULL)
return maximum(currentNode->left);
// Case 2: There is no left subtree, the predecessor is an
ancestor of the current node.
node *pred = currentNode->predecessor;
while (pred != NULL && currentNode == pred->left)
{
currentNode = pred;
pred = pred->predecessor;
}
return pred;
}
void displayPredecessorAndSuccessors(node* root, int
value)
{
node* keyNode = search(root, value);

if (keyNode != NULL)
{
cout << "Predecessor of node " << value << " is: ";
node* pred = predecessor(root, value);
if (pred != NULL)
cout << pred->info;
else
cout << "Does not exist.";
cout << endl;
cout << "Successors of node " << value << " are: ";
node* succ = successor(root, value);
while (succ != NULL)
{
cout << succ->info << " ";
succ = successor(root, succ->info);
}
cout << endl;
}
else
cout << "Node " << value << " not found in the tree." <<
endl;
}
node* findSibling(node* root, int value)

{
node* keyNode = search(root, value);
if (keyNode == NULL)
return NULL;
node* predecessor = keyNode->predecessor;
if (predecessor == NULL) // The key node is the root of
the tree
return NULL;
if (keyNode == predecessor->left)
return predecessor->right;
else
return predecessor->left;
}
void displaySibling(node* root, int value)
{
node* sibling = findSibling(root, value);
if (sibling != NULL)
cout << "The sibling of " << value << " is " << sibling-
>info << "." << endl;
else
cout << "Node " << value << " has no sibling." << endl;
}
bool areSiblings(node* root, int x, int y)

{
node* siblingX = findSibling(root, x);
if (siblingX != NULL && siblingX->info == y)
return true;
return false;
}
void checkSiblingRelation(node* root, int x, int y)
{
if (areSiblings(root, x, y))
cout << x << " and " << y << " are siblings." << endl;
else
cout << x << " and " << y << " are not siblings." <<
endl;
}
int main()
{
node *root = NULL;
int value;
ifstream file("input.txt");
while (file >> value)
insert(root, value, NULL); // The predecessor of the root is
NULL
cout << "Self-balancing binary search tree is: ";

display(root);
cout << endl;
cout << "Enter a node: ";
cin >> value;
displayPredecessorAndSuccessors(root, value);
cout << "Sibling of " << value << ": " << endl;
displaySibling(root, value);
int y;
cout << "x="; cin >> value;
cout << "y="; cin >> y;
checkSiblingRelation(root, value, y);
return 0;
}
1. Write a function that transforms a binary search
tree into a threaded binary search tree (each node
having a link to its predecessor).
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
struct nod
{

int info;
nod *st,*dr;
nod *predecesor;//pt inseilare
};
nod* createNode(int val)
{
nod* newNode=new nod;
newNode->info=val;
newNode->st=NULL;
newNode->dr=NULL;
newNode->predecesor=NULL;
return newNode;
}
nod* insert(nod *&r,int val)
{
if(r==NULL)
r=createNode(val);
else if(val<=r->info)
r->st=insert(r->st,val);
else r->dr=insert(r->dr,val);
return r;
}
void display(nod *r)

{
if(r!=NULL)
{
cout<<r->info<<" ";
display(r->st);
display(r->dr);
}
}
void seteazaPredecesor(nod* r, nod*& predecesor)
{
if(r==NULL)
return;
seteazaPredecesor(r->st,predecesor);
r->predecesor=predecesor;
predecesor=r;
seteazaPredecesor(r->dr,predecesor);
}
void convertireInseilare(nod* r)
{
nod* predecesor=NULL;
seteazaPredecesor(r,predecesor);
}
void afisareInseilat(nod* r)

{
if (r!=NULL)
{
afisareInseilat(r->st);
cout<<r->info<<" ";
afisareInseilat(r->dr);
}
}
int main()
{
nod *R=NULL;
int x;
ifstream f("data.in");
while(f>>x)
insert(R,x);
cout<<"Binary tree displayed: ";
display(R);
cout<<endl;
nod* predecesor=NULL;
convertireInseilare(R);
cout<<"The new generated tree is: ";
afisareInseilat(R);
return 0;

}
1. Read and store integers in a binary search tree. As
numbers may repeat, their frequency of occurrence
will be recorded. Display the numbers in ascending
order.
Implementation:
#include <iostream>
#include <fstream>
using namespace std;
struct nod
{
int info;
int frecventa;//frequency for each node
nod *st,*dr;
};
nod* creareNod(int val)
{
nod* newNode=new nod;
newNode->info=val;
newNode->frecventa=1;
newNode->st=NULL;
newNode->dr=NULL;

return newNode;
}
nod* insereaza(nod *&r,int val)
{
if(r==NULL)
r=creareNod(val);
else if(val==r->info)
r->frecventa++;//increment the frequency
else if (val<r->info)
r->st=insereaza(r->st,val);
else
r->dr=insereaza(r->dr,val);
return r;
}
void afisare(nod *r)
{
if (r!=NULL)
{  //display the numbers
afisare(r->st);
for(int i=0; i<r->frecventa; i++)
cout<<r->info<<" ";
afisare(r->dr);
}

}
int main()
{
nod *R=NULL;
int x;
ifstream f("data.in");
while(f>>x)
insereaza(R,x);
cout<<"Binary Tree: ";
afisare(R);
return 0;
}
1. Store the digits of integers read from the keyboard
in a binary search tree. As digits may repeat, their
frequency of occurrence will be recorded. Display
the digits of the input number in ascending order.
Implementation:
#include <iostream>
using namespace std;
struct nod
{
int info;

int frecventa;
nod *st,*dr;
};
nod* createNode(int val)
{
nod* newNode=new nod;
newNode->info=val;
newNode->frecventa=1;
newNode->st=NULL;
newNode->dr=NULL;
return newNode;
}
nod* insertNode(nod *&r,int val)
{
if(r==NULL)
r=createNode(val);
else if(val==r->info)
r->frecventa++;
else if (val<r->info)
r->st=insertNode(r->st,val);
else
r->dr=insertNode(r->dr,val);
return r;

}
void display(nod *r)
{
if (r!=NULL)
{
display(r->st);
for(int i=0; i<r->frecventa; i++)
cout<<r->info<<" ";
display(r->dr);
}
}
void saveDigits(nod*& r,int no)
{
while(no!=0)
{
int digit=no%10;
r=insertNode(r,digit);
no/=10;
}
}
int main()
{
nod *R=NULL;

int x;
cout<<"x=";cin>>x;
saveDigits(R,x);
cout<<"Digits in ascending order: ";
display(R);
return 0;
}
1. Store in a binary search tree the lowercase letters
from a text read from the file data.in. As letters
may repeat, their frequency of occurrence will be
recorded.
a. Display the letters occurring only once in
alphabetical order.
b. Display all letters in alphabetical order.
c. Display the letters with the maximum frequency.
d. Insert letters into the tree so that it stores the
entire alphabet.
e. Display the leaves of the tree.
f. Display the height of the tree.
Implementation:
struct node
{
char info;

int frequency;
node *left, *right;
};
node* createNode(char value)
{
node* newNode = new node;
newNode->info = value;
newNode->frequency = 1;
newNode->left = NULL;
newNode->right = NULL;
return newNode;
}
node* insert(node*& root, char value)
{
if (root == NULL)
root = createNode(value);
else if (value == root->info)
root->frequency++;
else if (value < root->info)
root->left = insert(root->left, value);
else
root->right = insert(root->right, value);
return root;

}
void display(node* root)
{
if (root != NULL)
{
display(root->left);
cout << root->info << " (frequency: " << root-
>frequency << ")" << endl;
display(root->right);
}
}
void displayDistinct(node* root)
{
if (root != NULL)
{
displayDistinct(root->left);
cout << root->info << " ";
displayDistinct(root->right);
}
}
void displayAlphabetical(node* root)
{
if (root != NULL)

{
displayAlphabetical(root->left);
for (int i = 0; i < root->frequency; i++)
cout << root->info << " ";
displayAlphabetical(root->right);
}
}
void displayMaxFrequency(node* root, int&
maxFrequency)
{
if (root != NULL)
{
displayMaxFrequency(root->left, maxFrequency);
if (root->frequency == maxFrequency)
cout << root->info << " ";
displayMaxFrequency(root->right, maxFrequency);
}
}
void insertMissingCharacters(node*& root, char c)
{
if (root == NULL)
root = createNode(c);
else if (c < root->info)

insertMissingCharacters(root->left, c);
else if (c > root->info)
insertMissingCharacters(root->right, c);
}
void insertMissingLetters(node*& root)
{
for (char c = 'a'; c <= 'z'; c++)
{
node* currentNode = root;
bool found = false;
while (currentNode != NULL)
{
if (currentNode->info == c)
{
found = true;
break;
}
else if (c < currentNode->info)
currentNode = currentNode->left;
else
currentNode = currentNode->right;
}
if (!found)

insertMissingCharacters(root, c);
}
}
void displayLeaves(node* root)
{
if (root == NULL)
return;
if (root->left == NULL && root->right == NULL)
cout << root->info << " ";
displayLeaves(root->left);
displayLeaves(root->right);
}
int treeHeight(node* root)
{
if (root == NULL)
return 0;
else
{
int leftHeight = treeHeight(root->left);
int rightHeight = treeHeight(root->right);
return 1 + max(leftHeight, rightHeight);
}
}

int main()
{
node* root = NULL;
ifstream file("input.txt");
char text[255];
file.get(text, 255);
for (int i = 0; i < strlen(text); i++)
{
if (text[i] >= 'a' && text[i] <= 'z')
insert(root, text[i]);
}
cout << "Generated binary tree and letter frequencies: "
<< endl;
display(root);
cout << endl;
cout << "Unique letters sorted alphabetically: ";
displayDistinct(root);
cout << endl;
cout << "All letters sorted alphabetically: ";
displayAlphabetical(root);
cout << endl;
cout << "Letters with maximum frequency are: ";
int maxFrequency = 0;

node* currentNode = root;
while (currentNode != NULL)
{
if (currentNode->frequency > maxFrequency)
maxFrequency = currentNode->frequency;
currentNode = currentNode->right;
}
displayMaxFrequency(root, maxFrequency);
cout << endl;
cout << "Insert missing letters into the tree to store the
entire alphabet: " << endl;
insertMissingLetters(root);
cout << "Generated binary tree: " << endl;
display(root);
cout << endl;
cout << "Leaves of the tree are: " << endl;
displayLeaves(root);
cout << endl;
int height = treeHeight(root);
cout << "Height of the tree is: " << height;
return 0;
}

1. Store in a binary search tree the names of students
in a class with n students (n≤30).
a. Display the names in alphabetical order.
b. Determine whether the name of a student x, is
present in the class.
c. Remove the student y, from the class.
Implementation:
int n;
struct node
{
char name[30];
node* left, * right;
};
node* createNode(char value[30])
{
node* newNode = new node;
strcpy(newNode->name, value);
newNode->left = NULL;
newNode->right = NULL;
return newNode;
}
node* insert(node*& root, char value[30])

{
if (root == NULL)
root = createNode(value);
else if (stricmp(value, root->name) <= 0)
root->left = insert(root->left, value);
else
root->right = insert(root->right, value);
return root;
}
void readData(node*& root)
{
ifstream file("input.txt");
char name[30];
file >> n;
for (int i = 1; i <= n; i++)
{
file >> name;
insert(root, name);
}
file.close();
}
void alphabeticalDisplay(node* root)
{

if (root != NULL)
{
alphabeticalDisplay(root->left);
cout << root->name << endl;
alphabeticalDisplay(root->right);
}
}
bool searchStudent(node* root, char searchedName[30])
{
if (root == NULL)
return false;
int comparisonResult = stricmp(searchedName, root-
>name);
if (comparisonResult == 0)
return true;
else if (comparisonResult < 0)
return searchStudent(root->left, searchedName);
else
return searchStudent(root->right, searchedName);
}
void deleteNode(node*& parent, node*& currentMax)
{
node* temp;

if (currentMax->right != NULL)
deleteNode(parent, currentMax->right);
else
{
strcpy(parent->name, currentMax->name);
temp = currentMax;
currentMax = currentMax->left;
delete temp;
}
}
void deleteStudent(node*& root, char key[30])
{
node* parent;
node* current;
if (root != NULL)
{
if (stricmp(root->name, key) == 0)
{
// Case 1
if (root->left == NULL && root->right == NULL)
{
delete root;
root = NULL;

}
// Case 2a
else if (root->left == NULL)
{
parent = root->right;
delete root;
root = parent;
}
// Case 2b
else if (root->right == NULL)
{
parent = root->left;
delete root;
root = parent;
}
else // Case 3
deleteNode(root, root->left);
}
else if (stricmp(root->name, key) > 0)
deleteStudent(root->left, key);
else
deleteStudent(root->right, key);
}

else
cout << "The student does not exist" << endl;
}
int main()
{
node* root = NULL;
readData(root);
cout << "Class students (alphabetically ordered): " <<
endl;
alphabeticalDisplay(root);
cout << endl;
char studentName[30];
cout << "Name of a student? ";
cin >> studentName;
if (searchStudent(root, studentName))
cout<<studentName<<" is found in the class."<<endl;
else
cout<<studentName<< " is not found in the class."
<<endl;
char studentToDelete[30];
cout << "Which student to delete? ";
cin >> studentToDelete;
deleteStudent(root, studentToDelete);

cout << "The tree after deletion: " << endl;
alphabeticalDisplay(root);
return 0;
}
1. Determine the minimum (maximum) value in a
binary search tree without traversing the entire
tree.
Implementation:
struct nod
{
int info;
nod *st,*dr;
};
nod* createNode(int val)
{
nod* newNode=new nod;
newNode->info=val;
newNode->st=NULL;
newNode->dr=NULL;
return newNode;
}
nod* insertNode(nod *&r,int val)

{
if(r==NULL)
r=createNode(val);
else if(val<=r->info)
r->st=insertNode(r->st,val);
else r->dr=insertNode(r->dr,val);
return r;
}
void SDR(nod* r)
{
if(r!=NULL)
{
SDR(r->st);
cout<<r->info<<" ";
SDR(r->dr);
}
}
int Minimum(nod *r)
{
if(r->st!=NULL)
return Minimum(r->st);
return r->info;
}

int Maximum(nod *r)
{
if(r->dr!=NULL)
return Maximum(r->dr);
return r->info;
}
int main()
{
nod *R=NULL;
ifstream f("data.in");
int x;
while(f>>x)
R=insertNode(R,x);
cout<<"Binary Search Tree: ";
SDR(R);
cout<<endl;
int valMin=Minimum(R);
cout<<"Minimum value from the tree: "<<valMin<<endl;
int valMax=Maximum(R);
cout<<"Maximum value from the tree: "
<<valMax<<endl;
return 0;
}

CHAPTER 18 – FUNDAMENTAL
ALGORITHMS
1. SWAPPING TWO VALUES
1. FIND THE MINIMUM/MAXIMUM FROM N
NUMBERS

1. ALGORITHMS FOR PROCESSING DIGITS OF A
NUMBER
a. First digit of a number
a. Sum/Product of digits of a number

a. Maximum/Minimum digit of a number
a. Number of digits for a number

a. Arithmetic mean of digits for a number
a. “Mirror” number of a number

a. The palindrome test
a. Delete even digits of a number

a. Delete odd digits of a number
a. Replace the first digit with the last

1. GREAT COMMON DIVISOR OF 2 NUMBERS
a. Nichomachus's Algorithm (repeated subtractions)
a. Euclid’s Algorithm (repeated divisions)

1. THE LEAST COMMON MULTIPLE OF 2 NUMBERS
a. The mathematical formula can be taken into
account lcm = (a·b)/gcd(a, b).
b. Or the algorithm below is valid even when
calculating lcm for multiple numbers:
1. PRIME NUMBER TEST

1. THE DIVISORS OF A NUMBER. THE SUM AND
PRODUCT OF DIVISORS
1. FACTORIZATION OF A NUMBER INTO PRIME
FACTORS

1. DELETING AN ELEMENT FROM A ONE-
DIMENSIONAL ARRAY
1. INSERTING AN ELEMENT INTO A ONE-
DIMENSIONAL ARRAY
a. Before the element

a. After the element
1. SELECTION OR EXCHANGE SORT

1. BUBBLE SORT
1. QUICKSORT

1. SEQUENTIAL SEARCH OF AN ELEMENT IN A
VECTOR

1. BINARY SEARCH OF AN ELEMENT (USING
RECURSION)
1. MERGING TWO SORTED VECTORS


CHAPTER 19 – PROPOSED
EXERCISE TO RESOLVE
a. Linear/Conditional and Repetitive Structure
1. Read a natural number n from the keyboard.
Display the sum and product of its digits.
2. Read a natural number n from the keyboard.
Display the number of digits in this number.
3. Read a natural number n from the keyboard.
Determine its reverse and check if it is a
palindromic prime number.
4. Given n real numbers, determine the minimum,
maximum, sum of even numbers, sum of odd
numbers, and the maximum sum that can be
formed with these numbers.
5. Determine the greatest common divisor between
two natural numbers using three distinct methods,
and then find the least common multiple using the
mathematical formula, but also by another
method.
6. Read a real number x from the keyboard.
Determine two prime numbers p and q such that p
≤ x ≤ q, and the difference q–p is minimized.
7. Read a sequence of 0s and 1s from the keyboard,
where the first is 1. This sequence represents a

number written in base 2. Display the number in
base 10.
8. Calculate the sum and product of the prime
divisors of a natural number x read from the
keyboard.
9. Calculate the sum of the digits raised to the power
of k for a given number.
10. Check if a given number is a prime number in an
optimized way.
11. Calculate the following sums:
i. 
ii. 
iii. 
12. Generate the first prime numbers less than or
equal to 1000000.
13. Decompose an even number n read from the
keyboard (greater than or equal to 4) into a sum of
two prime numbers (Goldbach's conjecture).
14. Display three-digit prime numbers whose digit
product is p, where p is read from the keyboard.
15. Read two natural numbers a and b from the
keyboard. Determine if the two numbers are
amicable – the sum of the proper divisors of one
number plus 1 is equal to the value of the other
number.

16. Generate the first n pairs of twin prime numbers.
Two numbers are twin primes if they are prime and
the difference between them is 2.
17. Determine Euler's indicator – the number of
positive integers less than n that are coprime with
n.
18. Given two numbers a and b, each with four distinct
digits, display the number of common digits
between a and b.
19. Read an integer in the form of 
. Calculate the
value of the expression: 
.
20. Read three real numbers n, p, k, and a sequence
of n natural numbers from the keyboard. Display
the numbers that, when divided by p, yield a
remainder of k.
21. Determine the sum of all remainders when four-
digit numbers are divided by 999.
22. Twin Prime Numbers. Two consecutive odd prime
numbers are called twin prime numbers.
Determine the pairs of twin prime numbers up to a
value n read from the keyboard.
23. Find a two-digit natural number whose cube has six
digits and can be written with the digits from the
set {6, 7, 8}.
24. Determine a number n (n ≤ 1000000) for which
nn has n digits.

25. Calculate how many times the digit c appears in
the representation of whole numbers less than or
equal to a value n read from the keyboard.
26. Calculate the following expression: 
.
27. Read n natural numbers from the keyboard.
Determine how many zeros the product of these
numbers ends with, without actually calculating
the product.
Example: If the values 23, 48, 15, 25, and 34 are
read, the output will be 3 zeros.
1. Calculate the exponent at which the prime number
p, read from the keyboard, appears in the
factorization of the number 1*2*3*...*n, without
actually performing the multiplication.
Example: For n=20, p=3, the result is 8.
1. Triangular Numbers. Triangular numbers are
calculated as the sum of the first n natural
numbers. Display triangular numbers up to a given
n.
2. Calculate the sum of the first n prime numbers.
Determine if this sum is a perfect number. A

perfect number is a positive integer equal to the
sum of its proper divisors.
3. Specify the value of the element at position k, read
from the keyboard, in the sequence:
1,2,2,3,3,3,4,4,4,4, ... without actually reading or
constructing the sequence.
4. Read a natural number n with at most 18 digits.
a. Display the digit that appears the least frequently.
If there are multiple such digits, display any one of
them.
b. Check if the number obtained by removing the first
digit and the number obtained by removing the
last digit of n are coprime (have the greatest
common divisor equal to 1). Display "YES" or
"NO".
Input
Output
Explanation
n=296623
a. 9 or
3
b. YES
The digits 3 and 9 appear
only once. The numbers
29662 and 96623 are
coprime.
n=62002
a. 6
b. NO
The digit 6 appears only once. The
numbers 2002 and 6200 are not

coprime.
1. Read a natural number n, then read n natural
numbers, each with at most 9 digits. Display the
sum of the numbers obtained after removing the
odd digits from each input number.
Input
Output
Explanation
n=5
123 489 790 15 1234
74
2+48+0+0+24=74
n=4
246 179 235 7800
1048
246+0+2+800=1048
1. Read several natural numbers smaller than 10000
until encountering 0. Display all pairs of
consecutively read numbers with the property that
the first number is evenly divisible by the product
of the non-zero digits of the second number. The
last number, 0, is not considered.
Example: For the numbers 245, 51, 300, 35, 77,
17, 111, 42, 67, 0, the output will be (245, 5), (51,

300), (300, 35), (77, 17), (17, 111), (42, 67).
a. One Dimensional Arrays
Read a one-dimensional array v from the keyboard
with n components. Perform the following operations:
1. Determine elements with the maximum and
minimum number of divisors.
2. Find the three smallest positive values and the
three largest negative values.
3. Identify the largest unit fraction where both
numerator and denominator belong to the array.
4. Determine and display the vector y with
components y[i] corresponding to the position of
the minimum value in the vector v.
5. Form the vector z such that z[i] =
max{(x1+x2+...+xi)/i, yi} if yi ≥ 0, and z[i] =
max{xi, (y1+y2+...+yi)/i} if yi ≤ 0. Vector y is from
the previous problem.
6. Display a number from the array that has the most
distinct digits in its representation. If there are
multiple such numbers, display the first one. If
there are no such numbers, display a message.
7. Sort the vector using:
I. Insertion sort;
II. Selection sort (ascending);

III. QuickSort (descending);
IV. MergeSort.
1. Read two ascendingly sorted vectors a and b
with n and m components, respectively. Create
a third vector c using the sentinel merge
algorithm.
2. Read two binary vectors x and y representing
the binary representation of two integers.
Calculate the binary sum and difference of the
two numbers.
3. Read a one-dimensional array v from the
keyboard with a maximum of 100 components.
Locate the maximum element, and order all
elements before it in ascending order and all
elements after it in descending order.
4. The minimum deletion problem: Given an
array of integers, perform the minimum
number of deletions such that the resulting
array is strictly decreasing.
5. The minimum insertion problem: Given an
array of integers and a number x, perform the
minimum number of insertions so that the
resulting array contains x and is strictly
increasing.
6. The minimum inversions problem: Given an
array of integers, determine the minimum

number of inversions needed to transform it
into a strictly increasing array.
7. The descending sorting problem: Given an
array of integers, perform the minimum
number of element swaps so that the resulting
array is sorted in descending order.
8. The combination sorting problem: Given
two ascendingly sorted arrays, combine them
into a single ascendingly sorted array using the
minimum number of operations (insertions,
deletions, order changes).
9. The array partitioning problem: Given an
array of integers and a value x, rearrange the
array such that all values less than x are before
values greater than x. Minimize the number of
operations.
10. The circular sorting problem: Given a
circular array of integers, determine the
minimum number of element swaps required to
sort it in ascending order.
11. The triplet finding problem: Given an array
of integers, find all distinct triplets of numbers
(a, b, c) such that a + b = c.
12. The multiple set intersection problem:
Given two ascendingly sorted arrays, find the
common elements (intersection) between the
two arrays.

13. The multiple set union problem: Given two
ascendingly sorted arrays, find all distinct
elements from the two arrays (union).
14. The triplet with given sum problem: Given
an array of integers and a number x, find all
distinct triplets of numbers (a, b, c) such that a
+ b + c = x.
15. The multiple array search problem: Given a
set of ascendingly sorted arrays, find the
position (index) of an element x in the set of
arrays using binary search.
16. The triplet processing problem: Given an
array of integers, find all distinct triplets of
numbers (a, b, c) such that a * b = c.
17. The multiple set intersection problem:
Given a list of ascendingly sorted arrays, find
the common elements (intersection) among all
arrays.
18. The symmetric difference problem: Given
two ascendingly sorted arrays, find all elements
that are in one of the arrays but not in both
(symmetric difference).
19. The large number addition/multiplication
problem: Given two large numbers
represented as arrays of digits, perform
addition and multiplication.

20. The postfix expression evaluation
problem: Given a mathematical expression in
postfix form (RPN - Reverse Polish Notation)
represented as an array of symbols and digits,
evaluate the expression.
21. Given a number in base 10, convert it to base
16 and vice versa. The number is stored in an
array.
22. The modular inverse calculation problem:
Given a number and a modulus, find the
modular inverse of the given number using the
extended Euclidean algorithm.
23. The prime number search problem: Given
an interval [a, b], find all prime numbers in
that interval using the Sieve of Eratosthenes
implemented with a one-dimensional array.
24. The palindromic check problem in a
number system: Given a number in a specific
number system (base 16, base 2), check if the
number is a palindrome (reads the same in
both directions).
25. The problem of finding the dominant digit:
Given an array of integers, find the dominant
digit (the one that appears most frequently)
using a one-dimensional array.
a. Two Dimensional Arrays

1. The problem of calculating the sum of
elements on rows: Given a two-dimensional matrix,
calculate the sum of elements on each row.
2. The problem of calculating the product of
elements on columns: Given a two-dimensional
matrix, calculate the product of elements on each
column.
3. The problem of searching for an element on
a row and column: Given a two-dimensional matrix
and an element x, find the position (row and column)
where the element x is located in the matrix.
4. The problem of deleting a row: Given a two-
dimensional matrix, remove a specified row from the
matrix.
5. The problem of deleting a column: Given a
two-dimensional matrix, remove a specified column
from the matrix.
6. The problem of generating an identity
matrix: Generate a square identity matrix of size n x
n.
7. The problem of generating a spiral matrix:
Generate a two-dimensional matrix of size n x n, filling
it in a spiral pattern from the outer edge to the center.

8. The problem of changing the order of rows:
Given a two-dimensional matrix, reverse the order of
the rows.
9. The problem of changing the order of
columns: Given a two-dimensional matrix, reverse
the order of the columns.
10. The problem of calculating the sum of
main and secondary diagonals: Given a square
matrix, calculate the sum of elements on the main
diagonal and the secondary diagonal.
11. The problem of calculating the sum of
elements in the area above the main diagonal:
Given a square matrix, calculate the sum of elements
located above the main diagonal.
12. The problem of calculating the sum of
elements in the area below the main diagonal:
Given a square matrix, calculate the sum of elements
located below the main diagonal.
13. The problem of searching for a submatrix:
Given a two-dimensional matrix and a specified
submatrix, find the position (row and column) where
the submatrix begins in the large matrix.

14. The problem of calculating the sum of
elements in an area delimited by the main
diagonal: Given a square matrix, calculate the sum of
elements in an area delimited by the main diagonal.
15. The problem of calculating the product of
elements in an area delimited by the secondary
diagonal: Given a square matrix, calculate the
product of elements in an area delimited by the
secondary diagonal.
16. The problem of reversing the order of
elements on each row: Given a two-dimensional
matrix, reverse the order of elements on each row.
17. The problem of reversing the order of
elements on each column: Given a two-dimensional
matrix, reverse the order of elements on each column.
18. The problem of deleting all lines with
negative elements: Given a two-dimensional matrix,
remove all lines that contain at least one negative
element.
19. The problem of deleting all columns with
positive elements: Given a two-dimensional matrix,
remove all columns that contain at least one positive
element.

20. The problem of calculating the sum of
elements in a specified submatrix: Given a two-
dimensional matrix and a submatrix specified by its
corner coordinates, calculate the sum of elements in
the submatrix.
21. The problem of calculating the product of
elements on the main diagonal: Given a square
matrix, calculate the product of elements on the main
diagonal.
22. The problem of calculating the sum of
elements on each row and column: Given a two-
dimensional matrix, calculate the sum of elements on
each row and column.
23. The problem of searching for a square
submatrix of maximum size with maximum sum
of elements: Given a two-dimensional matrix, find a
square submatrix of maximum size that has the
maximum sum of elements.
24. The problem of searching for a submatrix
with a sum of elements equal to a given
number: Given a two-dimensional matrix and a
number x, find a submatrix that has a sum of elements
equal to x.

25. The problem of checking if a matrix is
symmetric: Given a two-dimensional matrix, check if
it is symmetric with respect to the main diagonal.
26. The problem of sorting rows in descending
order: Given a two-dimensional matrix, sort the rows
in descending order based on the sum of elements in
each row.
27. The problem of sorting columns in
ascending order: Given a two-dimensional matrix,
sort the columns in ascending order based on the
product of elements in each column.
28. The problem of searching for a maximum
element on each row: Given a two-dimensional
matrix, find the maximum element on each row.
29. The problem of searching for a minimum
element on each column: Given a two-dimensional
matrix, find the minimum element on each column.
30. The problem of calculating the sum of
elements in an area delimited by the main and
secondary diagonals: Given a square matrix,
calculate the sum of elements in an area delimited by
the main and secondary diagonals.

31. The problem of searching for a maximum
element in a specified submatrix: Given a two-
dimensional matrix and a specified submatrix, find the
maximum element in the submatrix.
32. The problem of calculating the sum of
elements in an area delimited by the matrix
boundaries: Given a two-dimensional matrix,
calculate the sum of elements in an area delimited by
the matrix boundaries.
33. The problem of searching for a submatrix
with the maximum sum of elements: Given a two-
dimensional matrix, find a submatrix that has the
maximum sum of elements.
34. The problem of checking if a matrix is
upper triangular: Given a square matrix, check if it
is upper triangular.
35. The problem of calculating the sum of
elements above the secondary diagonal: Given a
square matrix, calculate the sum of elements located
above the secondary diagonal.
36. The problem of generating a matrix with
elements in ascending order: Generate a two-
dimensional matrix of size n x m, where each element

is greater than the previous one and smaller than the
next one, starting from a given initial value.
37. The problem of generating a matrix with
distinct random elements: Generate a two-
dimensional matrix of size n x m, where each element
is a distinct random number from a given interval.
38. The problem of generating a matrix with
prime elements: Generate a two-dimensional matrix
of size n x m, where each element is a distinct prime
number.
39. The problem of generating a matrix with
palindromic elements: Generate a two-dimensional
matrix of size n x m, where each element is a distinct
palindromic number.
40. The problem of generating a matrix with
elements based on a specified pattern: Generate
a two-dimensional matrix of size n x m, where each
element is calculated based on a specified pattern,
using mathematical or algorithmic rules.
a. Character Strings
1. Find the longest common subsequence between
two strings.

2. Find all permutations of a string.
3. Find all palindromic substrings of a string.
4. Check if a string is composed only of distinct
characters.
5. Find the longest palindromic substring of a string.
6. Find all maximal common substrings between
two strings read from the keyboard.
7. Find the longest non-empty substring that
appears simultaneously in all strings from a list of n
strings.
8. Find the shortest superstring containing all
characters of a given string.
9. Determine the minimum number of operations
(insertions, deletions, and replacements) needed to
transform one string into another.
10. Find the longest common subsequence among
three strings.
11. Find the longest common subsequence among
multiple strings.
12. Determine the maximum number of distinct
substrings that can be formed from a given string.

13. Find all substrings of a string that are
palindromic and have maximum length.
14. Find all substrings of a string with maximum
length containing at least one vowel.
15. Find all substrings of a string composed of
consecutive characters in lexicographic order.
16. Find all substrings of a string with the same sum
of ASCII values of characters.
17. Find all substrings of a string composed of
distinct characters with maximum length.
18. Find all substrings of a string composed of
distinct characters with minimum length.
19. Find all substrings of a string containing only
digits and having the maximum sum of digit values.
20. Find all substrings of a string containing only
lowercase letters with the maximum sum of ASCII
values of letters.
21. Find all substrings of a string containing only
uppercase letters with the maximum sum of ASCII
values of letters.
22. Find all substrings of a string containing only
special characters with maximum length.

23. Find all substrings of a string containing only
alphanumeric characters with maximum length.
24. Find all substrings of a string containing only
alphanumeric characters with minimum length.
25. Find all substrings of a string containing only
alphanumeric characters with the maximum sum of
ASCII values.
26. Find the shortest string that contains all
substrings of a given string.
27. Find all substrings of a string with the maximum
Levenshtein distance from another given string.
28. Find all substrings of a string with the minimum
Levenshtein distance from another given string.
29. Find all substrings of a string with a Levenshtein
distance less than or equal to a given value from
another given string.
30. Find the longest common subsequence between
two strings using the Levenshtein distance.
31. Find all substrings of a string with the maximum
Levenshtein distance from a given list of strings.
32. Find all substrings of a string with the minimum
Levenshtein distance from a given list of strings.

33. Find all substrings of a string with a Levenshtein
distance less than or equal to a given value from a
given list of strings.
34. Find the longest common subsequence among
multiple strings using the Levenshtein distance.
35. Find all substrings of a string with the maximum
Levenshtein distance from a given reference string.
36. Find all substrings of a string with the minimum
Levenshtein distance from a given reference string.
37. Find all substrings of a string with a Levenshtein
distance less than or equal to a given value from a
given reference string.
38. Find all substrings of a string with the maximum
Levenshtein distance from a given list of reference
strings.
39. Implement a function that takes a string
representing text as a parameter and returns the list
of words in the text.
40. Implement a function that takes a string
representing text as a parameter and returns the total
number of words in the text.

41. Implement a function that takes a string
representing text as a parameter and returns the list
of unique words in the text.
42. Implement a function that takes a string
representing text as a parameter and returns the
frequency of each word in the text.
43. Implement a function that takes two string
parameters, one representing text and the other
representing a word, and returns the number of
occurrences of the word in the text.
44. Implement a function that takes a string
representing text as a parameter and returns the text
with all words reversed.
45. Implement a function that takes two string
parameters, one representing text and the other
representing a word, and returns the text where all
occurrences of the word are replaced with another
given word.
46. Implement a function that takes two string
parameters, one representing text and the other
representing a word, and returns the text where all
occurrences of the word are removed.

47. Implement a function that takes two string
parameters, one representing text and the other
representing a word, and returns the text where all
occurrences of the word are replaced with censored
versions (e.g., replaced with asterisks).
48. Implement a function that takes a string
representing text as a parameter and returns the list
of sentences in the text.
a. Subroutines/Methods
1. Write a recursive function to calculate the
factorial of a given number.
2. Implement a function to determine the greatest
common divisor (GCD) of two given numbers.
3. Create a function that takes a string of
characters and returns its reverse.
4. Implement a function to check if a string of
characters is a palindrome.
5. Write a function to determine the nth number in
the Fibonacci sequence.
6. Create a function to check if a given number is
prime.

7. Implement a function to convert a number from
base 10 to base 2.
8. Write a function to determine the permutations
of a string of characters.
9. Create a function to determine the combinations
of n taken k at a time.
10. Implement a function to check if a string of
characters is an anagram.
11. Write a function to determine the sum of all
divisors of a given number.
12. Create a function to calculate the value of π
using the Leibniz series.
13. Implement a function to determine if a given
number is a power of another number.
14. Write a function to determine the number of
occurrences of a string of characters in another string.
15. Create a function to determine the least
common multiple (LCM) of multiple numbers.
16. Implement a function to check if a number is
perfect (the sum of its divisors equals the number
itself).

17. Write a function to determine the n-th prime
number.
18. Create a function to determine if a string of
characters consists only of digits.
19. Implement a function to check if a number is a
palindrome.
20. Write a function to determine the largest prime
number smaller than a given number.
21. Create a function to determine the prime
divisors of a given number.
22. Implement a function to check if a number is
triangular (can be written as the sum of consecutive
numbers).
23. Write a function to determine the number of
digits in a given number.
24. Create a function to determine if a number is a
perfect square.
25. Implement a function to check if a string of
characters consists only of lowercase letters.
26. Write a function to determine the sum of the
digits of a given number.

27. Create a function to determine the largest
prime divisor of a given number.
28. Implement a function to check if a number is a
palindrome in a specific base b read from the
keyboard.
29. Write a function to determine the divisors of a
given number.
30. Create a function to determine the smallest
multiple of a number that contains only prime digits.
31. Implement a function to check if a number is a
power of 2.
32. Write a function to determine the sum of prime
numbers smaller than a given number.
33. Create a function to determine the longest
increasing sequence in a given array.
34. Implement a function to check if a string of
characters consists only of uppercase letters.
35. Write a function to determine the sum of the
squares of the digits of a given number.
36. Create a function to determine the n-th perfect
number (the sum of its divisors is twice the number
itself).

37. Implement a function to check if a number is a
square triangular number.
38. Write a function to determine the smallest
prime number smaller than a given number, with the
sum of its digits equal to the sum of the digits of the
given number.
39. Create a function to determine the largest
prime number smaller than a given number, with the
sum of its digits equal to the sum of the digits of the
given number.
40. Implement a function to check if a string of
characters consists only of alphanumeric characters.
a. Recursion
1. Write a recursive function to calculate the
Ackermann function defined as follows:
Ack=
2. Implement a recursive function to determine the
greatest common divisor (GCD) of two given numbers
using Euclid's algorithm.
3. Create a recursive function that takes a string of
characters and returns its reverse.

4. Implement a recursive function to check if a
string of characters is a palindrome.
5. Write a recursive function to determine the n-th
number in the Fibonacci sequence.
6. Calculate the following expressions using
recursive functions:
a) 2 × 4 × 6 × ... × (2n);
b) 1 × 3 × 5 × ... × (2n-1);
c) 1 × 4 × 7 × ... × (3n-2);
d) 2 + 4 + 6 + ... + 2n;
7. Implement a recursive function to convert a
decimal number to binary.
8. Write a recursive function to determine the
permutations of a string of characters.
9. Create a recursive function to determine
combinations of n taken k at a time.
10. Implement a recursive function to check if a
string of characters is an anagram.
11. Write a recursive function to find the sum of all
divisors of a given number.

12. Develop a recursive function to calculate the
value of π using the Leibniz series.
13. Implement a recursive function to determine if
a given number is a power of another number.
14. Given a one-dimensional array v with n
components, use recursive functions to determine:
a) The product of elements at odd positions in v.
b) The sum of even elements at positions divisible
by a number k (input from the user).
c) The sum of squares of elements whose cube is
less than k.
d) The number of odd elements in the interval [a,
b].
e) The number of negative elements.
f) The sum of prime numbers.
g) The product of odd elements.
15. Create a recursive function to determine the
least common multiple (LCM) of n numbers.
16. Implement a recursive function to check if a
number is perfect (the sum of its divisors equals the
number itself).

17. Write a recursive function to determine the n-th
prime number.
18. Read a two-dimensional array with n rows and
m columns from the keyboard. Use recursive functions
for the following operations:
a) Sum of elements in a row k (input from the user).
b) Sum of elements in a column p (input from the
user).
c) Sum of elements on the main diagonal.
d) Product of elements on the secondary diagonal.
19. Implement a recursive function to check if a
number is a palindrome.
20. Write a recursive function to find the largest
prime number smaller than a given number n.
21. Create a recursive function to determine the
prime divisors of a given number.
22. Implement a recursive function to check if a
number is triangular (can be written as the sum of
consecutive numbers).
23. Write a recursive function to determine the
number of digits in a given number.

24. Develop a recursive function to determine if a
number is a perfect square.
25. Implement a recursive function to check if a
string of characters consists only of lowercase letters.
26. Write a recursive function to calculate the sum
of the digits of a given number.
27. Implement a recursive function to find the
largest prime divisor of a given number.
28. Develop a recursive function to check if a
number is a palindrome in a specific base b, read from
the keyboard.
29. Write a recursive function to determine the
divisors of a given number.
30. Create a recursive function to find the smallest
multiple of a number that contains only prime digits.
31. Implement a recursive function to check if a
number is a power of 2.
32. Write a recursive function to determine the sum
of prime numbers smaller than a given number.
33. Develop a recursive function to find the longest
increasing sequence in a given vector.

34. Consider a maze represented by a two-
dimensional array a with n rows and m columns.
Pathways are encoded with the value “1”, and walls
with the value “0”. Given an initial position specified
by the row l and column c, find a single exit path from
the maze, moving only on its pathways.
Example: n=7, m=6
0 0 0 0 0 0
0 1 1 0 0 0
0 0 1 0 0 0
0 1 1 1 1 0
0 1 0 0 1 0
0 0 0 0 1 0
0 0 0 0 1 0, starting position (2,2), then the exit
path is as follows: (2,2); (2,3); (3,3); (4,3); (4,4); (4,5);
(5,5); (6,5); (7,5).
35. Write a recursive function to determine the sum
of the squares of the digits of a given number.
36. Create a recursive function to find the nth
perfect number (the sum of its divisors is twice the
number itself).

37. Implement a recursive function to check if a
number is a square triangular number.
38. Develop a recursive function to find the
smallest prime number smaller than a given number,
with the sum of its digits equal to the sum of the digits
of the given number.
39. Write a recursive function to find the largest
prime number smaller than a given number, with the
sum of its digits equal to the sum of the digits of the
given number.
40. Implement a recursive function to check if a
string of characters consists only of alphanumeric
characters.
a. Structure Type
1. The data for a geometric figure (circle, square,
rectangle, and triangle) is read. Calculate the area of
the respective figure.
2. Read data for n students, including their names
and surnames as character strings, and two real
numbers representing the average grades in English
and mathematics. Display the students in alphabetical

order by name, then sort them by overall average
grade.
3. Write a program that reads data about
employees in a company: name, surname, date of
birth, address, income.
a) Display the employees in alphabetical order.
b) Display the employees who have a salary greater
than £500, in descending order of income.
c) Display the oldest and youngest employee.
4. Write a program that reads data about books in a
personal library: author, book title, publisher, year of
publication, number of pages, and domain. Display the
books in alphabetical order by authors, and for an
author entered from the keyboard, display the books
from the current year with a palindrome number of
pages.
5. The length and width of n rectangles are read
from the file data.in. Display the rectangles in
ascending order of area. Determine the rectangle with
the largest area and the maximum diagonal length.
6. Read data for n students from the file exam.in –
their names and grades on the Baccalaureate exam. A
student is considered to have passed if they have a

grade of at least 5 in a subject and a final average of
at least 6. Solve the following requirements:
a) Order the students in ascending order of passing
grades.
b) Display the students who failed.
c) Display the exam grades of a student x entered
from the keyboard. If the student is not in the file,
display a message.
7. From the file town.in read data for n people –
their names, locality, and personal identification
number. Determine the oldest and youngest person;
alphabetically order the people by locality and
determine from which localities most people come.
8. For tracking cosmetic products in a warehouse,
define a structure with the following information:
product code, name, and price. Due to inflation, the
prices of products must be increased as follows: by 7%
if the product code is less than 500, and otherwise by
15%. Display the products with the highest price after
the increase.

REFERENCES
1. Bucur, C. (2002). ”Culegere de Probleme de
Informatică.” Editura Donaris.
2. Gianibuzatu, G. - https://gianibuzatu.wordpress.com/
3. Infoarena.ro - https://www.infoarena.ro/
4. Info.mcip.ro - https://info.mcip.ro/index.php
5. Ionescu, C. (2004). ”Informatică pentru Grupele de
Performanță. ” Editura Dacia.
6. Neagu, V. (2012). ”1024 Probleme de Informatică.”
Editura Sfântul Ierarh Nicolae.
7. Pbinfo.ro - https://www.pbinfo.ro/
8. Sorin, T. ”Informatica Varianta C++.” Editura L&S.
9. Variante de Bacalaureat (2009). Available here:
https://profs.info.uaic.ro/~vcosmin/pagini/resurse_pregatir
e/variante-bac-2009-informatica-intensiv.pdf
10. Voinea, M. (2011). ”Inițiere în Programare.” Editura
Sfântul Ierarh Nicolae.
11. Invatainfo.ro - https://invata.info/




