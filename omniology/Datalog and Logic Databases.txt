Datalog and  
Logic Databases
Sergio Greco
Cristian Molinaro
SyntheSiS LectureS on Data ManageMent
Z. Meral Ã–zsoyoÄŸlu, Series Editor
MORGAN&CLAYPOOL PUBLISHERS


Datalog and Logic Databases

Synthesis Lectures on Data
Management
Editor
Z. Meral Ã–zsoyoË‡glu, Case Western Reserve University
Founding Editor
M. Tamer Ã–zsu, University of Waterloo
Synthesis Lectures on Data Management is edited by Meral Ã–zsoyoË‡glu of Case Western Reserve
University. î€€e series publishes 80- to 150-page publications on topics pertaining to data
management. Topics include query languages, database system architectures, transaction
management, data warehousing, XML and databases, data stream systems, wide scale data
distribution, multimedia data management, data mining, and related subjects.
Datalog and Logic Databases
Sergio Greco and Cristian Molinaro
2015
Big Data Integration
Xin Luna Dong and Divesh Srivastava
2015
Instant Recovery with Write-Ahead Logging: Page Repair, System Restart, and Media
Restore
Goetz Graefe, Wey Guy, and Caetano Sauer
2014
Similarity Joins in Relational Database Systems
Nikolaus Augsten and Michael H. BÃ¶hlen
2013
Information and Inï¬‚uence Propagation in Social Networks
Wei Chen, Laks V.S. Lakshmanan, and Carlos Castillo
2013
Data Cleaning: A Practical Perspective
Venkatesh Ganti and Anish Das Sarma
2013

iii
Data Processing on FPGAs
Jens Teubner and Louis Woods
2013
Perspectives on Business Intelligence
Raymond T. Ng, Patricia C. Arocena, Denilson Barbosa, Giuseppe Carenini, Luiz Gomes, Jr.,
Stephan Jou, Rock Anthony Leung, Evangelos Milios, RenÃ©e J. Miller, John Mylopoulos, Rachel A.
Pottinger, Frank Tompa, and Eric Yu
2013
Semantics Empowered Web 3.0: Managing Enterprise, Social, Sensor, and Cloud-based
Data and Services for Advanced Applications
Amit Sheth and Krishnaprasad î€€irunarayan
2012
Data Management in the Cloud: Challenges and Opportunities
Divyakant Agrawal, Sudipto Das, and Amr El Abbadi
2012
Query Processing over Uncertain Databases
Lei Chen and Xiang Lian
2012
Foundations of Data Quality Management
Wenfei Fan and Floris Geerts
2012
Incomplete Data and Data Dependencies in Relational Databases
Sergio Greco, Cristian Molinaro, and Francesca Spezzano
2012
Business Processes: A Database Perspective
Daniel Deutch and Tova Milo
2012
Data Protection from Insider î€€reats
Elisa Bertino
2012
Deep Web Query Interface Understanding and Integration
Eduard C. Dragut, Weiyi Meng, and Clement T. Yu
2012
P2P Techniques for Decentralized Applications
Esther Pacitti, Reza Akbarinia, and Manal El-Dick
2012

iv
Query Answer Authentication
HweeHwa Pang and Kian-Lee Tan
2012
Declarative Networking
Boon î€€au Loo and Wenchao Zhou
2012
Full-Text (Substring) Indexes in External Memory
Marina Barsky, Ulrike Stege, and Alex î€€omo
2011
Spatial Data Management
Nikos Mamoulis
2011
Database Repairing and Consistent Query Answering
Leopoldo Bertossi
2011
Managing Event Information: Modeling, Retrieval, and Applications
Amarnath Gupta and Ramesh Jain
2011
Fundamentals of Physical Design and Query Compilation
David Toman and Grant Weddell
2011
Methods for Mining and Summarizing Text Conversations
Giuseppe Carenini, Gabriel Murray, and Raymond Ng
2011
Probabilistic Databases
Dan Suciu, Dan Olteanu, Christopher RÃ©, and Christoph Koch
2011
Peer-to-Peer Data Management
Karl Aberer
2011
Probabilistic Ranking Techniques in Relational Databases
Ihab F. Ilyas and Mohamed A. Soliman
2011
Uncertain Schema Matching
Avigdor Gal
2011

v
Fundamentals of Object Databases: Object-Oriented and Object-Relational Design
Suzanne W. Dietrich and Susan D. Urban
2010
Advanced Metasearch Engine Technology
Weiyi Meng and Clement T. Yu
2010
Web Page Recommendation Models: î€€eory and Algorithms
Sule GÃ¼ndÃ¼z-Ã–gÃ¼dÃ¼cÃ¼
2010
Multidimensional Databases and Data Warehousing
Christian S. Jensen, Torben Bach Pedersen, and Christian î€€omsen
2010
Database Replication
Bettina Kemme, Ricardo Jimenez-Peris, and Marta Patino-Martinez
2010
Relational and XML Data Exchange
Marcelo Arenas, Pablo Barcelo, Leonid Libkin, and Filip Murlak
2010
User-Centered Data Management
Tiziana Catarci, Alan Dix, Stephen Kimani, and Giuseppe Santucci
2010
Data Stream Management
Lukasz Golab and M. Tamer Ã–zsu
2010
Access Control in Data Management Systems
Elena Ferrari
2010
An Introduction to Duplicate Detection
Felix Naumann and Melanie Herschel
2010
Privacy-Preserving Data Publishing: An Overview
Raymond Chi-Wing Wong and Ada Wai-Chee Fu
2010
Keyword Search in Databases
Jeï¬€rey Xu Yu, Lu Qin, and Lijun Chang
2009

Copyright Â© 2016 by Morgan & Claypool
All rights reserved. No part of this publication may be reproduced, stored in a retrieval system, or transmitted in
any form or by any meansâ€”electronic, mechanical, photocopy, recording, or any other except for brief quotations
in printed reviews, without the prior permission of the publisher.
Datalog and Logic Databases
Sergio Greco and Cristian Molinaro
www.morganclaypool.com
ISBN: 9781627051132
paperback
ISBN: 9781627051149
ebook
DOI 10.2200/S00648ED1V01Y201505DTM041
A Publication in the Morgan & Claypool Publishers series
SYNTHESIS LECTURES ON DATA MANAGEMENT
Lecture #41
Series Editor: Z. Meral Ã–zsoyoË‡glu, Case Western Reserve University
Founding Editor: M. Tamer Ã–zsu, University of Waterloo
Series ISSN
Print 2153-5418
Electronic 2153-5426

Datalog and Logic Databases
Sergio Greco and Cristian Molinaro
DIMES, UniversitÃ  della Calabria
SYNTHESIS LECTURES ON DATA MANAGEMENT #41
C
M
&
cLaypool
Morgan
publishers
&

ABSTRACT
î€€e use of logic in databases started in the late 1960s. In the early 1970s Codd formalized
databases in terms of the relational calculus and the relational algebra. A major inï¬‚uence on the
use of logic in databases was the development of the ï¬eld of logic programming. Logic provides
a convenient formalism for studying classical database problems and has the important property
of being declarative, that is, it allows one to express what she wants rather than how to get it.
For a long time, relational calculus and algebra were considered the relational database
languages. However, there are simple operations, such as computing the transitive closure of a
graph, which cannot be expressed with these languages. Datalog is a declarative query language
for relational databases based on the logic programming paradigm. One of the peculiarities that
distinguishes Datalog from query languages like relational algebra and calculus is recursion, which
gives Datalog the capability to express queries like computing a graph transitive closure.
Recent years have witnessed a revival of interest in Datalog in a variety of emerging appli-
cation domains such as data integration, information extraction, networking, program analysis,
security, cloud computing, ontology reasoning, and many others. î€€e aim of this book is to present
the basics of Datalog, some of its extensions, and recent applications to diï¬€erent domains.
KEYWORDS
relational databases, logic programs, datalog, recursion, negation, function symbols,
aggregates, query optimization

ix
Contents
Acknowledgments. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xiii
1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
2
Logic and Relational Databases . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
2.1
First-order Logic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
2.1.1 Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
2.1.2 Herbrand Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
2.2
Relational Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
2.2.1 Relational Algebra . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
2.2.2 Relational Calculus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
2.2.3 Conjunctive Queries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
2.2.4 Data Dependencies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
2.3
Complexity Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
3
Datalog . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
3.1
Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
3.2
Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
3.2.1 Model-î€€eoretic Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
3.2.2 Fixpoint Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
3.2.3 Proof-î€€eoretic Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
3.3
Program Evaluation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
3.3.1 Evaluation of Non-recursive Programs . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
3.3.2 Evaluation of Recursive Programs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
3.4
Expressivity and Complexity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
4
Negation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
4.1
Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
4.2
Semipositive Programs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
4.3
Stratiï¬ed Programs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
4.4
Locally Stratiï¬ed Programs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
4.5
Unstratiï¬ed Negation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41

x
4.5.1 Stable Model Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
4.5.2 Well-founded Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
4.6
Choice. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
4.6.1 Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
4.6.2 Stable-model Declarative Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
4.6.3 Fixpoint Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
4.6.4 Greedy Choice . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
4.7
Disjunction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
5
Function Symbols . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61
5.1
Syntax and Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61
5.2
Termination Criteria . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62
5.2.1 -restricted Programs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
5.2.2 Finite Domain Programs. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64
5.2.3 Argument-restricted Programs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
5.2.4 Safe Programs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
5.2.5   -acyclic Programs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
5.2.6 Bounded Programs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70
5.3
Program Adornment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
5.4
Dealing with Disjunction and Negation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85
6
Aggregates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89
6.1
Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89
6.2
Sum and Count . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90
6.3
Summation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94
6.4
Combining Summation and Greedy Choice . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96
7
Query Optimization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
7.1
Magic-sets Rewriting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
7.2
Chain Queries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109
7.2.1 î€€e Pushdown Method. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112
7.2.2 Right-Linear Programs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
7.2.3 Grammar Transformations to Improve Pushdown . . . . . . . . . . . . . . . . 116
7.2.4 When Pushdown Reduces to Counting . . . . . . . . . . . . . . . . . . . . . . . . . 121
7.2.5 Implementation and Termination . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122

xi
8
Applications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
8.1
Security . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
8.2
Networking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130
8.3
Web Data Management . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130
8.4
Program Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
8.5
Module Composition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132
Bibliography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135
Authorsâ€™ Biographies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 155


xiii
Acknowledgments
We are very grateful to Leo Bertossi for his valuable comments, and to Tamer Ã–zsu for the
opportunity to write this book.
We would also like to express our thanks to Diane Cerra at Morgan & Claypool for her
constant support and assistance.
Sergio Greco and Cristian Molinaro
October 2015


1
C H A P T E R
1
Introduction
î€€e use of logic in databases started in the late 1960s. In the early 1970s, Codd formalized
databases in terms of the relational calculus and the relational algebra. A major inï¬‚uence on the
use of logic in databases was the development of the ï¬eld of logic programming. Logic provides
a convenient formalism for studying classical database problems.
For a long time, relational calculus and algebra were considered the relational database
languages. However, there are simple operations, such as computing the transitive closure of a
graph, which cannot be expressed with these languages. Datalog is a declarative query language
for relational databases based on the logic programming paradigm. From a syntactical standpoint,
an important diï¬€erence between Datalog and logic programs is that function symbols are not
allowed in Datalog. One of the peculiarities that distinguishes Datalog from query languages like
relational algebra and calculus is recursion, which gives Datalog the capability to express queries
like computing a graph transitive closure.
Recent years have witnessed a revival of interest in Datalog in a variety of emerging appli-
cation domains such as data integration, information extraction, networking, program analysis,
security, cloud computing, ontology reasoning, and many others.
î€€e aim of this book is to present the basics of Datalog, its extensions, and recent applica-
tions to diï¬€erent domains.
î€€is book starts with a brief review of ï¬rst-order logic, the relational model, and complexity
classes in Chapter 2.
Chapter 3 introduces the syntax and diï¬€erent (equivalent) semantics of the Datalog lan-
guage. Moreover, simple algorithms for the evaluation of Datalog queries are presented. Com-
plexity and expressive power are analyzed as well.
î€€en, diï¬€erent extensions are considered, namely negation, functions symbols, and aggre-
gates. Each of them is addressed in a separate chapter.
In Chapter 4, we ï¬rst consider negation, which is an important feature to formalize com-
mon sense reasoning in knowledge representation, as it enables us to express nonmonotonic
queries. Diï¬€erent increasingly liberal restrictions on the use of negation are considered, start-
ing from diï¬€erent notions of â€œstratiï¬cationâ€ and ending with an arbitrary, or â€œunstratiï¬ed,â€ use
of negation. For the latter, two diï¬€erent well-known semantics are presented, namely the stable
model and the well-founded semantics. î€€en, we consider Datalog extended with a limited form
a negation embedded in the choice construct. We also brieï¬‚y discuss the extension of Datalog with
disjunction.

2
1. INTRODUCTION
In Chapter 5, Datalog is extended to include function symbols. Function symbols are widely
acknowledged as an important feature, as they often make modeling easier and the resulting en-
codings more readable and concise. Unfortunately, the main problem with their introduction in
Datalog is that the least model of a program can be inï¬nite and thus the bottom-up program
evaluation might not terminate. î€€e chapter reports on recent research on identifying classes of
programs allowing only a restricted use of function symbols while ensuring ï¬niteness and com-
putability of the least model.
In Chapter 6, another important feature of query languages is considered, namely aggre-
gates. î€€e most common aggregate operators are considered and we show how they help express
optimization problems.
In Chapter 7, we report techniques that take advantage of the information in Datalog
queries to make their evaluation more eï¬ƒcient. î€€e ï¬rst technique is the well-known magic-sets
rewriting method, which consists of rewriting a Datalog query into an equivalent one that com-
bines the advantages of the bottom-up and top-down evaluation strategies. î€€e second technique
applies to a special class of Datalog queries, called chain queries.
Finally, Chapter 8 brieï¬‚y illustrates the use of Datalog in diï¬€erent current database appli-
cations.

3
C H A P T E R
2
Logic and Relational Databases
A database is a collection of data organized to model relevant aspects of reality and to support
processes requiring this information.
A database model is a formalizm to describe how data are structured and used. It provides
the means for specifying particular data structures, for constraining the data associated with these
structures, and for manipulating the data. î€€e most popular example of a database model is the
relational model, although several other data models have been proposed and are currently used.
î€€e relational model was introduced by E. F. Codd in 1970 [Codd, 1970] as a way to make
Database Management Systems (DBMSs) independent of any particular application.
Logic and databases have gone a long way together since the beginning of the relational data
model itself. One of the ï¬rst relational database query language, namely the relational calculus,
is a fragment of ï¬rst-order logic. Logic provides a convenient formalizm for studying classical
database problems.
In this chapter, we report the basics of ï¬rst-order logic, relational model, relational query
languages, data dependencies, and complexity classes.
2.1
FIRST-ORDER LOGIC
In this section, we report syntax and the Herbrand semantics of classical ï¬rst-order predicate
logic.
2.1.1
SYNTAX
A ï¬rst-order language consists of an alphabet and all formulas that can be built from it. An alphabet
consists of the following classes of symbols:
â€¢ a set of variables;
â€¢ a set of constants;
â€¢ a set of function symbols;
â€¢ a set of predicate symbols;
â€¢ the connectives : (negation), _ (disjunction), ^ (conjunction), ! (implication), and $
(equivalence);
â€¢ the quantiï¬ers 9 (there exists) and 8 (for all); and

4
2. LOGIC AND RELATIONAL DATABASES
â€¢ the parentheses â€˜â€˜.â€ and â€˜â€˜/â€, and the comma â€˜â€˜; â€.
Each predicate and function symbol is associated with a ï¬xed arity (i.e., the number of
arguments), which is a non-negative integer for predicate symbols and a positive integer for func-
tion symbols (the role of function symbols with arity 0 is played by the constants). î€€us, the sets
of connectives, quantiï¬ers, and parentheses are ï¬xed. We also assume that the set of variables is
inï¬nite and ï¬xed. î€€e sets of constants, function symbols, and predicate symbols may vary and
determine diï¬€erent ï¬rst-order languages.
Terms are recursively deï¬ned as follows:
â€¢ a constant is a term;
â€¢ a variable is a term;
â€¢ if f is a function symbol of arity m and t1; : : : ; tm are terms, then f .t1; : : : ; tm/ is a term.
Formulas are recursively deï¬ned as follows:
â€¢ if p is a predicate symbol of arity n and t1; : : : ; tn are terms, then p.t1; : : : ; tn/ is a formula
(also-called atom);
â€¢ if F and G are formulas, then so are :F , .F ^ G/, .F _ G/, .F ! G/, and .F $ G/; and
â€¢ if F is a formula and X is a variable, then 9XF and 8XF are formulas.
An atom of the form p.t1; : : : ; tn/ will be also-called a p-atom. In the following, a formula
.F ! G/ will be written also as .G  F /. Some well-known binary function symbols (e.g., C)
and predicate symbols (e.g., D) are written in inï¬x notation, that is, the symbol is written between
the arguments. In order to avoid an excessive use of parentheses, we introduce a binding order
among the connectives and the quantiï¬ers: we assume that :, 9, and 8 bind stronger than ^
which in turns binds stronger than _ which binds stronger than ! and $. We also assume that
_, ^, !, and $ associate to the right. A formula of the form 8X1 : : : 8Xn F will be also written
as 8X1; : : : ; Xn F , and likewise for the existential quantiï¬er 9. î€€us, for instance, the formulaÂ¹
8X8Y..p.X/ ^ :r.Y // ! .:q.X/ _ .q.X/ _ s.Y ////
can be rewritten as
8X; Y.p.X/ ^ :r.Y / ! :q.X/ _ .q.X/ _ s.Y ///
which can be in turn rewritten as the following formula because we are assuming that _ associates
to the right
8X; Y.p.X/ ^ :r.Y / ! :q.X/ _ q.X/ _ s.Y //:
Â¹Here p, q, r, and s are predicate symbols.

2.1. FIRST-ORDER LOGIC
5
A term or formula is ground if no variables appear in it.
î€€e scope of 8X (resp. 9X) in the formula 8XF (resp. 9XF ) is F . A bound occurrence of a
variable in a formula is an occurrence immediately following a quantiï¬er, or an occurrence within
the scope of a quantiï¬er of the variable immediately after the quantiï¬er. Any other occurrence of a
variable is free. A formula without free variable occurrences is called a sentence. î€€us, for instance,
in the formula
9Xp.X; Y / ^ q.X/
the ï¬rst two occurrences of X are bound, while the third one is free, because the scope of 9X is
p.X; Y /. î€€e occurrence of Y is free. In the formula
9X.p.X; Y / ^ q.X//
all occurrences of X are bound because the scope of 9X is p.X; Y / ^ q.X/. î€€e occurrence of Y
is free. Neither of the previous two formulas is a sentence as they have a free variable occurrence.
î€€e formula
9X.p.X; X/ ^ q.X//
is a sentence because it does not have free variable occurrences (the only variable in the formula
is X and all its occurrences are bound).
Logic Programs.
Logic programs are sets of certain formulas of a ï¬rst-order language. A rule is
a formula of the following form:
8X1 : : : 8Xm A1 _    _ Ak _ :L1 _    _ :Ln;
where the Aiâ€™s are atoms, the Ljâ€™s are literals, and X1; : : : ; Xm are all the variables occurring in the
formulaâ€™s atoms and literals. î€€e rule above can be written in the following special form (where
all variables are implicitly assumed to be universally quantiï¬ed at the front of the rule):
A1 _    _ Ak  L1 ^ : : : ^ Ln:
A logic program is a ï¬nite set of rules. With any logic program P we can associate a ï¬rst-order lan-
guage LP whose constants, function symbols, and predicate symbols are exactly those occurring
in P .
A fact is a ground rule with k D 1 and n D 0, that is, a rule of the form
p.t1; : : : ; tk/  ;
where the tiâ€™s are ground terms. For notational simplicity, we will often write this fact simply as
p.t1; : : : ; tk/I
that is, we drop the symbol  .

6
2. LOGIC AND RELATIONAL DATABASES
2.1.2
HERBRAND SEMANTICS
Let L be a ï¬rst-order language whose set of constants is not empty. î€€e Herbrand universe UL
of L is the possibly inï¬nite set of ground terms which can be built using constants and function
symbols of L. î€€e Herbrand base BL of L is the (possibly inï¬nite) set of ground atoms which
can be built using predicate symbols of L and ground terms in UL. A Herbrand interpretation (or
simply interpretation in the following) for L is a subset of the Herbrand base BL.
In order to deï¬ne the notion of satisfaction of a formula by an interpretation, we need the
notion of variable assignment to accommodate variables occurring free in formulas. A variable
assignment is a function assigning each variable to an element of UL and each element of UL to
itself. Given a variable assignment , a variable X, and a ground term t in UL, we use Å’X=tÂ
to denote the variable assignment that is the same as  except that .X/ D t. Below we deï¬ne
when an interpretation I satisï¬es a formula F w.r.t. a variable assignment , denoted I Ë† F .
Let I be an interpretation,  a variable assignment, F and G formulas. î€€en,
â€¢ if F is an atom p.t1; : : : ; tn/, then I Ë† F iï¬€p..t1/; : : : ; .tn// 2 I;
â€¢ I Ë† :F iï¬€I Ë† F does not hold;
â€¢ I Ë† F _ G iï¬€I Ë† F or I Ë† G; and
â€¢ I Ë† 8XF iï¬€I Ë†Å’X=tÂ F for every t 2 UL.
We now deï¬ne when I satisï¬es other kinds of formulas not mentioned above w.r.t.  by
expressing the remaining connectives and the quantiï¬er 9 in terms of :, _, and 8:
â€¢ F ^ G is rewritten as :.:F _ :G/;
â€¢ F ! G is rewritten as :F _ G;
â€¢ F $ G is rewritten as .F ! G/ ^ .G ! F /, which is rewritten as .:F _ G/ ^ .:G _
F /; and
â€¢ 9XF is rewritten as :8X:F .
î€€e diï¬€erence between variables occurring free (for which the considered variable assign-
ment is relevant) and those which are not is important. When interpreting a formula, the only
bindings we need to know are those of free variables; we can change any of other bindings and
still get the same result.
More formally, given an interpretation I, a formula F , and two variable assignments 1
and 2 agreeing on the variables occurring free in F , the following holds: I Ë†1 F iï¬€I Ë†2 F .
As a consequence, if F is a sentence, then I Ë†1 F iï¬€I Ë†2 F for any two variable assignments
1 and 2. î€€us, when F is a sentence, we use I Ë† F to denote that I Ë† F for any variable
assignment . In such a case, we also say that I is a model for F (or F is true in I). Given a set
S of sentences and an interpretation I, we say that I is a model of S iï¬€I is a model of every

2.2. RELATIONAL MODEL
7
sentence in S. We say that S is satisï¬able if there exists a model for it, otherwise it is unsatisï¬able
or inconsistent. If every interpretation is a model of S then S is valid.
Given another set of sentences S0, we say that S semantically implies S0, denoted S Ë† S0,
iï¬€every model of S is also a model of S0. Finally, S and S0 are semantically equivalent iï¬€S Ë† S0
and S0 Ë† S.
2.2
RELATIONAL MODEL
We assume the existence of the following pairwise disjoint sets: a set of constants, a set of attributes,
and a set of relation names. î€€e set of constants is called database domain and will be denoted as
C. Each attribute A is associated with a set of constants called the attribute domain and denoted
as dom.A/. Each relation name r has an arity n, which is a natural number, and is associated with
a ï¬nite sequence of n attributes A1; : : : ; An. A relation schema is of the form r.A1; : : : ; An/. A
relation R over r.A1; : : : ; An/ is a ï¬nite subset of dom.A1/      dom.An/. Each element of R
is called a tuple. Given a tuple t D .a1; : : : ; an/ in R, we use tÅ’AiÂ to denote ai. Likewise, for a
sequence X of attributes Ai1; : : : ; Aim, tÅ’XÂ denotes the tuple .tÅ’Ai1Â; : : : ; tÅ’AimÂ/. Intuitively, R
can be seen as a table where each row is a tuple of R, each column refers to an attribute Ai and
the values contained in the i-th column are taken from the attribute domain dom.Ai/.
A database schema is a set fS1; : : : ; Smg of relation schemas; a database instance (or simply
database) D over such a schema is a ï¬nite set of relations fR1; : : : ; Rmg where each Ri is a relation
over schema Si. If schema Si is of the form ri.A1; : : : ; An/, the extension or instance of relation
name ri in D is Ri.
Query languages are introduced to derive information from databases. A query is a function
that takes as input a database (over a ï¬xed input schema) and gives as output another database
(over a ï¬xed output schema). Queries can be expressed by means of a given query language, such
as the relational algebra, the relational calculus, SQL (Structured Query Language), or Datalog.
î€€e expressive power of a language is measured in terms of the set of queries that can be expressed
using the languageâ€”for this purpose, queries have to be generic, that is, invariant under renamings
of the database domain.
Next, we present the relational algebra and the relational calculus.
2.2.1
RELATIONAL ALGEBRA
î€€e relational algebra extends the algebra of sets and consists of ï¬ve primitive operators deï¬ned
below. Consider two relation schemas r.A1; : : : ; An/ and s.B1; : : : ; Bm/ and let R and S be two
relations over the ï¬rst and second schema, respectively. î€€e primitive relational algebra operators
are deï¬ned as follows:
â€¢ Cartesian product: R  S D f.r1; : : : ; rn; s1; : : : ; sm/ j .r1; : : : ; rn/2R ^ .s1; : : : ; sm/2Sg;
â€¢ Union: R [ S D ft j t 2 R _ t 2 Sg;

8
2. LOGIC AND RELATIONAL DATABASES
â€¢ Diï¬€erence: R   S D ft j t 2 R ^ t â€¦ Sg;
â€¢ Projection: X.R/ D ftÅ’XÂ j t 2 Rg, where X is a sequence of attributes among A1; : : : ; An;
and
â€¢ Selection: F .R/ D ft j t 2 R ^ F.t/g. Here F is an expression built using the logical con-
nectives _, ^, :, and atomic expressions of the form E1 op E2 where op is a comparison
operator, whereas E1 and E2 are constants or attributes names. F.t/ denotes the true/false
value given by evaluating expression F over tuple t.
î€€e relational algebra deï¬ned above is also-called named, since attribute names are used
in the relational algebra operators. In the unnamed relational algebra attributes are referred to by
their positions in the relation schema. So, in the projection and selection operators, we can refer
to an attribute Ai of a relation R over schema r.A1; : : : ; An/ using the expression $i instead of
Ai.
Several derived operators have been deï¬ned as well. Derived operators do not increase the
expressive power of the language (i.e., they do not allow us to express more queries), but are
introduced to make expressions more comprehensible and their evaluation more eï¬ƒcient. For
instance, the derived operators intersection and join are deï¬ned as follows:
â€¢ Intersection: R \ S D ft j t 2 R ^ t 2 Sg D R   .R   S/ D S   .S   R/; and
â€¢ Join:
R â€°F S D f.r1; : : : ; rn; s1; : : : ; sm/ j .r1; : : : ; rn/ 2 R ^ .s1; : : : ; sm/ 2 S ^
F.r1; : : : ; rn; s1; : : : ; sm/g D F .R  S/, where F is a selection expression (here we
are assuming that the schemas of R and S have no common attribute).
In the unnamed relational algebra, the atomic expressions of F are of the form $i op $j,
with 1  i  n and 1  j  m, that is, $i refers to an attribute of R and $j refers to an
attribute of S. î€€us, R â€°F S D F 0.R  S/ where F 0 is obtained from F by replacing
each atomic expression $i op $j with $i op $.n C j/.
Example 2.1
Suppose to have two relations Employee and Department over relation schemas
employee.EmpId; EmpName; Dept/ and department.DeptId; DeptName/, respectively. î€€e query
asking for the names of the employees who work in the department physics can be expressed in
the named relational algebra as:
EmpName
 Employee â€°DeptDDeptId .DeptNameDphysics.Department//

:
In the unnamed relational algebra, the same query can be expressed as follows:
$2
 Employee â€°$3D$1 .$2Dphysics.Department//

:
Notice that in the join condition, $3 refers to the third attribute of Employee whereas $1 refers to
the ï¬rst attribute of Department.

2.2. RELATIONAL MODEL
9
2.2.2
RELATIONAL CALCULUS
î€€e relational calculus, introduced below, is another formalizm to express queries in the relational
model and can be viewed as a specialization of ï¬rst-order logic. More precisely, the language
we present in this subsection is sometimes called domain calculus, because variables range over
the underlying database domain; in tuple calculus, which we do not consider, variables range over
tuples.
Consider the ï¬rst-order language L whose set of constants is the database domain C, the
set of function symbols is empty, and the set of predicate symbols consists of the set of relation
names and comparison predicate symbols. Notice that the Herbrand universe UL is equal to C.
An atom of the form p.t1; : : : ; tn/, where p is a relation name and the tiâ€™s are terms, is called
relation atom; an atom of the form t1 op t2, where op is a comparison predicate symbol and t1, t2
are terms, is called comparison atomâ€”here the inï¬x notation has been used for op. When op is D,
we call the atom equality atom.
Notice that a database D can be seen as a set of facts: if .a1; : : : ; an/ is a tuple belonging to
the extension of a relation name r in D, then we have a fact r.a1; : : : ; an/. î€€us, in the following
we will look at databases as ï¬nite sets of facts. î€€is also means that a database D can be seen
as a (ï¬nite) Herbrand interpretation for L. As a consequence, we can deï¬ne when a database D
satisï¬es a formula F w.r.t. a variable assignment , denoted D Ë† F , in the same way as deï¬ned
for interpretations in Section 2.1.2â€”in this regard, notice that if F is a comparison atom t1 op t2,
then D Ë† F iï¬€.t1/ op .t2/ holds.
A relational calculus query is an expression of the form:
f.u1; : : : ; un/ j F g;
where the uiâ€™s are terms of L, F is a formula of L, and the variables in .u1; : : : ; un/ are exactly
the variables occurring free in F . Notice that each ui is either a constant or a variable (as L does
not have function symbols) and the same term can be repeated in .u1; : : : ; un/.
Example 2.2
Consider again the database schema consisting of the two relation schemas
employee.EmpId; EmpName; Dept/ and department.DeptId; DeptName/. î€€e query asking for the
names of the employees working in the physics department can be expressed with the following
relational calculus query:
f.Y / j 9X 9Z employee.X; Y; Z/ ^ department.Z; physics/g:
Given a database D and a relational calculus query Q of the form f.u1; : : : ; un/ j F g, the
semantics of Q over D is
Q.D/ D f..u1/; : : : ; .un// j  is a variable assignment and D Ë† F g:
We also say that tuples in Q.D/ are the answers to Q over D.

10
2. LOGIC AND RELATIONAL DATABASES
In the ï¬rst-order language L considered so far, the set of constants is equal to the database
domain C. î€€e semantics above can be generalized to allow explicit speciï¬cation of the underlying
domain to use (i.e., the set of constants over which variables may range). î€€e active domain of a
database D, denoted adom.D/, is the set of constants appearing in D. Likewise, we use adom.Q/
and adom.F / to denote the set of constants appearing in a relational calculus query Q and formula
F , respectively. î€€e semantics of a relational calculus query over a database with respect to a
particular domain C0, called evaluation domain, is deï¬ned as seen before except that the underlying
set of constants of the language is C0 and the range of variable assignment is C0 rather than C.
Notice that the supersets of adom.D/ [ adom.Q/ are the only domains with respect to which it
makes sense to evaluate Q over D, so we assume .adom.D/ [ adom.Q//  C0  C. In order to
specify the evaluation domain C0 w.r.t. which a query is evaluated we use the notation QC0.D/.
Note that if C0 is inï¬nite, then QC0.D/ can be an inï¬nite set of tuples.
Domain Independent and Safe Relational Calculus Queries.
A relational calculus query Q
is domain independent if for every database D, and every pair C0, C00 such that .adom.D/ [
adom.Q//  C0; C00  C, it is the case that QC0.D/ D QC00.D/. î€€us, for an arbitrary database,
a domain independent relational calculus query gives the same result regardless of the do-
main with respect to which is evaluated. In other words, if Q is domain independent, then
QC0.D/ does not change when C0 changes. î€€is means that QC0.D/ can be computed for
C0 D adom.D/ [ adom.Q/.
Example2.3
Consider the relation schema r.A; B/ and the following relational calculus queries:
Q1 D f.X; Y / j 9U 9Z .r.U; Z/ _ r.X; Y //g,
Q2 D f.X; Y / j :r.X; Y //g,
Q3 D f.X/ j 8Y r.X; Y //g.
All the queries above are not domain independent. To see why, consider a relation R D
f.a; a/; .a; b/g and let C0 be a domain. It is easy to check that Q1
C0.fRg/ D f.x; y/ j x 2 C0 ^ y 2
C0g and Q2
C0.fRg/ D f.x; y/ j x 2 C0 ^ y 2 C0 ^ .x; y/ 62 Rg.
As the results of Q1 and Q2 contain values of C0, then their results clearly depend on C0.
It is easy to see that Q3 will always contain values taken from the input relation; nevertheless, it
is not domain independent. In fact, it is easy to see that if C0 is inï¬nite, then Q3
C0.fRg/ is empty.
î€€e same holds if, for instance, C0 D fa; b; cg. However, if C0 D fa; bg, then Q3
C0.fRg/ D f.a/g.
Hence, Q3 can give diï¬€erent results over the same relation when diï¬€erent evaluation domains
are considered.
On the other hand, it is easy to see that the following queries are domain independent, as
the query answers depend only on the content of the input database:
Q4 D f.X; Y / j 9Z.r.X; Z/ ^ r.Z; Y //g,

2.2. RELATIONAL MODEL
11
Q5 D f.X; Y / j r.X; Y //g.
î€€e problem of deciding whether a relational calculus query is domain independent is un-
decidable [Abiteboul et al., 1995, Ullman, 1988]. It is important to observe that the fact that we
can express relational calculus queries that are not domain independent is not a positive aspect
as, in the presence of an inï¬nite database domain, we can get query answers that have an inï¬nite
number of tuples.
We now present some syntactical restrictions that lead to a class of relational calculus
queries, called safe, that are guaranteed to be domain independent. Safe relational calculus queries
are a subset of the domain independent relational calculus queries [Abiteboul et al., 1995, Ullman,
1988].
Safe relational calculus is derived from relational calculus by imposing the following re-
strictions on formulas.
1. î€€e universal quantiï¬er 8 is not used. î€€is does not aï¬€ect the expressiveness of the language
as expressions of the form 8XF can be rewritten as :.9X:F /.
2. î€€e disjunction operator is applied only to formulas having the same set of free variables.
3. For any maximal sub-formula F of the form F1 ^    ^ Fn, all the free variables of F must
be limited in the following sense:
â€¢ a variable is limited if it is free in some Fi and Fi is not a comparison atom and is not
negated;
â€¢ if Fi is of the form X D c or c D X, where X is a variable and c is a constant, then X
is limited; and
â€¢ if Fi is of the form X D Y or Y D X, where X, Y are variables and Y is limited, then
X is limited.
4. Negation is applied only to an Fi in a maximal sub-formula F of the form F1 ^    ^ Fn
where all free variables are limited.
î€€e safe relational calculus and the relational algebra have the same expressive power, that
is, the set of queries that can be expressed by them is the same.
Example 2.4
î€€e relational calculus queries Q4 and Q5 of Example 2.3, which are domain
independent, are also safe. î€€e relational calculus query Q D f.X; Y; Z/ j F g, where F is the
following formula
r.X; Y; Z/ ^ :.p.X; Y / _ q.Y; Z//;
is domain independent but is not safe because F violates Condition 2â€”speciï¬cally, Condition 2
is violated by the subformula p.X; Y / _ q.Y; Z/. On the other hand, if F is the formula below,

12
2. LOGIC AND RELATIONAL DATABASES
then the relational calulus query is safe
r.X; Y; Z/ ^ :p.X; Y / ^ :q.Y; Z/:
2.2.3
CONJUNCTIVE QUERIES
Conjunctive queries (ï¬rst introduced in Chandra and Merlin, 1977) are a natural class of com-
monly arising queries that enjoy diï¬€erent desirable properties (e.g., checking for equivalence and
containment of conjunctive queries is decidable). î€€ey can be expressed in the languages seen so
far as follows.
â€¢ Relational calculus: relational calculus queries of the form fY j 9X r1.U 1/ ^    ^ rk.U k/g
where Y is a tuple of variables (that must appear in the conjunction) and constants, X is the
tuple of variables in the conjunction that are not in Y , the riâ€™s are relation names, and the
U iâ€™s are tuples of terms (i.e., variables and constants). Notice that relational calculus queries
of this form are safe, and thus, domain independent.
â€¢ Relational algebra: relational algebra queries using only positive selection (i.e., selection
conditions are restricted to be conjunctions of equalities), projection, and Cartesian product.
Example 2.5
î€€e relational calculus query of Example 2.2 is conjunctive. î€€e relational algebra
query of Example 2.1 can be rewritten into the following equivalent conjunctive query (recall that
the join operator is a derived operator that can be expressed by means of Cartesian product and
selection):
EmpName

DeptDDeptId
 Employee  .DeptNameDphysics.Department//

:
2.2.4
DATA DEPENDENCIES
Data dependencies are used to express integrity constraints on data, that is semantic properties
that database instances should satisfy to properly reï¬‚ect the real state of the world. Data depen-
dencies are also used in database schema design to deï¬ne normal forms, that is, conditions that a
â€œgoodâ€ relational database schema has to satisfy in order to reduce or eliminate redundant infor-
mation. Recent years have seen a renewed interest in data dependencies since they play a central
role in several current database applications such as data exchange and integration [Fagin et al.,
2005, Lenzerini, 2002] and ontology management [CalÃ¬ et al., 2009a,b]. For a more complete
treatment of the subject we refer to Abiteboul et al. [1995] and Greco et al. [2012a].
An embedded dependency is a ï¬rst-order logic sentence of the form:
8X; 8Y ..X; Y / ! 9Z  .X; Z//;

2.2. RELATIONAL MODEL
13
where X, Y , and Z are tuple of variables, .X; Y / and  .X; Z/ are conjunctions of relation
and equality atoms, called the body and the head of the dependency, respectively. Without loss of
generality we can assume that equality atoms may appear only in the head of the dependency and
there is no existentially quantiï¬ed variable involved in an equality atom.
Subclasses of embedded dependencies are:
â€¢ unirelational dependencies: only one relational symbol is used in  and  ;
â€¢ 1-head dependencies: only a single atom in the head;
â€¢ tuple generating dependencies (TGDs): no equality atoms;
â€¢ full dependencies: no existentially quantiï¬ed variables Z; and
â€¢ equality generating dependencies (EGDs): full, 1-head with an equality atom in the head.
Example 2.6
Consider the database schema consisting of the two relation schemas
employee.EmpId; EmpName; Dept/ and department.DeptId; DeptName/. î€€e following equality
generating dependency states that, given a database D over the schema above, the instance of
department in D cannot contain two distinct tuples with the same value on DeptId.
8D; N1; N2 .department.D; N1/ ^ department.D; N2/ ! N1 D N2/
î€€e previous dependency is a functional dependency (in particular, a key dependency) and DeptId is
a key of department [Abiteboul et al., 1995, Greco et al., 2012a].
In general, a functional dependency is an equality generating dependency of the form
8X; Y 1; Y 2; Z1; Z2 .p.X; Y 1; Z1/ ^ p.X; Y 2; Z2/ ! Z1 D Z2/;
where p.X; Y 1; Z1/ and p.X; Y 2; Z2/ are relation atoms with X, Y 1, Y 2, Z1, and Z2 being lists
of variables. î€€is functional dependency can be expressed also as A ! B, where A is the set of
attributes of p corresponding to X and B is the set of attributes of p corresponding to Z1 (and
Z2). A relation R over the schema of p satisï¬es such a functional dependency if, for every two
tuples t1; t2 2 R, if t1Å’AÂ D t2Å’AÂ then t1Å’BÂ D t2Å’BÂ.
î€€e following tuple generating dependency states that, given a database D over the schema
above, for every tuple t in the instance of employee in D, there must be a tuple t0 in the instance
of department in D s.t. tÅ’DeptÂ D t0Å’DeptIdÂ
8E; N; D .employee.E; N; D/ ! 9M department.D; M//:
î€€e previous dependency is also called inclusion dependency.

14
2. LOGIC AND RELATIONAL DATABASES
Dependency Skolemization.
Given a TGD d of the form
8X; 8Y ..X; Y / ! 9Z1; : : : ; Zn  .X; Z1; : : : ; Zn//
the skolemized version of d, denoted sk.d/, is the following sentence
8X; 8Y ..X; Y / !  .X; f d
Z1.X; Y /; : : : ; f d
Zn.X; Y ///;
where each f d
Zi is a fresh function symbol of arity jXj C jY j. î€€us, existentially quantiï¬ed vari-
ables in the head of d are replaced by skolemized terms. For a full data dependency d (including
EGDs), sk.d/ D d.
2.3
COMPLEXITY CLASSES
Let Ë™ be a ï¬nite alphabet and L  Ë™ be a language in Ë™, that is, a set of ï¬nite strings over
Ë™. Let T be a Deterministic Turing Machine (DTM) or a Nondeterministic Turing Machine
(NDTM), such that (i) if x 2 L, then T accepts x, and (ii) if x 62 L, then T rejects x. In this
case, we say that T decides L. In addition, if T halts in time O.f .n//, we say that T decides L in
time O.f .n//. Similarly, if T halts within space O.f .n//, we say that T decides L within space
O.f .n// (for details on DTM and NDTM, see Johnson [1990] and Papadimitriou [1994]).
We deï¬ne the following sets of languages:
TIME.f .n//
D
fL j L is a language decided by some DTM in time O.f .n//g
NTIME.f .n//
D
fL j L is a language decided by some NDTM in time O.f .n//g
SPACE.f .n//
D
fL j L is a language decided by some DTM within space O.f .n//g
NSPACE.f .n//
D
fL j L is a language decided by some NDTM within space O.f .n//g:
All these sets are examples of complexity classes. Complexity classes of most interest are not
classes corresponding to particular functions but their unions such as, for example, the union
[d>0TIME.nd/ taken over all polynomials of the form nd. Some common complexity classes are:
P
D
S
d>0 TIME.nd/
NP
D
S
d>0 NTIME.nd/
EXPTIME
D
S
d>0 TIME.2nd /
NEXPTIME
D
S
d>0 NTIME.2nd /
PSPACE
D
S
d>0 SPACE.nd/
EXPSPACE
D
S
d>0 SPACE.2nd /
L
D
SPACE.log n/
NL
D
NSPACE.log n/:
î€€e list does not contain the nondeterministic counterparts of PSPACE and EXPSPACE because
S
d>0 NSPACE.nd/ coincides with the class PSPACE and S
d>0 NSPACE.2nd / coincides with the
class EXPSPACE.

2.3. COMPLEXITY CLASSES
15
î€€e complementary class of a complexity class C, denoted co-C, is deï¬ned as follows. For
every language L in Ë™, let L denote its complement, that is, the set Ë™nL. î€€en, co-C is fL j L 2
Cg.
Below we deï¬ne the polynomial hierarchy classes. In order to do it, we ï¬rst need to introduce
oracle Turing machines. Let A be a language. An oracle DTM T A, also-called a DTM with oracle
A, can be thought of as an ordinary DTM augmented by an additional write-only query tape
and additional three states query, 2, and 62. When T A is not in the state query, the computation
proceeds as usual (in addition, T A can write on the query tape). When T A is in query, T A changes
this state to 2 or 62 depending on whether the string written on the query tape belongs to A;
furthermore, the query tape is instantaneously erased. As in the case of an ordinary DTM, the
expended time is the number of steps and the required space is the number of cells used on the
tape and the query tape. î€€e oracle replies to a query in unit time, and thus, roughly speaking,
models a call to a subroutine that is evaluated in unit time. An oracle NDTM is deï¬ned as the
same augmentation of a NDTM.
Let C be a set of languages. î€€e complexity classes PC and NPC are deï¬ned as follows. Given
a language L, we have L 2 PC (resp. L 2 NPC) if and only if there is some language A 2 C and
some oracle DTM (resp. NDTM) T A such that T A decides L in polynomial-time. î€€e polynomial
hierarchy consists of classes p
i , Ë™p
i , and Ë˜ p
i deï¬ned as follows:
p
0 D Ë™p
0 D Ë˜ p
0 D P
p
iC1 D PË™p
i
for i  0
Ë™p
iC1 D NPË™p
i
for i  0
Ë˜ p
iC1 D co-Ë™p
iC1
for i  0:
î€€e class PH is deï¬ned as S
i0 Ë™p
i . Notice that NP D Ë™p
1 , co-NP D Ë˜ p
1 , and p
2 D PNP.
Let L1 and L2 be languages. Assume that there is a DTM R such that (i) for all input
strings x, we have x 2 L1 if and only if R.x/ 2 L2, where R.x/ denotes the output of R on input
x; and (ii) R halts within space O.log n/. î€€en, R is called a logarithmic-space reduction from
L1 to L2 and we say that L1 is reducible to L2. Let C be a set of languages. A language L is
called C-hard if any language L0 in C is reducible to L. If L is C-hard and L 2 C, then L is called
C-complete or complete for C.
BIBLIOGRAPHIC NOTES
Relational model and relational algebra were introduced by Codd [1970]. Codd [1972] introduced
relational calculus showing its equivalence with relational algebra. For a more complete treatment
of relational databases the reader is referred to Abiteboul et al. [1995], Date [2000], Elmasri and
Navathe [2000], Garcia-Molina et al. [2009], Maier [1983], Ramakrishnan and Gehrke [2003],
Silberschatz et al. [2010], Ullman [1988]. For a more complete treatment of logic programming
we refer to Apt [1991], Lloyd [1987], while for a detailed exposition of complexity notions we
refer to Johnson [1990] and Papadimitriou [1994].


17
C H A P T E R
3
Datalog
Datalog is a declarative query language for relational databases based on the logic programming
paradigm. From a syntactical standpoint, an important diï¬€erence between Datalog and logic pro-
grams is that function symbols are not allowed in Datalog. For a long time, relational calculus and
algebra were considered the relational database languages. However, there are simple operations,
such as computing the transitive closure of a graph, which cannot be accomplished with those lan-
guages. One of the peculiarities that distinguishes Datalog from the query languages presented
in the previous chapter is recursion, which gives Datalog the capability to express queries like
computing a graph transitive closure.
3.1
SYNTAX
A Datalog rule r is (a logic program rule) of the form:
A0  A1; : : : ; An;
where n  0, the Aiâ€™s are atoms where no function symbol appears, and every variable appearing
in A0 also appears in at least one of A1; : : : ; An. î€€e last requirement is called safety and is used to
avoid rules yielding inï¬nite relations from ï¬nite ones. Comparison operators are not allowed in a
Datalog rule. A0 is called the head of r and is denoted by head.r/; the conjunction A1; : : : ; An is
called the body of r and is denoted by body.r/. With a slight abuse of notation, body.r/ will be also
used to denote the set of atoms appearing in the body of r. î€€e intuitive meaning of the Datalog
rule above is that if A1; : : : ; An are all true, then A0 has to be true. A fact is a ground rule with
empty body; we call it a p-fact if p is the predicate symbol in the head. For notational simplicity,
we will often write a fact simply as A0: rather than A0  :, that is, we drop the symbol  .
A Datalog program is a ï¬nite set of Datalog rules. î€€e deï¬nition of a predicate symbol p
in a program P , denoted def.p; P /, is the set of rules of P having p in the head atom. Recall
that a database can be seen as a ï¬nite set of facts. In the context of logic programming all the
knowledge (facts and general rules) is usually contained in a single logic program. As Datalog has
been developed for database applications, we will consider two sets of Datalog rules:
1. a set of facts D representing tuples of a database; and
2. a Datalog program P whose rules deï¬ne new relations (or â€œviewsâ€) from the database.
D is called the Extensional Database (EDB) and P is called the Intensional Database (IDB). We
will refer to D simply as database and refer to P as Datalog program. î€€us, predicate symbols are

18
3. DATALOG
partitioned into two disjoint sets: base (or EDB or extensional) and derived (or IDB or intensional)
predicate symbols. î€€e deï¬nition of base predicate symbols is stored in D. Base predicate symbols
can appear in the body of rules in P but not in the head. Derived predicate symbols cannot appear
in D and their deï¬nition is in P . We will use PD to denote P [ D. An atom whose predicate
symbol is base (resp. derived) is also-called a base (resp. derived) atom.
Example 3.1
î€€e following database stores the edges of a directed graph by means of facts of
the form edge.v1; v2/, meaning that there is an edge from vertex v1 to vertex v2 in the graph:
edge.a; b/:
edge.b; c/:
edge.c; d/:
Below is a Datalog program to compute the transitive closure of a graph stored by means of
edge-facts:
tc.X; Y /  edge.X; Y /:
tc.X; Y /  edge.X; Z/; tc.Z; Y /:
Intuitively, the ï¬rst rule above says that if there is an edge from a vertex X to a vertex Y , then
.X; Y / belongs to the transitive closure of the graph. î€€e second rule says that if there is an edge
from a vertex X to a vertex Z and there exists a vertex Y such that .Z; Y / belongs to the transitive
closure, then .X; Y / belongs to the transitive closure as well.
It is worth noting that the transitive closure of a graph cannot be expressed using the rela-
tional algebra and calculus [Aho and Ullman, 1979].
î€€e dependency graph GP of a Datalog program P is a directed graph deï¬ned as follows:
the set of vertices is the set of derived predicate symbols appearing in P ; for each pair of derived
predicate symbols p and p0 (not necessarily distinct) appearing in P , there is an edge from p0 to
p iï¬€P contains a rule where p0 appears in the body and p appears in the head. Program P is said
to be recursive if the dependency graph GP is cyclic. A derived predicate symbol p is said to be
recursive if it occurs in a cycle of GP ; two predicate symbols p and p0 are mutually recursive if they
occur in the same cycle. As an example, the Datalog program of Example 3.1 is recursive as its
dependency graph has an edge from tc to tc. A predicate symbol p depends on a predicate symbol
p0, denoted p0  p, if there is a path from p0 to p in GP ; leq.p/ denotes the set of all predicate
symbols p0 for which p0  p.
Given a Datalog program P , a rule in P with head predicate symbol p is linear if there is
at most one atom in the body of the rule whose predicate symbol is mutually recursive with p. If
each rule in P is linear, then P is linear. Clearly, the Datalog program of Example 3.1 is linear.
Conjunctive queries can be expressed by non-recursive Datalog programs with only base
predicate symbols occurring in the body. More precisely, a conjunctive query can be expressed by
means of a Datalog rule of the form
ans.X/  r1.X1/; : : : ; rn.Xn/;

3.2. SEMANTICS
19
where ans is a derived predicate symbol, X is a tuple of variables (that must appear in the rule
body) and constants, the riâ€™s are base predicate symbols, and the Xiâ€™s are tuples of terms (i.e.,
variables and constants).
Example 3.2
Consider again the database schema consisting of the two relation schemas
employee.EmpId; EmpName; Dept/ and department.DeptId; DeptName/. î€€e query asking for the
names of the employees working in the physics department can be expressed with the following
Datalog rule:
ans.Y /  employee.X; Y; Z/; department.Z; physics/:
3.2
SEMANTICS
In this section, we report three semantics for Datalog programs. î€€ese semantics are â€œequivalentâ€
in that they give the same extensions to derived predicate symbols.
3.2.1
MODEL-THEORETIC SEMANTICS
Let P be a Datalog program and D a database. î€€e Herbrand universe HPD of PD is the set of
constants appearing in PD. î€€e Herbrand base BPD of PD is the set of ground atoms which can
be built using predicate symbols appearing in PD and constants of HPD.
A (ground) atom A0 is a ground instance of an atom A if A0 can be obtained from A by
substituting every variable in A with some constant in HPDâ€”with multiple occurrences of the
same variable being replaced with the same constant. We use ground.A/ to denote the set of
all ground instances of A. Likewise, a (ground) rule r0 is a ground instance of a rule r in PD if
r0 can be obtained from r by substituting every variable in r with some constant in HPD. î€€e
ground instantiation of r, denoted ground.r/, is the set of all ground instances of r. î€€e ground
instantiation of PD, denoted ground.PD/, is the set of all ground instances of the rules in PD,
that is, ground.PD/ D [r2PDground.r/.
An interpretation of PD is any subset I of BPD. î€€e truth value of a ground atom A w.r.t.
I, denoted valueI.A/, is true if A 2 I, false otherwise. î€€e truth value of a conjunction of ground
atoms A1; : : : ; An w.r.t. I is true if every Ai (1  i  n) is true w.r.t. I; otherwise, the truth value
of the conjunction w.r.t. I is false. Notice that if n D 0, the conjunction is empty and its truth
value w.r.t. I is true. A ground rule r is satisï¬ed by I, denoted I Ë† r, if the conjunction in the
body is false w.r.t. I or the head atom is true w.r.t. I; we write I 6Ë† r if r is not satisï¬ed by I.
î€€us, a ground rule r with empty body is satisï¬ed by I if valueI.head.r// D true.
An interpretation of PD is a model of PD if it satisï¬es every ground rule in ground.PD/. A
model M of PD is minimal if no proper subset of M is a model of PD.

20
3. DATALOG
It is well known that PD has a unique minimal model, which coincides with the intersection
of all models of PD, and thus is the least (under set inclusion) model of PD. î€€e model-theoretic
semantics of PD is given by its (unique) least model.
î€€us, the model-theoretic semantics for a Datalog program is given by a minimal set of
ground atoms satisfying the ground instantiation of the program. î€€e minimality requirement is
because the model should not contain more ground atoms than necessary to satisfy the ground
rules in ground.PD/. In this way, the least model contains exactly the atoms in D plus those that
are semantically implied by D [ P as a ï¬rst-order theory.
Example 3.3
Let D be the database and P the Datalog program of Example 3.1. It is easy to
see that an interpretation of PD satisï¬es all ground rules of PD iï¬€it contains at least the following
set M of ground atoms:
edge.a; b/:
tc.a; b/:
tc.a; c/:
edge.b; c/:
tc.b; c/:
tc.b; d/:
edge.c; d/:
tc.c; d/:
tc.a; d/:
Indeed, M is the least model of PD. Notice that M is a model of PD and no proper subset of it
is a model of PD.
3.2.2
FIXPOINT SEMANTICS
î€€e ï¬xpoint semantics is an operational semantics given in terms of an operator called the im-
mediate consequence operator. Intuitively, this operator derives new ground atoms starting from
known ground atoms, using the rules of a Datalog program.
Let P be a Datalog program and D a database. î€€e immediate consequence operator TPD of
PD is deï¬ned as follows. Given a set I of ground atoms, then
TPD.I/ D fA0 j A0  A1; : : : ; An is a ground rule in ground.PD/ and
Ai 2 I for every 1  i  ng:
î€€us, TPD takes as input a set of ground atoms I and returns as output a set of ground
atoms TPD.I/, called the immediate consequences of I w.r.t. PD. Clearly, for every fact in D, its
head is an immediate consequence of any set I of ground atoms as the fact body is empty. We say
that a set of ground atoms I is a ï¬xpoint of TPD if TPD.I/ D I.
It is easy to see that TPD is monotonic, that is, if I1  I2, then TPD.I1/  TPD.I2/, for
any sets of ground atoms I1 and I2. By the Knaster-Tarski theorem, since TPD is monotonic it
has a least ï¬xpoint (that is, a ï¬xpoint that is included in any other ï¬xpoint), which we denote as
lfp.TPD/. î€€e ï¬xpoint semantics of PD is given by the least ï¬xpoint lfp.TPD/.
î€€e least ï¬xpoint can be computed as follows. î€€e i-th iteration of TPD (i  1) w.r.t. I
is deï¬ned as follows: T 1
PD.I/ D TPD.I/ and T i
PD.I/ D TPD.T i 1
PD .I// for i > 1. By iteratively
applying TPD we always reach a ï¬xpoint in a ï¬nite number of iterations, that is, there always
exists a ï¬nite n such T i
PD.I/ D T n
PD.I/ for any i  n. Such a ï¬xpoint is denoted as T 1
PD.I/. î€€e

3.2. SEMANTICS
21
least ï¬xpoint of TPD can be computed by iteratively applying TPD starting from the empty set,
that is, lfp.TPD/ D T 1
PD.;/.
î€€e least model of PD, discussed in the previous section, is equal to lfp.TPD/. î€€us, this
approach provides an alternative constructive deï¬nition of the semantics of a Datalog program.
Example 3.4
Let D be the database and P the Datalog program of Example 3.1.
T 1
PD.;/ D
I1 D
TPD.;/ D
fedge.a; b/; edge.b; c/; edge.c; d/g
T 2
PD.;/ D
I2 D
TPD.I1/ D
I1 [ ftc.a; b/; tc.b; c/; tc.c; d/g
T 3
PD.;/ D
I3 D
TPD.I2/ D
I2 [ ftc.a; c/; tc.b; d/g
T 4
PD.;/ D
I4 D
TPD.I3/ D
I3 [ ftc.a; d/g
T 5
PD.;/ D
I5 D
TPD.I4/ D
I4:
î€€us, I4 is the least ï¬xpoint of TPD, and, indeed, it is equal to the least model of PD (cf. Exam-
ple 3.3).
3.2.3
PROOF-THEORETIC SEMANTICS
î€€e last semantics for Datalog programs is based on proofs. Speciï¬cally, the proof-theoretic se-
mantics deï¬nes the semantics of a Datalog program P and a database D in terms of the set of
ground atoms that can be proven from D using the Datalog rules of P as proof rules.
First of all, we need to deï¬ne a proof. A proof tree of a ground atom A from a database D
and a Datalog program P is a labeled tree where:
â€¢ each vertex of the tree is labeled with a ground atom;
â€¢ each leaf is labeled with a ground atom for which there is a fact in D;
â€¢ the root is labeled by A;
â€¢ for each internal vertex labeled with A0, there exists a ground rule A0  A1; : : : ; An in
ground.P / such that the vertex children are A1; : : : ; An.
Proof trees provide proofs of ground atoms. Given a ground atom A to prove, one can
look for a proof either in a bottom-up or in a top-down fashion. î€€e bottom-up approach is an
alternative way of looking at the ï¬xpoint semantics. One begins with the ground atoms in facts
of D and then uses rules of P to infer new ground atoms as done by the immediate consequence
operator. î€€is is iteratively done until no new facts can be derived.
î€€e top-down approach searches for a proof starting from a particular atom or set of atoms.
In a sense, the top-down approach tries to avoid the inference of atoms that are irrelevant for
proving the atoms of interest. Before presenting the details of a top-down procedure called SLD
resolution, we introduce some additional notions.

22
3. DATALOG
A goal clause in an expression of the form
 B1; : : : ; Bm;
where m  0 and the Biâ€™s are atoms (with no function symbols). When m D 0 the goal clause is
called empty goal clause and is denoted as .
A substitution  is a ï¬nite mapping from variables to terms and is written as  D
fX1=t1; : : : ; Xn=tng where the Xiâ€™s are distinct variables and the tiâ€™s are terms. We also as-
sume that Xi Â¤ ti for every 1  i  n. î€€e result of applying  to an expression E (e.g., a
term, an atom, a goal clause, etc.), denoted E, is the expression obtained from E by simul-
taneously replacing each occurrence of a variable Xi in E with ti iï¬€Xi=ti belongs to . Sub-
stitutions can be composed as follows. Given two substitutions  D fX1=t1; : : : ; Xn=tng and
# D fY1=u1; : : : ; Ym=umg, their composition, denoted  Ä± #, is the substitution obtained from
the set fX1=t1#; : : : ; Xn=tn#; Y1=u1; : : : ; Ym=umg by removing every Xi=ti# such that Xi D ti#
and every Yj =uj such that Yj 2 fX1; : : : ; Xng. A substitution  is more general than a substitution
# if there exists a substitution  such that # D  Ä± .
Example 3.5
Consider the atom A D p.X; Y / and the substitution  D fX=b; Y=Xg. î€€en,
A D p.b; X/. Consider now two substitutions  D fX=Y; Y=Zg and # D fX=a; Y=b; Z=Y g.
î€€en,  Ä± # D fX=b; Z=Y g.
Given two atoms A1 and A2, a uniï¬er of A1 and A2 is a substitution  such that A1 D A2.
When a uniï¬er of A1 and A2 exists, we say that A1 and A2 are uniï¬able. A uniï¬er  of A1 and A2
is called a most general uniï¬er (mgu) of A1 and A2 if it is more general than any other uniï¬er of
A1 and A2. If there exists a uniï¬er of A1 and A2, then there exists an mgu of A1 and A2. Indeed,
the mgu is unique modulo renaming of variables. î€€ere exists an algorithm that yields an mgu
for any two atoms if they are uniï¬able and report nonexistence of a uniï¬er otherwise (for more
details, see, e.g., Lloyd [1987] and Apt [1991]).
Example 3.6
î€€e two atoms A1 D p.X; Z/ and A2 D p.Y; a/ are uniï¬able, as, for instance, a
uniï¬er is  D fX=a; Y=a; Z=ag. A most general uniï¬er of A1 and A2 is  D fY=X; Z=ag. Notice
that  D  Ä± fX=ag and thus  is more general than .
In order to ï¬nd a proof for B1; : : : ; Bm, SLD resolution starts with the goal clause  
B1; : : : ; Bm; then, it iteratively derives a new goal clause from a previous goal clause (as described
in the following) until the empty goal clause is reachedâ€”when the empty goal clause is reached
the procedure is successful. Below we detail SLD resolution. Let gc be a non-empty goal clause
of the form
 B1; : : : ; Bi 1; Bi; BiC1; : : : ; Bm;
and r be a Datalog rule of the form
A0  A1; : : : ; An

3.2. SEMANTICS
23
such that gc and r have no variable in common (this can always be ensured by renaming variables
of r) and Bi, A0 have an mgu . î€€en, the resolvent of gc and r using  is the goal clause
 .B1; : : : ; Bi 1; A1; : : : ; An; BiC1; : : : ; Bm/
and Bi is called the selected atom of gc.
Let P be a Datalog program, D a database, and gc a goal clause. An SLD derivation from gc
with PD is a sequence gc0; gc1; gc2; : : : of goal clauses and a sequence 1; 2; : : : of substitutions
such that
â€¢ gc0 D gc, and
â€¢ gci is the resolvent of gci 1 and some rule in PD using i, for i  1.
An SLD derivation can be ï¬nite or inï¬nite. An SLD refutation of gc with PD is an SLD derivation
gc; gc1; : : : ; gck from gc with PD s.t. gck D .
SLD resolution is a technique that provides proofs of atoms. An SLD refutation of a goal
clause gc of the form  B1; : : : ; Bm with PD means that from the assumption that the goal clause
gc holds in the presence of PD, we get the empty clause , which stands for a contradiction. î€€is
can be viewed as a proof of the negation of gc from PD, that is, the proof of 9XB1 ^    ^ Bm,
where X are all variables in gc (variables X are implicitly universally quantiï¬ed at the begin-
ning of gc). Moreover, an SLD refutation whose sequence of substitutions is 1; : : : ; k pro-
vides a proof of .B1 ^    ^ Bm/1 Ä±    Ä± k. Importantly, SLD resolution produces only correct
proofs (soundness) and and all true facts (completeness). More formally, let P be a program, D
a database, and gc a goal clause  B1; : : : ; Bm. If there exists an SLD refutation of gc with PD
whose substitutions are 1; : : : ; k, then PD semantically implies .B1 ^    ^ Bm/1 Ä±    Ä± k. If
PD semantically implies :gc, then there exists a refutation of gc with PD.
As SLD resolution is sound and complete, it provides an adequate top-down technique for
obtaining the ground atoms in the answer to a Datalog program. To prove that a ground atom
is in the answer, one must search for a refutation of the corresponding goal clause, and there can
be many of them. î€€ere are two sources of nondeterminism in searching for a refutation: (i) the
choice of the selected atom and (ii) the choice of the rule whose head atom uniï¬es with the chosen
atom. Assuming a rule for choosing which atom to select at each step in a refutation (e.g., as in
Prolog, always take the leftmost atom) we can systematically search for all possible unifying rules.
It turns out that the proof-theoretic semantics gives the same set of ground atoms as the
model-theoretic and the ï¬xpoint semantics. î€€us, a ground atom A is in the least model of a
program iï¬€there is a proof tree for A from D and P .
Example 3.7
Let D be the database and P the Datalog program of Example 3.1. Suppose we
want to ï¬nd a proof a tc.a; c/. An SLD refutation of  tc.a; c/ with PD, where the selected atom
is always the leftmost, is as follows. We start with the goal clause
 tc.a; c/:

24
3. DATALOG
î€€e resolvent of the goal clause above and the second rule of P using  D fX=a; Y; cg is the goal
clause
 edge.a; Z/; tc.Z; c/:
î€€e resolvent of the goal clause above and the ï¬rst fact of D using  D fZ=bg is the goal clause
 tc.b; c/:
î€€e resolvent of the goal clause above and the ï¬rst rule of P using  D fX=b; Y=cg is the goal
clause
 edge.b; c/:
î€€e resolvent of the goal clause above and the second fact of using the empty substitution is the
empty goal clause  and thus tc.a; c/ is successfully proven.
3.3
PROGRAM EVALUATION
In this section, we report algorithms to evaluate a Datalog program P over a database D, that is,
to compute the semantics of PD.
3.3.1
EVALUATION OF NON-RECURSIVE PROGRAMS
We start by presenting an algorithm to evaluate non-recursive Datalog programs.
î€€e algorithm to evaluate a non-recursive program P over a database D consists of deriving
a relational algebra expression for each derived predicate symbol p of P ; the evaluation of this
expression over D yields the same answer relation for p as when P is evaluated over D. If a
program P is not recursive, then its dependency graph GP has no cycles and thus it is possible to
determine a topological sorting of the graph, that is, an ordering p1; : : : ; pn of the graph vertices
such that if .pi; pj / is an edge of GP , then pi comes before pj in the ordering. î€€e relational
algebra expressions for the derived predicate symbols of P are computed following the order
determined by a topological sorting of GP . î€€e expression for a predicate symbol p is obtained
by computing an expression for each rule having p in the head and then taking the union of the
expressions obtained for all rules having p in the head.
Let r be a rule of the form
A0  A1; : : : ; An;
where A0 is an atom of the form p.t1; : : : ; tm/, and, for ease of presentation, assume the tiâ€™s are all
variables. Moreover, assume to have a relation Ri for each atom Ai in the body of râ€”evaluating
rules according to a topological sorting of GP ensures that we always have a relation for each atom
appearing in the body of r. If two atoms Ai and Aj have the same predicate symbol, then Ri and
Rj are the same relation. We deï¬ne Eval-rule.r; R1; : : : ; Rn/ as the relational algebra expression
obtained as follows.

3.3. PROGRAM EVALUATION
25
1. Let E be the relational algebra expression F .R1      Rn/ where F is a conjunction
of conditions obtained as follows: if position k in the body of r has a constant c, then
F has the condition $k D c; if positions k and l in the body of r both contain the
same variable, then F has the condition $k D $l. As an example, if the body of r is
p1.X; Y /; p2.Y; Z; Z/; p3.X; a/, then F is $1 D $6 ^ $2 D $3 ^ $4 D $5 ^ $7 D a. No-
tice that F can be empty and in this case it is always satisï¬ed by any tuple.
2. Finally, Eval-rule.r; R1; : : : ; Rn/ is the relational algebra expression V .E/ where V has m
(i.e., the arity of p) components deï¬ned as follows: if the i-th term of A0 is a variable X,
then the i-th component of V is one of the positions where X appears in the body of r. As
an example, if p.X; Z/ is the head of r and the body of r is as above, then we get $1$4.E/.
î€€us, Eval-rule.r; R1; : : : ; Rn/ gives a relational algebra expression for rule r. î€€e relational
algebra expressions for the derived predicate symbols of a program P are obtained by considering
predicate symbols according to a topological sorting of GP and for each predicate symbol pi we
do the following.
1. For each rule r in P having pi in the head, compute a relational algebra expression E using
Eval-rule.
2. As we are following a topological sorting of GP , for each derived predicate symbol in the
body of r, there is a relational algebra expression (deï¬ned using base relations only). Sub-
stitute each occurrence of a derived relation in E with the corresponding relational algebra
expression.
3. Take the union of the expressions obtained at the second step.
Example3.8
Consider again the graph database of Example 3.1 and the following non-recursive
Datalog program:
r1 W
onehop.X; Y /
 
edge.X; Y /:
r2 W
twohops.X; Y /
 
edge.X; Z/; onehop.Z; Y /:
r3 W
ans.X/
 
onehop.a; X/:
r4 W
ans.X/
 
twohops.a; X/:
Intuitively, the ï¬rst rule computes pairs .X; Y / such that Y can be reached from X by going
through one edge, while the second rule computes pairs .X; Y / such that Y can be reached from
X by going through two edges. î€€e last two rules compute those vertices that can be reached
from vertex a by going through one or two edges.
Clearly, twohops depends on onehop, while ans depends on both onehop and twohops. î€€us,
a topological sorting of the dependency graph is onehop; twohops; ans.

26
3. DATALOG
Denoting with Edge the edge relation, we consider the ï¬rst predicate symbol according to
the topological sorting above, namely onehop, and get
Eval-rule.r1; Edge/ D $1$2.Edge/:
Since the deï¬nition of onehop consists only of r1, then the relational algebra expression to com-
pute the relation for onehop is:
Onehop D $1$2.Edge/:
Obviously, the previous expression might be simpliï¬ed into the equivalent one Onehop D Edge.
Next, considering the second predicate symbol according to the topological sorting, namely
twohops, we have
Eval-rule.r2; Edge; Onehop/ D $1$4.$2D$3.Edge  Onehop//:
Since the deï¬nition of twohops consists only of r2, the relational algebra expression for twohops
is:
Twohops D $1$4.$2D$3.Edge  $1$2.Edge///:
Finally, when we consider the last predicate symbol, namly ans, we get
Eval-rule.r3; Onehop/ D $2.$1Da.Onehop//
Eval-rule.r4; Twohops/ D $2.$1Da.Twohops//
and the relational algebra expression for ans is
Ans D $2.$1Da.$1$2.Edge/// [ $2.$1Da.$1$4.$2D$3.Edge  $1$2.Edge/////:
3.3.2
EVALUATION OF RECURSIVE PROGRAMS
In the following, we report algorithms to evaluate possibly recursive Datalog programs. Specif-
ically, we ï¬rst present a â€œnaÃ¯veâ€ algorithm and then an improvement of it called â€œsemi-naÃ¯veâ€
algorithm (see also Abiteboul et al. [1995] and Ullman [1988]).
Algorithm NaÃ¯ve
Consider a program P and a database D. Let R1; : : : ; Rk be the base relations and
P1; : : : ; Pm
the derived relations. For each derived predicate symbol pi, we deï¬ne
Eval.pi; R1; : : : ; Rk; P1; : : : ; Pm/ as the result of evaluating the union of the expressions given
by Eval-rule over all rules with pi in the head.
Given a possibly recursive Datalog program P and a database D, where the base predicate
symbols are r1; : : : ; rk, the derived predicate symbols are p1; : : : ; pm, and the base relations are
R1; : : : ; Rk, the following algorithm performs the evaluation of P over D.

3.3. PROGRAM EVALUATION
27
Algorithm 1 Naive-Evaluation
1: for i WD 1 to m do
2:
Pi WD ;;
3: repeat
4:
for i WD 1 to m do
5:
P 0
i WD Pi;
6:
for i WD 1 to m do
7:
Pi WD Eval.pi; R1; : : : ; Rk; P 0
1; : : : ; P 0
m/;
8: until Pi D P 0
i for all 1  i  m
9: return P1; : : : ; Pm
î€€e algorithm above iteratively computes Eval for every derived predicate symbol until
none of the derived relations changes anymore. At each iteration, the updated derived relations
obtained in the previous iteration are used in the computation of Eval.
One simple optimization that can be applied to the algorithm above is the following. Given
a possibly recursive Datalog program P , we ï¬rst determine the strongly connected components
of the dependency graph GP . If each strongly connected component is contracted to a single ver-
tex, the resulting graph is a directed acyclic graph G0
P . î€€en, we apply Algorithm Naive-Evaluation
to each connected component following the order given by a topological sorting of G0
P . Apply-
ing Algorithm Naive-Evaluation to a connected component means applying the algorithm to the
subprogram of P consisting of those rules which have a predicate symbol belonging to the con-
nected component in the head, and considering the relations for predicate symbols in previous
components as base relations.
Example 3.9
Consider the database and the Datalog program of Example 3.1, which are re-
ported below for the readerâ€™s convenience.
edge.a; b/:
edge.b; c/:
edge.c; d/:
r1 W
tc.X; Y /  edge.X; Y /:
r2 W
tc.X; Y /  edge.X; Z/; tc.Z; Y /:
Clearly, edge is the only base predicate symbol and tc is the only derived predicate symbol. Let
Edge D f.a; b/; .b; c/; .c; d/g be the base relation corresponding to predicate symbol edge. Ini-
tially, Tc D ; (lines 1â€“2). î€€en, the repeat-until loop of lines 3â€“8 proceeds as follows.
Iteration 1:
Tc0 D Tc D ;:
Tc D Eval.tc; Edge; Tc0/ D Edge [ $1$4.$2D$3.Edge  Tc0// D
f.a; b/; .b; c/; .c; d/g

28
3. DATALOG
Iteration 2:
Tc0 D Tc D f.a; b/; .b; c/; .c; d/g:
Tc D Eval.tc; Edge; Tc0/ D Edge [ $1$4.$2D$3.Edge  Tc0// D
f.a; b/; .b; c/; .c; d/g [
f.a; c/; .b; d/g
Iteration 3:
Tc0 D Tc D f.a; b/; .b; c/; .c; d/; .a; c/; .b; d/g:
Tc D Eval.tc; Edge; Tc0/ D Edge [ $1$4.$2D$3.Edge  Tc0// D
f.a; b/; .b; c/; .c; d/g [
f.a; c/; .b; d/g [
f.a; d/g
Iteration 4:
Tc0 D Tc D f.a; b/; .b; c/; .c; d/; .a; c/; .b; d/; .a; d/g:
Tc D Eval.tc; Edge; Tc0/ D Edge [ $1$4.$2D$3.Edge  Tc0// D
f.a; b/; .b; c/; .c; d/g [
f.a; c/; .b; d/g [
f.a; d/g
As in the last iteration Tc D Tc0, the repeat-until loop terminates and the derived relation Tc is
returned.
Suppose adding the following rule to the program considered above:
reachable-from-a.X/  tc.a; X/:
With this addition, the dependency graph has two strongly connected components, one con-
sisting of tc and another one containing reachable-from-a. We can ï¬rst apply Algorithm
Naive-Evaluation to the subprogram containing the ï¬rst two rules, as detailed above. î€€en, Al-
gorithm Naive-Evaluation can be applied to the subprogram consisting only of the last rule using
the relation Tc computed at the previous step as a base relation.
Algorithm Semi-naÃ¯ve
One shortcoming of Algorithm Naive-Evaluation is that at each iteration, all tuples computed in
the previous iteration are recomputed (e.g., see Example 3.9). We now present an algorithm that
tries to overcome this ineï¬ƒciency by incrementally computing the new relations at each iteration.
We start by introducing an incremental version of Eval-rule seen in Section 3.3.1. Consider
a rule r of the form
A0  A1; : : : ; An;
and assume to have a relation Ri and an â€œincrementalâ€ relation Ri for each atom Ai in the body
of r. We deï¬ne the incremental version of Eval-rule as follows:
Eval-rule-incr.r; R1; : : : ; Rn; R1; : : : ; Rn/ D
S
1in Eval-rule.r; R1; : : : ; Ri 1; Ri; RiC1; : : : ; Rn/:

3.3. PROGRAM EVALUATION
29
Consider a program P
and a database D. Let R1; : : : ; Rk
be the base re-
lations
and
P1; : : : ; Pm
the
derived
relations.
For
each
Pi,
we
also
have
an
â€œincrementalâ€
relation
Pi.
For
each
derived
predicate
symbol
pi,
we
deï¬ne
Eval-incr.pi; R1; : : : ; Rk; P1; : : : ; Pm; P1; : : : ; Pm/ as the result of evaluating the union of
the expressions given by Eval-rule-incr over all rules with pi in the head. In the evaluation of
Eval-rule-incr, the incremental relations for base predicate symbols are the empty set.
Algorithm Seminaive-Evaluation performs the evaluation of P over D and improves over
Algorithm Naive-Evaluation by incrementally computing the derived relations.
Algorithm 2 Seminaive-Evaluation
1: for i WD 1 to m do
2:
Pi WD Eval.pi; R1; : : : ; Rk; ;; : : : ; ;/;
3:
Pi WD Pi;
4: repeat
5:
for i WD 1 to m do
6:
P 0
i WD Pi;
7:
for i WD 1 to m do
8:
Pi WD Eval-incr.pi; R1; : : : ; Rk; P1; : : : ; Pm; P 0
1; : : : ; P 0
m/;
9:
Pi WD Pi   Pi;
10:
for i WD 1 to m do
11:
Pi WD Pi [ Pi;
12: until Pi D ; for all 1  i  m
13: return P1; : : : ; Pm
Example 3.10
Consider the database and the Datalog program of Example 3.9. Once again,
Edge D f.a; b/; .b; c/; .c; d/g is the base relation corresponding to predicate symbol edge. More-
over, Edge D ; as edge is a base predicate symbol. Initially, relation Tc is computed as follows
(line 2):
Tc WD Eval.tc; Edge; ;/ D Edge [ $1$4.$2D$3.Edge  ;// D f.a; b/; .b; c/; .c; d/g:
î€€en, Tc D Tc D f.a; b/; .b; c/; .c; d/g (line 3). Next, the repeat-until loop of lines 4â€“12
proceeds as follows.

30
3. DATALOG
Iteration 1:
Tc0
D
Tc D f.a; b/; .b; c/; .c; d/g:
Tc
D
Eval-incr.tc; Edge; Tc; Tc0/
D
Eval-rule-incr.r1; Edge; Edge/ [ Eval-rule-incr.r2; Edge; Tc; Edge; Tc0/
D
Eval-rule.r1; Edge/ [ Eval-rule.r2; Edge; Tc/ [ Eval-rule.r2; Edge; Tc0/
D
; [ ; [ $1$4.$2D$3.Edge  Tc0//
D
f.a; c/; .b; d/g
Tc
D
Tc   Tc D f.a; c/; .b; d/g
Tc
D
Tc [ Tc D f.a; b/; .b; c/; .c; d/; .a; c/; .b; d/g
Iteration 2:
Tc0
D
Tc D f.a; c/; .b; d/g:
Tc
D
Eval-incr.tc; Edge; Tc; Tc0/
D
Eval-rule-incr.r1; Edge; Edge/ [ Eval-rule-incr.r2; Edge; Tc; Edge; Tc0/
D
Eval-rule.r1; Edge/ [ Eval-rule.r2; Edge; Tc/ [ Eval-rule.r2; Edge; Tc0/
D
; [ ; [ $1$4.$2D$3.Edge  Tc0//
D
f.a; d/g
Tc
D
Tc   Tc D f.a; d/g
Tc
D
Tc [ Tc D f.a; b/; .b; c/; .c; d/; .a; c/; .b; d/; .a; d/g
Iteration 3:
Tc0
D
Tc D f.a; d/g:
Tc
D
Eval-incr.tc; Edge; Tc; Tc0/
D
Eval-rule-incr.r1; Edge; Edge/ [ Eval-rule-incr.r2; Edge; Tc; Edge; Tc0/
D
Eval-rule.r1; Edge/ [ Eval-rule.r2; Edge; Tc/ [ Eval-rule.r2; Edge; Tc0/
D
; [ ; [ $1$4.$2D$3.Edge  Tc0//
D
;
Tc
D
Tc   Tc D ;
Tc
D
Tc [ Tc D f.a; b/; .b; c/; .c; d/; .a; c/; .b; d/; .a; d/g
As in the last iteration Tc D ;, the repeat-until loop terminates and the derived relation
Tc is returned by Algorithm Seminaive-Evaluation.
3.4
EXPRESSIVITY AND COMPLEXITY
Recall that a query is a function that takes a database as input and gives another database as
output. Furthermore, queries have to be generic, that is, invariant under renamings of the database
domain. Queries can be expressed using query languages and the expressive power of a given query
language is measured in terms of the set of queries that can be expressed using that language.

3.4. EXPRESSIVITY AND COMPLEXITY
31
A Datalog query Q is a pair hP; Gi where P is a Datalog program and G is an atom
g.t1; : : : ; tm/, called query goal, s.t. g appears in the head of some rule in P . Let ti1; : : : ; tik be the
terms of G that are variables, where 1  i1 <    < ik  m. î€€e answer to Q over a database D,
denoted Q.D/, is the set of all tuples of constants .c1; : : : ; ck/ s.t. the atom obtained from G by
replacing every tij with cj (1  j  k) belongs to the least model of P [ D. When k D 0 (i.e.,
the query goal is ground), the Datalog query is Boolean an returns true if G belongs to the least
model of P [ D, false otherwise.
Two Datalog queries Q and Q0 are equivalent, denoted Q  Q0, iï¬€Q.D/ D Q0.D/ for
every database D.
Datalog allows us to express only monotonic queries (a monotonic query is such that if a
database D1 is a subset of a database D2, then the result of the query over D1 is a subset of the
result of the query over D2). Datalog can express only a proper subset of the queries computable
in polynomial time. Indeed, Datalog cannot even express all monotonic queries computable in
polynomial time [Afrati et al., 1995]. As already mentioned before, recursion allows Datalog to
express queries which cannot be expressed in relational algebra and calculus, such as computing
the transitive closure of a binary relation [Aho and Ullman, 1979]. Non-recursive Datalog has
the same expressive power as the fragment of relational algebra using only projection, positive
selection (i.e., selection conditions are restricted to be conjunctions of equalities), union, Cartesian
product (in other words, non-recursive Datalog can express union of conjunctive queries). Datalog
needs to be extended with negation in order to get (at least) the same expressive power as relational
algebra and safe relational calculus. We will consider negation in Chapter 4.
î€€ere are three interesting complexity issues connected to Datalog and its extensions.
â€¢ î€€e data complexity is the complexity of checking whether D [ P Ë† A for a ï¬xed Datalog
program P , and variable input database D and ground atoms A.
â€¢ î€€e program complexity is the complexity of checking whether D [ P Ë† A for variable
Datalog program P and ground atoms A, and ï¬xed input database D.
â€¢ î€€e combined complexity is the complexity of checking whether D [ P Ë† A for variable
Datalog program P , input database D, and ground atoms A.
î€€e data complexity of Datalog is P-complete. î€€e program and combined complexity
of Datalog are EXPTIME-complete. î€€e data complexity of linear Datalog is NL-complete. î€€e
program and combined complexity of linear Datalog are PSPACE-complete. î€€e data complexity
of conjunctive queries expressed in Datalog is L, while their program and combined complexity
are NP-complete. î€€e following table reports these results.

32
3. DATALOG
Table 3.1: î€€e complexity of Datalog
Query Language
Data Complexity
Program and Combined Complexity
Conjunctive queries
L
NP-complete
Linear Datalog
NL-complete
PSPACE-complete
Datalog
P-complete
EXPTIME-complete
BIBLIOGRAPHIC NOTES
For early applications of logic to databases we refer to Gallaire and Minker [1978], Gallaire et al.
[1984] and Minker [1988]. An overview of logic programming and databases can be found in Ceri
et al. [1990]; see also Minker et al. [2014].
Fixpoint semantics was explored in the context of logic programming in van Emden and
Kowalski [1976] and Apt and van Emden [1982] and in the database context in Chandra and
Harel [1982].
Resolution was originally proposed in the context of automatic theorem proving [Robinson,
1965], while SLD resolution was developed in [van Emden and Kowalski, 1976]. î€€ese form the
basis of logic programming as introduced by Kowalski [1974] (see also Kowalski [1986]).
Safety conditions on datalog programs have been studied in Kifer et al. [1988], Krishna-
murthy et al. [1988], Ramakrishnan et al. [1987], Sagiv and Vardi [1989] and Zaniolo [1986].
î€€e seminaive evaluation of Datalog programs has been considered in several papers [Balbin
and Ramamohanarao, 1987, Bancilhon and Ramakrishnan, 1986, Fong and Ullman, 1976] and
[Paige and Schwartz, 1977].
For a more detailed treatment of Datalog we also refer to Abiteboul et al. [1995] and Ull-
man [1988].
A survey of various complexity and expressiveness results for diï¬€erent forms of logic pro-
gramming can be found in Dantsin et al. [1997, 2001].

33
C H A P T E R
4
Negation
Even if Datalog provides recursion and allows us to express queries that cannot be expressed in
the relational algebra or calculus (e.g., computing the transitive closure of a graph), its expressive
power remains limited. In fact, Datalog allows us to express only a proper subset of the queries
computable in polynomial time, and only monotonic ones. Simple nonmonotonic queries, such
as checking whether the active domain of an input database has an even number of elements
or computing the diï¬€erence of two relations, cannot be expressed. Indeed, Datalog cannot even
express all monotonic queries computable in polynomial time [Afrati et al., 1995].
Datalog needs to be extended with negation in order to get (at least) the same expressive
power as the relational algebra and the safe relational calculus. Negation is an important feature to
formalize common sense reasoning in knowledge representation as it enables us to express non-
monotonic queries, and thus perform nonmonotonic reasoning. î€€e problem of ï¬nding a suitable
semantics for Datalog programs with negation has been an important and diï¬ƒcult problem that
has received considerable attention over the years, leading to diï¬€erent semantics.
In this chapter, we consider Datalog augmented with negation (in rule bodies)â€”the result-
ing language will be referred to as Datalog:. We start by deï¬ning the general syntax of Datalog:.
î€€en, we focus on restricted subsets of Datalog: where only a limited use of negation is allowed,
namely semipositive, stratiï¬ed, and locally stratiï¬ed Datalog: programs. After that, we consider
the full Datalog: language and present the stable model and the well-founded semantics. Finally,
we consider Datalog extended with a limited form of negation embedded in the choice construct.
At the end of the chapter, we also brieï¬‚y discuss the extension of Datalog with disjunction.
4.1
SYNTAX
In this section, the syntax of Datalog: programs is introduced.
A Datalog: rule r is of the form:
A  L1; : : : ; Ln;
where n  0, A is an atom, and the Liâ€™s are literals (i.e., atoms or negated atoms). Function
symbols are not allowed and thus terms appearing in a Datalog: rule are constants and variables.
Once again, A is called the head of r and is denoted by head.r/; the conjunction L1; : : : ; Ln is
called the body of r and is denoted by body.r/. Comparison atoms of the form t1 op t2 are allowed
in the body, where op is a comparison predicate symbol (i.e., op 2 f; >; ; <; D; Â¤g) and t1 and
t2 are terms.

34
4. NEGATION
Every rule must be safe. î€€e safety condition presented in Section 3.1 for Datalog is gen-
eralized as follows to accommodate negation and comparison atoms. For every Datalog: rule,
every variable must be limited in the following sense:
â€¢ a variable X is limited if it appears in a positive literal of the body whose predicate symbol
is not a comparison predicate symbol;
â€¢ a variable X is limited if it appears in a comparison atom of the form X D c or c D X,
where c is a constant; and
â€¢ a variable X is limited if it appears in a comparison atom of the form X D Y or Y D X,
where Y is a limited variable.
Notice that the ï¬rst two conditions above are base cases to determine if a variable is limited, while
the last condition can be iteratively applied to determine new variables as limited.
Example 4.1
Consider the following Datalog: rule
p.X/  q.X/; :s.Y /; X D Y:
Variable X is limited because it appears in the positive body literal q.X/ and q is not a comparison
predicate symbol. î€€en, we can conclude that Y is limited as well, because it appears in the
comparison atom X D Y and X has been determined as limited. î€€us, the rule is safe.
A Datalog: program is a ï¬nite set of (safe) Datalog: rules. î€€e dependency graph GP of a
Datalog: program P is deï¬ned in the same way as for Datalog programs (see Section 3.1). Once
again, we use ground.P / to denote the set of all ground rules obtained from the rules of P by
replacing all variables with constants.
4.2
SEMIPOSITIVE PROGRAMS
î€€e most restricted use of negation that we consider is semipositive Datalog:, which will be re-
ferred to as Datalog:sp. î€€e following deï¬nition introduces Datalog:sp programs.
Deï¬nition 4.2
A Datalog: program P is semipositive if for every rule r 2 P and every negative
literal L in the body of r, the predicate symbol of L is a base predicate symbol.
Essentially, Datalog:sp allows negation to be applied only to base atoms.
Example 4.3
Consider a directed graph stored in a database by means of facts of the form
vertex.v/, meaning that v is a vertex of the graph, and facts of the form edge.v1; v2/, meaning
that there is an edge from vertex v1 to vertex v2 in the graph (obviously, vertex and edge are base
predicate symbols).

4.2. SEMIPOSITIVE PROGRAMS
35
Below is a Datalog:sp program P to compute the pairs of vertices .v1; v2/ such that the
edge from v1 to v2 does not belong to the graph:
no-edge.X1; X2/  vertex.X1/; vertex.X2/; :edge.X1; X2/:
Datalog:sp allows us to compute the diï¬€erence of two (base) relations, which cannot be
expressed in Datalog. As an example, if p and q are base predicate symbols of arity 1, then the
Datalog:sp rule diff.X/  p.X/; :q.X/ computes the set-theoretic diï¬€erence of p and q. No-
tice that even in the presence of this limited form of negation the existence of a unique mini-
mal model, which is the case for Datalog programs, is no longer guaranteed. For instance, if we
consider the Datalog:sp program P consisting of the aforementioned rule and the database D
consisting only of the fact p.a/, then PD has two minimal models, namely fp.a/; diff.a/g and
fp.a/; q.a/gâ€”intuitively, only the former is the intended one and, indeed, is the one assigned by
the semantics presented below.
î€€e semantics of a Datalog:sp program P and a database D is given by the semantics of
the Datalog program P 0 and the database D0 obtained as follows.
â€¢ Program P 0 is obtained from P by eliminating negation in the following way: each negative
literal :p.t1; : : : ; tn/ in the body of a rule is replaced with a positive literal p0.t1; : : : ; tn/.
â€¢ Database D0 is obtained by adding to D, for each base predicate symbol p, a new relation
whose predicate symbol is p0 and which is deï¬ned as the complement (w.r.t. the Herbrand
universe of PD) of the relation in D for p.
Basically, a ground negative literal :A is interpreted as true if A does not belong to D,
otherwise it is interpreted as false.
Example 4.4
Consider the Datalog:sp program P of Example 4.3 and suppose we are given a
database D containing the following facts:
edge.a; b/:
vertex.a/:
edge.b; b/:
vertex.b/:
edge.b; c/:
vertex.c/:
edge.c; b/:
î€€e semantics of P and D is given by the Datalog program P 0 consisting of the following rule:
no-edge.X1; X2/  vertex.X1/; vertex.X2/; edge0.X1; X2/

36
4. NEGATION
and the database D0 obtained by adding the following facts to D
edge0.a; a/;
edge0.a; c/;
edge0.b; a/;
edge0.c; a/;
edge0.c; c/:
î€€en, the no-edge-atoms that can be derived are
no-edge.a; a/;
no-edge.a; c/;
no-edge.b; a/;
no-edge.c; a/;
no-edge.c; c/:
Datalog:sp is strictly more expressive than Datalog. For instance, the diï¬€erence of two
relations can be expressed in Datalog:sp but not in Datalog. Datalog:sp queries can be evaluated
in polynomial time (data complexity).
4.3
STRATIFIED PROGRAMS
We now present a natural generalization of semipositive Datalog: called stratiï¬ed Datalog: [Apt
et al., 1988, Chandra and Harel, 1985, Lifschitz, 1988, Van Gelder, 1989]. Stratiï¬ed Datalog:
programs restrict the manner in which recursion and negation may occur together.
First, we need to introduce some additional notions. Let P be a Datalog: program. A
partition S1; : : : ; Sm of the set of predicate symbols in P , where the Siâ€™s are called strata, and Sj
is lower than Sk if j < k, is a stratiï¬cation of P iï¬€the following condition holds for every rule in
P :
1. if p is the head predicate symbol and q is the predicate symbol of a positive body literal,
then q belongs to a stratum lower than or equal to the stratum of p; and
2. if p is the head predicate symbol and q is the predicate symbol of a negative body literal,
then q belongs to a stratum lower than the stratum of p.
Stratiï¬ed Datalog programs are deï¬ned as follows.
Deï¬nition 4.5
A Datalog: program P is stratiï¬ed if it has a stratiï¬cation.
We will refer to stratiï¬ed Datalog: also as Datalog:s. It is worth noting that there can be
diï¬€erent stratiï¬cations for a Datalog:s program.
Example 4.6
Consider again a directed graph stored in a database by means of facts of the form
vertex.v/ and edge.v1; v2/. î€€e following Datalog: program P computes the pairs of vertices

4.3. STRATIFIED PROGRAMS
37
.v1; v2/ for which there is no path from v1 to v2 in the graph.
r1 W
tc.X; Y /
 
edge.X; Y /:
r2 W
tc.X; Y /
 
edge.X; Z/; tc.Z; Y /:
r3 W
non-reachable.X1; X2/
 
vertex.X1/; vertex.X2/; :tc.X1; X2/:
As negation is applied to the derived atom tc.X1; X2/ in the third rule, P is not semipositive.
However, P is stratiï¬ed. In fact, a possible stratiï¬cation is given by S1 D fvertex; edge; tcg
and S2 D fnon-reachableg. Notice that there exist other stratiï¬cations. For instance, another
stratiï¬cation is given by S1 D fvertex; edgeg, S2 D ftcg, and S3 D fnon-reachableg. Because of
rule r3, in any stratiï¬cation, the stratum of tc must be lower than the stratum of non-reachable.
An equivalent deï¬nition of Datalog:s programs can be given by imposing some restrictions
on the structure of the dependency graph associated with a Datalog: program. Speciï¬cally, a
Datalog: program P is stratiï¬ed iï¬€every rule r in P satisï¬es the following condition: if p is the
head predicate symbol, then for every derived predicate symbol q appearing in a negative literal
of the body of r, there is no path in GP from p to q. î€€us, the condition above prevents recursion
through negation.
Clearly, non-recursive Datalog: programs are always stratiï¬ed. Moreover, Datalog:sp pro-
grams are stratiï¬ed as well.
We now deï¬ne the semantics of Datalog:s programs in terms of the iterated ï¬xed point
model. Consider a Datalog:s program P and a database D. First of all, we generalize the imme-
diate consequence operator TPD (cf. Section 3.2.2) to deal with negative literals in rule bodies.
Given a set I of ground atoms, then
TPD.I/ D fA0 j A0  A1; : : : ; Ak; :AkC1; : : : ; :An is a ground rule in ground.PD/; and
Ai 2 I for every 1  i  k; and
Ai 62 I for every k C 1  i  ng:
A stratiï¬cation S1; : : : ; Sm of P induces a partition of P into m sets P1; : : : ; Pm such that
Pi consists of the rules of P deï¬ning the predicate symbols in Si. Let
M1 D T !
P1[D.;/;
M2 D M1 [ T !
P2.M1/;
:::
Mm D Mm 1 [ T !
Pm.Mm 1/:
î€€en, Mm is an iterated ï¬xed point model of P . Even if there might be diï¬€erent stratiï¬cations for
a Datalog:s program, they all yield the same iterated ï¬xed point model, which is thus unique for
any Datalog:s program.
Example 4.7
Consider the Datalog:s program P of Example 4.6 and the stratiï¬cation consist-
ing of S1 D fvertex; edge; tcg and S2 D fnon-reachableg. î€€e partition of P determined by such

38
4. NEGATION
a stratiï¬cation is P1 D fr1; r2g and P2 D fr3g. Suppose we are given a database D containing the
following facts:
edge.a; b/:
vertex.a/:
edge.b; b/:
vertex.b/:
edge.b; c/:
vertex.c/:
edge.c; b/:
î€€en,
M1
D
T !
P1[D.;/ D D [ ftc.a; b/; tc.a; c/; tc.b; b/; tc.b; c/; tc.c; b/; tc.c; c/g;
M2
D
M1 [ T !
P2.M1/ D
D
M1 [ fnon-reachable.a; a/; non-reachable.b; a/; non-reachable.c; a/g:
î€€e iterated ï¬xed point model of PD is M2.
While in Datalog:sp negation is restricted only to base atoms, in Datalog:s negation can be
applied also to derived atoms (in a restricted way, though). î€€e existence of stratiï¬cations allows
us to choose one of them and evaluate the induced subprograms following the order dictated
by the stratiï¬cation. When evaluating a subprogram Pi, predicate symbols deï¬ned by rules in
subprograms that have been already evaluated (i.e., those subprograms Pj with j < i) can be
seen as base predicate symbolsâ€”thus, in this sense, Pi can be seen as a semipositive program.
î€€e computation of the iterated ï¬xed point model can be carried out by computing each
Mi by means of the algorithms presented in Chapter 3, with the only diï¬€erence being how the
relations corresponding to negative body literals are deï¬ned. In this regard, consider a predicate
symbol q and let Q be the corresponding relation computed after the stratum of q has been
processed. When Evalrule (cf. Section 3.3) is called for a rule having a negative body literal of
the form :q.t1; : : : ; tk/, the relation for such a negative literal is deï¬ned as .Dom/k   Q, where
Dom is the set of constants appearing in PD.
From the discussion above, it is easy to see that the computation of the iterated ï¬xed point
model can be carried out in polynomial time in the data complexity; indeed, the data complexity
of Datalog:s is P-complete [Apt et al., 1988].
Datalog:s is strictly more expressive than Datalog:sp [Abiteboul et al., 1995]. Datalog:s
without recursion has the same expressive power as the relational algebra and the safe relational
calculus [Abiteboul et al., 1995]. î€€us, Datalog:s (with recursion allowed) is strictly more expres-
sive than the relational algebra and the safe relational calculus (e.g., it can express the transitive
closure of a graph, which cannot be expressed using the other two languages).

4.4. LOCALLY STRATIFIED PROGRAMS
39
4.4
LOCALLY STRATIFIED PROGRAMS
Locally stratiï¬ed programs, originally introduced by Przymusinski [1988], generalize stratiï¬ed
programs. î€€e basic idea is illustrated in the following example.
Example 4.8
Consider the following Datalog: program:
p.a/  :p.c/:
p.b/  :p.c/:
It is easy to check that the program is not stratiï¬ed, since predicate symbol p depends on it-
self â€œthrough negation.â€ If the program had been written as below, using three diï¬€erent (0-ary)
predicate symbols pa, pb, pc rather than a single one, it would be stratiï¬ed:
pa  :pc:
pb  :pc:
î€€is example suggests that we might use a more ï¬ne-grained version of the Datalog:s
condition, looking for a stratiï¬cation of ground atoms rather than a stratiï¬cation of predicate
symbolsâ€”this is the basic idea of locally stratiï¬ed programs, which are formally deï¬ned as follows.
Deï¬nition 4.9
Let P be a Datalog: program. A partition B1; : : : ; Bm of the Herbrand base
BP , where the Biâ€™s are called local strata and Bj is lower than Bk if j < k, is a local stratiï¬cation
of P iï¬€the following condition holds for every ground rule in ground.P /:
1. if H is the head atom and A is a positive body literal, then A belongs to a local stratum
lower than or equal to the local stratum of H; and
2. if H is the head atom and :A is a negative body literal, then A belongs to a local stratum
lower than the local stratum of H.
We say that P is locally stratiï¬ed if admits a local stratiï¬cation.
î€€e class of locally stratiï¬ed Datalog: programs will be also referred to as Datalog:ls.
î€€ere is a simple analogy between stratiï¬cation of Datalog:s programs and local stratiï¬cation
of Datalog:ls programs: the latter treats ground atoms and ground rules in the same way as the
former treats predicate symbols and arbitrary rules.
Example 4.10
Consider again the Datalog: program of Example 4.8, whose Herbrand base is
fp.a/; p.b/; p.c/g. î€€e program is locally stratiï¬ed as B1 D fp.c/g and B2 D fp.a/; p.b/g form
a local stratiï¬cation.
Similar to Datalog:s programs, for a locally stratiï¬ed program there can be diï¬€erent local
stratiï¬cations. For instance, B1 D fp.c/g, B2 D fp.a/g, and B3 D fp.b/g is another local strat-
iï¬cation of the Datalog: program of Example 4.8.

40
4. NEGATION
Datalog:ls programs can be equivalently deï¬ned using a â€œground versionâ€ of the depen-
dency graph. More precisely, given a Datalog: program P , the ground dependency graph of P is
a directed graph whose nodes are the ground atoms in the Herbrand base BP of P . î€€ere is an
edge from a ground atom A to a ground atom H iï¬€there is a rule in ground.P / whose head is H
and one of the body literals is either A or :A. A Datalog: program is locally stratiï¬ed iï¬€every
ground rule r in ground.P / satisï¬es the following condition: if H is the head atom, then for every
negative literal :A in the body of r, there is no path in the ground dependency graph from H to
A.
We now deï¬ne the semantics of Datalog:ls programs. Consider a Datalog: program P
and a database D such that PD is locally stratiï¬ed. î€€e semantics of P and D is given by the
perfect model deï¬ned as follows. Let B1; : : : ; Bm be a local stratiï¬cation of PD and P1; : : : ; Pm
be the partition of ground.PD/ such that Pi consists of the rules of ground.P / whose head atom
is in Bi. Similar to stratiï¬ed programs, we deï¬ne
M1 D T !
P1[D.;/;
M2 D M1 [ T !
P2.M1/;
:::
Mm D Mm 1 [ T !
Pm.Mm 1/:
î€€en, Mm is the perfect model of P . Even if PD can have diï¬€erent local stratiï¬cations, they all
yield the same perfect model, which is thus unique for any Datalog:ls program.
Notice that in the deï¬nition of a perfect model above, the more general deï¬nition of the
immediate consequence operator is used (cf. Section 4.3), that is, the one which deals with neg-
ative literals in rule bodies.
Example 4.11
Consider the Datalog:ls program of Example 4.8 and the local stratiï¬cation
consisting of the local strata B1 D fp.c/g, B2 D fp.a/g, and B3 D fp.b/g.
î€€en,
P1 D ;;
P2 D fp.a/  :p.c/:g; and
P3 D fp.b/  :p.c/:g
and
M1 D ;;
M2 D fp.a/g; and
M3 D fp.a/; p.b/g:
î€€us, the perfect model is M3.
In a sense, compared with stratiï¬ed Datalog: programs, locally stratiï¬ed Datalog: pro-
grams allow us to handle situations where recursion through negation is apparent, but not real,
as in the previous example, where a natural semantics can be given to the program.

4.5. UNSTRATIFIED NEGATION
41
We notice that the notion of a perfect model has been proposed by Przymusinski [1988,
1989] for a class of Datalog: programs more general than Datalog:ls programs.
Every Datalog:s program is locally stratiï¬ed and its iterated ï¬xed point model coincides
with its perfect model. Note that a Datalog: program is stratiï¬ed if all ground atoms with the
same predicate symbol can be assigned the same local stratum Bi.
î€€e data complexity of locally stratiï¬ed Datalog: programs is still polynomial time.
4.5
UNSTRATIFIED NEGATION
In the previous sections we considered subclasses of Datalog: by imposing restrictions on the use
of negation, with the more general subclass being Datalog:ls. î€€ere are Datalog: programs that
are not locally stratiï¬ed and for which we cannot rely on the semantics previously discussed.
In this section, we remove any limitation on the use of negation and thus consider the full
Datalog: language. We present two diï¬€erent semantics for Datalog: programs, namely the stable
model semantics and the well-founded semantics, which both generalize the semantics discussed so
far.Â¹
4.5.1
STABLE MODEL SEMANTICS
î€€e stable model semantics has been proposed by Gelfond and Lifschitz [1988]. It is more general
than the perfect model semantics of Datalog:ls programs and is applicable to Datalog: programs
that are not locally stratiï¬ed.
Consider a Datalog: program P and a database D. As usual, the Herbrand universe HPD
of PD is the set of constants appearing in PD, the Herbrand base BPD of PD is the set of ground
atoms which can be built using predicate symbols appearing in PD and constants in HPD, and
an interpretation of PD is any subset of BPD.
Given an interpretation I of PD, let PDI denote the ground Datalog program derived
from ground.PD/ by deleting
â€¢ every rule that contains a negative literal :A in its body with A 2 I, and
â€¢ all negative literals in the bodies of the remaining rules.
An interpretation I of PD is a stable model of PD if and only if I is the least model of
PDIâ€”notice that PDI has a (unique) least model as it is a Datalog program, cf. Section 3.2.1.
Example 4.12
[Gelfond and Lifschitz, 1988] Consider the following Datalog: program P
q.X/  p.X; Y /; :q.Y /
Â¹Other interesting semantics for Datalog: programs have been proposed, see the bibliographic notes of this chapter.

42
4. NEGATION
and a database D containing only the fact p.1; 2/. Here p is a base predicate symbol and q is a
derived one. Clearly, PD is as follows:
p.1; 2/:
q.1/  p.1; 2/; :q.2/:
q.1/  p.1; 1/; :q.1/:
q.2/  p.2; 2/; :q.2/:
q.2/  p.2; 1/; :q.1/:
Notice that PD is not locally stratiï¬ed.
Consider the interpretation I1 D fq.2/g. î€€en, PDI1 is the following Datalog program
p.1; 2/:
q.1/  p.1; 1/:
q.2/  p.2; 1/:
whose least model is fp.1; 2/g, which is diï¬€erent from I1. Hence, I1 is not a stable model.
Consider now the interpretation I2 D fp.1; 2/; q.1/g. î€€en, PDI2 is the following Datalog
program
p.1; 2/:
q.1/  p.1; 2/:
q.2/  p.2; 2/:
whose least model is I2. Hence, I2 is a stable model. Indeed, I2 is the only stable model of P .
î€€e underlying idea of the stable model semantics is the following. If an interpretation I is
the set of ground atoms that are considered to be true, then any rule having a negative literal :A in
its body with A 2 I is useless and any negative literal :A with A 62 I is trivial. î€€en, ground.PD/
can be simpliï¬ed into PDI. If I happens to be precisely the set of atoms that logically follow
from the simpliï¬ed program PDI, then I is a stable model. î€€us, in a sense, a stable model is
able to â€œreproduceâ€ itself.
A Datalog: program can have zero, one, or many stable models. As an example, the
Datalog: program consisting only of the rule p  :p has no stable models. î€€e Datalog: pro-
gram consisting of the two rules p  :q and q  :q has two stable models, namely fpg and
fqg.
Stable models are minimal models. Furthermore, the stable model semantics generalizes
all the semantics considered in the previous sections. Hence, locally stratiï¬ed Datalog: programs
have a unique stable model which is equal to the perfect model. Obviously, since the perfect
model semantics restricted to stratiï¬ed Datalog: programs coincides with the iterated ï¬xed point
semantics, we can also conclude that a stratiï¬ed Datalog: program has a unique stable model
which is identical to its iterated ï¬xed point model.
Notice that when we consider Datalog programs, PDI coincides with ground.PD/ for every
interpretation I and thus the only interpretation that is a stable model is the the least model of
PD.

4.5. UNSTRATIFIED NEGATION
43
î€€e data complexity of Datalog: under the stable model semantics is co-NP-complete and
the program complexity is co-NEXPTIME-complete [Dantsin et al., 2001, Kolaitis and Papadim-
itriou, 1991, Marek and Truszczynski, 1991, Schlipf, 1995]. Marek and Truszczynski [1991]
showed that even for a propositional (i.e., all predicate symbols have arity 0 and thus there are no
variables) Datalog: program, checking whether it has a stable model is NP-complete.
Datalog: under the stable model semantics is able to express exactly all queries whose
evaluation complexity is in co-NP [Schlipf, 1995].Â²
4.5.2
WELL-FOUNDED SEMANTICS
î€€e well-founded semantics has been proposed by Van Gelder et al. [1988, 1991].
In the semantics considered so far, a stable model provides a truth value for every atom in
the Herbrand base of a given program, provided that a semantics can be assigned to the considered
program (e.g., the Datalog: program p  :p has no stable models). î€€e well-founded semantics
is based on the idea that a program may not necessarily provide such information for all ground
atoms, and thus the truth value of some ground atoms can be unknown. Such a relaxation allows
the well-founded semantics to assign a natural semantics to all Datalog: programs (including,
for instance, the program consisting of the rule p  :p, for which no stable model exists). î€€e
price to pay is that total information is no longer guaranteed, that is, there might be ground atoms
whose truth value is unknown.
In a sense, the well-founded semantics tries to give a reasonable meaning to as much of
the program as possible in the unfavorable cases, when only a partial model exists (i.e., the truth
values of some ground atoms is unknown), as an extension of the semantics for the favorable cases,
which have a total model (i.e., the truth value of every ground atom is knownâ€”it is either true
or false).
Another aspect of the well-founded semantics is that it treats negative and positive literals
in a more uniform way in the following sense. One can no longer assume that :A is true simply
because A is not inferred. Instead, both negative and positive literals must be inferred.
Roughly speaking, another way of looking at the well-founded semantics is that it assigns
value â€œunknownâ€ to an atom if it is deï¬ned by unstratiï¬ed negation.
Before formally deï¬ning the well-founded semantics, we introduce some needed notation
and terminology. A positive literal A and the negative literal :A, where A is an atom, are said to
be complements of each other. We say that a set of literals is consistent if it does not contain both a
literal and its complement. Given a set of literals U , we use :U to denote the set of literals built
by taking the complement of each literal in U .
Let P be a Datalog: program and D a database. A partial interpretation I of PD is a
consistent set of ground literals whose atoms are taken from the Herbrand base BPD. A total
interpretation is a partial interpretation that contains every atom of BPD or its negation.
Â²î€€e evaluation complexity of a query is the complexity of checking whether a given atom belongs to the query result, or, in
the case of Boolean queries, whether the query evaluates to true.

44
4. NEGATION
A ground literal L is true w.r.t. I if L is in I and false if its complement is in I.
A conjunction of ground literals is true w.r.t. I if all its literals are true w.r.t. I, and is false
w.r.t. I if any of its literals is false w.r.t. I.
We say that a ground rule r is
â€¢ satisï¬ed w.r.t. I if the head is true w.r.t. I or some body literal is false w.r.t. I,
â€¢ falsiï¬ed w.r.t. I if the head is false w.r.t. I and all body literals are true w.r.t. I, and
â€¢ weakly falsiï¬ed w.r.t. I if the head is false w.r.t. I but no body literal is false w.r.t. I.
A total model of PD is a total interpretation of PD such that every ground rule in
ground.PD/ is satisï¬ed.
A partial model of PD is a partial interpretation of PD that can be extended to a total model
of PD. î€€us, for a partial model, there might be some ground rules that are not satisï¬ed, but all
rules can be satisï¬ed by adding some ground literals to the partial model (the resulting set of
literals must be consistent). Clearly, this is impossible if the partial model falsiï¬es a ground rule
in ground.PD/. If the partial interpretation only weakly falsiï¬es a ground rule, then the addition
of some literal may be necessary to satisfy the rule.
Intuitively, a partial interpretation I says that the truth value of each atom A 2 I is true,
the truth value of each atom A s.t. :A 2 I is false, and the truth value of other atoms is unknown.
î€€us, a partial interpretation may contain incomplete information. î€€e natural ordering on partial
interpretations is . Given two partial interpretations I and I 0, if I  I 0 then I 0 contains all the
information in I, both positive and negative, and possibly more.
We now present the important notion of an unfounded set.
Deï¬nition 4.13
Let P be a Datalog: program and D a database. A subset U of the Herbrand
base BPD is an unfounded set w.r.t. a partial interpretation I of PD if each atom A 2 U satisï¬es
the following condition: for every ground rule in ground.PD/ whose head is A, at least one of the
following conditions hold:
1. some (positive or negative) body literal is false w.r.t. I and
2. some positive body literal belongs to U .
Intuitively, we can look at I as what we already know about the intended model of PD
(possibly partial). Rules satisfying the ï¬rst condition above cannot be used to infer anything as
their bodies are false w.r.t. I. î€€e second condition above is the unfoundedness condition: of all
the rules that still might be usable to derive something in the set U , each requires an atom in U
to be true. In other words, there is no one atom in U that can be ï¬rst to be established as true by
the rules of PD (starting from knowing I). Consequently, if we choose to infer that some or all
atoms in U are false, there is no way we could later have to infer one to be true.

4.5. UNSTRATIFIED NEGATION
45
î€€e well-founded semantics uses the two aforementioned conditions to draw negative con-
clusions. Essentially, it simultaneously infers all atoms in U to be false.
Example 4.14
[Van Gelder et al., 1991] Consider the following (ground) Datalog: program:
p.a/  p.c/; :p.b/:
p.b/  :p.a/:
p.e/  :p.d/:
p.c/:
p.d/  q.a/; :q.b/:
p.d/  q.b/; :q.c/:
q.a/  p.d/:
q.b/  q.a/:
î€€e set U D fp.d/; q.a/; q.b/; q.c/g is an unfounded set with respect to the partial interpretation
;. In particular, there is no rule with q.c/ in the head so the condition in Deï¬nition 4.13 is trivially
satisï¬ed for q.c/. For each of p.d/, q.a/, and q.b/, the second condition of Deï¬nition 4.13 applies
as there is no way to establish p.d/ as true without ï¬rst establishing q.a/ or q.b/ as true, there
is no way to establish q.a/ as true without ï¬rst establishing p.d/ as true, and likewise for q.b/.
Clearly, q.c/ can never be proven, but we can also see that among p.d/, q.a/, and q.b/, none can
be the ï¬rst one to be proven.
In contrast, it can be easily veriï¬ed that fp.a/; p.b/g is not an unfounded set with respect
to the partial interpretation ;.
It is easy to see that the union of arbitrary unfounded sets is an unfounded set. Given
a Datalog: program P and a database D, the greatest unfounded set with respect to a partial
interpretation I, denoted UPD.I/, is the union of all sets that are unfounded with respect to I.
We now introduce three operators that will be used to deï¬ne the well-founded semantics.
Deï¬nition 4.15
Let P be a Datalog: program, D a database, and I a partial interpretation
of PD. We deï¬ne the operators TPD, UPD, WPD, which take a set of literals and return a set of
literals, as follows:
â€¢ a ground atom A belongs to TPD.I/ iï¬€there is some ground rule in ground.PD/ whose
head is A and such that every body literal is true w.r.t. I;
â€¢ UPD.I/ is the greatest unfounded set with respect to I; and
â€¢ WPD.I/ D TPD.I/ [ :UPD.I/.
Intuitively, given a partial interpretation I (which can be seen as what we already know
about the intended model of PD), TPD.I/ infers ground atoms that are established as true,

46
4. NEGATION
UPD.I/ infers ground atoms that can be established as false, and WPD simply combines the result
of the two operators. It is easy to see that the three operators are monotone.
Notice that when the TPD.I/ operator is applied and we want to determine whether we
can infer the head atom of a ground rule r, to decide whether a negative literal :A in the body of
r is true w.r.t. I, the presence of :A in I is required. î€€is is diï¬€erent from other semantics that
look for the absence of A from Iâ€”see, e.g., the more general version (able to deal with negative
body literals) of the immediate consequence operator TPD reported in Section 4.3.
Deï¬nition 4.16
Consider a Datalog: program P and a database D. We deï¬ne the sets I and
I 1, whose elements are ground literals built from the atoms in the Herbrand base of PD, as
follows:
1. I0 D ;;
2. IC1 D WPD.I/, for   0; and
3. I 1 D S

I .
We are now ready to deï¬ne the well-founded semantics.
Deï¬nition 4.17
Consider a Datalog: program P and a database D. î€€e well-founded semantics
of PD is given by the least ï¬xed point of WPD (or the limit I 1).
Indeed, the least ï¬xed point of WPD is a partial model, and is called well-founded model.
î€€e well-founded model is unique and always exists, in contrast to the stable model semantics for
which there exist Datalog: programs that have no stable models.
Every positive literal in the well-founded model denotes that its atom is true, every nega-
tive literal denotes that its atom is false, and missing atoms have no truth value assigned by the
semantics.
î€€e well-founded semantics coincides with the perfect model semantics on locally stratiï¬ed
Datalog: programs (thus, it also coincides with the stable model semantics on such programs).
î€€us, for locally stratiï¬ed Datalog: programs the well-founded model is total. Furthermore, there
are Datalog: programs that are not locally stratiï¬ed but have a total well-founded model. For
instance, considering the Datalog: program P and the database D of Example 4.12, we have
that PD is not locally stratiï¬ed but it has a total well-founded model, which is the unique stable
model of PD (see Example 4.12).
While stratiï¬cation is a syntactic property of a Datalog: program, for an unstratiï¬ed
Datalog: program, whether it has a total well-founded model depends in general on the database.
For arbitrary Datalog: programs (thus, beyond locally stratiï¬ed ones) the relation between
the stable model and the well-founded semantics has been investigated in [Van Gelder et al.,
1991]. If a Datalog: program has a total well-founded model, then that model is the unique
stable model of the program. However, the converse does not hold, that is, there are programs

4.6. CHOICE
47
that do not have a total well-founded model but do have a unique stable model, as shown in the
following example.
Example 4.18
[Van Gelder et al., 1991] Consider the following Datalog: program P :
a  :b:
b  :a:
p  :p:
î€€ere exist two minimal models for P , namely fa; pg and fb; pg. It can be easily veriï¬ed that P
has no stable model while its well-founded model is ;, which is not total.
Consider now the Datalog: program P 0 obtained by adding the following rule to P
p  :b:
î€€en, P 0 has a unique stable model, namely fa; pg while its well-founded model is still the empty
set. In a sense, the addition of the aforementioned rule to P â€œstabilizesâ€ one of the two minimal
models of P .
Below is another example reporting a Datalog: program that has a unique stable model
but does not have a total well-founded model.
Example 4.19
[Van Gelder et al., 1991] Consider the following Datalog: program P :
a  :b:
b  :a:
c  a; b:
a  :c:
î€€e well-founded model of P is the empty set, while its unique stable model is fag.
î€€e well-founded model of a Datalog: program P is a subset of every stable model of
P [Van Gelder et al., 1991].Â³
î€€e data complexity of the well-founded semantics is P-complete, while the program com-
plexity is EXPTIME-complete [Dantsin et al., 2001, Van Gelder et al., 1991].
4.6
CHOICE
In this section, we extend Datalog with the choice construct [Giannotti et al., 1991, 2001, SaccÃ 
and Zaniolo, 1990].â´ î€€e choice construct allows us to get an increase in expressive power and to
Â³In Section 4.5.1 we represented stable models as subsets of the Herbrand base BPD, and thus they are sets of atoms; here it
is assumed that a stable model M can be seen as the set of literals M [ :.BPD n M/.
â´A choice construct called static choice was considered by Krishnamurthy and Naqvi [1988] and Naqvi and Tsur [1989]. A
diï¬€erent choice construct called dynamic choice was considered in Giannotti et al. [1991, 2001], SaccÃ  and Zaniolo [1990]. In
this section, we consider the dynamic choice and call it simply choice.

48
4. NEGATION
obtain simple declarative formulations of classical combinatorial problems, such as those which
can be solved by means of greedy algorithms [Greco and Zaniolo, 2001]. î€€e declarative seman-
tics of the choice construct is given in terms of Datalog: rules, so augmenting Datalog with the
choice means introducing a restricted form a negation (embedded in the choice construct).
We also discuss the choice-least and choice-most constructs [Greco and Zaniolo, 2001],
which specialize the choice construct so as to force greedy selections among alternative choicesâ€”
these turn out to be particularly useful to express classical greedy algorithms.
4.6.1
SYNTAX
We start by introducing the basic idea of the choice construct with an example.
Example 4.20
Consider a database schema fstudent.Name; Major; Year/; professor.Name;
Major/g and a university database over such a schema containing the following facts:
student.john; ee; senior/:
professor.ohm; ee/:
professor.bell; ee/:
Also, suppose that the major of a student must match his/her advisorâ€™s major area of spe-
cialization. î€€en, eligible advisors can be computed with the following rule:
elig_adv.S; A/  student.S; M; Y /; professor.A; M/
which yields elig_adv.john; ohm/ and elig_adv.john; bell/.
Now, suppose we want to enforce that a student can have only one advisor. î€€is can be
obtained by adding the atom choice..S/; .A// in the body of the rule above, which forces the
selection of a unique advisor, out of the eligible advisors, for a student. î€€e resulting rule is:
actual_adv.S; A/  student.S; M; Y /; professor.A; M/; choice..S/; .A//:
Intuitively, the rule above forces each student S to be associated with a unique professor A.
î€€e goal choice..S/; .A// can also be viewed as enforcing the functional dependency S ! A
on the set of atoms derived by means of the rule; thus, in actual_adv, the second column (professor
name) is functionally dependent on the ï¬rst one (student name).
î€€e result of executing the rule is nondeterministic: it can give either actual_adv.john; ohm/
or actual_adv.john; bell/.
Choice rules and programs are deï¬ned as follows.
Deï¬nition 4.21
A choice rule is of the form:
A  B.Z/; choice..X1/; .Y 1//; : : : ; choice..Xk/; .Y k//;

4.6. CHOICE
49
where k > 0, A is an atom whose variables appear in Z,âµ B.Z/ is a conjunction of atoms, Z is
a list of the variables occurring in B.Z/, Xi, and Y i are lists of variables such that Xi \ Y i D ;
and Xi; Y i  Z, for all 1  i  k.
A choice program is a ï¬nite set of Datalog rules and choice rules.
In a choice rule of the form reported in the preceding deï¬nition, each of the
choice..Xi/; .Y i//â€™s is called choice atom.
In this section, we are interested in choice programs having at least one choice ruleâ€”in
fact, when this is not the case, we are dealing with simple Datalog programs. î€€us, in the rest of
this section, a choice program is understood to have at least one choice rule.
4.6.2
STABLE-MODEL DECLARATIVE SEMANTICS
î€€e semantics of a choice program P is deï¬ned in terms of the stable model semantics of a
Datalog: program derived from P , called ï¬rst-order equivalent of P . In the following deï¬nition,
we use Ä± to denote the operator that concatenates (ordered) lists of variables.
Deï¬nition 4.22
Given a choice program P , the ï¬rst-order equivalent of P , denoted foe.P /, is
the Datalog: program obtained from P by replacing every choice rule r of the form
A  B.Z/; choice..X1/; .Y 1//; : : : ; choice..Xk/; .Y k//
with the following set of rules:
A
 
B.Z/; chosenr.X; Y /:
chosenr.X; Y /
 
B.Z/; :diff_choicer.X; Y /:
diff_choicer.X; Y 1; : : : ; Y k/
 
chosenr.X; Y
0
1; : : : ; Y
0
k/; Y i Â¤ Y
0
i:
8i 2 Å’1; kÂ;
where X D X1 Ä±    Ä± Xk, Y D Y 1 Ä±    Ä± Y k, and Y
0
i is the list of variables obtained by â€œprimingâ€
every variable in Y i. Moreover, the intended meaning of Y i Â¤ Y
0
i is that it is true if Y Â¤ Y 0 is
true for some variable Y 2 Y i and its primed counterpart Y 0.â¶
Deï¬nition 4.23
î€€e semantics of a choice program P and a database D is given by the stable
models of foe.P / [ D, which are called choice models of PD.
Example 4.24
Consider the choice program P consisting only of the following choice rule r
(taken from Example 4.20):
actual_adv.S; A/  student.S; M; Y /; professor.A; M/; choice..S/; .A//:
âµî€€is is a safety condition.
â¶Notice that the last kind of rules does not satisfy the safety condition as variables Y i are not limited (cf. Section 4.1). However,
such rules might be made safe by adding a suitable atom d.Y i/ in the rule body which dictates what are the values that variables
Y i can take.

50
4. NEGATION
î€€e ï¬rst-order equivalent of P is reported below (it can be read as a statement that a professor
will be assigned to a student with the same major whenever a diï¬€erent professor has not been
assigned to the same student):
actual_adv.S; A/
 
student.S; M; Y /; professor.A; M/; chosenr.S; A/:
chosenr.S; A/
 
student.S; M; Y /; professor.A; M/; :diff_choicer.S; A/:
diff_choicer.S; A/
 
chosenr.S; A0/; A Â¤ A0:
Consider now the following database D (taken again from Example 4.20)
student.john; ee; senior/:
professor.ohm; ee/:
professor.bell; ee/:
î€€en, PD has two choice models whose actual_adv-atoms are factual_adv.john; ohm/g and
factual_adv.john; bell/g, respectively.
î€€e body of a choice rule may contain a choice atom of the form choice../; X//, that is, the
ï¬rst argument is the empty list. î€€e intuitive meaning is that a unique value for X is nondeter-
ministically chosen. î€€is kind of choice atom is illustrated in the following example.
Example 4.25
Consider again the university database schema of Example 4.20 and suppose we
are given the following database D:
student.john; ee; senior/:
student.alice; ee; senior/:
professor.ohm; ee/:
professor.bell; ee/:
Let P be the choice program consisting of the following choice rule r
adv.S; A/  student.S; M1; Y /; professor.A; M2/; choice../; .A//:
î€€is choice rule assigns to all students the same (nondeterministically chosen) advisor A and thus
the adv relation will contain a single professor. î€€en, PD has two choice models whose adv-atoms
are fadv.john; ohm/; adv.alice; ohm/g and fadv.john; bell/; adv.alice; bell/g, respectively.
Notice also that that the ï¬rst-order equivalent of P is the following Datalog: program
adv.S; A/
 
student.S; M1; Y /; professor.A; M2/; chosenr.A/:
chosenr.S; A/
 
student.S; M1; Y /; professor.A; M2/; :diff_choicer.A/:
diff_choicer.A/
 
chosenr.A0/; A Â¤ A0:
In general, program foe.P / has the following properties [Giannotti et al., 2001]:

4.6. CHOICE
51
â€¢ foe.P / has one or more stable models and
â€¢ the chosenr atoms in each stable model of foe.P / obey the functional dependencies deï¬ned
by the choice atoms.
It is worth noting that the functional dependency enforced by a choice atom in the body
of a choice rule r is â€œlocalâ€ to r, that is, what is derived through the application of r must satisfy
the functional dependency; however, there might be some other rules in the considered program
that allow us to derive atoms that violate the functional dependency. î€€is aspect is illustrated in
the following example.
Example 4.26
Consider again the choice program P and the database D of Example 4.24.
Recall that P contains only one choice rule assigning a single advisor to each student.
î€€us, PD has two choice models whose actual_adv-atoms are factual_adv.john; ohm/g and
factual_adv.john; bell/g, respectively.
Consider the choice program P 0 obtained by adding to P the following Datalog rule:
actual_adv.S; A/  student.S; M; Y /; professor.A; M/:
Now
P 0
D
has
only
one
choice
model
whose
actual_adv-atoms
are
factual_adv.john; ohm/; actual_adv.john; bell/g. î€€e addition of the rule above allows us to
derive more atoms that lead to the violation of the functional dependency enforced by the choice
rule.
Below we report diï¬€erent examples showing how some classical combinatorial problems
can be easily expressed using the choice construct.
Example 4.27
Consider a bipartite undirected graph G D h.V1; V2/; Ei, that is, an undirected
graph where vertices are partitioned into two subsets V1 and V2, and each edge in E connects a
vertex in V1 with a vertex in V2.
Consider the problem of ï¬nding a matching, i.e., a subset E0 of E, such that for every vertex
v 2 V1 [ V2 at most one edge of E0 is incident on v. Suppose that we have a fact edge.x; y/
for each edge joining vertex x 2 V1 with vertex y 2 V2. î€€e problem can be expressed with the
following choice rule:
matching.X; Y /  edge.X; Y /; choice..Y /; .X//; choice..X/; .Y //:
Intuitively, the choice rule says that any edge might be included in the matching provide that the
matching relation satisï¬es the conditions imposed by the choice atoms, that is, if an edge .X; Y /
is included in the matching then X is joined only with Y in the matching, and, likewise, Y is
joined only with X in the matching.
Example 4.28
Consider an undirected graph stored in a database as follows: for each edge con-
necting vertex x with vertex y there are two facts edge.x; y/ and edge.y; x/ in the database. A

52
4. NEGATION
spanning tree starting from the root vertex a can be computed by means of the following choice
program:â·
st.root; a/:
st.X; Y /  st.Z; X/; edge.X; Y /; Y Â¤ a; Y Â¤ X; choice..Y /; .X//:
To illustrate the presence of multiple choice models for this choice program, consider a
simple graph consisting of the following edges:
edge.a; b/:
edge.b; a/:
edge.b; c/:
edge.c; b/:
edge.a; c/:
edge.c; a/:
Initially, the recursive rule could derive st.a; b/ and st.a; c/. No further edges can be added
after those, since the addition of st.c; b/ or st.b; c/ would violate the functional dependency en-
forced by choice..Y /; .X//. Notice that st.root; a/ is always derived by the ï¬rst rule and thus there
are no â€œchosenâ€ atoms with the second argument equal to the source vertex a. î€€erefore, to avoid
the addition of st.b; a/ or st.c; a/, the atom Y Â¤ a was added to the recursive rule.
î€€e choice program has three diï¬€erent choice models, for which we list only the st-atoms
below:
â€¢ fst.a; b/; st.a; c/g
â€¢ fst.a; b/; st.b; c/g
â€¢ fst.a; c/; st.c; b/g:
4.6.3
FIXPOINT SEMANTICS
In this section, we present a ï¬xpoint semantics for choice programs. î€€is semantics will be spe-
cialized in Section 4.6.4 to deï¬ne the greedy choice.
Given a choice program P , we use PC to denote the set of rules in foe.P / that deï¬ne a
predicate chosenr (for some r in P ), and use PS to denote the remaining rules of foe.P /, i.e.,
PS D foe.P /   PC. We can associate PC (resp. PS) with an immediate consequence operator
TPC (resp. TPS). Clearly, for any interpretation I of foe.P /, the following holds:
Tfoe.P /.I/ D TPC .I/ [ TPS.I/:
â·For illustrative purposes, here we are slightly abusing the syntax of choice programs (cf. Deï¬nition 4.21) by allowing inequal-
ities in the body of a rule. However, the semantics of such more general choice programs can be deï¬ned in the same way as
in Deï¬nition 4.22 as it is given in terms of the stable models of Datalog: programs.

4.6. CHOICE
53
We now introduce a general operator for computing the nondeterministic ï¬xpoints of a
choice program P . We will denote by FDP the functional dependencies deï¬ned by the choice
atoms in P .
Deï¬nition 4.29
Given a choice program P , its nondeterministic immediate consequence operator
	P is a mapping from an interpretation of foe.P / to a set of interpretations of foe.P / deï¬ned as
follows:
	P .I/ D fT !
PS.I [ C/ [ C j C 2  P .I/g;
where
 P .I/ D
(
f;g
if TPC .I/ D ;
fC j ;  C  TPC .I/ n I and I [ C Ë† FDP g;
otherwise.
I [ C Ë† FDP denotes that I [ C satisï¬es the dependencies in FDP .
Basically, the 	P operator is the composition of two operators. Given an interpretation I,
the ï¬rst operator computes all the admissible subsets C  TPC .I/ n I; that is, those where I [
C obeys the functional dependencies FDP . î€€e second operator derives the logical consequence
for each admissible subset using the ï¬xpoint of TPS.
î€€e deï¬nition of  P .I/ is such that C is not empty iï¬€TPC .I/ n I is not empty. î€€us,
if there are possible new choices, then at least one has to be taken. î€€e 	P operator formalizes a
single step of a bottom-up evaluation of a choice program.
Observe that, given the presence of the condition I [ C Ë† FDP , we can eliminate the
atoms diff_choicer.X; Y / from the rules deï¬ning predicate symbols chosenr. In fact, if TP 0
C de-
notes the immediate consequence operator for the set of rules obtained from PC by deleting
the atoms diff_choicer.X; Y /, then TP 0
C can replace TPC in the deï¬nition of  P .I/ (cf. Deï¬ni-
tion 4.29 above), without aï¬€ecting the ï¬nal result.
Deï¬nition 4.30
Given a choice program P , an inï¬‚ationary choice ï¬xpoint computation for P is
a sequence hInin0 of interpretations such that:
1. I0 D ;,
2. InC1 2 	P .In/,
for n  0.
Inasmuch as every sequence hInin0 is monotonic, it has a unique limit for n ! 1; this
limit will be called an inï¬‚ationary choice ï¬xpoint for the choice program P .
Given a choice program P and a Herbrand interpretation M of foe.P /, then M is a choice
model of P iï¬€M is an inï¬‚ationary choice ï¬xpoint for P [Giannotti et al., 1991]. î€€us, the
inï¬‚ationary choice ï¬xpoint computation is sound (every inï¬‚ationary choice ï¬xpoint is a choice
model) and complete (for each choice model there is some inï¬‚ationary choice ï¬xpoint computation
producing it).

54
4. NEGATION
î€€e data complexity (i.e., the computational complexity evaluated with respect to the size of
the database) of computing a choice model for a choice program P is polynomial time [Giannotti
et al., 1991]. î€€erefore, the computation of one of the stable models of foe.P / can be performed
in polynomial time using the inï¬‚ationary choice ï¬xpoint computation. î€€is contrasts with the
general intractability of ï¬nding stable models of Datalog: programs: in fact, as already mentioned
in Section 4.5.1, checking if a Datalog: program has a stable model is NP-complete [Marek and
Truszczynski, 1991].
î€€e choice construct allows us to capture a special subclass of Datalog: programs that
have a stable model semantics but are amenable to eï¬ƒcient implementation and are appealing
to intuition. Evaluating these programs only requires memorization of the chosenr predicates;
from these, the diff_choicer predicates can be generated on-the-ï¬‚y, thus eliminating the need
to store diff_choicer explicitly. Moreover, the model of memorizing tables to enforce functional
dependencies provides a simple enough metaphor for a programmer to make eï¬€ective usage of
this construct without having to become cognizant on the subtleties of non-monotonic semantics.
We also mention that, although we are considering Datalog programs with choice, the
framework can be trivially extended to consider stratiï¬ed negation. î€€e computation of a choice
model for a Datalog:s program with choice can be carried out by partitioning the program into an
ordered number of suitable subprograms and computing the choice ï¬xpoints of every subprogram
in their order.
4.6.4
GREEDY CHOICE
In this section, we focus on a specialization of the choice construct called greedy choice [Greco and
Zaniolo, 1998, 2001, Greco et al., 1992]. î€€e interest in such a specialization follows from the
observation that it is frequently desirable to select a value that is the least or the most among a set
of candidate values, and still satisfy the functional dependencies deï¬ned by the choice atoms.
A choice-least (resp. choice-most) atom is of the form choice-least..X/; .C// (resp.
choice-most..X/; .C//), where X is a list of variables and C is a single variable ranging over
an ordered domain.
A choice-least rule (resp. choice-most rule) is a Datalog rule that contains one choice-least
(resp. one choice-most) atom, and zero or more choice atoms (besides standard atoms, of course).
A choice-least (resp. choice-most) program is a ï¬nite set of choice-least (resp. choice-most)
rules, choice rules, and Datalog rules. In the rest of this section, we assume that a choice-least
(resp. choice-most) program has at least one choice-least (resp. choice-most) rule as when this is
not the case we are dealing with choice programs or Datalog programs, which have been already
discussed before.
A choice-least..X/; .C// (resp. choice-most..X/; .C//) atom in a rule indicates that the
functional dependency deï¬ned by the atom choice..X/; .C// is to be satisï¬ed, and the C value
assigned to a certain value of X has to be the minimum (resp. maximum) one among the candidate

4.6. CHOICE
55
values. For instance, a rule of the form
p.X; Y; C/  q.X; Y; C/; choice..X/; .Y //; choice-least..X/; .C//
imposes the functional dependency X ! Y; C on the possible instances of p. In addition, for
each value of X, the minimum among the candidate values of C must be chosen. For instance,
assuming that q is deï¬ned by the facts q.a; b; 1/ and q.a; c; 2/, from the rule above we might
derive either p.a; b; 1/ or p.a; c; 2/. However, the choice-least atom introduces the additional
requirement that the minimum value on the third attribute has to be chosen, so that only p.a; b; 1/
is derived. î€€is means that, by using the choice-least and choice-most constructs, we introduce
some preference criteria on the stable models of the program.
Choice-least and choice-most programs have dual properties; thus, in the following we
will consider choice-least programs with the understanding that the corresponding properties for
choice-most programs are implicitly deï¬ned by this duality.
î€€e correct evaluation of choice-least programs can be deï¬ned by specializing the nonde-
terministic immediate consequence operator (Deï¬nition 4.29) by ensuring that (i) C is a set
containing only one element, and (ii) a least-cost tuple among those that are candidates is chosen.
In order to deï¬ne such an operator, we ï¬rst deï¬ne a â€œlazyâ€ version of the nondeterministic
immediate consequence operator, called lazy immediate consequence operator, where C is spe-
cialized into a singleton set Ä±. î€€e specialized version of 	P so derived will be denoted 	 lazy
P . As
proven in Giannotti et al. [1991], the inï¬‚ationary choice ï¬xpoint computation restricted so as
to use 	 lazy
P
still provides a sound and nondeterministically complete computation for the choice
models of P . After that, we deï¬ne an immediate consequence operator called least-cost immediate
consequence operator, which ensures that a least-cost tuple among the candidate ones is chosen.
Given a choice-least program P , the ï¬rst-order equivalent of P , denoted foe.P /, is deï¬ned
as for standard choice programs (cf. Deï¬nition 4.22), by treating choice-least atoms as choice
atoms. As for choice programs, PC denotes the set of rules in foe.P / that deï¬ne a predicate
chosenr (for some r in P ), and PS denotes the remaining rules of foe.P /, i.e., PS D foe.P /   PC.
We start by deï¬ning 	 lazy
P .
Deï¬nition 4.31
Let P be a choice-least program and I an interpretation of foe.P /. î€€e lazy
immediate consequence operator 	 lazy
P
for P is deï¬ned as follows:
I
D
fÄ± j Ä± 2 TPC .I/ n I and I [ fÄ±g Ë† FDP g
  lazy
P
.I/
D
fI [ fÄ±g j Ä± 2 Ig [ fI j I D ;g
	 lazy
P .I/
D
fT !
PS .J / j J 2   lazy
P
.I/g:
Given an interpretation I, a set C 2  P .I/, and two atoms t1; t2 2 C, we write t1 < t2
if both atoms are inferred only by choice-least rules, and the cost of t1 is less than the cost of t2
according to some choice-least atom. For instance, consider the choice-least rule
p.X; Y; C/  q.X; Y; C/; choice-least..X/; .C//;

56
4. NEGATION
where the â€œcostâ€ of p-atoms with respect to the choice-least atom choice-least..X/; .C// is their
third argument. Suppose t1 and t2 are the atoms p.a; b; 1/ and p.a; b; 2/, respectively. î€€en, the
cost of t1 is less than the cost of t2.
Furthermore, we denote with least.C/ the set of atoms of C with least cost, i.e.,
least.C/ D ft j t 2 C and Ã€u 2 C s.t. u < tg. î€€e implementation of the least-cost imme-
diate consequence operator is simply obtained by replacing Ä± 2 I with Ä± 2 least.I/ in the
deï¬nition of the lazy immediate consequence operator.
Deï¬nition 4.32
Let P be a choice-least program and I an interpretation of foe.P /. î€€e least-
cost immediate consequence operator 	 least
P
for P is deï¬ned as follows:
I
D
fÄ± j Ä± 2 TPC .I/ n I and I [ fÄ±g Ë† FDP g
  least
P
.I/
D
fI [ fÄ±g j Ä± 2 least.I/g [ fI j I D ;g
	 least
P
.I/
D
fT !
PS .J / j J 2   least
P
.I/g:
Likewise, the dual deï¬nition of the most-cost immediate consequence operator can be easily
derived.
Deï¬nition 4.33
Given a choice-least program P , an inï¬‚ationary least choice ï¬xpoint computation
for P is a sequence hInin0 of interpretations such that:
â€¢ I0 D ; and
â€¢ InC1 2 	 least
P
.In/,
for n  0.
î€€us, all atoms that do not violate the functional dependencies deï¬ned by choice atoms
(including those imposed by choice-least atoms) are considered, and one is chosen that has the
least value for the cost argument. For a choice-least program P ,
1. every inï¬‚ationary least choice ï¬xpoint for P is a choice model for the choice program ob-
tained from P by treating choice-least atoms as choice atoms; and
2. every inï¬‚ationary least choice ï¬xpoint of P can be computed in polynomial time.
As for the ï¬rst property, observe that every computation of the inï¬‚ationary least choice
ï¬xpoint is also a computation of the lazy choice ï¬xpoint.
î€€e second property follows from the fact that the complexity of the inï¬‚ationary lazy choice
ï¬xpoint is polynomial time, and the cost of selecting an atom with least cost is also polynomial.
î€€e model so constructed will be called greedy choice models.
In a system that adopts a semantics based on the least choice ï¬xpoint, a programmer will
specify a choice-least..X/; .Y // atom to ensure that only particular choice models rather than
arbitrary ones are produced through the greedy selection of the least values of Y at each step.

4.7. DISJUNCTION
57
î€€e specialization of choice atoms into choice-least or choice-most atoms yields a con-
venient and eï¬ƒcient formulation of many greedy algorithms, such as Dijkstraâ€™s shortest path
(for which arithmetic operators are needed as well) and Primâ€™s minimum-spanning tree algo-
rithms [Greco and Zaniolo, 1998].
Example 4.34
Consider a weighted directed graph stored by means of facts of the form
edge.x; y; c/, meaning that there is an edge in the graph from vertex x to vertex y with cost
c. An algorithm for ï¬nding a minimum spanning tree starting from a source vertex a can be
formulated as follows, yielding the well-known Primâ€™s algorithm.
st.root; a; 0/:
st.X; Y; C/
 
st.Z; X; W /; edge.X; Y; C/; Y Â¤ a;
choice..Y /; .X//; choice-least..Y /; .C//:
Greedy algorithms often provide eï¬ƒcient approximate solutions to NP-complete problems;
the following algorithm yields heuristically eï¬€ective approximations of optimal solutions for the
traveling salesperson problem [Papadimitriou and Steiglitz, 1982].
Example4.35
Given a complete undirected graph, the ï¬rst rule of the following program simply
selects an arbitrary vertex X from which to start the search. î€€en, the second rule greedily chooses
at each step an edge .X; Y; C/ of least cost C having X as endpoint.
spath.root; X; 0/
 
vertex.X/; choice../; X/:
spath.X; Y; C/
 
spath.W; X; K/; edge.X; Y; C/; spath.root; Z; 0/; Y Â¤ Z;
choice..X/; .Y //; choice..Y /; .X//; choice-least..Y /; .C//:
î€€e examples above show that the choice constructs provide a logic-based approach for the
design of greedy algorithms. In a nutshell, the design approach is as follows: (i) formulate the all-
answer solution to the problem at hand (e.g., ï¬nd all the costs of all paths from a source vertex to
the other vertices), (ii) use choice-induced functional dependency constraints so that the original
logic program generates non-deterministic single answers (e.g., ï¬nd a cost from the source vertex
to each other vertex), and (iii) specialize the choice atoms into choice-least or choice-most atoms
to force a greedy heuristics upon the generation of single answers (thus computing the least-cost
paths). î€€is approach yields conceptual simplicity and simple programs.
4.7
DISJUNCTION
In this section, we brieï¬‚y discuss the extension of Datalog and Datalog: with disjunction (in
rule heads). î€€e resulting languages will be referred to as Datalog_ and Datalog_;:, respectively.

58
4. NEGATION
Disjunction is an important feature for knowledge representation, database querying, and for
representing incomplete information.
We start by deï¬ning the syntax of Datalog_. A Datalog_ rule r is of the form:
H1 _    _ Hm  A1; : : : ; An;
where m  1, n  0, and both the Hiâ€™s and the Aiâ€™s are atoms (function symbols are not allowed).
î€€e disjunction H1 _    _ Hm is called the head of r while the conjunction A1; : : : ; An is called
the body of r. A Datalog_ program is a ï¬nite set of Datalog_ rules.
î€€e safety condition of Datalog programs (cf. Section 3.1) is generalized by requiring that
every variable appearing in the head must appear in at least one atom of the body, for every
Datalog_ rule.
î€€e semantics of a Datalog_ program is given by its minimal Herbrand models as deï¬ned
below. Consider a Datalog_ program P and a database D. As usual, the Herbrand universe HPD
of PD (recall that PD denotes P [ D) is the set of constants appearing in PD, and the Herbrand
base BPD of PD is the set of ground atoms which can be built using predicate symbols appearing
in PD and constants in HPD. An interpretation of PD is any subset of BPD. Once again, we use
ground.PD/ to denote the set of all ground rules obtained from the rules of PD by replacing all
variables with constants.
î€€e truth value of a ground atom A w.r.t. an interpretation I is true if A 2 I, false otherwise.
A ground rule r is satisï¬ed by I if there is a ground atom in the head of r which is true w.r.t. I or
there is a ground atom in the body of r which is false w.r.t. I. An interpretation of PD is a model
of PD if it satisï¬es every ground rule in ground.PD/. A model M of PD is minimal if no proper
subset of M is a model of PD.
î€€e model-theoretic semantics of a Datalog_ program PD is given by its minimal models.
Obviously, this semantics is a generalization of the model-theoretic semantics for Datalog pro-
grams presented in Section 3.2.1. Notice that while every Datalog program has a unique minimal
model (the least model), a Datalog_ program might have more than one minimal model.
Example 4.36
Consider the Datalog_ program P consisting of the following Datalog_ rule,
saying that a person X is either male or female
male.X/ _ female.X/  person.X/:
Consider also the database D consisting only of the fact person.a/. î€€en, PD has two minimal
models, namely fperson.a/; male.a/g and fperson.a/; female.a/g.
î€€e language obtained by extending Datalog: with disjunction is denoted as Datalog_;:.
More speciï¬cally, a Datalog_;: rule is of the form
H1 _    _ Hm  L1; : : : ; Ln;

4.7. DISJUNCTION
59
where m  1, n  0, the Hiâ€™s are atoms, and the Liâ€™s are literals (i.e., atoms or negated atoms);
function symbols are not allowed. î€€e safety condition is the same as for Datalog: (cf. Sec-
tion 4.1).
A Datalog_;: program is a ï¬nite set of Datalog_;: rules.
î€€e stable model semantics for Datalog: programs is easily generalized to Datalog_;: pro-
grams as follows [Gelfond and Lifschitz, 1991, Przymusinski, 1991].
Consider a Datalog_;: program P and a database D. î€€e Herbrand universe HPD, the
Herbrand base BPD, and interpretations of PD are deï¬ned in the usual way as well as ground.PD/.
Given an interpretation I of PD, let PDI denote the ground Datalog_ program derived from
ground.PD/ by deleting
â€¢ every rule that contains a negative literal :A in its body with A 2 I, and
â€¢ all negative literals in the bodies of the remaining rules.
An interpretation I of PD is a disjunctive stable model of PD if and only if I is a mini-
mal model of PDI. Clearly, this is a generalization of the stable model semantics for Datalog:
programs (cf. Section 4.5.1).
Notice that if P is a Datalog_ program, then PDI D ground.PD/ for any interpretation I
of PD and thus the disjunctive stable models of PD are exactly the minimal models of PD. î€€us,
the disjunctive stable model semantics also generalizes the minimal model semantics discussed
above for Datalog_ programs.
î€€e expressive power and the complexity of Datalog_;: and several sublanguages of it,
under diï¬€erent semantics, are thoroughly studied in Dantsin et al. [2001], Eiter et al. [1997a].
Here we just mention that Datalog_;: is more expressive than Datalog: (unless the polynomial
hierarchy collapses).
BIBLIOGRAPHIC NOTES
Other interesting semantics (which have not been reported in this chapter) have been proposed for
Datalog: programs, such as the inï¬‚ationary and noninï¬‚ationary semantics, partial stable models,
maximal partial stable models, regular models, perfect models, two- and three-valued completion
semantics, and ï¬xpoint models [Abiteboul and Vianu, 1991, Abiteboul et al., 1995, Bidoit and
Hull, 1986, Dudakov, 1999, Eiter et al., 1997b, Furfaro et al., 2007, Kolaitis and Papadimitriou,
1991, Przymusinski, 1988, SaccÃ , 1995, SaccÃ  and Zaniolo, 1991, 1997, Schlipf, 1995, You and
Yuan, 1995].
A extension of the class of locally stratiï¬ed Datalog: programs, called weakly stratiï¬ed
programs, has been proposed by Przymusinska and Przymusinski [1988].
î€€e expressivity and the complexity of various subclasses of Datalog: under diï¬€erent se-
mantics have been studied in Abiteboul et al. [1995], Buccafurri et al. [1997], Cadoli and Palopoli
[1998], Cholak and Blair [1994], Dantsin et al. [2001], Eiter et al. [1998], Greco and SaccÃ  [1996,

60
4. NEGATION
1997a,b, 1999], Greco et al. [2001], Kolaitis [1991], Kolaitis and Vardi [1995], Palopoli [1992],
SaccÃ  [1997].
î€€e expressive power of the choice construct has been studied in Giannotti and Pedreschi
[1998], Giannotti et al. [2001], Greco et al. [1995], where it is shown that it is more powerful than
other nondeterministic constructs, including the witness operator Abiteboul and Vianu [1991],
and the original version of choice (called static choice) proposed in Krishnamurthy and Naqvi
[1988]. For instance, it has been shown in Giannotti et al. [1991] that the task of ordering a
domain or checking whether a relation contains an even number of elements cannot be performed
by Datalog programs with static choice or the witness operator [Abiteboul and Vianu, 1991].
Because of the ability of choice programs to order the elements of a set, Datalog:s with choice
allows us to express all problems in P.
An extension of Datalog with the choice construct and weak constraints has been studied
in Greco [1996, 1998a].
For a more complete treatment of disjunctive logic programming, we refer the reader to
Eiter et al. [1997a], Lobo et al. [1992], Minker [1994], Minker and Seipel [2002].
We conclude by mentioning various systems for Datalog and diï¬€erent extensions of it,
including negation and disjunction: Clasp [Gebser et al., 2012], DeALS [Mazuran et al., 2013,
Shkapsky et al., 2015], DLV [Leone et al.], LogicBlox [Aref et al., 2015], NP Datalog [Greco
et al., 2006, 2010], and Smodels [Simons et al., 2002].

61
C H A P T E R
5
Function Symbols
Function symbols are widely acknowledged as an important feature, as they often make modeling
easier, and the resulting encodings more readable and concise. î€€ey also increase the expressive
power and allow us to overcome the inability of dealing with inï¬nite domains.
î€€e main problem with the introduction of function symbols in Datalog is that the least
model of a program can be inï¬niteâ€”equivalently, the bottom-up program evaluation might not
terminate. Unfortunately, it is undecidable whether the evaluation terminates. In order to cope
with this issue, recent research has focused on identifying classes of programs allowing only a
restricted use of function symbols while ensuring ï¬niteness and computability of the least model.
î€€ese approaches provide conditions, called termination criteria, specifying suï¬ƒcient conditions
for the (bottom-up) program evaluation to terminate.
î€€is chapter presents termination criteria recently proposed in the literature. It also presents
an orthogonal technique, based on program adornment, that can be used in conjunction with
current termination criteria to make them more eï¬€ective.
5.1
SYNTAX AND SEMANTICS
In this chapter, we consider the extension of Datalog with uninterpreted function symbols (i.e.,
they are not evaluated)â€”the resulting language will be referred to as Datalogf .
In addition to inï¬nite sets of constants, variables, and predicate symbols, we assume to have
an inï¬nite set of function symbols. Each function symbol is associated with a ï¬xed arity, which
is a positive integer. Besides constants and variables (which are called simple terms), terms now
include also expressions of the form f .t1; : : : ; tm/, where f is a function symbol of arity m and
the tiâ€™s are termsâ€”terms of this form are called complex.
As for the syntax, a Datalogf rule simply is a Datalog rule (see Section 3.1) where complex
terms can occur. In this chapter, we sometimes call Datalogf rules simply rules. A Datalogf
program is a ï¬nite set of Datalogf rules.
î€€e three semantics for Datalog programs discussed in Chapter 3 can be straightforwardly
generalized to the case where function symbols are allowed.
Compared with the model-theoretic semantics of Datalog programs (cf. Section 3.2.1),
the main diï¬€erence is that the Herbrand universe HP of a Datalogf program P contains the
set of ground terms which can be built using constants and function symbols appearing in P
(while for Datalog programs the Herbrand universe contains only constants). î€€e Herbrand base
BP of P remains deï¬ned as the set of ground atoms which can be built using predicate symbols

62
5. FUNCTION SYMBOLS
appearing in P and ground terms of HP . î€€e ground instances of atoms, Datalogf rules, and
Datalogf programs are still obtained by replacing variables with ground terms of HP . However,
notice that since HP can contain complex terms, the Herbrand base and the ground instantiations
can contain complex terms as well. î€€us, in a nutshell, the main diï¬€erence between Datalog and
Datalogf is that ground terms are not only constants, but also include complex terms built from
function symbols and constants. î€€e other deï¬nitions of Section 3.2.1 remain unmodiï¬ed and
the same notation and terminology therein will be used in the following.
It is important to note that the Herbrand universe is inï¬nite if P contains at least one
function symbol and one constant. As a consequence, the Herbrand base is inï¬nite, and inter-
pretations and models can be inï¬nite too. A Datalogf program has a unique least model, which
can be inï¬nite.
î€€e immediate consequence operator can be deï¬ned for Datalogf programs in the same
way as for Datalog programs (cf. Section 3.2.2), with the only diï¬€erence that the ground instan-
tiations of Datalogf rules and programs are obtained by replacing variables with constants and
ground complex terms built from function symbols and constants. As for Datalogf programs,
the least model coincides with the least ï¬xpoint of the immediate consequence operator.
Example 5.1
Consider the following Datalogf program which counts the number of elements
in a list:
r0 W count.Å’a; b; cÂ; 0/:
r1 W count.L; s.I//  count.Å’XjLÂ; I/:
î€€e bottom-up evaluation of the program terminates yielding the set of atoms count.Å’a; b; cÂ; 0/,
count.Å’b; cÂ; s.0//, count.Å’cÂ; s.s.0///, and count.Å’ Â; s.s.s.0////. î€€e length L of list Å’a; b; cÂ can
be retrieved from the atom count.Å’ Â; L/ by counting the number of s in L, which 3 in this case.Â¹
To make function symbols more explicit, the program above can be rewritten into the fol-
lowing Datalogf program:
r0 W count.lc.a; lc.b; lc.c; nil///; 0/:
r1 W count.L; s.I//  count.lc.X; L/; I/:
Here lc is a binary function symbol denoting the list constructor operator, and nil denotes the
empty list.
5.2
TERMINATION CRITERIA
î€€e main problem with the introduction of function symbols in Datalog is that the least model
can be inï¬nite and thus cannot be fully and explicitly computed. To deal with this issue, subclasses
of Datalogf imposing a restricted use of function symbols, but guaranteeing the computability of
Â¹Notice that the program has been written so as to count the number of elements in a list when evaluated in a bottom-up
fashion, and therefore diï¬€ers from the classical formulation relying on a top-down evaluation strategy. However, programs
relying on a top-down evaluation strategy can be rewritten into programs whose bottom-up evaluation gives the same result.

5.2. TERMINATION CRITERIA
63
the least model have been proposedâ€”this section surveys several of such subclasses proposed in
the literature. We start by introducing some additional notation and terminology used throughout
the chapter.
î€€e binary relation subterm over terms is recursively deï¬ned as follows: every term is a
subterm of itself; if t is a complex term of the form f .t1; : : : ; tm/, then every ti is a subterm of t,
for 1  i  m; if t1 is a subterm of t2 and t2 is a subterm of t3, then t1 is a subterm of t3.
Given a predicate symbol p of arity n, the i-th argument of p is an expression of the form
pÅ’iÂ, for 1  i  n. If p is a base (resp. derived) predicate symbol, then pÅ’iÂ is said to be a base
(resp. derived) argument. î€€e set of all predicate symbols appearing in a Datalogf program P is
denoted by pred.P /. î€€e set of all arguments of P is denoted by arg.P /, that is, arg.P / D fpÅ’iÂ j
p belongs to pred.P /; and has arity n and 1  i  ng.
î€€e following subsections present current termination criteria.
5.2.1
-RESTRICTED PROGRAMS
In this section, we present the class of -restricted programs [Gebser et al., 2007].
Given a Datalogf program P , we use V.r/ to denote the set of variables appearing in a
rule r 2 P and B.X; r/ to denote the set of predicate symbols of the atoms in the body of r which
contain variable X. Moreover, recall that def.p; P / denotes the deï¬nition of a predicate symbol
p in P , that is, the set of rules of P having p in the head atom.
Deï¬nition 5.2
-restricted program.
A Datalogf program P is -restricted if there exists
a mapping  W pred.P / ! N such that, for every predicate symbol p 2 pred.P /, the following
holds:
maxfmaxfminf.p0/j p0 2 B.X; r/gj X 2 V.r/gj r 2 def.p; P /g < .p/:
Intuitively, the condition stated in the deï¬nition above means that, for each predicate sym-
bol p, all the variables in rules deï¬ning p are â€œboundedâ€ by predicate symbols p0 in the body
such that .p0/ < .p/. If this is the case, the feasible ground instances of rules in def.p; P / are
completely determined by predicate symbols from lower levels than the one of p.
Example 5.3
î€€e following Datalogf program is -restricted:
p.f .X//
 
q.X/:
q.X/
 
p.X/; r.X/:
In fact, it can be easily veriï¬ed that the mapping  deï¬ned as .r/ D 1, .q/ D 2, .p/ D 3
satisï¬es the condition of Deï¬nition 5.2.
One limitation of -restriction is that some Datalog programs (thus, without function sym-
bols) are not recognized as -restrictedâ€”however, the least model of a Datalog program is always

64
5. FUNCTION SYMBOLS
ï¬nite and the bottom-up evaluation always terminates. An example is the following Datalog pro-
gram:
p.X/  q.X/:
q.X/  p.X/:
To satisfy the condition of Deï¬nition 5.2, any mapping  from predicate symbols to natural
numbers should be s.t. .p/ > .q/ (because of the ï¬rst rule) and .q/ > .p/ (because of the
second rule); since such a mapping does not exist, the program above is not -restricted. î€€us,
by relying on the -restriction criterion, no conclusion can be drawn on the termination of the
program above.
5.2.2
FINITE DOMAIN PROGRAMS
Finite domain programs have been introduced by Calimeri et al. [2008]. î€€e deï¬nition relies on
the notion of argument graph, deï¬ned below, which represents the propagation of values among
arguments of a Datalogf program.
Deï¬nition 5.4
Argument graph.
î€€e argument graph of a Datalogf program P , denoted
G.P /, is a directed graph whose set of nodes is arg.P /, and there is an edge .qÅ’j Â; pÅ’iÂ/ iï¬€there
is a rule r 2 P such that
â€¢ an atom p.t1; : : : ; tn/ appears in head.r/,
â€¢ an atom q.u1; : : : ; um/ appears in body.r/, and
â€¢ terms ti and uj have a common variable.
Example 5.5
Consider the following Datalogf program, where base is a base predicate symbol.
q.X; Y /
 
p.X/; base.Y /:
p.f .X; Y //
 
q.X; Y /:
î€€e argument graph is depicted in Figure 5.1.
Given a Datalogf program P , an argument pÅ’iÂ is said to be recursive if it appears in a
cycle of G.P /; two arguments pÅ’iÂ and qÅ’j Â are mutually recursive if there exists a cycle in G.P /
involving both pÅ’iÂ and qÅ’j Â. For instance, considering the Datalogf program of Example 5.5,
arguments baseÅ’1Â and qÅ’2Â are not recursive while pÅ’1Â and qÅ’1Â are recursive. Moreover, pÅ’1Â and
qÅ’1Â are mutually recursive.
Deï¬nition 5.6 Finite domain program.
Given a Datalogf program P , the set of ï¬nite domain
arguments of P is the maximal set FD.P / of arguments of P such that, for each argument qÅ’kÂ 2
FD.P /, every rule r whose predicate symbol in the head is q satisï¬es the following condition. Let
t be the term corresponding to argument qÅ’kÂ in the head of r. î€€en, either

5.2. TERMINATION CRITERIA
65
p[1]
base[1]
q[1]
q[2]
Figure 5.1: Argument graph.
1. t is variable-free,
2. t is a subterm of a term corresponding to a ï¬nite domain argument of a body predicate
symbol, or
3. every variable appearing in t also appears in a term corresponding to a ï¬nite domain argu-
ment of a body predicate symbol which is not mutually recursive with qÅ’kÂ.
If all arguments of P are ï¬nite domain (i.e., FD.P / D arg.P /), then P is a ï¬nite domain program.
Example 5.7
Consider the following simple Datalogf program
q.X/  q.f .X//:
Obviously, qÅ’1Â is mutually recursive with itself. It can be easily veriï¬ed that the program above
is ï¬nite domain (by applying the second condition of Deï¬nition 5.6).
Checking whether a Datalogf program P is ï¬nite domain or not can be done by ï¬rst
assuming that all arguments are in FD.P / and then iteratively eliminating arguments appearing
in the head of a rule such that none of the three conditions of Deï¬nition 5.6 holds. î€€us, checking
whether a Datalogf program is ï¬nite domain is decidable.
Notice that all Datalog programs (i.e., no function symbols are allowed) are ï¬nite domain:
by assuming that all arguments of a Datalog program are ï¬nite domain, it is easy to see that, for
all of them, the ï¬rst or second condition of Deï¬nition 5.6 is always satisï¬ed.
Moreover, the class of ï¬nite domain programs is not comparable with the class of -
restricted programs.
Example 5.8
Consider the two Datalogf programs of Example 5.3. As discussed before, the
ï¬rst one is -restricted while the second one is not. On the other hand, the second program is

66
5. FUNCTION SYMBOLS
ï¬nite domain (in fact, it is a Datalog program) while the ï¬rst one is not. To see why the ï¬rst
program is not ï¬nite domain, it suï¬ƒces to notice that if we assume that all arguments are ï¬nite
domain, then pÅ’1Â and the ï¬rst rule do not satisfy any of the conditions of Deï¬nition 5.6.
5.2.3
ARGUMENT-RESTRICTED PROGRAMS
î€€e class of argument-restricted programs has been introduced by Lierler and Lifschitz [2009].
Before presenting its deï¬nition, some additional notation is introduced. For any atom A of the
form p.t1; : : : ; tn/, we use A0 to denote predicate symbol p and Ai to denote term ti, for 1  i 
n. î€€e depth d.X; t/ of a variable X in a term t that contains X is recursively deï¬ned as follows:
d.X; X/ D 0;
d.X; f .t1; : : : ; tm// D 1 C
max
i W ti contains X d.X; ti/:
Deï¬nition 5.9 Argument-restricted program.
An argument ranking for a Datalogf program
P is a function  from arg.P / to integers such that the following condition is satisï¬ed for every
rule r of P . Let A be the atom in the head of r. For every variable X occurring in a term Ai,
body.r/ contains an atom B such that X occurs in a term Bj satisfying the condition
.A0Å’iÂ/   .B0Å’j Â/  d.X; Ai/   d.X; Bj /:
A Datalogf program is argument-restricted if it has an argument ranking.
Example 5.10
î€€e two programs of Example 5.3 are both argument-restricted. For the ï¬rst
one, an argument ranking is .pÅ’1Â/ D 1, .qÅ’1Â/ D .rÅ’1Â/ D 0. For the second program, an
argument ranking is .pÅ’1Â/ D .qÅ’1Â/ D 0.
Argument-restricted programs strictly include -restricted and ï¬nite domain pro-
grams [Lierler and Lifschitz, 2009]. An algorithm for checking whether a Datalogf program
is argument-restricted can be found in Lierler and Lifschitz [2009].
5.2.4
SAFE PROGRAMS
î€€e class of safe programs [Greco et al., 2012b] is an extension of the class of ï¬nite domain pro-
grams. Its deï¬nition is based on the notions of activation graph and safe argument.
Let P be a Datalogf program and r1; r2 be (not necessarily distinct) rules of P . We say
that r1 activates r2 iï¬€there exist two ground rules r0
1 2 ground.r1/, r0
2 2 ground.r2/ and an inter-
pretation I such that (i) I 6Ë† r0
1, (ii) I Ë† r0
2, and (iii) I [ head.r0
1/ 6Ë† r0
2. î€€is intuitively means

5.2. TERMINATION CRITERIA
67
that if I does not satisfy r0
1, I satisï¬es r0
2, and head.r0
1/ is added to I to satisfy r0
1, this causes r0
2
not to be satisï¬ed anymore (and then to be â€œactivatedâ€).
Deï¬nition 5.11
Activation graph.
î€€e activation graph of a Datalogf program P , denoted
Ë.P /, is a directed graph whose nodes are the rules of P , and there is an edge .ri; rj / in the
graph iï¬€ri activates rj.
Example 5.12
Consider the following Datalogf program:
r0 W
p.X/
 
base.X/:
r1 W
q.f .X//
 
p.X/:
r2 W
p.g.X//
 
q.X/;
where base is a base predicate symbol. It is easy to see that r0 activates r1, but not vice versa; r1
activates r2 and vice versa. î€€e activation graph is shown in Figure 5.2.
r0
r1
r2
Figure 5.2: Activation graph.
Deï¬nition 5.13 Safe program.
Given a Datalogf program P , the set of safe arguments safe.P /
is computed by ï¬rst setting safe.P / D FD.P / (cf. Deï¬nition 5.6) and next iteratively adding each
argument qÅ’kÂ of P such that for every rule r 2 P where q appears in the head,
â€¢ r does not appear in a cycle of Ë.P /, or
â€¢ if q.t1; : : : ; tn/ is the head atom, then for every variable X appearing in tk, there is an atom
p.u1; : : : ; um/ in body.r/ and a term ui (1  i  m) s.t. X appears in ui and pÅ’iÂ is safe.

68
5. FUNCTION SYMBOLS
A Datalogf program P is said to be safe if all its arguments are safe.
Example 5.14
î€€e following Datalogf program, where base is a base predicate symbol, is safe
as its activation graph does not have cycles (notice that rule r2 does not activate itself):
r1 W
p.X; X/
 
base.X/:
r2 W
p.f .X/; g.X//
 
p.X; X/:
Although the class of safe programs strictly includes -restricted programs, the classes of
safe and argument-restricted programs are not comparable, as shown in the following example.
Example 5.15
î€€e Datalogf program of Example 5.14 is safe, but not argument-restricted.
On the other hand, the following Datalogf program, where base is a base predicate symbol, is
argument-restricted, but not safe:
r1 W
q.X; f .X//
 
p.X/:
r2 W
r.X; Y /
 
q.X; Y /:
r3 W
p.X/
 
r.Y; X/; base.X/:
r4 W
t.X; X/
 
q.Y; X/:
r5 W
q.X; X/
 
t.X; Y /:
r6 W
t.X; g.X; Y1; Y2//
 
t.Y1; X/; q.Y2; X/:
It can be readily veriï¬ed that the function  deï¬ned as follows is an argument ranking, and thus,
the program above is argument-restricted:
.pÅ’1Â/ D 0;
.baseÅ’1Â/ D 0;
.qÅ’1Â/ D 1;
.qÅ’2Â/ D 1;
.rÅ’1Â/ D 1;
.rÅ’2Â/ D 1;
.tÅ’1Â/ D 1;
.tÅ’2Â/ D 2:
î€€e set of ï¬nite domain arguments is fbaseÅ’1Â; pÅ’1Âg, which is also the set of safe arguments. î€€us,
the program above is not safe.
5.2.5
  -ACYCLIC PROGRAMS
  -acyclic programs have been introduced by Greco et al. [2012b]. î€€e deï¬nition of   -acyclic
programs relies on the notion of propagation graph deï¬ned below.
Deï¬nition 5.16 Propagation graph.
î€€e (labeled) propagation graph .P / of a Datalogf pro-
gram P is a labeled directed graph deï¬ned as follows. î€€e set of nodes is the set of non-safe
arguments (see Deï¬nition 5.13) of P , also-called aï¬€ected arguments and denoted as aff.P /. î€€e
set of (labeled) edges is deï¬ned in the following way: for each pair of nodes pÅ’iÂ; qÅ’j Â 2 aff.P /
and for every rule r 2 P such that

5.2. TERMINATION CRITERIA
69
â€¢ there is an atom p.t1; : : : ; tn/ in the head of r,
â€¢ there is an atom q.u1; : : : ; um/ in the body of r, and
â€¢ the same variable X occurs in both ti and uj,
there is a labeled edge .qÅ’j Â; pÅ’iÂ; Ë›/ 2 E, where Ë› is deï¬ned as follows:
â€¢ Ë› D  if ti D uj,
â€¢ Ë› D f if uj D X and ti D f .: : : ; X; : : : /, and
â€¢ Ë› D f if uj D f .: : : ; X; : : : / and ti D X.
In the previous deï¬nition,  is used to denote the empty string. Furthermore, without loss
of generality, we assumed that if the same variable occurs in two terms appearing in the head and
in the body of a rule, then one term is a subterm of the other and the nesting level of the complex
terms is at most one.
î€€e deï¬nition of   -acyclic programs relies also on the grammar introduced in the following
deï¬nition.
Deï¬nition 5.17 Grammar  P .
Let P be a Datalogf program and FP the set of function sym-
bols occurring in P . î€€e grammar  P is a 4-tuple .N; T; R; S/, where N D fS; S1; S2g is the set
of nonterminal symbols, S is the start symbol, T D ff j f 2 FP g [ ff j f 2 FP g is the set of
terminal symbols, and R is the set consisting of the following production rules:
â€¢ S ! S1 f S2,
8f 2 FP ;
â€¢ S1 ! f S1 f S1 j ,
8f 2 FP ;
â€¢ S2 ! .S1 j f / S2 j ,
8f 2 FP .
î€€e language L. P / is the set of strings generated by  P .
A path  in a propagation graph .P / is a sequence .a1; b1; Ë›1/; : : : ; .ak; bk; Ë›k/ of labeled
edges of .P /, where k  1 and bi D aiC1 for all 1  i < k. If a1 D bk, then  is also called
a cycle. For any path  as above, we denote with ./ the string Ë›1 : : : Ë›k. Given a grammar
 P D .N; T; R; S/ and a propagation graph .P /, we say that path  in .P / spells a string
w 2 L. P / if ./ D w. We are now ready to deï¬ne   -acyclic programs.
Deï¬nition 5.18   -acyclic program.
A Datalogf program P is   -acyclic if there is no cycle in
.P / spelling a string of L. P /.
It straightforwardly follows from the deï¬nition above that the class of safe programs is a
subset of the class of   -acyclic programs. In fact, for every safe program, the propagation graph
is empty (because the set of aï¬€ected arguments is empty, cf. Deï¬nition 5.16), and thus, the

70
5. FUNCTION SYMBOLS
condition of   -acyclicity of Deï¬nition 5.18 is trivially satisï¬ed. î€€e class of   -acyclic programs
strictly contains that of safe programs, while it is not comparable with that of argument-restricted
programs, as shown in the following example.
Example 5.19
As already discussed, the Datalogf program of Example 5.14 is safe, but not
argument-restricted. Since the program is safe, then it is also   -acyclic.
î€€e following Datalogf program is   -acyclic but not safe (it is not argument-restricted
either):
r1 W
r.f .X//
 
s.X/:
r2 W
q.f .X//
 
r.X/:
r3 W
p.X/
 
q.X/:
r4 W
n.X/
 
p.g.X//:
r5 W
s.X/
 
n.X/:
Notice that all arguments are aï¬€ected. î€€e propagation graph has a single cycle going through all
arguments of the program, and the corresponding string is ff g. Since the string does not belong
to the language L. P /, the program is   -acyclic.
As already shown, the Datalogf program of Example 5.15 is argument-restricted. It can
be easily veriï¬ed that the corresponding propagation graph has a cycle spelling a string of L. P /
(e.g., there is a cycle going through tÅ’1Â and tÅ’2Â whose associated string is g). î€€us, the program
is not   -acyclic.
5.2.6
BOUNDED PROGRAMS
A termination criterion more general than the ones presented thus far has been proposed by Greco
et al. [2013a], who introduced the class of bounded programs, which strictly includes the classes
of programs presented in the previous sections.
î€€e criterion relies on two powerful tools: (i) the labeled argument graph, a directed graph
whose edges are labeled with useful information on how terms are propagated from the body to
the head of rules, and (ii) the activation graph presented before (Deï¬nition 5.11). î€€e labeled
argument graph is used in synergy with the activation graph for a better understanding of how
terms are propagated.
Another relevant aspect that distinguishes the criterion presented in this section from the
the termination criteria previously discussed is that the latter analyze one group of arguments
(depending on each other) at a time, without looking at how groups of arguments are related. On
the contrary, the criterion of bounded programs can be used to perform an analysis of how groups
of arguments aï¬€ect each other.
For instance, none of the termination criteria discussed in the previous sections is able to
realize that the bottom-up evaluation of the program of Example 5.1 terminates. Intuitively, this
is because they analyze how the ï¬rst argument of count aï¬€ects itself and how the second argument
of count aï¬€ects itself, but miss noticing that the growth of the latter is bounded by the reduction

5.2. TERMINATION CRITERIA
71
of the former. One of the novelties of the criterion presented in this section is the capability of
doing this kind of reasoningâ€”indeed, it is able to realize that the bottom-up evaluation of the
program above terminates.
We start by introducing some notation and terminology used in the following. We deï¬ne
a partial argument ranking for a Datalogf program P as a partial function  from arg.P / to
non-negative integers, such that the following condition is satisï¬ed for every rule r of P . Let A
be the atom occurring in the head of r. For every variable X occurring in a term Ai, if .A0Å’iÂ/ is
deï¬ned, then body.r/ contains an atom B such that X occurs in a term Bj, .B0Å’jÂ/ is deï¬ned,
and the following condition is satisï¬ed:
.A0Å’iÂ/   .B0Å’jÂ/  d.X; Ai/   d.X; Bj /:
î€€e
set
of
restricted
arguments
of
P
is
AR.P / D fpÅ’iÂ
j
pÅ’iÂ 2 arg.P / ^
there exists a partial argument ranking  s:t: .pÅ’iÂ/ is deï¬nedg.
An argument pÅ’iÂ in arg.P / is said to be limited iï¬€for any ï¬nite database D, the set
fti j p.t1; : : : ; ti; : : : ; tn/ 2 Mg is ï¬nite, where M is the least model of PD.
For ease of presentation, we assume that if the same variable occurs in two terms appearing
in the head and in the body of a rule, then one term is a subterm of the other, and complex terms
are of the form f .t1; : : : ; tm/ with the tiâ€™s being simple terms. î€€ere is no loss of generality in
such assumptions as every Datalogf program can be rewritten into an equivalent one satisfying
such conditions (e.g., a rule of the form p.f .h.X/// q.g.X// can be rewritten into the three
rules p.f .X// p0.X/, p0.h.X// p00.X/, and p00.X/ q.g.X//).
Below we introduce the ï¬rst tool used to deï¬ne bounded programs. It is a new graph derived
from the argument graph by labeling edges with additional information.
Deï¬nition 5.20 Labeled argument graph.
î€€e labeled argument graph of a Datalogf program
P , denoted GL.P /, is a directed graph whose set of nodes is arg.P /, and the set of labeled edges
is deï¬ned as follows. For each pair of nodes pÅ’iÂ; qÅ’j Â 2 arg.P /, and for every rule r 2 P such
that
1. there is an atom p.t1; : : : ; tn/ in head.r/,
2. there is an atom q.u1; : : : ; um/ in body.r/, and
3. terms ti and uj have a common variable X;
there exists an edge .qÅ’j Â; pÅ’iÂ; hË›; r; ki/, where k is a natural number denoting the position of
q.u1; : : : ; um/ in body.r/,Â² and
â€¢ Ë› D  if uj D ti;
Â²We assume that atoms in the body are ordered with the ï¬rst one being associated with 1, the second one with 2, etc. î€€e order
is used only for the purpose of identifying body atoms.

72
5. FUNCTION SYMBOLS
r0
1
b[1]
f,r ,2
0
Ñ”,r ,1
ÌŸ
5
ÌŸ1
ÌŸ2
ÌŸ3
ÌŸ4
ÌŸ
6
1
1
f,r ,1
2
f,r ,1
3
f,r ,1
3
f,r ,1
2
Ñ”,r ,1
Ñ”,r ,1
4
Ñ”,r ,1
4
h,r ,1
0
Ñ”,r ,1
a[1]
t[1]
t[2]
q[1]
q[2]
s[1]
s[2]
r1
r2
r4
r3
Figure 5.3: Labeled argument and activation graphs.
â€¢ Ë› D f if uj D X and ti D f .: : : ; X; : : : /; and
â€¢ Ë› D f if uj D f .: : : ; X; : : : / and ti D X.
Example 5.21
Consider the following Datalogf program
r0 W
t.X; X/
 
a.X/:
r1 W
q.f .X/; Y /
 
t.X; Y /; b.X/:
r2 W
t.X; f .Y //
 
q.X; Y /:
r3 W
q.f .X/; f .Y //
 
s.X; Y /:
r4 W
s.X; Y /
 
q.h.X/; Y /;
where a and b are base predicate symbols. î€€e labeled argument and activation graphs of the
program above are depicted in Figure 5.3. For instance, the edge .tÅ’1Â; qÅ’1Â; hf; r1; 1i/ says that
the ï¬rst atom in the body of r1 is an atom whose predicate symbol is t, its ï¬rst term is a variable,
say X, and the atom in the head of r1 is an atom whose predicate symbol is q and whose ï¬rst
term is of the form f .: : : ; X; : : : /. We will show how this kind of information can be proï¬tably
used to analyze Datalogf programs (e.g., to keep track of how complex terms are generated from
argument to argument).
A path  from a1 to bm in a labeled argument graph GL.P / is a non-empty sequence
.a1; b1; hË›1; r1; k1i/; : : : ; .am; bm; hË›m; rm; kmi/ of labeled edges of GL.P / s.t. bi D aiC1 for all
1  i < m. If the ï¬rst and last nodes coincide (i.e., a1 D bm), then  is called a cyclic path. We de-
ï¬ne 1./ D Ë›1 : : : Ë›m as the sequence of  and function symbols labeling the edges of , 2./ D

5.2. TERMINATION CRITERIA
73
r1; : : : ; rm as the sequence of rules labeling the edges of , and 3./ D hr1; k1i : : : hrm; kmi as
the sequence of pairs hrule, body atom identiï¬eri labeling the edges of . In the case where the
indication of the start edge is not relevant, we will call a cyclic path a cycle. Given a cycle  consist-
ing of n labeled edges e1; : : : ; en, we can derive n diï¬€erent cyclic paths starting from each of the
eiâ€™sâ€”we use ./ to denote the set of such cyclic paths. As an example, if  is a cycle consisting of
labeled edges e1; e2; e3, then ./ D f.e1; e2; e3/; .e2; e3; e1/; .e3; e2; e1/g. Given two cycles 1
and 2, we write 1 2 iï¬€there exist 1 2 .1/ and 2 2 .2/ such that 3.1/ D 3.2/. A
cycle is basic if it does not contain two occurrences of the same edge.
We say that a node pÅ’iÂ of GL.P / depends on a node qÅ’j Â of GL.P / iï¬€there is a path from
qÅ’j Â to pÅ’iÂ in GL.P /. Moreover, we say that pÅ’iÂ depends on a cycle  iï¬€it depends on a node
qÅ’j Â appearing in . Clearly, nodes belonging to a cycle  depend on . We say that 2./ D
r1; : : : ; rm denotes a cyclic path in the activation graph Ë.P / iï¬€.r1; r2/; : : : ; .rm 1; rm/; .rm; r1/
are edges of the activation graph Ë.P /.
Deï¬nition 5.22 Active cycle.
Given a Datalogf program P , we say that a cycle  in GL.P /
is active iï¬€9 2 ./ such that 2./ denotes a cyclic path in the activation graph Ë.P /.
î€€us, checking if a cycle in the labeled argument graph is active requires looking at the
activation graph. Here the basic idea is to check, based on the information reported in the acti-
vation graph, if the propagation of terms along a cycle of the labeled argument graph can really
take place. We illustrate this with the following example.
Example 5.23
Consider the labeled argument graph and the activation graph of Example 5.21
(cf. Figure 5.3). Cycles 1 and 3 in Figure 5.3 are active as .r1; r2/; .r2; r1/ is a cyclic path in the
activation graph. On the contrary, it is easy to check that cycles 2 and 4 in Figure 5.3 are not
active.
In the previous example, the labeled edges of the non-active cycle 4 say that a complex
term with function symbol f might be generated from sÅ’2Â to qÅ’2Â (using rule r3), be propagated
from qÅ’2Â to sÅ’2Â (using rule r4), and so on and so forth, possibly causing the generation of complex
terms of unbounded size. However, in order for this to happen, rules r3 and r4 should activate
each other, which is not the case from an analysis of the activation graph. î€€us, we can conclude
that the generation of unbounded terms cannot really happen.
On the other hand, active cycles might lead to the generation of terms of unbounded size.
To establish whether this can really be the case, a deeper analysis of the cycles in the labeled
argument graph is performed. Speciï¬cally, grammars are used to analyze edge labels to get a
better understanding of what terms can be propagated among arguments. We use two distinct
languages which allows us to distinguish between â€œgrowingâ€ paths, which could give rise to terms
of inï¬nite size, and â€œbalancedâ€ paths, where propagated terms do not grow (see Deï¬nition 5.25).

74
5. FUNCTION SYMBOLS
In addition to the grammar  P of Deï¬nition 5.17, we deï¬ne the grammar   0
P below.
Deï¬nition 5.24 Grammar   0
P .
Let P be a Datalogf program and FP the set of function sym-
bols occurring in P . î€€e grammar   0
P is a 4-tuple .N; T; R; S/ where N D fSg is the set of
nonterminal symbols, S is the start symbol, T D ff j f 2 FP g [ ff j f 2 FP g is the set of
terminal symbols, R contains the production rule:
â€¢ S ! f S f S j ,
8f 2 FP .
î€€e language L.  0
P / is the set of strings generated by   0
P .
Notice that L. P / \ L.  0
P / D ;. Recall that grammar  P has been introduced in Greco
et al. [2012b] to analyze cycles of the propagation graph. Here we consider a more detailed anal-
ysis of the relationships among arguments by considering also   0
P . Intuitively, strings in L. P /
describe growing sequences of functions symbols used to compose and decompose complex terms,
so that, starting from a given term we obtain a larger term. On the other hand, strings in L.  0
P /
describe â€œbalancedâ€ sequences of functions symbols used to compose and decompose complex
terms, so that starting from a given term we obtain the same term.
Deï¬nition 5.25 Classiï¬cation of cycles.
Given a Datalogf program P and a cycle  in GL.P /,
we say that  is
â€¢ growing if there is  2 ./ s.t. 1./ 2 L. P /,
â€¢ balanced if there is  2 ./ s.t. 1./ 2 L.  0
P /, and
â€¢ failing otherwise.
Consider the labeled argument graph in Figure 5.3. Cycles 1, 3, and 4 are growing,
whereas cycle 2 is failing. Observe that, in general, a failing cycle is not active, but the inverse is
not true. In fact, cycle 4 from Figure 5.3 is not active even if it is not failing.
î€€e tools introduced so far are used to deï¬ne the binding operator 	P (Deï¬nition 5.26
below). î€€e idea is to compute the ï¬xpoint of 	P starting from a set of limited arguments, so
as to get a set of limited arguments, which can be used as an underestimation of the limited
arguments of the program. If the ï¬xpoint computation gives us all arguments of P , then P is
bounded.
Deï¬nition 5.26
	P operator.
Let P be a Datalogf program and A  arg.P /. We deï¬ne
	P .A/ as the set of arguments qÅ’kÂ of P such that, for each cycle  in GL.P / on which qÅ’kÂ
depends, at least one of the following conditions holds:
1.  is not active or is not growing;

5.2. TERMINATION CRITERIA
75
2.  contains an edge .sÅ’j Â; pÅ’iÂ; hf; r; li/ and, letting p.t1; : : : ; tn/ be the atom in the head of
r, for every variable X in ti, there is an atom b.u1; : : : ; um/ in body.r/ s.t. X appears in a
term uh and bÅ’hÂ 2 A; and
3. there is a cycle 0 in GL.P / s.t. 0 , 0 is not balanced, and 0 passes only through
arguments in A.
î€€e following example illustrates the 	P operator.
Example 5.27
Consider the Datalogf program of Example 5.21, whose labeled argument and
activation graphs are reported in Figure 5.3. Notice that cycles 1 and 3 are growing and active,
2 is failing and non-active, 4 is growing and non-active. î€€e cycle 5 composed by 1 and 2
(denoted by a dashed line) is failing and non-active, and the cycle 6 composed by 3 and 4
(denoted by a dashed line) is growing and non-active. Furthermore, base arguments aÅ’1Â and bÅ’1Â
do not depend on any cycle; tÅ’1Â, qÅ’1Â, sÅ’1Â depend on 1, 2, and 5; tÅ’2Â, qÅ’2Â, sÅ’2Â depend on
3, 4, and 6. By iteratively applying operator 	P starting from ; we have:
â€¢ A1 D 	P .;/ D faÅ’1Â; bÅ’1Âg;
â€¢ A2 D 	P .A1/ D A1 [ ftÅ’1Â; qÅ’1Â; sÅ’1Âg as Condition 2 of Deï¬nition 5.26 applies to 1, and
Condition 1 applies to 2 and 5; and
â€¢ A3 D 	P .A2/ D A2 [ ftÅ’2Â; qÅ’2Â; sÅ’2Âg as Condition 1 applies to 4 and 6, and Condi-
tion 3 applies to 3 (in fact, 1 3, 1 is not balanced and goes only through nodes in
A3).
î€€erefore, we derive that all arguments are limited.
We are now ready to deï¬ne the class of bounded programs. Given a Datalogf program P , we
start with the set of restricted arguments AR.P /, which gives a good and eï¬ƒciently computable
approximation of the set of limited arguments; then, we iteratively apply operator 	P trying to
infer more limited arguments. If, eventually, all arguments in arg.P / are determined as limited,
then P is bounded.
More formally, given a Datalogf program P , the i-th iteration of 	P (i  1) w.r.t. a set
A  arg.P / is deï¬ned as follows: 	 1
P .A/ D 	P .A/ and 	 i
P .A/ D 	P .	 i 1
P
.A// for i > 1. It can
be easily veriï¬ed that 	P always has a ï¬xpoint, denoted by 	 1
P .A/.
Deï¬nition 5.28 Bounded programs.
î€€e set of bounded arguments of a Datalogf program P
is 	 1
P .AR.P //. We say that P is bounded iï¬€all its arguments are bounded.
Bounded programs strictly include argument-restricted and   -acyclic programs [Greco
et al., 2013a].

76
5. FUNCTION SYMBOLS
5.3
PROGRAM ADORNMENT
î€€e termination criteria discussed in the previous section are not able to identify as terminating
even simple Datalogf programs whose bottom-up evaluation always terminates. For instance,
consider the following example.
Example 5.29
Consider the following Datalogf program
p.X; X/
 
base.X/:
q.X; Y /
 
p.X; Y /:
p.f .X/; g.X//
 
q.X; X/;
where base is a base predicate symbol. î€€e bottom-up evaluation of the program terminates what-
ever set of facts for base is added to it. Nevertheless, none of the termination criteria introduced
so far is able to realize that the bottom-up evaluation terminates.
In this section, we present an orthogonal technique that, used in conjunction with current
termination criteria, allows us to detect more Datalogf programs whose evaluation terminates.
î€€e technique has been introduced in Greco et al. [2013b]. It takes a Datalogf program P and
transforms it into an â€œadornedâ€ Datalogf program P  with the aim of applying termination cri-
teria to P  rather than P . î€€e transformation is sound in that if P  satisï¬es a certain termination
criterion, then the bottom-up evaluation of P terminates.
Applying termination criteria to adorned programs rather than the original ones makes
termination criteria (strictly) more eï¬€ective, that is, (strictly) more programs whose evaluation
terminates are recognized. Roughly speaking, each adorned rule is obtained from a rule in the
original program by adding adornments, which keep track of the structure of the terms that can
be propagated during the bottom-up evaluation. Here the basic idea is to generate only rules that
have a chance to trigger, and disregard those rules that have no chance to trigger (because what
can actually be derived during the program evaluation does not comply with the structure of the
body). As adorning predicate symbols possibly breaks â€œcyclicâ€ dependencies among arguments
and/or rules, this often allows us to recognize more Datalogf programs as terminating than if
termination criteria are applied to the original Datalogf programs. An example is provided below.
Example5.30
Consider again the Datalogf program of Example 5.29. î€€e technique presented
in this section transforms it into the following adorned Datalogf program:
p.X; X/
 
base.X/:
q.X; Y /
 
p.X; Y /:
pf1g1.f .X/; g.X//
 
q.X; X/:
qf1g1.X; Y /
 
pf1g1.X; Y /:
î€€e adorned program above is â€œequivalentâ€ to the original one of Example 5.29 in that the least
model of the original program can be obtained from the least model of the transformed program
by dropping adornments.

5.3. PROGRAM ADORNMENT
77
As opposed to the original program, the transformed program above is not recursive, and
thus, it is easily recognized as terminating by all current termination criteria. î€€is allows us to say
that the bottom-up evaluation of the original program is terminating because of the aforemen-
tioned equivalence.
For the sake of simplicity and without loss of generality, we assume that databases do not
contain complex terms (hence, we can assume that base atoms in rule bodies do not contain
complex terms). For instance, the set of facts fbase.a/; base.f .b//g can be replaced with the set
of facts fbase.a/; base.b/g and the rules fbased.a/  base.a/; based.f .b//  base.b/g, where
based is a derived predicate symbol. Additionally, atoms appearing in rule bodies and having base
as predicate symbol are replaced with the same atoms where based replaces base. Since databases
are not relevant for the proposed technique, they are not shown in examples. In fact, as discussed
in the following, the technique allows us to conclude that the evaluation of a Datalogf program
terminates for any database that is added to the program.
We start by introducing notation and terminology used hereafter. We will use the
notation p.t/ to refer to an atom p.t1; : : : ; tn/ (here t is understood to be a sequence
of n terms). Given a Datalogf program P , we deï¬ne the adornment alphabet  D fg [
ffi j f is a function symbol in P and i 2 Ng; elements of  are called adornment symbols. An
adornment Ë› for a predicate symbol p of arity n is a string of length n over the alphabet ; the
expression pË› is an adorned predicate symbol, and pË›.t1; : : : ; tn/ is an adorned atom, where the tiâ€™s
are terms. An adorned conjunction is a conjunction of adorned atoms. An adorned rule is a rule con-
taining only adorned atoms. Given an adornment symbol fi in    fg, an adornment deï¬nition
for fi is an expression of the form fi D f .Ë›1; : : : ; Ë›m/, where m is the arity of function symbol
f and the Ë›iâ€™s are adornment symbols. As an example, if the transformation technique derives
an adorned predicate symbol pf1g1 with adornment deï¬nitions f1 D f ./ and g1 D g.f1/, this
means that the bottom-up evaluation of the considered Datalogf program might yield atoms of
the form p.f .c1/; g.f .c2/// with c1 and c2 being constants.Â³ Intuitively, adornment deï¬nitions
are used to keep track of what kind of complex terms can be propagated.
Roughly speaking, the transformation technique works as follows. It maintains a set of
adorned predicate symbols, a set of adornment deï¬nitions, and a set of adorned rules. Whenever
we ï¬nd a rule whose body can be adorned in a â€œcoherentâ€ way (we will make clear what this
means in Deï¬nition 5.33), we derive an adorned predicate symbol from the rule head (using the
body adornments), and generate an adorned rule. In this step, new adornment deï¬nitions might
Â³Here predicate symbol p is assumed of arity 2, and function symbols f and g are assumed of arity 1.

78
5. FUNCTION SYMBOLS
be generated as well. New adorned predicate symbols are used to generate further adorned rules.
Below is an example that illustrates the basic idea.
Example5.31
Consider the following Datalogf program, where base is a base predicate symbol:
r0 W
p.X; f .X//
 
base.X/:
r1 W
p.X; f .X//
 
p.Y; X/; base.Y /:
r2 W
p.X; Y /
 
p.f .X/; f .Y //:
First, base predicate symbols are adorned with strings of â€™s; thus, we get the adorned predicate
symbol base. î€€is is used to adorn the body of r0 so as to get
0 W pf1.X; f .X//  base.X/
from which we derive the new adorned predicate symbol pf1, and the adornment deï¬nition
f1 D f ./. Next, pf1 and base are used to adorn the body of r1 so as to get
1 W pf1f2.X; f .X//  pf1.Y; X/; base.Y /
from which we derive the new adorned predicate symbol pf1f2, and the adornment deï¬nition
f2 D f .f1/. Intuitively, the body of 1 is coherently adorned because Y is always associated with
the same adornment symbol . Using the new adorned predicate symbol pf1f2, we can adorn rule
r2 and get
2 W pf1.X; Y /  pf1f2.f .X/; f .Y //:
At this point, we are not able to generate new adorned rules (using the adorned predicate symbols
generated so far) with coherently adorned bodies and the transformation terminates. For instance,
we may attempt to adorn the body of r1 as pf1f2.Y; X/; base.Y /, but this is not coherently
adorned because the same variable Y is associated with both f1 and . As a further example,
we may attempt to adorn the body of r2 as pf1.f .X/; f .Y //, but again this is not coherently
adorned because f .X/ does not comply with the term structure described by , which indicates
that the ï¬rst term of the atom should be a simple term.
î€€e order according to which rules are adorned is irrelevant.
In the previous example, to determine termination of the bottom-up evaluation of the
original program, we can apply current termination criteria to the transformed program P  D
f0; 1; 2g rather than the original one. In fact, the adornment technique ensures that if P 
is recognized as terminating, so is the original program. Notice that both the original program
and the transformed one are recursive, but while some termination criteria (e.g., the argument-
restricted,   -acyclicity, and bounded criteria) detect P  as terminating, none of the current ter-
mination criteria is able to realize that the original programâ€™s evaluation terminates.
For instance, consider argument-restriction (cf. Section 5.2.3). î€€e original program of
Example 5.31 above is not argument-restricted, as there is no argument ranking for it. In fact,

5.3. PROGRAM ADORNMENT
79
every argument ranking must satisfy .pÅ’2Â/   .pÅ’2Â/  1 (because of rule r1), but this con-
dition is clearly unsatisï¬able. On the other hand, the transformed program P  D f0; 1; 2g
is argument-restricted, as an argument ranking for it can be found. For instance, the function
 deï¬ned as follows is an argument ranking: .baseÅ’1Â/ D 0, .pf1Å’1Â/ D 0, .pf1Å’2Â/ D 1,
.pf1f2Å’1Â/ D 1, .pf1f2Å’2Â/ D 2.
Furthermore, the transformation technique allows current termination criteria to detect
strictly more programs as terminating under bottom-up evaluation. As an example, the original
program in the example above is not argument-restricted, so we could not say anything about
the termination of its bottom-up evaluation on the basis of such a criterion. However, P  is
argument-restricted and this allows us to conclude that the bottom-up evaluation of the original
program terminates for any database added to it.
In the following, we formally present the transformation technique. First, we deï¬ne how to
determine the adornment symbols associated with the variables in an adorned conjunction, and
how to check if the conjunction is coherently adorned. î€€en, we deï¬ne how to determine the
adornment of a rule head when its body is coherently adorned. Finally, we present the complete
technique.
Checking adornment coherency.
î€€e aim of adornment coherency is to check if the adorned
conjunction in the body of an adorned rule satisï¬es two conditions that are necessary for the
rule to â€œtrigger.â€ First, for each adorned atom pË›1:::Ë›n.t1; : : : ; tn/ in the conjunction, we check
if ti complies with the term structure corresponding to Ë›i. As an example, in the adorned atom
pf1.g.X// with adornment deï¬nition f1 D f ./, g.X/ does not comply with the term structure
f .c/ corresponding to f1, where c is an arbitrary constant. Second, we determine the adornment
symbol associated with each variable occurrence in the conjunction and check if, for every variable,
all its occurrences are associated with adornment symbols describing compatible term structures.
As an example, if pf1g1.X; X/ is an atom in the conjunction with adornment deï¬nitions f1 D
f ./ and g1 D g./, then two diï¬€erent term structures are associated with two occurrences of the
same variable X and the conjunction is not coherently adorned.
Function TermAdn below determines the adornment symbols associated with the variables
in a term ti in an adorned atom pË›1:::Ë›n.t1; : : : ; tn/ on the basis of Ë›i and a set of adornment deï¬ni-
tions S. Function BodyAdn simply collects the adornment symbols for all variables in an adorned
conjunction (using TermAdn), and is used to check if the conjunction is coherently adorned.
Deï¬nition 5.32
Let body be an adorned conjunction and S a set of adornment deï¬nitions.
We deï¬ne
BodyAdn.body; S/ D
[
pË›1:::Ë›n.t1;:::;tn/ 2 body^
1 i n
TermAdn.ti;Ë›i;S/I
where TermAdn is recursively deï¬ned as follows:
1. TermAdn.ti; ; S/ D ;, if ti is a constant;

80
5. FUNCTION SYMBOLS
2. TermAdn.ti; Ë›i; S/ D fti=Ë›ig, if ti is a variable;
3. TermAdn.f .u1; : : : ; um/; fi; S/D
mS
j D1
TermAdn.uj ; Ë›j ; S/, if fi Df .Ë›1; : : : ; Ë›m/ is in S;
and
4. TermAdn.ti; Ë›i; S/ D ffailg, otherwise.
Notice that there is a non-deterministic choice to be made in item 3 above, when
there are multiple adornment deï¬nitions for the same fi in S. Depending on the choice,
BodyAdn.body; S/ can return diï¬€erent sets; we deï¬ne SBodyAdn.body; S/ as the set of all pos-
sible outcomes. Notice that if body is the empty conjunction, then SBodyAdn.body; S/ contains
only the empty set.
Deï¬nition 5.33
Consider an adorned conjunction body and a set of adornment deï¬nitions S,
and let W 2 SBodyAdn.body; S/. We say that body is coherently adorned w.r.t. W iï¬€fail 62 W
and for every two distinct X=Ë› and X=Ë‡ in W it is the case that Ë› D fi and Ë‡ D fj, where f is
a function symbol and i; j 2 N.
Notice
that
the
empty
conjunction
is
coherently
adorned.
Given
a
set
W 2
SBodyAdn.body; S/, we deï¬ne S.W / as the set of all subsets T of W containing exactly one
expression of the form X=Ë› for every variable X in body. î€€e following example illustrates the
previous deï¬nitions.
Example 5.34
Consider
the
set
of
adornment
deï¬nitions
S D ff2 D f .f1/; f1 D
f ./; g1 D g./g.
For
the
adorned
conjunction
pf2g1.f .f .X//; g.X//,
we
have
that
BodyAdn.pf2g1.f .f .X//; g.X//; S/ can return only the set W obtained as follows:
W
D
TermAdn.f .f .X//; f2; S/ [ TermAdn.g.X/; g1; S/
D
TermAdn.f .X/; f1; S/ [ TermAdn.X; ; S/
D
TermAdn.X; ; S/ [ fX=g
D
fX=g [ fX=g D fX=g;
and pf2g1.f .f .X//; g.X// is coherently adorned w.r.t. W .
Considering qf2.f .g.X///, we have that BodyAdn.qf2.f .g.X///; S/ can return only
W D TermAdn.f .g.X//; f2; S/ D TermAdn.g.X/; f1; S/ D ffailg, and qf2.f .g.X/// is not co-
herently adorned w.r.t. W .
Considering pf2g1.f .X/; g.X//, we have that BodyAdn.pf2g1.f .X/; g.X//; S/ can re-
turn only the set W obtained as follows:
W
D
TermAdn.f .X/; f2; S/ [ TermAdn.g.X/; g1; S/
D
TermAdn.X; f1; S/ [ TermAdn.X; ; S/
D
fX=f1g [ fX=g D fX=f1; X=g;
and pf2g1.f .X/; g.X// is not coherently adorned w.r.t. W .

5.3. PROGRAM ADORNMENT
81
Head adornment.
When the conjunction in the body of a rule can be coherently adorned,
adornments are propagated from the body to the head. î€€e adornment of the head predicate
symbol is determined on the basis of (i) the structure of the terms in the head, and (ii) the
adornment symbols associated with the variables in the body. As an example, consider the rule
p.X; f .X; g.X///  b.X/ and the adorned body conjunction b.X/. î€€e adornment symbol
associated with variable X is , which intuitively means that the bottom-up evaluation of the
considered Datalogf program might yield atoms of the form b.c/, with c being a constant. As
a consequence, the rule above might yield atoms of the form p.c; f .c; g.c///. To keep track of
this, the head predicate symbol is adorned as pf1, and the adornment deï¬nitions f1 D f .; g1/
and g1 D g./ are derived.
We start by introducing a special (asymmetric) â€œunion operator,â€ denoted by t, which takes
as input a set of adornment deï¬nitions S and a set containing a single adornment deï¬nition
fh D f .Ë›1; : : : ; Ë›m/, and gives as output a set S0 of adornment deï¬nitions with S  S0. Operator
t is deï¬ned as follows:
â€¢ S t ffh Df .Ë›1; : : : ; Ë›m/gDS, if there exists fk Df .Ë›1; : : : ; Ë›m/ in S; and
â€¢ S t ffh Df .Ë›1; : : : ; Ë›m/gDS [ ffh Df .Ë›1; : : : ; Ë›m/g, if there is no fk Df .Ë›1; : : : ; Ë›m/
in S.
We are now ready to deï¬ne how rule heads are adorned.
Deï¬nition 5.35
Consider a Datalogf rule p.t1; : : : ; tn/  body, a set of adornment deï¬nitions
S0, and an adorned conjunction body obtained by adding adornments to all atoms in body. Let W
be an element of SBodyAdn.body; S0/ s.t. body is coherently adorned w.r.t. W , and T 2 S.W /.
î€€e adornment of the head atom p.t1; : : : ; tn/ w.r.t. T and S0 is
SetHeadAdn.p.t1; : : : ; tn/; T; S0/ D hpË›1:::Ë›n.t1; : : : ; tn/; Sni;
where
hË›1; S1i D Adn.t1; T; S0/
hË›2; S2i D Adn.t2; T; S1/
:::
hË›n; Sni D Adn.tn; T; Sn 1/
and function Adn is deï¬ned as follows:
â€¢ Adn.t; T; S/ D h; Si, if t is a constant;
â€¢ Adn.t; T; S/ D hË›i; Si, if t is a variable X and X=Ë›i is in T ;â´
â€¢ Adn.f .u1; : : : ; um/; T; S/ D hfj ; S0i, where
â´Notice that X always appears in body because of the safety condition (cf. Section 3.1).

82
5. FUNCTION SYMBOLS
â€“ hË‡1; S1i D Adn.u1; T; S/;
â€“ hË‡2; S2i D Adn.u2; T; S1/;
:::
â€“ hË‡m; Smi D Adn.um; T; Sm 1/;
â€“ S0 D Sm t ffi Df .Ë‡1; : : : ; Ë‡m/g, with i D maxfk j fk Df .1; : : : ; m/ 2 Smg C 1;
â€“ j is s.t. fj D f .Ë‡1; : : : ; Ë‡m/ is in S0.
Example 5.36
Consider the Datalogf rule
p.f .a; nil/; f .X; f .Y; nil///  base.X; Y /
and the adorned body base.X; Y /. î€€en, SBodyAdn.base.X; Y /; ;/ has one element, W D
fX=; Y=g, and T D fX=; Y=g is the only element in S.W /. î€€en,
SetHeadAdn.p.f .a; nil/; f .X; f .Y; nil///; T; ;/
gives hpf1f2.f .a; nil/; f .X; f .Y; nil///; S2i, where S2 D ff1 D f .; /; f2 D f .; f1/g. In fact,
by Deï¬nition 5.35,
â€¢ Adn.f .a; nil/; T; ;/ gives hf1; S1i; where S1 D ff1 D f .; /g; since
â€“ Adn.a; T; ;/ gives h; ;i; and
â€“ Adn.nil; T; ;/ gives h; ;i:
â€¢ î€€en, Adn.f .X; f .Y; nil//; T; S1/ gives hf2; S2i as
â€“ Adn.X; T; S1/ gives h; S1i; and
â€“ Adn.f .Y; nil/; T; S1/ gives hf1; S1i as
* Adn.Y; T; S1/ gives h; S1i; and
* Adn.nil; T; S1/ gives h; S1i:
Transformation function.
Before presenting the complete transformation technique, we intro-
duce some further notations and terminology. An adornment substitution  is a set of pairs the
form fi=fj (i.e., the same function symbol is used, but with diï¬€erent subscripts) with i > j that
does not contain two pairs of the form fi=fj and fj =fk. î€€us, a symbol fi cannot be replaced
by a symbol gh, and a symbol fj used to replace a symbol fi cannot be substituted in  by a
symbol fkâ€”where fi; fj ; fk; gh are in    fg. For instance, ff2=f1; g3=g1g is an adornment
substitution, but ff1=g1g and ff3=f2; f2=f1g are not. î€€e result of applying  to an adorned rule
r, denoted r, is the adorned rule obtained from r by substituting each fi appearing in r with

5.3. PROGRAM ADORNMENT
83
Algorithm 3 Adorn
Input: Datalogf program P .
Output: Adorned Datalogf program P .
1: S D ;; P  D ;;
2: AP D fpË›1:::Ë›n j p is a base predicate symbol appearing in P of arity n and every Ë›i D g;
3: repeat
4:
AP0 D AP;
5:
for each rule p.t/ body in P do
6:
for each body in A.body; AP/ do
7:
for each W in SBodyAdn.body; S/ do
8:
if body is coherently adorned w.r.t. W then
9:
for each T in S.W / do
10:
hpË›.t/;S0i D SetHeadAdn.p.t/; T; S/;
11:
AP D AP [ fpË›g; S D S0;
12:
ar D pË›.t/ body;
13:
P  D P  [ farg;
14:
if 9r 2P  ^ 9substitution  Â¤ ; s:t: ar Dr then
15:
P  D P ; AP D AP; S D S;
16: until AP0 D AP
17: return P ;
fj, where fi=fj belongs to . î€€e result of applying  to a set of adorned rules P  (resp. adorned
predicate symbols AP, adornment deï¬nitions S), denoted P  (resp. AP, S), is analogously
deï¬ned.
î€€e set of the adorned versions of an atom p.t/ w.r.t. a set of adorned predicate symbols
AP is A.p.t/; AP/ D fpË›.t/ j pË› 2 APg. î€€e set of the adorned versions of a conjunction of atoms
body D A1; : : : ; Ak w.r.t. AP is A.body; AP/ D fAA1; : : : ; AAk j AAi 2 A.Ai; AP/ for 1  i  kg.
If body is the empty conjunction, then A.body; AP/ contains only the empty conjunction.
Function Adorn (Algorithm 3) performs the transformation of a Datalogf program. It
maintains a set of adornment deï¬nitions S, a set of adorned rules P  (eventually, this will be the
output), and a set AP of adorned predicate symbols. Initially, S and P  are empty (line 1), and
AP contains all base predicate symbols in P adorned with strings of â€™s (line 2). î€€en, for each
coherently adorned body body of a rule p.t/ body in the original program, we determine the
adorned head pË›.t/ and the set of adornment deï¬nitions S0 using function SetHeadAdn (line 10).
î€€e set AP is extended with pË›, S0 is assigned to S (line 11), and a new adorned rule ar of the
form pË›.t/ body is added to P  (line 13). If there exists an adornment substitution  that
applied to ar gives a rule r in P , then  is applied to P , AP, and S (line 15). î€€is ensures
termination of Adorn.

84
5. FUNCTION SYMBOLS
î€€e following example shows the role of adornment substitutions.
Example 5.37
Consider the Datalogf program below where base is a base predicate symbol:
p.X/
 
base.X/:
p.f .X//
 
p.X/:
Starting from S D ;, P  D ;, and AP D fbaseg, the transformation algorithm adds the follow-
ing adorned rules to P 
0 W
p.X/
 
base.X/:
1 W
pf1.f .X//
 
p.X/:
2 W
pf2.f .X//
 
pf1.X/:
3 W
pf3.f .X//
 
pf2.X/:
Furthermore, the adornment deï¬nitions f1 D f ./, f2 D f .f1/, f3 D f .f2/ are added to S, and
the adorned predicate symbols p, pf1, pf2, pf3 are added to AP. At this point, the following
adorned rule is derived and added to P :
4 W
pf4.f .X//
 
pf3.X/:
î€€e adornment deï¬nition f4 D f .f3/ is added to S and pf4 is added to AP. However, since there
is an adornment substitution  D ff4=f2; f3=f1g such that 4 D 2, then  is applied to P ,
AP, and S. î€€us, P  becomes f0; 1; 2; 3g, where 3 is
pf1.f .X//
 
pf2.X/:
AP D fp; pf1; pf2g and S D ff1 D f ./; f2 D f .f1/; f1 D f .f2/g. At this point, no new
adorned rule can be generated and the algorithm terminates.
In the previous example, notice that both the original and the transformed programs are not
recognized as terminating by current termination criteria. Indeed, for any database containing at
least one fact base.c/, the least model is not ï¬nite and the bottom-up evaluation of both programs
never terminates. Nevertheless, function Adorn terminates.
We conclude this section by mentioning diï¬€erent important properties of the transforma-
tion technique (more details can be found in Greco et al. [2013b]).
First of all, function Adorn always terminates.
An important property of the transformation technique is that the original Datalogf pro-
gram it takes as input and the transformed Datalogf program it gives as output are â€œequivalentâ€
in the following sense: the least model of the original program can be obtained from the least
model of transformed program by dropping adornments.
Another crucial property of the transformation technique is its soundness: if the trans-
formed program Adorn.P / satisï¬es one of the termination criteria presented in the previous sec-
tion, then the bottom-up evaluation of the original Datalogf program P terminatesâ€”indeed, we

5.4. DEALING WITH DISJUNCTION AND NEGATION
85
can state that the evaluation of P [ D terminates for any ï¬nite database D (recall that we assume
that databases do not contain complex terms). î€€us, the least model of P [ D is ï¬nite, and can
be computed.
Finally, applying termination criteria to adorned programs as discussed in this section allows
us to detect strictly more programs as terminating.
5.4
DEALING WITH DISJUNCTION AND NEGATION
î€€e termination criteria presented in this chapter have been originally proposed for Datalog pro-
grams allowing function symbols, negation in the body, and disjunction in the head of rules. In
this chapter, we have restricted attention to Datalogf programs (where there is no negation in
rule bodies and no disjunction in rule heads).
Nevertheless, a program P with disjunction in the head and negation in the body (e.g., see
Example 5.38) can be analyzed by checking termination of a Datalogf program st.P / derived
from P as follows: every rule A1 _    _ Am  body in P is replaced with m Datalogf rules of
the form Ai  bodyC (1  i  m) where bodyC is obtained from body by deleting all negative
literals.
It is easy to see that if M is the least model of st.P /, then SM  M for every stable
model SM of P (because deleting literals from rule bodies and introducing multiple rules for
head disjunctions allows us to infer more ground atoms). Hence, if st.P / satisï¬es a termina-
tion criterion, then P has a ï¬nite number of stable models, and each of them has ï¬nite size
and can be computedâ€”e.g., by computing the stable models of the (ï¬nite) ground program
P 0  ground.P / consisting only of those rules whose terms all appear in M.
Indeed, the analysis performed by current termination criteria over a program P (possibly
with negation and disjunction) is equivalent to the analysis of st.P /, because the analysis ignores
negation and looks at a rule A1 _    _ Am  body in the same way as m rules of the form Ai  
body, 1  i  m.
Example 5.38
Consider the following program P where disjunction and negation occur:
p.X/ _ q.f .X//
 
s.X/; :base.X/:
s.X/
 
q.g.X//; :p.X/:
î€€en, st.P / is as follows:
p.X/
 
s.X/:
q.f .X//
 
s.X/:
s.X/
 
q.g.X//:
If st.P / satisï¬es a certain termination criterion, then P has a ï¬nite set of stable models and each
of them has ï¬nite size and can be computed.

86
5. FUNCTION SYMBOLS
BIBLIOGRAPHIC NOTES
A signiï¬cant body of work has been done on termination of logic programs under top-down
evaluation [Baselice et al., 2009, Bonatti, 2004, Bruynooghe et al., 2007, Codish et al., 2005,
De Schreye and Decorte, 1994, Marchiori, 1996, Nguyen et al., 2007, Nishida and Vidal, 2010,
Ohlebusch, 2001, Schneider-Kamp et al., 2009a,b, 2010, Serebrenik and De Schreye, 2005, Voets
and De Schreye, 2011].
î€€e problem of checking termination of the bottom-up evaluation of Datalogf programs
is also akin to work done in the area of term rewriting [Arts and Giesl, 2000, Endrullis et al.,
2008, Ferreira and Zantema, 1996, Sternagel and Middeldorp, 2008, Zantema, 1994, 1995].
In this chapter, we have considered the problem of checking if the bottom-up evaluation
of a Datalogf program terminates, and thus, as noticed and discussed in Alviano et al. [2010],
Calimeri et al. [2008, 2010], all the works above cannot straightforwardly be applied to the setting
considered in this chapter.
As for the context considered in this chapter, recent years have witnessed an increasing
interest in the problem of identifying Datalog programs with function symbols for which a ï¬nite
set of ï¬nite stable models exists and can be computed.
î€€e class of ï¬nitely-ground programs, guaranteeing the aforementioned desirable property,
has been proposed in Calimeri et al. [2008]. Since membership in the class is not decidable,
recent research has concentrated on the identiï¬cation of decidable suï¬ƒcient conditions for a pro-
gram to be ï¬nitely-ground. Eï¬€orts in this direction are !-restricted programs [SyrjÃ¤nen, 2001],
-restricted programs [Gebser et al., 2007], and ï¬nite domain programs [Calimeri et al., 2008].
More general classes are argument-restricted programs [Lierler and Lifschitz, 2009], safe and   -
acyclic programs [Calautti et al., 2015a, Greco et al., 2012b], mapping-restricted programs [Calautti
et al., 2013], bounded programs [Greco et al., 2013a], rule- and cycle-bounded programs [Calautti
et al., 2014, 2015c, 2016], and size-restricted programs [Calautti et al., 2015b]. We point out
that the aforementioned techniques have been proposed for Datalog programs allowing function
symbols, negation in the body, and disjunction in the head of rules. In this chapter, we restricted
attention to Datalogf programs (where there is no negation in rule bodies and no disjunction in
rule heads). However, the analysis performed by current techniques over a program P , possibly
with negation and disjunction, is indeed equivalent to the analysis of the Datalogf program st.P /
(cf. Section 5.4).
Termination properties of query evaluation for programs under tabling were studied
in Riguzzi and Swift [2014], Verbaeten et al. [2001].
î€€e topic of this chapter is also related to research done in the database community on
termination of the chase procedure, where existential rules are considered [Deutsch et al., 2008,
Fagin et al., 2005, Grau et al., 2013, Greco and Spezzano, 2010, Greco et al., 2011, KrÃ¶tzsch
and Rudolph, 2011, Marnette, 2009b, Meier et al., 2009]. A survey on this topic can be found
in Greco et al. [2012a].

5.4. DEALING WITH DISJUNCTION AND NEGATION
87
Indeed, suï¬ƒcient conditions ensuring termination of the bottom-up evaluation of logic
programs can be directly applied to existential rules. Speciï¬cally, one can analyze the logic pro-
gram obtained from the skolemization of existential rules, where existentially quantiï¬ed variables
are replaced with complex terms [Marnette, 2009a]. In fact, the evaluation of such a program
behaves as the â€œsemi-obliviousâ€ chase [Marnette, 2009a], whose termination guarantees the ter-
mination of the standard chase [Meier, 2010, Onet, 2013]. î€€us, if the program obtained from
the skolemization of a set of existential rules satisï¬es a termination criterion, then its bottom-up
evaluation terminates, which means that the semi-oblivious chase for the original set of existential
rules terminates, which in turn implies that the standard chase for the original set of existential
rules terminates.
On the other hand, termination criteria developed for the chase cannot directly applied to
Datalog programs with function symbols. î€€e rules obtained via skolemization of existential rules
are of a very restricted form: function symbols appear only in rule heads, each function symbol
occurs at most once, there is no nesting of function symbols. In contrast, we have considered a
much more general setting allowing an arbitrary use of function symbols: they can appear in both
the head and the body of rules, may be nested, and the same function symbol can appear multiple
times.


89
C H A P T E R
6
Aggregates
In this chapter, we extend Datalog to include aggregation constructs, such as count, sum, and
summation, and show how they help express optimization problems.
Aggregates are an important feature of query languages and allow us to summarize a large
amount of data into a single valueâ€”for instance, they can be used to count the number of products
supplied by a certain supplier, or compute the total amount of a certain purchase.
We ï¬rst discuss two classical aggregates, namely count and sum. î€€en, we present the
summation aggregate proposed by Greco [1999a]. Finally, we consider the combination of the
summation aggregate and the choice-least and choice-most constructs (cf. Section 4.6), and illus-
trate how they can be used to easily express classical optimization problems.
For all the aforementioned aggregate constructs, we provide a declarative semantics based
on rewriting programs with aggregates into programs with choice and choice-least/most con-
structs.
6.1
SYNTAX
In this section, we discuss some common syntactical aspects of the languages considered in this
chapter. In the following sections, we will individually consider diï¬€erent languages, each obtained
by extending Datalog with a speciï¬c aggregate.
An aggregate is a function that takes a multiset of values as input and returns a single value
as output. Indeed, besides allowing aggregates, in this chapter the syntax of Datalog is extended
to allow arithmetic and comparison operators too.
We will make use of arithmetic on a ï¬nite subset N of the cardinal numbers. More specif-
ically, given a program P , we assume the existence of a ï¬nite subset N D f0; : : : ; nP g of cardinal
numbers, where nP is the maximum number a programmer wants to manipulate in program P .
In contrast to other constants, which are uninterpreted, constants in N are interpreted, as
well as the arithmetic operators deï¬ned on N. î€€e operators we consider are the usual arithmetic
operators of sum, diï¬€erence, product, and so on, which are interpreted in the standard way. Ob-
serve that the assumption of a ï¬nite subset of the cardinal numbers guarantees that the Herbrand
universe is ï¬nite and the the bottom-up evaluation of a program always terminates.
In the following, we assume that for each predicate symbol at most one argument, called
cost argument, can take values from the ordered domain N whereas all the remaining arguments
take values from the Herbrand universe. Variables appearing in cost arguments will be called cost

90
6. AGGREGATES
variables. For the sake of simplicity, we also assume that the cost argument in a predicate, if any,
is always the last one.
Comparison atoms of the form t1 op t2 are allowed in the body of rules, where op is a com-
parison predicate symbol (i.e., op 2 f; >; ; <; D; Â¤g) and t1 and t2 are terms. Besides constants
and variables, t1 and t2 can be complex arithmetic expressions involving arithmetic operators, con-
stants from N, and variables. Such terms are interpreted in the standard way and then compared
according to op. For instance, given the comparison atom X D 2  Y , its true ground instances
are those where X is replaced with a value which is twice the value Y is replaced with.
Aggregates are expressed by means of aggregate atoms of the form sum..X/; V; S/,
count..X/; C/, summation..X/; V; S/, where X is a list of variables, and V , S, and C are variables.
î€€e intuitive meaning as well as a formal semantics of such aggregate atoms will be discussed in
the following sections. Aggregate atoms can appear only in the body of rules.
î€€us, the body of a rule can contain standard atoms (i.e., atoms whose predicate symbol is
neither a comparison predicate symbol nor an aggregate one), comparison atoms, and aggregate
atoms.
Every rule must be safe. To accommodate the three diï¬€erent types of atoms that can occur
in a rule, the safety condition is deï¬ned as follows. For every rule, every variable must be limited
in the following sense:
â€¢ a variable X is limited if it appears in a standard atom in the body; and
â€¢ a variable X is limited if it appears in a comparison atom of the form X D t or t D X,
where t is a term whose variables are all limited (notice that t can be a complex arithmetic
expression)â€”in the case that t is a constant, the condition is trivially satisï¬ed.
In the rest of the chapter we ï¬rst present the sum and count aggregates. î€€en, we consider
the summation aggregate. After that, we discuss the combination of summation and choice-least
and choice-most. We point out that the classical min and max aggregates can indeed be expressed
by the choice-least and choice-most constructs, respectively.
Given a list of terms X, we will use var.X/ to denote the list of variables occurring in X.
6.2
SUM AND COUNT
î€€e aggregates sum and count were ï¬rst introduced in Mumick et al. [1990] and further investi-
gated in several subsequent papers.
In the following, we deï¬ne syntax and semantics of such aggregates. In particular, we
present the semantics given by Greco [1999a], which is deï¬ned in terms of choice-most pro-
grams.
Sum aggregate.
î€€e sum aggregate is expressed by means of atoms of the form sum..X/; V; S/,
where X is a list of variables, and V and S are variables. î€€e intuitive meaning is that, given a
multiset T of tuples of the form .x; v/, where x is a list of constants from the Herbrand universe

6.2. SUM AND COUNT
91
called the X-value of the tuple and v is a value from N called the V -value of the tuple, for each
maximal subset T 0 of T of tuples having the same X-value, all the V -values must be added,
yielding S. î€€us, the aggregate atom yields as many values for S as the number of distinct values
of X. An example is provided below.
Example 6.1
Consider the rule
p.X; S/  q.X; Y; V /; sum..X/; V; S/
along with the following facts:
q.a; c; 2/:
q.a; d; 4/:
q.b; c; 3/:
î€€e evaluation of the rule above yields p.a; 6/ by summing up the V -values of the ï¬rst two facts,
and p.b; 3/ by summing up the V -value of the last fact.
If we replace the rule above with the following one
p.Y; S/  q.X; Y; V /; sum..Y /; V; S/
then we get p.c; 5/ from the ï¬rst and last facts, and p.d; 4/ from the second fact.
We now formally deï¬ne the syntax of rules with the sum aggregate.
Deï¬nition 6.2
A Datalogsum rule is of the form:
p.Y ; S/  body.W ; V /; sum..X/; V; S/
where
â€¢ Y and W are lists of terms, X is a list of variables, and var.Y /  X  var.W /;
â€¢ V is a cost variable such that V 62 X and S is a distinct variable such that S 62 var.W /; and
â€¢ body.W ; V / is a conjunction of standard and comparison atoms whose terms are W and V .
A Datalogsum program is a ï¬nite set of Datalog and Datalogsum rules, where for every
Datalogsum rule, the predicate symbol in the head is not mutually recursive with any of the pred-
icate symbols in the body.
Following Greco [1999a], the semantics of a Datalogsum program is given in terms of a
choice-most program (cf. Section 4.6) derived from the original one by replacing every Datalogsum
rule with two groups of rules.
More speciï¬cally, consider a Datalogsum program P and a Datalogsum rule r 2 P of the
following form (i.e., as per Deï¬nition 6.2):
p.Y ; S/  body.W ; V /; sum..X/; V; S/:

92
6. AGGREGATES
î€€e ï¬rst group of rules is used to partition the set of body tuples with respect to the values
of the variables in X and deï¬ne a linear order for each partition. Formally, we deï¬ne ord.r/ as
the set consisting of the following rules:
orderedr.0; X; root/
 
body.W ; V /:
orderedr.J; X; V /
 
orderedr.J 0; X; Y /; body.W ; V /; J D J 0 C 1
choice..J; X/; .W //; choice..W /; .J; X//:
î€€e second group of rules is used to compute the sum of each partition by iterating over
the corresponding linear order. Formally, we deï¬ne sum.r/ as the set consisting of the following
rules:
p.Y ; S/
 
sum_bodyr.J; X; S/; choice-most..X/; J /:
sum_bodyr.0; X; 0/
 
orderedr.0; X; root/:
sum_bodyr.J; X; S/
 
sum_bodyr.J 0; X; S0/; orderedr.J; X; V /; S DS0 C V; J DJ 0 C 1:
î€€e semantics of a Datalogsum program P is given in terms of the greedy choice models
of the choice-most program P 0 derived from P by replacing every Datalogsum rule r in P with
ord.r/ [ sum.r/.Â¹ Notice that P 0 can have multiple greedy choice models, which diï¬€er only in the
atoms deï¬ning the linear orders (i.e., the orderedr-atoms) and, consequently, they also diï¬€er in
the sum_bodyr-atoms. î€€is is not surprising since the ï¬nal result of the sum of a set of elements
is independent of the order in which the elements are summed up, although the partial results
can be diï¬€erent.
î€€us, the semantics of P is given by taking all the p-atoms of any greedy choice model of
P 0 where p is a predicate symbol appearing in P . As discussed above, we can choose any greedy
choice model of P 0 without aï¬€ecting the result, and thus the semantics of P is deterministic.
Count aggregate.
î€€e count aggregate is expressed by means of atoms of the form
count..X/; C/, where X is a list of variables and C is a variable. î€€e intuitive meaning is that,
given a multiset T of tuples of the form .x/, where x is a list of constants from the Herbrand
universe called the X-value of the tuple, for each maximal subset T 0 of T of tuples having the
same X-value, we count the number of elements of T 0. î€€e aggregate atom yields as many values
for C as the number of distinct values of X in T . An example is provided below.
Example 6.3
Consider a directed graph stored by means of facts of the form edge.a; b/, mean-
ing that there is an edge in the graph from node a to node b. î€€e following rule computes the
outdegree of every node having outgoing edges (i.e., having outdegree greater than 0):
outdegree.X; C/  edge.X; Y /; count..X/; C/:
Â¹Indeed, P 0 is a choice-most program where arithmetic operators are allowed.

6.2. SUM AND COUNT
93
Consider now the directed graph corresponding to the following database:
edge.a; b/:
edge.a; c/:
edge.b; c/:
edge.c; a/:
edge.c; d/:
edge.c; b/:
î€€e evaluation of the rule above yields outdegree.a; 2/ by counting the number of facts having a
as the ï¬rst argument, and likewise it also yields outdegree.b; 1/ and outdegree.c; 3/.
î€€e following rule allows us to compute the indegree of every node having ingoing edges:
indegree.Y; C/  edge.X; Y /; count..Y /; C/:
By evaluating this rule over the database above we get indegree.a; 1/, indegree.b; 2/,
indegree.c; 2/, and indegree.d; 1/.
We now formally deï¬ne the syntax of programs with the count aggregate.
Deï¬nition 6.4
A Datalogcount rule is of the form:
p.Y ; C/  body.W /; count..X/; C/;
where
â€¢ Y and W are lists of terms, X is a list of variables, and var.Y /  X  var.W /;
â€¢ C is a variable such that C 62 var.W /; and
â€¢ body.W / is a conjunction of standard and comparison atoms whose terms are W .
A Datalogcount program is a ï¬nite set of Datalog and Datalogcount rules where for every Datalogcount
rule, the predicate symbol in the head is not mutually recursive with any of the predicate symbols
in the body.
î€€e semantics of a Datalogcount program P is given in terms of the semantics of a Datalogsum
program derived from P by replacing each Datalogcount rule r in P of the form
p.Y ; C/  body.W /; count..X/; C/
with the following rules:
p.Y ; C/
 
bodyr.W ; V /; sum..X/; V; C/:
bodyr.W ; 1/
 
body.W /:
î€€us, count can be reduced to the case of sum. Speciï¬cally, every tuple involved in the counting
is given an extra argument whose values is 1 (see the second rule above), then such values are
summed (see the ï¬rst rule above), thereby obtaining the eï¬€ect of counting.

94
6. AGGREGATES
6.3
SUMMATION
î€€e summation aggregate is a useful construct for expressing optimization problems (e.g., see
Examples 6.8 and 6.10 in the following). It is expressed by means of atoms of the form
summation..X/; V; S/, where X is a list of variables, and V and S are variables. î€€e intuitive
meaning is that, given a multiset T of tuples of the form .x; v/, where x is a list of constants from
the Herbrand universe called the X-value of the tuple and v is a value from N called the V -value
of the tuple, for each maximal subset T 0 of T such that there are no two tuples in T 0 with the
same X-value, all the V -values must be added, yielding S.
In other words, if T Å’XÂ denotes the set of X-values in T and, for each x in T Å’XÂ, .x/
non-deterministically selects exactly one value v for which .x; v/ is in T , then a value for S is
obtained as P
x2T Å’XÂ .x/. An example is provided below.
Example 6.5
Consider the following rule:
p.S/  q.X; W; V /; summation..X/; V; S/
and the database consisting of the following facts:
q.a; c; 1/:
q.a; c; 2/:
q.b; c; 2/:
q.b; d; 3/:
î€€e evaluation of the rule above yields the atoms p.3/ (using the ï¬rst and third facts in the
database), p.4/ (using the ï¬rst and the fourth facts or using the second and the third ones), and
p.5/ (using the second and the fourth facts). If we replace the rule above with the following one:
p.S/  q.X; W; V /; summation..W /; V; S/I
that is, variable W is used in place of variable X in the summation atom, then we get the atoms
p.4/ (using the ï¬rst and fourth facts in the database) and p.5/ (using the second and the fourth
facts or using the third and the fourth ones).
î€€e syntax of programs with the summation aggregate is deï¬ned as follows.
Deï¬nition 6.6
A Datalog
P
rule is of the form:
p.S1; : : : ; Sn/
 
body.W ; X; V1; : : : ; Vn/;
summation..X/; V1; S1/; : : : ; summation..X/; Vn; Sn/;
where
â€¢ W is a list of terms and X is a list of variables;

6.3. SUMMATION
95
â€¢ V1; : : : ; Vn; S1; : : : ; Sn are distinct variables none of which belongs to W or X; and
â€¢ body.W ; X; V1; : : : ; Vn/ is a conjunction of standard and comparison atoms whose terms
are W ; X; V1; : : : ; Vn.
A Datalog
P
program is a ï¬nite set of Datalog and Datalog
P
rules where for every Datalog
P
rule,
the predicate symbol in the head is not mutually recursive with any of the predicate symbols in
the body.
Observe that the body of a Datalog
P
rule may contain several summation atoms, but must
satisfy the following constraints:
â€¢ all summation atoms must have the same ï¬rst argument X;
â€¢ variables X; V1; : : : ; Vn must appear in the conjunction body.W ; X; V1; : : : ; Vn/;
â€¢ only variables Si may occur in the head and they cannot appear in body.W ; X; V1; : : : ; Vn/;
and
â€¢ variables V1; : : : ; Vn; S1; : : : ; Sn take values from the domain N.
î€€e semantics of a Datalog
P
program is given in terms of a choice-most program derived
from P as follows. We ï¬rst deï¬ne a linear order on the values of the variables X by using the
non-determinism of the choice construct. More speciï¬cally, consider a Datalog
P
program P and
a Datalog
P
rule r in P of the form (see Deï¬nition 6.6)
p.S1; : : : ; Sn/
 
body.W ; X; V1; : : : ; Vn/;
summation..X/; V1; S1/; : : : ; summation..X/; Vn; Sn/:
We deï¬ne ord.r/ as the set consisting of the following rules:
orderedr.0; root/:
orderedr.J; X/
 
orderedr.J 0; X0/; body.W ; X; V1; : : : ; Vn/;
choice..J /; .X//; choice..X/; .J //; J D J 0 C 1:
î€€e linear order on the values of the variables X is built by deï¬ning a bijection between the
set of possible values of X and the cardinal numbers: this is enforced by the atoms choice..J /; .X//
and choice..X/; .J // in the body of the rule above.
We now deï¬ne sum.r/ as the set consisting of the following rules:
p.S1; : : : ; Sn/
 
pr.J; S1; : : : ; Sn/; choice-most../; J /:
pr.0; 0; : : : ; 0/:
pr.J; S1; : : : ; Sn/
 
pr.J 0; S0
1; : : : ; S0
n/; J D J 0 C 1;
orderedr.J; X/; body.W ; X; V1; : : : ; Vn/;
S1 D S0
1 C V1; : : : ; Sn D S0
n C Vn;

96
6. AGGREGATES
where pr is a fresh predicate symbol.
î€€e semantics of a Datalog
P
program P is given in terms of the choice-most program
P 0 derived from P by replacing every Datalog
P
rule r in P with ord.r/ [ sum.r/. Similar to
Datalogsum programs, P 0 can have multiple greedy choice models, which have the same p-atoms
for every predicate symbol p appearing in P . î€€e semantics of P is given by the set of such atoms,
which is the same across all greedy choice models of P 0.
Example 6.7
Consider the following Datalog
P
rule r:
p.Y; V /  range.I; Xi/; item.I; Yi; Vi/; summation..I/; Yi; Y /; summation..I/; Vi; V /:
î€€en, ord.r/ [ sum.r/ consists of the following rules:
orderedr.0; root/:
orderedr.J; I/
 
orderedr.J 0; I 0/; range.I; Xi/; item.I; Yi; Vi/; ;
choice..J /; .I//; choice..I/; .J //; J D J 0 C 1:
p.Y; V /
 
p0.J; Y; V /; choice-most../; J /:
p0.0; 0; 0/:
p0.J; Y; V /
 
p0.J 0; Y 0; V 0/; J D J 0 C 1;
orderedr.J; I/; range.I; Xi/; item.I; Yi; Vi/
Y D Y 0 C Yi; V D V 0 C Vi:
6.4
COMBINING SUMMATION AND GREEDY CHOICE
In this section, we consider programs where the summation aggregate is used along with the
choice-least/choice-most constructs, and show that they are well suited to express optimization
problemsâ€”the former can be used to compute summations and the latter can be used to se-
lect optimal values. In particular, we will focus on the combination of summation and choice-most;
the case involving choice-least is analogous. An example is given below.
Example 6.8
Given 1000 dollars to invest in diï¬€erent enterprises, we want to determine how
we should allocate this amount of money in order to have maximum proï¬t. Speciï¬cally, assume
we have facts of the form invest.ei; xi; pi/ meaning that pi is the proï¬t from the investment of
xi dollars on enterprise ei, and we want to determine the exact distribution of the resources in
each of the enterprises so that the global proï¬t is maximized.
By combining summation and choice-most, the problem can be expressed as follows:
global_proï¬t.S/
 
proï¬t.D; S/; choice-most../; S/:
proï¬t.D; S/
 
invest.E; X; P /;
summation..E/; X; D/; D  1000;
summation..E/; P; S/; choice-most..D/; S/:

6.4. COMBINING SUMMATION AND GREEDY CHOICE
97
î€€e second rule above computes the maximum proï¬t S we can get by investing D dollars, for
diï¬€erent values of D (less than or equal to 1000). î€€en, the ï¬rst rule selects the maximum value
of S across all values derived from the second rule.
We now deï¬ne the syntax of programs including summation and choice-most.
Deï¬nition 6.9
A Datalog
P
;most rule is of the form:
p.S1; : : : ; Sn/
 
body.W ; X; V1; : : : ; Vn/;
summation.X; V1; S1/; : : : ; summation.X; Vn; Sn/;
choice-most..S1; : : : ; Sn 1/; Sn/;
where
â€¢ W is a list of terms and X is a list of variables;
â€¢ V1; : : : ; Vn; S1; : : : ; Sn are distinct variables none of which belongs to W or X; and
â€¢ body.W ; X; V1; : : : ; Vn/ is a conjunction of standard and comparison atoms whose terms
are W ; X; V1; : : : ; Vn.
A Datalog
P
;most program is a ï¬nite set of Datalog, choice-most, and Datalog
P
;most rules
where, for every choice-most or Datalog
P
;most rule, the predicate symbol in the head is not mutu-
ally recursive with any of the predicate symbols in the body.
î€€e semantics of a Datalog
P
;most program P is given in terms of a choice-most program P 0
obtained from P by replacing every Datalog
P
;most rule r in P by ord.r/ as deï¬ned in Section 6.3,
plus the following set of rules:
p.S1; : : : ; Sn/
 
pr.J; S1; : : : ; Sn/; choice-most../; J /:
pr.0; 0; : : : ; 0/:
pr.J; S1; : : : ; Sn/
 
pr.J 0; S0
1; : : : ; S0
n/; J D J 0 C 1;
orderedr.J; X/; body.W ; X; V1; : : : ; Vn/;
S1 D S0
1 C V1; : : : ; Sn D S0
n C Vn;
choice-most..J; S1; : : : ; Sn 1/; Sn/;
where pr is a fresh predicate symbol.
Recall that predicate orderedr is deï¬ned by rules in ord.r/ (see the previous section). Similar
to the semantics discussed in the previous sections, the semantics of P is given in terms of the
p-atoms of any greedy choice model of P 0, where p is a predicate symbol appearing in P â€”once
again, even if P 0 can have multiple greedy choice models, they all agree on the p-atoms (with p
being a predicate symbol that appears in P ) and thus the semantics is deterministic.
Details on the evaluation of Datalog
P
;most programs (as well as Datalog
P
;least programs) can
be found in Greco [1999a]. A general technique for the propagation of extrema predicates into
Datalog programs has been deï¬ned in Greco et al. [1998] (see also Ganguly et al. [1991]).

98
6. AGGREGATES
Below we report another example where the summation aggregate is used along with the
choice-most construct to express an optimization problem.
Example6.10
Suppose we are given a set of facts of the form item.i; bi; vi/ meaning that there is
an item i with weight bi and value vi. î€€e following Datalog
P
;most program returns the maximum
value of the expression P
i vi  x2
i under the constraint P
i bi  xi  15â€”here the xiâ€™s variables
can take non-negative integer values.
max_p.V /
 
p.B; V /; choice-most../; V /:
p.B; V /
 
range.Xi/; item.I; Bi; Vi/;
B0
i D Xi  Bi; summation..I/; B0
i; B/; B  15;
V 0
i D Xi  Xi  Vi; summation..I/; V 0
i ; V /; choice-most..B/; V /:
î€€us, the above program formulates a quadratic integer programming problem. Notice that
we also have a fact range.v/ for every integer value v that a variable Xi can take.
Dynamic programming is a technique for solving optimization problems which decom-
poses a problem into subproblems of smaller size, solves the smaller subproblems, and uses their
solutions to later solve larger subproblems up to the original problem. î€€e technique is based
on a bottom-up approach which is also the approach used by the evaluation strategy of Datalog.
For instance, the resource allocation problem above can be solved with a dynamic programming
approach. Greco [1999a] reports other examples showing that the summation aggregate in com-
bination with greedy choice allows us to express many optimization problems in a declarative
way.
BIBLIOGRAPHIC NOTES
î€€e classes of programs discussed in this chapter can be easily extended to accommodate stratiï¬ed
negation, see Greco [1999a].
Notice also that we considered classes of programs with only one aggregate. For instance,
Datalogsum programs cannot contain Datalogcount rules. However, the generalization to classes of
programs containing both Datalogsum and Datalogcount rules is easy since the semantics of such
programs can be deï¬ned by rewriting each Datalogsum rule and each Datalogcount rule as dis-
cussed in Section 6.2. î€€e same argument applies to other combinations of rules with aggregates
belonging to the same program.
î€€e extension of Datalog with aggregates has been widely investigated, with particular focus
on the deï¬nition of a suitable semantics and the design of techniques for the eï¬ƒcient evaluation
of such programs.
A semantics for Datalog programs with non-recursive and monotonic recursive aggregates
was ï¬rst proposed in Mumick et al. [1990].
î€€e extension of the well-founded semantics to logic programs with aggregates was con-
sidered in Kemp and Stuckey [1991]. A diï¬€erent deï¬nition (based on the alternating ï¬xpoint)

6.4. COMBINING SUMMATION AND GREEDY CHOICE
99
of the well-founded semantics in the presence of aggregates was proposed in Van Gelder [1992],
which was later generalized by Osorio and Jayaraman [1999]. î€€e main shortcoming of such se-
mantics is that they often leave too many undeï¬ned atoms, as shown by Ross and Sagiv [1997].
î€€e latter is an alternative approach based on the deï¬nition of monotonicity conditions using lat-
tices and which is more general than the one deï¬ned by set-containment. î€€is semantics does not
capture some important cases such as cost-monotonic programs. Yet another semantics based on
the deï¬nition of a stronger partial order relation was proposed in Gelder [1993]. An extension of
the well-founded semantics to programs with aggregates was proposed also in Pelov et al. [2007]
and Alviano et al. [2011].
Eï¬ƒcient bottom-up techniques for evaluating diï¬€erent classes of Datalog programs with
aggregates were proposed in Ganguly et al. [1991], Sudarshan and Ramakrishnan [1991], whereas
a top-down method which uses extension tables was presented in Dietrich [1992]. î€€e technique
presented in Sudarshan and Ramakrishnan [1991] was also implemented in the CORAL sys-
tem [Ramakrishnan et al., 1992].
î€€e eï¬ƒcient evaluation of Datalog programs extended with both negation and aggregation
was studied in Kemp and Ramamohanarao [1998].
Incremental techniques for eï¬ƒciently evaluating programs with monotonic aggregates were
proposed in Ramakrishnan et al. [1994].
Expressive power and complexity of diï¬€erent extensions of Datalog with aggregates were
investigated in Consens and Mendelzon [1990], Mumick and Shmueli [1995].
Semantics and complexity of Datalog extended with unstratiï¬ed negation, disjunction, and
aggregates were investigated in Faber et al. [2011]. A discussion of various other approaches can
be found in Pelov et al. [2007].


101
C H A P T E R
7
Query Optimization
In this chapter, we discuss techniques that take advantage of the information in Datalog queries
to make their evaluation more eï¬ƒcient.
î€€e ï¬rst technique is called magic-sets rewriting and consists of rewriting a Datalog query
into an equivalent one which combines the advantages of the bottom-up and top-down evaluation
strategies. î€€e Datalog query obtained from the rewriting is evaluated in a bottom-up fashion,
but it indeed emulates a top-down evaluation strategy of the original query.
î€€e second technique we present applies to a special class of Datalog queries, called chain
queries, and is based on the rewriting of the original Datalog query into a new one (containing
function symbols) that emulates a pushdown automaton. Several other techniques deï¬ned in the
literature (e.g., the counting method) are characterized as special cases of this technique.
7.1
MAGIC-SETS REWRITING
Magic-sets rewriting [Bancilhon et al., 1986, Beeri and Ramakrishnan, 1991] is a well-known
technique for the eï¬ƒcient evaluation of Datalog queries. î€€e approach consists of rewriting a
Datalog query into an equivalent one whose bottom-up evaluation simulates the pushing of bind-
ing information that occurs in top-down evaluation approaches. We illustrate this aspect in the
following example.
Example 7.1
Consider a database storing facts of the form person.a/ and parent.a; b/ meaning
that a is a person and b is a parent of a, respectively. Consider the Datalog query hP; same-
generation.john; Y /iÂ¹ asking for those people of the same generation as john, where P is the
following Datalog program:
samegeneration.X; X/  person.X/:
samegeneration.X; Y /  parent.X; X1/; samegeneration.X1; Y1/; parent.Y; Y1/:
î€€is query could be answered rather eï¬ƒciently using a top-down evaluation strategy. As
discussed in Chapter 3, a top-down evaluation tries to avoid the inference of atoms that are irrel-
evant for proving the atoms of interestâ€”in our example, we are interested only in the people of
the same generation as john.
Â¹Recall that a Datalog query is a pair hP; Gi where P is a Datalog program and G is an atom, called query goalâ€”see Section 3.4
for further details.

102
7. QUERY OPTIMIZATION
In contrast, bottom-up algorithms (such as those seen in Chapter 3) would compute the
entire samegeneration relation to eventually keep only those tuples belonging to the query answer.
If there are many tuples not involving john in the samegeneration relation, then the bottom-up
computation would spend time to compute them even though they are useless for the purpose of
answering the query.
î€€e previous example highlights some advantages of the top-down evaluation. However,
a bottom-up computation has also diï¬€erent advantages over top-down strategies. In fact, a top-
down evaluation strategy might get stuck in inï¬nite loops, and even if it is possible to avoid
them, detecting termination is not easy. Moreover, bottom-up evaluation strategies can make use
of eï¬ƒcient techniques for computing joins of big relations.
Magic-sets rewriting is a technique that combines the advantages of both the top-down
and the bottom-up evaluation strategies. It consists of three steps.
1. An adornment step which derives a new program, called adorned program, from the original
one. In the adorned program the relationships between bound arguments in the head of a
rule and the bindings in the rule body are made explicit by â€œadorningâ€ predicate symbolsâ€”
roughly speaking, by attaching strings (specifying if a term is expected to be free or bound)
to predicate symbols.
2. A modiï¬cation step which modiï¬es the adorned rules obtained at the ï¬rst step by introducing
new atoms, called magic atoms, into the rule bodies.
3. A generation step which adds new rules, called magic rules, to the adorned program obtained
at the second step. î€€e magic rules deï¬ne the atoms introduced in the second step and
simulate the top-down evaluation scheme.
î€€e ï¬rst step in the magic-sets rewriting is to produce an adorned query. Query adornment
is a formal way of depicting information ï¬‚ow between atoms in rules. î€€is is done by annotating
predicate symbols with strings. More precisely, an adornment Ë› for a predicate symbol p of arity
n is a string Ë›1 : : : Ë›n of length n built from the letters b (which stands for bound) and f (which
stands for free). So, pË› is an adorned predicate symbol and pË›.t1; : : : ; tn/ is an adorned atom, where
the tiâ€™s are terms. For instance, parentfb is an adorned predicate symbol and parentfb.X; john/ is
an adorned atom.
Intuitively, an adorned atom pË›.t1; : : : ; tn/ is used to express if each ti is expected to be
bound or free during the evaluation of a program. Depending on the information ï¬‚ow, if ti is
expected to be bound (resp. free), then Ë›i is set to b (resp. f ).
First of all, we deï¬ne how the query goal is adorned.
Deï¬nition 7.2
Given a query goal G of the form g.t1; : : : ; tm/, the adorned version of G is
the adorned atom gË›.t1; : : : ; tm/ where adornment Ë› D Ë›1 : : : Ë›m is deï¬ned as follows: if ti is a
constant, then Ë›i D b; otherwise (ti is a variable) Ë›i D f . î€€e adorned version of G is denoted
by adorn.G/.

7.1. MAGIC-SETS REWRITING
103
Now the program of the given query has to be adorned. Adornments are generated with
reference to a speciï¬c sideways information-passing strategy (SIPS). A sideways information pass-
ing strategy is an inherent component of any query evaluation strategy. Intuitively, for a rule of
a program, a SIPS represents a decision about the order in which the atoms of the rule will be
evaluated, and how values for variables are passed from atoms to other atoms during evaluation.
Speciï¬cally, a SIPS describes how bindings passed to a ruleâ€™s head by uniï¬cation are used to eval-
uate the atoms in the ruleâ€™s body. î€€us, a SIPS describes how we evaluate a rule when a given set
of head terms are bound to constants. Below is an example.
Example 7.3
Consider again the Datalog query hP; samegeneration.john; Y /i of Example 7.1.
î€€e ï¬rst argument of the query goal is bound to john and thus, in the ï¬rst rule of P , variable X
is bound to john as well and can be used in the body to check if john is a person.
In the second rule, a possible SIPS is the following one. Variable X is bound to john and
is used to retrieve johnâ€™s parents. î€€e value of X1, bound to a parent of john, is available for
the evaluation of samegeneration.X1; Y1/. î€€us, in the second rule, variable X is passed sideways
from samegeneration.X; Y / in the head to parent.X; X1/ in the body whereas variable X1 is passed
sideways from parent.X; X1/ to samegeneration.X1; Y1/.
If the query goal is samegeneration.X; john/, the following diï¬€erent strategy can be used.
In the second rule, the value of Y is bound to john and is passed sideways to the body atom
parent.Y; Y1/, so that the value of Y1 is used to retrieve johnâ€™s parents; the (bound) variable Y1
is then available for the evaluation of samegeneration.X1; Y1/. î€€erefore, the evaluation strategy
depends on SIPSs, that is, how bindings are passed though atoms.
SIPSs are associated with a rule according to the query goal formâ€”in particular, according
to the adorned version of the query goal. Diï¬€erent query goals usually have diï¬€erent SIPSs for
the same program (e.g., the two diï¬€erent query goals in the example above, whose adorned ver-
sions are samegenerationbf .X; Y / and samegenerationfb.X; Y /). However, diï¬€erent SIPSs can be
associated with the same query form too (e.g., see Example 7.5 in the following). î€€e choice of
one SIPS over another is guided by factors such as the current and expected size of the diï¬€erent
relations and the employed indexing mechanism.
In a given rule, two atoms A and A0 are connected if they share a common variable or there
exists an atom A00 connected to both A and A0. î€€e notion of SIPS is formally deï¬ned as follows.
Deï¬nition7.4
Let r be a Datalog rule, p.t1; : : : ; tn/ the atom in the head of r, and Ë› D Ë›1 : : : Ë›n
an adornment for p. A sideways information-passing strategy (SIPS) for r with respect to pË› is a
labeled graph satisfying the following conditions:
â€¢ each edge is of the form N !X s, where N  .body.r/ [ fpË›.t1; : : : ; tn/g/, s 2 body.r/,
and X is a non-empty set of variables. Moreover,
â€“ each variable in X appears in s; and

104
7. QUERY OPTIMIZATION
â€“ each variable in X appears either in a term ti s.t. Ë›i D b, provided that pË›.t1; : : : ; tn/
is in N, or in an atom in N   fpË›.t1; : : : ; tn/g (or both); and
â€“ each atom in N is connected to s.
â€¢ î€€ere exists a total order of body.r/ [ fpË›.t1; : : : ; tn/g s.t.
â€“ pË›.t1; : : : ; tn/ precedes all atoms in body.r/;
â€“ every atom which does not appear in the graph follows every atom appearing in the
graph; and
â€“ for each edge N !X s in the SIPS, every element in N precedes s.
Intuitively, an edge N !X s means that by evaluating the join of the atoms in N (with some
terms possibly bound to constants), values for the variables in X are obtained, and these values are
passed to atom s, and are used to restrict its computation. Clearly, we can have diï¬€erent SIPSs
for a given rule, as shown in the following example.
Example 7.5
Consider the Datalog query hP; q.1; Y /i, where P is the following program:
q.X; Y /  a.X; Y; Z/:
q.X; Y /  a.X; W; Z/; q.Z; T /; b.T; W /; q.T; Y /:
q.X; Y /  b.X; Z/; p.Z; Y /; c.Y /:
Here q and p are derived predicate symbols, while a, b, and c are base predicate symbols. î€€e
adorned version of the query goal is qbf.1; Y /.
A possible SIPS for the ï¬rst rule w.r.t. qbf is the one consisting of the following edge:
f qbf .X; Y /g !fXg a.X; Y; Z/:
A SIPS for the second rule w.r.t. qbf is the one consisting of the following edges:
f qbf.X; Y /g !fXg a.X; W; Z/
f qbf.X; Y /; a.X; W; Z/g !fZg q.Z; T /
f qbf.X; Y /; a.X; W; Z/; q.Z; T /g !fT;W g b.T; W /
f qbf.X; Y /; a.X; W; Z/; q.Z; T /; b.T; W /g !fT g q.T; Y /:
Notice that this is a SIPS for the second rule w.r.t. qbf as:
â€¢ all edges satisfy the conditions stated in the ï¬rst bullet of Deï¬nition 7.4. For instance,
consider the last edge above (an analogous reasoning can be applied to all other edges). î€€e
left-hand side of !fT g contains qbf.X; Y / and atoms in the body of the second rule, while
the right-hand side is an atom in the body of the second rule. Moreover,
â€“ T appears in q.T; Y /;

7.1. MAGIC-SETS REWRITING
105
â€“ T appears in fa.X; W; Z/; q.Z; T /; b.T; W /g; and
â€“ each atom in f qbf.X; Y /; a.X; W; Z/; q.Z; T /; b.T; W /g is connected to q.T; Y /.
Notice that b.T; W / is connected to q.T; Y / because they share the same variable T .
For the same reason, q.Z; T / is connected to q.T; Y /. î€€en, a.X; W; Z/ is connected
to q.T; Y / because it shares variable Z with q.Z; T /, which is connected to q.T; Y /.
Finally, qbf.X; Y / is connected to q.T; Y / as they share variable Y .
â€¢ î€€e total order qbf.X; Y /; a.X; W; Z/; q.Z; T /; b.T; W /; q.T; Y / satisï¬es the conditions
in second bullet of Deï¬nition 7.4.
Another possible SIPS for the second rule w.r.t. qbf might be the following:
f qbf .X; Y /g !fXg a.X; W; Z/
f a.X; W; Z/g !fZg q.Z; T /
f q.Z; T /g !fT g b.T; W /
f b.T; W /g !fT g q.T; Y /:
î€€ere is a subtle diï¬€erence between the two SIPSs for the second rule reported above. In the ï¬rst
one, the last three edges specify that each atom in the body of the rule receives some information
based on the evaluation of the conjunction of the body atoms to its left. However, in the second
SIPS, although q.Z; T / passes ground values for T to b.T; W / (see the third edge), the ground
values for W that are generated need not be the same set of ground values for W computed by
evaluating a.X; W; Z/ from the previous edge. It is only when all the tuples for the body atoms
are joined at the end that the compatible values of W from b and a are reconciled (uniï¬ed).
A possible SIPS for the third rule w.r.t. qbf is the one consisting of the following edges:
f qbf.X; Y /g !fXg b.X; Z/
f qbf.X; Y /; b.X; Z/g !fZg p.Z; Y /
f qbf.X; Y /; b.X; Z/; p.Z; Y /g !fY g c.Y /:
For ease of presentation, we omit explicit SIPSs and assume a default SIPS for every rule,
according to which if the tail of an edge contains a body atom A, then it also includes all atoms to
the left of A in the rule (including the head). We also assume that all SIPSs have been normalized
as follows. Given n SIPS edges of the form
N1 !X1 s
N2 !X2 s
:::
Nn !Xn s:
î€€e normalized edge for s is
N1 [ N2 [    [ Nn ![n
iD1Xi s:

106
7. QUERY OPTIMIZATION
Algorithm 4 Adornment
Input: A Datalog query hP; g.t1; : : : ; tm/i and a set S of SIPSs
Output: An (adorned) Datalog query hP ; gË›.t1; : : : ; tm/i and a set S0 of SIPSs
1: gË›.t1; : : : ; tm/ D adorn.g.t1; : : : ; tm//;
2: N D fgË›gI
3: P  D ;; D D ;; S0 D ;;
4: while N Â¤ ; do
5:
move an adorned predicate symbol qË‡ from N to D;
6:
for each rule r 2 def.q; P / do
7:
let r0 be a copy of r;
8:
let S.r/ be a copy of the SIPS associated with r w.r.t. qË‡;
9:
replace q with qË‡ in the head of r0;
10:
for each derived atom p.v1; : : : ; vk/ in the body of r0 do
11:
 D adornment.p.v1; : : : ; vk/; S.r//;
12:
replace p.v1; : : : ; vk/ in both r0 and S.r/ by p.v1; : : : ; vk/;
13:
if p 62 D then
14:
N D N [ fpg;
15:
P  D P  [ fr0g;
16:
S0 D S0 [ fS.r/g;
17: return hP ; gË›.t1; : : : ; tm/i and S0;
î€€e adornment of a Datalog query is performed by Algorithm 4. It takes as input a Datalog
query hP; g.t1; : : : ; tm/i and a set S of SIPSs for the rules of P , and gives as output an adorned
Datalog query hP ; gË›.t1; : : : ; tm/i and a set S0 of SIPSs for the rules of P .
Algorithm 4 maintains a set P  of adorned rules obtained by adorning rules of P , a set
N of adorned predicate symbols not yet deï¬ned in P , a set D of adorned predicate symbols
deï¬ned in P , and a set S0 of SIPSs for the rules in P . Initially, D is empty and N contains
the adorned predicate symbol corresponding to the query goal. î€€en, the algorithm iteratively
moves a predicate symbol qË‡ from N to D and adds to P  the rules deï¬ning q in P adorned
with respect to Ë‡. Moreover, SIPSs from S are added to S0 by replacing predicate symbols with
adorned predicate symbols.
Function adornment.p.v1; : : : ; vk/; S.r// on line 11 takes a (derived) atom p.v1; : : : ; vk/
from the body of a rule r and the SIPS S.r/ associated with r, and returns an adornment  D
1 : : : k according to the following rule: Let N !X p.v1; : : : ; vk/ be an edge in S.r/ (if such an
edge does not exist, then X is assumed to be empty). If vi 2 X or vi is a constant, then set i to
b, otherwise set i to f , for 1  i  k.

7.1. MAGIC-SETS REWRITING
107
Given a Datalog query Q D hP; Gi and a set S of SIPSs, the adorned version of Q w.r.t.
S, denoted Adorn.Q; S/, is the adorned Datalog query returned by Algorithm Adornment when
called with Q and S as input.
Example 7.6
î€€e adorned version of the Datalog query and the SIPSs of Example 7.5 (for the
second rule, the ï¬rst SIPS reported in Example 7.5 is considered) is hP 0; qbf .1; Y /i, where P 0
consists of the following rules:
qbf.X; Y /  a.X; Y; Z/:
qbf.X; Y /  a.X; W; Z/; qbf .Z; T /; b.T; W /; qbf.T; Y /:
qbf.X; Y /  b.X; Z/; pbf.Z; Y /; c.Y /:
Notice that base atoms are not adorned as the for each loop in lines 10â€“14 considers only derived
atoms. If we consider a diï¬€erent order for the body atoms of the third rule (and thus a diï¬€erent
SIPS), where base atoms precede the derived atom, the adorned version of the rule is
qbf .X; Y /  b.X; Z/; c.Y /; pbb.Z; Y /:
An important property of the adornment step discussed above is that the adorned version
of a Datalog query is equivalent to the original one [Balbin et al., 1991, Beeri and Ramakrish-
nan, 1991]. Recall that two Datalog queries are equivalent iï¬€they give the same result for every
database (cf. Section 3.4).
î€€us far, we have seen how the ï¬rst step of the magic-sets rewriting is performed, that is,
how to derive an adorned Datalog query Q0 from the original one. After Q0 has been generated,
the magic-sets rewriting proceeds by introducing new adorned atoms (called magic atoms) into
the bodies of the adorned rules of Q0 and introducing new rules (called magic rules) deï¬ning the
new adorned atoms.
î€€e new adorned atoms are related to the adorned atoms appearing in Q0 as follows: if A is
an adorned atom of the form qË›1:::Ë›n.t1; : : : ; tn/ appearing in Q0, then the new adorned atom is
obtained from A by replacing predicate symbol qË›1:::Ë›n with the predicate symbol magic_qË›1:::Ë›n
and deleting the variables ti s.t. Ë›i D f , for 1  i  n (thus, the arity of magic_qË›1:::Ë›n is less
than or equal to n). For instance, given the adorned atom pbfb.X; Y; Z/, the magic atom is
magic_pbfb.X; Z/, that is, the second term has been eliminated since the second symbol in the
adornment is f . Given an adorned atom A, magic.A/ denotes the magic atom derived from A.
Algorithm 5 performs the magic-sets rewriting. It takes as input the adorned Datalog query
and the set of SIPSs returned by Algorithm 4; it gives as output a new Datalog query. For Al-
gorithm 5, initially, P 0 is empty. î€€en, for each adorned rule in P , a modiï¬ed rule and a set of
magic rules (one for each edge in the associated SIPS) are added to P 0. In the algorithm, for a
SIPS edge N !X s, we use conj.N/ to denote the conjunction of the atoms in N.
Consider a Datalog query Q and a set S of SIPSs, and let Q0 and S0 be the adorned Datalog
query and the set of SIPSs returned by Adornment.Q; S/. We denote by magicRew.Q; S/ the

108
7. QUERY OPTIMIZATION
Algorithm 5 Magic-sets
Input: An adorned query hP ; gË›.t1; : : : ; tm/i and a set S of SIPSs
Output: An adorned query hP 0; gË›.t1; : : : ; tm/i
1: P 0 D ;;
2: for each rule r 2 P  do
3:
add the rule head.r/  magic.head.r//; body.r/ to P 0;
4:
for each edge N !X s in the SIPS associated with r do
5:
if head.r/ 2 N then
6:
add the rule magic.s/  magic.head.r//; conj.N   fhead.r/g/ to P 0;
7:
else
8:
add the rule magic.s/  conj.N/ to P 0;
9: P 0 D P 0 [ fmagic.gË›.t1; : : : ; tm//:g;
10: return hP 0; gË›.t1; : : : ; tm/i;
adorned Datalog query returned by Algorithm Magic-Set when called with Q0 e S0 as input. î€€us,
the overall magic-sets rewriting for a Datalog query Q is carried out by ï¬rst calling Algorithm
Adornment and then calling Algorithm Magic-sets on the output of Algorithm Adornment.
An important property of the magic-sets rewriting technique is that magicRew.Q; S/ is
equivalent to the original Datalog query Q [Balbin et al., 1991, Beeri and Ramakrishnan, 1991].
Example 7.7
Consider the Datalog query Q D hP; p.1; C/i where P consists of the following
rules:
p.X; C/
 
q.X; 2; C/:
q.X; Y; C/
 
a.X; Y; C/:
q.X; Y; C/
 
b.X; Y; Z; W /; q.Z; W; D/; c.D; C/:
In this program, q and p are derived predicate symbols, while a, b, and c are base predicate
symbols. Assume a default SIPS for every rule where if the tail of an edge contains a body atom
A, then it also includes all atoms to the left of A in the rule (including the head). Let S be the
set of such SIPSs. î€€e adorned version of Q is hP ; pbf .1; C/i where P  is as follows:
pbf.X; C/
 
qbbf .X; 2; C/:
qbbf.X; Y; C/
 
a.X; Y; C/:
qbbf.X; Y; C/
 
b.X; Y; Z; W /; qbbf.Z; W; D/; c.D; C/:
In the third rule, predicate symbol b passes the bindings from the (bound) head variables X and Y
to the variables Z and W appearing in the derived atom q.Z; W; D/. î€€en, Algorithm Magic-sets

7.2. CHAIN QUERIES
109
returns the query hP 0; pbf.1; C/i, where P 0 is as follows:
magic_pbf.1/:
magic_qbbf .X; 2/
 
magic_pbf.X/:
magic_qbbf.Z; W /
 
magic_qbbf.X; Y /; b.X; Y; Z; W /:
pbf .X; C/
 
magic_pbf.X/; qbbf.X; 2; C/:
qbbf .X; Y; C/
 
magic_qbbf.X; Y /; a.X; Y; C/:
qbbf .X; Y; C/
 
magic_qbbf.X; Y /; b.X; Y; Z; W /; qbbf .Z; W; D/; c.D; C/:
In the example above, notice that the conjunction magic_qbbf .X; Y /; b.X; Y; Z; W / appears
in two rules of the ï¬nal program P 0 and, thus, it might be computed twice during the bottom-up
evaluation. î€€e supplementary magic-sets technique is an improvement of the magic-sets method
that computes repeated conjunctions only once. As an example, the program of Example 7.7
is rewritten by introducing a new predicate symbol (called supplementary predicate symbol) as
follows:
magic_pbf.1/:
magic_qbbf .X; 2/
 
magic_pbf.X/:
magic_qbbf.Z; W /
 
sup_magic.X; Y; Z; W /:
sup_magic.X; Y; Z; W /
 
magic_qbbf.X; Y /; b.X; Y; Z; W /:
pbf .X; C/
 
magic_pbf.X/; qbbf.X; 2; C/:
qbbf.X; Y; C/
 
magic_qbbf.X; Y /; a.X; Y; C/:
qbbf.X; Y; C/
 
sup_magic.X; Y; Z; W /; qbbf.Z; W; D/; c.D; C/:
î€€e rule deï¬ning sup_magic computes the conjunction magic_qbbf .X; Y /; b.X; Y; Z; W /
only once so that its results, namely sup_magic.X; Y; Z; W /, is used in place of the conjunction
itself.
7.2
CHAIN QUERIES
In this section, we present a method for the optimization of chain queries, that is, queries where
bindings are propagated from the head to the body of rules in a â€œchain-likeâ€ fashion [Beeri et al.,
1990, Dong, 1992b, Wood, 1990]. î€€e method, called pushdown method [Greco et al., 1995,
1999], is based on the fact that a chain query can be associated with a context-free language, and
a pushdown automaton recognizing this language can be emulated by rewriting the query as a
particular left-linear program.
î€€e method presented in this section generalizes and uniï¬es techniques such as the count-
ing [Bancilhon et al., 1986] and right-, left-, mixed-linear methods [Naughton et al., 1989b]. It
also succeeds in reducing many nonlinear queries to equivalent linear ones.

110
7. QUERY OPTIMIZATION
Using general optimization methods (e.g., the magic-sets rewriting discussed in the previ-
ous section) for chain queries does not allow us to take advantage of the chain structure, thereby
resulting in ineï¬ƒcient query evaluation. î€€erefore, as chain queries are rather frequent in practice
(e.g., in graph applications), there is a need for ad-hoc optimization methods. Several specialized
methods for chain queries have been proposed [Afrati and Cosmadakis, 1989, Beeri et al., 1990,
Dong, 1992b, Wood, 1990, Yannakakis, 1990]. î€€ese methods do not fully exploit possible bind-
ings. One method that is particularly specialized for bound chain queries is the counting method
[Bancilhon et al., 1986]. However, this method, although proposed in the context of general
queries [Haddad and Naughton, 1991, SaccÃ  and Zaniolo, 1987, 1988], preserves the original
simplicity and eï¬ƒciency [Bancilhon et al., 1986, Marchetti-Spaccamela et al., 1991, Ullman,
1989] only for a subset of chain queries whose recursive rules are linear.
î€€e approach proposed in this section exploits the relationship between chain queries and
context-free languages. We will show that classical grammar transformations can be applied to
optimize queries. Moreover, the relationship between context-free languages and pushdown au-
tomata allows us to rewrite chain queries into a format that is more suitable for the bottom-up
evaluation.
Besides giving an eï¬ƒcient execution scheme to bound chain queries and providing an ex-
tension of the counting method, another nice property of the presented method is that it intro-
duces a uniï¬ed framework for the treatment of special cases, such as the factorization of right-,
left-, mixed-linear programs (see Naughton et al. [1989b]), as well as the linearization of non-
linear programs. A number of specialized techniques for the above special cases are known in the
literature [Ioannidis, 1992, Ioannidis and Wong, 1988, Naughton et al., 1989a,b, Saraiya, 1989,
Troy et al., 1989, Wood, 1990]. Given the importance and frequency of these special situations in
practical applications, novel deductive systems call for the usage of a unique method that includes
all advantages of the various specialized techniques.
Before presenting the pushdown method, we introduce some notation and terminology.
Given a Datalog program P , we say that a rule r in P with p as head predicate symbol is
â€¢ recursive if p is mutually recursive with some predicate symbol in the body of r;
â€¢ linear if there is at most one atom in the body of r whose predicate symbol is mutually
recursive with p;
â€¢ left-recursive (resp. right-recursive) if the predicate symbol of the ï¬rst (resp. last) atom in the
body is mutually recursive with p.
If r is linear and left-recursive (resp. right-recursive), then it is also-called left-linear (resp.
right-linear).
Example 7.8
Consider the following Datalog program:
sg.X0; Y0/  a.X0; Y0/:
sg.X0; Y2/  b.X0; Y0/; sg.Y0; X1/; c.X1; Y1/; sg.Y1; X2/; d.X2; Y2/:

7.2. CHAIN QUERIES
111
î€€e ï¬rst rule is not recursive, as the only predicate symbol in the body is a, which is not mutually
recursive with the head predicate symbol sg. î€€us, the rule is linear. Moreover, the rule is neither
left-recursive nor right-recursive.
Consider now the second rule. Notice that predicate symbol sg is mutually recursive with
itself. î€€us, the second rule is recursive, as sg appears in the head and in the body. î€€e rule is not
linear, as there are two atoms in the body whose predicate symbol is sg. Also, the rule is neither
left-recursive nor right-recursive, as the ï¬rst body atomâ€™s predicate symbol is b and the last body
atomâ€™s predicate symbol is d, both of which are not mutually recursive with the head predicate
symbol sg.
Given a Datalog program P and a set q of derived predicate symbols occurring in P , a rule
r of P is a q-chain rule if it is of the form:
p0.X0; Y n/
 
a0.X0; Y 0/; q1.Y 0; X1/; a1.X1; Y 1/; q2.Y 1; X2/; : : : ;
an 1.Xn 1; Y n 1/; qn 1.Y n 1; Xn/; an.Xn; Y n/:
where n  0, the Xiâ€™s and Y iâ€™s are non-empty lists of distinct variables, the ai.Xi; Y i/â€™s are (pos-
sibly empty) conjunction of atoms whose predicate symbols are not in q and are not mutually
recursive with p0, and the qiâ€™s are (not necessarily distinct) predicate symbols in q. We require
that the lists of variables are pairwise disjoint; moreover, for each i (0  i  n), if ai.Xi; Y i/ is
empty then Y i D Xi, otherwise the variables occurring in the conjunction include all those in Xi
and Y i plus possibly other variables that do not occur elsewhere in the rule. For instance, the two
rules of Example 7.8 above are fsgg-chain rules.
If n D 0, then r reduces to p0.X0; Y 0/  a0.X0; Y 0/ and is called an exit chain rule. In
all other cases (i.e., n > 0), r is called a recurrence chain rule. Observe that a chain rule is left-
recursive (resp. right-recursive) iï¬€a0.X0; Y 0/ (resp. an.Xn; Y n/) is the empty conjunction and
q1 (resp. qn 1) is mutually recursive with p0. For instance, the ï¬rst rule in Example 7.8 is an exit
chain rule, while the second one is a recurrence chain rule.
A Datalog program P is a q-chain program if for each predicate symbol p in q, every rule
with p in the head is a q-chain rule and for each two atoms p.X; Y / and p.Z; W / occurring in
the body or the head of q-chain rules, X D Z and Y D W modulo renaming of the variables.
A q-bound chain Datalog query (or simply chain query when q is clear from the context or is
not relevant) Q is a Datalog query hP; p.b; Y /i, where P is a q-chain program, p is a predicate
symbol in q, b is a list of constants, and Y is a list of variables.
In the following we present a method which, given a q-bound chain Datalog query
hP; p.b; Y /i, constructs an equivalent left-linear query. î€€e obtained query can be implemented
eï¬ƒciently using the bottom-up ï¬xpoint computation. In order to guarantee that the binding b is
propagated through all q-chain rules, we will assume that
â€¢ q D fpg [ q0 for some q0;
â€¢ q0  leq.p/Â²; and
Â²Recall that leq.p/ denotes the set of all predicate symbols p depends on.

112
7. QUERY OPTIMIZATION
â€¢ for each q in q, every q0 2 leq.p/ s.t. q  q0 is in q as well.
Moreover, in order to restrict optimization to those portions which depend on some recursion,
we will also assume that for each q in q, there exists at least one recursive predicate symbol q0 in
q s.t. q0  q.
7.2.1
THE PUSHDOWN METHOD
î€€e pushdown method is based on the analogy of chain queries and context-free grammars [Ull-
man, 1992]. Without loss of generality we assume that each list of variables in chain rules consist
of one variable and that the ï¬rst argument of the query goal is a constant whereas the second one
is a variable. î€€us, all considered predicate symbols are binary. We start by introducing the basic
idea in the following example.
Example 7.9
Consider the chain query Q D hP; sg.1; Y /i, where P is the (non-linear) pro-
gram of Example 7.8. A context-free language corresponding to this program is generated by the
following grammarÂ³
G.Q/ D hVN ; VT ; Ë˜; sgi
where the set of non-terminal symbols VN contains only sg, the set of terminal symbols VT is
fa; b; c; dg, and Ë˜ consists of the following production rules:
sg
!
a
sg
!
b sg c sg d
Note that the production rules in Ë˜ are obtained from the rules of P by dropping the arguments
of predicate symbols and reversing the arrow. î€€e language L.Q/ generated by this grammar can
be recognized by the automaton shown in Figure 7.1.
î€€is automaton can in turn be implemented by the following program OË˜ (where function
symbols are used)
Â³We refer the reader to Hopcroft and Ullman [1979] for a treatment of automata theory and languages.
b
c
d
a

.q0; Z0/
.q; sg Z0/
.q; sg/
.q; sg c sg d/
.q; /
.q; c/
.q; /
.q; d/
.q; /
Figure 7.1: Pushdown Automaton for the query of Example 7.9.

7.2. CHAIN QUERIES
113
q.Å’ sg Â/:
q.T /
 
q.Å’ sg j T Â/; a:
q.Å’ sg; c; sg; d j T Â/
 
q.Å’ sg j T Â/; b:
q.T /
 
q.Å’ c j T Â/; c:
q.T /
 
q.Å’ d j T Â/; d:
We can now derive a program OP by reintroducing variables into OË˜â€”the derived program
will be used as part of a query equivalent to the original one. Speciï¬cally, variables X and Y are
added to the non-recursive predicate symbols. For the recursive predicate symbol, we add the
variable Y to the occurrences of the predicate symbol in the head, and the variable X to the
occurrences of the predicate symbol in the body. î€€e resulting program OP is:
q.1; Å’ sg Â/:
q.Y; T /
 
q.X; Å’ sg j T Â/; a.X; Y /:
q.Y; Å’ sg; c; sg; d j T Â/
 
q.X; Å’ sg j T Â/; b.X; Y /:
q.Y; T /
 
q.X; Å’ c j T Â/; c.X; Y /:
q.Y; T /
 
q.X; Å’ d j T Â/; d.X; Y /:
î€€e query h OP ; q.Y; Å’ Â/i is equivalent to the original one. Observe that the rewritten program is
not a Datalog program anymore as function symbols have been used (see Chapter 5).
We now present how the technique works in general. We start by deï¬ning the context-free
language associated with a q-chain query Q D hP; p.b; Y /i. Let V be the set of all predicate
symbols occurring in the q-chain rules. î€€e set VN of non-terminal symbols is q and the set of
terminal symbols is VT D V   VN. We associate with Q the context-free language L.Q/ on the
alphabet VT deï¬ned by the grammar G.Q/ D hVN ; VT ; Ë˜; pi where the production rules in Ë˜
are deï¬ned as follows.
For each q-chain rule rj of the form:
pj
0.X0; Yn/  aj
0.X0; Y0/; pj
1.Y0; X1/; aj
1.X1; Y1/; : : : ; pj
n 1.Yn 1; Xn/; aj
n.Xn; Yn/:
with n  0, the following production rule is generated:
pj
0
!
aj
0 pj
1 aj
1    pj
n 1 aj
n:
î€€e language L.Q/ is recognized by a pushdown automaton deï¬ned as follows:
â€¢ it has two states q0 and q, which are, respectively, the initial and the ï¬nal state; and
â€¢ the transition table has one column for each symbol in VT plus a column for the  symbol,
one row for the pair .q0; Z0/, where Z0 is the starting pushdown symbol, and one row .q; v/
for each v 2 V .

114
7. QUERY OPTIMIZATION
Figure 7.2 illustrates the transition table. Note that, for the sake of presentation, the pushdown
alphabet is not distinct from the language alphabet. î€€e last entry in the ï¬rst row corresponds to
the start up of the pushdown automaton and consists of entering the query goal predicate symbol
p in the pushdown store. î€€e remaining rows corresponds to the generic q-chain rule rj shown
above; speciï¬cally, we have one row for aj
0 and one row for each aj
i , 1  i  n, that is not empty.
Obviously, if the rule is an exit rule (i.e., n D 0), the entry corresponding to aj
0 is .q; /.
aj
0
aj
1
  
aj
n

.q0; Z0/
.q; p Z0/
  
.q; pj
0/
.q; pj
1aj
1    pj
n 1aj
n/
.q; aj
1/
.q; /
  
.q; aj
n/
.q; /
  
Figure 7.2: Pushdown automaton recognizing L.Q/.
Given a string Ë› D ak1
i1 ak2
i2    akm
im in V 
T , a path spelling Ë› on P is a sequence of m C 1 (not
necessarily distinct) constants b0, b1, b2; : : : ; bm such that for each j, 1  j  m, a
kj
ij .bj 1; bj /
is an atom in the least model of P ; if m D 0 then the path spells the empty string  [Afrati and
Cosmadakis, 1989].
It is well known that, given a database D, a ground atom p.b; c/ belongs to Q.D/ if and
only if there exists a path from b to c spelling a string Ë› of L.Q/ on P . î€€erefore, in order to
compute Q.D/, it is suï¬ƒcient to use the automaton of Figure 7.2 to recognize all paths leaving
from b and spelling a string Ë› of L.Q/ on P [Afrati and Cosmadakis, 1989]. î€€is can be easily
done by a logic program OP which implements the automaton. In fact, OP can be directly con-
structed using all transition rules of Figure 7.2. Speciï¬cally, we use a rule for each entry in the
table. î€€e start-up of the automaton is simulated by a fact which sets both the initial node of the
path spelling a string of the language and the initial state of the pushdown store. For the chain
query Q D hP; p.b; Y /i, the resulting program OP is as follows:
q.b; Å’pÂ/:
  
q.Y; Å’pj
1; aj
1; : : : ; pj
n 1; aj
njT Â/
 
q.X; Å’pj
0jT Â/; aj
0.X; Y /:
q.Y; T /
 
q.X; Å’aj
1jT Â/; aj
1.X; Y /:
  
q.Y; T /
 
q.X; Å’aj
njT Â/; aj
n.X; Y /:
  

7.2. CHAIN QUERIES
115
Program
OP will be called the pushdown program of the Datalog query Q; the query
OQ D
h OP ; q.Y; Å’ Â/i will be called the pushdown query of Q. î€€e technique for constructing pushdown-
queries will be called the pushdown method. Here one important property is that Q is equivalent
to its pushdown query [Greco et al., 1999].
We point out that a naive execution of the rewritten program can sometimes be ineï¬ƒ-
cient or even non-terminating for cyclic databases. In Section 7.2.5 we will present a technique,
based on the approach of Greco and Zaniolo [1992], where lists implementing pushdown stores
are represented as pairs consisting of the head and a pointer to the tuple storing the tail of the
list. In this way, each possible cyclic sequence in the pushdown store is recorded only once and
termination is guaranteed.
7.2.2
RIGHT-LINEAR PROGRAMS
î€€e pushdown method is based on constructing a particular pushdown automaton to recognize a
context-free language.
Let us consider the case of a chain query Q for which every recursive chain rule is right-
linear, that is, both right-recursive and linear. î€€en, the associated grammar G.Q/ is regular
right-linear (see Hopcroft and Ullman [1979] for more details) and, therefore, the pushdown
actually acts as a ï¬nite state automaton. Indeed, if the query is right-linear, then the pushdown
store either is empty or contains only one symbol. î€€erefore, it is possible to delete the pushdown
store and put the information of the pushdown store into the states.
Of course, for right-linear chain queries, it is possible to generate directly the push-
down query which works as a ï¬nite state automaton. î€€us, given a chain right-linear query
Q D hP; p.b; Y /i, the pushdown query is h OP ; pF .Y /i where OP consists of:
â€¢ a fact of the form
q.b/I
â€¢ a rule of the form
q0.Y /  q.X/; a.X; Y /:
for each production rule of the form q ! a q0 in G.Q/ with q and q0 being mutually recur-
sive; and
â€¢ a rule of the form
qF .Y /  q.X/; a.X; Y /:
for each production rule of the form q ! a in G.Q/.
î€€e query obtained as described above is called the ï¬nite state query of Q.
Example 7.10
Consider the chain query Q D hP; p.c; Y /i, where P is:
p.X; Y /  b.X; Y /:
p.X; Y /  a.X; Z/; p.Z; Y /:

116
7. QUERY OPTIMIZATION
î€€e grammar G.Q/ is regular right-linear and is as follows:
p ! b j a p:
î€€e pushdown automaton recognizing L.Q/ is as follows
a
b

.q0; Z0/
.q; p Z0/
.q; p/
.q; p/
.q; /
î€€e pushdown query of Q is OQ D h OP ; q.Y; Å’ Â/i with OP as follows:
q.c; Å’pÂ/:
q.Y; Å’pÂ/
 
q.X; Å’pÂ/; a.X; Y /:
q.Y; Å’ Â/
 
q.X; Å’pÂ/; b.X; Y /:
By deleting the pushdown store and putting its information into the state we obtain the query
h OP 0; q.Y /i where OP 0 is as follows:
qp.c/:
qp.Y /
 
qp.X/; a.X; Y /:
q.Y /
 
qp.X/; b.X; Y /:
Observe that the language L.Q/ can be recognized by a ï¬nite state automaton whose tran-
sition function is as follows:
Ä±.p; a/
!
p
Ä±.p; b/
!
pF ;
where p and pF denote the initial state and the ï¬nal state, respectively. î€€e ï¬nite state query of
Q is h OP 00; pF .Y /i where OP 00 is the following program:
p.c/:
p.Y /
 
p.X/; a.X; Y /:
pF .Y /
 
p.X/; b.X; Y /:
î€€us, for right-linear queries the pushdown method does not use any pushdown store and
the pushdown query of Q reduces to the ï¬nite state query of Q. Given a q-chain query Q such
that G.Q/ is right-linear, the ï¬nite state query of Q is equivalent to Q [Greco et al., 1999].
7.2.3
GRAMMAR TRANSFORMATIONS TO IMPROVE PUSHDOWN
In this section, we demonstrate that the use of automata becomes more eï¬€ective if the grammar
of the language has a particular structure. More interestingly, we show that if the grammar does
not have this structure, then the program can be rewritten so that the corresponding grammar

7.2. CHAIN QUERIES
117
achieves the desired structure. î€€e rewriting is mainly done by applying known techniques for
transforming grammars.
Observe that, for a Datalog query Q, if the grammar G.Q/ is regular left-linear, then the
pushdown method does not emulate a ï¬nite state automaton, as opposed to the case where G.Q/
is regular right-linear, and it may become rather ineï¬ƒcient or even non-terminating. As shown
in the following, we can overcome this problem by replacing left-recursion with right-recursion
applying well-known reduction techniques for grammars.
Consider a q-chain query Q D hP; p.b; Y /i and suppose that a predicate symbol s 2 q is
in the head of some left-recursive chain ruleâ€”in this case, we say that s is left-recursive. î€€en, the
deï¬nition def.s; P / of s consists of m > 0 left-recursive chain rules and n chain rules that are not
left-recursive, that is, def.s; P / is as follows (below we assume n > 0 for the sake of simplicity):
s.X; Y /
 
Ë›i.X; Y /:
1  i  n
s.X; Y /
 
s0.X; Z/; Ë‡i.Z; Y /:
1  i  m;
where Ë›i.X; Y / and Ë‡i.Z; Y / are conjunctions of atoms. î€€e production rules deï¬ning the symbol
s in the grammar G.Q/ are:
s
!
Ë›i
1  i  n
s
!
s0 Ë‡i
1  i  m;
where Ë›i and Ë‡i denote the sequences of predicate symbols appearing in Ë›i.X; Y / and Ë‡i.Z; Y /,
respectively. We can apply known transformations to remove left-recursion from the second group
of production rules for all left-recursive predicate symbols s; we then write the corresponding
Datalog rules accordingly. It turns out that the resulting program, which is said to be in canon-
ical form and is denoted by can.P /, does not contain any left-recursive q-chain rule. Moreover,
hP; p.b; Y /i is equivalent to hcan.P /; p.b; Y /i [Greco et al., 1999].
Example 7.11
Consider the following left-linear q-chain query Q D hP; path.b; Y /i, where
q D fpathg and P contains the following two rules:
path.X; Y /  edge.X; Y /:
path.X; Y /  path.X; Z/; edge.Z; Y /:
Program P computes the transitive closure of the binary relation edge and is left-linear. î€€e
associated grammar G.Q/ is
path ! edge j path edge
and is left-recursive. To remove left-recursion, the grammar above can be rewritten into the fol-
lowing right-recursive grammar:
path
!
edge path0
path0
!
edge path0 j :

118
7. QUERY OPTIMIZATION
So, the program can.P / is:
path.X; Y /  edge.X; Z/; path0.Z; Y /:
path0.X; X/:
path0.X; Y /  edge.X; Z/; path0.Z; Y /
and is right-linear. î€€erefore, the pushdown query can be now solved eï¬ƒciently.
Notice that the rule path0.X; X/ does not satisfy the safety condition for Datalog programs
(cf. Section 3.1) because variable X is not limitedâ€”the reason is that the rule body is empty.
However, the rule might be made safe by adding the atom edge.Y; X/ in the body, without altering
the semantics of the query. In general, we can add suitable atoms in the body of rules in can.P /
specifying what are the values that the variables appearing only in the head can take.
Example 7.12
Assume now that program P of Example 7.11 is deï¬ned as the following non-
linear program:
path.X; Y /  edge.X; Y /:
path.X; Y /  path.X; Z/; path.Z; Y /:
î€€is program is left-recursive and, after the ï¬rst step of the procedure for removing left-recursion,
is rewritten as follows:
r1 W path.X; Y /  edge.X; Z/; path0.Z; Y /:
r2 W path0.X; X/:
r3 W path0.X; Y /  path.X; Z/; path0.Z; Y /:
î€€e second step removes left recursion from rule r3 by rewriting it as follows:
path0.X; Y /  edge.X; W /; path0.W; Z/; path0.Z; Y /:
We now introduce a program transformation that improves the performance of the push-
down method for an interesting case of right-recursion. Suppose that there exists a predicate
symbol s in P such that def.s; P / consists of a single chain rule of the form s.X; X/ and m > 0
right-recursive chain rules of the form:
s.X; Y /  Ë›i.X; Z/; s.Z; Y /:
1  i  m:
We rewrite each recursive chain rule that is in the following format:
s.X; Y /  Ë›i.X; Z/; s.Z; W /; s.W; Y /:
as follows:
s.X; Y /  Ë›i.X; Z/; s.Z; Y /:

7.2. CHAIN QUERIES
119
î€€at is, we drop one occurrence of the recursive atoms at the end of the rule. If the resulting rule
has still multiple recursive atoms at the end, we repeat the transformation. î€€e program obtained
after performing the above transformations for all the predicate symbols s in P is denoted by
simple.P /. î€€en, hP; p.b; Y /i is equivalent to hsimple.P /; p.b; Y /i [Greco et al., 1999].
Example 7.13
Consider the program P 0 D can.P / of Example 7.12 which is reported below:
r1 W path.X; Y /
 
edge.X; Z/; path0.Z; Y /:
r2 W path0.X; X/:
r3 W path0.X; Y /
 
edge.X; W /; path0.W; Z/; path0.Z; Y /:
Clearly, def.path0; P 0/ D fr2; r3g. î€€en, simple.P 0/ is as follows:
path.X; Y /
 
edge.X; Z/; path0.Z; Y /:
path0.X; X/:
path0.X; Y /
 
edge.X; W /; path0.W; Y /:
î€€us, we have eventually linearized the non-linear transitive closure.
We observe that the transformation simple can be applied to a larger number of cases by
applying further grammar rewriting. For instance, given the grammar:
s
!
a s0
s0
!
b s s0 j :
We can modify it into:
s
!
a s0
s0
!
b a s0 s0 j 
so that we can eventually apply the transformation simple.
Example 7.14
Consider the fpathg-chain query Q D hP; path.b; Y /i where P is deï¬ned as
follows:
path.X; Y /
 
yellow.X; Y /:
path.X; Y /
 
path.X; U /; red.U; V /; path.V; W /; blue.W; Z/; path.Z; Y /:
î€€en, can.P / is as follows:
path.X; Y /
 
yellow.X; Z/; path0.Z; Y /:
path0.X; X/:
path0.X; Y /
 
red.X; U /; path.U; W /; blue.W; Z/; path.Z; T /; path0.T; Y /:

120
7. QUERY OPTIMIZATION
We now replace the two occurrence of path in the body of the last rule with the body of the ï¬rst
rule and obtain the equivalent program P 0:
path.X; Y /
 
yellow.X; Z/; path0.Z; Y /:
path0.X; X/:
path0.X; Y /
 
red.X; U /; yellow.U; V /; path0.V; W /; blue.W; Z/;
yellow.Z; S/; path0.S; T /; path0.T; Y /:
We can now apply the transformation simple to path0 and the last rule of P 0 becomes:
path0.X; Y /  red.X; U /; yellow.U; V /; path0.V; W /; bblue.W; Z/; yellow.Z; S/; path0.S; Y /:
We now apply another transformation for the predicate symbols for which the transforma-
tion simple cannot be applied because of the lack of the chain rule of the form s.X; X/. Suppose
that there exists a predicate symbol s in q such that def.s; P / consists of n > 0 exit chain rules,
say
s.X; Y /  Ë‡i.X; Y /:
1  i  n
and m > 0 right-recursive chain rules of the form:
s.X; Y /  Ë›i.X; Z/; s.Z; Y /:
1  i  m
We rewrite the above rules as follows:
s.X; Y /
 
s0.X; Z/; Ë‡i.Z; Y /:
1  i  n
s0.X; X/:
s0.X; Y /
 
Ë›i.X; Z/; s0.Z; Y /:
1  i  m:
We now replace atoms in Ë›i having s as predicate symbol with the bodies of the rules deï¬ning s.
In this way, every rule will not have two consecutive recursive predicate symbols at the end of the
body.
î€€e program obtained after performing the above transformations for all the predicate
symbols in P is denoted by simple0.P /. As shown in Greco et al. [1999], hsimple0.P /; p.b; Y /i
is equivalent to the original chain query hP; p.b; Y /i.
Example 7.15
Consider the fpathg-chain query Q D hP; path.b; Y /i where P is deï¬ned as
follows:
path.X; Y /
 
yellow.X; Y /:
path.X; Y /
 
red.X; V /; path.V; W /; path.W; Y /:
î€€en, simple0.P / consists of the following rules:
path.X; Y /
 
path0.X; Z/; yellow.Z; Y /:
path0.X; X/:
path0.X; Y /
 
red.X; V /; path0.V; W /; yellow.W; T /; path0.T; Y /:

7.2. CHAIN QUERIES
121
As discussed in the next section, the form of simple0.P / is very eï¬€ective for the performance not
only of the pushdown method but also of the counting method.
7.2.4
WHEN PUSHDOWN REDUCES TO COUNTING
In this section, we describe some conditions under which the pushdown method reduces to
the counting method [Bancilhon et al., 1986, SaccÃ  and Zaniolo, 1988]. Actually, the count-
ing method can be seen as a space-eï¬ƒcient implementation of the pushdown store. On the other
hand, as the pushdown method has a larger application domain, we can conclude that the push-
down method is a powerful extension of the counting method.
We ï¬rst observe that, given the pushdown program of a q-chain query, the pushdown store
can be eï¬ƒciently implemented whenever it contains strings of the form Ë›k.Ë‡/n, with 0  k  1
and n  0. Indeed, the store can be replaced by the counter n and the introduction of two new
states qË› and qË‡ to record whether the top symbol is Ë› or Ë‡, respectively. î€€is situation arises when
the program consists of a number of exit chain rules and right-linear chain rules, and a single linear
non-left-recursive chain rule. î€€e next example illustrates that the above implementation of the
pushdown store corresponds to applying the counting method.
Example 7.16
Consider the Datalog query hP; sg.d; Y /i where P is the linear program below:
sg.X; Y /
 
c.X; Y /:
sg.X; Y /
 
a.X; X1/; sg.X1; Y1/; b.Y1; Y /:
î€€e pushdown query is hP 0; q.Y; Å’ Â/i, where P 0 is:
q.d; Å’ sg Â/:
q.Y; Å’ sg; b j T Â/
 
q.X; Å’ sg j T Â/; a.X; Y /:
q.Y; T /
 
q.X; Å’ sg j T Â/; c.X; Y /:
q.Y; T /
 
q.Y; Å’ b j T Â/; b.X; Y /:
Observe that the pushdown store contains strings of the form sg.b/n or of the form .b/n, with
n  0. So, we replace the store with the counter n and the introduction of two new states qsg and
qb to record whether the top symbol is sg or b, respectively. î€€erefore, the rules above can be
rewritten as follows:
qsg.d; 0/:
qsg.Y; I/
 
qsg.X; J /; a.X; Y /; I D J C 1:
qb.Y; I/
 
qsg.X; I/; c.X; Y /:
qb.Y; I/
 
qb.Y; J /; b.X; Y /; I D J   1:
î€€ese rules are the same as those generated by the counting method. î€€e query goal becomes
qb.Y; 0/.

122
7. QUERY OPTIMIZATION
We now show that the above counting implementation of the pushdown store can be done
also when the pushdown strings are of the form Ë›k .Ë‡Ë›/n where 0  k  1 and n  0. î€€is sit-
uation arises when the queryâ€™s program consists of a number of exit chain rules and right-linear
chain rules, and a single bi-linear (i.e., the rule body contains two atoms whose predicate symbols
are mutually recursive with the head predicate symbol) recursive chain rule that is right-recursive
but not left-recursive, e.g., the rule might be of the form:
p.X0; Y2/  a0.X0; Y0/; p.Y0; X1/; a1.X1; Y1/; p.Y1; Y2/:
Example 7.17
Consider the query Q D hP; path.b; Y /i where P is:
path.X; X/:
path.X; Y /  red.X; V /; path.V; W /; yellow.W; T /; path.T; Y /:
Using the counting implementation of the pushdown store, we obtain the following program:
qpath.b; 0/:
qyellow.X; I/
 
qpath.X; I/:
qpath.Y; I C 1/
 
qpath.X; I/; red.X; Y /:
qpath.Y; I   1/
 
qyellow.X; I/; yellow.X; Y /:
î€€e query goal is qyellow.Y; 0/. It is worth noting that the above program cannot be handled by
the counting method.
7.2.5
IMPLEMENTATION AND TERMINATION
As pointed out in Section 7.2.1, the pushdown method could be ineï¬ƒcient or even non-
terminating for cyclic databases. In this section, we show how the method can be implemented
in order to guarantee eï¬ƒciency and termination.
î€€e basic idea is to â€œdistributeâ€ stores among facts and link the facts used to memorize the
same store. Speciï¬cally, the store associated with a fact is memorized by means of two distinct
elements: a list containing a block of elements in the top of the store and a link to a fact which can
be used to derive the tail of the store. î€€us, a fact of the form q.x; Å’p1; : : : ; pnÂ/ is memorized as
q.x; Å’p1; : : : ; pkÂ; Id/ where k  n and Id is a link to some fact which permit to determine the
tail Å’pkC1; : : : ; pnÂ of the store.
We now present how the pushdown method is implemented. Let Q D hP; p.a; Y /i be a
chain Datalog query and let OQ D hP 0; q.Y; Å’ Â/i be the pushdown query of Q. Recall that P 0 has

7.2. CHAIN QUERIES
123
rules of the form (see Section 7.2.1):
q.b; Å’pÂ/:
  
q.Y; Å’pj
1; aj
1; : : : ; pj
n 1; aj
njT Â/
 
q.X; Å’pj
0jT Â/; aj
0.X; Y /:
q.Y; T /
 
q.X; Å’aj
1jT Â/; aj
1.X; Y /:
  
q.Y; T /
 
q.X; Å’aj
njT Â/; aj
n.X; Y /:
  
î€€e
pushdown implementation query
of
Q,
denoted
I. OQ/,
is
the
pushdown
query
hP 00; q.Y; Å’ Â; nil/i where P 00 is derived from P 0 as follows.
1. A fact of the form
q.b; Å’pÂ/:
is substituted by the following fact where nil is a new constant
q.b; Å’pÂ; nil/:
2. A rule rj of the form
q.Y; Å’pj
1; aj
1; : : : ; pj
n; aj
n j T Â/  q.X; Å’pj
0 j T Â/; aj
0.X; Y /
is substituted by the rule
q.Y; Å’pj
1; aj
1; : : : ; pj
n; aj
nÂ; Id.X//  q.X; Å’pj
0 j T Â; I/; aj
0.X; Y /;
where Id.X/ is a unique identiï¬er associated with the list of ground tuples having X as ï¬rst
argument. In the following, for the sake of simplicity, we assume that Id.X/ D X.
3. A rule rj of the following form with i < n
q.Y; T /  q.X; Å’aj
i j T Â/; aj
i .X; Y /
is substituted by the rule
q.Y; T; I/  q.X; Å’aj
i j T Â; I/; aj
i .X; Y /:
4. A rule rj of the form
q.Y; T /  q.X; Å’aj
n j T Â/; aj
n.X; Y /
is substituted by the rule
q.Y; T; I/  q.X; Å’aj
nÂ; Id.Z//; q.Z; Å’p j T Â; I/; aj
n.X; Y /:
Recall that p is the predicate symbol of the goal of the original chain Datalog query.

124
7. QUERY OPTIMIZATION
î€€e following example illustrates how the pushdown implementation query is carried out.
Example 7.18
Consider the query Q D hP; sg.1; Y /i of Example 7.9. As already discussed in
Example 7.9, the pushdown query is h OP ; q.Y; Å’ Â/i, where OP is as follows:
q.1; Å’ sg Â/:
q.Y; T /
 
q.X; Å’ sg j T Â/; a.X; Y /:
q.Y; Å’ sg; c; sg; d j T Â/
 
q.X; Å’ sg j T Â/; b.X; Y /:
q.Y; T /
 
q.X; Å’ c j T Â/; c.X; Y /:
q.Y; T /
 
q.X; Å’ d j T Â/; d.X; Y /:
î€€e pushdown implementation query I. OQ/ is hP 00; sg.Y; Å’ Â; nil/i where P 00 is as follows:
q.1; Å’ sg Â; nil/:
q.Y; T; I/
 
q.X; Å’ sg j T Â; I/; a.X; Y /:
q.Y; Å’ sg; c; sg; d Â; X/
 
q.X; Å’ sg j T Â; I/; b.X; Y /:
q.Y; T; I/
 
q.X; Å’ c j T Â; I/; c.X; Y /:
q.Y; T; I/
 
q.X; Å’ d Â; Z/; q.Z; Å’ sg j T Â; I/; d.X; Y /:
As shown in Greco et al. [1999], I. OQ/ is equivalent to the original query Q. Moreover,
the implementation technique, besides eï¬ƒciency, guarantees also termination of the evaluation
process, that is, the bottom-up computation of I. OQ/ always terminates [Greco et al., 1999].
î€€e following example shows how queries are computed in the presence of cyclic databases.
Example 7.19
Let I. OQ/ D hP 00; sg.Y; Å’ Â; nil/i be the pushdown query of Example 7.18. Con-
sider the database pictured in Figure 7.3 where a fact p.x; y/ is represented by an edge from x to
y with label p.
c
a
a
d
b
d
c
a
b
n
?
-
?
-
-
-
6
6
-
10
9
8
7
6
5
4
3
2
1n
Figure 7.3: Acyclic database.

7.2. CHAIN QUERIES
125
î€€e evaluation of program P 00 produces the following ground atoms: q.1; Å’ sg Â; nil/,
q.2; Å’ sg; c; sg; d Â; 1/, q.3; Å’ sg; c; sg; d Â; 2/, q.4; Å’ c; sg; d Â; 2/, q.5; Å’ sg; d Â; 2/, q.6; Å’ d Â; 2/,
q.7; Å’ c; sg; d Â; 1/,
q.8; Å’ sg; d Â; 1/,
q.9; Å’ d Â; 1/, and
q.10; Å’ Â; nil/.
î€€erefore, the answer is
Y D 10.
Consider now the cyclic database pictured in Figure 7.4. î€€e evaluation of program
P 00 produces the ground atoms q.1; Å’ sg Â; nil/, q.2; Å’ sg; c; sg; d Â; 1/,
q.1; Å’ sg; c; sg; d Â; 2/,
q.3; Å’ c; sg; d Â; 1/, q.4; Å’ sg; d Â; 1/, q.5; Å’ d Â; 1/, q.6; Å’ Â; nil/, q.6; Å’ c; sg; d Â; 2/, q.7; Å’ sg; d Â; 2/,
q.8; Å’ d Â; 2/, q.9; Å’ c; sg; d Â; 1/, q.10; Å’ sg; d Â; 1/, q.11; Å’ d Â; 1/ and q.10; Å’ Â; nil/. î€€erefore, the
answers are Y D 6 and Y D 12.
HH
j


12
11
10
d
n
?
-
-
n
n
1
2
3
4
5
6
7
8
9
-
6
-
-
-
?
-
?
b
a
c
d
b
d
a
a
c
Figure 7.4: Cyclic database.
î€€e implementation of the pushdown method can be seen as a smart implementation of
the supplementary magic-sets method [SaccÃ  and Zaniolo, 1986] (see also Beeri and Ramakr-
ishnan [1991]). Moreover, for non-linear programs there is an important diï¬€erence since the
method generates less non-linear recursive rules than the supplementary magic-sets method. For
instance, consider the non-linear query of Example 7.9. î€€e program obtained by applying the
supplementary magic-sets method is as follows:
m_sg.b/:
m_sg.X1/
 
s_sg1.Z; X1/:
m_sg.Y2/
 
s_sg3.Z; Y2/:
s_sg1.X; X1/
 
m_sg.X/; b.X; X1/:
s_sg2.X; X2/
 
s_sg1.X; X1/; sg.X1; X2/:
s_sg3.X; X3/
 
s_sg2.X; X2/; c.X2; Y2/:
sg.X; Y /
 
m_sg.X/; a.X; Y /:
sg.X; Y /
 
s_sg3.X; Y2/; sg.Y2; Y1/; d.Y1; Y /:

126
7. QUERY OPTIMIZATION
î€€e rule deï¬ning predicate symbol s_sg2 and the second rule deï¬ning predicate symbol
sg are bi-linear, that is, they have two occurrences of predicate symbols mutually recursive with
the head predicate symbol. î€€e program generated by the pushdown method contains only one
bi-linear rule and, therefore, its execution can be more eï¬ƒcient.
In the general case, given a nonlinear recursive rule having n > 1 occurrences of predicate
symbols in its body that are mutually recursive with the head predicate symbol, the pushdown
method generates only one bi-linear rule whereas the supplementary magic-sets method generates
n bi-linear rules. Observe also that the space used by the pushdown method is less than that
used by the supplementary magic-sets method since the pushdown method does not use magic
predicates.
BIBLIOGRAPHIC NOTES
Magic-sets rewriting has been studied in several papers [Bancilhon and Ramakrishnan, 1988,
Bancilhon et al., 1986, Beeri and Ramakrishnan, 1987, 1991, Greco and Zaniolo, 1992, 1994,
Naughton et al., 1989a,b, Ramakrishnan et al., 1989, Ullman, 1989]
î€€e analogies between chain queries and context-free languages were investigated by several
authors, including [Afrati and Papadimitriou, 1987, Beeri et al., 1990, Dong, 1992a,b, Pereira and
Warren, 1980, Ullman, 1992, Ullman and Van Gelder, 1986]. In particular, the use of automata
to compute general logic queries was ï¬rst proposed by Lang [1988]. Langâ€™s method is based on
pushing facts from the database onto the stack for later use in reverse order in the proof of a goal.
As the method applies to general queries, it is not very eï¬€ective for chain queries; besides, it does
not exploit possible bindings.
Vieille [1989] independently proposed an extension of SLD-resolution which avoids repli-
cated computations in the evaluation of general logic queries using stacks to perform a set-oriented
computation. Also this method does not take advantage of a possible chain structure but it does
exploit possible bindings.
î€€e ï¬rst proposal of a method that is both specialized for chain queries and based on
the properties of context-free language is due to Yannakakis [1990], who proposed a dynamic
programming technique implementing the method of Cocke-Younger and Kasami to recognize
strings of general context-free languages. î€€is technique turns out to be eï¬ƒcient for unbound
queries but it does not support any mechanism to reduce the search space when bindings are
available.
Strategies for processing and optimizing Datalog queries are discussed also in Abiteboul
et al. [1995], Bancilhon and Ramakrishnan [1986], Ceri et al. [1989], Green et al. [2013], Ullman
[1989].
Several extensions of the magic-sets technique have been proposed to deal with Datalog
extended with stratiï¬ed negation [Behrend, 2003], a restricted form of negation called modular
stratiï¬cation [Ross, 1994], unstratiï¬ed negation [Faber et al., 2007], disjunction [Cumbo et al.,

7.2. CHAIN QUERIES
127
2004], disjunction and stratiï¬ed negation [Alviano et al., 2012, Greco, 1998b, 1999b, 2003], and
disjunction and constraints [Greco et al., 2005].


129
C H A P T E R
8
Applications
Recently, there has been a great deal of interest in applying Datalog in several domains [Huang
et al., 2011] such as declarative networking [Loo et al., 2005a,b, 2006], network monitor-
ing [Abiteboul et al., 2005], program analysis [Bravenboer and Smaragdakis, 2009], secu-
rity [Marczak et al., 2010, Zhou et al., 2009], cloud computing [Alvaro et al., 2010], information
extraction [Gottlob et al., 2004, Shen et al., 2007], P2P deductive databases [Caroprese et al.,
2006], and social network analysis [Seo et al., 2013]. Speciï¬cally, these works extend the Data-
log language and its implementation techniques with constructs that are particularly useful for a
speciï¬c domain.
î€€e arguments in favor of Datalog-like languages is the declarative nature of the resulting
languages, which eases the problem formulation for the user and allows powerful performance
optimizations on the part of the system.
In this chapter, we brieï¬‚y discuss diï¬€erent domains where Datalog or Datalog-like lan-
guages have been recently applied.
8.1
SECURITY
î€€e Binder language [DeTreville, 2002] is a Datalog-based language for access control in dis-
tributed systems.
A â€œprincipalâ€ in Binder refers to a component in a distributed environment. Each principal
has its own local context where its rules reside. Binder assumes an untrusted network, where
diï¬€erent components can serve diï¬€erent roles running distinct sets of rules. Because of the lack
of trust among nodes, a component does not have control over rule execution at other nodes.
Instead, Binder allows separate programs to interoperate correctly and securely via the export and
import of rules and derived tuples across contexts
Example8.1
Binder has a distinguished operator says. î€€e says operator implements a common
logical construct in authentication, where â€œp says sâ€ means that principal p supports statement
s. For instance, in Binder we can write:
access.P; O; read/  good.P /:
access.P; O; read/  bob says access.P; O; read/:
î€€e rules above state that any principal P may access any object O in read mode if P is good
or if bob says that P may do so. î€€e says operator abstracts from the details of authentication.

130
8. APPLICATIONS
8.2
NETWORKING
Network Datalog (NDlog) [Loo et al., 2006] is a Datalog-like language used for querying network
graphs, allowing one to implement a variety of routing protocols and overlay networks.
Example 8.2
î€€e following NDlog programs ï¬nds all pairs of reachable vertices over a graph
stored by means of link-facts representing the graph edges.
reachable.@S; D/  link.@S; D/:
reachable.@S; D/  link.@S; Z/; reachable.@Z; D/:
î€€e rules above specify a distributed transitive closure computation. NDlog supports a lo-
cation speciï¬er in each predicate, expressed with @ symbol followed by an attribute. î€€is attribute
is used to denote the source location of each corresponding tuple. For example, all reachable and
link tuples are stored based on the @S address ï¬eld.
î€€e Secure Network Datalog (SeNDlog) language [Zhou et al., 2009] uniï¬es Binder and
NDlog. SecureBlox [Marczak et al., 2010] is a declarative system that uniï¬es a distributed query
processor with a security policy framework. SecureBlox decouples security concerns from sys-
tem speciï¬cation allowing easy reconï¬guration of a systemâ€™s security properties to suit a given
execution environment.
8.3
WEB DATA MANAGEMENT
Webdamlog [Abiteboul et al., 2011] is a language to support the distribution of both data and
knowledge (i.e., programs) over a network of autonomous peers communicating in an asyn-
chronous way. î€€e language supports updates, distribution, negation, and the novel feature of
delegation, that is, the ability for a peer to communicate a program to another peer.
î€€e following example illustrates the main aspects of the languageâ€”for a formal deï¬nition
we refer the reader to Abiteboul et al. [2011].
Example 8.3
[Abiteboul et al., 2011] Consider a relation birthday at a peer named myIphone
storing information on friendsâ€™ birthdays and how to wish them a happy birthday (i.e., on which
servers and with which messages). Facts of this kind can be express as follows:
birthday@myIphone.â€˜â€˜Alice;00 sendmail; inria:fr; 08=08/
birthday@myIphone.â€˜â€˜Bob;00 sms; BobIphone; 01=12/;
where, for instance, the ï¬rst fact says that Aliceâ€™s birthdays is August 8ï›³ï˜·and wishes should be
sent by email to server inria:fr.
A rule of the following form can be used to send birthday messages:
$message@$peer.$name; â€˜â€˜Happy birthdayâ€/ W  today@myIphone.$d/;
birthday@myIphone.$name; $message; $peer; $d/

8.4. PROGRAM ANALYSIS
131
An identiï¬er starting with the symbol $ is a variable. While the two facts above represent
pieces of local knowledge of myIphone, the fact
sendmail@inria:fr.Alice; â€˜â€˜Happy birthdayâ€/
describes a message that is sent from myIphone to inria:fr.
î€€e semantics of the global system is deï¬ned based on local semantics and the exchange
of messages and rules. Intuitively, a given peer chooses how to move to another state based on its
local state (a set of local facts and messages received from other peers) and its program. A move
consists in (1) consuming the local facts, (2) deriving new local facts, which deï¬ne the next state,
(3) deriving nonlocal facts, i.e., messages sent to other peers, and (4) modifying their programs
via â€œdelegations.â€
Example 8.3 showed the derivation of local facts and messages sent to other peers. î€€e
following example illustrates delegation, one of the main features of Webdamlog.
Example 8.4
[Abiteboul et al., 2011] Consider the following rule, installed at peer p:
at p W m@q./ W  m1@p.$x/; m2@p0.$x/:
Suppose that m1@p.a1/ holds, for some value a1. î€€en, the eï¬€ect of the rule is to install at p0
the following rule:
at p0 W m@q./ W  m2@p0.a1/:
î€€e action of installing a rule at some other peer is called delegation.
When p0 runs, if m2@p0.a1/ holds, it will send the message m@q./ to q. î€€e basic idea of
the delegation from p to p0 is that there is some knowledge from p0 that is needed to perform
the task speciï¬ed by the rule above. So, to perform that task, p delegates the remainder of the
rule to p0.
8.4
PROGRAM ANALYSIS
î€€e Doop framework has been proposed in Bravenboer and Smaragdakis [2009] for points-to
analysis of Java programs. Points-to analysis concerns the problem of determining which objects
a program variable can point to. î€€e approach of Bravenboer and Smaragdakis [2009] relies on
Datalog for specifying program analyses and proposes optimizations to speed-up such analyses.
Example 8.5
For the purpose of performing points-to analysis the following two base relations
can be used:
â€¢ a
binary
relation
AssignHeapAllocation
storing
facts
of
the
form
AssignHeapAllocation.v; o/, where v is a Java variable and o identiï¬es a heap object
(pointed to by v)â€”such facts can be derived from a Java program by introducing one
fact for each instruction a D new A./ in the Java program, that is, when a heap object is
allocated and assigned to a Java variable; and

132
8. APPLICATIONS
â€¢ a binary relation Assign storing facts of the form Assign.from; to/, where from and to are Java
variablesâ€”the Assign relation has one fact for each assignment between two Java (reference)
variables, that is, when a Java assignment to D from is found.
Given the AssignHeapAllocation and Assign relations of a given Java program, a simple
points-to analysis can be easily expressed in Datalog as follows:
varPointsTo.V; O/
 AssignHeapAllocation.V; O/:
varPointsTo.To; O/
 Assign.From; To/; varPointsTo.From; O/:
î€€e declarative nature of Datalog and its ability of expressing recursive relations makes
Datalog suitable for expressing complex program analysis algorithms. For instance, Example 8.5
showed how a simple points-to analysis can be succinctly expressed in Datalog leveraging recur-
sion.
As another example, recursion can be exploited to easily express a Datalog program check-
ing whether a method m1 is reachable from a method m2, provided that we have points-to infor-
mation, so that the target objects of a virtual method call are known.
8.5
MODULE COMPOSITION
A Datalog language for automatic service composition has been proposed in Albanese et al.
[2013]. Composition comes into play when a userâ€™s request cannot be fulï¬lled by a single software
module, but the composition of multiple modules can provide the requested services.
î€€e general framework of Albanese et al. [2013] allows users to express QoS and security
attributes associated with services and take them into account in the composition process. In ad-
dition, it is possible to express both hard and soft requirements for the QoS and security attributes
that should come with the requested services. î€€e adopted language is Datalog augmented with
disjunction, negation, strong and weak constraints [Buccafurri et al., 2000].
î€€e following example illustrates some of the basic features of the language.
Example 8.6
Suppose we are given a set of modules, where each of them provides services to
other modules and possibly requires services from other modules in order to deliver those oï¬€ered.
Modules and their required/provided services can be expressed by means of facts of the following
form.
â€¢ A fact module.m/ means that m is a module.
â€¢ A fact requires.m; r/ means that r is a service required by module m.
â€¢ A fact provides.m; p/ means that p is a service provided by module m.
â€¢ A fact of the form compatible.m1; p; m2; r/ means that service p provided by module m1
can fulï¬ll service r required by module m2. Facts of this kind can be computed by means of
Datalog rules expressing speciï¬c compatibility criteria.

8.5. MODULE COMPOSITION
133
î€€e following Datalog rules can be used to guess a set of modules and determine the services
that can be delivered through their composition:
taken.M/ _ not_taken.M/
 
module.M/:
fulï¬lled.M2; R/
 
taken.M2/; requires.M2; R/;
delivers.M1; P/; compatible.M1; P; M2; R/:
delivers.M; I/
 
taken.M/; provides.M; I/; :cannot_deliver.M/:
cannot_deliver.M/
 
requires.M; I/; :fulï¬lled.M; I/:
î€€e ï¬rst rule above is used to guess a subset of the available modules, say S. î€€e second rule
says that fulï¬lled.hM2; R/ is derived if R is a service required by module M2 and there is a module
M1 in S delivering a service P that fulï¬ls R. î€€e third rule allows us to derive delivers.M; I/ if
module M can deliver service I. î€€e fourth rule allows us to derive cannot_deliver.M/ if M is a
module whose provided services cannot be delivered because at least one of its required services
cannot be matched with a service delivered by a taken module.


135
Bibliography
Serge Abiteboul and Victor Vianu. Datalog extensions for database queries and updates. J. Comp.
and System Sci., 43(1):62â€“124, 1991. DOI: 10.1016/0022-0000(91)90032-Z. 59, 60
Serge Abiteboul, Richard Hull, and Victor Vianu. Foundations of Databases. Addison-Wesley,
1995. 11, 12, 13, 15, 26, 32, 38, 59, 126
Serge Abiteboul, ZoÃ« Abrams, Stefan Haar, and Tova Milo. Diagnosis of asynchronous discrete
event systems: datalog to the rescue! In Proc. 24th ACM SIGACT-SIGMOD-SIGART Symp.
on Principles of Database Systems, pages 358â€“367, 2005. DOI: 10.1145/1065167.1065214. 129
Serge Abiteboul, Meghyn Bienvenu, Alban Galland, and Emilien Antoine. A rule-based lan-
guage for web data management. In Proc. 30th ACM SIGACT-SIGMOD-SIGART Symp. on
Principles of Database Systems, pages 293â€“304, 2011. DOI: 10.1145/1989284.1989320. 130,
131
Foto N. Afrati and Stavros S. Cosmadakis. Expressiveness of restricted recursive queries (ex-
tended abstract). In Proc. 21st Annual ACM Symp. on îeory of Computing, pages 113â€“126,
1989. DOI: 10.1145/73007.73018. 110, 114
Foto N. Afrati and Christos H. Papadimitriou. î€€e parallel complexity of simple chain queries.
In Proc. 6th ACM SIGACT-SIGMOD-SIGART Symp. on Principles of Database Systems, pages
210â€“213, 1987. DOI: 10.1145/28659.28682. 126
Foto N. Afrati, Stavros S. Cosmadakis, and Mihalis Yannakakis. On datalog vs. polynomial time.
J. Comp. and System Sci., 51(2):177â€“196, 1995. DOI: 10.1006/jcss.1995.1060. 31, 33
Alfred V. Aho and Jeï¬€rey D. Ullman. î€€e universality of data retrieval languages. In Proc.
16th ACM SIGACT-SIGPLAN Symp. on Principles of Programming Languages, pages 110â€“120,
1979. DOI: 10.1145/567752.567763. 18, 31
Massimiliano Albanese, Sushil Jajodia, and Cristian Molinaro. A logic framework for ï¬‚exible
and security-aware service composition. In Proc. IEEE International Conference on Autonomic
and Trusted Computing, pages 337â€“346, 2013. DOI: 10.1109/UIC-ATC.2013.11. 132
Peter Alvaro, Tyson Condie, Neil Conway, Khaled Elmeleegy, Joseph M. Hellerstein, and
Russell Sears.
Boom analytics: exploring data-centric, declarative programming for the
cloud.
In Proc. European Conference on Computer Systems, pages 223â€“236, 2010. DOI:
10.1145/1755913.1755937. 129

136
BIBLIOGRAPHY
Mario Alviano, Wolfgang Faber, and Nicola Leone. Disjunctive asp with functions: Decidable
queries and eï¬€ective computation. îeory & Practice of Logic Program., 10(4-6):497â€“512, 2010.
DOI: 10.1017/S1471068410000244. 86
Mario Alviano, Francesco Calimeri, Wolfgang Faber, Nicola Leone, and Simona Perri. Un-
founded sets and well-founded semantics of answer set programs with aggregates. J. Artiï¬cial
Intel. Res., 42:487â€“527, 2011. DOI: 10.1613/jair.3432. 99
Mario Alviano, Wolfgang Faber, Gianluigi Greco, and Nicola Leone. Magic sets for disjunctive
datalog programs. Artiï¬cial Intell., 187:156â€“192, 2012. DOI: 10.1016/j.artint.2012.04.008.
127
Krzysztof R. Apt. Logic Programming, pages 493â€“574. Handbook of î€€eoretical Computer
Science. Elsevier, 1991. 15, 22
Krzysztof R. Apt and Maarten H. van Emden. Contributions to the theory of logic programming.
J. ACM, 29(3):841â€“862, 1982. DOI: 10.1145/322326.322339. 32
Krzysztof R. Apt, Howard A. Blair, and Adrian Walker. Towards a theory of declarative knowl-
edge. In Foundations of Deductive Databases and Logic Programming., pages 89â€“148. Morgan
Kaufmann, 1988. 36, 38
Molham Aref, Balder ten Cate, Todd J. Green, Benny Kimelfeld, Dan Olteanu, Emir Pasalic,
Todd L. Veldhuizen, and Geoï¬€rey Washburn. Design and implementation of the logicblox
system. In Proc. ACM SIGMOD Int. Conf. on Management of Data, pages 1371â€“1382, 2015.
DOI: 10.1145/2723372.2742796. 60
î€€omas Arts and JÃ¼rgen Giesl. Termination of term rewriting using dependency pairs. îeor.
Comp. Sci., 236(1-2):133â€“178, 2000. DOI: 10.1016/S0304-3975(99)00207-8. 86
Isaac Balbin and Kotagiri Ramamohanarao.
A generalization of the diï¬€erential approach to
recursive query evaluation.
J. Logic Program., 4(3):259â€“262, 1987. DOI: 10.1016/0743-
1066(87)90004-5. 32
Isaac Balbin, Graeme S. Port, Kotagiri Ramamohanarao, and Krishnamurthy Meenakshi. Eï¬ƒ-
cient bottom-up computation of queries on stratiï¬ed databases. J. Logic Program., 11(3&4):
295â€“344, 1991. DOI: 10.1016/0743-1066(91)90030-S. 107, 108
FranÃ§ois Bancilhon and Raghu Ramakrishnan. Performance evaluation of data intensive logic
programs. In Foundations of Deductive Databases and Logic Program. Morgan Kaufmann, 1988.
DOI: 10.1016/B978-0-934613-40-8.50016-6. 126
FranÃ§ois Bancilhon, David Maier, Yehoshua Sagiv, and Jeï¬€rey D. Ullman. Magic sets and other
strange ways to implement logic programs. In Proc. 5th ACM SIGACT-SIGMOD Symp. on

BIBLIOGRAPHY
137
Principles of Database Systems, pages 1â€“15, 1986. DOI: 10.1145/6012.15399. 101, 109, 110,
121, 126
FranÃ§ois Bancilhon and Raghu Ramakrishnan. An amateurâ€™s introduction to recursive query
processing strategies. In Proc. ACM SIGMOD Int. Conf. on Management of Data, pages 16â€“
52, 1986. DOI: 10.1145/16856.16859. 32, 126
Sabrina Baselice, Piero A. Bonatti, and Giovanni Criscuolo. On ï¬nitely recursive programs.
îeory & Practice of Logic Program., 9(2):213â€“238, 2009. DOI: 10.1017/S147106840900372X.
86
Catriel Beeri and Raghu Ramakrishnan. On the power of magic. In Proc. 6th ACM SIGACT-
SIGMOD-SIGART Symp. on Principles of Database Systems, pages 269â€“284, 1987. DOI:
10.1145/28659.28689. 126
Catriel Beeri and Raghu Ramakrishnan. On the power of magic. J. Logic Program., 10(3&4):
255â€“299, 1991. DOI: 10.1016/0743-1066(91)90038-Q. 101, 107, 108, 125, 126
Catriel Beeri, Paris C. Kanellakis, FranÃ§ois Bancilhon, and Raghu Ramakrishnan. Bounds on the
propagation of selection into logic programs. J. Comp. and System Sci., 41(2):157â€“180, 1990.
DOI: 10.1016/0022-0000(90)90035-J. 109, 110, 126
Andreas Behrend. Soft stratiï¬cation for magic set based query evaluation in deductive databases.
In Proc. 22nd ACM SIGACT-SIGMOD-SIGART Symp. on Principles of Database Systems, pages
102â€“110, 2003. DOI: 10.1145/773153.773164. 126
Nicole Bidoit and Richard Hull. Positivism vs. minimalism in deductive databases. In Proc. 5th
ACM SIGACT-SIGMOD Symp. on Principles of Database Systems, pages 123â€“132, 1986. DOI:
10.1145/6012.15409. 59
Piero A. Bonatti. Reasoning with inï¬nite stable models. Artiï¬cial Intell., 156(1):75â€“111, 2004.
DOI: 10.1016/j.artint.2004.02.001. 86
Martin Bravenboer and Yannis Smaragdakis. Strictly declarative speciï¬cation of sophisticated
points-to analyses. In Proc. 24th ACM SIGPLAN Conf. on Object-Oriented Programming Sys-
tems, Languages & Applications, pages 243â€“262, 2009. DOI: 10.1145/1639949.1640108. 129,
131
Maurice Bruynooghe, Michael Codish, John P. Gallagher, Samir Genaim, and Wim Vanhoof.
Termination analysis of logic programs through combination of type-based norms. ACM Trans.
Prog. Lang. and Syst., 29(2), 2007. DOI: 10.1145/1216374.1216378. 86
Francesco Buccafurri, Sergio Greco, and Domenico SaccÃ . î€€e expressive power of unique total
stable model semantics. In 24th Int. Colloquium on Automata, Languages, and Programming,
pages 849â€“859, 1997. DOI: 10.1007/3-540-63165-8_237. 59

138
BIBLIOGRAPHY
Francesco Buccafurri, Nicola Leone, and Pasquale Rullo. Enhancing disjunctive datalog by con-
straints. IEEE Trans. Knowl. and Data Eng., 12(5):845â€“860, 2000. DOI: 10.1109/69.877512.
132
Marco Cadoli and Luigi Palopoli. Circumscribing datalog: Expressive power and complexity.
îeor. Comp. Sci., 193(1-2):215â€“244, 1998. DOI: 10.1016/S0304-3975(97)00108-4. 59
M. Calautti, S. Greco, F. Spezzano, and I. Trubitsyna. Checking termination of bottom-up
evaluation of logic programs with function symbols. îeory & Practice of Logic Program., 2015a.
DOI: 10.1017/S1471068414000623. 86
Marco Calautti, Sergio Greco, and Irina Trubitsyna. Detecting decidable classes of ï¬nitely ground
logic programs with function symbols. In Proc. International Symposium on Principles and Prac-
tice of Declarative Programming, pages 239â€“250, 2013. DOI: 10.1145/2505879.2505883. 86
Marco Calautti, Sergio Greco, Cristian Molinaro, and Irina Trubitsyna. Checking termination
of logic programs with function symbols through linear constraints. In Proc. International Web
Rule Symposium, pages 97â€“111, 2014. DOI: 10.1007/978-3-319-09870-8_7. 86
Marco Calautti, Sergio Greco, Cristian Molinaro, and Irina Trubitsyna. Logic program termi-
nation analysis using atom sizes. In Proc. 24th Int. Joint Conf. on AI, pages 2833â€“2839, 2015b.
86
Marco Calautti, Sergio Greco, Cristian Molinaro, and Irina Trubitsyna. Checking termination
of datalog with function symbols through linear constraints. In Proc. 23rd Italian Symposium
on Advanced Database Systems, 2015c. 86
Marco Calautti, Sergio Greco, Cristian Molinaro, and Irina Trubitsyna. Using linear constraints
for logic program termination analysis. îeory & Practice of Logic Program., 2016. 86
Andrea CalÃ¬, Georg Gottlob, and î€€omas Lukasiewicz.
A general datalog-based frame-
work for tractable query answering over ontologies.
In Proc. 28th ACM SIGACT-
SIGMOD-SIGART Symp. on Principles of Database Systems, pages 77â€“86, 2009. DOI:
10.1016/j.websem.2012.03.001. 12
Andrea CalÃ¬, Georg Gottlob, and î€€omas Lukasiewicz. DatalogË™: a uniï¬ed approach to ontolo-
gies and integrity constraints. In Proc. 12th Int. Conf. on Database îeory, pages 14â€“30, 2009.
DOI: 10.1145/1514894.1514897. 12
Francesco Calimeri, Susanna Cozza, Giovambattista Ianni, and Nicola Leone. Computable func-
tions in asp: î€€eory and implementation. In Proc. 24th Int. Conf. Logic Programming, pages
407â€“424, 2008. DOI: 10.1007/978-3-540-89982-2_37. 64, 86

BIBLIOGRAPHY
139
Francesco Calimeri, Susanna Cozza, Giovambattista Ianni, and Nicola Leone. Enhancing ASP
by functions: Decidable classes and implementation techniques. In Proc. 24th National Conf.
on Artiï¬cial Intelligence, 2010. 86
Luciano Caroprese, Cristian Molinaro, and Ester Zumpano. Integrating and querying P2P de-
ductive databases. In Proc. 10th International Database Engineering and Applications Symposium
(IDEAS), pages 285â€“290, 2006. DOI: 10.1109/IDEAS.2006.28. 129
Stefano Ceri, Georg Gottlob, and Letizia Tanca. What you always wanted to know about datalog
(and never dared to ask). IEEE Trans. Knowl. and Data Eng., 1(1):146â€“166, 1989. DOI:
10.1109/69.43410. 126
Stefano Ceri, Georg Gottlob, and Letizia Tanca. Logic Programming and Databases. Springer,
1990. DOI: 10.1007/978-3-642-83952-8. 32
Ashok K. Chandra and David Harel. Structure and complexity of relational queries. J. Comp.
and System Sci., 25(1):99â€“128, 1982. DOI: 10.1016/0022-0000(82)90012-5. 32
Ashok K. Chandra and David Harel. Horn clauses queries and generalizations. J. Logic Program.,
2(1):1â€“15, 1985. DOI: 10.1016/0743-1066(85)90002-0. 36
Ashok K. Chandra and Philip M. Merlin. Optimal implementation of conjunctive queries in
relational data bases. In Proc. 9th Annual ACM Symp. on îeory of Computing, pages 77â€“90,
1977. DOI: 10.1145/800105.803397. 12
Peter Cholak and Howard A. Blair. î€€e complexity of local stratiï¬cation. Fundam. Inform., 21
(4):333â€“344, 1994. DOI: 10.3233/FI-1994-2144. 59
E. F. Codd. Relational completeness of data base sublanguages. In: R. Rustin (ed.): Database
Systems: 65-98, Prentice Hall and IBM Research Report RJ 987, San Jose, California, 1972.
15
Edgar F. Codd. A relational model of data for large shared data banks. Commun. ACM, 13(6):
377â€“387, 1970. DOI: 10.1145/362384.362685. 3, 15
Michael Codish, Vitaly Lagoon, and Peter J. Stuckey.
Testing for termination with mono-
tonicity constraints. In Proc. 21st Int. Conf. Logic Programming, pages 326â€“340, 2005. DOI:
10.1007/11562931_25. 86
Mariano P. Consens and Alberto O. Mendelzon. Low complexity aggregation in graphlog and
datalog. In Proc. 3rd Int. Conf. on Database îeory, pages 379â€“394, 1990. DOI: 10.1007/3-
540-53507-1_90. 99
Chiara Cumbo, Wolfgang Faber, Gianluigi Greco, and Nicola Leone. Enhancing the magic-set
method for disjunctive datalog programs. In Proc. 20th Int. Conf. Logic Programming, pages
371â€“385, 2004. DOI: 10.1007/978-3-540-27775-0_26. 126

140
BIBLIOGRAPHY
Evgeny Dantsin, î€€omas Eiter, Georg Gottlob, and Andrei Voronkov. Complexity and expressive
power of logic programming. In IEEE Conference on Computational Complexity, pages 82â€“101,
1997. DOI: 10.1109/CCC.1997.612304. 32
Evgeny Dantsin, î€€omas Eiter, Georg Gottlob, and Andrei Voronkov.
Complexity and ex-
pressive power of logic programming.
ACM Comput. Surv., 33(3):374â€“425, 2001. DOI:
10.1145/502807.502810. 32, 43, 47, 59
Chris J. Date. An Introduction to Database Systems (7th ed.). Addison-Wesley-Longman, 2000.
15
Danny De Schreye and Stefaan Decorte. Termination of logic programs: î€€e never-ending story.
J. Logic Program., 19/20:199â€“260, 1994. DOI: 10.1016/0743-1066(94)90027-2. 86
John DeTreville. Binder, a logic-based security language. In Proc. IEEE Symposium on Security
and Privacy, pages 105â€“113, 2002. DOI: 10.1109/SECPRI.2002.1004365. 129
Alin Deutsch, Alan Nash, and Jeï¬€rey B. Remmel. î€€e chase revisited. In Proc. 27th ACM
SIGACT-SIGMOD-SIGART Symp. on Principles of Database Systems, pages 149â€“158, 2008.
DOI: 10.1145/1376916.1376938. 86
Suzanne W. Dietrich. Shortest path by approximation in logic programs. ACM Lett. on Program.
Lang. and Syst., 1(2):119â€“137, 1992. DOI: 10.1145/151333.151377. 99
Guozhu Dong. Datalog expressiveness of chain queries: Grammar tools and characterizations.
In Proc. 11th ACM SIGACT-SIGMOD-SIGART Symp. on Principles of Database Systems, pages
81â€“90, 1992a. DOI: 10.1145/137097.137113. 126
Guozhu Dong. On datalog linearization of chain queries. In îeoretical Studies in Computer
Science, pages 181â€“206, 1992b. 109, 110, 126
Sergey Dudakov. On the complexity of perfect models of logic programs. Fundam. Inform., 39
(3):249â€“258, 1999. DOI: 10.3233/FI-1999-39302. 59
î€€omas Eiter, Georg Gottlob, and Heikki Mannila. Disjunctive datalog. ACM Trans. Database
Syst., 22(3):364â€“418, 1997a. DOI: 10.1145/261124.261126. 59, 60
î€€omas Eiter, Nicola Leone, and Domenico SaccÃ .
On the partial semantics for disjunc-
tive deductive databases.
Ann. of Math. and Artiï¬cial Intell., 19(1-2):59â€“96, 1997b. DOI:
10.1023/A:1018947420290. 59
î€€omas Eiter, Nicola Leone, and Domenico SaccÃ . Expressive power and complexity of partial
models for disjunctive deductive databases. îeor. Comp. Sci., 206(1-2):181â€“218, 1998. DOI:
10.1016/S0304-3975(97)00129-1. 59

BIBLIOGRAPHY
141
Ramez Elmasri and Shamkant B. Navathe. Fundamentals of Database Systems, 3rd ed. Addison-
Wesley-Longman, 2000. 15
JÃ¶rg Endrullis, Johannes Waldmann, and Hans Zantema.
Matrix interpretations for prov-
ing termination of term rewriting.
J. of Automated Reason., 40(2-3):195â€“220, 2008. DOI:
10.1007/s10817-007-9087-9. 86
Wolfgang Faber, Gianluigi Greco, and Nicola Leone. Magic sets and their application to data
integration. J. Comp. and System Sci., 73(4):584â€“609, 2007. DOI: 10.1016/j.jcss.2006.10.012.
126
Wolfgang Faber, Gerald Pfeifer, and Nicola Leone.
Semantics and complexity of recur-
sive aggregates in answer set programming.
Artiï¬cial Intell., 175(1):278â€“298, 2011. DOI:
10.1016/j.artint.2010.04.002. 99
Ronald Fagin, Phokion G. Kolaitis, RenÃ©e J. Miller, and Lucian Popa. Data exchange: semantics
and query answering. îeor. Comp. Sci., 336(1):89â€“124, 2005. DOI: 10.1016/j.tcs.2004.10.033.
12, 86
Maria C. F. Ferreira and Hans Zantema. Total termination of term rewriting. Applic. Algebra in
Eng., Commun. and Comput., 7(2):133â€“162, 1996. DOI: 10.1007/BF01191381. 86
Amelia C. Fong and Jeï¬€rey D. Ullman. Induction variables in very high level languages. In Proc.
3rd ACM SIGACT-SIGPLAN Symp. on Principles of Programming Languages, pages 104â€“112,
1976. DOI: 10.1145/800168.811544. 32
Filippo Furfaro, Sergio Greco, and Cristian Molinaro. A three-valued semantics for querying and
repairing inconsistent databases. Ann. of Math. and Artiï¬cial Intell., 51(2-4):167â€“193, 2007.
DOI: 10.1007/s10472-008-9088-3. 59
HervÃ© Gallaire and Jack Minker, editors. Logic and Data Bases, Symposium on Logic and Data
Bases, Centre dâ€™Ã©tudes et de recherches de Toulouse, 1977, Advances in Data Base î€€eory, 1978.
Plemum Press. 32
HervÃ© Gallaire, Jack Minker, and Jean-Marie Nicolas. Logic and databases: A deductive ap-
proach. ACM Comput. Surv., 16(2):153â€“185, 1984. DOI: 10.1145/356924.356929. 32
Sumit Ganguly, Sergio Greco, and Carlo Zaniolo. Minimum and maximum predicates in logic
programming. In Proc. 10th ACM SIGACT-SIGMOD-SIGART Symp. on Principles of Database
Systems, pages 154â€“163, 1991. DOI: 10.1145/113413.113427. 97, 99
Hector Garcia-Molina, Jeï¬€rey D. Ullman, and Jennifer Widom. Database Systems - îe Complete
Book (2nd ed.). Pearson Education, 2009. 15

142
BIBLIOGRAPHY
Martin Gebser, Torsten Schaub, and Sven î€€iele. Gringo: A new grounder for answer set pro-
gramming. In Proc. 9th Int. Conf. Logic Programming and Nonmonotonic Reasoning, pages 266â€“
271, 2007. DOI: 10.1007/978-3-540-72200-7_24. 63, 86
Martin Gebser, Benjamin Kaufmann, and Torsten Schaub.
Conï¬‚ict-driven answer
set solving: From theory to practice.
Artiï¬cial Intell., 187-188:52â€“89, 2012. DOI:
10.1016/j.artint.2012.04.001. 60
Allen Van Gelder. Foundations of aggregation in deductive databases. In Proc. 3rd Int. Conf.
on Deductive and Object-Oriented Databases, pages 13â€“34, 1993. DOI: 10.1007/3-540-57530-
8_2. 99
Michael Gelfond and Vladimir Lifschitz. î€€e stable model semantics for logic programming. In
Proc. 5th Int. Conf. Logic Programming, pages 1070â€“1080, 1988. 41
Michael Gelfond and Vladimir Lifschitz. Classical negation in logic programs and disjunctive
databases. New Generation Comput., 9(3/4):365â€“386, 1991. DOI: 10.1007/BF03037169. 59
Fosca Giannotti and Dino Pedreschi. Datalog with non-deterministic choice computers ndb-
ptime. J. Logic Program., 35(1):79â€“101, 1998. DOI: 10.1016/S0743-1066(97)10004-8. 60
Fosca Giannotti, Dino Pedreschi, Domenico SaccÃ , and Carlo Zaniolo. Non-determinism in
deductive databases. In Proc. 2nd Int. Conf. on Deductive and Object-Oriented Databases, pages
129â€“146, 1991. DOI: 10.1007/3-540-55015-1_7. 47, 53, 54, 55, 60
Fosca Giannotti, Dino Pedreschi, and Carlo Zaniolo. Semantics and expressive power of nonde-
terministic constructs in deductive databases. J. Comp. and Syst. Sci., 62(1):15â€“42, 2001. DOI:
10.1006/jcss.1999.1699. 47, 50, 60
Georg Gottlob, Christoph Koch, Robert Baumgartner, Marcus Herzog, and Sergio Flesca. î€€e
lixto data extraction project - back and forth between theory and practice. In Proc. 23rd ACM
SIGACT-SIGMOD-SIGART Symp. on Principles of Database Systems, pages 1â€“12, 2004. DOI:
10.1145/1055558.1055560. 129
Bernardo Cuenca Grau, Ian Horrocks, Markus KrÃ¶tzsch, Clemens Kupke, Despoina Magka,
Boris Motik, and Zhe Wang.
Acyclicity notions for existential rules and their applica-
tion to query answering in ontologies.
J. Artiï¬cial Intell. Res., 47:741â€“808, 2013. DOI:
10.1613/jair.3949. 86
Gianluigi Greco, Sergio Greco, Irina Trubitsyna, and Ester Zumpano. Optimization of bound
disjunctive queries with constraints. îeory & Practice of Logic Program., 5(6):713â€“745, 2005.
DOI: 10.1017/S1471068404002273. 127

BIBLIOGRAPHY
143
Sergio Greco.
Extending datalog with choice and weak constraints.
In Proc. Joint
Conf. on Declarative Programming, APPIA-GULP-PRODE, pages 329â€“340, 1996. DOI:
10.1007/BF03037430. 60
Sergio Greco. Non-determinism and weak constraints in datalog. New Generation Comput., 16
(4):373â€“396, 1998a. DOI: 10.1007/BF03037430. 60
Sergio Greco. Binding propagation in disjunctive databases. In Proc. 24th Int. Conf. on Very Large
Data Bases, pages 287â€“298, 1998b. DOI: 10.1109/TKDE.2003.1185840. 127
Sergio Greco. Dynamic programming in datalog with aggregates. IEEE Trans. Knowl. and Data
Eng., 11(2):265â€“283, 1999a. DOI: 10.1109/69.761663. 89, 90, 91, 97, 98
Sergio Greco. Optimization of disjunctive queries. In Proc. 16th Int. Conf. Logic Programming,
pages 441â€“455, 1999b. DOI: 10.1109/69.842265. 127
Sergio Greco.
Binding propagation techniques for the optimization of bound disjunc-
tive queries.
IEEE Trans. on Knowl. and Data Eng., 15(2):368â€“385, 2003. DOI:
10.1109/TKDE.2003.1185840. 127
Sergio Greco and Domenico SaccÃ .
î€€e expressive power of â€possible-is-certainâ€ semantics
(extended abstract). In Proc. Asian Computing Science Conference, pages 33â€“42, 1996. DOI:
10.1007/BFb0027777. 59
Sergio Greco and Domenico SaccÃ . Deterministic semantics for datalog:: Complexity and ex-
pressive power. In Proc. 5th Int. Conf. on Deductive and Object-Oriented Databases, pages 337â€“
350, 1997a. DOI: 10.1007/3-540-63792-3_24. 60
Sergio Greco and Domenico SaccÃ . â€œpossible is certainâ€ is desirable and can be expressive. Ann.
of Math. and Artiï¬cial Intell., 19(1-2):147â€“168, 1997b. DOI: 10.1023/A:1018903705269. 60
Sergio Greco and Domenico SaccÃ . Complexity and expressive power of deterministic semantics
for datalog:. Inform. and Comput., 153(1):81â€“98, 1999. DOI: 10.1006/inco.1999.2800. 60
Sergio Greco and Francesca Spezzano. Chase termination: A constraints rewriting approach.
Proc. VLDB Endowment, 3(1):93â€“104, 2010. DOI: 10.14778/1920841.1920858. 86
Sergio Greco and Carlo Zaniolo. Optimization of linear logic programs using counting methods.
In Advances in Database Technology, Proc. 3rd Int. Conf. on Extending Database Technology, pages
72â€“87, 1992. DOI: 10.1007/BFb0032424. 115, 126
Sergio Greco and Carlo Zaniolo. Eï¬ƒcient execution of recursive queries through controlled
binding propagation. In Proc. 8th Int. Symposium on Methodologies for Intelligent Systems, pages
193â€“202, 1994. DOI: 10.1007/3-540-58495-1_20. 126

144
BIBLIOGRAPHY
Sergio Greco and Carlo Zaniolo. Greedy algorithms in datalog with choice and negation. In
Proc. 15th Int. Conf. Logic Programming, pages 294â€“309, 1998. 54, 57
Sergio Greco and Carlo Zaniolo. Greedy algorithms in datalog. îeory & Practice of Logic Pro-
gram., 1(4):381â€“407, 2001. DOI: 10.1017/S1471068401001090. 48, 54
Sergio Greco, Carlo Zaniolo, and Sumit Ganguly.
Greedy by choice.
In Proc. 11th ACM
SIGACT-SIGMOD-SIGART Symp. on Principles of Database Systems, pages 105â€“113, 1992.
DOI: 10.1145/137097.137836. 54
Sergio Greco, Domenico SaccÃ , and Carlo Zaniolo. Datalog queries with stratiï¬ed negation and
choice: from p to dp. In Proc. 5th Int. Conf. on Database îeory, pages 82â€“96, 1995. DOI:
10.1007/3-540-58907-4_8. 60, 109
Sergio Greco, Carlo Zaniolo, and Sumit Ganguly. Optimization of logic queries with MIN and
MAX predicates. In Proc. 3rd Int. Conf. Flexible Query Answering Systems, pages 188â€“202,
1998. DOI: 10.1007/BFb0056001. 97
Sergio Greco, Domenico SaccÃ , and Carlo Zaniolo.
Grammars and automata to op-
timize chain logic queries.
Int. J. Found. Comput. Sci., 10(3):349â€“372, 1999. DOI:
10.1142/S0129054199000253. 109, 115, 116, 117, 119, 120, 124
Sergio Greco, Domenico SaccÃ , and Carlo Zaniolo.
Extending stratiï¬ed datalog to capture
complexity classes ranging from p to qh.
Acta Informatica, 37(10):699â€“725, 2001. DOI:
10.1007/PL00013306. 60
Sergio Greco, Cristian Molinaro, and Irina Trubitsyna. Implementation and experimentation
of the logic language NP datalog. In Proc. 17th Int. Conf. on Database and Expert Systems
Applications, pages 622â€“633, 2006. DOI: 10.1007/11827405_61. 60
Sergio Greco, Cristian Molinaro, Irina Trubitsyna, and Ester Zumpano. NP datalog: A logic
language for expressing search and optimization problems. îeory & Practice of Logic Program.,
10(2):125â€“166, 2010. DOI: 10.1017/S1471068409990251. 60
Sergio Greco, Francesca Spezzano, and Irina Trubitsyna. Stratiï¬cation criteria and rewriting
techniques for checking chase termination. Proc. VLDB Endowment, 4(11):1158â€“1168, 2011.
DOI: 10.1109/TKDE.2014.2339816. 86
Sergio Greco, Cristian Molinaro, and Francesca Spezzano. Incomplete Data and Data Dependen-
cies in Relational Databases. Synthesis Lectures on Data Management. Morgan & Claypool
Publishers, 2012a. DOI: 10.2200/S00435ED1V01Y201207DTM029. 12, 13, 86
Sergio Greco, Francesca Spezzano, and Irina Trubitsyna. On the termination of logic programs
with function symbols. In Proc. 28th Int. Conf. Logic Programming, pages 323â€“333, 2012b.
DOI: 10.4230/LIPIcs.ICLP.2012.323. 66, 68, 74, 86

BIBLIOGRAPHY
145
Sergio Greco, Cristian Molinaro, and Irina Trubitsyna. Bounded programs: A new decidable class
of logic programs with function symbols. In Proc. 23rd Int. Joint Conf. on AI, pages 926â€“932,
2013a. 70, 75, 86
Sergio Greco, Cristian Molinaro, and Irina Trubitsyna. Logic programming with function sym-
bols: Checking termination of bottom-up evaluation through program adornments. îeory &
Practice of Logic Program., 13(4-5):737â€“752, 2013b. DOI: 10.1017/S147106841300046X. 76,
84
Todd J. Green, Shan Shan Huang, Boon î€€au Loo, and Wenchao Zhou.
Datalog and
recursive query processing.
Found. and Trends in Databases, 5(2):105â€“195, 2013. DOI:
10.1561/1900000017. 126
Ramsey W. Haddad and Jeï¬€rey F. Naughton. A counting algorithm for a cyclic binary query. J.
Comp. and System Sci., 43(1):145â€“169, 1991. DOI: 10.1016/0022-0000(91)90034-3. 110
John E. Hopcroft and Jeï¬€rey D. Ullman. Introduction to Automata îeory, Languages and Com-
putation. Addison-Wesley, 1979. 112, 115
Shan Shan Huang, Todd Jeï¬€rey Green, and Boon î€€au Loo. Datalog and emerging applications:
an interactive tutorial. In Proc. ACM SIGMOD Int. Conf. on Management of Data, pages 1213â€“
1216, 2011. DOI: 10.1145/1989323.1989456. 129
Yannis E. Ioannidis. Commutativity and its role in the processing of linear recursion. J. Logic
Program., 14(3&4):223â€“252, 1992. DOI: 10.1016/0743-1066(92)90012-R. 110
Yannis E. Ioannidis and Eugene Wong. Transforming nonlinear recursion into linear recursion.
In Expert Database Conf., pages 401â€“421, 1988. 110
David S. Johnson. A catalog of complexity classes. In Handbook of îeoretical Computer Science,
Volume A: Algorithms and Complexity (A), pages 67â€“161. 1990. 14, 15
David B. Kemp and Kotagiri Ramamohanarao. Eï¬ƒcient recursive aggregation and negation
in deductive databases.
IEEE Trans. Knowl. and Data Eng., 10(5):727â€“745, 1998. DOI:
10.1109/69.729729. 99
David B. Kemp and Peter J. Stuckey. Semantics of logic programs with aggregates. In Interna-
tional Symposium on Logic Programming, pages 387â€“401, 1991. 98
Michael Kifer, Raghu Ramakrishnan, and Abraham Silberschatz. An axiomatic approach to
deciding query safety in deductive databases. In Proc. 7th ACM SIGACT-SIGMOD-SIGART
Symp. on Principles of Database Systems, pages 52â€“60, 1988. DOI: 10.1145/308386.308412. 32
Phokion G. Kolaitis. î€€e expressive power of stratiï¬ed programs. Inform. and Comput., 90(1):
50â€“66, 1991. DOI: 10.1016/0890-5401(91)90059-B. 60

146
BIBLIOGRAPHY
Phokion G. Kolaitis and Christos H. Papadimitriou. Why not negation by ï¬xpoint? J. Comp.
and Syst. Sci., 43(1):125â€“144, 1991. DOI: 10.1016/0022-0000(91)90033-2. 43, 59
Phokion G. Kolaitis and Moshe Y. Vardi. On the expressive power of datalog: Tools and a case
study. J. Comp. and Syst. Sci., 51(1):110â€“134, 1995. DOI: 10.1006/jcss.1995.1055. 60
Robert Kowalski.
Logic for Problem-solving.
North-Holland Publishing Co., 1986. DOI:
10.1145/1005937.1005947. 32
Robert A. Kowalski. Predicate logic as programming language. In IFIP Congress, pages 569â€“574,
1974. 32
Ravi Krishnamurthy and Shamim A. Naqvi. Non-deterministic choice in datalog. In Proc. 3rd
International Conference on Data and Knowledge Bases, pages 416â€“424, 1988. 47, 60
Ravi Krishnamurthy, Raghu Ramakrishnan, and Oded Shmueli. A framework for testing safety
and eï¬€ective computability of extended datalog (extended abstract). In Proc. ACM SIGMOD
Int. Conf. on Management of Data, pages 154â€“163, 1988. DOI: 10.1145/971701.50219. 32
Markus KrÃ¶tzsch and Sebastian Rudolph.
Extending decidable existential rules by joining
acyclicity and guardedness. In Proc. 22nd Int. Joint Conf. on AI, pages 963â€“968, 2011. DOI:
10.5591/978-1-57735-516-8/IJCAI11-166. 86
Bernard Lang. Datalog automata. In Proc. 3rd International Conference on Data and Knowledge
Bases, pages 389â€“404, 1988. 126
Maurizio Lenzerini. Data integration: A theoretical perspective. In Proc. 21st ACM SIGACT-
SIGMOD-SIGART Symp. on Principles of Database Systems, pages 233â€“246, 2002. DOI:
10.1145/543613.543644. 12
Nicola Leone, Gerald Pfeifer, Wolfgang Faber, î€€omas Eiter, Georg Gottlob, Simona Perri, and
Francesco Scarcello. î€€e dlv system for knowledge representation and reasoning. ACM Trans.
Comput. Log. DOI: 10.1145/1149114.1149117. 60
Yuliya Lierler and Vladimir Lifschitz. One more decidable class of ï¬nitely ground programs. In
International Conference on Logic Programming, pages 489â€“493, 2009. DOI: 10.1007/978-3-
642-02846-5_40. 66, 86
Vladimir Lifschitz. On the declarative semantics of logic programs with negation. In Foundations
of Deductive Databases and Logic Programming., pages 177â€“192. Morgan Kaufmann, 1988. 36
John W. Lloyd.
Foundations of Logic Programming, 2nd ed.
Springer-Verlag, 1987. DOI:
10.1007/978-3-642-83189-8. 15, 22
Jorge Lobo, Jack Minker, and Arcot Rajasekar. Foundations of Disjunctive Logic Programming.
Logic Programming. MIT Press, 1992. 60

BIBLIOGRAPHY
147
Boon î€€au Loo, Tyson Condie, Joseph M. Hellerstein, Petros Maniatis, Timothy Roscoe, and
Ion Stoica. Implementing declarative overlays. In Proc. 20th ACM Symp. on Operating System
Principles, pages 75â€“90, 2005a. DOI: 10.1145/1095809.1095818. 129
Boon î€€au Loo, Joseph M. Hellerstein, Ion Stoica, and Raghu Ramakrishnan. Declarative rout-
ing: extensible routing with declarative queries.
In Proc. 2005 Conf. on Applications, Tech-
nologies, Architectures, and Protocols for Computer Communication, pages 289â€“300, 2005b. DOI:
10.1145/1080091.1080126. 129
Boon î€€au Loo, Tyson Condie, Minos N. Garofalakis, David E. Gay, Joseph M. Hellerstein,
Petros Maniatis, Raghu Ramakrishnan, Timothy Roscoe, and Ion Stoica. Declarative network-
ing: language, execution and optimization. In Proc. ACM SIGMOD Int. Conf. on Management
of Data, 2006. DOI: 10.1145/1142473.1142485. 129, 130
David Maier. îe îeory of Relational Databases. Computer Science Press, 1983. 15
Alberto Marchetti-Spaccamela, Antonella Pelaggi, and Domenico SaccÃ . Comparison of meth-
ods for logic-query implementation.
J. Logic Program., 10(3&4):333â€“360, 1991. DOI:
10.1016/0743-1066(91)90040-V. 110
Massimo Marchiori. Proving existential termination of normal logic programs. In Algebraic
Methodology and Software Technology, pages 375â€“390, 1996. DOI: 10.1007/BFb0014328. 86
William R. Marczak, Shan Shan Huang, Martin Bravenboer, Micah Sherr, Boon î€€au Loo, and
Molham Aref. Secureblox: customizable secure distributed data processing. In Proc. ACM
SIGMOD Int. Conf. on Management of Data, 2010. DOI: 10.1145/1807167.1807246. 129,
130
V. Wiktor Marek and Miroslaw Truszczynski. Autoepistemic logic. J. ACM, 38(3):588â€“619,
1991. DOI: 10.1145/116825.116836. 43, 54
Bruno Marnette.
Generalized schema-mappings: from termination to tractability.
In Proc.
28th ACM SIGACT-SIGMOD-SIGART Symp. on Principles of Database Systems, pages 13â€“22,
2009a. DOI: 10.1145/1559795.1559799. 87
Bruno Marnette.
Generalized schema-mappings: from termination to tractability.
In Proc.
28th ACM SIGACT-SIGMOD-SIGART Symp. on Principles of Database Systems, pages 13â€“22,
2009b. DOI: 10.1145/1559795.1559799. 86
Mirjana Mazuran, Edoardo Serra, and Carlo Zaniolo. A declarative extension of horn clauses,
and its signiï¬cance for datalog and its applications. îeory & Practice of Logic Program., 13
(4-5):609â€“623, 2013. DOI: 10.1017/S1471068413000380. 60
Michael Meier. On the Termination of the Chase Algorithm. Albert-Ludwigs-Universitat Freiburg
(Germany), 2010. 87

148
BIBLIOGRAPHY
Michael Meier, Michael Schmidt, and Georg Lausen. On chase termination beyond stratiï¬ca-
tion. Proc. VLDB Endowment, 2(1):970â€“981, 2009. DOI: 10.14778/1687627.1687737. 86
Jack Minker, editor. Foundations of Deductive Databases and Logic Programming. Morgan Kauf-
mann, 1988. 32
Jack Minker. Overview of disjunctive logic programming. Ann. of Math. and Artiï¬cial Intell., 12
(1-2):1â€“24, 1994. DOI: 10.1007/BF01530759. 60
Jack Minker and Dietmar Seipel. Disjunctive logic programming: A survey and assessment. In
Computational Logic: Logic Programming and Beyond, Essays in Honour of Robert A. Kowalski,
Part I, pages 472â€“511, 2002. DOI: 10.1007/3-540-45628-7_18. 60
Jack Minker, Dietmar Seipel, and Carlo Zaniolo. Logic and databases: A history of deductive
databases. In Computational Logic, pages 571â€“627. 2014. DOI: 10.1016/B978-0-444-51624-
4.50013-7. 32
Inderpal Singh Mumick and Oded Shmueli. How expressive is statiï¬ed aggregation? Ann. of
Math. and Artiï¬cial Intell., 15(3-4):407â€“434, 1995. DOI: 10.1007/BF01536403. 99
Inderpal Singh Mumick, Hamid Pirahesh, and Raghu Ramakrishnan. î€€e magic of duplicates
and aggregates. In Proc. 16th Int. Conf. on Very Large Data Bases, pages 264â€“277, 1990. 90, 98
Shamim A. Naqvi and Shalom Tsur. A Logical Language for Data and Knowledge Bases. Computer
Science Press, 1989. 47
Jeï¬€rey F. Naughton, Raghu Ramakrishnan, Yehoshua Sagiv, and Jeï¬€rey D. Ullman. Argument
reduction by factoring. In Proc. 15th Int. Conf. on Very Large Data Bases, pages 173â€“182, 1989a.
DOI: 10.1016/0304-3975(94)00186-M. 110, 126
Jeï¬€rey F. Naughton, Raghu Ramakrishnan, Yehoshua Sagiv, and Jeï¬€rey D. Ullman. Eï¬ƒcient
evaluation of right-, left-, and mult-linear rules. In Proc. ACM SIGMOD Int. Conf. on Man-
agement of Data, pages 235â€“242, 1989b. DOI: 10.1145/66926.66948. 109, 110, 126
Manh î€€ang Nguyen, JÃ¼rgen Giesl, Peter Schneider-Kamp, and Danny De Schreye. Termination
analysis of logic programs based on dependency graphs. In Proc. International Symposium on
Logic-based Program Synthesis and Transformation, pages 8â€“22, 2007. DOI: 10.1007/978-3-
540-78769-3_2. 86
Naoki Nishida and GermÃ¡n Vidal. Termination of narrowing via termination of rewriting. Applic.
Algebra in Eng., Commun. and Comput., 21(3):177â€“225, 2010. DOI: 10.1007/s00200-010-
0122-4. 86
Enno Ohlebusch. Termination of logic programs: Transformational methods revisited. Applic. Al-
gebra in Eng., Communic. and Comput., 12(1/2):73â€“116, 2001. DOI: 10.1007/s002000100064.
86

BIBLIOGRAPHY
149
Adrian Onet. î€€e chase procedure and its applications in data exchange. In Data Exchange,
Integration, and Streams, pages 1â€“37. 2013. DOI: 10.4230/DFU.Vol5.10452.1. 87
Mauricio Osorio and Bharat Jayaraman. Aggregation and negation-as-failure. New Generation
Comput., 17(3):255â€“284, 1999. DOI: 10.1007/BF03037222. 99
Robert Paige and Jacob T. Schwartz. Reduction in strength of high level operations. In Proc. 4th
ACM SIGACT-SIGPLAN Symp. on Principles of Programming Languages, pages 58â€“71, 1977.
32
Luigi Palopoli. Testing logic programs for local stratiï¬cation. îeor. Comp. Sci., 103(2):205â€“234,
1992. DOI: 10.1016/0304-3975(92)90013-6. 60
Christos H. Papadimitriou. Computational Complexity. Addison-Wesley, 1994. ISBN 978-0-
201-53082-7. 14, 15
Christos H. Papadimitriou and Kenneth Steiglitz. Combinatorial Optimization: Algorithms and
Complexity. Prentice-Hall, 1982. 57
Nikolay Pelov, Marc Denecker, and Maurice Bruynooghe. Well-founded and stable semantics
of logic programs with aggregates. îeory & Practice of Logic Program., 7(3):301â€“353, 2007.
DOI: 10.1017/S1471068406002973. 99
Fernando C. N. Pereira and David H. D. Warren. Deï¬nite clause grammars for language analysis
- a survey of the formalism and a comparison with augmented transition networks. Artiï¬cial
Intell., 13(3):231â€“278, 1980. DOI: 10.1016/0004-3702(80)90003-X. 126
Halina Przymusinska and Teodor C. Przymusinski. Weakly perfect model semantics for logic
programs. In Proc. 5th Int. Conf. Logic Programming, pages 1106â€“1120, 1988. 59
Teodor C. Przymusinski. On the declarative semantics of deductive databases and logic pro-
grams. In Foundations of Deductive Databases and Logic Programming, pages 193â€“216. Morgan
Kaufmann, 1988. 39, 41, 59
Teodor C. Przymusinski. On the declarative and procedural semantics of logic programs. J.
Autom. Reasoning, 5(2):167â€“205, 1989. DOI: 10.1007/BF00243002. 41
Teodor C. Przymusinski. Stable semantics for disjunctive programs. New Generation Comput., 9
(3/4):401â€“424, 1991. DOI: 10.1007/BF03037171. 59
Raghu Ramakrishnan and Johannes Gehrke. Database Management Systems (3rd ed.). McGraw-
Hill, 2003. 15
Raghu Ramakrishnan, FranÃ§ois Bancilhon, and Abraham Silberschatz. Safety of recursive horn
clauses with inï¬nite relations. In Proc. 6th ACM SIGACT-SIGMOD-SIGART Symp. on Prin-
ciples of Database Systems, pages 328â€“339, 1987. DOI: 10.1145/28659.28694. 32

150
BIBLIOGRAPHY
Raghu Ramakrishnan, Yehoshua Sagiv, Jeï¬€rey D. Ullman, and Moshe Y. Vardi. Proof-tree trans-
formation theorems and their applications. In Proc. 8th ACM SIGACT-SIGMOD-SIGART
Symp. on Principles of Database Systems, pages 172â€“181, 1989. DOI: 10.1145/73721.73739.
126
Raghu Ramakrishnan, Divesh Srivastava, and S. Sudarshan. CORAL - control, relations and
logic. In Proc. 18th Int. Conf. on Very Large Data Bases, pages 238â€“250, 1992. 99
Raghu Ramakrishnan, Kenneth A. Ross, Divesh Srivastava, and S. Sudarshan. Eï¬ƒcient incre-
mental evaluation of queries with aggregation. In International Symposium on Logic Program-
ming, pages 204â€“218, 1994. 99
Fabrizio Riguzzi and Terrance Swift. Terminating evaluation of logic programs with ï¬nite three-
valued models. ACM Trans. Comput. Log., 15(4):32:1â€“32:38, 2014. DOI: 10.1145/2629337.
86
John Alan Robinson. A machine-oriented logic based on the resolution principle. J. ACM, 12
(1):23â€“41, 1965. DOI: 10.1145/321250.321253. 32
Kenneth A. Ross. Modular stratiï¬cation and magic sets for datalog programs with negation. J.
ACM, 41(6):1216â€“1266, 1994. DOI: 10.1145/195613.195646. 126
Kenneth A. Ross and Yehoshua Sagiv. Monotonic aggregation in deductive database. J. Comp.
and System Sci., 54(1):79â€“97, 1997. DOI: 10.1006/jcss.1997.1453. 99
Domenico SaccÃ . Deterministic and non-deterministic stable model semantics for unbound dat-
alog queries. In Proc. 5th Int. Conf. on Database îeory, pages 353â€“367, 1995. DOI: 10.1007/3-
540-58907-4_27. 59
Domenico SaccÃ . î€€e expressive powers of stable models for bound and unbound datalog queries.
J. Comp. and System Sci., 54(3):441â€“464, 1997. DOI: 10.1006/jcss.1997.1446. 60
Domenico SaccÃ  and Carlo Zaniolo. On the implementation of a simple class of logic queries
for databases. In Proc. 5th ACM SIGACT-SIGMOD Symp. on Principles of Database Systems,
pages 16â€“23, 1986. DOI: 10.1145/6012.6013. 125
Domenico SaccÃ  and Carlo Zaniolo. Magic counting methods. In Proc. ACM SIGMOD Int.
Conf. on Management of Data, pages 49â€“59, 1987. DOI: 10.1145/38714.38725. 110
Domenico SaccÃ  and Carlo Zaniolo. î€€e generalized counting method for recursive logic queries.
îeor. Comp. Sci., 62(1-2):187â€“220, 1988. DOI: 10.1007/3-540-17187-8_28. 110, 121
Domenico SaccÃ  and Carlo Zaniolo. Stable models and non-determinism in logic programs
with negation. In Proc. 9th ACM SIGACT-SIGMOD-SIGART Symp. on Principles of Database
Systems, pages 205â€“217, 1990. DOI: 10.1145/298514.298572. 47

BIBLIOGRAPHY
151
Domenico SaccÃ  and Carlo Zaniolo. Partial models and three-valued models in logic programs
with negation. In Proc. 1st Int. Conf. Logic Programming and Nonmonotonic Reasoning, pages
87â€“101, 1991. 59
Domenico SaccÃ  and Carlo Zaniolo. Deterministic and non-deterministic stable models. J. of
Logic and Comput., 7(5):555â€“579, 1997. DOI: 10.1093/logcom/7.5.555. 59
Yehoshua Sagiv and Moshe Y. Vardi. Safety of datalog queries over inï¬nite databases. In Proc.
8th ACM SIGACT-SIGMOD-SIGART Symp. on Principles of Database Systems, pages 160â€“171,
1989. DOI: 10.1145/73721.73738. 32
Yatin P. Saraiya.
Linearizing nonlinear recursions in polynomial time.
In Proc. 8th ACM
SIGACT-SIGMOD-SIGART Symp. on Principles of Database Systems, pages 182â€“189, 1989.
DOI: 10.1145/73721.73740. 110
John S. Schlipf. î€€e expressive powers of the logic programming semantics. J. Comp. and Syst.
Sci., 51(1):64â€“86, 1995. DOI: 10.1006/jcss.1995.1053. 43, 59
Peter Schneider-Kamp, JÃ¼rgen Giesl, and Manh î€€ang Nguyen. î€€e dependency triple frame-
work for termination of logic programs. In Proc. International Symposium on Logic-based Pro-
gram Synthesis and Transformation, pages 37â€“51, 2009a. DOI: 10.1007/978-3-642-12592-8_4.
86
Peter Schneider-Kamp, JÃ¼rgen Giesl, Alexander Serebrenik, and RenÃ© î€€iemann. Automated
termination proofs for logic programs by term rewriting. ACM Trans. Comput. Log., 11(1),
2009b. DOI: 10.1145/1614431.1614433. 86
Peter Schneider-Kamp, JÃ¼rgen Giesl, î€€omas StrÃ¶der, Alexander Serebrenik, and RenÃ© î€€ie-
mann. Automated termination analysis for logic programs with cut. îeory & Practice of Logic
Program., 10(4-6):365â€“381, 2010. DOI: 10.1017/S1471068410000165. 86
Jiwon Seo, Stephen Guo, and Monica S. Lam.
Socialite: Datalog extensions for eï¬ƒ-
cient social network analysis.
In Proc. 29th Int. Conf. on Data Engineering, 2013. DOI:
10.1109/ICDE.2013.6544832. 129
Alexander Serebrenik and Danny De Schreye. On termination of meta-programs. îeory &
Practice of Logic Program., 5(3):355â€“390, 2005. DOI: 10.1017/S1471068404002248. 86
Warren Shen, AnHai Doan, Jeï¬€rey F. Naughton, and Raghu Ramakrishnan. Declarative infor-
mation extraction using datalog with embedded extraction predicates. In Proc. 33rd Int. Conf.
on Very Large Data Bases, pages 1033â€“1044, 2007. 129
Alexander Shkapsky, Mohan Yang, and Carlo Zaniolo. Optimizing recursive queries with mono-
tonic aggregates in deals. In Proc. 31st Int. Conf. on Data Engineering, pages 867â€“878, 2015.
DOI: 10.1007/BFb0056001. 60

152
BIBLIOGRAPHY
Abraham Silberschatz, Henry F. Korth, and S. Sudarshan. Database System Concepts, 6th ed.
McGraw-Hill Book Company, 2010. 15
Patrik Simons, Ilkka NiemelÃ¤, and Timo Soininen.
Extending and implementing the sta-
ble model semantics.
Artiï¬cial Intell., 138(1-2):181â€“234, 2002. DOI: 10.1016/S0004-
3702(02)00187-X. 60
Christian Sternagel and Aart Middeldorp. Root-labeling. In Rewriting Techniques and Applica-
tions, pages 336â€“350, 2008. DOI: 10.1007/978-3-540-70590-1_23. 86
S. Sudarshan and Raghu Ramakrishnan.
Aggregation and relevance in deductive
databases.
In Proc. 17th Int. Conf. on Very Large Data Bases, pages 501â€“511, 1991. DOI:
10.1006/jcss.1997.1453. 99
Tommi SyrjÃ¤nen. Omega-restricted logic programs. In Proc. 6th Int. Conf. Logic Programming
and Nonmonotonic Reasoning, pages 267â€“279, 2001. DOI: 10.1007/3-540-45402-0_20. 86
Daniel Troy, Clement T. Yu, and Weining Zhang. Linearization of nonlinear recursive rules.
IEEE Trans. Software Eng., 15(9):1109â€“1119, 1989. DOI: 10.1109/32.31368. 110
Jeï¬€rey D. Ullman. Principles of Database and Knowledge-Base Systems, Volume I. Computer Sci-
ence Press, 1988. 11, 15, 26, 32
Jeï¬€rey D. Ullman. Principles of Database and Knowledge-Base Systems, Volume II. Computer
Science Press, 1989. 110, 126
Jeï¬€rey D. Ullman. î€€e interface between language theory and database theory. In îeoretical
Studies in Computer Science, pages 133â€“151, 1992. 112, 126
Jeï¬€rey D. Ullman and Allen Van Gelder. Parallel complexity of logical query programs. In
Proc. 27th Annual Symp. on Foundations of Computer Science, pages 438â€“454, 1986. DOI:
10.1109/SFCS.1986.40. 126
Maarten H. van Emden and Robert A. Kowalski. î€€e semantics of predicate logic as a program-
ming language. J. ACM, 23(4):733â€“742, 1976. DOI: 10.1145/321978.321991. 32
Allen Van Gelder. Negation as failure using tight derivations for general logic programs. J. Logic
Program., 6(1&2):109â€“133, 1989. DOI: 10.1016/0743-1066(89)90032-0. 36
Allen Van Gelder. î€€e well-founded semantics of aggregation. In Proc. 11th ACM SIGACT-
SIGMOD-SIGART Symp. on Principles of Database Systems, pages 127â€“138, 1992. DOI:
10.1145/137097.137854. 99
Allen Van Gelder, Kenneth A. Ross, and John S. Schlipf. Unfounded sets and well-founded
semantics for general logic programs. In Proc. 7th ACM SIGACT-SIGMOD-SIGART Symp.
on Principles of Database Systems, pages 221â€“230, 1988. DOI: 10.1145/308386.308444. 43

BIBLIOGRAPHY
153
Allen Van Gelder, Kenneth A. Ross, and John S. Schlipf. î€€e well-founded semantics for general
logic programs. J. ACM, 38(3):620â€“650, 1991. DOI: 10.1145/116825.116838. 43, 45, 46, 47
Soï¬e Verbaeten, Danny De Schreye, and Konstantinos F. Sagonas.
Termination proofs
for logic programs with tabling.
ACM Trans. Comput. Log., 2(1):57â€“92, 2001. DOI:
10.1145/371282.371357. 86
Laurent Vieille. Recursive query processing: î€€e power of logic. îeor. Comp. Sci., 69(1):1â€“53,
1989. DOI: 10.1016/0304-3975(89)90088-1. 126
Dean Voets and Danny De Schreye.
Non-termination analysis of logic programs with in-
teger arithmetics.
îeory & Practice of Logic Program., 11(4-5):521â€“536, 2011. DOI:
10.1017/S1471068411000159. 86
Peter T. Wood. Factoring augmented regular chain programs. In Proc. 16th Int. Conf. on Very
Large Data Bases, pages 255â€“263, 1990. 109, 110
Mihalis Yannakakis. Graph-theoretic methods in database theory. In Proc. 9th ACM SIGACT-
SIGMOD-SIGART Symp. on Principles of Database Systems, pages 230â€“242, 1990. DOI:
10.1145/298514.298576. 110, 126
Jia-Huai You and Li-Yan Yuan. On the equivalence of semantics for normal logic programs. J.
Logic Program., 22(3):211â€“222, 1995. DOI: 10.1016/0743-1066(94)00023-Y. 59
Carlo Zaniolo.
Safety and compilation of non-recursive horn clauses.
In Proc. 1st Inter-
national Conference on Expert Database Systems, pages 237â€“252, 1986. DOI: 10.1016/0304-
3975(86)90015-0. 32
Hans Zantema. Termination of term rewriting: Interpretation and type elimination. J. of Symbol.
Comput., 17(1):23â€“50, 1994. DOI: 10.1006/jsco.1994.1003. 86
Hans Zantema. Termination of term rewriting by semantic labelling. Fundamenta Informaticae,
24(1/2):89â€“105, 1995. DOI: 10.3233/FI-1995-24124. 86
Wenchao Zhou, Yun Mao, Boon î€€au Loo, and MartÃ­n Abadi. Uniï¬ed declarative platform
for secure netwoked information systems. In Proc. 25th Int. Conf. on Data Engineering, pages
150â€“161, 2009. DOI: 10.1109/ICDE.2009.58. 129, 130


155
Authorsâ€™ Biographies
SERGIO GRECO
Sergio Greco is a Full Professor and Chair of the DIMES Department at the University of Cal-
abria (Italy). Before that he was Assistant Professor (1989-1998) and Associate Professor (1998-
2000) at the University of Calabria and visiting researcher at the Microelectronics and Computer
Corporation of Austin (1990-1991) and at the of University of California at Los Angeles (1996
and 1998). Prof. Grecoâ€™s research interests include database theory, data integration, inconsistent
data, data mining, knowledge representation, logic programming, and computational logic.
CRISTIAN MOLINARO
Cristian Molinaro received his Ph.D. degree in Computer Science Engineering from the Uni-
versity of Calabria, Italy. He was a Visiting Scholar at the Department of Computer Science and
Engineering of the State University of New York at Buï¬€alo. He was a Faculty Research Assistant
at the University of Maryland Institute for Advanced Computer Studies (2009-2011). Currently,
he is an Assistant Professor at the University of Calabria, Italy. His research interests include
database theory and logic programming.

