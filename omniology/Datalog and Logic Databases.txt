Datalog and  
Logic Databases
Sergio Greco
Cristian Molinaro
SyntheSiS LectureS on Data ManageMent
Z. Meral Özsoyoğlu, Series Editor
MORGAN&CLAYPOOL PUBLISHERS


Datalog and Logic Databases

Synthesis Lectures on Data
Management
Editor
Z. Meral Özsoyoˇglu, Case Western Reserve University
Founding Editor
M. Tamer Özsu, University of Waterloo
Synthesis Lectures on Data Management is edited by Meral Özsoyoˇglu of Case Western Reserve
University. e series publishes 80- to 150-page publications on topics pertaining to data
management. Topics include query languages, database system architectures, transaction
management, data warehousing, XML and databases, data stream systems, wide scale data
distribution, multimedia data management, data mining, and related subjects.
Datalog and Logic Databases
Sergio Greco and Cristian Molinaro
2015
Big Data Integration
Xin Luna Dong and Divesh Srivastava
2015
Instant Recovery with Write-Ahead Logging: Page Repair, System Restart, and Media
Restore
Goetz Graefe, Wey Guy, and Caetano Sauer
2014
Similarity Joins in Relational Database Systems
Nikolaus Augsten and Michael H. Böhlen
2013
Information and Inﬂuence Propagation in Social Networks
Wei Chen, Laks V.S. Lakshmanan, and Carlos Castillo
2013
Data Cleaning: A Practical Perspective
Venkatesh Ganti and Anish Das Sarma
2013

iii
Data Processing on FPGAs
Jens Teubner and Louis Woods
2013
Perspectives on Business Intelligence
Raymond T. Ng, Patricia C. Arocena, Denilson Barbosa, Giuseppe Carenini, Luiz Gomes, Jr.,
Stephan Jou, Rock Anthony Leung, Evangelos Milios, Renée J. Miller, John Mylopoulos, Rachel A.
Pottinger, Frank Tompa, and Eric Yu
2013
Semantics Empowered Web 3.0: Managing Enterprise, Social, Sensor, and Cloud-based
Data and Services for Advanced Applications
Amit Sheth and Krishnaprasad irunarayan
2012
Data Management in the Cloud: Challenges and Opportunities
Divyakant Agrawal, Sudipto Das, and Amr El Abbadi
2012
Query Processing over Uncertain Databases
Lei Chen and Xiang Lian
2012
Foundations of Data Quality Management
Wenfei Fan and Floris Geerts
2012
Incomplete Data and Data Dependencies in Relational Databases
Sergio Greco, Cristian Molinaro, and Francesca Spezzano
2012
Business Processes: A Database Perspective
Daniel Deutch and Tova Milo
2012
Data Protection from Insider reats
Elisa Bertino
2012
Deep Web Query Interface Understanding and Integration
Eduard C. Dragut, Weiyi Meng, and Clement T. Yu
2012
P2P Techniques for Decentralized Applications
Esther Pacitti, Reza Akbarinia, and Manal El-Dick
2012

iv
Query Answer Authentication
HweeHwa Pang and Kian-Lee Tan
2012
Declarative Networking
Boon au Loo and Wenchao Zhou
2012
Full-Text (Substring) Indexes in External Memory
Marina Barsky, Ulrike Stege, and Alex omo
2011
Spatial Data Management
Nikos Mamoulis
2011
Database Repairing and Consistent Query Answering
Leopoldo Bertossi
2011
Managing Event Information: Modeling, Retrieval, and Applications
Amarnath Gupta and Ramesh Jain
2011
Fundamentals of Physical Design and Query Compilation
David Toman and Grant Weddell
2011
Methods for Mining and Summarizing Text Conversations
Giuseppe Carenini, Gabriel Murray, and Raymond Ng
2011
Probabilistic Databases
Dan Suciu, Dan Olteanu, Christopher Ré, and Christoph Koch
2011
Peer-to-Peer Data Management
Karl Aberer
2011
Probabilistic Ranking Techniques in Relational Databases
Ihab F. Ilyas and Mohamed A. Soliman
2011
Uncertain Schema Matching
Avigdor Gal
2011

v
Fundamentals of Object Databases: Object-Oriented and Object-Relational Design
Suzanne W. Dietrich and Susan D. Urban
2010
Advanced Metasearch Engine Technology
Weiyi Meng and Clement T. Yu
2010
Web Page Recommendation Models: eory and Algorithms
Sule Gündüz-Ögüdücü
2010
Multidimensional Databases and Data Warehousing
Christian S. Jensen, Torben Bach Pedersen, and Christian omsen
2010
Database Replication
Bettina Kemme, Ricardo Jimenez-Peris, and Marta Patino-Martinez
2010
Relational and XML Data Exchange
Marcelo Arenas, Pablo Barcelo, Leonid Libkin, and Filip Murlak
2010
User-Centered Data Management
Tiziana Catarci, Alan Dix, Stephen Kimani, and Giuseppe Santucci
2010
Data Stream Management
Lukasz Golab and M. Tamer Özsu
2010
Access Control in Data Management Systems
Elena Ferrari
2010
An Introduction to Duplicate Detection
Felix Naumann and Melanie Herschel
2010
Privacy-Preserving Data Publishing: An Overview
Raymond Chi-Wing Wong and Ada Wai-Chee Fu
2010
Keyword Search in Databases
Jeﬀrey Xu Yu, Lu Qin, and Lijun Chang
2009

Copyright © 2016 by Morgan & Claypool
All rights reserved. No part of this publication may be reproduced, stored in a retrieval system, or transmitted in
any form or by any means—electronic, mechanical, photocopy, recording, or any other except for brief quotations
in printed reviews, without the prior permission of the publisher.
Datalog and Logic Databases
Sergio Greco and Cristian Molinaro
www.morganclaypool.com
ISBN: 9781627051132
paperback
ISBN: 9781627051149
ebook
DOI 10.2200/S00648ED1V01Y201505DTM041
A Publication in the Morgan & Claypool Publishers series
SYNTHESIS LECTURES ON DATA MANAGEMENT
Lecture #41
Series Editor: Z. Meral Özsoyoˇglu, Case Western Reserve University
Founding Editor: M. Tamer Özsu, University of Waterloo
Series ISSN
Print 2153-5418
Electronic 2153-5426

Datalog and Logic Databases
Sergio Greco and Cristian Molinaro
DIMES, Università della Calabria
SYNTHESIS LECTURES ON DATA MANAGEMENT #41
C
M
&
cLaypool
Morgan
publishers
&

ABSTRACT
e use of logic in databases started in the late 1960s. In the early 1970s Codd formalized
databases in terms of the relational calculus and the relational algebra. A major inﬂuence on the
use of logic in databases was the development of the ﬁeld of logic programming. Logic provides
a convenient formalism for studying classical database problems and has the important property
of being declarative, that is, it allows one to express what she wants rather than how to get it.
For a long time, relational calculus and algebra were considered the relational database
languages. However, there are simple operations, such as computing the transitive closure of a
graph, which cannot be expressed with these languages. Datalog is a declarative query language
for relational databases based on the logic programming paradigm. One of the peculiarities that
distinguishes Datalog from query languages like relational algebra and calculus is recursion, which
gives Datalog the capability to express queries like computing a graph transitive closure.
Recent years have witnessed a revival of interest in Datalog in a variety of emerging appli-
cation domains such as data integration, information extraction, networking, program analysis,
security, cloud computing, ontology reasoning, and many others. e aim of this book is to present
the basics of Datalog, some of its extensions, and recent applications to diﬀerent domains.
KEYWORDS
relational databases, logic programs, datalog, recursion, negation, function symbols,
aggregates, query optimization

ix
Contents
Acknowledgments. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xiii
1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
2
Logic and Relational Databases . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
2.1
First-order Logic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
2.1.1 Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
2.1.2 Herbrand Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
2.2
Relational Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
2.2.1 Relational Algebra . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
2.2.2 Relational Calculus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
2.2.3 Conjunctive Queries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
2.2.4 Data Dependencies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
2.3
Complexity Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
3
Datalog . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
3.1
Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
3.2
Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
3.2.1 Model-eoretic Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
3.2.2 Fixpoint Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
3.2.3 Proof-eoretic Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
3.3
Program Evaluation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
3.3.1 Evaluation of Non-recursive Programs . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
3.3.2 Evaluation of Recursive Programs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
3.4
Expressivity and Complexity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
4
Negation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
4.1
Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
4.2
Semipositive Programs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
4.3
Stratiﬁed Programs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
4.4
Locally Stratiﬁed Programs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
4.5
Unstratiﬁed Negation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41

x
4.5.1 Stable Model Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
4.5.2 Well-founded Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
4.6
Choice. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
4.6.1 Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
4.6.2 Stable-model Declarative Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
4.6.3 Fixpoint Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
4.6.4 Greedy Choice . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
4.7
Disjunction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
5
Function Symbols . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61
5.1
Syntax and Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61
5.2
Termination Criteria . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62
5.2.1 -restricted Programs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
5.2.2 Finite Domain Programs. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64
5.2.3 Argument-restricted Programs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
5.2.4 Safe Programs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
5.2.5   -acyclic Programs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
5.2.6 Bounded Programs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70
5.3
Program Adornment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
5.4
Dealing with Disjunction and Negation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85
6
Aggregates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89
6.1
Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89
6.2
Sum and Count . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90
6.3
Summation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94
6.4
Combining Summation and Greedy Choice . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96
7
Query Optimization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
7.1
Magic-sets Rewriting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
7.2
Chain Queries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109
7.2.1 e Pushdown Method. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112
7.2.2 Right-Linear Programs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
7.2.3 Grammar Transformations to Improve Pushdown . . . . . . . . . . . . . . . . 116
7.2.4 When Pushdown Reduces to Counting . . . . . . . . . . . . . . . . . . . . . . . . . 121
7.2.5 Implementation and Termination . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122

xi
8
Applications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
8.1
Security . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
8.2
Networking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130
8.3
Web Data Management . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130
8.4
Program Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
8.5
Module Composition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132
Bibliography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135
Authors’ Biographies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 155


xiii
Acknowledgments
We are very grateful to Leo Bertossi for his valuable comments, and to Tamer Özsu for the
opportunity to write this book.
We would also like to express our thanks to Diane Cerra at Morgan & Claypool for her
constant support and assistance.
Sergio Greco and Cristian Molinaro
October 2015


1
C H A P T E R
1
Introduction
e use of logic in databases started in the late 1960s. In the early 1970s, Codd formalized
databases in terms of the relational calculus and the relational algebra. A major inﬂuence on the
use of logic in databases was the development of the ﬁeld of logic programming. Logic provides
a convenient formalism for studying classical database problems.
For a long time, relational calculus and algebra were considered the relational database
languages. However, there are simple operations, such as computing the transitive closure of a
graph, which cannot be expressed with these languages. Datalog is a declarative query language
for relational databases based on the logic programming paradigm. From a syntactical standpoint,
an important diﬀerence between Datalog and logic programs is that function symbols are not
allowed in Datalog. One of the peculiarities that distinguishes Datalog from query languages like
relational algebra and calculus is recursion, which gives Datalog the capability to express queries
like computing a graph transitive closure.
Recent years have witnessed a revival of interest in Datalog in a variety of emerging appli-
cation domains such as data integration, information extraction, networking, program analysis,
security, cloud computing, ontology reasoning, and many others.
e aim of this book is to present the basics of Datalog, its extensions, and recent applica-
tions to diﬀerent domains.
is book starts with a brief review of ﬁrst-order logic, the relational model, and complexity
classes in Chapter 2.
Chapter 3 introduces the syntax and diﬀerent (equivalent) semantics of the Datalog lan-
guage. Moreover, simple algorithms for the evaluation of Datalog queries are presented. Com-
plexity and expressive power are analyzed as well.
en, diﬀerent extensions are considered, namely negation, functions symbols, and aggre-
gates. Each of them is addressed in a separate chapter.
In Chapter 4, we ﬁrst consider negation, which is an important feature to formalize com-
mon sense reasoning in knowledge representation, as it enables us to express nonmonotonic
queries. Diﬀerent increasingly liberal restrictions on the use of negation are considered, start-
ing from diﬀerent notions of “stratiﬁcation” and ending with an arbitrary, or “unstratiﬁed,” use
of negation. For the latter, two diﬀerent well-known semantics are presented, namely the stable
model and the well-founded semantics. en, we consider Datalog extended with a limited form
a negation embedded in the choice construct. We also brieﬂy discuss the extension of Datalog with
disjunction.

2
1. INTRODUCTION
In Chapter 5, Datalog is extended to include function symbols. Function symbols are widely
acknowledged as an important feature, as they often make modeling easier and the resulting en-
codings more readable and concise. Unfortunately, the main problem with their introduction in
Datalog is that the least model of a program can be inﬁnite and thus the bottom-up program
evaluation might not terminate. e chapter reports on recent research on identifying classes of
programs allowing only a restricted use of function symbols while ensuring ﬁniteness and com-
putability of the least model.
In Chapter 6, another important feature of query languages is considered, namely aggre-
gates. e most common aggregate operators are considered and we show how they help express
optimization problems.
In Chapter 7, we report techniques that take advantage of the information in Datalog
queries to make their evaluation more eﬃcient. e ﬁrst technique is the well-known magic-sets
rewriting method, which consists of rewriting a Datalog query into an equivalent one that com-
bines the advantages of the bottom-up and top-down evaluation strategies. e second technique
applies to a special class of Datalog queries, called chain queries.
Finally, Chapter 8 brieﬂy illustrates the use of Datalog in diﬀerent current database appli-
cations.

3
C H A P T E R
2
Logic and Relational Databases
A database is a collection of data organized to model relevant aspects of reality and to support
processes requiring this information.
A database model is a formalizm to describe how data are structured and used. It provides
the means for specifying particular data structures, for constraining the data associated with these
structures, and for manipulating the data. e most popular example of a database model is the
relational model, although several other data models have been proposed and are currently used.
e relational model was introduced by E. F. Codd in 1970 [Codd, 1970] as a way to make
Database Management Systems (DBMSs) independent of any particular application.
Logic and databases have gone a long way together since the beginning of the relational data
model itself. One of the ﬁrst relational database query language, namely the relational calculus,
is a fragment of ﬁrst-order logic. Logic provides a convenient formalizm for studying classical
database problems.
In this chapter, we report the basics of ﬁrst-order logic, relational model, relational query
languages, data dependencies, and complexity classes.
2.1
FIRST-ORDER LOGIC
In this section, we report syntax and the Herbrand semantics of classical ﬁrst-order predicate
logic.
2.1.1
SYNTAX
A ﬁrst-order language consists of an alphabet and all formulas that can be built from it. An alphabet
consists of the following classes of symbols:
• a set of variables;
• a set of constants;
• a set of function symbols;
• a set of predicate symbols;
• the connectives : (negation), _ (disjunction), ^ (conjunction), ! (implication), and $
(equivalence);
• the quantiﬁers 9 (there exists) and 8 (for all); and

4
2. LOGIC AND RELATIONAL DATABASES
• the parentheses ‘‘.” and ‘‘/”, and the comma ‘‘; ”.
Each predicate and function symbol is associated with a ﬁxed arity (i.e., the number of
arguments), which is a non-negative integer for predicate symbols and a positive integer for func-
tion symbols (the role of function symbols with arity 0 is played by the constants). us, the sets
of connectives, quantiﬁers, and parentheses are ﬁxed. We also assume that the set of variables is
inﬁnite and ﬁxed. e sets of constants, function symbols, and predicate symbols may vary and
determine diﬀerent ﬁrst-order languages.
Terms are recursively deﬁned as follows:
• a constant is a term;
• a variable is a term;
• if f is a function symbol of arity m and t1; : : : ; tm are terms, then f .t1; : : : ; tm/ is a term.
Formulas are recursively deﬁned as follows:
• if p is a predicate symbol of arity n and t1; : : : ; tn are terms, then p.t1; : : : ; tn/ is a formula
(also-called atom);
• if F and G are formulas, then so are :F , .F ^ G/, .F _ G/, .F ! G/, and .F $ G/; and
• if F is a formula and X is a variable, then 9XF and 8XF are formulas.
An atom of the form p.t1; : : : ; tn/ will be also-called a p-atom. In the following, a formula
.F ! G/ will be written also as .G  F /. Some well-known binary function symbols (e.g., C)
and predicate symbols (e.g., D) are written in inﬁx notation, that is, the symbol is written between
the arguments. In order to avoid an excessive use of parentheses, we introduce a binding order
among the connectives and the quantiﬁers: we assume that :, 9, and 8 bind stronger than ^
which in turns binds stronger than _ which binds stronger than ! and $. We also assume that
_, ^, !, and $ associate to the right. A formula of the form 8X1 : : : 8Xn F will be also written
as 8X1; : : : ; Xn F , and likewise for the existential quantiﬁer 9. us, for instance, the formula¹
8X8Y..p.X/ ^ :r.Y // ! .:q.X/ _ .q.X/ _ s.Y ////
can be rewritten as
8X; Y.p.X/ ^ :r.Y / ! :q.X/ _ .q.X/ _ s.Y ///
which can be in turn rewritten as the following formula because we are assuming that _ associates
to the right
8X; Y.p.X/ ^ :r.Y / ! :q.X/ _ q.X/ _ s.Y //:
¹Here p, q, r, and s are predicate symbols.

2.1. FIRST-ORDER LOGIC
5
A term or formula is ground if no variables appear in it.
e scope of 8X (resp. 9X) in the formula 8XF (resp. 9XF ) is F . A bound occurrence of a
variable in a formula is an occurrence immediately following a quantiﬁer, or an occurrence within
the scope of a quantiﬁer of the variable immediately after the quantiﬁer. Any other occurrence of a
variable is free. A formula without free variable occurrences is called a sentence. us, for instance,
in the formula
9Xp.X; Y / ^ q.X/
the ﬁrst two occurrences of X are bound, while the third one is free, because the scope of 9X is
p.X; Y /. e occurrence of Y is free. In the formula
9X.p.X; Y / ^ q.X//
all occurrences of X are bound because the scope of 9X is p.X; Y / ^ q.X/. e occurrence of Y
is free. Neither of the previous two formulas is a sentence as they have a free variable occurrence.
e formula
9X.p.X; X/ ^ q.X//
is a sentence because it does not have free variable occurrences (the only variable in the formula
is X and all its occurrences are bound).
Logic Programs.
Logic programs are sets of certain formulas of a ﬁrst-order language. A rule is
a formula of the following form:
8X1 : : : 8Xm A1 _    _ Ak _ :L1 _    _ :Ln;
where the Ai’s are atoms, the Lj’s are literals, and X1; : : : ; Xm are all the variables occurring in the
formula’s atoms and literals. e rule above can be written in the following special form (where
all variables are implicitly assumed to be universally quantiﬁed at the front of the rule):
A1 _    _ Ak  L1 ^ : : : ^ Ln:
A logic program is a ﬁnite set of rules. With any logic program P we can associate a ﬁrst-order lan-
guage LP whose constants, function symbols, and predicate symbols are exactly those occurring
in P .
A fact is a ground rule with k D 1 and n D 0, that is, a rule of the form
p.t1; : : : ; tk/  ;
where the ti’s are ground terms. For notational simplicity, we will often write this fact simply as
p.t1; : : : ; tk/I
that is, we drop the symbol  .

6
2. LOGIC AND RELATIONAL DATABASES
2.1.2
HERBRAND SEMANTICS
Let L be a ﬁrst-order language whose set of constants is not empty. e Herbrand universe UL
of L is the possibly inﬁnite set of ground terms which can be built using constants and function
symbols of L. e Herbrand base BL of L is the (possibly inﬁnite) set of ground atoms which
can be built using predicate symbols of L and ground terms in UL. A Herbrand interpretation (or
simply interpretation in the following) for L is a subset of the Herbrand base BL.
In order to deﬁne the notion of satisfaction of a formula by an interpretation, we need the
notion of variable assignment to accommodate variables occurring free in formulas. A variable
assignment is a function assigning each variable to an element of UL and each element of UL to
itself. Given a variable assignment , a variable X, and a ground term t in UL, we use ŒX=t
to denote the variable assignment that is the same as  except that .X/ D t. Below we deﬁne
when an interpretation I satisﬁes a formula F w.r.t. a variable assignment , denoted I ˆ F .
Let I be an interpretation,  a variable assignment, F and G formulas. en,
• if F is an atom p.t1; : : : ; tn/, then I ˆ F iﬀp..t1/; : : : ; .tn// 2 I;
• I ˆ :F iﬀI ˆ F does not hold;
• I ˆ F _ G iﬀI ˆ F or I ˆ G; and
• I ˆ 8XF iﬀI ˆŒX=t F for every t 2 UL.
We now deﬁne when I satisﬁes other kinds of formulas not mentioned above w.r.t.  by
expressing the remaining connectives and the quantiﬁer 9 in terms of :, _, and 8:
• F ^ G is rewritten as :.:F _ :G/;
• F ! G is rewritten as :F _ G;
• F $ G is rewritten as .F ! G/ ^ .G ! F /, which is rewritten as .:F _ G/ ^ .:G _
F /; and
• 9XF is rewritten as :8X:F .
e diﬀerence between variables occurring free (for which the considered variable assign-
ment is relevant) and those which are not is important. When interpreting a formula, the only
bindings we need to know are those of free variables; we can change any of other bindings and
still get the same result.
More formally, given an interpretation I, a formula F , and two variable assignments 1
and 2 agreeing on the variables occurring free in F , the following holds: I ˆ1 F iﬀI ˆ2 F .
As a consequence, if F is a sentence, then I ˆ1 F iﬀI ˆ2 F for any two variable assignments
1 and 2. us, when F is a sentence, we use I ˆ F to denote that I ˆ F for any variable
assignment . In such a case, we also say that I is a model for F (or F is true in I). Given a set
S of sentences and an interpretation I, we say that I is a model of S iﬀI is a model of every

2.2. RELATIONAL MODEL
7
sentence in S. We say that S is satisﬁable if there exists a model for it, otherwise it is unsatisﬁable
or inconsistent. If every interpretation is a model of S then S is valid.
Given another set of sentences S0, we say that S semantically implies S0, denoted S ˆ S0,
iﬀevery model of S is also a model of S0. Finally, S and S0 are semantically equivalent iﬀS ˆ S0
and S0 ˆ S.
2.2
RELATIONAL MODEL
We assume the existence of the following pairwise disjoint sets: a set of constants, a set of attributes,
and a set of relation names. e set of constants is called database domain and will be denoted as
C. Each attribute A is associated with a set of constants called the attribute domain and denoted
as dom.A/. Each relation name r has an arity n, which is a natural number, and is associated with
a ﬁnite sequence of n attributes A1; : : : ; An. A relation schema is of the form r.A1; : : : ; An/. A
relation R over r.A1; : : : ; An/ is a ﬁnite subset of dom.A1/      dom.An/. Each element of R
is called a tuple. Given a tuple t D .a1; : : : ; an/ in R, we use tŒAi to denote ai. Likewise, for a
sequence X of attributes Ai1; : : : ; Aim, tŒX denotes the tuple .tŒAi1; : : : ; tŒAim/. Intuitively, R
can be seen as a table where each row is a tuple of R, each column refers to an attribute Ai and
the values contained in the i-th column are taken from the attribute domain dom.Ai/.
A database schema is a set fS1; : : : ; Smg of relation schemas; a database instance (or simply
database) D over such a schema is a ﬁnite set of relations fR1; : : : ; Rmg where each Ri is a relation
over schema Si. If schema Si is of the form ri.A1; : : : ; An/, the extension or instance of relation
name ri in D is Ri.
Query languages are introduced to derive information from databases. A query is a function
that takes as input a database (over a ﬁxed input schema) and gives as output another database
(over a ﬁxed output schema). Queries can be expressed by means of a given query language, such
as the relational algebra, the relational calculus, SQL (Structured Query Language), or Datalog.
e expressive power of a language is measured in terms of the set of queries that can be expressed
using the language—for this purpose, queries have to be generic, that is, invariant under renamings
of the database domain.
Next, we present the relational algebra and the relational calculus.
2.2.1
RELATIONAL ALGEBRA
e relational algebra extends the algebra of sets and consists of ﬁve primitive operators deﬁned
below. Consider two relation schemas r.A1; : : : ; An/ and s.B1; : : : ; Bm/ and let R and S be two
relations over the ﬁrst and second schema, respectively. e primitive relational algebra operators
are deﬁned as follows:
• Cartesian product: R  S D f.r1; : : : ; rn; s1; : : : ; sm/ j .r1; : : : ; rn/2R ^ .s1; : : : ; sm/2Sg;
• Union: R [ S D ft j t 2 R _ t 2 Sg;

8
2. LOGIC AND RELATIONAL DATABASES
• Diﬀerence: R   S D ft j t 2 R ^ t … Sg;
• Projection: X.R/ D ftŒX j t 2 Rg, where X is a sequence of attributes among A1; : : : ; An;
and
• Selection: F .R/ D ft j t 2 R ^ F.t/g. Here F is an expression built using the logical con-
nectives _, ^, :, and atomic expressions of the form E1 op E2 where op is a comparison
operator, whereas E1 and E2 are constants or attributes names. F.t/ denotes the true/false
value given by evaluating expression F over tuple t.
e relational algebra deﬁned above is also-called named, since attribute names are used
in the relational algebra operators. In the unnamed relational algebra attributes are referred to by
their positions in the relation schema. So, in the projection and selection operators, we can refer
to an attribute Ai of a relation R over schema r.A1; : : : ; An/ using the expression $i instead of
Ai.
Several derived operators have been deﬁned as well. Derived operators do not increase the
expressive power of the language (i.e., they do not allow us to express more queries), but are
introduced to make expressions more comprehensible and their evaluation more eﬃcient. For
instance, the derived operators intersection and join are deﬁned as follows:
• Intersection: R \ S D ft j t 2 R ^ t 2 Sg D R   .R   S/ D S   .S   R/; and
• Join:
R ‰F S D f.r1; : : : ; rn; s1; : : : ; sm/ j .r1; : : : ; rn/ 2 R ^ .s1; : : : ; sm/ 2 S ^
F.r1; : : : ; rn; s1; : : : ; sm/g D F .R  S/, where F is a selection expression (here we
are assuming that the schemas of R and S have no common attribute).
In the unnamed relational algebra, the atomic expressions of F are of the form $i op $j,
with 1  i  n and 1  j  m, that is, $i refers to an attribute of R and $j refers to an
attribute of S. us, R ‰F S D F 0.R  S/ where F 0 is obtained from F by replacing
each atomic expression $i op $j with $i op $.n C j/.
Example 2.1
Suppose to have two relations Employee and Department over relation schemas
employee.EmpId; EmpName; Dept/ and department.DeptId; DeptName/, respectively. e query
asking for the names of the employees who work in the department physics can be expressed in
the named relational algebra as:
EmpName
 Employee ‰DeptDDeptId .DeptNameDphysics.Department//

:
In the unnamed relational algebra, the same query can be expressed as follows:
$2
 Employee ‰$3D$1 .$2Dphysics.Department//

:
Notice that in the join condition, $3 refers to the third attribute of Employee whereas $1 refers to
the ﬁrst attribute of Department.

2.2. RELATIONAL MODEL
9
2.2.2
RELATIONAL CALCULUS
e relational calculus, introduced below, is another formalizm to express queries in the relational
model and can be viewed as a specialization of ﬁrst-order logic. More precisely, the language
we present in this subsection is sometimes called domain calculus, because variables range over
the underlying database domain; in tuple calculus, which we do not consider, variables range over
tuples.
Consider the ﬁrst-order language L whose set of constants is the database domain C, the
set of function symbols is empty, and the set of predicate symbols consists of the set of relation
names and comparison predicate symbols. Notice that the Herbrand universe UL is equal to C.
An atom of the form p.t1; : : : ; tn/, where p is a relation name and the ti’s are terms, is called
relation atom; an atom of the form t1 op t2, where op is a comparison predicate symbol and t1, t2
are terms, is called comparison atom—here the inﬁx notation has been used for op. When op is D,
we call the atom equality atom.
Notice that a database D can be seen as a set of facts: if .a1; : : : ; an/ is a tuple belonging to
the extension of a relation name r in D, then we have a fact r.a1; : : : ; an/. us, in the following
we will look at databases as ﬁnite sets of facts. is also means that a database D can be seen
as a (ﬁnite) Herbrand interpretation for L. As a consequence, we can deﬁne when a database D
satisﬁes a formula F w.r.t. a variable assignment , denoted D ˆ F , in the same way as deﬁned
for interpretations in Section 2.1.2—in this regard, notice that if F is a comparison atom t1 op t2,
then D ˆ F iﬀ.t1/ op .t2/ holds.
A relational calculus query is an expression of the form:
f.u1; : : : ; un/ j F g;
where the ui’s are terms of L, F is a formula of L, and the variables in .u1; : : : ; un/ are exactly
the variables occurring free in F . Notice that each ui is either a constant or a variable (as L does
not have function symbols) and the same term can be repeated in .u1; : : : ; un/.
Example 2.2
Consider again the database schema consisting of the two relation schemas
employee.EmpId; EmpName; Dept/ and department.DeptId; DeptName/. e query asking for the
names of the employees working in the physics department can be expressed with the following
relational calculus query:
f.Y / j 9X 9Z employee.X; Y; Z/ ^ department.Z; physics/g:
Given a database D and a relational calculus query Q of the form f.u1; : : : ; un/ j F g, the
semantics of Q over D is
Q.D/ D f..u1/; : : : ; .un// j  is a variable assignment and D ˆ F g:
We also say that tuples in Q.D/ are the answers to Q over D.

10
2. LOGIC AND RELATIONAL DATABASES
In the ﬁrst-order language L considered so far, the set of constants is equal to the database
domain C. e semantics above can be generalized to allow explicit speciﬁcation of the underlying
domain to use (i.e., the set of constants over which variables may range). e active domain of a
database D, denoted adom.D/, is the set of constants appearing in D. Likewise, we use adom.Q/
and adom.F / to denote the set of constants appearing in a relational calculus query Q and formula
F , respectively. e semantics of a relational calculus query over a database with respect to a
particular domain C0, called evaluation domain, is deﬁned as seen before except that the underlying
set of constants of the language is C0 and the range of variable assignment is C0 rather than C.
Notice that the supersets of adom.D/ [ adom.Q/ are the only domains with respect to which it
makes sense to evaluate Q over D, so we assume .adom.D/ [ adom.Q//  C0  C. In order to
specify the evaluation domain C0 w.r.t. which a query is evaluated we use the notation QC0.D/.
Note that if C0 is inﬁnite, then QC0.D/ can be an inﬁnite set of tuples.
Domain Independent and Safe Relational Calculus Queries.
A relational calculus query Q
is domain independent if for every database D, and every pair C0, C00 such that .adom.D/ [
adom.Q//  C0; C00  C, it is the case that QC0.D/ D QC00.D/. us, for an arbitrary database,
a domain independent relational calculus query gives the same result regardless of the do-
main with respect to which is evaluated. In other words, if Q is domain independent, then
QC0.D/ does not change when C0 changes. is means that QC0.D/ can be computed for
C0 D adom.D/ [ adom.Q/.
Example2.3
Consider the relation schema r.A; B/ and the following relational calculus queries:
Q1 D f.X; Y / j 9U 9Z .r.U; Z/ _ r.X; Y //g,
Q2 D f.X; Y / j :r.X; Y //g,
Q3 D f.X/ j 8Y r.X; Y //g.
All the queries above are not domain independent. To see why, consider a relation R D
f.a; a/; .a; b/g and let C0 be a domain. It is easy to check that Q1
C0.fRg/ D f.x; y/ j x 2 C0 ^ y 2
C0g and Q2
C0.fRg/ D f.x; y/ j x 2 C0 ^ y 2 C0 ^ .x; y/ 62 Rg.
As the results of Q1 and Q2 contain values of C0, then their results clearly depend on C0.
It is easy to see that Q3 will always contain values taken from the input relation; nevertheless, it
is not domain independent. In fact, it is easy to see that if C0 is inﬁnite, then Q3
C0.fRg/ is empty.
e same holds if, for instance, C0 D fa; b; cg. However, if C0 D fa; bg, then Q3
C0.fRg/ D f.a/g.
Hence, Q3 can give diﬀerent results over the same relation when diﬀerent evaluation domains
are considered.
On the other hand, it is easy to see that the following queries are domain independent, as
the query answers depend only on the content of the input database:
Q4 D f.X; Y / j 9Z.r.X; Z/ ^ r.Z; Y //g,

2.2. RELATIONAL MODEL
11
Q5 D f.X; Y / j r.X; Y //g.
e problem of deciding whether a relational calculus query is domain independent is un-
decidable [Abiteboul et al., 1995, Ullman, 1988]. It is important to observe that the fact that we
can express relational calculus queries that are not domain independent is not a positive aspect
as, in the presence of an inﬁnite database domain, we can get query answers that have an inﬁnite
number of tuples.
We now present some syntactical restrictions that lead to a class of relational calculus
queries, called safe, that are guaranteed to be domain independent. Safe relational calculus queries
are a subset of the domain independent relational calculus queries [Abiteboul et al., 1995, Ullman,
1988].
Safe relational calculus is derived from relational calculus by imposing the following re-
strictions on formulas.
1. e universal quantiﬁer 8 is not used. is does not aﬀect the expressiveness of the language
as expressions of the form 8XF can be rewritten as :.9X:F /.
2. e disjunction operator is applied only to formulas having the same set of free variables.
3. For any maximal sub-formula F of the form F1 ^    ^ Fn, all the free variables of F must
be limited in the following sense:
• a variable is limited if it is free in some Fi and Fi is not a comparison atom and is not
negated;
• if Fi is of the form X D c or c D X, where X is a variable and c is a constant, then X
is limited; and
• if Fi is of the form X D Y or Y D X, where X, Y are variables and Y is limited, then
X is limited.
4. Negation is applied only to an Fi in a maximal sub-formula F of the form F1 ^    ^ Fn
where all free variables are limited.
e safe relational calculus and the relational algebra have the same expressive power, that
is, the set of queries that can be expressed by them is the same.
Example 2.4
e relational calculus queries Q4 and Q5 of Example 2.3, which are domain
independent, are also safe. e relational calculus query Q D f.X; Y; Z/ j F g, where F is the
following formula
r.X; Y; Z/ ^ :.p.X; Y / _ q.Y; Z//;
is domain independent but is not safe because F violates Condition 2—speciﬁcally, Condition 2
is violated by the subformula p.X; Y / _ q.Y; Z/. On the other hand, if F is the formula below,

12
2. LOGIC AND RELATIONAL DATABASES
then the relational calulus query is safe
r.X; Y; Z/ ^ :p.X; Y / ^ :q.Y; Z/:
2.2.3
CONJUNCTIVE QUERIES
Conjunctive queries (ﬁrst introduced in Chandra and Merlin, 1977) are a natural class of com-
monly arising queries that enjoy diﬀerent desirable properties (e.g., checking for equivalence and
containment of conjunctive queries is decidable). ey can be expressed in the languages seen so
far as follows.
• Relational calculus: relational calculus queries of the form fY j 9X r1.U 1/ ^    ^ rk.U k/g
where Y is a tuple of variables (that must appear in the conjunction) and constants, X is the
tuple of variables in the conjunction that are not in Y , the ri’s are relation names, and the
U i’s are tuples of terms (i.e., variables and constants). Notice that relational calculus queries
of this form are safe, and thus, domain independent.
• Relational algebra: relational algebra queries using only positive selection (i.e., selection
conditions are restricted to be conjunctions of equalities), projection, and Cartesian product.
Example 2.5
e relational calculus query of Example 2.2 is conjunctive. e relational algebra
query of Example 2.1 can be rewritten into the following equivalent conjunctive query (recall that
the join operator is a derived operator that can be expressed by means of Cartesian product and
selection):
EmpName

DeptDDeptId
 Employee  .DeptNameDphysics.Department//

:
2.2.4
DATA DEPENDENCIES
Data dependencies are used to express integrity constraints on data, that is semantic properties
that database instances should satisfy to properly reﬂect the real state of the world. Data depen-
dencies are also used in database schema design to deﬁne normal forms, that is, conditions that a
“good” relational database schema has to satisfy in order to reduce or eliminate redundant infor-
mation. Recent years have seen a renewed interest in data dependencies since they play a central
role in several current database applications such as data exchange and integration [Fagin et al.,
2005, Lenzerini, 2002] and ontology management [Calì et al., 2009a,b]. For a more complete
treatment of the subject we refer to Abiteboul et al. [1995] and Greco et al. [2012a].
An embedded dependency is a ﬁrst-order logic sentence of the form:
8X; 8Y ..X; Y / ! 9Z  .X; Z//;

2.2. RELATIONAL MODEL
13
where X, Y , and Z are tuple of variables, .X; Y / and  .X; Z/ are conjunctions of relation
and equality atoms, called the body and the head of the dependency, respectively. Without loss of
generality we can assume that equality atoms may appear only in the head of the dependency and
there is no existentially quantiﬁed variable involved in an equality atom.
Subclasses of embedded dependencies are:
• unirelational dependencies: only one relational symbol is used in  and  ;
• 1-head dependencies: only a single atom in the head;
• tuple generating dependencies (TGDs): no equality atoms;
• full dependencies: no existentially quantiﬁed variables Z; and
• equality generating dependencies (EGDs): full, 1-head with an equality atom in the head.
Example 2.6
Consider the database schema consisting of the two relation schemas
employee.EmpId; EmpName; Dept/ and department.DeptId; DeptName/. e following equality
generating dependency states that, given a database D over the schema above, the instance of
department in D cannot contain two distinct tuples with the same value on DeptId.
8D; N1; N2 .department.D; N1/ ^ department.D; N2/ ! N1 D N2/
e previous dependency is a functional dependency (in particular, a key dependency) and DeptId is
a key of department [Abiteboul et al., 1995, Greco et al., 2012a].
In general, a functional dependency is an equality generating dependency of the form
8X; Y 1; Y 2; Z1; Z2 .p.X; Y 1; Z1/ ^ p.X; Y 2; Z2/ ! Z1 D Z2/;
where p.X; Y 1; Z1/ and p.X; Y 2; Z2/ are relation atoms with X, Y 1, Y 2, Z1, and Z2 being lists
of variables. is functional dependency can be expressed also as A ! B, where A is the set of
attributes of p corresponding to X and B is the set of attributes of p corresponding to Z1 (and
Z2). A relation R over the schema of p satisﬁes such a functional dependency if, for every two
tuples t1; t2 2 R, if t1ŒA D t2ŒA then t1ŒB D t2ŒB.
e following tuple generating dependency states that, given a database D over the schema
above, for every tuple t in the instance of employee in D, there must be a tuple t0 in the instance
of department in D s.t. tŒDept D t0ŒDeptId
8E; N; D .employee.E; N; D/ ! 9M department.D; M//:
e previous dependency is also called inclusion dependency.

14
2. LOGIC AND RELATIONAL DATABASES
Dependency Skolemization.
Given a TGD d of the form
8X; 8Y ..X; Y / ! 9Z1; : : : ; Zn  .X; Z1; : : : ; Zn//
the skolemized version of d, denoted sk.d/, is the following sentence
8X; 8Y ..X; Y / !  .X; f d
Z1.X; Y /; : : : ; f d
Zn.X; Y ///;
where each f d
Zi is a fresh function symbol of arity jXj C jY j. us, existentially quantiﬁed vari-
ables in the head of d are replaced by skolemized terms. For a full data dependency d (including
EGDs), sk.d/ D d.
2.3
COMPLEXITY CLASSES
Let ˙ be a ﬁnite alphabet and L  ˙ be a language in ˙, that is, a set of ﬁnite strings over
˙. Let T be a Deterministic Turing Machine (DTM) or a Nondeterministic Turing Machine
(NDTM), such that (i) if x 2 L, then T accepts x, and (ii) if x 62 L, then T rejects x. In this
case, we say that T decides L. In addition, if T halts in time O.f .n//, we say that T decides L in
time O.f .n//. Similarly, if T halts within space O.f .n//, we say that T decides L within space
O.f .n// (for details on DTM and NDTM, see Johnson [1990] and Papadimitriou [1994]).
We deﬁne the following sets of languages:
TIME.f .n//
D
fL j L is a language decided by some DTM in time O.f .n//g
NTIME.f .n//
D
fL j L is a language decided by some NDTM in time O.f .n//g
SPACE.f .n//
D
fL j L is a language decided by some DTM within space O.f .n//g
NSPACE.f .n//
D
fL j L is a language decided by some NDTM within space O.f .n//g:
All these sets are examples of complexity classes. Complexity classes of most interest are not
classes corresponding to particular functions but their unions such as, for example, the union
[d>0TIME.nd/ taken over all polynomials of the form nd. Some common complexity classes are:
P
D
S
d>0 TIME.nd/
NP
D
S
d>0 NTIME.nd/
EXPTIME
D
S
d>0 TIME.2nd /
NEXPTIME
D
S
d>0 NTIME.2nd /
PSPACE
D
S
d>0 SPACE.nd/
EXPSPACE
D
S
d>0 SPACE.2nd /
L
D
SPACE.log n/
NL
D
NSPACE.log n/:
e list does not contain the nondeterministic counterparts of PSPACE and EXPSPACE because
S
d>0 NSPACE.nd/ coincides with the class PSPACE and S
d>0 NSPACE.2nd / coincides with the
class EXPSPACE.

2.3. COMPLEXITY CLASSES
15
e complementary class of a complexity class C, denoted co-C, is deﬁned as follows. For
every language L in ˙, let L denote its complement, that is, the set ˙nL. en, co-C is fL j L 2
Cg.
Below we deﬁne the polynomial hierarchy classes. In order to do it, we ﬁrst need to introduce
oracle Turing machines. Let A be a language. An oracle DTM T A, also-called a DTM with oracle
A, can be thought of as an ordinary DTM augmented by an additional write-only query tape
and additional three states query, 2, and 62. When T A is not in the state query, the computation
proceeds as usual (in addition, T A can write on the query tape). When T A is in query, T A changes
this state to 2 or 62 depending on whether the string written on the query tape belongs to A;
furthermore, the query tape is instantaneously erased. As in the case of an ordinary DTM, the
expended time is the number of steps and the required space is the number of cells used on the
tape and the query tape. e oracle replies to a query in unit time, and thus, roughly speaking,
models a call to a subroutine that is evaluated in unit time. An oracle NDTM is deﬁned as the
same augmentation of a NDTM.
Let C be a set of languages. e complexity classes PC and NPC are deﬁned as follows. Given
a language L, we have L 2 PC (resp. L 2 NPC) if and only if there is some language A 2 C and
some oracle DTM (resp. NDTM) T A such that T A decides L in polynomial-time. e polynomial
hierarchy consists of classes p
i , ˙p
i , and ˘ p
i deﬁned as follows:
p
0 D ˙p
0 D ˘ p
0 D P
p
iC1 D P˙p
i
for i  0
˙p
iC1 D NP˙p
i
for i  0
˘ p
iC1 D co-˙p
iC1
for i  0:
e class PH is deﬁned as S
i0 ˙p
i . Notice that NP D ˙p
1 , co-NP D ˘ p
1 , and p
2 D PNP.
Let L1 and L2 be languages. Assume that there is a DTM R such that (i) for all input
strings x, we have x 2 L1 if and only if R.x/ 2 L2, where R.x/ denotes the output of R on input
x; and (ii) R halts within space O.log n/. en, R is called a logarithmic-space reduction from
L1 to L2 and we say that L1 is reducible to L2. Let C be a set of languages. A language L is
called C-hard if any language L0 in C is reducible to L. If L is C-hard and L 2 C, then L is called
C-complete or complete for C.
BIBLIOGRAPHIC NOTES
Relational model and relational algebra were introduced by Codd [1970]. Codd [1972] introduced
relational calculus showing its equivalence with relational algebra. For a more complete treatment
of relational databases the reader is referred to Abiteboul et al. [1995], Date [2000], Elmasri and
Navathe [2000], Garcia-Molina et al. [2009], Maier [1983], Ramakrishnan and Gehrke [2003],
Silberschatz et al. [2010], Ullman [1988]. For a more complete treatment of logic programming
we refer to Apt [1991], Lloyd [1987], while for a detailed exposition of complexity notions we
refer to Johnson [1990] and Papadimitriou [1994].


17
C H A P T E R
3
Datalog
Datalog is a declarative query language for relational databases based on the logic programming
paradigm. From a syntactical standpoint, an important diﬀerence between Datalog and logic pro-
grams is that function symbols are not allowed in Datalog. For a long time, relational calculus and
algebra were considered the relational database languages. However, there are simple operations,
such as computing the transitive closure of a graph, which cannot be accomplished with those lan-
guages. One of the peculiarities that distinguishes Datalog from the query languages presented
in the previous chapter is recursion, which gives Datalog the capability to express queries like
computing a graph transitive closure.
3.1
SYNTAX
A Datalog rule r is (a logic program rule) of the form:
A0  A1; : : : ; An;
where n  0, the Ai’s are atoms where no function symbol appears, and every variable appearing
in A0 also appears in at least one of A1; : : : ; An. e last requirement is called safety and is used to
avoid rules yielding inﬁnite relations from ﬁnite ones. Comparison operators are not allowed in a
Datalog rule. A0 is called the head of r and is denoted by head.r/; the conjunction A1; : : : ; An is
called the body of r and is denoted by body.r/. With a slight abuse of notation, body.r/ will be also
used to denote the set of atoms appearing in the body of r. e intuitive meaning of the Datalog
rule above is that if A1; : : : ; An are all true, then A0 has to be true. A fact is a ground rule with
empty body; we call it a p-fact if p is the predicate symbol in the head. For notational simplicity,
we will often write a fact simply as A0: rather than A0  :, that is, we drop the symbol  .
A Datalog program is a ﬁnite set of Datalog rules. e deﬁnition of a predicate symbol p
in a program P , denoted def.p; P /, is the set of rules of P having p in the head atom. Recall
that a database can be seen as a ﬁnite set of facts. In the context of logic programming all the
knowledge (facts and general rules) is usually contained in a single logic program. As Datalog has
been developed for database applications, we will consider two sets of Datalog rules:
1. a set of facts D representing tuples of a database; and
2. a Datalog program P whose rules deﬁne new relations (or “views”) from the database.
D is called the Extensional Database (EDB) and P is called the Intensional Database (IDB). We
will refer to D simply as database and refer to P as Datalog program. us, predicate symbols are

18
3. DATALOG
partitioned into two disjoint sets: base (or EDB or extensional) and derived (or IDB or intensional)
predicate symbols. e deﬁnition of base predicate symbols is stored in D. Base predicate symbols
can appear in the body of rules in P but not in the head. Derived predicate symbols cannot appear
in D and their deﬁnition is in P . We will use PD to denote P [ D. An atom whose predicate
symbol is base (resp. derived) is also-called a base (resp. derived) atom.
Example 3.1
e following database stores the edges of a directed graph by means of facts of
the form edge.v1; v2/, meaning that there is an edge from vertex v1 to vertex v2 in the graph:
edge.a; b/:
edge.b; c/:
edge.c; d/:
Below is a Datalog program to compute the transitive closure of a graph stored by means of
edge-facts:
tc.X; Y /  edge.X; Y /:
tc.X; Y /  edge.X; Z/; tc.Z; Y /:
Intuitively, the ﬁrst rule above says that if there is an edge from a vertex X to a vertex Y , then
.X; Y / belongs to the transitive closure of the graph. e second rule says that if there is an edge
from a vertex X to a vertex Z and there exists a vertex Y such that .Z; Y / belongs to the transitive
closure, then .X; Y / belongs to the transitive closure as well.
It is worth noting that the transitive closure of a graph cannot be expressed using the rela-
tional algebra and calculus [Aho and Ullman, 1979].
e dependency graph GP of a Datalog program P is a directed graph deﬁned as follows:
the set of vertices is the set of derived predicate symbols appearing in P ; for each pair of derived
predicate symbols p and p0 (not necessarily distinct) appearing in P , there is an edge from p0 to
p iﬀP contains a rule where p0 appears in the body and p appears in the head. Program P is said
to be recursive if the dependency graph GP is cyclic. A derived predicate symbol p is said to be
recursive if it occurs in a cycle of GP ; two predicate symbols p and p0 are mutually recursive if they
occur in the same cycle. As an example, the Datalog program of Example 3.1 is recursive as its
dependency graph has an edge from tc to tc. A predicate symbol p depends on a predicate symbol
p0, denoted p0  p, if there is a path from p0 to p in GP ; leq.p/ denotes the set of all predicate
symbols p0 for which p0  p.
Given a Datalog program P , a rule in P with head predicate symbol p is linear if there is
at most one atom in the body of the rule whose predicate symbol is mutually recursive with p. If
each rule in P is linear, then P is linear. Clearly, the Datalog program of Example 3.1 is linear.
Conjunctive queries can be expressed by non-recursive Datalog programs with only base
predicate symbols occurring in the body. More precisely, a conjunctive query can be expressed by
means of a Datalog rule of the form
ans.X/  r1.X1/; : : : ; rn.Xn/;

3.2. SEMANTICS
19
where ans is a derived predicate symbol, X is a tuple of variables (that must appear in the rule
body) and constants, the ri’s are base predicate symbols, and the Xi’s are tuples of terms (i.e.,
variables and constants).
Example 3.2
Consider again the database schema consisting of the two relation schemas
employee.EmpId; EmpName; Dept/ and department.DeptId; DeptName/. e query asking for the
names of the employees working in the physics department can be expressed with the following
Datalog rule:
ans.Y /  employee.X; Y; Z/; department.Z; physics/:
3.2
SEMANTICS
In this section, we report three semantics for Datalog programs. ese semantics are “equivalent”
in that they give the same extensions to derived predicate symbols.
3.2.1
MODEL-THEORETIC SEMANTICS
Let P be a Datalog program and D a database. e Herbrand universe HPD of PD is the set of
constants appearing in PD. e Herbrand base BPD of PD is the set of ground atoms which can
be built using predicate symbols appearing in PD and constants of HPD.
A (ground) atom A0 is a ground instance of an atom A if A0 can be obtained from A by
substituting every variable in A with some constant in HPD—with multiple occurrences of the
same variable being replaced with the same constant. We use ground.A/ to denote the set of
all ground instances of A. Likewise, a (ground) rule r0 is a ground instance of a rule r in PD if
r0 can be obtained from r by substituting every variable in r with some constant in HPD. e
ground instantiation of r, denoted ground.r/, is the set of all ground instances of r. e ground
instantiation of PD, denoted ground.PD/, is the set of all ground instances of the rules in PD,
that is, ground.PD/ D [r2PDground.r/.
An interpretation of PD is any subset I of BPD. e truth value of a ground atom A w.r.t.
I, denoted valueI.A/, is true if A 2 I, false otherwise. e truth value of a conjunction of ground
atoms A1; : : : ; An w.r.t. I is true if every Ai (1  i  n) is true w.r.t. I; otherwise, the truth value
of the conjunction w.r.t. I is false. Notice that if n D 0, the conjunction is empty and its truth
value w.r.t. I is true. A ground rule r is satisﬁed by I, denoted I ˆ r, if the conjunction in the
body is false w.r.t. I or the head atom is true w.r.t. I; we write I 6ˆ r if r is not satisﬁed by I.
us, a ground rule r with empty body is satisﬁed by I if valueI.head.r// D true.
An interpretation of PD is a model of PD if it satisﬁes every ground rule in ground.PD/. A
model M of PD is minimal if no proper subset of M is a model of PD.

20
3. DATALOG
It is well known that PD has a unique minimal model, which coincides with the intersection
of all models of PD, and thus is the least (under set inclusion) model of PD. e model-theoretic
semantics of PD is given by its (unique) least model.
us, the model-theoretic semantics for a Datalog program is given by a minimal set of
ground atoms satisfying the ground instantiation of the program. e minimality requirement is
because the model should not contain more ground atoms than necessary to satisfy the ground
rules in ground.PD/. In this way, the least model contains exactly the atoms in D plus those that
are semantically implied by D [ P as a ﬁrst-order theory.
Example 3.3
Let D be the database and P the Datalog program of Example 3.1. It is easy to
see that an interpretation of PD satisﬁes all ground rules of PD iﬀit contains at least the following
set M of ground atoms:
edge.a; b/:
tc.a; b/:
tc.a; c/:
edge.b; c/:
tc.b; c/:
tc.b; d/:
edge.c; d/:
tc.c; d/:
tc.a; d/:
Indeed, M is the least model of PD. Notice that M is a model of PD and no proper subset of it
is a model of PD.
3.2.2
FIXPOINT SEMANTICS
e ﬁxpoint semantics is an operational semantics given in terms of an operator called the im-
mediate consequence operator. Intuitively, this operator derives new ground atoms starting from
known ground atoms, using the rules of a Datalog program.
Let P be a Datalog program and D a database. e immediate consequence operator TPD of
PD is deﬁned as follows. Given a set I of ground atoms, then
TPD.I/ D fA0 j A0  A1; : : : ; An is a ground rule in ground.PD/ and
Ai 2 I for every 1  i  ng:
us, TPD takes as input a set of ground atoms I and returns as output a set of ground
atoms TPD.I/, called the immediate consequences of I w.r.t. PD. Clearly, for every fact in D, its
head is an immediate consequence of any set I of ground atoms as the fact body is empty. We say
that a set of ground atoms I is a ﬁxpoint of TPD if TPD.I/ D I.
It is easy to see that TPD is monotonic, that is, if I1  I2, then TPD.I1/  TPD.I2/, for
any sets of ground atoms I1 and I2. By the Knaster-Tarski theorem, since TPD is monotonic it
has a least ﬁxpoint (that is, a ﬁxpoint that is included in any other ﬁxpoint), which we denote as
lfp.TPD/. e ﬁxpoint semantics of PD is given by the least ﬁxpoint lfp.TPD/.
e least ﬁxpoint can be computed as follows. e i-th iteration of TPD (i  1) w.r.t. I
is deﬁned as follows: T 1
PD.I/ D TPD.I/ and T i
PD.I/ D TPD.T i 1
PD .I// for i > 1. By iteratively
applying TPD we always reach a ﬁxpoint in a ﬁnite number of iterations, that is, there always
exists a ﬁnite n such T i
PD.I/ D T n
PD.I/ for any i  n. Such a ﬁxpoint is denoted as T 1
PD.I/. e

3.2. SEMANTICS
21
least ﬁxpoint of TPD can be computed by iteratively applying TPD starting from the empty set,
that is, lfp.TPD/ D T 1
PD.;/.
e least model of PD, discussed in the previous section, is equal to lfp.TPD/. us, this
approach provides an alternative constructive deﬁnition of the semantics of a Datalog program.
Example 3.4
Let D be the database and P the Datalog program of Example 3.1.
T 1
PD.;/ D
I1 D
TPD.;/ D
fedge.a; b/; edge.b; c/; edge.c; d/g
T 2
PD.;/ D
I2 D
TPD.I1/ D
I1 [ ftc.a; b/; tc.b; c/; tc.c; d/g
T 3
PD.;/ D
I3 D
TPD.I2/ D
I2 [ ftc.a; c/; tc.b; d/g
T 4
PD.;/ D
I4 D
TPD.I3/ D
I3 [ ftc.a; d/g
T 5
PD.;/ D
I5 D
TPD.I4/ D
I4:
us, I4 is the least ﬁxpoint of TPD, and, indeed, it is equal to the least model of PD (cf. Exam-
ple 3.3).
3.2.3
PROOF-THEORETIC SEMANTICS
e last semantics for Datalog programs is based on proofs. Speciﬁcally, the proof-theoretic se-
mantics deﬁnes the semantics of a Datalog program P and a database D in terms of the set of
ground atoms that can be proven from D using the Datalog rules of P as proof rules.
First of all, we need to deﬁne a proof. A proof tree of a ground atom A from a database D
and a Datalog program P is a labeled tree where:
• each vertex of the tree is labeled with a ground atom;
• each leaf is labeled with a ground atom for which there is a fact in D;
• the root is labeled by A;
• for each internal vertex labeled with A0, there exists a ground rule A0  A1; : : : ; An in
ground.P / such that the vertex children are A1; : : : ; An.
Proof trees provide proofs of ground atoms. Given a ground atom A to prove, one can
look for a proof either in a bottom-up or in a top-down fashion. e bottom-up approach is an
alternative way of looking at the ﬁxpoint semantics. One begins with the ground atoms in facts
of D and then uses rules of P to infer new ground atoms as done by the immediate consequence
operator. is is iteratively done until no new facts can be derived.
e top-down approach searches for a proof starting from a particular atom or set of atoms.
In a sense, the top-down approach tries to avoid the inference of atoms that are irrelevant for
proving the atoms of interest. Before presenting the details of a top-down procedure called SLD
resolution, we introduce some additional notions.

22
3. DATALOG
A goal clause in an expression of the form
 B1; : : : ; Bm;
where m  0 and the Bi’s are atoms (with no function symbols). When m D 0 the goal clause is
called empty goal clause and is denoted as .
A substitution  is a ﬁnite mapping from variables to terms and is written as  D
fX1=t1; : : : ; Xn=tng where the Xi’s are distinct variables and the ti’s are terms. We also as-
sume that Xi ¤ ti for every 1  i  n. e result of applying  to an expression E (e.g., a
term, an atom, a goal clause, etc.), denoted E, is the expression obtained from E by simul-
taneously replacing each occurrence of a variable Xi in E with ti iﬀXi=ti belongs to . Sub-
stitutions can be composed as follows. Given two substitutions  D fX1=t1; : : : ; Xn=tng and
# D fY1=u1; : : : ; Ym=umg, their composition, denoted  ı #, is the substitution obtained from
the set fX1=t1#; : : : ; Xn=tn#; Y1=u1; : : : ; Ym=umg by removing every Xi=ti# such that Xi D ti#
and every Yj =uj such that Yj 2 fX1; : : : ; Xng. A substitution  is more general than a substitution
# if there exists a substitution  such that # D  ı .
Example 3.5
Consider the atom A D p.X; Y / and the substitution  D fX=b; Y=Xg. en,
A D p.b; X/. Consider now two substitutions  D fX=Y; Y=Zg and # D fX=a; Y=b; Z=Y g.
en,  ı # D fX=b; Z=Y g.
Given two atoms A1 and A2, a uniﬁer of A1 and A2 is a substitution  such that A1 D A2.
When a uniﬁer of A1 and A2 exists, we say that A1 and A2 are uniﬁable. A uniﬁer  of A1 and A2
is called a most general uniﬁer (mgu) of A1 and A2 if it is more general than any other uniﬁer of
A1 and A2. If there exists a uniﬁer of A1 and A2, then there exists an mgu of A1 and A2. Indeed,
the mgu is unique modulo renaming of variables. ere exists an algorithm that yields an mgu
for any two atoms if they are uniﬁable and report nonexistence of a uniﬁer otherwise (for more
details, see, e.g., Lloyd [1987] and Apt [1991]).
Example 3.6
e two atoms A1 D p.X; Z/ and A2 D p.Y; a/ are uniﬁable, as, for instance, a
uniﬁer is  D fX=a; Y=a; Z=ag. A most general uniﬁer of A1 and A2 is  D fY=X; Z=ag. Notice
that  D  ı fX=ag and thus  is more general than .
In order to ﬁnd a proof for B1; : : : ; Bm, SLD resolution starts with the goal clause  
B1; : : : ; Bm; then, it iteratively derives a new goal clause from a previous goal clause (as described
in the following) until the empty goal clause is reached—when the empty goal clause is reached
the procedure is successful. Below we detail SLD resolution. Let gc be a non-empty goal clause
of the form
 B1; : : : ; Bi 1; Bi; BiC1; : : : ; Bm;
and r be a Datalog rule of the form
A0  A1; : : : ; An

3.2. SEMANTICS
23
such that gc and r have no variable in common (this can always be ensured by renaming variables
of r) and Bi, A0 have an mgu . en, the resolvent of gc and r using  is the goal clause
 .B1; : : : ; Bi 1; A1; : : : ; An; BiC1; : : : ; Bm/
and Bi is called the selected atom of gc.
Let P be a Datalog program, D a database, and gc a goal clause. An SLD derivation from gc
with PD is a sequence gc0; gc1; gc2; : : : of goal clauses and a sequence 1; 2; : : : of substitutions
such that
• gc0 D gc, and
• gci is the resolvent of gci 1 and some rule in PD using i, for i  1.
An SLD derivation can be ﬁnite or inﬁnite. An SLD refutation of gc with PD is an SLD derivation
gc; gc1; : : : ; gck from gc with PD s.t. gck D .
SLD resolution is a technique that provides proofs of atoms. An SLD refutation of a goal
clause gc of the form  B1; : : : ; Bm with PD means that from the assumption that the goal clause
gc holds in the presence of PD, we get the empty clause , which stands for a contradiction. is
can be viewed as a proof of the negation of gc from PD, that is, the proof of 9XB1 ^    ^ Bm,
where X are all variables in gc (variables X are implicitly universally quantiﬁed at the begin-
ning of gc). Moreover, an SLD refutation whose sequence of substitutions is 1; : : : ; k pro-
vides a proof of .B1 ^    ^ Bm/1 ı    ı k. Importantly, SLD resolution produces only correct
proofs (soundness) and and all true facts (completeness). More formally, let P be a program, D
a database, and gc a goal clause  B1; : : : ; Bm. If there exists an SLD refutation of gc with PD
whose substitutions are 1; : : : ; k, then PD semantically implies .B1 ^    ^ Bm/1 ı    ı k. If
PD semantically implies :gc, then there exists a refutation of gc with PD.
As SLD resolution is sound and complete, it provides an adequate top-down technique for
obtaining the ground atoms in the answer to a Datalog program. To prove that a ground atom
is in the answer, one must search for a refutation of the corresponding goal clause, and there can
be many of them. ere are two sources of nondeterminism in searching for a refutation: (i) the
choice of the selected atom and (ii) the choice of the rule whose head atom uniﬁes with the chosen
atom. Assuming a rule for choosing which atom to select at each step in a refutation (e.g., as in
Prolog, always take the leftmost atom) we can systematically search for all possible unifying rules.
It turns out that the proof-theoretic semantics gives the same set of ground atoms as the
model-theoretic and the ﬁxpoint semantics. us, a ground atom A is in the least model of a
program iﬀthere is a proof tree for A from D and P .
Example 3.7
Let D be the database and P the Datalog program of Example 3.1. Suppose we
want to ﬁnd a proof a tc.a; c/. An SLD refutation of  tc.a; c/ with PD, where the selected atom
is always the leftmost, is as follows. We start with the goal clause
 tc.a; c/:

24
3. DATALOG
e resolvent of the goal clause above and the second rule of P using  D fX=a; Y; cg is the goal
clause
 edge.a; Z/; tc.Z; c/:
e resolvent of the goal clause above and the ﬁrst fact of D using  D fZ=bg is the goal clause
 tc.b; c/:
e resolvent of the goal clause above and the ﬁrst rule of P using  D fX=b; Y=cg is the goal
clause
 edge.b; c/:
e resolvent of the goal clause above and the second fact of using the empty substitution is the
empty goal clause  and thus tc.a; c/ is successfully proven.
3.3
PROGRAM EVALUATION
In this section, we report algorithms to evaluate a Datalog program P over a database D, that is,
to compute the semantics of PD.
3.3.1
EVALUATION OF NON-RECURSIVE PROGRAMS
We start by presenting an algorithm to evaluate non-recursive Datalog programs.
e algorithm to evaluate a non-recursive program P over a database D consists of deriving
a relational algebra expression for each derived predicate symbol p of P ; the evaluation of this
expression over D yields the same answer relation for p as when P is evaluated over D. If a
program P is not recursive, then its dependency graph GP has no cycles and thus it is possible to
determine a topological sorting of the graph, that is, an ordering p1; : : : ; pn of the graph vertices
such that if .pi; pj / is an edge of GP , then pi comes before pj in the ordering. e relational
algebra expressions for the derived predicate symbols of P are computed following the order
determined by a topological sorting of GP . e expression for a predicate symbol p is obtained
by computing an expression for each rule having p in the head and then taking the union of the
expressions obtained for all rules having p in the head.
Let r be a rule of the form
A0  A1; : : : ; An;
where A0 is an atom of the form p.t1; : : : ; tm/, and, for ease of presentation, assume the ti’s are all
variables. Moreover, assume to have a relation Ri for each atom Ai in the body of r—evaluating
rules according to a topological sorting of GP ensures that we always have a relation for each atom
appearing in the body of r. If two atoms Ai and Aj have the same predicate symbol, then Ri and
Rj are the same relation. We deﬁne Eval-rule.r; R1; : : : ; Rn/ as the relational algebra expression
obtained as follows.

3.3. PROGRAM EVALUATION
25
1. Let E be the relational algebra expression F .R1      Rn/ where F is a conjunction
of conditions obtained as follows: if position k in the body of r has a constant c, then
F has the condition $k D c; if positions k and l in the body of r both contain the
same variable, then F has the condition $k D $l. As an example, if the body of r is
p1.X; Y /; p2.Y; Z; Z/; p3.X; a/, then F is $1 D $6 ^ $2 D $3 ^ $4 D $5 ^ $7 D a. No-
tice that F can be empty and in this case it is always satisﬁed by any tuple.
2. Finally, Eval-rule.r; R1; : : : ; Rn/ is the relational algebra expression V .E/ where V has m
(i.e., the arity of p) components deﬁned as follows: if the i-th term of A0 is a variable X,
then the i-th component of V is one of the positions where X appears in the body of r. As
an example, if p.X; Z/ is the head of r and the body of r is as above, then we get $1$4.E/.
us, Eval-rule.r; R1; : : : ; Rn/ gives a relational algebra expression for rule r. e relational
algebra expressions for the derived predicate symbols of a program P are obtained by considering
predicate symbols according to a topological sorting of GP and for each predicate symbol pi we
do the following.
1. For each rule r in P having pi in the head, compute a relational algebra expression E using
Eval-rule.
2. As we are following a topological sorting of GP , for each derived predicate symbol in the
body of r, there is a relational algebra expression (deﬁned using base relations only). Sub-
stitute each occurrence of a derived relation in E with the corresponding relational algebra
expression.
3. Take the union of the expressions obtained at the second step.
Example3.8
Consider again the graph database of Example 3.1 and the following non-recursive
Datalog program:
r1 W
onehop.X; Y /
 
edge.X; Y /:
r2 W
twohops.X; Y /
 
edge.X; Z/; onehop.Z; Y /:
r3 W
ans.X/
 
onehop.a; X/:
r4 W
ans.X/
 
twohops.a; X/:
Intuitively, the ﬁrst rule computes pairs .X; Y / such that Y can be reached from X by going
through one edge, while the second rule computes pairs .X; Y / such that Y can be reached from
X by going through two edges. e last two rules compute those vertices that can be reached
from vertex a by going through one or two edges.
Clearly, twohops depends on onehop, while ans depends on both onehop and twohops. us,
a topological sorting of the dependency graph is onehop; twohops; ans.

26
3. DATALOG
Denoting with Edge the edge relation, we consider the ﬁrst predicate symbol according to
the topological sorting above, namely onehop, and get
Eval-rule.r1; Edge/ D $1$2.Edge/:
Since the deﬁnition of onehop consists only of r1, then the relational algebra expression to com-
pute the relation for onehop is:
Onehop D $1$2.Edge/:
Obviously, the previous expression might be simpliﬁed into the equivalent one Onehop D Edge.
Next, considering the second predicate symbol according to the topological sorting, namely
twohops, we have
Eval-rule.r2; Edge; Onehop/ D $1$4.$2D$3.Edge  Onehop//:
Since the deﬁnition of twohops consists only of r2, the relational algebra expression for twohops
is:
Twohops D $1$4.$2D$3.Edge  $1$2.Edge///:
Finally, when we consider the last predicate symbol, namly ans, we get
Eval-rule.r3; Onehop/ D $2.$1Da.Onehop//
Eval-rule.r4; Twohops/ D $2.$1Da.Twohops//
and the relational algebra expression for ans is
Ans D $2.$1Da.$1$2.Edge/// [ $2.$1Da.$1$4.$2D$3.Edge  $1$2.Edge/////:
3.3.2
EVALUATION OF RECURSIVE PROGRAMS
In the following, we report algorithms to evaluate possibly recursive Datalog programs. Specif-
ically, we ﬁrst present a “naïve” algorithm and then an improvement of it called “semi-naïve”
algorithm (see also Abiteboul et al. [1995] and Ullman [1988]).
Algorithm Naïve
Consider a program P and a database D. Let R1; : : : ; Rk be the base relations and
P1; : : : ; Pm
the derived relations. For each derived predicate symbol pi, we deﬁne
Eval.pi; R1; : : : ; Rk; P1; : : : ; Pm/ as the result of evaluating the union of the expressions given
by Eval-rule over all rules with pi in the head.
Given a possibly recursive Datalog program P and a database D, where the base predicate
symbols are r1; : : : ; rk, the derived predicate symbols are p1; : : : ; pm, and the base relations are
R1; : : : ; Rk, the following algorithm performs the evaluation of P over D.

3.3. PROGRAM EVALUATION
27
Algorithm 1 Naive-Evaluation
1: for i WD 1 to m do
2:
Pi WD ;;
3: repeat
4:
for i WD 1 to m do
5:
P 0
i WD Pi;
6:
for i WD 1 to m do
7:
Pi WD Eval.pi; R1; : : : ; Rk; P 0
1; : : : ; P 0
m/;
8: until Pi D P 0
i for all 1  i  m
9: return P1; : : : ; Pm
e algorithm above iteratively computes Eval for every derived predicate symbol until
none of the derived relations changes anymore. At each iteration, the updated derived relations
obtained in the previous iteration are used in the computation of Eval.
One simple optimization that can be applied to the algorithm above is the following. Given
a possibly recursive Datalog program P , we ﬁrst determine the strongly connected components
of the dependency graph GP . If each strongly connected component is contracted to a single ver-
tex, the resulting graph is a directed acyclic graph G0
P . en, we apply Algorithm Naive-Evaluation
to each connected component following the order given by a topological sorting of G0
P . Apply-
ing Algorithm Naive-Evaluation to a connected component means applying the algorithm to the
subprogram of P consisting of those rules which have a predicate symbol belonging to the con-
nected component in the head, and considering the relations for predicate symbols in previous
components as base relations.
Example 3.9
Consider the database and the Datalog program of Example 3.1, which are re-
ported below for the reader’s convenience.
edge.a; b/:
edge.b; c/:
edge.c; d/:
r1 W
tc.X; Y /  edge.X; Y /:
r2 W
tc.X; Y /  edge.X; Z/; tc.Z; Y /:
Clearly, edge is the only base predicate symbol and tc is the only derived predicate symbol. Let
Edge D f.a; b/; .b; c/; .c; d/g be the base relation corresponding to predicate symbol edge. Ini-
tially, Tc D ; (lines 1–2). en, the repeat-until loop of lines 3–8 proceeds as follows.
Iteration 1:
Tc0 D Tc D ;:
Tc D Eval.tc; Edge; Tc0/ D Edge [ $1$4.$2D$3.Edge  Tc0// D
f.a; b/; .b; c/; .c; d/g

28
3. DATALOG
Iteration 2:
Tc0 D Tc D f.a; b/; .b; c/; .c; d/g:
Tc D Eval.tc; Edge; Tc0/ D Edge [ $1$4.$2D$3.Edge  Tc0// D
f.a; b/; .b; c/; .c; d/g [
f.a; c/; .b; d/g
Iteration 3:
Tc0 D Tc D f.a; b/; .b; c/; .c; d/; .a; c/; .b; d/g:
Tc D Eval.tc; Edge; Tc0/ D Edge [ $1$4.$2D$3.Edge  Tc0// D
f.a; b/; .b; c/; .c; d/g [
f.a; c/; .b; d/g [
f.a; d/g
Iteration 4:
Tc0 D Tc D f.a; b/; .b; c/; .c; d/; .a; c/; .b; d/; .a; d/g:
Tc D Eval.tc; Edge; Tc0/ D Edge [ $1$4.$2D$3.Edge  Tc0// D
f.a; b/; .b; c/; .c; d/g [
f.a; c/; .b; d/g [
f.a; d/g
As in the last iteration Tc D Tc0, the repeat-until loop terminates and the derived relation Tc is
returned.
Suppose adding the following rule to the program considered above:
reachable-from-a.X/  tc.a; X/:
With this addition, the dependency graph has two strongly connected components, one con-
sisting of tc and another one containing reachable-from-a. We can ﬁrst apply Algorithm
Naive-Evaluation to the subprogram containing the ﬁrst two rules, as detailed above. en, Al-
gorithm Naive-Evaluation can be applied to the subprogram consisting only of the last rule using
the relation Tc computed at the previous step as a base relation.
Algorithm Semi-naïve
One shortcoming of Algorithm Naive-Evaluation is that at each iteration, all tuples computed in
the previous iteration are recomputed (e.g., see Example 3.9). We now present an algorithm that
tries to overcome this ineﬃciency by incrementally computing the new relations at each iteration.
We start by introducing an incremental version of Eval-rule seen in Section 3.3.1. Consider
a rule r of the form
A0  A1; : : : ; An;
and assume to have a relation Ri and an “incremental” relation Ri for each atom Ai in the body
of r. We deﬁne the incremental version of Eval-rule as follows:
Eval-rule-incr.r; R1; : : : ; Rn; R1; : : : ; Rn/ D
S
1in Eval-rule.r; R1; : : : ; Ri 1; Ri; RiC1; : : : ; Rn/:

3.3. PROGRAM EVALUATION
29
Consider a program P
and a database D. Let R1; : : : ; Rk
be the base re-
lations
and
P1; : : : ; Pm
the
derived
relations.
For
each
Pi,
we
also
have
an
“incremental”
relation
Pi.
For
each
derived
predicate
symbol
pi,
we
deﬁne
Eval-incr.pi; R1; : : : ; Rk; P1; : : : ; Pm; P1; : : : ; Pm/ as the result of evaluating the union of
the expressions given by Eval-rule-incr over all rules with pi in the head. In the evaluation of
Eval-rule-incr, the incremental relations for base predicate symbols are the empty set.
Algorithm Seminaive-Evaluation performs the evaluation of P over D and improves over
Algorithm Naive-Evaluation by incrementally computing the derived relations.
Algorithm 2 Seminaive-Evaluation
1: for i WD 1 to m do
2:
Pi WD Eval.pi; R1; : : : ; Rk; ;; : : : ; ;/;
3:
Pi WD Pi;
4: repeat
5:
for i WD 1 to m do
6:
P 0
i WD Pi;
7:
for i WD 1 to m do
8:
Pi WD Eval-incr.pi; R1; : : : ; Rk; P1; : : : ; Pm; P 0
1; : : : ; P 0
m/;
9:
Pi WD Pi   Pi;
10:
for i WD 1 to m do
11:
Pi WD Pi [ Pi;
12: until Pi D ; for all 1  i  m
13: return P1; : : : ; Pm
Example 3.10
Consider the database and the Datalog program of Example 3.9. Once again,
Edge D f.a; b/; .b; c/; .c; d/g is the base relation corresponding to predicate symbol edge. More-
over, Edge D ; as edge is a base predicate symbol. Initially, relation Tc is computed as follows
(line 2):
Tc WD Eval.tc; Edge; ;/ D Edge [ $1$4.$2D$3.Edge  ;// D f.a; b/; .b; c/; .c; d/g:
en, Tc D Tc D f.a; b/; .b; c/; .c; d/g (line 3). Next, the repeat-until loop of lines 4–12
proceeds as follows.

30
3. DATALOG
Iteration 1:
Tc0
D
Tc D f.a; b/; .b; c/; .c; d/g:
Tc
D
Eval-incr.tc; Edge; Tc; Tc0/
D
Eval-rule-incr.r1; Edge; Edge/ [ Eval-rule-incr.r2; Edge; Tc; Edge; Tc0/
D
Eval-rule.r1; Edge/ [ Eval-rule.r2; Edge; Tc/ [ Eval-rule.r2; Edge; Tc0/
D
; [ ; [ $1$4.$2D$3.Edge  Tc0//
D
f.a; c/; .b; d/g
Tc
D
Tc   Tc D f.a; c/; .b; d/g
Tc
D
Tc [ Tc D f.a; b/; .b; c/; .c; d/; .a; c/; .b; d/g
Iteration 2:
Tc0
D
Tc D f.a; c/; .b; d/g:
Tc
D
Eval-incr.tc; Edge; Tc; Tc0/
D
Eval-rule-incr.r1; Edge; Edge/ [ Eval-rule-incr.r2; Edge; Tc; Edge; Tc0/
D
Eval-rule.r1; Edge/ [ Eval-rule.r2; Edge; Tc/ [ Eval-rule.r2; Edge; Tc0/
D
; [ ; [ $1$4.$2D$3.Edge  Tc0//
D
f.a; d/g
Tc
D
Tc   Tc D f.a; d/g
Tc
D
Tc [ Tc D f.a; b/; .b; c/; .c; d/; .a; c/; .b; d/; .a; d/g
Iteration 3:
Tc0
D
Tc D f.a; d/g:
Tc
D
Eval-incr.tc; Edge; Tc; Tc0/
D
Eval-rule-incr.r1; Edge; Edge/ [ Eval-rule-incr.r2; Edge; Tc; Edge; Tc0/
D
Eval-rule.r1; Edge/ [ Eval-rule.r2; Edge; Tc/ [ Eval-rule.r2; Edge; Tc0/
D
; [ ; [ $1$4.$2D$3.Edge  Tc0//
D
;
Tc
D
Tc   Tc D ;
Tc
D
Tc [ Tc D f.a; b/; .b; c/; .c; d/; .a; c/; .b; d/; .a; d/g
As in the last iteration Tc D ;, the repeat-until loop terminates and the derived relation
Tc is returned by Algorithm Seminaive-Evaluation.
3.4
EXPRESSIVITY AND COMPLEXITY
Recall that a query is a function that takes a database as input and gives another database as
output. Furthermore, queries have to be generic, that is, invariant under renamings of the database
domain. Queries can be expressed using query languages and the expressive power of a given query
language is measured in terms of the set of queries that can be expressed using that language.

3.4. EXPRESSIVITY AND COMPLEXITY
31
A Datalog query Q is a pair hP; Gi where P is a Datalog program and G is an atom
g.t1; : : : ; tm/, called query goal, s.t. g appears in the head of some rule in P . Let ti1; : : : ; tik be the
terms of G that are variables, where 1  i1 <    < ik  m. e answer to Q over a database D,
denoted Q.D/, is the set of all tuples of constants .c1; : : : ; ck/ s.t. the atom obtained from G by
replacing every tij with cj (1  j  k) belongs to the least model of P [ D. When k D 0 (i.e.,
the query goal is ground), the Datalog query is Boolean an returns true if G belongs to the least
model of P [ D, false otherwise.
Two Datalog queries Q and Q0 are equivalent, denoted Q  Q0, iﬀQ.D/ D Q0.D/ for
every database D.
Datalog allows us to express only monotonic queries (a monotonic query is such that if a
database D1 is a subset of a database D2, then the result of the query over D1 is a subset of the
result of the query over D2). Datalog can express only a proper subset of the queries computable
in polynomial time. Indeed, Datalog cannot even express all monotonic queries computable in
polynomial time [Afrati et al., 1995]. As already mentioned before, recursion allows Datalog to
express queries which cannot be expressed in relational algebra and calculus, such as computing
the transitive closure of a binary relation [Aho and Ullman, 1979]. Non-recursive Datalog has
the same expressive power as the fragment of relational algebra using only projection, positive
selection (i.e., selection conditions are restricted to be conjunctions of equalities), union, Cartesian
product (in other words, non-recursive Datalog can express union of conjunctive queries). Datalog
needs to be extended with negation in order to get (at least) the same expressive power as relational
algebra and safe relational calculus. We will consider negation in Chapter 4.
ere are three interesting complexity issues connected to Datalog and its extensions.
• e data complexity is the complexity of checking whether D [ P ˆ A for a ﬁxed Datalog
program P , and variable input database D and ground atoms A.
• e program complexity is the complexity of checking whether D [ P ˆ A for variable
Datalog program P and ground atoms A, and ﬁxed input database D.
• e combined complexity is the complexity of checking whether D [ P ˆ A for variable
Datalog program P , input database D, and ground atoms A.
e data complexity of Datalog is P-complete. e program and combined complexity
of Datalog are EXPTIME-complete. e data complexity of linear Datalog is NL-complete. e
program and combined complexity of linear Datalog are PSPACE-complete. e data complexity
of conjunctive queries expressed in Datalog is L, while their program and combined complexity
are NP-complete. e following table reports these results.

32
3. DATALOG
Table 3.1: e complexity of Datalog
Query Language
Data Complexity
Program and Combined Complexity
Conjunctive queries
L
NP-complete
Linear Datalog
NL-complete
PSPACE-complete
Datalog
P-complete
EXPTIME-complete
BIBLIOGRAPHIC NOTES
For early applications of logic to databases we refer to Gallaire and Minker [1978], Gallaire et al.
[1984] and Minker [1988]. An overview of logic programming and databases can be found in Ceri
et al. [1990]; see also Minker et al. [2014].
Fixpoint semantics was explored in the context of logic programming in van Emden and
Kowalski [1976] and Apt and van Emden [1982] and in the database context in Chandra and
Harel [1982].
Resolution was originally proposed in the context of automatic theorem proving [Robinson,
1965], while SLD resolution was developed in [van Emden and Kowalski, 1976]. ese form the
basis of logic programming as introduced by Kowalski [1974] (see also Kowalski [1986]).
Safety conditions on datalog programs have been studied in Kifer et al. [1988], Krishna-
murthy et al. [1988], Ramakrishnan et al. [1987], Sagiv and Vardi [1989] and Zaniolo [1986].
e seminaive evaluation of Datalog programs has been considered in several papers [Balbin
and Ramamohanarao, 1987, Bancilhon and Ramakrishnan, 1986, Fong and Ullman, 1976] and
[Paige and Schwartz, 1977].
For a more detailed treatment of Datalog we also refer to Abiteboul et al. [1995] and Ull-
man [1988].
A survey of various complexity and expressiveness results for diﬀerent forms of logic pro-
gramming can be found in Dantsin et al. [1997, 2001].

33
C H A P T E R
4
Negation
Even if Datalog provides recursion and allows us to express queries that cannot be expressed in
the relational algebra or calculus (e.g., computing the transitive closure of a graph), its expressive
power remains limited. In fact, Datalog allows us to express only a proper subset of the queries
computable in polynomial time, and only monotonic ones. Simple nonmonotonic queries, such
as checking whether the active domain of an input database has an even number of elements
or computing the diﬀerence of two relations, cannot be expressed. Indeed, Datalog cannot even
express all monotonic queries computable in polynomial time [Afrati et al., 1995].
Datalog needs to be extended with negation in order to get (at least) the same expressive
power as the relational algebra and the safe relational calculus. Negation is an important feature to
formalize common sense reasoning in knowledge representation as it enables us to express non-
monotonic queries, and thus perform nonmonotonic reasoning. e problem of ﬁnding a suitable
semantics for Datalog programs with negation has been an important and diﬃcult problem that
has received considerable attention over the years, leading to diﬀerent semantics.
In this chapter, we consider Datalog augmented with negation (in rule bodies)—the result-
ing language will be referred to as Datalog:. We start by deﬁning the general syntax of Datalog:.
en, we focus on restricted subsets of Datalog: where only a limited use of negation is allowed,
namely semipositive, stratiﬁed, and locally stratiﬁed Datalog: programs. After that, we consider
the full Datalog: language and present the stable model and the well-founded semantics. Finally,
we consider Datalog extended with a limited form of negation embedded in the choice construct.
At the end of the chapter, we also brieﬂy discuss the extension of Datalog with disjunction.
4.1
SYNTAX
In this section, the syntax of Datalog: programs is introduced.
A Datalog: rule r is of the form:
A  L1; : : : ; Ln;
where n  0, A is an atom, and the Li’s are literals (i.e., atoms or negated atoms). Function
symbols are not allowed and thus terms appearing in a Datalog: rule are constants and variables.
Once again, A is called the head of r and is denoted by head.r/; the conjunction L1; : : : ; Ln is
called the body of r and is denoted by body.r/. Comparison atoms of the form t1 op t2 are allowed
in the body, where op is a comparison predicate symbol (i.e., op 2 f; >; ; <; D; ¤g) and t1 and
t2 are terms.

34
4. NEGATION
Every rule must be safe. e safety condition presented in Section 3.1 for Datalog is gen-
eralized as follows to accommodate negation and comparison atoms. For every Datalog: rule,
every variable must be limited in the following sense:
• a variable X is limited if it appears in a positive literal of the body whose predicate symbol
is not a comparison predicate symbol;
• a variable X is limited if it appears in a comparison atom of the form X D c or c D X,
where c is a constant; and
• a variable X is limited if it appears in a comparison atom of the form X D Y or Y D X,
where Y is a limited variable.
Notice that the ﬁrst two conditions above are base cases to determine if a variable is limited, while
the last condition can be iteratively applied to determine new variables as limited.
Example 4.1
Consider the following Datalog: rule
p.X/  q.X/; :s.Y /; X D Y:
Variable X is limited because it appears in the positive body literal q.X/ and q is not a comparison
predicate symbol. en, we can conclude that Y is limited as well, because it appears in the
comparison atom X D Y and X has been determined as limited. us, the rule is safe.
A Datalog: program is a ﬁnite set of (safe) Datalog: rules. e dependency graph GP of a
Datalog: program P is deﬁned in the same way as for Datalog programs (see Section 3.1). Once
again, we use ground.P / to denote the set of all ground rules obtained from the rules of P by
replacing all variables with constants.
4.2
SEMIPOSITIVE PROGRAMS
e most restricted use of negation that we consider is semipositive Datalog:, which will be re-
ferred to as Datalog:sp. e following deﬁnition introduces Datalog:sp programs.
Deﬁnition 4.2
A Datalog: program P is semipositive if for every rule r 2 P and every negative
literal L in the body of r, the predicate symbol of L is a base predicate symbol.
Essentially, Datalog:sp allows negation to be applied only to base atoms.
Example 4.3
Consider a directed graph stored in a database by means of facts of the form
vertex.v/, meaning that v is a vertex of the graph, and facts of the form edge.v1; v2/, meaning
that there is an edge from vertex v1 to vertex v2 in the graph (obviously, vertex and edge are base
predicate symbols).

4.2. SEMIPOSITIVE PROGRAMS
35
Below is a Datalog:sp program P to compute the pairs of vertices .v1; v2/ such that the
edge from v1 to v2 does not belong to the graph:
no-edge.X1; X2/  vertex.X1/; vertex.X2/; :edge.X1; X2/:
Datalog:sp allows us to compute the diﬀerence of two (base) relations, which cannot be
expressed in Datalog. As an example, if p and q are base predicate symbols of arity 1, then the
Datalog:sp rule diff.X/  p.X/; :q.X/ computes the set-theoretic diﬀerence of p and q. No-
tice that even in the presence of this limited form of negation the existence of a unique mini-
mal model, which is the case for Datalog programs, is no longer guaranteed. For instance, if we
consider the Datalog:sp program P consisting of the aforementioned rule and the database D
consisting only of the fact p.a/, then PD has two minimal models, namely fp.a/; diff.a/g and
fp.a/; q.a/g—intuitively, only the former is the intended one and, indeed, is the one assigned by
the semantics presented below.
e semantics of a Datalog:sp program P and a database D is given by the semantics of
the Datalog program P 0 and the database D0 obtained as follows.
• Program P 0 is obtained from P by eliminating negation in the following way: each negative
literal :p.t1; : : : ; tn/ in the body of a rule is replaced with a positive literal p0.t1; : : : ; tn/.
• Database D0 is obtained by adding to D, for each base predicate symbol p, a new relation
whose predicate symbol is p0 and which is deﬁned as the complement (w.r.t. the Herbrand
universe of PD) of the relation in D for p.
Basically, a ground negative literal :A is interpreted as true if A does not belong to D,
otherwise it is interpreted as false.
Example 4.4
Consider the Datalog:sp program P of Example 4.3 and suppose we are given a
database D containing the following facts:
edge.a; b/:
vertex.a/:
edge.b; b/:
vertex.b/:
edge.b; c/:
vertex.c/:
edge.c; b/:
e semantics of P and D is given by the Datalog program P 0 consisting of the following rule:
no-edge.X1; X2/  vertex.X1/; vertex.X2/; edge0.X1; X2/

36
4. NEGATION
and the database D0 obtained by adding the following facts to D
edge0.a; a/;
edge0.a; c/;
edge0.b; a/;
edge0.c; a/;
edge0.c; c/:
en, the no-edge-atoms that can be derived are
no-edge.a; a/;
no-edge.a; c/;
no-edge.b; a/;
no-edge.c; a/;
no-edge.c; c/:
Datalog:sp is strictly more expressive than Datalog. For instance, the diﬀerence of two
relations can be expressed in Datalog:sp but not in Datalog. Datalog:sp queries can be evaluated
in polynomial time (data complexity).
4.3
STRATIFIED PROGRAMS
We now present a natural generalization of semipositive Datalog: called stratiﬁed Datalog: [Apt
et al., 1988, Chandra and Harel, 1985, Lifschitz, 1988, Van Gelder, 1989]. Stratiﬁed Datalog:
programs restrict the manner in which recursion and negation may occur together.
First, we need to introduce some additional notions. Let P be a Datalog: program. A
partition S1; : : : ; Sm of the set of predicate symbols in P , where the Si’s are called strata, and Sj
is lower than Sk if j < k, is a stratiﬁcation of P iﬀthe following condition holds for every rule in
P :
1. if p is the head predicate symbol and q is the predicate symbol of a positive body literal,
then q belongs to a stratum lower than or equal to the stratum of p; and
2. if p is the head predicate symbol and q is the predicate symbol of a negative body literal,
then q belongs to a stratum lower than the stratum of p.
Stratiﬁed Datalog programs are deﬁned as follows.
Deﬁnition 4.5
A Datalog: program P is stratiﬁed if it has a stratiﬁcation.
We will refer to stratiﬁed Datalog: also as Datalog:s. It is worth noting that there can be
diﬀerent stratiﬁcations for a Datalog:s program.
Example 4.6
Consider again a directed graph stored in a database by means of facts of the form
vertex.v/ and edge.v1; v2/. e following Datalog: program P computes the pairs of vertices

4.3. STRATIFIED PROGRAMS
37
.v1; v2/ for which there is no path from v1 to v2 in the graph.
r1 W
tc.X; Y /
 
edge.X; Y /:
r2 W
tc.X; Y /
 
edge.X; Z/; tc.Z; Y /:
r3 W
non-reachable.X1; X2/
 
vertex.X1/; vertex.X2/; :tc.X1; X2/:
As negation is applied to the derived atom tc.X1; X2/ in the third rule, P is not semipositive.
However, P is stratiﬁed. In fact, a possible stratiﬁcation is given by S1 D fvertex; edge; tcg
and S2 D fnon-reachableg. Notice that there exist other stratiﬁcations. For instance, another
stratiﬁcation is given by S1 D fvertex; edgeg, S2 D ftcg, and S3 D fnon-reachableg. Because of
rule r3, in any stratiﬁcation, the stratum of tc must be lower than the stratum of non-reachable.
An equivalent deﬁnition of Datalog:s programs can be given by imposing some restrictions
on the structure of the dependency graph associated with a Datalog: program. Speciﬁcally, a
Datalog: program P is stratiﬁed iﬀevery rule r in P satisﬁes the following condition: if p is the
head predicate symbol, then for every derived predicate symbol q appearing in a negative literal
of the body of r, there is no path in GP from p to q. us, the condition above prevents recursion
through negation.
Clearly, non-recursive Datalog: programs are always stratiﬁed. Moreover, Datalog:sp pro-
grams are stratiﬁed as well.
We now deﬁne the semantics of Datalog:s programs in terms of the iterated ﬁxed point
model. Consider a Datalog:s program P and a database D. First of all, we generalize the imme-
diate consequence operator TPD (cf. Section 3.2.2) to deal with negative literals in rule bodies.
Given a set I of ground atoms, then
TPD.I/ D fA0 j A0  A1; : : : ; Ak; :AkC1; : : : ; :An is a ground rule in ground.PD/; and
Ai 2 I for every 1  i  k; and
Ai 62 I for every k C 1  i  ng:
A stratiﬁcation S1; : : : ; Sm of P induces a partition of P into m sets P1; : : : ; Pm such that
Pi consists of the rules of P deﬁning the predicate symbols in Si. Let
M1 D T !
P1[D.;/;
M2 D M1 [ T !
P2.M1/;
:::
Mm D Mm 1 [ T !
Pm.Mm 1/:
en, Mm is an iterated ﬁxed point model of P . Even if there might be diﬀerent stratiﬁcations for
a Datalog:s program, they all yield the same iterated ﬁxed point model, which is thus unique for
any Datalog:s program.
Example 4.7
Consider the Datalog:s program P of Example 4.6 and the stratiﬁcation consist-
ing of S1 D fvertex; edge; tcg and S2 D fnon-reachableg. e partition of P determined by such

38
4. NEGATION
a stratiﬁcation is P1 D fr1; r2g and P2 D fr3g. Suppose we are given a database D containing the
following facts:
edge.a; b/:
vertex.a/:
edge.b; b/:
vertex.b/:
edge.b; c/:
vertex.c/:
edge.c; b/:
en,
M1
D
T !
P1[D.;/ D D [ ftc.a; b/; tc.a; c/; tc.b; b/; tc.b; c/; tc.c; b/; tc.c; c/g;
M2
D
M1 [ T !
P2.M1/ D
D
M1 [ fnon-reachable.a; a/; non-reachable.b; a/; non-reachable.c; a/g:
e iterated ﬁxed point model of PD is M2.
While in Datalog:sp negation is restricted only to base atoms, in Datalog:s negation can be
applied also to derived atoms (in a restricted way, though). e existence of stratiﬁcations allows
us to choose one of them and evaluate the induced subprograms following the order dictated
by the stratiﬁcation. When evaluating a subprogram Pi, predicate symbols deﬁned by rules in
subprograms that have been already evaluated (i.e., those subprograms Pj with j < i) can be
seen as base predicate symbols—thus, in this sense, Pi can be seen as a semipositive program.
e computation of the iterated ﬁxed point model can be carried out by computing each
Mi by means of the algorithms presented in Chapter 3, with the only diﬀerence being how the
relations corresponding to negative body literals are deﬁned. In this regard, consider a predicate
symbol q and let Q be the corresponding relation computed after the stratum of q has been
processed. When Evalrule (cf. Section 3.3) is called for a rule having a negative body literal of
the form :q.t1; : : : ; tk/, the relation for such a negative literal is deﬁned as .Dom/k   Q, where
Dom is the set of constants appearing in PD.
From the discussion above, it is easy to see that the computation of the iterated ﬁxed point
model can be carried out in polynomial time in the data complexity; indeed, the data complexity
of Datalog:s is P-complete [Apt et al., 1988].
Datalog:s is strictly more expressive than Datalog:sp [Abiteboul et al., 1995]. Datalog:s
without recursion has the same expressive power as the relational algebra and the safe relational
calculus [Abiteboul et al., 1995]. us, Datalog:s (with recursion allowed) is strictly more expres-
sive than the relational algebra and the safe relational calculus (e.g., it can express the transitive
closure of a graph, which cannot be expressed using the other two languages).

4.4. LOCALLY STRATIFIED PROGRAMS
39
4.4
LOCALLY STRATIFIED PROGRAMS
Locally stratiﬁed programs, originally introduced by Przymusinski [1988], generalize stratiﬁed
programs. e basic idea is illustrated in the following example.
Example 4.8
Consider the following Datalog: program:
p.a/  :p.c/:
p.b/  :p.c/:
It is easy to check that the program is not stratiﬁed, since predicate symbol p depends on it-
self “through negation.” If the program had been written as below, using three diﬀerent (0-ary)
predicate symbols pa, pb, pc rather than a single one, it would be stratiﬁed:
pa  :pc:
pb  :pc:
is example suggests that we might use a more ﬁne-grained version of the Datalog:s
condition, looking for a stratiﬁcation of ground atoms rather than a stratiﬁcation of predicate
symbols—this is the basic idea of locally stratiﬁed programs, which are formally deﬁned as follows.
Deﬁnition 4.9
Let P be a Datalog: program. A partition B1; : : : ; Bm of the Herbrand base
BP , where the Bi’s are called local strata and Bj is lower than Bk if j < k, is a local stratiﬁcation
of P iﬀthe following condition holds for every ground rule in ground.P /:
1. if H is the head atom and A is a positive body literal, then A belongs to a local stratum
lower than or equal to the local stratum of H; and
2. if H is the head atom and :A is a negative body literal, then A belongs to a local stratum
lower than the local stratum of H.
We say that P is locally stratiﬁed if admits a local stratiﬁcation.
e class of locally stratiﬁed Datalog: programs will be also referred to as Datalog:ls.
ere is a simple analogy between stratiﬁcation of Datalog:s programs and local stratiﬁcation
of Datalog:ls programs: the latter treats ground atoms and ground rules in the same way as the
former treats predicate symbols and arbitrary rules.
Example 4.10
Consider again the Datalog: program of Example 4.8, whose Herbrand base is
fp.a/; p.b/; p.c/g. e program is locally stratiﬁed as B1 D fp.c/g and B2 D fp.a/; p.b/g form
a local stratiﬁcation.
Similar to Datalog:s programs, for a locally stratiﬁed program there can be diﬀerent local
stratiﬁcations. For instance, B1 D fp.c/g, B2 D fp.a/g, and B3 D fp.b/g is another local strat-
iﬁcation of the Datalog: program of Example 4.8.

40
4. NEGATION
Datalog:ls programs can be equivalently deﬁned using a “ground version” of the depen-
dency graph. More precisely, given a Datalog: program P , the ground dependency graph of P is
a directed graph whose nodes are the ground atoms in the Herbrand base BP of P . ere is an
edge from a ground atom A to a ground atom H iﬀthere is a rule in ground.P / whose head is H
and one of the body literals is either A or :A. A Datalog: program is locally stratiﬁed iﬀevery
ground rule r in ground.P / satisﬁes the following condition: if H is the head atom, then for every
negative literal :A in the body of r, there is no path in the ground dependency graph from H to
A.
We now deﬁne the semantics of Datalog:ls programs. Consider a Datalog: program P
and a database D such that PD is locally stratiﬁed. e semantics of P and D is given by the
perfect model deﬁned as follows. Let B1; : : : ; Bm be a local stratiﬁcation of PD and P1; : : : ; Pm
be the partition of ground.PD/ such that Pi consists of the rules of ground.P / whose head atom
is in Bi. Similar to stratiﬁed programs, we deﬁne
M1 D T !
P1[D.;/;
M2 D M1 [ T !
P2.M1/;
:::
Mm D Mm 1 [ T !
Pm.Mm 1/:
en, Mm is the perfect model of P . Even if PD can have diﬀerent local stratiﬁcations, they all
yield the same perfect model, which is thus unique for any Datalog:ls program.
Notice that in the deﬁnition of a perfect model above, the more general deﬁnition of the
immediate consequence operator is used (cf. Section 4.3), that is, the one which deals with neg-
ative literals in rule bodies.
Example 4.11
Consider the Datalog:ls program of Example 4.8 and the local stratiﬁcation
consisting of the local strata B1 D fp.c/g, B2 D fp.a/g, and B3 D fp.b/g.
en,
P1 D ;;
P2 D fp.a/  :p.c/:g; and
P3 D fp.b/  :p.c/:g
and
M1 D ;;
M2 D fp.a/g; and
M3 D fp.a/; p.b/g:
us, the perfect model is M3.
In a sense, compared with stratiﬁed Datalog: programs, locally stratiﬁed Datalog: pro-
grams allow us to handle situations where recursion through negation is apparent, but not real,
as in the previous example, where a natural semantics can be given to the program.

4.5. UNSTRATIFIED NEGATION
41
We notice that the notion of a perfect model has been proposed by Przymusinski [1988,
1989] for a class of Datalog: programs more general than Datalog:ls programs.
Every Datalog:s program is locally stratiﬁed and its iterated ﬁxed point model coincides
with its perfect model. Note that a Datalog: program is stratiﬁed if all ground atoms with the
same predicate symbol can be assigned the same local stratum Bi.
e data complexity of locally stratiﬁed Datalog: programs is still polynomial time.
4.5
UNSTRATIFIED NEGATION
In the previous sections we considered subclasses of Datalog: by imposing restrictions on the use
of negation, with the more general subclass being Datalog:ls. ere are Datalog: programs that
are not locally stratiﬁed and for which we cannot rely on the semantics previously discussed.
In this section, we remove any limitation on the use of negation and thus consider the full
Datalog: language. We present two diﬀerent semantics for Datalog: programs, namely the stable
model semantics and the well-founded semantics, which both generalize the semantics discussed so
far.¹
4.5.1
STABLE MODEL SEMANTICS
e stable model semantics has been proposed by Gelfond and Lifschitz [1988]. It is more general
than the perfect model semantics of Datalog:ls programs and is applicable to Datalog: programs
that are not locally stratiﬁed.
Consider a Datalog: program P and a database D. As usual, the Herbrand universe HPD
of PD is the set of constants appearing in PD, the Herbrand base BPD of PD is the set of ground
atoms which can be built using predicate symbols appearing in PD and constants in HPD, and
an interpretation of PD is any subset of BPD.
Given an interpretation I of PD, let PDI denote the ground Datalog program derived
from ground.PD/ by deleting
• every rule that contains a negative literal :A in its body with A 2 I, and
• all negative literals in the bodies of the remaining rules.
An interpretation I of PD is a stable model of PD if and only if I is the least model of
PDI—notice that PDI has a (unique) least model as it is a Datalog program, cf. Section 3.2.1.
Example 4.12
[Gelfond and Lifschitz, 1988] Consider the following Datalog: program P
q.X/  p.X; Y /; :q.Y /
¹Other interesting semantics for Datalog: programs have been proposed, see the bibliographic notes of this chapter.

42
4. NEGATION
and a database D containing only the fact p.1; 2/. Here p is a base predicate symbol and q is a
derived one. Clearly, PD is as follows:
p.1; 2/:
q.1/  p.1; 2/; :q.2/:
q.1/  p.1; 1/; :q.1/:
q.2/  p.2; 2/; :q.2/:
q.2/  p.2; 1/; :q.1/:
Notice that PD is not locally stratiﬁed.
Consider the interpretation I1 D fq.2/g. en, PDI1 is the following Datalog program
p.1; 2/:
q.1/  p.1; 1/:
q.2/  p.2; 1/:
whose least model is fp.1; 2/g, which is diﬀerent from I1. Hence, I1 is not a stable model.
Consider now the interpretation I2 D fp.1; 2/; q.1/g. en, PDI2 is the following Datalog
program
p.1; 2/:
q.1/  p.1; 2/:
q.2/  p.2; 2/:
whose least model is I2. Hence, I2 is a stable model. Indeed, I2 is the only stable model of P .
e underlying idea of the stable model semantics is the following. If an interpretation I is
the set of ground atoms that are considered to be true, then any rule having a negative literal :A in
its body with A 2 I is useless and any negative literal :A with A 62 I is trivial. en, ground.PD/
can be simpliﬁed into PDI. If I happens to be precisely the set of atoms that logically follow
from the simpliﬁed program PDI, then I is a stable model. us, in a sense, a stable model is
able to “reproduce” itself.
A Datalog: program can have zero, one, or many stable models. As an example, the
Datalog: program consisting only of the rule p  :p has no stable models. e Datalog: pro-
gram consisting of the two rules p  :q and q  :q has two stable models, namely fpg and
fqg.
Stable models are minimal models. Furthermore, the stable model semantics generalizes
all the semantics considered in the previous sections. Hence, locally stratiﬁed Datalog: programs
have a unique stable model which is equal to the perfect model. Obviously, since the perfect
model semantics restricted to stratiﬁed Datalog: programs coincides with the iterated ﬁxed point
semantics, we can also conclude that a stratiﬁed Datalog: program has a unique stable model
which is identical to its iterated ﬁxed point model.
Notice that when we consider Datalog programs, PDI coincides with ground.PD/ for every
interpretation I and thus the only interpretation that is a stable model is the the least model of
PD.

4.5. UNSTRATIFIED NEGATION
43
e data complexity of Datalog: under the stable model semantics is co-NP-complete and
the program complexity is co-NEXPTIME-complete [Dantsin et al., 2001, Kolaitis and Papadim-
itriou, 1991, Marek and Truszczynski, 1991, Schlipf, 1995]. Marek and Truszczynski [1991]
showed that even for a propositional (i.e., all predicate symbols have arity 0 and thus there are no
variables) Datalog: program, checking whether it has a stable model is NP-complete.
Datalog: under the stable model semantics is able to express exactly all queries whose
evaluation complexity is in co-NP [Schlipf, 1995].²
4.5.2
WELL-FOUNDED SEMANTICS
e well-founded semantics has been proposed by Van Gelder et al. [1988, 1991].
In the semantics considered so far, a stable model provides a truth value for every atom in
the Herbrand base of a given program, provided that a semantics can be assigned to the considered
program (e.g., the Datalog: program p  :p has no stable models). e well-founded semantics
is based on the idea that a program may not necessarily provide such information for all ground
atoms, and thus the truth value of some ground atoms can be unknown. Such a relaxation allows
the well-founded semantics to assign a natural semantics to all Datalog: programs (including,
for instance, the program consisting of the rule p  :p, for which no stable model exists). e
price to pay is that total information is no longer guaranteed, that is, there might be ground atoms
whose truth value is unknown.
In a sense, the well-founded semantics tries to give a reasonable meaning to as much of
the program as possible in the unfavorable cases, when only a partial model exists (i.e., the truth
values of some ground atoms is unknown), as an extension of the semantics for the favorable cases,
which have a total model (i.e., the truth value of every ground atom is known—it is either true
or false).
Another aspect of the well-founded semantics is that it treats negative and positive literals
in a more uniform way in the following sense. One can no longer assume that :A is true simply
because A is not inferred. Instead, both negative and positive literals must be inferred.
Roughly speaking, another way of looking at the well-founded semantics is that it assigns
value “unknown” to an atom if it is deﬁned by unstratiﬁed negation.
Before formally deﬁning the well-founded semantics, we introduce some needed notation
and terminology. A positive literal A and the negative literal :A, where A is an atom, are said to
be complements of each other. We say that a set of literals is consistent if it does not contain both a
literal and its complement. Given a set of literals U , we use :U to denote the set of literals built
by taking the complement of each literal in U .
Let P be a Datalog: program and D a database. A partial interpretation I of PD is a
consistent set of ground literals whose atoms are taken from the Herbrand base BPD. A total
interpretation is a partial interpretation that contains every atom of BPD or its negation.
²e evaluation complexity of a query is the complexity of checking whether a given atom belongs to the query result, or, in
the case of Boolean queries, whether the query evaluates to true.

44
4. NEGATION
A ground literal L is true w.r.t. I if L is in I and false if its complement is in I.
A conjunction of ground literals is true w.r.t. I if all its literals are true w.r.t. I, and is false
w.r.t. I if any of its literals is false w.r.t. I.
We say that a ground rule r is
• satisﬁed w.r.t. I if the head is true w.r.t. I or some body literal is false w.r.t. I,
• falsiﬁed w.r.t. I if the head is false w.r.t. I and all body literals are true w.r.t. I, and
• weakly falsiﬁed w.r.t. I if the head is false w.r.t. I but no body literal is false w.r.t. I.
A total model of PD is a total interpretation of PD such that every ground rule in
ground.PD/ is satisﬁed.
A partial model of PD is a partial interpretation of PD that can be extended to a total model
of PD. us, for a partial model, there might be some ground rules that are not satisﬁed, but all
rules can be satisﬁed by adding some ground literals to the partial model (the resulting set of
literals must be consistent). Clearly, this is impossible if the partial model falsiﬁes a ground rule
in ground.PD/. If the partial interpretation only weakly falsiﬁes a ground rule, then the addition
of some literal may be necessary to satisfy the rule.
Intuitively, a partial interpretation I says that the truth value of each atom A 2 I is true,
the truth value of each atom A s.t. :A 2 I is false, and the truth value of other atoms is unknown.
us, a partial interpretation may contain incomplete information. e natural ordering on partial
interpretations is . Given two partial interpretations I and I 0, if I  I 0 then I 0 contains all the
information in I, both positive and negative, and possibly more.
We now present the important notion of an unfounded set.
Deﬁnition 4.13
Let P be a Datalog: program and D a database. A subset U of the Herbrand
base BPD is an unfounded set w.r.t. a partial interpretation I of PD if each atom A 2 U satisﬁes
the following condition: for every ground rule in ground.PD/ whose head is A, at least one of the
following conditions hold:
1. some (positive or negative) body literal is false w.r.t. I and
2. some positive body literal belongs to U .
Intuitively, we can look at I as what we already know about the intended model of PD
(possibly partial). Rules satisfying the ﬁrst condition above cannot be used to infer anything as
their bodies are false w.r.t. I. e second condition above is the unfoundedness condition: of all
the rules that still might be usable to derive something in the set U , each requires an atom in U
to be true. In other words, there is no one atom in U that can be ﬁrst to be established as true by
the rules of PD (starting from knowing I). Consequently, if we choose to infer that some or all
atoms in U are false, there is no way we could later have to infer one to be true.

4.5. UNSTRATIFIED NEGATION
45
e well-founded semantics uses the two aforementioned conditions to draw negative con-
clusions. Essentially, it simultaneously infers all atoms in U to be false.
Example 4.14
[Van Gelder et al., 1991] Consider the following (ground) Datalog: program:
p.a/  p.c/; :p.b/:
p.b/  :p.a/:
p.e/  :p.d/:
p.c/:
p.d/  q.a/; :q.b/:
p.d/  q.b/; :q.c/:
q.a/  p.d/:
q.b/  q.a/:
e set U D fp.d/; q.a/; q.b/; q.c/g is an unfounded set with respect to the partial interpretation
;. In particular, there is no rule with q.c/ in the head so the condition in Deﬁnition 4.13 is trivially
satisﬁed for q.c/. For each of p.d/, q.a/, and q.b/, the second condition of Deﬁnition 4.13 applies
as there is no way to establish p.d/ as true without ﬁrst establishing q.a/ or q.b/ as true, there
is no way to establish q.a/ as true without ﬁrst establishing p.d/ as true, and likewise for q.b/.
Clearly, q.c/ can never be proven, but we can also see that among p.d/, q.a/, and q.b/, none can
be the ﬁrst one to be proven.
In contrast, it can be easily veriﬁed that fp.a/; p.b/g is not an unfounded set with respect
to the partial interpretation ;.
It is easy to see that the union of arbitrary unfounded sets is an unfounded set. Given
a Datalog: program P and a database D, the greatest unfounded set with respect to a partial
interpretation I, denoted UPD.I/, is the union of all sets that are unfounded with respect to I.
We now introduce three operators that will be used to deﬁne the well-founded semantics.
Deﬁnition 4.15
Let P be a Datalog: program, D a database, and I a partial interpretation
of PD. We deﬁne the operators TPD, UPD, WPD, which take a set of literals and return a set of
literals, as follows:
• a ground atom A belongs to TPD.I/ iﬀthere is some ground rule in ground.PD/ whose
head is A and such that every body literal is true w.r.t. I;
• UPD.I/ is the greatest unfounded set with respect to I; and
• WPD.I/ D TPD.I/ [ :UPD.I/.
Intuitively, given a partial interpretation I (which can be seen as what we already know
about the intended model of PD), TPD.I/ infers ground atoms that are established as true,

46
4. NEGATION
UPD.I/ infers ground atoms that can be established as false, and WPD simply combines the result
of the two operators. It is easy to see that the three operators are monotone.
Notice that when the TPD.I/ operator is applied and we want to determine whether we
can infer the head atom of a ground rule r, to decide whether a negative literal :A in the body of
r is true w.r.t. I, the presence of :A in I is required. is is diﬀerent from other semantics that
look for the absence of A from I—see, e.g., the more general version (able to deal with negative
body literals) of the immediate consequence operator TPD reported in Section 4.3.
Deﬁnition 4.16
Consider a Datalog: program P and a database D. We deﬁne the sets I and
I 1, whose elements are ground literals built from the atoms in the Herbrand base of PD, as
follows:
1. I0 D ;;
2. IC1 D WPD.I/, for   0; and
3. I 1 D S

I .
We are now ready to deﬁne the well-founded semantics.
Deﬁnition 4.17
Consider a Datalog: program P and a database D. e well-founded semantics
of PD is given by the least ﬁxed point of WPD (or the limit I 1).
Indeed, the least ﬁxed point of WPD is a partial model, and is called well-founded model.
e well-founded model is unique and always exists, in contrast to the stable model semantics for
which there exist Datalog: programs that have no stable models.
Every positive literal in the well-founded model denotes that its atom is true, every nega-
tive literal denotes that its atom is false, and missing atoms have no truth value assigned by the
semantics.
e well-founded semantics coincides with the perfect model semantics on locally stratiﬁed
Datalog: programs (thus, it also coincides with the stable model semantics on such programs).
us, for locally stratiﬁed Datalog: programs the well-founded model is total. Furthermore, there
are Datalog: programs that are not locally stratiﬁed but have a total well-founded model. For
instance, considering the Datalog: program P and the database D of Example 4.12, we have
that PD is not locally stratiﬁed but it has a total well-founded model, which is the unique stable
model of PD (see Example 4.12).
While stratiﬁcation is a syntactic property of a Datalog: program, for an unstratiﬁed
Datalog: program, whether it has a total well-founded model depends in general on the database.
For arbitrary Datalog: programs (thus, beyond locally stratiﬁed ones) the relation between
the stable model and the well-founded semantics has been investigated in [Van Gelder et al.,
1991]. If a Datalog: program has a total well-founded model, then that model is the unique
stable model of the program. However, the converse does not hold, that is, there are programs

4.6. CHOICE
47
that do not have a total well-founded model but do have a unique stable model, as shown in the
following example.
Example 4.18
[Van Gelder et al., 1991] Consider the following Datalog: program P :
a  :b:
b  :a:
p  :p:
ere exist two minimal models for P , namely fa; pg and fb; pg. It can be easily veriﬁed that P
has no stable model while its well-founded model is ;, which is not total.
Consider now the Datalog: program P 0 obtained by adding the following rule to P
p  :b:
en, P 0 has a unique stable model, namely fa; pg while its well-founded model is still the empty
set. In a sense, the addition of the aforementioned rule to P “stabilizes” one of the two minimal
models of P .
Below is another example reporting a Datalog: program that has a unique stable model
but does not have a total well-founded model.
Example 4.19
[Van Gelder et al., 1991] Consider the following Datalog: program P :
a  :b:
b  :a:
c  a; b:
a  :c:
e well-founded model of P is the empty set, while its unique stable model is fag.
e well-founded model of a Datalog: program P is a subset of every stable model of
P [Van Gelder et al., 1991].³
e data complexity of the well-founded semantics is P-complete, while the program com-
plexity is EXPTIME-complete [Dantsin et al., 2001, Van Gelder et al., 1991].
4.6
CHOICE
In this section, we extend Datalog with the choice construct [Giannotti et al., 1991, 2001, Saccà
and Zaniolo, 1990].⁴ e choice construct allows us to get an increase in expressive power and to
³In Section 4.5.1 we represented stable models as subsets of the Herbrand base BPD, and thus they are sets of atoms; here it
is assumed that a stable model M can be seen as the set of literals M [ :.BPD n M/.
⁴A choice construct called static choice was considered by Krishnamurthy and Naqvi [1988] and Naqvi and Tsur [1989]. A
diﬀerent choice construct called dynamic choice was considered in Giannotti et al. [1991, 2001], Saccà and Zaniolo [1990]. In
this section, we consider the dynamic choice and call it simply choice.

48
4. NEGATION
obtain simple declarative formulations of classical combinatorial problems, such as those which
can be solved by means of greedy algorithms [Greco and Zaniolo, 2001]. e declarative seman-
tics of the choice construct is given in terms of Datalog: rules, so augmenting Datalog with the
choice means introducing a restricted form a negation (embedded in the choice construct).
We also discuss the choice-least and choice-most constructs [Greco and Zaniolo, 2001],
which specialize the choice construct so as to force greedy selections among alternative choices—
these turn out to be particularly useful to express classical greedy algorithms.
4.6.1
SYNTAX
We start by introducing the basic idea of the choice construct with an example.
Example 4.20
Consider a database schema fstudent.Name; Major; Year/; professor.Name;
Major/g and a university database over such a schema containing the following facts:
student.john; ee; senior/:
professor.ohm; ee/:
professor.bell; ee/:
Also, suppose that the major of a student must match his/her advisor’s major area of spe-
cialization. en, eligible advisors can be computed with the following rule:
elig_adv.S; A/  student.S; M; Y /; professor.A; M/
which yields elig_adv.john; ohm/ and elig_adv.john; bell/.
Now, suppose we want to enforce that a student can have only one advisor. is can be
obtained by adding the atom choice..S/; .A// in the body of the rule above, which forces the
selection of a unique advisor, out of the eligible advisors, for a student. e resulting rule is:
actual_adv.S; A/  student.S; M; Y /; professor.A; M/; choice..S/; .A//:
Intuitively, the rule above forces each student S to be associated with a unique professor A.
e goal choice..S/; .A// can also be viewed as enforcing the functional dependency S ! A
on the set of atoms derived by means of the rule; thus, in actual_adv, the second column (professor
name) is functionally dependent on the ﬁrst one (student name).
e result of executing the rule is nondeterministic: it can give either actual_adv.john; ohm/
or actual_adv.john; bell/.
Choice rules and programs are deﬁned as follows.
Deﬁnition 4.21
A choice rule is of the form:
A  B.Z/; choice..X1/; .Y 1//; : : : ; choice..Xk/; .Y k//;

4.6. CHOICE
49
where k > 0, A is an atom whose variables appear in Z,⁵ B.Z/ is a conjunction of atoms, Z is
a list of the variables occurring in B.Z/, Xi, and Y i are lists of variables such that Xi \ Y i D ;
and Xi; Y i  Z, for all 1  i  k.
A choice program is a ﬁnite set of Datalog rules and choice rules.
In a choice rule of the form reported in the preceding deﬁnition, each of the
choice..Xi/; .Y i//’s is called choice atom.
In this section, we are interested in choice programs having at least one choice rule—in
fact, when this is not the case, we are dealing with simple Datalog programs. us, in the rest of
this section, a choice program is understood to have at least one choice rule.
4.6.2
STABLE-MODEL DECLARATIVE SEMANTICS
e semantics of a choice program P is deﬁned in terms of the stable model semantics of a
Datalog: program derived from P , called ﬁrst-order equivalent of P . In the following deﬁnition,
we use ı to denote the operator that concatenates (ordered) lists of variables.
Deﬁnition 4.22
Given a choice program P , the ﬁrst-order equivalent of P , denoted foe.P /, is
the Datalog: program obtained from P by replacing every choice rule r of the form
A  B.Z/; choice..X1/; .Y 1//; : : : ; choice..Xk/; .Y k//
with the following set of rules:
A
 
B.Z/; chosenr.X; Y /:
chosenr.X; Y /
 
B.Z/; :diff_choicer.X; Y /:
diff_choicer.X; Y 1; : : : ; Y k/
 
chosenr.X; Y
0
1; : : : ; Y
0
k/; Y i ¤ Y
0
i:
8i 2 Œ1; k;
where X D X1 ı    ı Xk, Y D Y 1 ı    ı Y k, and Y
0
i is the list of variables obtained by “priming”
every variable in Y i. Moreover, the intended meaning of Y i ¤ Y
0
i is that it is true if Y ¤ Y 0 is
true for some variable Y 2 Y i and its primed counterpart Y 0.⁶
Deﬁnition 4.23
e semantics of a choice program P and a database D is given by the stable
models of foe.P / [ D, which are called choice models of PD.
Example 4.24
Consider the choice program P consisting only of the following choice rule r
(taken from Example 4.20):
actual_adv.S; A/  student.S; M; Y /; professor.A; M/; choice..S/; .A//:
⁵is is a safety condition.
⁶Notice that the last kind of rules does not satisfy the safety condition as variables Y i are not limited (cf. Section 4.1). However,
such rules might be made safe by adding a suitable atom d.Y i/ in the rule body which dictates what are the values that variables
Y i can take.

50
4. NEGATION
e ﬁrst-order equivalent of P is reported below (it can be read as a statement that a professor
will be assigned to a student with the same major whenever a diﬀerent professor has not been
assigned to the same student):
actual_adv.S; A/
 
student.S; M; Y /; professor.A; M/; chosenr.S; A/:
chosenr.S; A/
 
student.S; M; Y /; professor.A; M/; :diff_choicer.S; A/:
diff_choicer.S; A/
 
chosenr.S; A0/; A ¤ A0:
Consider now the following database D (taken again from Example 4.20)
student.john; ee; senior/:
professor.ohm; ee/:
professor.bell; ee/:
en, PD has two choice models whose actual_adv-atoms are factual_adv.john; ohm/g and
factual_adv.john; bell/g, respectively.
e body of a choice rule may contain a choice atom of the form choice../; X//, that is, the
ﬁrst argument is the empty list. e intuitive meaning is that a unique value for X is nondeter-
ministically chosen. is kind of choice atom is illustrated in the following example.
Example 4.25
Consider again the university database schema of Example 4.20 and suppose we
are given the following database D:
student.john; ee; senior/:
student.alice; ee; senior/:
professor.ohm; ee/:
professor.bell; ee/:
Let P be the choice program consisting of the following choice rule r
adv.S; A/  student.S; M1; Y /; professor.A; M2/; choice../; .A//:
is choice rule assigns to all students the same (nondeterministically chosen) advisor A and thus
the adv relation will contain a single professor. en, PD has two choice models whose adv-atoms
are fadv.john; ohm/; adv.alice; ohm/g and fadv.john; bell/; adv.alice; bell/g, respectively.
Notice also that that the ﬁrst-order equivalent of P is the following Datalog: program
adv.S; A/
 
student.S; M1; Y /; professor.A; M2/; chosenr.A/:
chosenr.S; A/
 
student.S; M1; Y /; professor.A; M2/; :diff_choicer.A/:
diff_choicer.A/
 
chosenr.A0/; A ¤ A0:
In general, program foe.P / has the following properties [Giannotti et al., 2001]:

4.6. CHOICE
51
• foe.P / has one or more stable models and
• the chosenr atoms in each stable model of foe.P / obey the functional dependencies deﬁned
by the choice atoms.
It is worth noting that the functional dependency enforced by a choice atom in the body
of a choice rule r is “local” to r, that is, what is derived through the application of r must satisfy
the functional dependency; however, there might be some other rules in the considered program
that allow us to derive atoms that violate the functional dependency. is aspect is illustrated in
the following example.
Example 4.26
Consider again the choice program P and the database D of Example 4.24.
Recall that P contains only one choice rule assigning a single advisor to each student.
us, PD has two choice models whose actual_adv-atoms are factual_adv.john; ohm/g and
factual_adv.john; bell/g, respectively.
Consider the choice program P 0 obtained by adding to P the following Datalog rule:
actual_adv.S; A/  student.S; M; Y /; professor.A; M/:
Now
P 0
D
has
only
one
choice
model
whose
actual_adv-atoms
are
factual_adv.john; ohm/; actual_adv.john; bell/g. e addition of the rule above allows us to
derive more atoms that lead to the violation of the functional dependency enforced by the choice
rule.
Below we report diﬀerent examples showing how some classical combinatorial problems
can be easily expressed using the choice construct.
Example 4.27
Consider a bipartite undirected graph G D h.V1; V2/; Ei, that is, an undirected
graph where vertices are partitioned into two subsets V1 and V2, and each edge in E connects a
vertex in V1 with a vertex in V2.
Consider the problem of ﬁnding a matching, i.e., a subset E0 of E, such that for every vertex
v 2 V1 [ V2 at most one edge of E0 is incident on v. Suppose that we have a fact edge.x; y/
for each edge joining vertex x 2 V1 with vertex y 2 V2. e problem can be expressed with the
following choice rule:
matching.X; Y /  edge.X; Y /; choice..Y /; .X//; choice..X/; .Y //:
Intuitively, the choice rule says that any edge might be included in the matching provide that the
matching relation satisﬁes the conditions imposed by the choice atoms, that is, if an edge .X; Y /
is included in the matching then X is joined only with Y in the matching, and, likewise, Y is
joined only with X in the matching.
Example 4.28
Consider an undirected graph stored in a database as follows: for each edge con-
necting vertex x with vertex y there are two facts edge.x; y/ and edge.y; x/ in the database. A

52
4. NEGATION
spanning tree starting from the root vertex a can be computed by means of the following choice
program:⁷
st.root; a/:
st.X; Y /  st.Z; X/; edge.X; Y /; Y ¤ a; Y ¤ X; choice..Y /; .X//:
To illustrate the presence of multiple choice models for this choice program, consider a
simple graph consisting of the following edges:
edge.a; b/:
edge.b; a/:
edge.b; c/:
edge.c; b/:
edge.a; c/:
edge.c; a/:
Initially, the recursive rule could derive st.a; b/ and st.a; c/. No further edges can be added
after those, since the addition of st.c; b/ or st.b; c/ would violate the functional dependency en-
forced by choice..Y /; .X//. Notice that st.root; a/ is always derived by the ﬁrst rule and thus there
are no “chosen” atoms with the second argument equal to the source vertex a. erefore, to avoid
the addition of st.b; a/ or st.c; a/, the atom Y ¤ a was added to the recursive rule.
e choice program has three diﬀerent choice models, for which we list only the st-atoms
below:
• fst.a; b/; st.a; c/g
• fst.a; b/; st.b; c/g
• fst.a; c/; st.c; b/g:
4.6.3
FIXPOINT SEMANTICS
In this section, we present a ﬁxpoint semantics for choice programs. is semantics will be spe-
cialized in Section 4.6.4 to deﬁne the greedy choice.
Given a choice program P , we use PC to denote the set of rules in foe.P / that deﬁne a
predicate chosenr (for some r in P ), and use PS to denote the remaining rules of foe.P /, i.e.,
PS D foe.P /   PC. We can associate PC (resp. PS) with an immediate consequence operator
TPC (resp. TPS). Clearly, for any interpretation I of foe.P /, the following holds:
Tfoe.P /.I/ D TPC .I/ [ TPS.I/:
⁷For illustrative purposes, here we are slightly abusing the syntax of choice programs (cf. Deﬁnition 4.21) by allowing inequal-
ities in the body of a rule. However, the semantics of such more general choice programs can be deﬁned in the same way as
in Deﬁnition 4.22 as it is given in terms of the stable models of Datalog: programs.

4.6. CHOICE
53
We now introduce a general operator for computing the nondeterministic ﬁxpoints of a
choice program P . We will denote by FDP the functional dependencies deﬁned by the choice
atoms in P .
Deﬁnition 4.29
Given a choice program P , its nondeterministic immediate consequence operator
	P is a mapping from an interpretation of foe.P / to a set of interpretations of foe.P / deﬁned as
follows:
	P .I/ D fT !
PS.I [ C/ [ C j C 2  P .I/g;
where
 P .I/ D
(
f;g
if TPC .I/ D ;
fC j ;  C  TPC .I/ n I and I [ C ˆ FDP g;
otherwise.
I [ C ˆ FDP denotes that I [ C satisﬁes the dependencies in FDP .
Basically, the 	P operator is the composition of two operators. Given an interpretation I,
the ﬁrst operator computes all the admissible subsets C  TPC .I/ n I; that is, those where I [
C obeys the functional dependencies FDP . e second operator derives the logical consequence
for each admissible subset using the ﬁxpoint of TPS.
e deﬁnition of  P .I/ is such that C is not empty iﬀTPC .I/ n I is not empty. us,
if there are possible new choices, then at least one has to be taken. e 	P operator formalizes a
single step of a bottom-up evaluation of a choice program.
Observe that, given the presence of the condition I [ C ˆ FDP , we can eliminate the
atoms diff_choicer.X; Y / from the rules deﬁning predicate symbols chosenr. In fact, if TP 0
C de-
notes the immediate consequence operator for the set of rules obtained from PC by deleting
the atoms diff_choicer.X; Y /, then TP 0
C can replace TPC in the deﬁnition of  P .I/ (cf. Deﬁni-
tion 4.29 above), without aﬀecting the ﬁnal result.
Deﬁnition 4.30
Given a choice program P , an inﬂationary choice ﬁxpoint computation for P is
a sequence hInin0 of interpretations such that:
1. I0 D ;,
2. InC1 2 	P .In/,
for n  0.
Inasmuch as every sequence hInin0 is monotonic, it has a unique limit for n ! 1; this
limit will be called an inﬂationary choice ﬁxpoint for the choice program P .
Given a choice program P and a Herbrand interpretation M of foe.P /, then M is a choice
model of P iﬀM is an inﬂationary choice ﬁxpoint for P [Giannotti et al., 1991]. us, the
inﬂationary choice ﬁxpoint computation is sound (every inﬂationary choice ﬁxpoint is a choice
model) and complete (for each choice model there is some inﬂationary choice ﬁxpoint computation
producing it).

54
4. NEGATION
e data complexity (i.e., the computational complexity evaluated with respect to the size of
the database) of computing a choice model for a choice program P is polynomial time [Giannotti
et al., 1991]. erefore, the computation of one of the stable models of foe.P / can be performed
in polynomial time using the inﬂationary choice ﬁxpoint computation. is contrasts with the
general intractability of ﬁnding stable models of Datalog: programs: in fact, as already mentioned
in Section 4.5.1, checking if a Datalog: program has a stable model is NP-complete [Marek and
Truszczynski, 1991].
e choice construct allows us to capture a special subclass of Datalog: programs that
have a stable model semantics but are amenable to eﬃcient implementation and are appealing
to intuition. Evaluating these programs only requires memorization of the chosenr predicates;
from these, the diff_choicer predicates can be generated on-the-ﬂy, thus eliminating the need
to store diff_choicer explicitly. Moreover, the model of memorizing tables to enforce functional
dependencies provides a simple enough metaphor for a programmer to make eﬀective usage of
this construct without having to become cognizant on the subtleties of non-monotonic semantics.
We also mention that, although we are considering Datalog programs with choice, the
framework can be trivially extended to consider stratiﬁed negation. e computation of a choice
model for a Datalog:s program with choice can be carried out by partitioning the program into an
ordered number of suitable subprograms and computing the choice ﬁxpoints of every subprogram
in their order.
4.6.4
GREEDY CHOICE
In this section, we focus on a specialization of the choice construct called greedy choice [Greco and
Zaniolo, 1998, 2001, Greco et al., 1992]. e interest in such a specialization follows from the
observation that it is frequently desirable to select a value that is the least or the most among a set
of candidate values, and still satisfy the functional dependencies deﬁned by the choice atoms.
A choice-least (resp. choice-most) atom is of the form choice-least..X/; .C// (resp.
choice-most..X/; .C//), where X is a list of variables and C is a single variable ranging over
an ordered domain.
A choice-least rule (resp. choice-most rule) is a Datalog rule that contains one choice-least
(resp. one choice-most) atom, and zero or more choice atoms (besides standard atoms, of course).
A choice-least (resp. choice-most) program is a ﬁnite set of choice-least (resp. choice-most)
rules, choice rules, and Datalog rules. In the rest of this section, we assume that a choice-least
(resp. choice-most) program has at least one choice-least (resp. choice-most) rule as when this is
not the case we are dealing with choice programs or Datalog programs, which have been already
discussed before.
A choice-least..X/; .C// (resp. choice-most..X/; .C//) atom in a rule indicates that the
functional dependency deﬁned by the atom choice..X/; .C// is to be satisﬁed, and the C value
assigned to a certain value of X has to be the minimum (resp. maximum) one among the candidate

4.6. CHOICE
55
values. For instance, a rule of the form
p.X; Y; C/  q.X; Y; C/; choice..X/; .Y //; choice-least..X/; .C//
imposes the functional dependency X ! Y; C on the possible instances of p. In addition, for
each value of X, the minimum among the candidate values of C must be chosen. For instance,
assuming that q is deﬁned by the facts q.a; b; 1/ and q.a; c; 2/, from the rule above we might
derive either p.a; b; 1/ or p.a; c; 2/. However, the choice-least atom introduces the additional
requirement that the minimum value on the third attribute has to be chosen, so that only p.a; b; 1/
is derived. is means that, by using the choice-least and choice-most constructs, we introduce
some preference criteria on the stable models of the program.
Choice-least and choice-most programs have dual properties; thus, in the following we
will consider choice-least programs with the understanding that the corresponding properties for
choice-most programs are implicitly deﬁned by this duality.
e correct evaluation of choice-least programs can be deﬁned by specializing the nonde-
terministic immediate consequence operator (Deﬁnition 4.29) by ensuring that (i) C is a set
containing only one element, and (ii) a least-cost tuple among those that are candidates is chosen.
In order to deﬁne such an operator, we ﬁrst deﬁne a “lazy” version of the nondeterministic
immediate consequence operator, called lazy immediate consequence operator, where C is spe-
cialized into a singleton set ı. e specialized version of 	P so derived will be denoted 	 lazy
P . As
proven in Giannotti et al. [1991], the inﬂationary choice ﬁxpoint computation restricted so as
to use 	 lazy
P
still provides a sound and nondeterministically complete computation for the choice
models of P . After that, we deﬁne an immediate consequence operator called least-cost immediate
consequence operator, which ensures that a least-cost tuple among the candidate ones is chosen.
Given a choice-least program P , the ﬁrst-order equivalent of P , denoted foe.P /, is deﬁned
as for standard choice programs (cf. Deﬁnition 4.22), by treating choice-least atoms as choice
atoms. As for choice programs, PC denotes the set of rules in foe.P / that deﬁne a predicate
chosenr (for some r in P ), and PS denotes the remaining rules of foe.P /, i.e., PS D foe.P /   PC.
We start by deﬁning 	 lazy
P .
Deﬁnition 4.31
Let P be a choice-least program and I an interpretation of foe.P /. e lazy
immediate consequence operator 	 lazy
P
for P is deﬁned as follows:
I
D
fı j ı 2 TPC .I/ n I and I [ fıg ˆ FDP g
  lazy
P
.I/
D
fI [ fıg j ı 2 Ig [ fI j I D ;g
	 lazy
P .I/
D
fT !
PS .J / j J 2   lazy
P
.I/g:
Given an interpretation I, a set C 2  P .I/, and two atoms t1; t2 2 C, we write t1 < t2
if both atoms are inferred only by choice-least rules, and the cost of t1 is less than the cost of t2
according to some choice-least atom. For instance, consider the choice-least rule
p.X; Y; C/  q.X; Y; C/; choice-least..X/; .C//;

56
4. NEGATION
where the “cost” of p-atoms with respect to the choice-least atom choice-least..X/; .C// is their
third argument. Suppose t1 and t2 are the atoms p.a; b; 1/ and p.a; b; 2/, respectively. en, the
cost of t1 is less than the cost of t2.
Furthermore, we denote with least.C/ the set of atoms of C with least cost, i.e.,
least.C/ D ft j t 2 C and Àu 2 C s.t. u < tg. e implementation of the least-cost imme-
diate consequence operator is simply obtained by replacing ı 2 I with ı 2 least.I/ in the
deﬁnition of the lazy immediate consequence operator.
Deﬁnition 4.32
Let P be a choice-least program and I an interpretation of foe.P /. e least-
cost immediate consequence operator 	 least
P
for P is deﬁned as follows:
I
D
fı j ı 2 TPC .I/ n I and I [ fıg ˆ FDP g
  least
P
.I/
D
fI [ fıg j ı 2 least.I/g [ fI j I D ;g
	 least
P
.I/
D
fT !
PS .J / j J 2   least
P
.I/g:
Likewise, the dual deﬁnition of the most-cost immediate consequence operator can be easily
derived.
Deﬁnition 4.33
Given a choice-least program P , an inﬂationary least choice ﬁxpoint computation
for P is a sequence hInin0 of interpretations such that:
• I0 D ; and
• InC1 2 	 least
P
.In/,
for n  0.
us, all atoms that do not violate the functional dependencies deﬁned by choice atoms
(including those imposed by choice-least atoms) are considered, and one is chosen that has the
least value for the cost argument. For a choice-least program P ,
1. every inﬂationary least choice ﬁxpoint for P is a choice model for the choice program ob-
tained from P by treating choice-least atoms as choice atoms; and
2. every inﬂationary least choice ﬁxpoint of P can be computed in polynomial time.
As for the ﬁrst property, observe that every computation of the inﬂationary least choice
ﬁxpoint is also a computation of the lazy choice ﬁxpoint.
e second property follows from the fact that the complexity of the inﬂationary lazy choice
ﬁxpoint is polynomial time, and the cost of selecting an atom with least cost is also polynomial.
e model so constructed will be called greedy choice models.
In a system that adopts a semantics based on the least choice ﬁxpoint, a programmer will
specify a choice-least..X/; .Y // atom to ensure that only particular choice models rather than
arbitrary ones are produced through the greedy selection of the least values of Y at each step.

4.7. DISJUNCTION
57
e specialization of choice atoms into choice-least or choice-most atoms yields a con-
venient and eﬃcient formulation of many greedy algorithms, such as Dijkstra’s shortest path
(for which arithmetic operators are needed as well) and Prim’s minimum-spanning tree algo-
rithms [Greco and Zaniolo, 1998].
Example 4.34
Consider a weighted directed graph stored by means of facts of the form
edge.x; y; c/, meaning that there is an edge in the graph from vertex x to vertex y with cost
c. An algorithm for ﬁnding a minimum spanning tree starting from a source vertex a can be
formulated as follows, yielding the well-known Prim’s algorithm.
st.root; a; 0/:
st.X; Y; C/
 
st.Z; X; W /; edge.X; Y; C/; Y ¤ a;
choice..Y /; .X//; choice-least..Y /; .C//:
Greedy algorithms often provide eﬃcient approximate solutions to NP-complete problems;
the following algorithm yields heuristically eﬀective approximations of optimal solutions for the
traveling salesperson problem [Papadimitriou and Steiglitz, 1982].
Example4.35
Given a complete undirected graph, the ﬁrst rule of the following program simply
selects an arbitrary vertex X from which to start the search. en, the second rule greedily chooses
at each step an edge .X; Y; C/ of least cost C having X as endpoint.
spath.root; X; 0/
 
vertex.X/; choice../; X/:
spath.X; Y; C/
 
spath.W; X; K/; edge.X; Y; C/; spath.root; Z; 0/; Y ¤ Z;
choice..X/; .Y //; choice..Y /; .X//; choice-least..Y /; .C//:
e examples above show that the choice constructs provide a logic-based approach for the
design of greedy algorithms. In a nutshell, the design approach is as follows: (i) formulate the all-
answer solution to the problem at hand (e.g., ﬁnd all the costs of all paths from a source vertex to
the other vertices), (ii) use choice-induced functional dependency constraints so that the original
logic program generates non-deterministic single answers (e.g., ﬁnd a cost from the source vertex
to each other vertex), and (iii) specialize the choice atoms into choice-least or choice-most atoms
to force a greedy heuristics upon the generation of single answers (thus computing the least-cost
paths). is approach yields conceptual simplicity and simple programs.
4.7
DISJUNCTION
In this section, we brieﬂy discuss the extension of Datalog and Datalog: with disjunction (in
rule heads). e resulting languages will be referred to as Datalog_ and Datalog_;:, respectively.

58
4. NEGATION
Disjunction is an important feature for knowledge representation, database querying, and for
representing incomplete information.
We start by deﬁning the syntax of Datalog_. A Datalog_ rule r is of the form:
H1 _    _ Hm  A1; : : : ; An;
where m  1, n  0, and both the Hi’s and the Ai’s are atoms (function symbols are not allowed).
e disjunction H1 _    _ Hm is called the head of r while the conjunction A1; : : : ; An is called
the body of r. A Datalog_ program is a ﬁnite set of Datalog_ rules.
e safety condition of Datalog programs (cf. Section 3.1) is generalized by requiring that
every variable appearing in the head must appear in at least one atom of the body, for every
Datalog_ rule.
e semantics of a Datalog_ program is given by its minimal Herbrand models as deﬁned
below. Consider a Datalog_ program P and a database D. As usual, the Herbrand universe HPD
of PD (recall that PD denotes P [ D) is the set of constants appearing in PD, and the Herbrand
base BPD of PD is the set of ground atoms which can be built using predicate symbols appearing
in PD and constants in HPD. An interpretation of PD is any subset of BPD. Once again, we use
ground.PD/ to denote the set of all ground rules obtained from the rules of PD by replacing all
variables with constants.
e truth value of a ground atom A w.r.t. an interpretation I is true if A 2 I, false otherwise.
A ground rule r is satisﬁed by I if there is a ground atom in the head of r which is true w.r.t. I or
there is a ground atom in the body of r which is false w.r.t. I. An interpretation of PD is a model
of PD if it satisﬁes every ground rule in ground.PD/. A model M of PD is minimal if no proper
subset of M is a model of PD.
e model-theoretic semantics of a Datalog_ program PD is given by its minimal models.
Obviously, this semantics is a generalization of the model-theoretic semantics for Datalog pro-
grams presented in Section 3.2.1. Notice that while every Datalog program has a unique minimal
model (the least model), a Datalog_ program might have more than one minimal model.
Example 4.36
Consider the Datalog_ program P consisting of the following Datalog_ rule,
saying that a person X is either male or female
male.X/ _ female.X/  person.X/:
Consider also the database D consisting only of the fact person.a/. en, PD has two minimal
models, namely fperson.a/; male.a/g and fperson.a/; female.a/g.
e language obtained by extending Datalog: with disjunction is denoted as Datalog_;:.
More speciﬁcally, a Datalog_;: rule is of the form
H1 _    _ Hm  L1; : : : ; Ln;

4.7. DISJUNCTION
59
where m  1, n  0, the Hi’s are atoms, and the Li’s are literals (i.e., atoms or negated atoms);
function symbols are not allowed. e safety condition is the same as for Datalog: (cf. Sec-
tion 4.1).
A Datalog_;: program is a ﬁnite set of Datalog_;: rules.
e stable model semantics for Datalog: programs is easily generalized to Datalog_;: pro-
grams as follows [Gelfond and Lifschitz, 1991, Przymusinski, 1991].
Consider a Datalog_;: program P and a database D. e Herbrand universe HPD, the
Herbrand base BPD, and interpretations of PD are deﬁned in the usual way as well as ground.PD/.
Given an interpretation I of PD, let PDI denote the ground Datalog_ program derived from
ground.PD/ by deleting
• every rule that contains a negative literal :A in its body with A 2 I, and
• all negative literals in the bodies of the remaining rules.
An interpretation I of PD is a disjunctive stable model of PD if and only if I is a mini-
mal model of PDI. Clearly, this is a generalization of the stable model semantics for Datalog:
programs (cf. Section 4.5.1).
Notice that if P is a Datalog_ program, then PDI D ground.PD/ for any interpretation I
of PD and thus the disjunctive stable models of PD are exactly the minimal models of PD. us,
the disjunctive stable model semantics also generalizes the minimal model semantics discussed
above for Datalog_ programs.
e expressive power and the complexity of Datalog_;: and several sublanguages of it,
under diﬀerent semantics, are thoroughly studied in Dantsin et al. [2001], Eiter et al. [1997a].
Here we just mention that Datalog_;: is more expressive than Datalog: (unless the polynomial
hierarchy collapses).
BIBLIOGRAPHIC NOTES
Other interesting semantics (which have not been reported in this chapter) have been proposed for
Datalog: programs, such as the inﬂationary and noninﬂationary semantics, partial stable models,
maximal partial stable models, regular models, perfect models, two- and three-valued completion
semantics, and ﬁxpoint models [Abiteboul and Vianu, 1991, Abiteboul et al., 1995, Bidoit and
Hull, 1986, Dudakov, 1999, Eiter et al., 1997b, Furfaro et al., 2007, Kolaitis and Papadimitriou,
1991, Przymusinski, 1988, Saccà, 1995, Saccà and Zaniolo, 1991, 1997, Schlipf, 1995, You and
Yuan, 1995].
A extension of the class of locally stratiﬁed Datalog: programs, called weakly stratiﬁed
programs, has been proposed by Przymusinska and Przymusinski [1988].
e expressivity and the complexity of various subclasses of Datalog: under diﬀerent se-
mantics have been studied in Abiteboul et al. [1995], Buccafurri et al. [1997], Cadoli and Palopoli
[1998], Cholak and Blair [1994], Dantsin et al. [2001], Eiter et al. [1998], Greco and Saccà [1996,

60
4. NEGATION
1997a,b, 1999], Greco et al. [2001], Kolaitis [1991], Kolaitis and Vardi [1995], Palopoli [1992],
Saccà [1997].
e expressive power of the choice construct has been studied in Giannotti and Pedreschi
[1998], Giannotti et al. [2001], Greco et al. [1995], where it is shown that it is more powerful than
other nondeterministic constructs, including the witness operator Abiteboul and Vianu [1991],
and the original version of choice (called static choice) proposed in Krishnamurthy and Naqvi
[1988]. For instance, it has been shown in Giannotti et al. [1991] that the task of ordering a
domain or checking whether a relation contains an even number of elements cannot be performed
by Datalog programs with static choice or the witness operator [Abiteboul and Vianu, 1991].
Because of the ability of choice programs to order the elements of a set, Datalog:s with choice
allows us to express all problems in P.
An extension of Datalog with the choice construct and weak constraints has been studied
in Greco [1996, 1998a].
For a more complete treatment of disjunctive logic programming, we refer the reader to
Eiter et al. [1997a], Lobo et al. [1992], Minker [1994], Minker and Seipel [2002].
We conclude by mentioning various systems for Datalog and diﬀerent extensions of it,
including negation and disjunction: Clasp [Gebser et al., 2012], DeALS [Mazuran et al., 2013,
Shkapsky et al., 2015], DLV [Leone et al.], LogicBlox [Aref et al., 2015], NP Datalog [Greco
et al., 2006, 2010], and Smodels [Simons et al., 2002].

61
C H A P T E R
5
Function Symbols
Function symbols are widely acknowledged as an important feature, as they often make modeling
easier, and the resulting encodings more readable and concise. ey also increase the expressive
power and allow us to overcome the inability of dealing with inﬁnite domains.
e main problem with the introduction of function symbols in Datalog is that the least
model of a program can be inﬁnite—equivalently, the bottom-up program evaluation might not
terminate. Unfortunately, it is undecidable whether the evaluation terminates. In order to cope
with this issue, recent research has focused on identifying classes of programs allowing only a
restricted use of function symbols while ensuring ﬁniteness and computability of the least model.
ese approaches provide conditions, called termination criteria, specifying suﬃcient conditions
for the (bottom-up) program evaluation to terminate.
is chapter presents termination criteria recently proposed in the literature. It also presents
an orthogonal technique, based on program adornment, that can be used in conjunction with
current termination criteria to make them more eﬀective.
5.1
SYNTAX AND SEMANTICS
In this chapter, we consider the extension of Datalog with uninterpreted function symbols (i.e.,
they are not evaluated)—the resulting language will be referred to as Datalogf .
In addition to inﬁnite sets of constants, variables, and predicate symbols, we assume to have
an inﬁnite set of function symbols. Each function symbol is associated with a ﬁxed arity, which
is a positive integer. Besides constants and variables (which are called simple terms), terms now
include also expressions of the form f .t1; : : : ; tm/, where f is a function symbol of arity m and
the ti’s are terms—terms of this form are called complex.
As for the syntax, a Datalogf rule simply is a Datalog rule (see Section 3.1) where complex
terms can occur. In this chapter, we sometimes call Datalogf rules simply rules. A Datalogf
program is a ﬁnite set of Datalogf rules.
e three semantics for Datalog programs discussed in Chapter 3 can be straightforwardly
generalized to the case where function symbols are allowed.
Compared with the model-theoretic semantics of Datalog programs (cf. Section 3.2.1),
the main diﬀerence is that the Herbrand universe HP of a Datalogf program P contains the
set of ground terms which can be built using constants and function symbols appearing in P
(while for Datalog programs the Herbrand universe contains only constants). e Herbrand base
BP of P remains deﬁned as the set of ground atoms which can be built using predicate symbols

62
5. FUNCTION SYMBOLS
appearing in P and ground terms of HP . e ground instances of atoms, Datalogf rules, and
Datalogf programs are still obtained by replacing variables with ground terms of HP . However,
notice that since HP can contain complex terms, the Herbrand base and the ground instantiations
can contain complex terms as well. us, in a nutshell, the main diﬀerence between Datalog and
Datalogf is that ground terms are not only constants, but also include complex terms built from
function symbols and constants. e other deﬁnitions of Section 3.2.1 remain unmodiﬁed and
the same notation and terminology therein will be used in the following.
It is important to note that the Herbrand universe is inﬁnite if P contains at least one
function symbol and one constant. As a consequence, the Herbrand base is inﬁnite, and inter-
pretations and models can be inﬁnite too. A Datalogf program has a unique least model, which
can be inﬁnite.
e immediate consequence operator can be deﬁned for Datalogf programs in the same
way as for Datalog programs (cf. Section 3.2.2), with the only diﬀerence that the ground instan-
tiations of Datalogf rules and programs are obtained by replacing variables with constants and
ground complex terms built from function symbols and constants. As for Datalogf programs,
the least model coincides with the least ﬁxpoint of the immediate consequence operator.
Example 5.1
Consider the following Datalogf program which counts the number of elements
in a list:
r0 W count.Œa; b; c; 0/:
r1 W count.L; s.I//  count.ŒXjL; I/:
e bottom-up evaluation of the program terminates yielding the set of atoms count.Œa; b; c; 0/,
count.Œb; c; s.0//, count.Œc; s.s.0///, and count.Œ ; s.s.s.0////. e length L of list Œa; b; c can
be retrieved from the atom count.Œ ; L/ by counting the number of s in L, which 3 in this case.¹
To make function symbols more explicit, the program above can be rewritten into the fol-
lowing Datalogf program:
r0 W count.lc.a; lc.b; lc.c; nil///; 0/:
r1 W count.L; s.I//  count.lc.X; L/; I/:
Here lc is a binary function symbol denoting the list constructor operator, and nil denotes the
empty list.
5.2
TERMINATION CRITERIA
e main problem with the introduction of function symbols in Datalog is that the least model
can be inﬁnite and thus cannot be fully and explicitly computed. To deal with this issue, subclasses
of Datalogf imposing a restricted use of function symbols, but guaranteeing the computability of
¹Notice that the program has been written so as to count the number of elements in a list when evaluated in a bottom-up
fashion, and therefore diﬀers from the classical formulation relying on a top-down evaluation strategy. However, programs
relying on a top-down evaluation strategy can be rewritten into programs whose bottom-up evaluation gives the same result.

5.2. TERMINATION CRITERIA
63
the least model have been proposed—this section surveys several of such subclasses proposed in
the literature. We start by introducing some additional notation and terminology used throughout
the chapter.
e binary relation subterm over terms is recursively deﬁned as follows: every term is a
subterm of itself; if t is a complex term of the form f .t1; : : : ; tm/, then every ti is a subterm of t,
for 1  i  m; if t1 is a subterm of t2 and t2 is a subterm of t3, then t1 is a subterm of t3.
Given a predicate symbol p of arity n, the i-th argument of p is an expression of the form
pŒi, for 1  i  n. If p is a base (resp. derived) predicate symbol, then pŒi is said to be a base
(resp. derived) argument. e set of all predicate symbols appearing in a Datalogf program P is
denoted by pred.P /. e set of all arguments of P is denoted by arg.P /, that is, arg.P / D fpŒi j
p belongs to pred.P /; and has arity n and 1  i  ng.
e following subsections present current termination criteria.
5.2.1
-RESTRICTED PROGRAMS
In this section, we present the class of -restricted programs [Gebser et al., 2007].
Given a Datalogf program P , we use V.r/ to denote the set of variables appearing in a
rule r 2 P and B.X; r/ to denote the set of predicate symbols of the atoms in the body of r which
contain variable X. Moreover, recall that def.p; P / denotes the deﬁnition of a predicate symbol
p in P , that is, the set of rules of P having p in the head atom.
Deﬁnition 5.2
-restricted program.
A Datalogf program P is -restricted if there exists
a mapping  W pred.P / ! N such that, for every predicate symbol p 2 pred.P /, the following
holds:
maxfmaxfminf.p0/j p0 2 B.X; r/gj X 2 V.r/gj r 2 def.p; P /g < .p/:
Intuitively, the condition stated in the deﬁnition above means that, for each predicate sym-
bol p, all the variables in rules deﬁning p are “bounded” by predicate symbols p0 in the body
such that .p0/ < .p/. If this is the case, the feasible ground instances of rules in def.p; P / are
completely determined by predicate symbols from lower levels than the one of p.
Example 5.3
e following Datalogf program is -restricted:
p.f .X//
 
q.X/:
q.X/
 
p.X/; r.X/:
In fact, it can be easily veriﬁed that the mapping  deﬁned as .r/ D 1, .q/ D 2, .p/ D 3
satisﬁes the condition of Deﬁnition 5.2.
One limitation of -restriction is that some Datalog programs (thus, without function sym-
bols) are not recognized as -restricted—however, the least model of a Datalog program is always

64
5. FUNCTION SYMBOLS
ﬁnite and the bottom-up evaluation always terminates. An example is the following Datalog pro-
gram:
p.X/  q.X/:
q.X/  p.X/:
To satisfy the condition of Deﬁnition 5.2, any mapping  from predicate symbols to natural
numbers should be s.t. .p/ > .q/ (because of the ﬁrst rule) and .q/ > .p/ (because of the
second rule); since such a mapping does not exist, the program above is not -restricted. us,
by relying on the -restriction criterion, no conclusion can be drawn on the termination of the
program above.
5.2.2
FINITE DOMAIN PROGRAMS
Finite domain programs have been introduced by Calimeri et al. [2008]. e deﬁnition relies on
the notion of argument graph, deﬁned below, which represents the propagation of values among
arguments of a Datalogf program.
Deﬁnition 5.4
Argument graph.
e argument graph of a Datalogf program P , denoted
G.P /, is a directed graph whose set of nodes is arg.P /, and there is an edge .qŒj ; pŒi/ iﬀthere
is a rule r 2 P such that
• an atom p.t1; : : : ; tn/ appears in head.r/,
• an atom q.u1; : : : ; um/ appears in body.r/, and
• terms ti and uj have a common variable.
Example 5.5
Consider the following Datalogf program, where base is a base predicate symbol.
q.X; Y /
 
p.X/; base.Y /:
p.f .X; Y //
 
q.X; Y /:
e argument graph is depicted in Figure 5.1.
Given a Datalogf program P , an argument pŒi is said to be recursive if it appears in a
cycle of G.P /; two arguments pŒi and qŒj  are mutually recursive if there exists a cycle in G.P /
involving both pŒi and qŒj . For instance, considering the Datalogf program of Example 5.5,
arguments baseŒ1 and qŒ2 are not recursive while pŒ1 and qŒ1 are recursive. Moreover, pŒ1 and
qŒ1 are mutually recursive.
Deﬁnition 5.6 Finite domain program.
Given a Datalogf program P , the set of ﬁnite domain
arguments of P is the maximal set FD.P / of arguments of P such that, for each argument qŒk 2
FD.P /, every rule r whose predicate symbol in the head is q satisﬁes the following condition. Let
t be the term corresponding to argument qŒk in the head of r. en, either

5.2. TERMINATION CRITERIA
65
p[1]
base[1]
q[1]
q[2]
Figure 5.1: Argument graph.
1. t is variable-free,
2. t is a subterm of a term corresponding to a ﬁnite domain argument of a body predicate
symbol, or
3. every variable appearing in t also appears in a term corresponding to a ﬁnite domain argu-
ment of a body predicate symbol which is not mutually recursive with qŒk.
If all arguments of P are ﬁnite domain (i.e., FD.P / D arg.P /), then P is a ﬁnite domain program.
Example 5.7
Consider the following simple Datalogf program
q.X/  q.f .X//:
Obviously, qŒ1 is mutually recursive with itself. It can be easily veriﬁed that the program above
is ﬁnite domain (by applying the second condition of Deﬁnition 5.6).
Checking whether a Datalogf program P is ﬁnite domain or not can be done by ﬁrst
assuming that all arguments are in FD.P / and then iteratively eliminating arguments appearing
in the head of a rule such that none of the three conditions of Deﬁnition 5.6 holds. us, checking
whether a Datalogf program is ﬁnite domain is decidable.
Notice that all Datalog programs (i.e., no function symbols are allowed) are ﬁnite domain:
by assuming that all arguments of a Datalog program are ﬁnite domain, it is easy to see that, for
all of them, the ﬁrst or second condition of Deﬁnition 5.6 is always satisﬁed.
Moreover, the class of ﬁnite domain programs is not comparable with the class of -
restricted programs.
Example 5.8
Consider the two Datalogf programs of Example 5.3. As discussed before, the
ﬁrst one is -restricted while the second one is not. On the other hand, the second program is

66
5. FUNCTION SYMBOLS
ﬁnite domain (in fact, it is a Datalog program) while the ﬁrst one is not. To see why the ﬁrst
program is not ﬁnite domain, it suﬃces to notice that if we assume that all arguments are ﬁnite
domain, then pŒ1 and the ﬁrst rule do not satisfy any of the conditions of Deﬁnition 5.6.
5.2.3
ARGUMENT-RESTRICTED PROGRAMS
e class of argument-restricted programs has been introduced by Lierler and Lifschitz [2009].
Before presenting its deﬁnition, some additional notation is introduced. For any atom A of the
form p.t1; : : : ; tn/, we use A0 to denote predicate symbol p and Ai to denote term ti, for 1  i 
n. e depth d.X; t/ of a variable X in a term t that contains X is recursively deﬁned as follows:
d.X; X/ D 0;
d.X; f .t1; : : : ; tm// D 1 C
max
i W ti contains X d.X; ti/:
Deﬁnition 5.9 Argument-restricted program.
An argument ranking for a Datalogf program
P is a function  from arg.P / to integers such that the following condition is satisﬁed for every
rule r of P . Let A be the atom in the head of r. For every variable X occurring in a term Ai,
body.r/ contains an atom B such that X occurs in a term Bj satisfying the condition
.A0Œi/   .B0Œj /  d.X; Ai/   d.X; Bj /:
A Datalogf program is argument-restricted if it has an argument ranking.
Example 5.10
e two programs of Example 5.3 are both argument-restricted. For the ﬁrst
one, an argument ranking is .pŒ1/ D 1, .qŒ1/ D .rŒ1/ D 0. For the second program, an
argument ranking is .pŒ1/ D .qŒ1/ D 0.
Argument-restricted programs strictly include -restricted and ﬁnite domain pro-
grams [Lierler and Lifschitz, 2009]. An algorithm for checking whether a Datalogf program
is argument-restricted can be found in Lierler and Lifschitz [2009].
5.2.4
SAFE PROGRAMS
e class of safe programs [Greco et al., 2012b] is an extension of the class of ﬁnite domain pro-
grams. Its deﬁnition is based on the notions of activation graph and safe argument.
Let P be a Datalogf program and r1; r2 be (not necessarily distinct) rules of P . We say
that r1 activates r2 iﬀthere exist two ground rules r0
1 2 ground.r1/, r0
2 2 ground.r2/ and an inter-
pretation I such that (i) I 6ˆ r0
1, (ii) I ˆ r0
2, and (iii) I [ head.r0
1/ 6ˆ r0
2. is intuitively means

5.2. TERMINATION CRITERIA
67
that if I does not satisfy r0
1, I satisﬁes r0
2, and head.r0
1/ is added to I to satisfy r0
1, this causes r0
2
not to be satisﬁed anymore (and then to be “activated”).
Deﬁnition 5.11
Activation graph.
e activation graph of a Datalogf program P , denoted
˝.P /, is a directed graph whose nodes are the rules of P , and there is an edge .ri; rj / in the
graph iﬀri activates rj.
Example 5.12
Consider the following Datalogf program:
r0 W
p.X/
 
base.X/:
r1 W
q.f .X//
 
p.X/:
r2 W
p.g.X//
 
q.X/;
where base is a base predicate symbol. It is easy to see that r0 activates r1, but not vice versa; r1
activates r2 and vice versa. e activation graph is shown in Figure 5.2.
r0
r1
r2
Figure 5.2: Activation graph.
Deﬁnition 5.13 Safe program.
Given a Datalogf program P , the set of safe arguments safe.P /
is computed by ﬁrst setting safe.P / D FD.P / (cf. Deﬁnition 5.6) and next iteratively adding each
argument qŒk of P such that for every rule r 2 P where q appears in the head,
• r does not appear in a cycle of ˝.P /, or
• if q.t1; : : : ; tn/ is the head atom, then for every variable X appearing in tk, there is an atom
p.u1; : : : ; um/ in body.r/ and a term ui (1  i  m) s.t. X appears in ui and pŒi is safe.

68
5. FUNCTION SYMBOLS
A Datalogf program P is said to be safe if all its arguments are safe.
Example 5.14
e following Datalogf program, where base is a base predicate symbol, is safe
as its activation graph does not have cycles (notice that rule r2 does not activate itself):
r1 W
p.X; X/
 
base.X/:
r2 W
p.f .X/; g.X//
 
p.X; X/:
Although the class of safe programs strictly includes -restricted programs, the classes of
safe and argument-restricted programs are not comparable, as shown in the following example.
Example 5.15
e Datalogf program of Example 5.14 is safe, but not argument-restricted.
On the other hand, the following Datalogf program, where base is a base predicate symbol, is
argument-restricted, but not safe:
r1 W
q.X; f .X//
 
p.X/:
r2 W
r.X; Y /
 
q.X; Y /:
r3 W
p.X/
 
r.Y; X/; base.X/:
r4 W
t.X; X/
 
q.Y; X/:
r5 W
q.X; X/
 
t.X; Y /:
r6 W
t.X; g.X; Y1; Y2//
 
t.Y1; X/; q.Y2; X/:
It can be readily veriﬁed that the function  deﬁned as follows is an argument ranking, and thus,
the program above is argument-restricted:
.pŒ1/ D 0;
.baseŒ1/ D 0;
.qŒ1/ D 1;
.qŒ2/ D 1;
.rŒ1/ D 1;
.rŒ2/ D 1;
.tŒ1/ D 1;
.tŒ2/ D 2:
e set of ﬁnite domain arguments is fbaseŒ1; pŒ1g, which is also the set of safe arguments. us,
the program above is not safe.
5.2.5
  -ACYCLIC PROGRAMS
  -acyclic programs have been introduced by Greco et al. [2012b]. e deﬁnition of   -acyclic
programs relies on the notion of propagation graph deﬁned below.
Deﬁnition 5.16 Propagation graph.
e (labeled) propagation graph .P / of a Datalogf pro-
gram P is a labeled directed graph deﬁned as follows. e set of nodes is the set of non-safe
arguments (see Deﬁnition 5.13) of P , also-called aﬀected arguments and denoted as aff.P /. e
set of (labeled) edges is deﬁned in the following way: for each pair of nodes pŒi; qŒj  2 aff.P /
and for every rule r 2 P such that

5.2. TERMINATION CRITERIA
69
• there is an atom p.t1; : : : ; tn/ in the head of r,
• there is an atom q.u1; : : : ; um/ in the body of r, and
• the same variable X occurs in both ti and uj,
there is a labeled edge .qŒj ; pŒi; ˛/ 2 E, where ˛ is deﬁned as follows:
• ˛ D  if ti D uj,
• ˛ D f if uj D X and ti D f .: : : ; X; : : : /, and
• ˛ D f if uj D f .: : : ; X; : : : / and ti D X.
In the previous deﬁnition,  is used to denote the empty string. Furthermore, without loss
of generality, we assumed that if the same variable occurs in two terms appearing in the head and
in the body of a rule, then one term is a subterm of the other and the nesting level of the complex
terms is at most one.
e deﬁnition of   -acyclic programs relies also on the grammar introduced in the following
deﬁnition.
Deﬁnition 5.17 Grammar  P .
Let P be a Datalogf program and FP the set of function sym-
bols occurring in P . e grammar  P is a 4-tuple .N; T; R; S/, where N D fS; S1; S2g is the set
of nonterminal symbols, S is the start symbol, T D ff j f 2 FP g [ ff j f 2 FP g is the set of
terminal symbols, and R is the set consisting of the following production rules:
• S ! S1 f S2,
8f 2 FP ;
• S1 ! f S1 f S1 j ,
8f 2 FP ;
• S2 ! .S1 j f / S2 j ,
8f 2 FP .
e language L. P / is the set of strings generated by  P .
A path  in a propagation graph .P / is a sequence .a1; b1; ˛1/; : : : ; .ak; bk; ˛k/ of labeled
edges of .P /, where k  1 and bi D aiC1 for all 1  i < k. If a1 D bk, then  is also called
a cycle. For any path  as above, we denote with ./ the string ˛1 : : : ˛k. Given a grammar
 P D .N; T; R; S/ and a propagation graph .P /, we say that path  in .P / spells a string
w 2 L. P / if ./ D w. We are now ready to deﬁne   -acyclic programs.
Deﬁnition 5.18   -acyclic program.
A Datalogf program P is   -acyclic if there is no cycle in
.P / spelling a string of L. P /.
It straightforwardly follows from the deﬁnition above that the class of safe programs is a
subset of the class of   -acyclic programs. In fact, for every safe program, the propagation graph
is empty (because the set of aﬀected arguments is empty, cf. Deﬁnition 5.16), and thus, the

70
5. FUNCTION SYMBOLS
condition of   -acyclicity of Deﬁnition 5.18 is trivially satisﬁed. e class of   -acyclic programs
strictly contains that of safe programs, while it is not comparable with that of argument-restricted
programs, as shown in the following example.
Example 5.19
As already discussed, the Datalogf program of Example 5.14 is safe, but not
argument-restricted. Since the program is safe, then it is also   -acyclic.
e following Datalogf program is   -acyclic but not safe (it is not argument-restricted
either):
r1 W
r.f .X//
 
s.X/:
r2 W
q.f .X//
 
r.X/:
r3 W
p.X/
 
q.X/:
r4 W
n.X/
 
p.g.X//:
r5 W
s.X/
 
n.X/:
Notice that all arguments are aﬀected. e propagation graph has a single cycle going through all
arguments of the program, and the corresponding string is ff g. Since the string does not belong
to the language L. P /, the program is   -acyclic.
As already shown, the Datalogf program of Example 5.15 is argument-restricted. It can
be easily veriﬁed that the corresponding propagation graph has a cycle spelling a string of L. P /
(e.g., there is a cycle going through tŒ1 and tŒ2 whose associated string is g). us, the program
is not   -acyclic.
5.2.6
BOUNDED PROGRAMS
A termination criterion more general than the ones presented thus far has been proposed by Greco
et al. [2013a], who introduced the class of bounded programs, which strictly includes the classes
of programs presented in the previous sections.
e criterion relies on two powerful tools: (i) the labeled argument graph, a directed graph
whose edges are labeled with useful information on how terms are propagated from the body to
the head of rules, and (ii) the activation graph presented before (Deﬁnition 5.11). e labeled
argument graph is used in synergy with the activation graph for a better understanding of how
terms are propagated.
Another relevant aspect that distinguishes the criterion presented in this section from the
the termination criteria previously discussed is that the latter analyze one group of arguments
(depending on each other) at a time, without looking at how groups of arguments are related. On
the contrary, the criterion of bounded programs can be used to perform an analysis of how groups
of arguments aﬀect each other.
For instance, none of the termination criteria discussed in the previous sections is able to
realize that the bottom-up evaluation of the program of Example 5.1 terminates. Intuitively, this
is because they analyze how the ﬁrst argument of count aﬀects itself and how the second argument
of count aﬀects itself, but miss noticing that the growth of the latter is bounded by the reduction

5.2. TERMINATION CRITERIA
71
of the former. One of the novelties of the criterion presented in this section is the capability of
doing this kind of reasoning—indeed, it is able to realize that the bottom-up evaluation of the
program above terminates.
We start by introducing some notation and terminology used in the following. We deﬁne
a partial argument ranking for a Datalogf program P as a partial function  from arg.P / to
non-negative integers, such that the following condition is satisﬁed for every rule r of P . Let A
be the atom occurring in the head of r. For every variable X occurring in a term Ai, if .A0Œi/ is
deﬁned, then body.r/ contains an atom B such that X occurs in a term Bj, .B0Œj/ is deﬁned,
and the following condition is satisﬁed:
.A0Œi/   .B0Œj/  d.X; Ai/   d.X; Bj /:
e
set
of
restricted
arguments
of
P
is
AR.P / D fpŒi
j
pŒi 2 arg.P / ^
there exists a partial argument ranking  s:t: .pŒi/ is deﬁnedg.
An argument pŒi in arg.P / is said to be limited iﬀfor any ﬁnite database D, the set
fti j p.t1; : : : ; ti; : : : ; tn/ 2 Mg is ﬁnite, where M is the least model of PD.
For ease of presentation, we assume that if the same variable occurs in two terms appearing
in the head and in the body of a rule, then one term is a subterm of the other, and complex terms
are of the form f .t1; : : : ; tm/ with the ti’s being simple terms. ere is no loss of generality in
such assumptions as every Datalogf program can be rewritten into an equivalent one satisfying
such conditions (e.g., a rule of the form p.f .h.X/// q.g.X// can be rewritten into the three
rules p.f .X// p0.X/, p0.h.X// p00.X/, and p00.X/ q.g.X//).
Below we introduce the ﬁrst tool used to deﬁne bounded programs. It is a new graph derived
from the argument graph by labeling edges with additional information.
Deﬁnition 5.20 Labeled argument graph.
e labeled argument graph of a Datalogf program
P , denoted GL.P /, is a directed graph whose set of nodes is arg.P /, and the set of labeled edges
is deﬁned as follows. For each pair of nodes pŒi; qŒj  2 arg.P /, and for every rule r 2 P such
that
1. there is an atom p.t1; : : : ; tn/ in head.r/,
2. there is an atom q.u1; : : : ; um/ in body.r/, and
3. terms ti and uj have a common variable X;
there exists an edge .qŒj ; pŒi; h˛; r; ki/, where k is a natural number denoting the position of
q.u1; : : : ; um/ in body.r/,² and
• ˛ D  if uj D ti;
²We assume that atoms in the body are ordered with the ﬁrst one being associated with 1, the second one with 2, etc. e order
is used only for the purpose of identifying body atoms.

72
5. FUNCTION SYMBOLS
r0
1
b[1]
f,r ,2
0
є,r ,1
̟
5
̟1
̟2
̟3
̟4
̟
6
1
1
f,r ,1
2
f,r ,1
3
f,r ,1
3
f,r ,1
2
є,r ,1
є,r ,1
4
є,r ,1
4
h,r ,1
0
є,r ,1
a[1]
t[1]
t[2]
q[1]
q[2]
s[1]
s[2]
r1
r2
r4
r3
Figure 5.3: Labeled argument and activation graphs.
• ˛ D f if uj D X and ti D f .: : : ; X; : : : /; and
• ˛ D f if uj D f .: : : ; X; : : : / and ti D X.
Example 5.21
Consider the following Datalogf program
r0 W
t.X; X/
 
a.X/:
r1 W
q.f .X/; Y /
 
t.X; Y /; b.X/:
r2 W
t.X; f .Y //
 
q.X; Y /:
r3 W
q.f .X/; f .Y //
 
s.X; Y /:
r4 W
s.X; Y /
 
q.h.X/; Y /;
where a and b are base predicate symbols. e labeled argument and activation graphs of the
program above are depicted in Figure 5.3. For instance, the edge .tŒ1; qŒ1; hf; r1; 1i/ says that
the ﬁrst atom in the body of r1 is an atom whose predicate symbol is t, its ﬁrst term is a variable,
say X, and the atom in the head of r1 is an atom whose predicate symbol is q and whose ﬁrst
term is of the form f .: : : ; X; : : : /. We will show how this kind of information can be proﬁtably
used to analyze Datalogf programs (e.g., to keep track of how complex terms are generated from
argument to argument).
A path  from a1 to bm in a labeled argument graph GL.P / is a non-empty sequence
.a1; b1; h˛1; r1; k1i/; : : : ; .am; bm; h˛m; rm; kmi/ of labeled edges of GL.P / s.t. bi D aiC1 for all
1  i < m. If the ﬁrst and last nodes coincide (i.e., a1 D bm), then  is called a cyclic path. We de-
ﬁne 1./ D ˛1 : : : ˛m as the sequence of  and function symbols labeling the edges of , 2./ D

5.2. TERMINATION CRITERIA
73
r1; : : : ; rm as the sequence of rules labeling the edges of , and 3./ D hr1; k1i : : : hrm; kmi as
the sequence of pairs hrule, body atom identiﬁeri labeling the edges of . In the case where the
indication of the start edge is not relevant, we will call a cyclic path a cycle. Given a cycle  consist-
ing of n labeled edges e1; : : : ; en, we can derive n diﬀerent cyclic paths starting from each of the
ei’s—we use ./ to denote the set of such cyclic paths. As an example, if  is a cycle consisting of
labeled edges e1; e2; e3, then ./ D f.e1; e2; e3/; .e2; e3; e1/; .e3; e2; e1/g. Given two cycles 1
and 2, we write 1 2 iﬀthere exist 1 2 .1/ and 2 2 .2/ such that 3.1/ D 3.2/. A
cycle is basic if it does not contain two occurrences of the same edge.
We say that a node pŒi of GL.P / depends on a node qŒj  of GL.P / iﬀthere is a path from
qŒj  to pŒi in GL.P /. Moreover, we say that pŒi depends on a cycle  iﬀit depends on a node
qŒj  appearing in . Clearly, nodes belonging to a cycle  depend on . We say that 2./ D
r1; : : : ; rm denotes a cyclic path in the activation graph ˝.P / iﬀ.r1; r2/; : : : ; .rm 1; rm/; .rm; r1/
are edges of the activation graph ˝.P /.
Deﬁnition 5.22 Active cycle.
Given a Datalogf program P , we say that a cycle  in GL.P /
is active iﬀ9 2 ./ such that 2./ denotes a cyclic path in the activation graph ˝.P /.
us, checking if a cycle in the labeled argument graph is active requires looking at the
activation graph. Here the basic idea is to check, based on the information reported in the acti-
vation graph, if the propagation of terms along a cycle of the labeled argument graph can really
take place. We illustrate this with the following example.
Example 5.23
Consider the labeled argument graph and the activation graph of Example 5.21
(cf. Figure 5.3). Cycles 1 and 3 in Figure 5.3 are active as .r1; r2/; .r2; r1/ is a cyclic path in the
activation graph. On the contrary, it is easy to check that cycles 2 and 4 in Figure 5.3 are not
active.
In the previous example, the labeled edges of the non-active cycle 4 say that a complex
term with function symbol f might be generated from sŒ2 to qŒ2 (using rule r3), be propagated
from qŒ2 to sŒ2 (using rule r4), and so on and so forth, possibly causing the generation of complex
terms of unbounded size. However, in order for this to happen, rules r3 and r4 should activate
each other, which is not the case from an analysis of the activation graph. us, we can conclude
that the generation of unbounded terms cannot really happen.
On the other hand, active cycles might lead to the generation of terms of unbounded size.
To establish whether this can really be the case, a deeper analysis of the cycles in the labeled
argument graph is performed. Speciﬁcally, grammars are used to analyze edge labels to get a
better understanding of what terms can be propagated among arguments. We use two distinct
languages which allows us to distinguish between “growing” paths, which could give rise to terms
of inﬁnite size, and “balanced” paths, where propagated terms do not grow (see Deﬁnition 5.25).

74
5. FUNCTION SYMBOLS
In addition to the grammar  P of Deﬁnition 5.17, we deﬁne the grammar   0
P below.
Deﬁnition 5.24 Grammar   0
P .
Let P be a Datalogf program and FP the set of function sym-
bols occurring in P . e grammar   0
P is a 4-tuple .N; T; R; S/ where N D fSg is the set of
nonterminal symbols, S is the start symbol, T D ff j f 2 FP g [ ff j f 2 FP g is the set of
terminal symbols, R contains the production rule:
• S ! f S f S j ,
8f 2 FP .
e language L.  0
P / is the set of strings generated by   0
P .
Notice that L. P / \ L.  0
P / D ;. Recall that grammar  P has been introduced in Greco
et al. [2012b] to analyze cycles of the propagation graph. Here we consider a more detailed anal-
ysis of the relationships among arguments by considering also   0
P . Intuitively, strings in L. P /
describe growing sequences of functions symbols used to compose and decompose complex terms,
so that, starting from a given term we obtain a larger term. On the other hand, strings in L.  0
P /
describe “balanced” sequences of functions symbols used to compose and decompose complex
terms, so that starting from a given term we obtain the same term.
Deﬁnition 5.25 Classiﬁcation of cycles.
Given a Datalogf program P and a cycle  in GL.P /,
we say that  is
• growing if there is  2 ./ s.t. 1./ 2 L. P /,
• balanced if there is  2 ./ s.t. 1./ 2 L.  0
P /, and
• failing otherwise.
Consider the labeled argument graph in Figure 5.3. Cycles 1, 3, and 4 are growing,
whereas cycle 2 is failing. Observe that, in general, a failing cycle is not active, but the inverse is
not true. In fact, cycle 4 from Figure 5.3 is not active even if it is not failing.
e tools introduced so far are used to deﬁne the binding operator 	P (Deﬁnition 5.26
below). e idea is to compute the ﬁxpoint of 	P starting from a set of limited arguments, so
as to get a set of limited arguments, which can be used as an underestimation of the limited
arguments of the program. If the ﬁxpoint computation gives us all arguments of P , then P is
bounded.
Deﬁnition 5.26
	P operator.
Let P be a Datalogf program and A  arg.P /. We deﬁne
	P .A/ as the set of arguments qŒk of P such that, for each cycle  in GL.P / on which qŒk
depends, at least one of the following conditions holds:
1.  is not active or is not growing;

5.2. TERMINATION CRITERIA
75
2.  contains an edge .sŒj ; pŒi; hf; r; li/ and, letting p.t1; : : : ; tn/ be the atom in the head of
r, for every variable X in ti, there is an atom b.u1; : : : ; um/ in body.r/ s.t. X appears in a
term uh and bŒh 2 A; and
3. there is a cycle 0 in GL.P / s.t. 0 , 0 is not balanced, and 0 passes only through
arguments in A.
e following example illustrates the 	P operator.
Example 5.27
Consider the Datalogf program of Example 5.21, whose labeled argument and
activation graphs are reported in Figure 5.3. Notice that cycles 1 and 3 are growing and active,
2 is failing and non-active, 4 is growing and non-active. e cycle 5 composed by 1 and 2
(denoted by a dashed line) is failing and non-active, and the cycle 6 composed by 3 and 4
(denoted by a dashed line) is growing and non-active. Furthermore, base arguments aŒ1 and bŒ1
do not depend on any cycle; tŒ1, qŒ1, sŒ1 depend on 1, 2, and 5; tŒ2, qŒ2, sŒ2 depend on
3, 4, and 6. By iteratively applying operator 	P starting from ; we have:
• A1 D 	P .;/ D faŒ1; bŒ1g;
• A2 D 	P .A1/ D A1 [ ftŒ1; qŒ1; sŒ1g as Condition 2 of Deﬁnition 5.26 applies to 1, and
Condition 1 applies to 2 and 5; and
• A3 D 	P .A2/ D A2 [ ftŒ2; qŒ2; sŒ2g as Condition 1 applies to 4 and 6, and Condi-
tion 3 applies to 3 (in fact, 1 3, 1 is not balanced and goes only through nodes in
A3).
erefore, we derive that all arguments are limited.
We are now ready to deﬁne the class of bounded programs. Given a Datalogf program P , we
start with the set of restricted arguments AR.P /, which gives a good and eﬃciently computable
approximation of the set of limited arguments; then, we iteratively apply operator 	P trying to
infer more limited arguments. If, eventually, all arguments in arg.P / are determined as limited,
then P is bounded.
More formally, given a Datalogf program P , the i-th iteration of 	P (i  1) w.r.t. a set
A  arg.P / is deﬁned as follows: 	 1
P .A/ D 	P .A/ and 	 i
P .A/ D 	P .	 i 1
P
.A// for i > 1. It can
be easily veriﬁed that 	P always has a ﬁxpoint, denoted by 	 1
P .A/.
Deﬁnition 5.28 Bounded programs.
e set of bounded arguments of a Datalogf program P
is 	 1
P .AR.P //. We say that P is bounded iﬀall its arguments are bounded.
Bounded programs strictly include argument-restricted and   -acyclic programs [Greco
et al., 2013a].

76
5. FUNCTION SYMBOLS
5.3
PROGRAM ADORNMENT
e termination criteria discussed in the previous section are not able to identify as terminating
even simple Datalogf programs whose bottom-up evaluation always terminates. For instance,
consider the following example.
Example 5.29
Consider the following Datalogf program
p.X; X/
 
base.X/:
q.X; Y /
 
p.X; Y /:
p.f .X/; g.X//
 
q.X; X/;
where base is a base predicate symbol. e bottom-up evaluation of the program terminates what-
ever set of facts for base is added to it. Nevertheless, none of the termination criteria introduced
so far is able to realize that the bottom-up evaluation terminates.
In this section, we present an orthogonal technique that, used in conjunction with current
termination criteria, allows us to detect more Datalogf programs whose evaluation terminates.
e technique has been introduced in Greco et al. [2013b]. It takes a Datalogf program P and
transforms it into an “adorned” Datalogf program P  with the aim of applying termination cri-
teria to P  rather than P . e transformation is sound in that if P  satisﬁes a certain termination
criterion, then the bottom-up evaluation of P terminates.
Applying termination criteria to adorned programs rather than the original ones makes
termination criteria (strictly) more eﬀective, that is, (strictly) more programs whose evaluation
terminates are recognized. Roughly speaking, each adorned rule is obtained from a rule in the
original program by adding adornments, which keep track of the structure of the terms that can
be propagated during the bottom-up evaluation. Here the basic idea is to generate only rules that
have a chance to trigger, and disregard those rules that have no chance to trigger (because what
can actually be derived during the program evaluation does not comply with the structure of the
body). As adorning predicate symbols possibly breaks “cyclic” dependencies among arguments
and/or rules, this often allows us to recognize more Datalogf programs as terminating than if
termination criteria are applied to the original Datalogf programs. An example is provided below.
Example5.30
Consider again the Datalogf program of Example 5.29. e technique presented
in this section transforms it into the following adorned Datalogf program:
p.X; X/
 
base.X/:
q.X; Y /
 
p.X; Y /:
pf1g1.f .X/; g.X//
 
q.X; X/:
qf1g1.X; Y /
 
pf1g1.X; Y /:
e adorned program above is “equivalent” to the original one of Example 5.29 in that the least
model of the original program can be obtained from the least model of the transformed program
by dropping adornments.

5.3. PROGRAM ADORNMENT
77
As opposed to the original program, the transformed program above is not recursive, and
thus, it is easily recognized as terminating by all current termination criteria. is allows us to say
that the bottom-up evaluation of the original program is terminating because of the aforemen-
tioned equivalence.
For the sake of simplicity and without loss of generality, we assume that databases do not
contain complex terms (hence, we can assume that base atoms in rule bodies do not contain
complex terms). For instance, the set of facts fbase.a/; base.f .b//g can be replaced with the set
of facts fbase.a/; base.b/g and the rules fbased.a/  base.a/; based.f .b//  base.b/g, where
based is a derived predicate symbol. Additionally, atoms appearing in rule bodies and having base
as predicate symbol are replaced with the same atoms where based replaces base. Since databases
are not relevant for the proposed technique, they are not shown in examples. In fact, as discussed
in the following, the technique allows us to conclude that the evaluation of a Datalogf program
terminates for any database that is added to the program.
We start by introducing notation and terminology used hereafter. We will use the
notation p.t/ to refer to an atom p.t1; : : : ; tn/ (here t is understood to be a sequence
of n terms). Given a Datalogf program P , we deﬁne the adornment alphabet  D fg [
ffi j f is a function symbol in P and i 2 Ng; elements of  are called adornment symbols. An
adornment ˛ for a predicate symbol p of arity n is a string of length n over the alphabet ; the
expression p˛ is an adorned predicate symbol, and p˛.t1; : : : ; tn/ is an adorned atom, where the ti’s
are terms. An adorned conjunction is a conjunction of adorned atoms. An adorned rule is a rule con-
taining only adorned atoms. Given an adornment symbol fi in    fg, an adornment deﬁnition
for fi is an expression of the form fi D f .˛1; : : : ; ˛m/, where m is the arity of function symbol
f and the ˛i’s are adornment symbols. As an example, if the transformation technique derives
an adorned predicate symbol pf1g1 with adornment deﬁnitions f1 D f ./ and g1 D g.f1/, this
means that the bottom-up evaluation of the considered Datalogf program might yield atoms of
the form p.f .c1/; g.f .c2/// with c1 and c2 being constants.³ Intuitively, adornment deﬁnitions
are used to keep track of what kind of complex terms can be propagated.
Roughly speaking, the transformation technique works as follows. It maintains a set of
adorned predicate symbols, a set of adornment deﬁnitions, and a set of adorned rules. Whenever
we ﬁnd a rule whose body can be adorned in a “coherent” way (we will make clear what this
means in Deﬁnition 5.33), we derive an adorned predicate symbol from the rule head (using the
body adornments), and generate an adorned rule. In this step, new adornment deﬁnitions might
³Here predicate symbol p is assumed of arity 2, and function symbols f and g are assumed of arity 1.

78
5. FUNCTION SYMBOLS
be generated as well. New adorned predicate symbols are used to generate further adorned rules.
Below is an example that illustrates the basic idea.
Example5.31
Consider the following Datalogf program, where base is a base predicate symbol:
r0 W
p.X; f .X//
 
base.X/:
r1 W
p.X; f .X//
 
p.Y; X/; base.Y /:
r2 W
p.X; Y /
 
p.f .X/; f .Y //:
First, base predicate symbols are adorned with strings of ’s; thus, we get the adorned predicate
symbol base. is is used to adorn the body of r0 so as to get
0 W pf1.X; f .X//  base.X/
from which we derive the new adorned predicate symbol pf1, and the adornment deﬁnition
f1 D f ./. Next, pf1 and base are used to adorn the body of r1 so as to get
1 W pf1f2.X; f .X//  pf1.Y; X/; base.Y /
from which we derive the new adorned predicate symbol pf1f2, and the adornment deﬁnition
f2 D f .f1/. Intuitively, the body of 1 is coherently adorned because Y is always associated with
the same adornment symbol . Using the new adorned predicate symbol pf1f2, we can adorn rule
r2 and get
2 W pf1.X; Y /  pf1f2.f .X/; f .Y //:
At this point, we are not able to generate new adorned rules (using the adorned predicate symbols
generated so far) with coherently adorned bodies and the transformation terminates. For instance,
we may attempt to adorn the body of r1 as pf1f2.Y; X/; base.Y /, but this is not coherently
adorned because the same variable Y is associated with both f1 and . As a further example,
we may attempt to adorn the body of r2 as pf1.f .X/; f .Y //, but again this is not coherently
adorned because f .X/ does not comply with the term structure described by , which indicates
that the ﬁrst term of the atom should be a simple term.
e order according to which rules are adorned is irrelevant.
In the previous example, to determine termination of the bottom-up evaluation of the
original program, we can apply current termination criteria to the transformed program P  D
f0; 1; 2g rather than the original one. In fact, the adornment technique ensures that if P 
is recognized as terminating, so is the original program. Notice that both the original program
and the transformed one are recursive, but while some termination criteria (e.g., the argument-
restricted,   -acyclicity, and bounded criteria) detect P  as terminating, none of the current ter-
mination criteria is able to realize that the original program’s evaluation terminates.
For instance, consider argument-restriction (cf. Section 5.2.3). e original program of
Example 5.31 above is not argument-restricted, as there is no argument ranking for it. In fact,

5.3. PROGRAM ADORNMENT
79
every argument ranking must satisfy .pŒ2/   .pŒ2/  1 (because of rule r1), but this con-
dition is clearly unsatisﬁable. On the other hand, the transformed program P  D f0; 1; 2g
is argument-restricted, as an argument ranking for it can be found. For instance, the function
 deﬁned as follows is an argument ranking: .baseŒ1/ D 0, .pf1Œ1/ D 0, .pf1Œ2/ D 1,
.pf1f2Œ1/ D 1, .pf1f2Œ2/ D 2.
Furthermore, the transformation technique allows current termination criteria to detect
strictly more programs as terminating under bottom-up evaluation. As an example, the original
program in the example above is not argument-restricted, so we could not say anything about
the termination of its bottom-up evaluation on the basis of such a criterion. However, P  is
argument-restricted and this allows us to conclude that the bottom-up evaluation of the original
program terminates for any database added to it.
In the following, we formally present the transformation technique. First, we deﬁne how to
determine the adornment symbols associated with the variables in an adorned conjunction, and
how to check if the conjunction is coherently adorned. en, we deﬁne how to determine the
adornment of a rule head when its body is coherently adorned. Finally, we present the complete
technique.
Checking adornment coherency.
e aim of adornment coherency is to check if the adorned
conjunction in the body of an adorned rule satisﬁes two conditions that are necessary for the
rule to “trigger.” First, for each adorned atom p˛1:::˛n.t1; : : : ; tn/ in the conjunction, we check
if ti complies with the term structure corresponding to ˛i. As an example, in the adorned atom
pf1.g.X// with adornment deﬁnition f1 D f ./, g.X/ does not comply with the term structure
f .c/ corresponding to f1, where c is an arbitrary constant. Second, we determine the adornment
symbol associated with each variable occurrence in the conjunction and check if, for every variable,
all its occurrences are associated with adornment symbols describing compatible term structures.
As an example, if pf1g1.X; X/ is an atom in the conjunction with adornment deﬁnitions f1 D
f ./ and g1 D g./, then two diﬀerent term structures are associated with two occurrences of the
same variable X and the conjunction is not coherently adorned.
Function TermAdn below determines the adornment symbols associated with the variables
in a term ti in an adorned atom p˛1:::˛n.t1; : : : ; tn/ on the basis of ˛i and a set of adornment deﬁni-
tions S. Function BodyAdn simply collects the adornment symbols for all variables in an adorned
conjunction (using TermAdn), and is used to check if the conjunction is coherently adorned.
Deﬁnition 5.32
Let body be an adorned conjunction and S a set of adornment deﬁnitions.
We deﬁne
BodyAdn.body; S/ D
[
p˛1:::˛n.t1;:::;tn/ 2 body^
1 i n
TermAdn.ti;˛i;S/I
where TermAdn is recursively deﬁned as follows:
1. TermAdn.ti; ; S/ D ;, if ti is a constant;

80
5. FUNCTION SYMBOLS
2. TermAdn.ti; ˛i; S/ D fti=˛ig, if ti is a variable;
3. TermAdn.f .u1; : : : ; um/; fi; S/D
mS
j D1
TermAdn.uj ; ˛j ; S/, if fi Df .˛1; : : : ; ˛m/ is in S;
and
4. TermAdn.ti; ˛i; S/ D ffailg, otherwise.
Notice that there is a non-deterministic choice to be made in item 3 above, when
there are multiple adornment deﬁnitions for the same fi in S. Depending on the choice,
BodyAdn.body; S/ can return diﬀerent sets; we deﬁne SBodyAdn.body; S/ as the set of all pos-
sible outcomes. Notice that if body is the empty conjunction, then SBodyAdn.body; S/ contains
only the empty set.
Deﬁnition 5.33
Consider an adorned conjunction body and a set of adornment deﬁnitions S,
and let W 2 SBodyAdn.body; S/. We say that body is coherently adorned w.r.t. W iﬀfail 62 W
and for every two distinct X=˛ and X=ˇ in W it is the case that ˛ D fi and ˇ D fj, where f is
a function symbol and i; j 2 N.
Notice
that
the
empty
conjunction
is
coherently
adorned.
Given
a
set
W 2
SBodyAdn.body; S/, we deﬁne S.W / as the set of all subsets T of W containing exactly one
expression of the form X=˛ for every variable X in body. e following example illustrates the
previous deﬁnitions.
Example 5.34
Consider
the
set
of
adornment
deﬁnitions
S D ff2 D f .f1/; f1 D
f ./; g1 D g./g.
For
the
adorned
conjunction
pf2g1.f .f .X//; g.X//,
we
have
that
BodyAdn.pf2g1.f .f .X//; g.X//; S/ can return only the set W obtained as follows:
W
D
TermAdn.f .f .X//; f2; S/ [ TermAdn.g.X/; g1; S/
D
TermAdn.f .X/; f1; S/ [ TermAdn.X; ; S/
D
TermAdn.X; ; S/ [ fX=g
D
fX=g [ fX=g D fX=g;
and pf2g1.f .f .X//; g.X// is coherently adorned w.r.t. W .
Considering qf2.f .g.X///, we have that BodyAdn.qf2.f .g.X///; S/ can return only
W D TermAdn.f .g.X//; f2; S/ D TermAdn.g.X/; f1; S/ D ffailg, and qf2.f .g.X/// is not co-
herently adorned w.r.t. W .
Considering pf2g1.f .X/; g.X//, we have that BodyAdn.pf2g1.f .X/; g.X//; S/ can re-
turn only the set W obtained as follows:
W
D
TermAdn.f .X/; f2; S/ [ TermAdn.g.X/; g1; S/
D
TermAdn.X; f1; S/ [ TermAdn.X; ; S/
D
fX=f1g [ fX=g D fX=f1; X=g;
and pf2g1.f .X/; g.X// is not coherently adorned w.r.t. W .

5.3. PROGRAM ADORNMENT
81
Head adornment.
When the conjunction in the body of a rule can be coherently adorned,
adornments are propagated from the body to the head. e adornment of the head predicate
symbol is determined on the basis of (i) the structure of the terms in the head, and (ii) the
adornment symbols associated with the variables in the body. As an example, consider the rule
p.X; f .X; g.X///  b.X/ and the adorned body conjunction b.X/. e adornment symbol
associated with variable X is , which intuitively means that the bottom-up evaluation of the
considered Datalogf program might yield atoms of the form b.c/, with c being a constant. As
a consequence, the rule above might yield atoms of the form p.c; f .c; g.c///. To keep track of
this, the head predicate symbol is adorned as pf1, and the adornment deﬁnitions f1 D f .; g1/
and g1 D g./ are derived.
We start by introducing a special (asymmetric) “union operator,” denoted by t, which takes
as input a set of adornment deﬁnitions S and a set containing a single adornment deﬁnition
fh D f .˛1; : : : ; ˛m/, and gives as output a set S0 of adornment deﬁnitions with S  S0. Operator
t is deﬁned as follows:
• S t ffh Df .˛1; : : : ; ˛m/gDS, if there exists fk Df .˛1; : : : ; ˛m/ in S; and
• S t ffh Df .˛1; : : : ; ˛m/gDS [ ffh Df .˛1; : : : ; ˛m/g, if there is no fk Df .˛1; : : : ; ˛m/
in S.
We are now ready to deﬁne how rule heads are adorned.
Deﬁnition 5.35
Consider a Datalogf rule p.t1; : : : ; tn/  body, a set of adornment deﬁnitions
S0, and an adorned conjunction body obtained by adding adornments to all atoms in body. Let W
be an element of SBodyAdn.body; S0/ s.t. body is coherently adorned w.r.t. W , and T 2 S.W /.
e adornment of the head atom p.t1; : : : ; tn/ w.r.t. T and S0 is
SetHeadAdn.p.t1; : : : ; tn/; T; S0/ D hp˛1:::˛n.t1; : : : ; tn/; Sni;
where
h˛1; S1i D Adn.t1; T; S0/
h˛2; S2i D Adn.t2; T; S1/
:::
h˛n; Sni D Adn.tn; T; Sn 1/
and function Adn is deﬁned as follows:
• Adn.t; T; S/ D h; Si, if t is a constant;
• Adn.t; T; S/ D h˛i; Si, if t is a variable X and X=˛i is in T ;⁴
• Adn.f .u1; : : : ; um/; T; S/ D hfj ; S0i, where
⁴Notice that X always appears in body because of the safety condition (cf. Section 3.1).

82
5. FUNCTION SYMBOLS
– hˇ1; S1i D Adn.u1; T; S/;
– hˇ2; S2i D Adn.u2; T; S1/;
:::
– hˇm; Smi D Adn.um; T; Sm 1/;
– S0 D Sm t ffi Df .ˇ1; : : : ; ˇm/g, with i D maxfk j fk Df .1; : : : ; m/ 2 Smg C 1;
– j is s.t. fj D f .ˇ1; : : : ; ˇm/ is in S0.
Example 5.36
Consider the Datalogf rule
p.f .a; nil/; f .X; f .Y; nil///  base.X; Y /
and the adorned body base.X; Y /. en, SBodyAdn.base.X; Y /; ;/ has one element, W D
fX=; Y=g, and T D fX=; Y=g is the only element in S.W /. en,
SetHeadAdn.p.f .a; nil/; f .X; f .Y; nil///; T; ;/
gives hpf1f2.f .a; nil/; f .X; f .Y; nil///; S2i, where S2 D ff1 D f .; /; f2 D f .; f1/g. In fact,
by Deﬁnition 5.35,
• Adn.f .a; nil/; T; ;/ gives hf1; S1i; where S1 D ff1 D f .; /g; since
– Adn.a; T; ;/ gives h; ;i; and
– Adn.nil; T; ;/ gives h; ;i:
• en, Adn.f .X; f .Y; nil//; T; S1/ gives hf2; S2i as
– Adn.X; T; S1/ gives h; S1i; and
– Adn.f .Y; nil/; T; S1/ gives hf1; S1i as
* Adn.Y; T; S1/ gives h; S1i; and
* Adn.nil; T; S1/ gives h; S1i:
Transformation function.
Before presenting the complete transformation technique, we intro-
duce some further notations and terminology. An adornment substitution  is a set of pairs the
form fi=fj (i.e., the same function symbol is used, but with diﬀerent subscripts) with i > j that
does not contain two pairs of the form fi=fj and fj =fk. us, a symbol fi cannot be replaced
by a symbol gh, and a symbol fj used to replace a symbol fi cannot be substituted in  by a
symbol fk—where fi; fj ; fk; gh are in    fg. For instance, ff2=f1; g3=g1g is an adornment
substitution, but ff1=g1g and ff3=f2; f2=f1g are not. e result of applying  to an adorned rule
r, denoted r, is the adorned rule obtained from r by substituting each fi appearing in r with

5.3. PROGRAM ADORNMENT
83
Algorithm 3 Adorn
Input: Datalogf program P .
Output: Adorned Datalogf program P .
1: S D ;; P  D ;;
2: AP D fp˛1:::˛n j p is a base predicate symbol appearing in P of arity n and every ˛i D g;
3: repeat
4:
AP0 D AP;
5:
for each rule p.t/ body in P do
6:
for each body in A.body; AP/ do
7:
for each W in SBodyAdn.body; S/ do
8:
if body is coherently adorned w.r.t. W then
9:
for each T in S.W / do
10:
hp˛.t/;S0i D SetHeadAdn.p.t/; T; S/;
11:
AP D AP [ fp˛g; S D S0;
12:
ar D p˛.t/ body;
13:
P  D P  [ farg;
14:
if 9r 2P  ^ 9substitution  ¤ ; s:t: ar Dr then
15:
P  D P ; AP D AP; S D S;
16: until AP0 D AP
17: return P ;
fj, where fi=fj belongs to . e result of applying  to a set of adorned rules P  (resp. adorned
predicate symbols AP, adornment deﬁnitions S), denoted P  (resp. AP, S), is analogously
deﬁned.
e set of the adorned versions of an atom p.t/ w.r.t. a set of adorned predicate symbols
AP is A.p.t/; AP/ D fp˛.t/ j p˛ 2 APg. e set of the adorned versions of a conjunction of atoms
body D A1; : : : ; Ak w.r.t. AP is A.body; AP/ D fAA1; : : : ; AAk j AAi 2 A.Ai; AP/ for 1  i  kg.
If body is the empty conjunction, then A.body; AP/ contains only the empty conjunction.
Function Adorn (Algorithm 3) performs the transformation of a Datalogf program. It
maintains a set of adornment deﬁnitions S, a set of adorned rules P  (eventually, this will be the
output), and a set AP of adorned predicate symbols. Initially, S and P  are empty (line 1), and
AP contains all base predicate symbols in P adorned with strings of ’s (line 2). en, for each
coherently adorned body body of a rule p.t/ body in the original program, we determine the
adorned head p˛.t/ and the set of adornment deﬁnitions S0 using function SetHeadAdn (line 10).
e set AP is extended with p˛, S0 is assigned to S (line 11), and a new adorned rule ar of the
form p˛.t/ body is added to P  (line 13). If there exists an adornment substitution  that
applied to ar gives a rule r in P , then  is applied to P , AP, and S (line 15). is ensures
termination of Adorn.

84
5. FUNCTION SYMBOLS
e following example shows the role of adornment substitutions.
Example 5.37
Consider the Datalogf program below where base is a base predicate symbol:
p.X/
 
base.X/:
p.f .X//
 
p.X/:
Starting from S D ;, P  D ;, and AP D fbaseg, the transformation algorithm adds the follow-
ing adorned rules to P 
0 W
p.X/
 
base.X/:
1 W
pf1.f .X//
 
p.X/:
2 W
pf2.f .X//
 
pf1.X/:
3 W
pf3.f .X//
 
pf2.X/:
Furthermore, the adornment deﬁnitions f1 D f ./, f2 D f .f1/, f3 D f .f2/ are added to S, and
the adorned predicate symbols p, pf1, pf2, pf3 are added to AP. At this point, the following
adorned rule is derived and added to P :
4 W
pf4.f .X//
 
pf3.X/:
e adornment deﬁnition f4 D f .f3/ is added to S and pf4 is added to AP. However, since there
is an adornment substitution  D ff4=f2; f3=f1g such that 4 D 2, then  is applied to P ,
AP, and S. us, P  becomes f0; 1; 2; 3g, where 3 is
pf1.f .X//
 
pf2.X/:
AP D fp; pf1; pf2g and S D ff1 D f ./; f2 D f .f1/; f1 D f .f2/g. At this point, no new
adorned rule can be generated and the algorithm terminates.
In the previous example, notice that both the original and the transformed programs are not
recognized as terminating by current termination criteria. Indeed, for any database containing at
least one fact base.c/, the least model is not ﬁnite and the bottom-up evaluation of both programs
never terminates. Nevertheless, function Adorn terminates.
We conclude this section by mentioning diﬀerent important properties of the transforma-
tion technique (more details can be found in Greco et al. [2013b]).
First of all, function Adorn always terminates.
An important property of the transformation technique is that the original Datalogf pro-
gram it takes as input and the transformed Datalogf program it gives as output are “equivalent”
in the following sense: the least model of the original program can be obtained from the least
model of transformed program by dropping adornments.
Another crucial property of the transformation technique is its soundness: if the trans-
formed program Adorn.P / satisﬁes one of the termination criteria presented in the previous sec-
tion, then the bottom-up evaluation of the original Datalogf program P terminates—indeed, we

5.4. DEALING WITH DISJUNCTION AND NEGATION
85
can state that the evaluation of P [ D terminates for any ﬁnite database D (recall that we assume
that databases do not contain complex terms). us, the least model of P [ D is ﬁnite, and can
be computed.
Finally, applying termination criteria to adorned programs as discussed in this section allows
us to detect strictly more programs as terminating.
5.4
DEALING WITH DISJUNCTION AND NEGATION
e termination criteria presented in this chapter have been originally proposed for Datalog pro-
grams allowing function symbols, negation in the body, and disjunction in the head of rules. In
this chapter, we have restricted attention to Datalogf programs (where there is no negation in
rule bodies and no disjunction in rule heads).
Nevertheless, a program P with disjunction in the head and negation in the body (e.g., see
Example 5.38) can be analyzed by checking termination of a Datalogf program st.P / derived
from P as follows: every rule A1 _    _ Am  body in P is replaced with m Datalogf rules of
the form Ai  bodyC (1  i  m) where bodyC is obtained from body by deleting all negative
literals.
It is easy to see that if M is the least model of st.P /, then SM  M for every stable
model SM of P (because deleting literals from rule bodies and introducing multiple rules for
head disjunctions allows us to infer more ground atoms). Hence, if st.P / satisﬁes a termina-
tion criterion, then P has a ﬁnite number of stable models, and each of them has ﬁnite size
and can be computed—e.g., by computing the stable models of the (ﬁnite) ground program
P 0  ground.P / consisting only of those rules whose terms all appear in M.
Indeed, the analysis performed by current termination criteria over a program P (possibly
with negation and disjunction) is equivalent to the analysis of st.P /, because the analysis ignores
negation and looks at a rule A1 _    _ Am  body in the same way as m rules of the form Ai  
body, 1  i  m.
Example 5.38
Consider the following program P where disjunction and negation occur:
p.X/ _ q.f .X//
 
s.X/; :base.X/:
s.X/
 
q.g.X//; :p.X/:
en, st.P / is as follows:
p.X/
 
s.X/:
q.f .X//
 
s.X/:
s.X/
 
q.g.X//:
If st.P / satisﬁes a certain termination criterion, then P has a ﬁnite set of stable models and each
of them has ﬁnite size and can be computed.

86
5. FUNCTION SYMBOLS
BIBLIOGRAPHIC NOTES
A signiﬁcant body of work has been done on termination of logic programs under top-down
evaluation [Baselice et al., 2009, Bonatti, 2004, Bruynooghe et al., 2007, Codish et al., 2005,
De Schreye and Decorte, 1994, Marchiori, 1996, Nguyen et al., 2007, Nishida and Vidal, 2010,
Ohlebusch, 2001, Schneider-Kamp et al., 2009a,b, 2010, Serebrenik and De Schreye, 2005, Voets
and De Schreye, 2011].
e problem of checking termination of the bottom-up evaluation of Datalogf programs
is also akin to work done in the area of term rewriting [Arts and Giesl, 2000, Endrullis et al.,
2008, Ferreira and Zantema, 1996, Sternagel and Middeldorp, 2008, Zantema, 1994, 1995].
In this chapter, we have considered the problem of checking if the bottom-up evaluation
of a Datalogf program terminates, and thus, as noticed and discussed in Alviano et al. [2010],
Calimeri et al. [2008, 2010], all the works above cannot straightforwardly be applied to the setting
considered in this chapter.
As for the context considered in this chapter, recent years have witnessed an increasing
interest in the problem of identifying Datalog programs with function symbols for which a ﬁnite
set of ﬁnite stable models exists and can be computed.
e class of ﬁnitely-ground programs, guaranteeing the aforementioned desirable property,
has been proposed in Calimeri et al. [2008]. Since membership in the class is not decidable,
recent research has concentrated on the identiﬁcation of decidable suﬃcient conditions for a pro-
gram to be ﬁnitely-ground. Eﬀorts in this direction are !-restricted programs [Syrjänen, 2001],
-restricted programs [Gebser et al., 2007], and ﬁnite domain programs [Calimeri et al., 2008].
More general classes are argument-restricted programs [Lierler and Lifschitz, 2009], safe and   -
acyclic programs [Calautti et al., 2015a, Greco et al., 2012b], mapping-restricted programs [Calautti
et al., 2013], bounded programs [Greco et al., 2013a], rule- and cycle-bounded programs [Calautti
et al., 2014, 2015c, 2016], and size-restricted programs [Calautti et al., 2015b]. We point out
that the aforementioned techniques have been proposed for Datalog programs allowing function
symbols, negation in the body, and disjunction in the head of rules. In this chapter, we restricted
attention to Datalogf programs (where there is no negation in rule bodies and no disjunction in
rule heads). However, the analysis performed by current techniques over a program P , possibly
with negation and disjunction, is indeed equivalent to the analysis of the Datalogf program st.P /
(cf. Section 5.4).
Termination properties of query evaluation for programs under tabling were studied
in Riguzzi and Swift [2014], Verbaeten et al. [2001].
e topic of this chapter is also related to research done in the database community on
termination of the chase procedure, where existential rules are considered [Deutsch et al., 2008,
Fagin et al., 2005, Grau et al., 2013, Greco and Spezzano, 2010, Greco et al., 2011, Krötzsch
and Rudolph, 2011, Marnette, 2009b, Meier et al., 2009]. A survey on this topic can be found
in Greco et al. [2012a].

5.4. DEALING WITH DISJUNCTION AND NEGATION
87
Indeed, suﬃcient conditions ensuring termination of the bottom-up evaluation of logic
programs can be directly applied to existential rules. Speciﬁcally, one can analyze the logic pro-
gram obtained from the skolemization of existential rules, where existentially quantiﬁed variables
are replaced with complex terms [Marnette, 2009a]. In fact, the evaluation of such a program
behaves as the “semi-oblivious” chase [Marnette, 2009a], whose termination guarantees the ter-
mination of the standard chase [Meier, 2010, Onet, 2013]. us, if the program obtained from
the skolemization of a set of existential rules satisﬁes a termination criterion, then its bottom-up
evaluation terminates, which means that the semi-oblivious chase for the original set of existential
rules terminates, which in turn implies that the standard chase for the original set of existential
rules terminates.
On the other hand, termination criteria developed for the chase cannot directly applied to
Datalog programs with function symbols. e rules obtained via skolemization of existential rules
are of a very restricted form: function symbols appear only in rule heads, each function symbol
occurs at most once, there is no nesting of function symbols. In contrast, we have considered a
much more general setting allowing an arbitrary use of function symbols: they can appear in both
the head and the body of rules, may be nested, and the same function symbol can appear multiple
times.


89
C H A P T E R
6
Aggregates
In this chapter, we extend Datalog to include aggregation constructs, such as count, sum, and
summation, and show how they help express optimization problems.
Aggregates are an important feature of query languages and allow us to summarize a large
amount of data into a single value—for instance, they can be used to count the number of products
supplied by a certain supplier, or compute the total amount of a certain purchase.
We ﬁrst discuss two classical aggregates, namely count and sum. en, we present the
summation aggregate proposed by Greco [1999a]. Finally, we consider the combination of the
summation aggregate and the choice-least and choice-most constructs (cf. Section 4.6), and illus-
trate how they can be used to easily express classical optimization problems.
For all the aforementioned aggregate constructs, we provide a declarative semantics based
on rewriting programs with aggregates into programs with choice and choice-least/most con-
structs.
6.1
SYNTAX
In this section, we discuss some common syntactical aspects of the languages considered in this
chapter. In the following sections, we will individually consider diﬀerent languages, each obtained
by extending Datalog with a speciﬁc aggregate.
An aggregate is a function that takes a multiset of values as input and returns a single value
as output. Indeed, besides allowing aggregates, in this chapter the syntax of Datalog is extended
to allow arithmetic and comparison operators too.
We will make use of arithmetic on a ﬁnite subset N of the cardinal numbers. More specif-
ically, given a program P , we assume the existence of a ﬁnite subset N D f0; : : : ; nP g of cardinal
numbers, where nP is the maximum number a programmer wants to manipulate in program P .
In contrast to other constants, which are uninterpreted, constants in N are interpreted, as
well as the arithmetic operators deﬁned on N. e operators we consider are the usual arithmetic
operators of sum, diﬀerence, product, and so on, which are interpreted in the standard way. Ob-
serve that the assumption of a ﬁnite subset of the cardinal numbers guarantees that the Herbrand
universe is ﬁnite and the the bottom-up evaluation of a program always terminates.
In the following, we assume that for each predicate symbol at most one argument, called
cost argument, can take values from the ordered domain N whereas all the remaining arguments
take values from the Herbrand universe. Variables appearing in cost arguments will be called cost

90
6. AGGREGATES
variables. For the sake of simplicity, we also assume that the cost argument in a predicate, if any,
is always the last one.
Comparison atoms of the form t1 op t2 are allowed in the body of rules, where op is a com-
parison predicate symbol (i.e., op 2 f; >; ; <; D; ¤g) and t1 and t2 are terms. Besides constants
and variables, t1 and t2 can be complex arithmetic expressions involving arithmetic operators, con-
stants from N, and variables. Such terms are interpreted in the standard way and then compared
according to op. For instance, given the comparison atom X D 2  Y , its true ground instances
are those where X is replaced with a value which is twice the value Y is replaced with.
Aggregates are expressed by means of aggregate atoms of the form sum..X/; V; S/,
count..X/; C/, summation..X/; V; S/, where X is a list of variables, and V , S, and C are variables.
e intuitive meaning as well as a formal semantics of such aggregate atoms will be discussed in
the following sections. Aggregate atoms can appear only in the body of rules.
us, the body of a rule can contain standard atoms (i.e., atoms whose predicate symbol is
neither a comparison predicate symbol nor an aggregate one), comparison atoms, and aggregate
atoms.
Every rule must be safe. To accommodate the three diﬀerent types of atoms that can occur
in a rule, the safety condition is deﬁned as follows. For every rule, every variable must be limited
in the following sense:
• a variable X is limited if it appears in a standard atom in the body; and
• a variable X is limited if it appears in a comparison atom of the form X D t or t D X,
where t is a term whose variables are all limited (notice that t can be a complex arithmetic
expression)—in the case that t is a constant, the condition is trivially satisﬁed.
In the rest of the chapter we ﬁrst present the sum and count aggregates. en, we consider
the summation aggregate. After that, we discuss the combination of summation and choice-least
and choice-most. We point out that the classical min and max aggregates can indeed be expressed
by the choice-least and choice-most constructs, respectively.
Given a list of terms X, we will use var.X/ to denote the list of variables occurring in X.
6.2
SUM AND COUNT
e aggregates sum and count were ﬁrst introduced in Mumick et al. [1990] and further investi-
gated in several subsequent papers.
In the following, we deﬁne syntax and semantics of such aggregates. In particular, we
present the semantics given by Greco [1999a], which is deﬁned in terms of choice-most pro-
grams.
Sum aggregate.
e sum aggregate is expressed by means of atoms of the form sum..X/; V; S/,
where X is a list of variables, and V and S are variables. e intuitive meaning is that, given a
multiset T of tuples of the form .x; v/, where x is a list of constants from the Herbrand universe

6.2. SUM AND COUNT
91
called the X-value of the tuple and v is a value from N called the V -value of the tuple, for each
maximal subset T 0 of T of tuples having the same X-value, all the V -values must be added,
yielding S. us, the aggregate atom yields as many values for S as the number of distinct values
of X. An example is provided below.
Example 6.1
Consider the rule
p.X; S/  q.X; Y; V /; sum..X/; V; S/
along with the following facts:
q.a; c; 2/:
q.a; d; 4/:
q.b; c; 3/:
e evaluation of the rule above yields p.a; 6/ by summing up the V -values of the ﬁrst two facts,
and p.b; 3/ by summing up the V -value of the last fact.
If we replace the rule above with the following one
p.Y; S/  q.X; Y; V /; sum..Y /; V; S/
then we get p.c; 5/ from the ﬁrst and last facts, and p.d; 4/ from the second fact.
We now formally deﬁne the syntax of rules with the sum aggregate.
Deﬁnition 6.2
A Datalogsum rule is of the form:
p.Y ; S/  body.W ; V /; sum..X/; V; S/
where
• Y and W are lists of terms, X is a list of variables, and var.Y /  X  var.W /;
• V is a cost variable such that V 62 X and S is a distinct variable such that S 62 var.W /; and
• body.W ; V / is a conjunction of standard and comparison atoms whose terms are W and V .
A Datalogsum program is a ﬁnite set of Datalog and Datalogsum rules, where for every
Datalogsum rule, the predicate symbol in the head is not mutually recursive with any of the pred-
icate symbols in the body.
Following Greco [1999a], the semantics of a Datalogsum program is given in terms of a
choice-most program (cf. Section 4.6) derived from the original one by replacing every Datalogsum
rule with two groups of rules.
More speciﬁcally, consider a Datalogsum program P and a Datalogsum rule r 2 P of the
following form (i.e., as per Deﬁnition 6.2):
p.Y ; S/  body.W ; V /; sum..X/; V; S/:

92
6. AGGREGATES
e ﬁrst group of rules is used to partition the set of body tuples with respect to the values
of the variables in X and deﬁne a linear order for each partition. Formally, we deﬁne ord.r/ as
the set consisting of the following rules:
orderedr.0; X; root/
 
body.W ; V /:
orderedr.J; X; V /
 
orderedr.J 0; X; Y /; body.W ; V /; J D J 0 C 1
choice..J; X/; .W //; choice..W /; .J; X//:
e second group of rules is used to compute the sum of each partition by iterating over
the corresponding linear order. Formally, we deﬁne sum.r/ as the set consisting of the following
rules:
p.Y ; S/
 
sum_bodyr.J; X; S/; choice-most..X/; J /:
sum_bodyr.0; X; 0/
 
orderedr.0; X; root/:
sum_bodyr.J; X; S/
 
sum_bodyr.J 0; X; S0/; orderedr.J; X; V /; S DS0 C V; J DJ 0 C 1:
e semantics of a Datalogsum program P is given in terms of the greedy choice models
of the choice-most program P 0 derived from P by replacing every Datalogsum rule r in P with
ord.r/ [ sum.r/.¹ Notice that P 0 can have multiple greedy choice models, which diﬀer only in the
atoms deﬁning the linear orders (i.e., the orderedr-atoms) and, consequently, they also diﬀer in
the sum_bodyr-atoms. is is not surprising since the ﬁnal result of the sum of a set of elements
is independent of the order in which the elements are summed up, although the partial results
can be diﬀerent.
us, the semantics of P is given by taking all the p-atoms of any greedy choice model of
P 0 where p is a predicate symbol appearing in P . As discussed above, we can choose any greedy
choice model of P 0 without aﬀecting the result, and thus the semantics of P is deterministic.
Count aggregate.
e count aggregate is expressed by means of atoms of the form
count..X/; C/, where X is a list of variables and C is a variable. e intuitive meaning is that,
given a multiset T of tuples of the form .x/, where x is a list of constants from the Herbrand
universe called the X-value of the tuple, for each maximal subset T 0 of T of tuples having the
same X-value, we count the number of elements of T 0. e aggregate atom yields as many values
for C as the number of distinct values of X in T . An example is provided below.
Example 6.3
Consider a directed graph stored by means of facts of the form edge.a; b/, mean-
ing that there is an edge in the graph from node a to node b. e following rule computes the
outdegree of every node having outgoing edges (i.e., having outdegree greater than 0):
outdegree.X; C/  edge.X; Y /; count..X/; C/:
¹Indeed, P 0 is a choice-most program where arithmetic operators are allowed.

6.2. SUM AND COUNT
93
Consider now the directed graph corresponding to the following database:
edge.a; b/:
edge.a; c/:
edge.b; c/:
edge.c; a/:
edge.c; d/:
edge.c; b/:
e evaluation of the rule above yields outdegree.a; 2/ by counting the number of facts having a
as the ﬁrst argument, and likewise it also yields outdegree.b; 1/ and outdegree.c; 3/.
e following rule allows us to compute the indegree of every node having ingoing edges:
indegree.Y; C/  edge.X; Y /; count..Y /; C/:
By evaluating this rule over the database above we get indegree.a; 1/, indegree.b; 2/,
indegree.c; 2/, and indegree.d; 1/.
We now formally deﬁne the syntax of programs with the count aggregate.
Deﬁnition 6.4
A Datalogcount rule is of the form:
p.Y ; C/  body.W /; count..X/; C/;
where
• Y and W are lists of terms, X is a list of variables, and var.Y /  X  var.W /;
• C is a variable such that C 62 var.W /; and
• body.W / is a conjunction of standard and comparison atoms whose terms are W .
A Datalogcount program is a ﬁnite set of Datalog and Datalogcount rules where for every Datalogcount
rule, the predicate symbol in the head is not mutually recursive with any of the predicate symbols
in the body.
e semantics of a Datalogcount program P is given in terms of the semantics of a Datalogsum
program derived from P by replacing each Datalogcount rule r in P of the form
p.Y ; C/  body.W /; count..X/; C/
with the following rules:
p.Y ; C/
 
bodyr.W ; V /; sum..X/; V; C/:
bodyr.W ; 1/
 
body.W /:
us, count can be reduced to the case of sum. Speciﬁcally, every tuple involved in the counting
is given an extra argument whose values is 1 (see the second rule above), then such values are
summed (see the ﬁrst rule above), thereby obtaining the eﬀect of counting.

94
6. AGGREGATES
6.3
SUMMATION
e summation aggregate is a useful construct for expressing optimization problems (e.g., see
Examples 6.8 and 6.10 in the following). It is expressed by means of atoms of the form
summation..X/; V; S/, where X is a list of variables, and V and S are variables. e intuitive
meaning is that, given a multiset T of tuples of the form .x; v/, where x is a list of constants from
the Herbrand universe called the X-value of the tuple and v is a value from N called the V -value
of the tuple, for each maximal subset T 0 of T such that there are no two tuples in T 0 with the
same X-value, all the V -values must be added, yielding S.
In other words, if T ŒX denotes the set of X-values in T and, for each x in T ŒX, .x/
non-deterministically selects exactly one value v for which .x; v/ is in T , then a value for S is
obtained as P
x2T ŒX .x/. An example is provided below.
Example 6.5
Consider the following rule:
p.S/  q.X; W; V /; summation..X/; V; S/
and the database consisting of the following facts:
q.a; c; 1/:
q.a; c; 2/:
q.b; c; 2/:
q.b; d; 3/:
e evaluation of the rule above yields the atoms p.3/ (using the ﬁrst and third facts in the
database), p.4/ (using the ﬁrst and the fourth facts or using the second and the third ones), and
p.5/ (using the second and the fourth facts). If we replace the rule above with the following one:
p.S/  q.X; W; V /; summation..W /; V; S/I
that is, variable W is used in place of variable X in the summation atom, then we get the atoms
p.4/ (using the ﬁrst and fourth facts in the database) and p.5/ (using the second and the fourth
facts or using the third and the fourth ones).
e syntax of programs with the summation aggregate is deﬁned as follows.
Deﬁnition 6.6
A Datalog
P
rule is of the form:
p.S1; : : : ; Sn/
 
body.W ; X; V1; : : : ; Vn/;
summation..X/; V1; S1/; : : : ; summation..X/; Vn; Sn/;
where
• W is a list of terms and X is a list of variables;

6.3. SUMMATION
95
• V1; : : : ; Vn; S1; : : : ; Sn are distinct variables none of which belongs to W or X; and
• body.W ; X; V1; : : : ; Vn/ is a conjunction of standard and comparison atoms whose terms
are W ; X; V1; : : : ; Vn.
A Datalog
P
program is a ﬁnite set of Datalog and Datalog
P
rules where for every Datalog
P
rule,
the predicate symbol in the head is not mutually recursive with any of the predicate symbols in
the body.
Observe that the body of a Datalog
P
rule may contain several summation atoms, but must
satisfy the following constraints:
• all summation atoms must have the same ﬁrst argument X;
• variables X; V1; : : : ; Vn must appear in the conjunction body.W ; X; V1; : : : ; Vn/;
• only variables Si may occur in the head and they cannot appear in body.W ; X; V1; : : : ; Vn/;
and
• variables V1; : : : ; Vn; S1; : : : ; Sn take values from the domain N.
e semantics of a Datalog
P
program is given in terms of a choice-most program derived
from P as follows. We ﬁrst deﬁne a linear order on the values of the variables X by using the
non-determinism of the choice construct. More speciﬁcally, consider a Datalog
P
program P and
a Datalog
P
rule r in P of the form (see Deﬁnition 6.6)
p.S1; : : : ; Sn/
 
body.W ; X; V1; : : : ; Vn/;
summation..X/; V1; S1/; : : : ; summation..X/; Vn; Sn/:
We deﬁne ord.r/ as the set consisting of the following rules:
orderedr.0; root/:
orderedr.J; X/
 
orderedr.J 0; X0/; body.W ; X; V1; : : : ; Vn/;
choice..J /; .X//; choice..X/; .J //; J D J 0 C 1:
e linear order on the values of the variables X is built by deﬁning a bijection between the
set of possible values of X and the cardinal numbers: this is enforced by the atoms choice..J /; .X//
and choice..X/; .J // in the body of the rule above.
We now deﬁne sum.r/ as the set consisting of the following rules:
p.S1; : : : ; Sn/
 
pr.J; S1; : : : ; Sn/; choice-most../; J /:
pr.0; 0; : : : ; 0/:
pr.J; S1; : : : ; Sn/
 
pr.J 0; S0
1; : : : ; S0
n/; J D J 0 C 1;
orderedr.J; X/; body.W ; X; V1; : : : ; Vn/;
S1 D S0
1 C V1; : : : ; Sn D S0
n C Vn;

96
6. AGGREGATES
where pr is a fresh predicate symbol.
e semantics of a Datalog
P
program P is given in terms of the choice-most program
P 0 derived from P by replacing every Datalog
P
rule r in P with ord.r/ [ sum.r/. Similar to
Datalogsum programs, P 0 can have multiple greedy choice models, which have the same p-atoms
for every predicate symbol p appearing in P . e semantics of P is given by the set of such atoms,
which is the same across all greedy choice models of P 0.
Example 6.7
Consider the following Datalog
P
rule r:
p.Y; V /  range.I; Xi/; item.I; Yi; Vi/; summation..I/; Yi; Y /; summation..I/; Vi; V /:
en, ord.r/ [ sum.r/ consists of the following rules:
orderedr.0; root/:
orderedr.J; I/
 
orderedr.J 0; I 0/; range.I; Xi/; item.I; Yi; Vi/; ;
choice..J /; .I//; choice..I/; .J //; J D J 0 C 1:
p.Y; V /
 
p0.J; Y; V /; choice-most../; J /:
p0.0; 0; 0/:
p0.J; Y; V /
 
p0.J 0; Y 0; V 0/; J D J 0 C 1;
orderedr.J; I/; range.I; Xi/; item.I; Yi; Vi/
Y D Y 0 C Yi; V D V 0 C Vi:
6.4
COMBINING SUMMATION AND GREEDY CHOICE
In this section, we consider programs where the summation aggregate is used along with the
choice-least/choice-most constructs, and show that they are well suited to express optimization
problems—the former can be used to compute summations and the latter can be used to se-
lect optimal values. In particular, we will focus on the combination of summation and choice-most;
the case involving choice-least is analogous. An example is given below.
Example 6.8
Given 1000 dollars to invest in diﬀerent enterprises, we want to determine how
we should allocate this amount of money in order to have maximum proﬁt. Speciﬁcally, assume
we have facts of the form invest.ei; xi; pi/ meaning that pi is the proﬁt from the investment of
xi dollars on enterprise ei, and we want to determine the exact distribution of the resources in
each of the enterprises so that the global proﬁt is maximized.
By combining summation and choice-most, the problem can be expressed as follows:
global_proﬁt.S/
 
proﬁt.D; S/; choice-most../; S/:
proﬁt.D; S/
 
invest.E; X; P /;
summation..E/; X; D/; D  1000;
summation..E/; P; S/; choice-most..D/; S/:

6.4. COMBINING SUMMATION AND GREEDY CHOICE
97
e second rule above computes the maximum proﬁt S we can get by investing D dollars, for
diﬀerent values of D (less than or equal to 1000). en, the ﬁrst rule selects the maximum value
of S across all values derived from the second rule.
We now deﬁne the syntax of programs including summation and choice-most.
Deﬁnition 6.9
A Datalog
P
;most rule is of the form:
p.S1; : : : ; Sn/
 
body.W ; X; V1; : : : ; Vn/;
summation.X; V1; S1/; : : : ; summation.X; Vn; Sn/;
choice-most..S1; : : : ; Sn 1/; Sn/;
where
• W is a list of terms and X is a list of variables;
• V1; : : : ; Vn; S1; : : : ; Sn are distinct variables none of which belongs to W or X; and
• body.W ; X; V1; : : : ; Vn/ is a conjunction of standard and comparison atoms whose terms
are W ; X; V1; : : : ; Vn.
A Datalog
P
;most program is a ﬁnite set of Datalog, choice-most, and Datalog
P
;most rules
where, for every choice-most or Datalog
P
;most rule, the predicate symbol in the head is not mutu-
ally recursive with any of the predicate symbols in the body.
e semantics of a Datalog
P
;most program P is given in terms of a choice-most program P 0
obtained from P by replacing every Datalog
P
;most rule r in P by ord.r/ as deﬁned in Section 6.3,
plus the following set of rules:
p.S1; : : : ; Sn/
 
pr.J; S1; : : : ; Sn/; choice-most../; J /:
pr.0; 0; : : : ; 0/:
pr.J; S1; : : : ; Sn/
 
pr.J 0; S0
1; : : : ; S0
n/; J D J 0 C 1;
orderedr.J; X/; body.W ; X; V1; : : : ; Vn/;
S1 D S0
1 C V1; : : : ; Sn D S0
n C Vn;
choice-most..J; S1; : : : ; Sn 1/; Sn/;
where pr is a fresh predicate symbol.
Recall that predicate orderedr is deﬁned by rules in ord.r/ (see the previous section). Similar
to the semantics discussed in the previous sections, the semantics of P is given in terms of the
p-atoms of any greedy choice model of P 0, where p is a predicate symbol appearing in P —once
again, even if P 0 can have multiple greedy choice models, they all agree on the p-atoms (with p
being a predicate symbol that appears in P ) and thus the semantics is deterministic.
Details on the evaluation of Datalog
P
;most programs (as well as Datalog
P
;least programs) can
be found in Greco [1999a]. A general technique for the propagation of extrema predicates into
Datalog programs has been deﬁned in Greco et al. [1998] (see also Ganguly et al. [1991]).

98
6. AGGREGATES
Below we report another example where the summation aggregate is used along with the
choice-most construct to express an optimization problem.
Example6.10
Suppose we are given a set of facts of the form item.i; bi; vi/ meaning that there is
an item i with weight bi and value vi. e following Datalog
P
;most program returns the maximum
value of the expression P
i vi  x2
i under the constraint P
i bi  xi  15—here the xi’s variables
can take non-negative integer values.
max_p.V /
 
p.B; V /; choice-most../; V /:
p.B; V /
 
range.Xi/; item.I; Bi; Vi/;
B0
i D Xi  Bi; summation..I/; B0
i; B/; B  15;
V 0
i D Xi  Xi  Vi; summation..I/; V 0
i ; V /; choice-most..B/; V /:
us, the above program formulates a quadratic integer programming problem. Notice that
we also have a fact range.v/ for every integer value v that a variable Xi can take.
Dynamic programming is a technique for solving optimization problems which decom-
poses a problem into subproblems of smaller size, solves the smaller subproblems, and uses their
solutions to later solve larger subproblems up to the original problem. e technique is based
on a bottom-up approach which is also the approach used by the evaluation strategy of Datalog.
For instance, the resource allocation problem above can be solved with a dynamic programming
approach. Greco [1999a] reports other examples showing that the summation aggregate in com-
bination with greedy choice allows us to express many optimization problems in a declarative
way.
BIBLIOGRAPHIC NOTES
e classes of programs discussed in this chapter can be easily extended to accommodate stratiﬁed
negation, see Greco [1999a].
Notice also that we considered classes of programs with only one aggregate. For instance,
Datalogsum programs cannot contain Datalogcount rules. However, the generalization to classes of
programs containing both Datalogsum and Datalogcount rules is easy since the semantics of such
programs can be deﬁned by rewriting each Datalogsum rule and each Datalogcount rule as dis-
cussed in Section 6.2. e same argument applies to other combinations of rules with aggregates
belonging to the same program.
e extension of Datalog with aggregates has been widely investigated, with particular focus
on the deﬁnition of a suitable semantics and the design of techniques for the eﬃcient evaluation
of such programs.
A semantics for Datalog programs with non-recursive and monotonic recursive aggregates
was ﬁrst proposed in Mumick et al. [1990].
e extension of the well-founded semantics to logic programs with aggregates was con-
sidered in Kemp and Stuckey [1991]. A diﬀerent deﬁnition (based on the alternating ﬁxpoint)

6.4. COMBINING SUMMATION AND GREEDY CHOICE
99
of the well-founded semantics in the presence of aggregates was proposed in Van Gelder [1992],
which was later generalized by Osorio and Jayaraman [1999]. e main shortcoming of such se-
mantics is that they often leave too many undeﬁned atoms, as shown by Ross and Sagiv [1997].
e latter is an alternative approach based on the deﬁnition of monotonicity conditions using lat-
tices and which is more general than the one deﬁned by set-containment. is semantics does not
capture some important cases such as cost-monotonic programs. Yet another semantics based on
the deﬁnition of a stronger partial order relation was proposed in Gelder [1993]. An extension of
the well-founded semantics to programs with aggregates was proposed also in Pelov et al. [2007]
and Alviano et al. [2011].
Eﬃcient bottom-up techniques for evaluating diﬀerent classes of Datalog programs with
aggregates were proposed in Ganguly et al. [1991], Sudarshan and Ramakrishnan [1991], whereas
a top-down method which uses extension tables was presented in Dietrich [1992]. e technique
presented in Sudarshan and Ramakrishnan [1991] was also implemented in the CORAL sys-
tem [Ramakrishnan et al., 1992].
e eﬃcient evaluation of Datalog programs extended with both negation and aggregation
was studied in Kemp and Ramamohanarao [1998].
Incremental techniques for eﬃciently evaluating programs with monotonic aggregates were
proposed in Ramakrishnan et al. [1994].
Expressive power and complexity of diﬀerent extensions of Datalog with aggregates were
investigated in Consens and Mendelzon [1990], Mumick and Shmueli [1995].
Semantics and complexity of Datalog extended with unstratiﬁed negation, disjunction, and
aggregates were investigated in Faber et al. [2011]. A discussion of various other approaches can
be found in Pelov et al. [2007].


101
C H A P T E R
7
Query Optimization
In this chapter, we discuss techniques that take advantage of the information in Datalog queries
to make their evaluation more eﬃcient.
e ﬁrst technique is called magic-sets rewriting and consists of rewriting a Datalog query
into an equivalent one which combines the advantages of the bottom-up and top-down evaluation
strategies. e Datalog query obtained from the rewriting is evaluated in a bottom-up fashion,
but it indeed emulates a top-down evaluation strategy of the original query.
e second technique we present applies to a special class of Datalog queries, called chain
queries, and is based on the rewriting of the original Datalog query into a new one (containing
function symbols) that emulates a pushdown automaton. Several other techniques deﬁned in the
literature (e.g., the counting method) are characterized as special cases of this technique.
7.1
MAGIC-SETS REWRITING
Magic-sets rewriting [Bancilhon et al., 1986, Beeri and Ramakrishnan, 1991] is a well-known
technique for the eﬃcient evaluation of Datalog queries. e approach consists of rewriting a
Datalog query into an equivalent one whose bottom-up evaluation simulates the pushing of bind-
ing information that occurs in top-down evaluation approaches. We illustrate this aspect in the
following example.
Example 7.1
Consider a database storing facts of the form person.a/ and parent.a; b/ meaning
that a is a person and b is a parent of a, respectively. Consider the Datalog query hP; same-
generation.john; Y /i¹ asking for those people of the same generation as john, where P is the
following Datalog program:
samegeneration.X; X/  person.X/:
samegeneration.X; Y /  parent.X; X1/; samegeneration.X1; Y1/; parent.Y; Y1/:
is query could be answered rather eﬃciently using a top-down evaluation strategy. As
discussed in Chapter 3, a top-down evaluation tries to avoid the inference of atoms that are irrel-
evant for proving the atoms of interest—in our example, we are interested only in the people of
the same generation as john.
¹Recall that a Datalog query is a pair hP; Gi where P is a Datalog program and G is an atom, called query goal—see Section 3.4
for further details.

102
7. QUERY OPTIMIZATION
In contrast, bottom-up algorithms (such as those seen in Chapter 3) would compute the
entire samegeneration relation to eventually keep only those tuples belonging to the query answer.
If there are many tuples not involving john in the samegeneration relation, then the bottom-up
computation would spend time to compute them even though they are useless for the purpose of
answering the query.
e previous example highlights some advantages of the top-down evaluation. However,
a bottom-up computation has also diﬀerent advantages over top-down strategies. In fact, a top-
down evaluation strategy might get stuck in inﬁnite loops, and even if it is possible to avoid
them, detecting termination is not easy. Moreover, bottom-up evaluation strategies can make use
of eﬃcient techniques for computing joins of big relations.
Magic-sets rewriting is a technique that combines the advantages of both the top-down
and the bottom-up evaluation strategies. It consists of three steps.
1. An adornment step which derives a new program, called adorned program, from the original
one. In the adorned program the relationships between bound arguments in the head of a
rule and the bindings in the rule body are made explicit by “adorning” predicate symbols—
roughly speaking, by attaching strings (specifying if a term is expected to be free or bound)
to predicate symbols.
2. A modiﬁcation step which modiﬁes the adorned rules obtained at the ﬁrst step by introducing
new atoms, called magic atoms, into the rule bodies.
3. A generation step which adds new rules, called magic rules, to the adorned program obtained
at the second step. e magic rules deﬁne the atoms introduced in the second step and
simulate the top-down evaluation scheme.
e ﬁrst step in the magic-sets rewriting is to produce an adorned query. Query adornment
is a formal way of depicting information ﬂow between atoms in rules. is is done by annotating
predicate symbols with strings. More precisely, an adornment ˛ for a predicate symbol p of arity
n is a string ˛1 : : : ˛n of length n built from the letters b (which stands for bound) and f (which
stands for free). So, p˛ is an adorned predicate symbol and p˛.t1; : : : ; tn/ is an adorned atom, where
the ti’s are terms. For instance, parentfb is an adorned predicate symbol and parentfb.X; john/ is
an adorned atom.
Intuitively, an adorned atom p˛.t1; : : : ; tn/ is used to express if each ti is expected to be
bound or free during the evaluation of a program. Depending on the information ﬂow, if ti is
expected to be bound (resp. free), then ˛i is set to b (resp. f ).
First of all, we deﬁne how the query goal is adorned.
Deﬁnition 7.2
Given a query goal G of the form g.t1; : : : ; tm/, the adorned version of G is
the adorned atom g˛.t1; : : : ; tm/ where adornment ˛ D ˛1 : : : ˛m is deﬁned as follows: if ti is a
constant, then ˛i D b; otherwise (ti is a variable) ˛i D f . e adorned version of G is denoted
by adorn.G/.

7.1. MAGIC-SETS REWRITING
103
Now the program of the given query has to be adorned. Adornments are generated with
reference to a speciﬁc sideways information-passing strategy (SIPS). A sideways information pass-
ing strategy is an inherent component of any query evaluation strategy. Intuitively, for a rule of
a program, a SIPS represents a decision about the order in which the atoms of the rule will be
evaluated, and how values for variables are passed from atoms to other atoms during evaluation.
Speciﬁcally, a SIPS describes how bindings passed to a rule’s head by uniﬁcation are used to eval-
uate the atoms in the rule’s body. us, a SIPS describes how we evaluate a rule when a given set
of head terms are bound to constants. Below is an example.
Example 7.3
Consider again the Datalog query hP; samegeneration.john; Y /i of Example 7.1.
e ﬁrst argument of the query goal is bound to john and thus, in the ﬁrst rule of P , variable X
is bound to john as well and can be used in the body to check if john is a person.
In the second rule, a possible SIPS is the following one. Variable X is bound to john and
is used to retrieve john’s parents. e value of X1, bound to a parent of john, is available for
the evaluation of samegeneration.X1; Y1/. us, in the second rule, variable X is passed sideways
from samegeneration.X; Y / in the head to parent.X; X1/ in the body whereas variable X1 is passed
sideways from parent.X; X1/ to samegeneration.X1; Y1/.
If the query goal is samegeneration.X; john/, the following diﬀerent strategy can be used.
In the second rule, the value of Y is bound to john and is passed sideways to the body atom
parent.Y; Y1/, so that the value of Y1 is used to retrieve john’s parents; the (bound) variable Y1
is then available for the evaluation of samegeneration.X1; Y1/. erefore, the evaluation strategy
depends on SIPSs, that is, how bindings are passed though atoms.
SIPSs are associated with a rule according to the query goal form—in particular, according
to the adorned version of the query goal. Diﬀerent query goals usually have diﬀerent SIPSs for
the same program (e.g., the two diﬀerent query goals in the example above, whose adorned ver-
sions are samegenerationbf .X; Y / and samegenerationfb.X; Y /). However, diﬀerent SIPSs can be
associated with the same query form too (e.g., see Example 7.5 in the following). e choice of
one SIPS over another is guided by factors such as the current and expected size of the diﬀerent
relations and the employed indexing mechanism.
In a given rule, two atoms A and A0 are connected if they share a common variable or there
exists an atom A00 connected to both A and A0. e notion of SIPS is formally deﬁned as follows.
Deﬁnition7.4
Let r be a Datalog rule, p.t1; : : : ; tn/ the atom in the head of r, and ˛ D ˛1 : : : ˛n
an adornment for p. A sideways information-passing strategy (SIPS) for r with respect to p˛ is a
labeled graph satisfying the following conditions:
• each edge is of the form N !X s, where N  .body.r/ [ fp˛.t1; : : : ; tn/g/, s 2 body.r/,
and X is a non-empty set of variables. Moreover,
– each variable in X appears in s; and

104
7. QUERY OPTIMIZATION
– each variable in X appears either in a term ti s.t. ˛i D b, provided that p˛.t1; : : : ; tn/
is in N, or in an atom in N   fp˛.t1; : : : ; tn/g (or both); and
– each atom in N is connected to s.
• ere exists a total order of body.r/ [ fp˛.t1; : : : ; tn/g s.t.
– p˛.t1; : : : ; tn/ precedes all atoms in body.r/;
– every atom which does not appear in the graph follows every atom appearing in the
graph; and
– for each edge N !X s in the SIPS, every element in N precedes s.
Intuitively, an edge N !X s means that by evaluating the join of the atoms in N (with some
terms possibly bound to constants), values for the variables in X are obtained, and these values are
passed to atom s, and are used to restrict its computation. Clearly, we can have diﬀerent SIPSs
for a given rule, as shown in the following example.
Example 7.5
Consider the Datalog query hP; q.1; Y /i, where P is the following program:
q.X; Y /  a.X; Y; Z/:
q.X; Y /  a.X; W; Z/; q.Z; T /; b.T; W /; q.T; Y /:
q.X; Y /  b.X; Z/; p.Z; Y /; c.Y /:
Here q and p are derived predicate symbols, while a, b, and c are base predicate symbols. e
adorned version of the query goal is qbf.1; Y /.
A possible SIPS for the ﬁrst rule w.r.t. qbf is the one consisting of the following edge:
f qbf .X; Y /g !fXg a.X; Y; Z/:
A SIPS for the second rule w.r.t. qbf is the one consisting of the following edges:
f qbf.X; Y /g !fXg a.X; W; Z/
f qbf.X; Y /; a.X; W; Z/g !fZg q.Z; T /
f qbf.X; Y /; a.X; W; Z/; q.Z; T /g !fT;W g b.T; W /
f qbf.X; Y /; a.X; W; Z/; q.Z; T /; b.T; W /g !fT g q.T; Y /:
Notice that this is a SIPS for the second rule w.r.t. qbf as:
• all edges satisfy the conditions stated in the ﬁrst bullet of Deﬁnition 7.4. For instance,
consider the last edge above (an analogous reasoning can be applied to all other edges). e
left-hand side of !fT g contains qbf.X; Y / and atoms in the body of the second rule, while
the right-hand side is an atom in the body of the second rule. Moreover,
– T appears in q.T; Y /;

7.1. MAGIC-SETS REWRITING
105
– T appears in fa.X; W; Z/; q.Z; T /; b.T; W /g; and
– each atom in f qbf.X; Y /; a.X; W; Z/; q.Z; T /; b.T; W /g is connected to q.T; Y /.
Notice that b.T; W / is connected to q.T; Y / because they share the same variable T .
For the same reason, q.Z; T / is connected to q.T; Y /. en, a.X; W; Z/ is connected
to q.T; Y / because it shares variable Z with q.Z; T /, which is connected to q.T; Y /.
Finally, qbf.X; Y / is connected to q.T; Y / as they share variable Y .
• e total order qbf.X; Y /; a.X; W; Z/; q.Z; T /; b.T; W /; q.T; Y / satisﬁes the conditions
in second bullet of Deﬁnition 7.4.
Another possible SIPS for the second rule w.r.t. qbf might be the following:
f qbf .X; Y /g !fXg a.X; W; Z/
f a.X; W; Z/g !fZg q.Z; T /
f q.Z; T /g !fT g b.T; W /
f b.T; W /g !fT g q.T; Y /:
ere is a subtle diﬀerence between the two SIPSs for the second rule reported above. In the ﬁrst
one, the last three edges specify that each atom in the body of the rule receives some information
based on the evaluation of the conjunction of the body atoms to its left. However, in the second
SIPS, although q.Z; T / passes ground values for T to b.T; W / (see the third edge), the ground
values for W that are generated need not be the same set of ground values for W computed by
evaluating a.X; W; Z/ from the previous edge. It is only when all the tuples for the body atoms
are joined at the end that the compatible values of W from b and a are reconciled (uniﬁed).
A possible SIPS for the third rule w.r.t. qbf is the one consisting of the following edges:
f qbf.X; Y /g !fXg b.X; Z/
f qbf.X; Y /; b.X; Z/g !fZg p.Z; Y /
f qbf.X; Y /; b.X; Z/; p.Z; Y /g !fY g c.Y /:
For ease of presentation, we omit explicit SIPSs and assume a default SIPS for every rule,
according to which if the tail of an edge contains a body atom A, then it also includes all atoms to
the left of A in the rule (including the head). We also assume that all SIPSs have been normalized
as follows. Given n SIPS edges of the form
N1 !X1 s
N2 !X2 s
:::
Nn !Xn s:
e normalized edge for s is
N1 [ N2 [    [ Nn ![n
iD1Xi s:

106
7. QUERY OPTIMIZATION
Algorithm 4 Adornment
Input: A Datalog query hP; g.t1; : : : ; tm/i and a set S of SIPSs
Output: An (adorned) Datalog query hP ; g˛.t1; : : : ; tm/i and a set S0 of SIPSs
1: g˛.t1; : : : ; tm/ D adorn.g.t1; : : : ; tm//;
2: N D fg˛gI
3: P  D ;; D D ;; S0 D ;;
4: while N ¤ ; do
5:
move an adorned predicate symbol qˇ from N to D;
6:
for each rule r 2 def.q; P / do
7:
let r0 be a copy of r;
8:
let S.r/ be a copy of the SIPS associated with r w.r.t. qˇ;
9:
replace q with qˇ in the head of r0;
10:
for each derived atom p.v1; : : : ; vk/ in the body of r0 do
11:
 D adornment.p.v1; : : : ; vk/; S.r//;
12:
replace p.v1; : : : ; vk/ in both r0 and S.r/ by p.v1; : : : ; vk/;
13:
if p 62 D then
14:
N D N [ fpg;
15:
P  D P  [ fr0g;
16:
S0 D S0 [ fS.r/g;
17: return hP ; g˛.t1; : : : ; tm/i and S0;
e adornment of a Datalog query is performed by Algorithm 4. It takes as input a Datalog
query hP; g.t1; : : : ; tm/i and a set S of SIPSs for the rules of P , and gives as output an adorned
Datalog query hP ; g˛.t1; : : : ; tm/i and a set S0 of SIPSs for the rules of P .
Algorithm 4 maintains a set P  of adorned rules obtained by adorning rules of P , a set
N of adorned predicate symbols not yet deﬁned in P , a set D of adorned predicate symbols
deﬁned in P , and a set S0 of SIPSs for the rules in P . Initially, D is empty and N contains
the adorned predicate symbol corresponding to the query goal. en, the algorithm iteratively
moves a predicate symbol qˇ from N to D and adds to P  the rules deﬁning q in P adorned
with respect to ˇ. Moreover, SIPSs from S are added to S0 by replacing predicate symbols with
adorned predicate symbols.
Function adornment.p.v1; : : : ; vk/; S.r// on line 11 takes a (derived) atom p.v1; : : : ; vk/
from the body of a rule r and the SIPS S.r/ associated with r, and returns an adornment  D
1 : : : k according to the following rule: Let N !X p.v1; : : : ; vk/ be an edge in S.r/ (if such an
edge does not exist, then X is assumed to be empty). If vi 2 X or vi is a constant, then set i to
b, otherwise set i to f , for 1  i  k.

7.1. MAGIC-SETS REWRITING
107
Given a Datalog query Q D hP; Gi and a set S of SIPSs, the adorned version of Q w.r.t.
S, denoted Adorn.Q; S/, is the adorned Datalog query returned by Algorithm Adornment when
called with Q and S as input.
Example 7.6
e adorned version of the Datalog query and the SIPSs of Example 7.5 (for the
second rule, the ﬁrst SIPS reported in Example 7.5 is considered) is hP 0; qbf .1; Y /i, where P 0
consists of the following rules:
qbf.X; Y /  a.X; Y; Z/:
qbf.X; Y /  a.X; W; Z/; qbf .Z; T /; b.T; W /; qbf.T; Y /:
qbf.X; Y /  b.X; Z/; pbf.Z; Y /; c.Y /:
Notice that base atoms are not adorned as the for each loop in lines 10–14 considers only derived
atoms. If we consider a diﬀerent order for the body atoms of the third rule (and thus a diﬀerent
SIPS), where base atoms precede the derived atom, the adorned version of the rule is
qbf .X; Y /  b.X; Z/; c.Y /; pbb.Z; Y /:
An important property of the adornment step discussed above is that the adorned version
of a Datalog query is equivalent to the original one [Balbin et al., 1991, Beeri and Ramakrish-
nan, 1991]. Recall that two Datalog queries are equivalent iﬀthey give the same result for every
database (cf. Section 3.4).
us far, we have seen how the ﬁrst step of the magic-sets rewriting is performed, that is,
how to derive an adorned Datalog query Q0 from the original one. After Q0 has been generated,
the magic-sets rewriting proceeds by introducing new adorned atoms (called magic atoms) into
the bodies of the adorned rules of Q0 and introducing new rules (called magic rules) deﬁning the
new adorned atoms.
e new adorned atoms are related to the adorned atoms appearing in Q0 as follows: if A is
an adorned atom of the form q˛1:::˛n.t1; : : : ; tn/ appearing in Q0, then the new adorned atom is
obtained from A by replacing predicate symbol q˛1:::˛n with the predicate symbol magic_q˛1:::˛n
and deleting the variables ti s.t. ˛i D f , for 1  i  n (thus, the arity of magic_q˛1:::˛n is less
than or equal to n). For instance, given the adorned atom pbfb.X; Y; Z/, the magic atom is
magic_pbfb.X; Z/, that is, the second term has been eliminated since the second symbol in the
adornment is f . Given an adorned atom A, magic.A/ denotes the magic atom derived from A.
Algorithm 5 performs the magic-sets rewriting. It takes as input the adorned Datalog query
and the set of SIPSs returned by Algorithm 4; it gives as output a new Datalog query. For Al-
gorithm 5, initially, P 0 is empty. en, for each adorned rule in P , a modiﬁed rule and a set of
magic rules (one for each edge in the associated SIPS) are added to P 0. In the algorithm, for a
SIPS edge N !X s, we use conj.N/ to denote the conjunction of the atoms in N.
Consider a Datalog query Q and a set S of SIPSs, and let Q0 and S0 be the adorned Datalog
query and the set of SIPSs returned by Adornment.Q; S/. We denote by magicRew.Q; S/ the

108
7. QUERY OPTIMIZATION
Algorithm 5 Magic-sets
Input: An adorned query hP ; g˛.t1; : : : ; tm/i and a set S of SIPSs
Output: An adorned query hP 0; g˛.t1; : : : ; tm/i
1: P 0 D ;;
2: for each rule r 2 P  do
3:
add the rule head.r/  magic.head.r//; body.r/ to P 0;
4:
for each edge N !X s in the SIPS associated with r do
5:
if head.r/ 2 N then
6:
add the rule magic.s/  magic.head.r//; conj.N   fhead.r/g/ to P 0;
7:
else
8:
add the rule magic.s/  conj.N/ to P 0;
9: P 0 D P 0 [ fmagic.g˛.t1; : : : ; tm//:g;
10: return hP 0; g˛.t1; : : : ; tm/i;
adorned Datalog query returned by Algorithm Magic-Set when called with Q0 e S0 as input. us,
the overall magic-sets rewriting for a Datalog query Q is carried out by ﬁrst calling Algorithm
Adornment and then calling Algorithm Magic-sets on the output of Algorithm Adornment.
An important property of the magic-sets rewriting technique is that magicRew.Q; S/ is
equivalent to the original Datalog query Q [Balbin et al., 1991, Beeri and Ramakrishnan, 1991].
Example 7.7
Consider the Datalog query Q D hP; p.1; C/i where P consists of the following
rules:
p.X; C/
 
q.X; 2; C/:
q.X; Y; C/
 
a.X; Y; C/:
q.X; Y; C/
 
b.X; Y; Z; W /; q.Z; W; D/; c.D; C/:
In this program, q and p are derived predicate symbols, while a, b, and c are base predicate
symbols. Assume a default SIPS for every rule where if the tail of an edge contains a body atom
A, then it also includes all atoms to the left of A in the rule (including the head). Let S be the
set of such SIPSs. e adorned version of Q is hP ; pbf .1; C/i where P  is as follows:
pbf.X; C/
 
qbbf .X; 2; C/:
qbbf.X; Y; C/
 
a.X; Y; C/:
qbbf.X; Y; C/
 
b.X; Y; Z; W /; qbbf.Z; W; D/; c.D; C/:
In the third rule, predicate symbol b passes the bindings from the (bound) head variables X and Y
to the variables Z and W appearing in the derived atom q.Z; W; D/. en, Algorithm Magic-sets

7.2. CHAIN QUERIES
109
returns the query hP 0; pbf.1; C/i, where P 0 is as follows:
magic_pbf.1/:
magic_qbbf .X; 2/
 
magic_pbf.X/:
magic_qbbf.Z; W /
 
magic_qbbf.X; Y /; b.X; Y; Z; W /:
pbf .X; C/
 
magic_pbf.X/; qbbf.X; 2; C/:
qbbf .X; Y; C/
 
magic_qbbf.X; Y /; a.X; Y; C/:
qbbf .X; Y; C/
 
magic_qbbf.X; Y /; b.X; Y; Z; W /; qbbf .Z; W; D/; c.D; C/:
In the example above, notice that the conjunction magic_qbbf .X; Y /; b.X; Y; Z; W / appears
in two rules of the ﬁnal program P 0 and, thus, it might be computed twice during the bottom-up
evaluation. e supplementary magic-sets technique is an improvement of the magic-sets method
that computes repeated conjunctions only once. As an example, the program of Example 7.7
is rewritten by introducing a new predicate symbol (called supplementary predicate symbol) as
follows:
magic_pbf.1/:
magic_qbbf .X; 2/
 
magic_pbf.X/:
magic_qbbf.Z; W /
 
sup_magic.X; Y; Z; W /:
sup_magic.X; Y; Z; W /
 
magic_qbbf.X; Y /; b.X; Y; Z; W /:
pbf .X; C/
 
magic_pbf.X/; qbbf.X; 2; C/:
qbbf.X; Y; C/
 
magic_qbbf.X; Y /; a.X; Y; C/:
qbbf.X; Y; C/
 
sup_magic.X; Y; Z; W /; qbbf.Z; W; D/; c.D; C/:
e rule deﬁning sup_magic computes the conjunction magic_qbbf .X; Y /; b.X; Y; Z; W /
only once so that its results, namely sup_magic.X; Y; Z; W /, is used in place of the conjunction
itself.
7.2
CHAIN QUERIES
In this section, we present a method for the optimization of chain queries, that is, queries where
bindings are propagated from the head to the body of rules in a “chain-like” fashion [Beeri et al.,
1990, Dong, 1992b, Wood, 1990]. e method, called pushdown method [Greco et al., 1995,
1999], is based on the fact that a chain query can be associated with a context-free language, and
a pushdown automaton recognizing this language can be emulated by rewriting the query as a
particular left-linear program.
e method presented in this section generalizes and uniﬁes techniques such as the count-
ing [Bancilhon et al., 1986] and right-, left-, mixed-linear methods [Naughton et al., 1989b]. It
also succeeds in reducing many nonlinear queries to equivalent linear ones.

110
7. QUERY OPTIMIZATION
Using general optimization methods (e.g., the magic-sets rewriting discussed in the previ-
ous section) for chain queries does not allow us to take advantage of the chain structure, thereby
resulting in ineﬃcient query evaluation. erefore, as chain queries are rather frequent in practice
(e.g., in graph applications), there is a need for ad-hoc optimization methods. Several specialized
methods for chain queries have been proposed [Afrati and Cosmadakis, 1989, Beeri et al., 1990,
Dong, 1992b, Wood, 1990, Yannakakis, 1990]. ese methods do not fully exploit possible bind-
ings. One method that is particularly specialized for bound chain queries is the counting method
[Bancilhon et al., 1986]. However, this method, although proposed in the context of general
queries [Haddad and Naughton, 1991, Saccà and Zaniolo, 1987, 1988], preserves the original
simplicity and eﬃciency [Bancilhon et al., 1986, Marchetti-Spaccamela et al., 1991, Ullman,
1989] only for a subset of chain queries whose recursive rules are linear.
e approach proposed in this section exploits the relationship between chain queries and
context-free languages. We will show that classical grammar transformations can be applied to
optimize queries. Moreover, the relationship between context-free languages and pushdown au-
tomata allows us to rewrite chain queries into a format that is more suitable for the bottom-up
evaluation.
Besides giving an eﬃcient execution scheme to bound chain queries and providing an ex-
tension of the counting method, another nice property of the presented method is that it intro-
duces a uniﬁed framework for the treatment of special cases, such as the factorization of right-,
left-, mixed-linear programs (see Naughton et al. [1989b]), as well as the linearization of non-
linear programs. A number of specialized techniques for the above special cases are known in the
literature [Ioannidis, 1992, Ioannidis and Wong, 1988, Naughton et al., 1989a,b, Saraiya, 1989,
Troy et al., 1989, Wood, 1990]. Given the importance and frequency of these special situations in
practical applications, novel deductive systems call for the usage of a unique method that includes
all advantages of the various specialized techniques.
Before presenting the pushdown method, we introduce some notation and terminology.
Given a Datalog program P , we say that a rule r in P with p as head predicate symbol is
• recursive if p is mutually recursive with some predicate symbol in the body of r;
• linear if there is at most one atom in the body of r whose predicate symbol is mutually
recursive with p;
• left-recursive (resp. right-recursive) if the predicate symbol of the ﬁrst (resp. last) atom in the
body is mutually recursive with p.
If r is linear and left-recursive (resp. right-recursive), then it is also-called left-linear (resp.
right-linear).
Example 7.8
Consider the following Datalog program:
sg.X0; Y0/  a.X0; Y0/:
sg.X0; Y2/  b.X0; Y0/; sg.Y0; X1/; c.X1; Y1/; sg.Y1; X2/; d.X2; Y2/:

7.2. CHAIN QUERIES
111
e ﬁrst rule is not recursive, as the only predicate symbol in the body is a, which is not mutually
recursive with the head predicate symbol sg. us, the rule is linear. Moreover, the rule is neither
left-recursive nor right-recursive.
Consider now the second rule. Notice that predicate symbol sg is mutually recursive with
itself. us, the second rule is recursive, as sg appears in the head and in the body. e rule is not
linear, as there are two atoms in the body whose predicate symbol is sg. Also, the rule is neither
left-recursive nor right-recursive, as the ﬁrst body atom’s predicate symbol is b and the last body
atom’s predicate symbol is d, both of which are not mutually recursive with the head predicate
symbol sg.
Given a Datalog program P and a set q of derived predicate symbols occurring in P , a rule
r of P is a q-chain rule if it is of the form:
p0.X0; Y n/
 
a0.X0; Y 0/; q1.Y 0; X1/; a1.X1; Y 1/; q2.Y 1; X2/; : : : ;
an 1.Xn 1; Y n 1/; qn 1.Y n 1; Xn/; an.Xn; Y n/:
where n  0, the Xi’s and Y i’s are non-empty lists of distinct variables, the ai.Xi; Y i/’s are (pos-
sibly empty) conjunction of atoms whose predicate symbols are not in q and are not mutually
recursive with p0, and the qi’s are (not necessarily distinct) predicate symbols in q. We require
that the lists of variables are pairwise disjoint; moreover, for each i (0  i  n), if ai.Xi; Y i/ is
empty then Y i D Xi, otherwise the variables occurring in the conjunction include all those in Xi
and Y i plus possibly other variables that do not occur elsewhere in the rule. For instance, the two
rules of Example 7.8 above are fsgg-chain rules.
If n D 0, then r reduces to p0.X0; Y 0/  a0.X0; Y 0/ and is called an exit chain rule. In
all other cases (i.e., n > 0), r is called a recurrence chain rule. Observe that a chain rule is left-
recursive (resp. right-recursive) iﬀa0.X0; Y 0/ (resp. an.Xn; Y n/) is the empty conjunction and
q1 (resp. qn 1) is mutually recursive with p0. For instance, the ﬁrst rule in Example 7.8 is an exit
chain rule, while the second one is a recurrence chain rule.
A Datalog program P is a q-chain program if for each predicate symbol p in q, every rule
with p in the head is a q-chain rule and for each two atoms p.X; Y / and p.Z; W / occurring in
the body or the head of q-chain rules, X D Z and Y D W modulo renaming of the variables.
A q-bound chain Datalog query (or simply chain query when q is clear from the context or is
not relevant) Q is a Datalog query hP; p.b; Y /i, where P is a q-chain program, p is a predicate
symbol in q, b is a list of constants, and Y is a list of variables.
In the following we present a method which, given a q-bound chain Datalog query
hP; p.b; Y /i, constructs an equivalent left-linear query. e obtained query can be implemented
eﬃciently using the bottom-up ﬁxpoint computation. In order to guarantee that the binding b is
propagated through all q-chain rules, we will assume that
• q D fpg [ q0 for some q0;
• q0  leq.p/²; and
²Recall that leq.p/ denotes the set of all predicate symbols p depends on.

112
7. QUERY OPTIMIZATION
• for each q in q, every q0 2 leq.p/ s.t. q  q0 is in q as well.
Moreover, in order to restrict optimization to those portions which depend on some recursion,
we will also assume that for each q in q, there exists at least one recursive predicate symbol q0 in
q s.t. q0  q.
7.2.1
THE PUSHDOWN METHOD
e pushdown method is based on the analogy of chain queries and context-free grammars [Ull-
man, 1992]. Without loss of generality we assume that each list of variables in chain rules consist
of one variable and that the ﬁrst argument of the query goal is a constant whereas the second one
is a variable. us, all considered predicate symbols are binary. We start by introducing the basic
idea in the following example.
Example 7.9
Consider the chain query Q D hP; sg.1; Y /i, where P is the (non-linear) pro-
gram of Example 7.8. A context-free language corresponding to this program is generated by the
following grammar³
G.Q/ D hVN ; VT ; ˘; sgi
where the set of non-terminal symbols VN contains only sg, the set of terminal symbols VT is
fa; b; c; dg, and ˘ consists of the following production rules:
sg
!
a
sg
!
b sg c sg d
Note that the production rules in ˘ are obtained from the rules of P by dropping the arguments
of predicate symbols and reversing the arrow. e language L.Q/ generated by this grammar can
be recognized by the automaton shown in Figure 7.1.
is automaton can in turn be implemented by the following program O˘ (where function
symbols are used)
³We refer the reader to Hopcroft and Ullman [1979] for a treatment of automata theory and languages.
b
c
d
a

.q0; Z0/
.q; sg Z0/
.q; sg/
.q; sg c sg d/
.q; /
.q; c/
.q; /
.q; d/
.q; /
Figure 7.1: Pushdown Automaton for the query of Example 7.9.

7.2. CHAIN QUERIES
113
q.Œ sg /:
q.T /
 
q.Œ sg j T /; a:
q.Œ sg; c; sg; d j T /
 
q.Œ sg j T /; b:
q.T /
 
q.Œ c j T /; c:
q.T /
 
q.Œ d j T /; d:
We can now derive a program OP by reintroducing variables into O˘—the derived program
will be used as part of a query equivalent to the original one. Speciﬁcally, variables X and Y are
added to the non-recursive predicate symbols. For the recursive predicate symbol, we add the
variable Y to the occurrences of the predicate symbol in the head, and the variable X to the
occurrences of the predicate symbol in the body. e resulting program OP is:
q.1; Œ sg /:
q.Y; T /
 
q.X; Œ sg j T /; a.X; Y /:
q.Y; Œ sg; c; sg; d j T /
 
q.X; Œ sg j T /; b.X; Y /:
q.Y; T /
 
q.X; Œ c j T /; c.X; Y /:
q.Y; T /
 
q.X; Œ d j T /; d.X; Y /:
e query h OP ; q.Y; Œ /i is equivalent to the original one. Observe that the rewritten program is
not a Datalog program anymore as function symbols have been used (see Chapter 5).
We now present how the technique works in general. We start by deﬁning the context-free
language associated with a q-chain query Q D hP; p.b; Y /i. Let V be the set of all predicate
symbols occurring in the q-chain rules. e set VN of non-terminal symbols is q and the set of
terminal symbols is VT D V   VN. We associate with Q the context-free language L.Q/ on the
alphabet VT deﬁned by the grammar G.Q/ D hVN ; VT ; ˘; pi where the production rules in ˘
are deﬁned as follows.
For each q-chain rule rj of the form:
pj
0.X0; Yn/  aj
0.X0; Y0/; pj
1.Y0; X1/; aj
1.X1; Y1/; : : : ; pj
n 1.Yn 1; Xn/; aj
n.Xn; Yn/:
with n  0, the following production rule is generated:
pj
0
!
aj
0 pj
1 aj
1    pj
n 1 aj
n:
e language L.Q/ is recognized by a pushdown automaton deﬁned as follows:
• it has two states q0 and q, which are, respectively, the initial and the ﬁnal state; and
• the transition table has one column for each symbol in VT plus a column for the  symbol,
one row for the pair .q0; Z0/, where Z0 is the starting pushdown symbol, and one row .q; v/
for each v 2 V .

114
7. QUERY OPTIMIZATION
Figure 7.2 illustrates the transition table. Note that, for the sake of presentation, the pushdown
alphabet is not distinct from the language alphabet. e last entry in the ﬁrst row corresponds to
the start up of the pushdown automaton and consists of entering the query goal predicate symbol
p in the pushdown store. e remaining rows corresponds to the generic q-chain rule rj shown
above; speciﬁcally, we have one row for aj
0 and one row for each aj
i , 1  i  n, that is not empty.
Obviously, if the rule is an exit rule (i.e., n D 0), the entry corresponding to aj
0 is .q; /.
aj
0
aj
1
  
aj
n

.q0; Z0/
.q; p Z0/
  
.q; pj
0/
.q; pj
1aj
1    pj
n 1aj
n/
.q; aj
1/
.q; /
  
.q; aj
n/
.q; /
  
Figure 7.2: Pushdown automaton recognizing L.Q/.
Given a string ˛ D ak1
i1 ak2
i2    akm
im in V 
T , a path spelling ˛ on P is a sequence of m C 1 (not
necessarily distinct) constants b0, b1, b2; : : : ; bm such that for each j, 1  j  m, a
kj
ij .bj 1; bj /
is an atom in the least model of P ; if m D 0 then the path spells the empty string  [Afrati and
Cosmadakis, 1989].
It is well known that, given a database D, a ground atom p.b; c/ belongs to Q.D/ if and
only if there exists a path from b to c spelling a string ˛ of L.Q/ on P . erefore, in order to
compute Q.D/, it is suﬃcient to use the automaton of Figure 7.2 to recognize all paths leaving
from b and spelling a string ˛ of L.Q/ on P [Afrati and Cosmadakis, 1989]. is can be easily
done by a logic program OP which implements the automaton. In fact, OP can be directly con-
structed using all transition rules of Figure 7.2. Speciﬁcally, we use a rule for each entry in the
table. e start-up of the automaton is simulated by a fact which sets both the initial node of the
path spelling a string of the language and the initial state of the pushdown store. For the chain
query Q D hP; p.b; Y /i, the resulting program OP is as follows:
q.b; Œp/:
  
q.Y; Œpj
1; aj
1; : : : ; pj
n 1; aj
njT /
 
q.X; Œpj
0jT /; aj
0.X; Y /:
q.Y; T /
 
q.X; Œaj
1jT /; aj
1.X; Y /:
  
q.Y; T /
 
q.X; Œaj
njT /; aj
n.X; Y /:
  

7.2. CHAIN QUERIES
115
Program
OP will be called the pushdown program of the Datalog query Q; the query
OQ D
h OP ; q.Y; Œ /i will be called the pushdown query of Q. e technique for constructing pushdown-
queries will be called the pushdown method. Here one important property is that Q is equivalent
to its pushdown query [Greco et al., 1999].
We point out that a naive execution of the rewritten program can sometimes be ineﬃ-
cient or even non-terminating for cyclic databases. In Section 7.2.5 we will present a technique,
based on the approach of Greco and Zaniolo [1992], where lists implementing pushdown stores
are represented as pairs consisting of the head and a pointer to the tuple storing the tail of the
list. In this way, each possible cyclic sequence in the pushdown store is recorded only once and
termination is guaranteed.
7.2.2
RIGHT-LINEAR PROGRAMS
e pushdown method is based on constructing a particular pushdown automaton to recognize a
context-free language.
Let us consider the case of a chain query Q for which every recursive chain rule is right-
linear, that is, both right-recursive and linear. en, the associated grammar G.Q/ is regular
right-linear (see Hopcroft and Ullman [1979] for more details) and, therefore, the pushdown
actually acts as a ﬁnite state automaton. Indeed, if the query is right-linear, then the pushdown
store either is empty or contains only one symbol. erefore, it is possible to delete the pushdown
store and put the information of the pushdown store into the states.
Of course, for right-linear chain queries, it is possible to generate directly the push-
down query which works as a ﬁnite state automaton. us, given a chain right-linear query
Q D hP; p.b; Y /i, the pushdown query is h OP ; pF .Y /i where OP consists of:
• a fact of the form
q.b/I
• a rule of the form
q0.Y /  q.X/; a.X; Y /:
for each production rule of the form q ! a q0 in G.Q/ with q and q0 being mutually recur-
sive; and
• a rule of the form
qF .Y /  q.X/; a.X; Y /:
for each production rule of the form q ! a in G.Q/.
e query obtained as described above is called the ﬁnite state query of Q.
Example 7.10
Consider the chain query Q D hP; p.c; Y /i, where P is:
p.X; Y /  b.X; Y /:
p.X; Y /  a.X; Z/; p.Z; Y /:

116
7. QUERY OPTIMIZATION
e grammar G.Q/ is regular right-linear and is as follows:
p ! b j a p:
e pushdown automaton recognizing L.Q/ is as follows
a
b

.q0; Z0/
.q; p Z0/
.q; p/
.q; p/
.q; /
e pushdown query of Q is OQ D h OP ; q.Y; Œ /i with OP as follows:
q.c; Œp/:
q.Y; Œp/
 
q.X; Œp/; a.X; Y /:
q.Y; Œ /
 
q.X; Œp/; b.X; Y /:
By deleting the pushdown store and putting its information into the state we obtain the query
h OP 0; q.Y /i where OP 0 is as follows:
qp.c/:
qp.Y /
 
qp.X/; a.X; Y /:
q.Y /
 
qp.X/; b.X; Y /:
Observe that the language L.Q/ can be recognized by a ﬁnite state automaton whose tran-
sition function is as follows:
ı.p; a/
!
p
ı.p; b/
!
pF ;
where p and pF denote the initial state and the ﬁnal state, respectively. e ﬁnite state query of
Q is h OP 00; pF .Y /i where OP 00 is the following program:
p.c/:
p.Y /
 
p.X/; a.X; Y /:
pF .Y /
 
p.X/; b.X; Y /:
us, for right-linear queries the pushdown method does not use any pushdown store and
the pushdown query of Q reduces to the ﬁnite state query of Q. Given a q-chain query Q such
that G.Q/ is right-linear, the ﬁnite state query of Q is equivalent to Q [Greco et al., 1999].
7.2.3
GRAMMAR TRANSFORMATIONS TO IMPROVE PUSHDOWN
In this section, we demonstrate that the use of automata becomes more eﬀective if the grammar
of the language has a particular structure. More interestingly, we show that if the grammar does
not have this structure, then the program can be rewritten so that the corresponding grammar

7.2. CHAIN QUERIES
117
achieves the desired structure. e rewriting is mainly done by applying known techniques for
transforming grammars.
Observe that, for a Datalog query Q, if the grammar G.Q/ is regular left-linear, then the
pushdown method does not emulate a ﬁnite state automaton, as opposed to the case where G.Q/
is regular right-linear, and it may become rather ineﬃcient or even non-terminating. As shown
in the following, we can overcome this problem by replacing left-recursion with right-recursion
applying well-known reduction techniques for grammars.
Consider a q-chain query Q D hP; p.b; Y /i and suppose that a predicate symbol s 2 q is
in the head of some left-recursive chain rule—in this case, we say that s is left-recursive. en, the
deﬁnition def.s; P / of s consists of m > 0 left-recursive chain rules and n chain rules that are not
left-recursive, that is, def.s; P / is as follows (below we assume n > 0 for the sake of simplicity):
s.X; Y /
 
˛i.X; Y /:
1  i  n
s.X; Y /
 
s0.X; Z/; ˇi.Z; Y /:
1  i  m;
where ˛i.X; Y / and ˇi.Z; Y / are conjunctions of atoms. e production rules deﬁning the symbol
s in the grammar G.Q/ are:
s
!
˛i
1  i  n
s
!
s0 ˇi
1  i  m;
where ˛i and ˇi denote the sequences of predicate symbols appearing in ˛i.X; Y / and ˇi.Z; Y /,
respectively. We can apply known transformations to remove left-recursion from the second group
of production rules for all left-recursive predicate symbols s; we then write the corresponding
Datalog rules accordingly. It turns out that the resulting program, which is said to be in canon-
ical form and is denoted by can.P /, does not contain any left-recursive q-chain rule. Moreover,
hP; p.b; Y /i is equivalent to hcan.P /; p.b; Y /i [Greco et al., 1999].
Example 7.11
Consider the following left-linear q-chain query Q D hP; path.b; Y /i, where
q D fpathg and P contains the following two rules:
path.X; Y /  edge.X; Y /:
path.X; Y /  path.X; Z/; edge.Z; Y /:
Program P computes the transitive closure of the binary relation edge and is left-linear. e
associated grammar G.Q/ is
path ! edge j path edge
and is left-recursive. To remove left-recursion, the grammar above can be rewritten into the fol-
lowing right-recursive grammar:
path
!
edge path0
path0
!
edge path0 j :

118
7. QUERY OPTIMIZATION
So, the program can.P / is:
path.X; Y /  edge.X; Z/; path0.Z; Y /:
path0.X; X/:
path0.X; Y /  edge.X; Z/; path0.Z; Y /
and is right-linear. erefore, the pushdown query can be now solved eﬃciently.
Notice that the rule path0.X; X/ does not satisfy the safety condition for Datalog programs
(cf. Section 3.1) because variable X is not limited—the reason is that the rule body is empty.
However, the rule might be made safe by adding the atom edge.Y; X/ in the body, without altering
the semantics of the query. In general, we can add suitable atoms in the body of rules in can.P /
specifying what are the values that the variables appearing only in the head can take.
Example 7.12
Assume now that program P of Example 7.11 is deﬁned as the following non-
linear program:
path.X; Y /  edge.X; Y /:
path.X; Y /  path.X; Z/; path.Z; Y /:
is program is left-recursive and, after the ﬁrst step of the procedure for removing left-recursion,
is rewritten as follows:
r1 W path.X; Y /  edge.X; Z/; path0.Z; Y /:
r2 W path0.X; X/:
r3 W path0.X; Y /  path.X; Z/; path0.Z; Y /:
e second step removes left recursion from rule r3 by rewriting it as follows:
path0.X; Y /  edge.X; W /; path0.W; Z/; path0.Z; Y /:
We now introduce a program transformation that improves the performance of the push-
down method for an interesting case of right-recursion. Suppose that there exists a predicate
symbol s in P such that def.s; P / consists of a single chain rule of the form s.X; X/ and m > 0
right-recursive chain rules of the form:
s.X; Y /  ˛i.X; Z/; s.Z; Y /:
1  i  m:
We rewrite each recursive chain rule that is in the following format:
s.X; Y /  ˛i.X; Z/; s.Z; W /; s.W; Y /:
as follows:
s.X; Y /  ˛i.X; Z/; s.Z; Y /:

7.2. CHAIN QUERIES
119
at is, we drop one occurrence of the recursive atoms at the end of the rule. If the resulting rule
has still multiple recursive atoms at the end, we repeat the transformation. e program obtained
after performing the above transformations for all the predicate symbols s in P is denoted by
simple.P /. en, hP; p.b; Y /i is equivalent to hsimple.P /; p.b; Y /i [Greco et al., 1999].
Example 7.13
Consider the program P 0 D can.P / of Example 7.12 which is reported below:
r1 W path.X; Y /
 
edge.X; Z/; path0.Z; Y /:
r2 W path0.X; X/:
r3 W path0.X; Y /
 
edge.X; W /; path0.W; Z/; path0.Z; Y /:
Clearly, def.path0; P 0/ D fr2; r3g. en, simple.P 0/ is as follows:
path.X; Y /
 
edge.X; Z/; path0.Z; Y /:
path0.X; X/:
path0.X; Y /
 
edge.X; W /; path0.W; Y /:
us, we have eventually linearized the non-linear transitive closure.
We observe that the transformation simple can be applied to a larger number of cases by
applying further grammar rewriting. For instance, given the grammar:
s
!
a s0
s0
!
b s s0 j :
We can modify it into:
s
!
a s0
s0
!
b a s0 s0 j 
so that we can eventually apply the transformation simple.
Example 7.14
Consider the fpathg-chain query Q D hP; path.b; Y /i where P is deﬁned as
follows:
path.X; Y /
 
yellow.X; Y /:
path.X; Y /
 
path.X; U /; red.U; V /; path.V; W /; blue.W; Z/; path.Z; Y /:
en, can.P / is as follows:
path.X; Y /
 
yellow.X; Z/; path0.Z; Y /:
path0.X; X/:
path0.X; Y /
 
red.X; U /; path.U; W /; blue.W; Z/; path.Z; T /; path0.T; Y /:

120
7. QUERY OPTIMIZATION
We now replace the two occurrence of path in the body of the last rule with the body of the ﬁrst
rule and obtain the equivalent program P 0:
path.X; Y /
 
yellow.X; Z/; path0.Z; Y /:
path0.X; X/:
path0.X; Y /
 
red.X; U /; yellow.U; V /; path0.V; W /; blue.W; Z/;
yellow.Z; S/; path0.S; T /; path0.T; Y /:
We can now apply the transformation simple to path0 and the last rule of P 0 becomes:
path0.X; Y /  red.X; U /; yellow.U; V /; path0.V; W /; bblue.W; Z/; yellow.Z; S/; path0.S; Y /:
We now apply another transformation for the predicate symbols for which the transforma-
tion simple cannot be applied because of the lack of the chain rule of the form s.X; X/. Suppose
that there exists a predicate symbol s in q such that def.s; P / consists of n > 0 exit chain rules,
say
s.X; Y /  ˇi.X; Y /:
1  i  n
and m > 0 right-recursive chain rules of the form:
s.X; Y /  ˛i.X; Z/; s.Z; Y /:
1  i  m
We rewrite the above rules as follows:
s.X; Y /
 
s0.X; Z/; ˇi.Z; Y /:
1  i  n
s0.X; X/:
s0.X; Y /
 
˛i.X; Z/; s0.Z; Y /:
1  i  m:
We now replace atoms in ˛i having s as predicate symbol with the bodies of the rules deﬁning s.
In this way, every rule will not have two consecutive recursive predicate symbols at the end of the
body.
e program obtained after performing the above transformations for all the predicate
symbols in P is denoted by simple0.P /. As shown in Greco et al. [1999], hsimple0.P /; p.b; Y /i
is equivalent to the original chain query hP; p.b; Y /i.
Example 7.15
Consider the fpathg-chain query Q D hP; path.b; Y /i where P is deﬁned as
follows:
path.X; Y /
 
yellow.X; Y /:
path.X; Y /
 
red.X; V /; path.V; W /; path.W; Y /:
en, simple0.P / consists of the following rules:
path.X; Y /
 
path0.X; Z/; yellow.Z; Y /:
path0.X; X/:
path0.X; Y /
 
red.X; V /; path0.V; W /; yellow.W; T /; path0.T; Y /:

7.2. CHAIN QUERIES
121
As discussed in the next section, the form of simple0.P / is very eﬀective for the performance not
only of the pushdown method but also of the counting method.
7.2.4
WHEN PUSHDOWN REDUCES TO COUNTING
In this section, we describe some conditions under which the pushdown method reduces to
the counting method [Bancilhon et al., 1986, Saccà and Zaniolo, 1988]. Actually, the count-
ing method can be seen as a space-eﬃcient implementation of the pushdown store. On the other
hand, as the pushdown method has a larger application domain, we can conclude that the push-
down method is a powerful extension of the counting method.
We ﬁrst observe that, given the pushdown program of a q-chain query, the pushdown store
can be eﬃciently implemented whenever it contains strings of the form ˛k.ˇ/n, with 0  k  1
and n  0. Indeed, the store can be replaced by the counter n and the introduction of two new
states q˛ and qˇ to record whether the top symbol is ˛ or ˇ, respectively. is situation arises when
the program consists of a number of exit chain rules and right-linear chain rules, and a single linear
non-left-recursive chain rule. e next example illustrates that the above implementation of the
pushdown store corresponds to applying the counting method.
Example 7.16
Consider the Datalog query hP; sg.d; Y /i where P is the linear program below:
sg.X; Y /
 
c.X; Y /:
sg.X; Y /
 
a.X; X1/; sg.X1; Y1/; b.Y1; Y /:
e pushdown query is hP 0; q.Y; Œ /i, where P 0 is:
q.d; Œ sg /:
q.Y; Œ sg; b j T /
 
q.X; Œ sg j T /; a.X; Y /:
q.Y; T /
 
q.X; Œ sg j T /; c.X; Y /:
q.Y; T /
 
q.Y; Œ b j T /; b.X; Y /:
Observe that the pushdown store contains strings of the form sg.b/n or of the form .b/n, with
n  0. So, we replace the store with the counter n and the introduction of two new states qsg and
qb to record whether the top symbol is sg or b, respectively. erefore, the rules above can be
rewritten as follows:
qsg.d; 0/:
qsg.Y; I/
 
qsg.X; J /; a.X; Y /; I D J C 1:
qb.Y; I/
 
qsg.X; I/; c.X; Y /:
qb.Y; I/
 
qb.Y; J /; b.X; Y /; I D J   1:
ese rules are the same as those generated by the counting method. e query goal becomes
qb.Y; 0/.

122
7. QUERY OPTIMIZATION
We now show that the above counting implementation of the pushdown store can be done
also when the pushdown strings are of the form ˛k .ˇ˛/n where 0  k  1 and n  0. is sit-
uation arises when the query’s program consists of a number of exit chain rules and right-linear
chain rules, and a single bi-linear (i.e., the rule body contains two atoms whose predicate symbols
are mutually recursive with the head predicate symbol) recursive chain rule that is right-recursive
but not left-recursive, e.g., the rule might be of the form:
p.X0; Y2/  a0.X0; Y0/; p.Y0; X1/; a1.X1; Y1/; p.Y1; Y2/:
Example 7.17
Consider the query Q D hP; path.b; Y /i where P is:
path.X; X/:
path.X; Y /  red.X; V /; path.V; W /; yellow.W; T /; path.T; Y /:
Using the counting implementation of the pushdown store, we obtain the following program:
qpath.b; 0/:
qyellow.X; I/
 
qpath.X; I/:
qpath.Y; I C 1/
 
qpath.X; I/; red.X; Y /:
qpath.Y; I   1/
 
qyellow.X; I/; yellow.X; Y /:
e query goal is qyellow.Y; 0/. It is worth noting that the above program cannot be handled by
the counting method.
7.2.5
IMPLEMENTATION AND TERMINATION
As pointed out in Section 7.2.1, the pushdown method could be ineﬃcient or even non-
terminating for cyclic databases. In this section, we show how the method can be implemented
in order to guarantee eﬃciency and termination.
e basic idea is to “distribute” stores among facts and link the facts used to memorize the
same store. Speciﬁcally, the store associated with a fact is memorized by means of two distinct
elements: a list containing a block of elements in the top of the store and a link to a fact which can
be used to derive the tail of the store. us, a fact of the form q.x; Œp1; : : : ; pn/ is memorized as
q.x; Œp1; : : : ; pk; Id/ where k  n and Id is a link to some fact which permit to determine the
tail ŒpkC1; : : : ; pn of the store.
We now present how the pushdown method is implemented. Let Q D hP; p.a; Y /i be a
chain Datalog query and let OQ D hP 0; q.Y; Œ /i be the pushdown query of Q. Recall that P 0 has

7.2. CHAIN QUERIES
123
rules of the form (see Section 7.2.1):
q.b; Œp/:
  
q.Y; Œpj
1; aj
1; : : : ; pj
n 1; aj
njT /
 
q.X; Œpj
0jT /; aj
0.X; Y /:
q.Y; T /
 
q.X; Œaj
1jT /; aj
1.X; Y /:
  
q.Y; T /
 
q.X; Œaj
njT /; aj
n.X; Y /:
  
e
pushdown implementation query
of
Q,
denoted
I. OQ/,
is
the
pushdown
query
hP 00; q.Y; Œ ; nil/i where P 00 is derived from P 0 as follows.
1. A fact of the form
q.b; Œp/:
is substituted by the following fact where nil is a new constant
q.b; Œp; nil/:
2. A rule rj of the form
q.Y; Œpj
1; aj
1; : : : ; pj
n; aj
n j T /  q.X; Œpj
0 j T /; aj
0.X; Y /
is substituted by the rule
q.Y; Œpj
1; aj
1; : : : ; pj
n; aj
n; Id.X//  q.X; Œpj
0 j T ; I/; aj
0.X; Y /;
where Id.X/ is a unique identiﬁer associated with the list of ground tuples having X as ﬁrst
argument. In the following, for the sake of simplicity, we assume that Id.X/ D X.
3. A rule rj of the following form with i < n
q.Y; T /  q.X; Œaj
i j T /; aj
i .X; Y /
is substituted by the rule
q.Y; T; I/  q.X; Œaj
i j T ; I/; aj
i .X; Y /:
4. A rule rj of the form
q.Y; T /  q.X; Œaj
n j T /; aj
n.X; Y /
is substituted by the rule
q.Y; T; I/  q.X; Œaj
n; Id.Z//; q.Z; Œp j T ; I/; aj
n.X; Y /:
Recall that p is the predicate symbol of the goal of the original chain Datalog query.

124
7. QUERY OPTIMIZATION
e following example illustrates how the pushdown implementation query is carried out.
Example 7.18
Consider the query Q D hP; sg.1; Y /i of Example 7.9. As already discussed in
Example 7.9, the pushdown query is h OP ; q.Y; Œ /i, where OP is as follows:
q.1; Œ sg /:
q.Y; T /
 
q.X; Œ sg j T /; a.X; Y /:
q.Y; Œ sg; c; sg; d j T /
 
q.X; Œ sg j T /; b.X; Y /:
q.Y; T /
 
q.X; Œ c j T /; c.X; Y /:
q.Y; T /
 
q.X; Œ d j T /; d.X; Y /:
e pushdown implementation query I. OQ/ is hP 00; sg.Y; Œ ; nil/i where P 00 is as follows:
q.1; Œ sg ; nil/:
q.Y; T; I/
 
q.X; Œ sg j T ; I/; a.X; Y /:
q.Y; Œ sg; c; sg; d ; X/
 
q.X; Œ sg j T ; I/; b.X; Y /:
q.Y; T; I/
 
q.X; Œ c j T ; I/; c.X; Y /:
q.Y; T; I/
 
q.X; Œ d ; Z/; q.Z; Œ sg j T ; I/; d.X; Y /:
As shown in Greco et al. [1999], I. OQ/ is equivalent to the original query Q. Moreover,
the implementation technique, besides eﬃciency, guarantees also termination of the evaluation
process, that is, the bottom-up computation of I. OQ/ always terminates [Greco et al., 1999].
e following example shows how queries are computed in the presence of cyclic databases.
Example 7.19
Let I. OQ/ D hP 00; sg.Y; Œ ; nil/i be the pushdown query of Example 7.18. Con-
sider the database pictured in Figure 7.3 where a fact p.x; y/ is represented by an edge from x to
y with label p.
c
a
a
d
b
d
c
a
b
n
?
-
?
-
-
-
6
6
-
10
9
8
7
6
5
4
3
2
1n
Figure 7.3: Acyclic database.

7.2. CHAIN QUERIES
125
e evaluation of program P 00 produces the following ground atoms: q.1; Œ sg ; nil/,
q.2; Œ sg; c; sg; d ; 1/, q.3; Œ sg; c; sg; d ; 2/, q.4; Œ c; sg; d ; 2/, q.5; Œ sg; d ; 2/, q.6; Œ d ; 2/,
q.7; Œ c; sg; d ; 1/,
q.8; Œ sg; d ; 1/,
q.9; Œ d ; 1/, and
q.10; Œ ; nil/.
erefore, the answer is
Y D 10.
Consider now the cyclic database pictured in Figure 7.4. e evaluation of program
P 00 produces the ground atoms q.1; Œ sg ; nil/, q.2; Œ sg; c; sg; d ; 1/,
q.1; Œ sg; c; sg; d ; 2/,
q.3; Œ c; sg; d ; 1/, q.4; Œ sg; d ; 1/, q.5; Œ d ; 1/, q.6; Œ ; nil/, q.6; Œ c; sg; d ; 2/, q.7; Œ sg; d ; 2/,
q.8; Œ d ; 2/, q.9; Œ c; sg; d ; 1/, q.10; Œ sg; d ; 1/, q.11; Œ d ; 1/ and q.10; Œ ; nil/. erefore, the
answers are Y D 6 and Y D 12.
HH
j


12
11
10
d
n
?
-
-
n
n
1
2
3
4
5
6
7
8
9
-
6
-
-
-
?
-
?
b
a
c
d
b
d
a
a
c
Figure 7.4: Cyclic database.
e implementation of the pushdown method can be seen as a smart implementation of
the supplementary magic-sets method [Saccà and Zaniolo, 1986] (see also Beeri and Ramakr-
ishnan [1991]). Moreover, for non-linear programs there is an important diﬀerence since the
method generates less non-linear recursive rules than the supplementary magic-sets method. For
instance, consider the non-linear query of Example 7.9. e program obtained by applying the
supplementary magic-sets method is as follows:
m_sg.b/:
m_sg.X1/
 
s_sg1.Z; X1/:
m_sg.Y2/
 
s_sg3.Z; Y2/:
s_sg1.X; X1/
 
m_sg.X/; b.X; X1/:
s_sg2.X; X2/
 
s_sg1.X; X1/; sg.X1; X2/:
s_sg3.X; X3/
 
s_sg2.X; X2/; c.X2; Y2/:
sg.X; Y /
 
m_sg.X/; a.X; Y /:
sg.X; Y /
 
s_sg3.X; Y2/; sg.Y2; Y1/; d.Y1; Y /:

126
7. QUERY OPTIMIZATION
e rule deﬁning predicate symbol s_sg2 and the second rule deﬁning predicate symbol
sg are bi-linear, that is, they have two occurrences of predicate symbols mutually recursive with
the head predicate symbol. e program generated by the pushdown method contains only one
bi-linear rule and, therefore, its execution can be more eﬃcient.
In the general case, given a nonlinear recursive rule having n > 1 occurrences of predicate
symbols in its body that are mutually recursive with the head predicate symbol, the pushdown
method generates only one bi-linear rule whereas the supplementary magic-sets method generates
n bi-linear rules. Observe also that the space used by the pushdown method is less than that
used by the supplementary magic-sets method since the pushdown method does not use magic
predicates.
BIBLIOGRAPHIC NOTES
Magic-sets rewriting has been studied in several papers [Bancilhon and Ramakrishnan, 1988,
Bancilhon et al., 1986, Beeri and Ramakrishnan, 1987, 1991, Greco and Zaniolo, 1992, 1994,
Naughton et al., 1989a,b, Ramakrishnan et al., 1989, Ullman, 1989]
e analogies between chain queries and context-free languages were investigated by several
authors, including [Afrati and Papadimitriou, 1987, Beeri et al., 1990, Dong, 1992a,b, Pereira and
Warren, 1980, Ullman, 1992, Ullman and Van Gelder, 1986]. In particular, the use of automata
to compute general logic queries was ﬁrst proposed by Lang [1988]. Lang’s method is based on
pushing facts from the database onto the stack for later use in reverse order in the proof of a goal.
As the method applies to general queries, it is not very eﬀective for chain queries; besides, it does
not exploit possible bindings.
Vieille [1989] independently proposed an extension of SLD-resolution which avoids repli-
cated computations in the evaluation of general logic queries using stacks to perform a set-oriented
computation. Also this method does not take advantage of a possible chain structure but it does
exploit possible bindings.
e ﬁrst proposal of a method that is both specialized for chain queries and based on
the properties of context-free language is due to Yannakakis [1990], who proposed a dynamic
programming technique implementing the method of Cocke-Younger and Kasami to recognize
strings of general context-free languages. is technique turns out to be eﬃcient for unbound
queries but it does not support any mechanism to reduce the search space when bindings are
available.
Strategies for processing and optimizing Datalog queries are discussed also in Abiteboul
et al. [1995], Bancilhon and Ramakrishnan [1986], Ceri et al. [1989], Green et al. [2013], Ullman
[1989].
Several extensions of the magic-sets technique have been proposed to deal with Datalog
extended with stratiﬁed negation [Behrend, 2003], a restricted form of negation called modular
stratiﬁcation [Ross, 1994], unstratiﬁed negation [Faber et al., 2007], disjunction [Cumbo et al.,

7.2. CHAIN QUERIES
127
2004], disjunction and stratiﬁed negation [Alviano et al., 2012, Greco, 1998b, 1999b, 2003], and
disjunction and constraints [Greco et al., 2005].


129
C H A P T E R
8
Applications
Recently, there has been a great deal of interest in applying Datalog in several domains [Huang
et al., 2011] such as declarative networking [Loo et al., 2005a,b, 2006], network monitor-
ing [Abiteboul et al., 2005], program analysis [Bravenboer and Smaragdakis, 2009], secu-
rity [Marczak et al., 2010, Zhou et al., 2009], cloud computing [Alvaro et al., 2010], information
extraction [Gottlob et al., 2004, Shen et al., 2007], P2P deductive databases [Caroprese et al.,
2006], and social network analysis [Seo et al., 2013]. Speciﬁcally, these works extend the Data-
log language and its implementation techniques with constructs that are particularly useful for a
speciﬁc domain.
e arguments in favor of Datalog-like languages is the declarative nature of the resulting
languages, which eases the problem formulation for the user and allows powerful performance
optimizations on the part of the system.
In this chapter, we brieﬂy discuss diﬀerent domains where Datalog or Datalog-like lan-
guages have been recently applied.
8.1
SECURITY
e Binder language [DeTreville, 2002] is a Datalog-based language for access control in dis-
tributed systems.
A “principal” in Binder refers to a component in a distributed environment. Each principal
has its own local context where its rules reside. Binder assumes an untrusted network, where
diﬀerent components can serve diﬀerent roles running distinct sets of rules. Because of the lack
of trust among nodes, a component does not have control over rule execution at other nodes.
Instead, Binder allows separate programs to interoperate correctly and securely via the export and
import of rules and derived tuples across contexts
Example8.1
Binder has a distinguished operator says. e says operator implements a common
logical construct in authentication, where “p says s” means that principal p supports statement
s. For instance, in Binder we can write:
access.P; O; read/  good.P /:
access.P; O; read/  bob says access.P; O; read/:
e rules above state that any principal P may access any object O in read mode if P is good
or if bob says that P may do so. e says operator abstracts from the details of authentication.

130
8. APPLICATIONS
8.2
NETWORKING
Network Datalog (NDlog) [Loo et al., 2006] is a Datalog-like language used for querying network
graphs, allowing one to implement a variety of routing protocols and overlay networks.
Example 8.2
e following NDlog programs ﬁnds all pairs of reachable vertices over a graph
stored by means of link-facts representing the graph edges.
reachable.@S; D/  link.@S; D/:
reachable.@S; D/  link.@S; Z/; reachable.@Z; D/:
e rules above specify a distributed transitive closure computation. NDlog supports a lo-
cation speciﬁer in each predicate, expressed with @ symbol followed by an attribute. is attribute
is used to denote the source location of each corresponding tuple. For example, all reachable and
link tuples are stored based on the @S address ﬁeld.
e Secure Network Datalog (SeNDlog) language [Zhou et al., 2009] uniﬁes Binder and
NDlog. SecureBlox [Marczak et al., 2010] is a declarative system that uniﬁes a distributed query
processor with a security policy framework. SecureBlox decouples security concerns from sys-
tem speciﬁcation allowing easy reconﬁguration of a system’s security properties to suit a given
execution environment.
8.3
WEB DATA MANAGEMENT
Webdamlog [Abiteboul et al., 2011] is a language to support the distribution of both data and
knowledge (i.e., programs) over a network of autonomous peers communicating in an asyn-
chronous way. e language supports updates, distribution, negation, and the novel feature of
delegation, that is, the ability for a peer to communicate a program to another peer.
e following example illustrates the main aspects of the language—for a formal deﬁnition
we refer the reader to Abiteboul et al. [2011].
Example 8.3
[Abiteboul et al., 2011] Consider a relation birthday at a peer named myIphone
storing information on friends’ birthdays and how to wish them a happy birthday (i.e., on which
servers and with which messages). Facts of this kind can be express as follows:
birthday@myIphone.‘‘Alice;00 sendmail; inria:fr; 08=08/
birthday@myIphone.‘‘Bob;00 sms; BobIphone; 01=12/;
where, for instance, the ﬁrst fact says that Alice’s birthdays is August 8and wishes should be
sent by email to server inria:fr.
A rule of the following form can be used to send birthday messages:
$message@$peer.$name; ‘‘Happy birthday”/ W  today@myIphone.$d/;
birthday@myIphone.$name; $message; $peer; $d/

8.4. PROGRAM ANALYSIS
131
An identiﬁer starting with the symbol $ is a variable. While the two facts above represent
pieces of local knowledge of myIphone, the fact
sendmail@inria:fr.Alice; ‘‘Happy birthday”/
describes a message that is sent from myIphone to inria:fr.
e semantics of the global system is deﬁned based on local semantics and the exchange
of messages and rules. Intuitively, a given peer chooses how to move to another state based on its
local state (a set of local facts and messages received from other peers) and its program. A move
consists in (1) consuming the local facts, (2) deriving new local facts, which deﬁne the next state,
(3) deriving nonlocal facts, i.e., messages sent to other peers, and (4) modifying their programs
via “delegations.”
Example 8.3 showed the derivation of local facts and messages sent to other peers. e
following example illustrates delegation, one of the main features of Webdamlog.
Example 8.4
[Abiteboul et al., 2011] Consider the following rule, installed at peer p:
at p W m@q./ W  m1@p.$x/; m2@p0.$x/:
Suppose that m1@p.a1/ holds, for some value a1. en, the eﬀect of the rule is to install at p0
the following rule:
at p0 W m@q./ W  m2@p0.a1/:
e action of installing a rule at some other peer is called delegation.
When p0 runs, if m2@p0.a1/ holds, it will send the message m@q./ to q. e basic idea of
the delegation from p to p0 is that there is some knowledge from p0 that is needed to perform
the task speciﬁed by the rule above. So, to perform that task, p delegates the remainder of the
rule to p0.
8.4
PROGRAM ANALYSIS
e Doop framework has been proposed in Bravenboer and Smaragdakis [2009] for points-to
analysis of Java programs. Points-to analysis concerns the problem of determining which objects
a program variable can point to. e approach of Bravenboer and Smaragdakis [2009] relies on
Datalog for specifying program analyses and proposes optimizations to speed-up such analyses.
Example 8.5
For the purpose of performing points-to analysis the following two base relations
can be used:
• a
binary
relation
AssignHeapAllocation
storing
facts
of
the
form
AssignHeapAllocation.v; o/, where v is a Java variable and o identiﬁes a heap object
(pointed to by v)—such facts can be derived from a Java program by introducing one
fact for each instruction a D new A./ in the Java program, that is, when a heap object is
allocated and assigned to a Java variable; and

132
8. APPLICATIONS
• a binary relation Assign storing facts of the form Assign.from; to/, where from and to are Java
variables—the Assign relation has one fact for each assignment between two Java (reference)
variables, that is, when a Java assignment to D from is found.
Given the AssignHeapAllocation and Assign relations of a given Java program, a simple
points-to analysis can be easily expressed in Datalog as follows:
varPointsTo.V; O/
 AssignHeapAllocation.V; O/:
varPointsTo.To; O/
 Assign.From; To/; varPointsTo.From; O/:
e declarative nature of Datalog and its ability of expressing recursive relations makes
Datalog suitable for expressing complex program analysis algorithms. For instance, Example 8.5
showed how a simple points-to analysis can be succinctly expressed in Datalog leveraging recur-
sion.
As another example, recursion can be exploited to easily express a Datalog program check-
ing whether a method m1 is reachable from a method m2, provided that we have points-to infor-
mation, so that the target objects of a virtual method call are known.
8.5
MODULE COMPOSITION
A Datalog language for automatic service composition has been proposed in Albanese et al.
[2013]. Composition comes into play when a user’s request cannot be fulﬁlled by a single software
module, but the composition of multiple modules can provide the requested services.
e general framework of Albanese et al. [2013] allows users to express QoS and security
attributes associated with services and take them into account in the composition process. In ad-
dition, it is possible to express both hard and soft requirements for the QoS and security attributes
that should come with the requested services. e adopted language is Datalog augmented with
disjunction, negation, strong and weak constraints [Buccafurri et al., 2000].
e following example illustrates some of the basic features of the language.
Example 8.6
Suppose we are given a set of modules, where each of them provides services to
other modules and possibly requires services from other modules in order to deliver those oﬀered.
Modules and their required/provided services can be expressed by means of facts of the following
form.
• A fact module.m/ means that m is a module.
• A fact requires.m; r/ means that r is a service required by module m.
• A fact provides.m; p/ means that p is a service provided by module m.
• A fact of the form compatible.m1; p; m2; r/ means that service p provided by module m1
can fulﬁll service r required by module m2. Facts of this kind can be computed by means of
Datalog rules expressing speciﬁc compatibility criteria.

8.5. MODULE COMPOSITION
133
e following Datalog rules can be used to guess a set of modules and determine the services
that can be delivered through their composition:
taken.M/ _ not_taken.M/
 
module.M/:
fulﬁlled.M2; R/
 
taken.M2/; requires.M2; R/;
delivers.M1; P/; compatible.M1; P; M2; R/:
delivers.M; I/
 
taken.M/; provides.M; I/; :cannot_deliver.M/:
cannot_deliver.M/
 
requires.M; I/; :fulﬁlled.M; I/:
e ﬁrst rule above is used to guess a subset of the available modules, say S. e second rule
says that fulﬁlled.hM2; R/ is derived if R is a service required by module M2 and there is a module
M1 in S delivering a service P that fulﬁls R. e third rule allows us to derive delivers.M; I/ if
module M can deliver service I. e fourth rule allows us to derive cannot_deliver.M/ if M is a
module whose provided services cannot be delivered because at least one of its required services
cannot be matched with a service delivered by a taken module.


135
Bibliography
Serge Abiteboul and Victor Vianu. Datalog extensions for database queries and updates. J. Comp.
and System Sci., 43(1):62–124, 1991. DOI: 10.1016/0022-0000(91)90032-Z. 59, 60
Serge Abiteboul, Richard Hull, and Victor Vianu. Foundations of Databases. Addison-Wesley,
1995. 11, 12, 13, 15, 26, 32, 38, 59, 126
Serge Abiteboul, Zoë Abrams, Stefan Haar, and Tova Milo. Diagnosis of asynchronous discrete
event systems: datalog to the rescue! In Proc. 24th ACM SIGACT-SIGMOD-SIGART Symp.
on Principles of Database Systems, pages 358–367, 2005. DOI: 10.1145/1065167.1065214. 129
Serge Abiteboul, Meghyn Bienvenu, Alban Galland, and Emilien Antoine. A rule-based lan-
guage for web data management. In Proc. 30th ACM SIGACT-SIGMOD-SIGART Symp. on
Principles of Database Systems, pages 293–304, 2011. DOI: 10.1145/1989284.1989320. 130,
131
Foto N. Afrati and Stavros S. Cosmadakis. Expressiveness of restricted recursive queries (ex-
tended abstract). In Proc. 21st Annual ACM Symp. on eory of Computing, pages 113–126,
1989. DOI: 10.1145/73007.73018. 110, 114
Foto N. Afrati and Christos H. Papadimitriou. e parallel complexity of simple chain queries.
In Proc. 6th ACM SIGACT-SIGMOD-SIGART Symp. on Principles of Database Systems, pages
210–213, 1987. DOI: 10.1145/28659.28682. 126
Foto N. Afrati, Stavros S. Cosmadakis, and Mihalis Yannakakis. On datalog vs. polynomial time.
J. Comp. and System Sci., 51(2):177–196, 1995. DOI: 10.1006/jcss.1995.1060. 31, 33
Alfred V. Aho and Jeﬀrey D. Ullman. e universality of data retrieval languages. In Proc.
16th ACM SIGACT-SIGPLAN Symp. on Principles of Programming Languages, pages 110–120,
1979. DOI: 10.1145/567752.567763. 18, 31
Massimiliano Albanese, Sushil Jajodia, and Cristian Molinaro. A logic framework for ﬂexible
and security-aware service composition. In Proc. IEEE International Conference on Autonomic
and Trusted Computing, pages 337–346, 2013. DOI: 10.1109/UIC-ATC.2013.11. 132
Peter Alvaro, Tyson Condie, Neil Conway, Khaled Elmeleegy, Joseph M. Hellerstein, and
Russell Sears.
Boom analytics: exploring data-centric, declarative programming for the
cloud.
In Proc. European Conference on Computer Systems, pages 223–236, 2010. DOI:
10.1145/1755913.1755937. 129

136
BIBLIOGRAPHY
Mario Alviano, Wolfgang Faber, and Nicola Leone. Disjunctive asp with functions: Decidable
queries and eﬀective computation. eory & Practice of Logic Program., 10(4-6):497–512, 2010.
DOI: 10.1017/S1471068410000244. 86
Mario Alviano, Francesco Calimeri, Wolfgang Faber, Nicola Leone, and Simona Perri. Un-
founded sets and well-founded semantics of answer set programs with aggregates. J. Artiﬁcial
Intel. Res., 42:487–527, 2011. DOI: 10.1613/jair.3432. 99
Mario Alviano, Wolfgang Faber, Gianluigi Greco, and Nicola Leone. Magic sets for disjunctive
datalog programs. Artiﬁcial Intell., 187:156–192, 2012. DOI: 10.1016/j.artint.2012.04.008.
127
Krzysztof R. Apt. Logic Programming, pages 493–574. Handbook of eoretical Computer
Science. Elsevier, 1991. 15, 22
Krzysztof R. Apt and Maarten H. van Emden. Contributions to the theory of logic programming.
J. ACM, 29(3):841–862, 1982. DOI: 10.1145/322326.322339. 32
Krzysztof R. Apt, Howard A. Blair, and Adrian Walker. Towards a theory of declarative knowl-
edge. In Foundations of Deductive Databases and Logic Programming., pages 89–148. Morgan
Kaufmann, 1988. 36, 38
Molham Aref, Balder ten Cate, Todd J. Green, Benny Kimelfeld, Dan Olteanu, Emir Pasalic,
Todd L. Veldhuizen, and Geoﬀrey Washburn. Design and implementation of the logicblox
system. In Proc. ACM SIGMOD Int. Conf. on Management of Data, pages 1371–1382, 2015.
DOI: 10.1145/2723372.2742796. 60
omas Arts and Jürgen Giesl. Termination of term rewriting using dependency pairs. eor.
Comp. Sci., 236(1-2):133–178, 2000. DOI: 10.1016/S0304-3975(99)00207-8. 86
Isaac Balbin and Kotagiri Ramamohanarao.
A generalization of the diﬀerential approach to
recursive query evaluation.
J. Logic Program., 4(3):259–262, 1987. DOI: 10.1016/0743-
1066(87)90004-5. 32
Isaac Balbin, Graeme S. Port, Kotagiri Ramamohanarao, and Krishnamurthy Meenakshi. Eﬃ-
cient bottom-up computation of queries on stratiﬁed databases. J. Logic Program., 11(3&4):
295–344, 1991. DOI: 10.1016/0743-1066(91)90030-S. 107, 108
François Bancilhon and Raghu Ramakrishnan. Performance evaluation of data intensive logic
programs. In Foundations of Deductive Databases and Logic Program. Morgan Kaufmann, 1988.
DOI: 10.1016/B978-0-934613-40-8.50016-6. 126
François Bancilhon, David Maier, Yehoshua Sagiv, and Jeﬀrey D. Ullman. Magic sets and other
strange ways to implement logic programs. In Proc. 5th ACM SIGACT-SIGMOD Symp. on

BIBLIOGRAPHY
137
Principles of Database Systems, pages 1–15, 1986. DOI: 10.1145/6012.15399. 101, 109, 110,
121, 126
François Bancilhon and Raghu Ramakrishnan. An amateur’s introduction to recursive query
processing strategies. In Proc. ACM SIGMOD Int. Conf. on Management of Data, pages 16–
52, 1986. DOI: 10.1145/16856.16859. 32, 126
Sabrina Baselice, Piero A. Bonatti, and Giovanni Criscuolo. On ﬁnitely recursive programs.
eory & Practice of Logic Program., 9(2):213–238, 2009. DOI: 10.1017/S147106840900372X.
86
Catriel Beeri and Raghu Ramakrishnan. On the power of magic. In Proc. 6th ACM SIGACT-
SIGMOD-SIGART Symp. on Principles of Database Systems, pages 269–284, 1987. DOI:
10.1145/28659.28689. 126
Catriel Beeri and Raghu Ramakrishnan. On the power of magic. J. Logic Program., 10(3&4):
255–299, 1991. DOI: 10.1016/0743-1066(91)90038-Q. 101, 107, 108, 125, 126
Catriel Beeri, Paris C. Kanellakis, François Bancilhon, and Raghu Ramakrishnan. Bounds on the
propagation of selection into logic programs. J. Comp. and System Sci., 41(2):157–180, 1990.
DOI: 10.1016/0022-0000(90)90035-J. 109, 110, 126
Andreas Behrend. Soft stratiﬁcation for magic set based query evaluation in deductive databases.
In Proc. 22nd ACM SIGACT-SIGMOD-SIGART Symp. on Principles of Database Systems, pages
102–110, 2003. DOI: 10.1145/773153.773164. 126
Nicole Bidoit and Richard Hull. Positivism vs. minimalism in deductive databases. In Proc. 5th
ACM SIGACT-SIGMOD Symp. on Principles of Database Systems, pages 123–132, 1986. DOI:
10.1145/6012.15409. 59
Piero A. Bonatti. Reasoning with inﬁnite stable models. Artiﬁcial Intell., 156(1):75–111, 2004.
DOI: 10.1016/j.artint.2004.02.001. 86
Martin Bravenboer and Yannis Smaragdakis. Strictly declarative speciﬁcation of sophisticated
points-to analyses. In Proc. 24th ACM SIGPLAN Conf. on Object-Oriented Programming Sys-
tems, Languages & Applications, pages 243–262, 2009. DOI: 10.1145/1639949.1640108. 129,
131
Maurice Bruynooghe, Michael Codish, John P. Gallagher, Samir Genaim, and Wim Vanhoof.
Termination analysis of logic programs through combination of type-based norms. ACM Trans.
Prog. Lang. and Syst., 29(2), 2007. DOI: 10.1145/1216374.1216378. 86
Francesco Buccafurri, Sergio Greco, and Domenico Saccà. e expressive power of unique total
stable model semantics. In 24th Int. Colloquium on Automata, Languages, and Programming,
pages 849–859, 1997. DOI: 10.1007/3-540-63165-8_237. 59

138
BIBLIOGRAPHY
Francesco Buccafurri, Nicola Leone, and Pasquale Rullo. Enhancing disjunctive datalog by con-
straints. IEEE Trans. Knowl. and Data Eng., 12(5):845–860, 2000. DOI: 10.1109/69.877512.
132
Marco Cadoli and Luigi Palopoli. Circumscribing datalog: Expressive power and complexity.
eor. Comp. Sci., 193(1-2):215–244, 1998. DOI: 10.1016/S0304-3975(97)00108-4. 59
M. Calautti, S. Greco, F. Spezzano, and I. Trubitsyna. Checking termination of bottom-up
evaluation of logic programs with function symbols. eory & Practice of Logic Program., 2015a.
DOI: 10.1017/S1471068414000623. 86
Marco Calautti, Sergio Greco, and Irina Trubitsyna. Detecting decidable classes of ﬁnitely ground
logic programs with function symbols. In Proc. International Symposium on Principles and Prac-
tice of Declarative Programming, pages 239–250, 2013. DOI: 10.1145/2505879.2505883. 86
Marco Calautti, Sergio Greco, Cristian Molinaro, and Irina Trubitsyna. Checking termination
of logic programs with function symbols through linear constraints. In Proc. International Web
Rule Symposium, pages 97–111, 2014. DOI: 10.1007/978-3-319-09870-8_7. 86
Marco Calautti, Sergio Greco, Cristian Molinaro, and Irina Trubitsyna. Logic program termi-
nation analysis using atom sizes. In Proc. 24th Int. Joint Conf. on AI, pages 2833–2839, 2015b.
86
Marco Calautti, Sergio Greco, Cristian Molinaro, and Irina Trubitsyna. Checking termination
of datalog with function symbols through linear constraints. In Proc. 23rd Italian Symposium
on Advanced Database Systems, 2015c. 86
Marco Calautti, Sergio Greco, Cristian Molinaro, and Irina Trubitsyna. Using linear constraints
for logic program termination analysis. eory & Practice of Logic Program., 2016. 86
Andrea Calì, Georg Gottlob, and omas Lukasiewicz.
A general datalog-based frame-
work for tractable query answering over ontologies.
In Proc. 28th ACM SIGACT-
SIGMOD-SIGART Symp. on Principles of Database Systems, pages 77–86, 2009. DOI:
10.1016/j.websem.2012.03.001. 12
Andrea Calì, Georg Gottlob, and omas Lukasiewicz. Datalog˙: a uniﬁed approach to ontolo-
gies and integrity constraints. In Proc. 12th Int. Conf. on Database eory, pages 14–30, 2009.
DOI: 10.1145/1514894.1514897. 12
Francesco Calimeri, Susanna Cozza, Giovambattista Ianni, and Nicola Leone. Computable func-
tions in asp: eory and implementation. In Proc. 24th Int. Conf. Logic Programming, pages
407–424, 2008. DOI: 10.1007/978-3-540-89982-2_37. 64, 86

BIBLIOGRAPHY
139
Francesco Calimeri, Susanna Cozza, Giovambattista Ianni, and Nicola Leone. Enhancing ASP
by functions: Decidable classes and implementation techniques. In Proc. 24th National Conf.
on Artiﬁcial Intelligence, 2010. 86
Luciano Caroprese, Cristian Molinaro, and Ester Zumpano. Integrating and querying P2P de-
ductive databases. In Proc. 10th International Database Engineering and Applications Symposium
(IDEAS), pages 285–290, 2006. DOI: 10.1109/IDEAS.2006.28. 129
Stefano Ceri, Georg Gottlob, and Letizia Tanca. What you always wanted to know about datalog
(and never dared to ask). IEEE Trans. Knowl. and Data Eng., 1(1):146–166, 1989. DOI:
10.1109/69.43410. 126
Stefano Ceri, Georg Gottlob, and Letizia Tanca. Logic Programming and Databases. Springer,
1990. DOI: 10.1007/978-3-642-83952-8. 32
Ashok K. Chandra and David Harel. Structure and complexity of relational queries. J. Comp.
and System Sci., 25(1):99–128, 1982. DOI: 10.1016/0022-0000(82)90012-5. 32
Ashok K. Chandra and David Harel. Horn clauses queries and generalizations. J. Logic Program.,
2(1):1–15, 1985. DOI: 10.1016/0743-1066(85)90002-0. 36
Ashok K. Chandra and Philip M. Merlin. Optimal implementation of conjunctive queries in
relational data bases. In Proc. 9th Annual ACM Symp. on eory of Computing, pages 77–90,
1977. DOI: 10.1145/800105.803397. 12
Peter Cholak and Howard A. Blair. e complexity of local stratiﬁcation. Fundam. Inform., 21
(4):333–344, 1994. DOI: 10.3233/FI-1994-2144. 59
E. F. Codd. Relational completeness of data base sublanguages. In: R. Rustin (ed.): Database
Systems: 65-98, Prentice Hall and IBM Research Report RJ 987, San Jose, California, 1972.
15
Edgar F. Codd. A relational model of data for large shared data banks. Commun. ACM, 13(6):
377–387, 1970. DOI: 10.1145/362384.362685. 3, 15
Michael Codish, Vitaly Lagoon, and Peter J. Stuckey.
Testing for termination with mono-
tonicity constraints. In Proc. 21st Int. Conf. Logic Programming, pages 326–340, 2005. DOI:
10.1007/11562931_25. 86
Mariano P. Consens and Alberto O. Mendelzon. Low complexity aggregation in graphlog and
datalog. In Proc. 3rd Int. Conf. on Database eory, pages 379–394, 1990. DOI: 10.1007/3-
540-53507-1_90. 99
Chiara Cumbo, Wolfgang Faber, Gianluigi Greco, and Nicola Leone. Enhancing the magic-set
method for disjunctive datalog programs. In Proc. 20th Int. Conf. Logic Programming, pages
371–385, 2004. DOI: 10.1007/978-3-540-27775-0_26. 126

140
BIBLIOGRAPHY
Evgeny Dantsin, omas Eiter, Georg Gottlob, and Andrei Voronkov. Complexity and expressive
power of logic programming. In IEEE Conference on Computational Complexity, pages 82–101,
1997. DOI: 10.1109/CCC.1997.612304. 32
Evgeny Dantsin, omas Eiter, Georg Gottlob, and Andrei Voronkov.
Complexity and ex-
pressive power of logic programming.
ACM Comput. Surv., 33(3):374–425, 2001. DOI:
10.1145/502807.502810. 32, 43, 47, 59
Chris J. Date. An Introduction to Database Systems (7th ed.). Addison-Wesley-Longman, 2000.
15
Danny De Schreye and Stefaan Decorte. Termination of logic programs: e never-ending story.
J. Logic Program., 19/20:199–260, 1994. DOI: 10.1016/0743-1066(94)90027-2. 86
John DeTreville. Binder, a logic-based security language. In Proc. IEEE Symposium on Security
and Privacy, pages 105–113, 2002. DOI: 10.1109/SECPRI.2002.1004365. 129
Alin Deutsch, Alan Nash, and Jeﬀrey B. Remmel. e chase revisited. In Proc. 27th ACM
SIGACT-SIGMOD-SIGART Symp. on Principles of Database Systems, pages 149–158, 2008.
DOI: 10.1145/1376916.1376938. 86
Suzanne W. Dietrich. Shortest path by approximation in logic programs. ACM Lett. on Program.
Lang. and Syst., 1(2):119–137, 1992. DOI: 10.1145/151333.151377. 99
Guozhu Dong. Datalog expressiveness of chain queries: Grammar tools and characterizations.
In Proc. 11th ACM SIGACT-SIGMOD-SIGART Symp. on Principles of Database Systems, pages
81–90, 1992a. DOI: 10.1145/137097.137113. 126
Guozhu Dong. On datalog linearization of chain queries. In eoretical Studies in Computer
Science, pages 181–206, 1992b. 109, 110, 126
Sergey Dudakov. On the complexity of perfect models of logic programs. Fundam. Inform., 39
(3):249–258, 1999. DOI: 10.3233/FI-1999-39302. 59
omas Eiter, Georg Gottlob, and Heikki Mannila. Disjunctive datalog. ACM Trans. Database
Syst., 22(3):364–418, 1997a. DOI: 10.1145/261124.261126. 59, 60
omas Eiter, Nicola Leone, and Domenico Saccà.
On the partial semantics for disjunc-
tive deductive databases.
Ann. of Math. and Artiﬁcial Intell., 19(1-2):59–96, 1997b. DOI:
10.1023/A:1018947420290. 59
omas Eiter, Nicola Leone, and Domenico Saccà. Expressive power and complexity of partial
models for disjunctive deductive databases. eor. Comp. Sci., 206(1-2):181–218, 1998. DOI:
10.1016/S0304-3975(97)00129-1. 59

BIBLIOGRAPHY
141
Ramez Elmasri and Shamkant B. Navathe. Fundamentals of Database Systems, 3rd ed. Addison-
Wesley-Longman, 2000. 15
Jörg Endrullis, Johannes Waldmann, and Hans Zantema.
Matrix interpretations for prov-
ing termination of term rewriting.
J. of Automated Reason., 40(2-3):195–220, 2008. DOI:
10.1007/s10817-007-9087-9. 86
Wolfgang Faber, Gianluigi Greco, and Nicola Leone. Magic sets and their application to data
integration. J. Comp. and System Sci., 73(4):584–609, 2007. DOI: 10.1016/j.jcss.2006.10.012.
126
Wolfgang Faber, Gerald Pfeifer, and Nicola Leone.
Semantics and complexity of recur-
sive aggregates in answer set programming.
Artiﬁcial Intell., 175(1):278–298, 2011. DOI:
10.1016/j.artint.2010.04.002. 99
Ronald Fagin, Phokion G. Kolaitis, Renée J. Miller, and Lucian Popa. Data exchange: semantics
and query answering. eor. Comp. Sci., 336(1):89–124, 2005. DOI: 10.1016/j.tcs.2004.10.033.
12, 86
Maria C. F. Ferreira and Hans Zantema. Total termination of term rewriting. Applic. Algebra in
Eng., Commun. and Comput., 7(2):133–162, 1996. DOI: 10.1007/BF01191381. 86
Amelia C. Fong and Jeﬀrey D. Ullman. Induction variables in very high level languages. In Proc.
3rd ACM SIGACT-SIGPLAN Symp. on Principles of Programming Languages, pages 104–112,
1976. DOI: 10.1145/800168.811544. 32
Filippo Furfaro, Sergio Greco, and Cristian Molinaro. A three-valued semantics for querying and
repairing inconsistent databases. Ann. of Math. and Artiﬁcial Intell., 51(2-4):167–193, 2007.
DOI: 10.1007/s10472-008-9088-3. 59
Hervé Gallaire and Jack Minker, editors. Logic and Data Bases, Symposium on Logic and Data
Bases, Centre d’études et de recherches de Toulouse, 1977, Advances in Data Base eory, 1978.
Plemum Press. 32
Hervé Gallaire, Jack Minker, and Jean-Marie Nicolas. Logic and databases: A deductive ap-
proach. ACM Comput. Surv., 16(2):153–185, 1984. DOI: 10.1145/356924.356929. 32
Sumit Ganguly, Sergio Greco, and Carlo Zaniolo. Minimum and maximum predicates in logic
programming. In Proc. 10th ACM SIGACT-SIGMOD-SIGART Symp. on Principles of Database
Systems, pages 154–163, 1991. DOI: 10.1145/113413.113427. 97, 99
Hector Garcia-Molina, Jeﬀrey D. Ullman, and Jennifer Widom. Database Systems - e Complete
Book (2nd ed.). Pearson Education, 2009. 15

142
BIBLIOGRAPHY
Martin Gebser, Torsten Schaub, and Sven iele. Gringo: A new grounder for answer set pro-
gramming. In Proc. 9th Int. Conf. Logic Programming and Nonmonotonic Reasoning, pages 266–
271, 2007. DOI: 10.1007/978-3-540-72200-7_24. 63, 86
Martin Gebser, Benjamin Kaufmann, and Torsten Schaub.
Conﬂict-driven answer
set solving: From theory to practice.
Artiﬁcial Intell., 187-188:52–89, 2012. DOI:
10.1016/j.artint.2012.04.001. 60
Allen Van Gelder. Foundations of aggregation in deductive databases. In Proc. 3rd Int. Conf.
on Deductive and Object-Oriented Databases, pages 13–34, 1993. DOI: 10.1007/3-540-57530-
8_2. 99
Michael Gelfond and Vladimir Lifschitz. e stable model semantics for logic programming. In
Proc. 5th Int. Conf. Logic Programming, pages 1070–1080, 1988. 41
Michael Gelfond and Vladimir Lifschitz. Classical negation in logic programs and disjunctive
databases. New Generation Comput., 9(3/4):365–386, 1991. DOI: 10.1007/BF03037169. 59
Fosca Giannotti and Dino Pedreschi. Datalog with non-deterministic choice computers ndb-
ptime. J. Logic Program., 35(1):79–101, 1998. DOI: 10.1016/S0743-1066(97)10004-8. 60
Fosca Giannotti, Dino Pedreschi, Domenico Saccà, and Carlo Zaniolo. Non-determinism in
deductive databases. In Proc. 2nd Int. Conf. on Deductive and Object-Oriented Databases, pages
129–146, 1991. DOI: 10.1007/3-540-55015-1_7. 47, 53, 54, 55, 60
Fosca Giannotti, Dino Pedreschi, and Carlo Zaniolo. Semantics and expressive power of nonde-
terministic constructs in deductive databases. J. Comp. and Syst. Sci., 62(1):15–42, 2001. DOI:
10.1006/jcss.1999.1699. 47, 50, 60
Georg Gottlob, Christoph Koch, Robert Baumgartner, Marcus Herzog, and Sergio Flesca. e
lixto data extraction project - back and forth between theory and practice. In Proc. 23rd ACM
SIGACT-SIGMOD-SIGART Symp. on Principles of Database Systems, pages 1–12, 2004. DOI:
10.1145/1055558.1055560. 129
Bernardo Cuenca Grau, Ian Horrocks, Markus Krötzsch, Clemens Kupke, Despoina Magka,
Boris Motik, and Zhe Wang.
Acyclicity notions for existential rules and their applica-
tion to query answering in ontologies.
J. Artiﬁcial Intell. Res., 47:741–808, 2013. DOI:
10.1613/jair.3949. 86
Gianluigi Greco, Sergio Greco, Irina Trubitsyna, and Ester Zumpano. Optimization of bound
disjunctive queries with constraints. eory & Practice of Logic Program., 5(6):713–745, 2005.
DOI: 10.1017/S1471068404002273. 127

BIBLIOGRAPHY
143
Sergio Greco.
Extending datalog with choice and weak constraints.
In Proc. Joint
Conf. on Declarative Programming, APPIA-GULP-PRODE, pages 329–340, 1996. DOI:
10.1007/BF03037430. 60
Sergio Greco. Non-determinism and weak constraints in datalog. New Generation Comput., 16
(4):373–396, 1998a. DOI: 10.1007/BF03037430. 60
Sergio Greco. Binding propagation in disjunctive databases. In Proc. 24th Int. Conf. on Very Large
Data Bases, pages 287–298, 1998b. DOI: 10.1109/TKDE.2003.1185840. 127
Sergio Greco. Dynamic programming in datalog with aggregates. IEEE Trans. Knowl. and Data
Eng., 11(2):265–283, 1999a. DOI: 10.1109/69.761663. 89, 90, 91, 97, 98
Sergio Greco. Optimization of disjunctive queries. In Proc. 16th Int. Conf. Logic Programming,
pages 441–455, 1999b. DOI: 10.1109/69.842265. 127
Sergio Greco.
Binding propagation techniques for the optimization of bound disjunc-
tive queries.
IEEE Trans. on Knowl. and Data Eng., 15(2):368–385, 2003. DOI:
10.1109/TKDE.2003.1185840. 127
Sergio Greco and Domenico Saccà.
e expressive power of ”possible-is-certain” semantics
(extended abstract). In Proc. Asian Computing Science Conference, pages 33–42, 1996. DOI:
10.1007/BFb0027777. 59
Sergio Greco and Domenico Saccà. Deterministic semantics for datalog:: Complexity and ex-
pressive power. In Proc. 5th Int. Conf. on Deductive and Object-Oriented Databases, pages 337–
350, 1997a. DOI: 10.1007/3-540-63792-3_24. 60
Sergio Greco and Domenico Saccà. “possible is certain” is desirable and can be expressive. Ann.
of Math. and Artiﬁcial Intell., 19(1-2):147–168, 1997b. DOI: 10.1023/A:1018903705269. 60
Sergio Greco and Domenico Saccà. Complexity and expressive power of deterministic semantics
for datalog:. Inform. and Comput., 153(1):81–98, 1999. DOI: 10.1006/inco.1999.2800. 60
Sergio Greco and Francesca Spezzano. Chase termination: A constraints rewriting approach.
Proc. VLDB Endowment, 3(1):93–104, 2010. DOI: 10.14778/1920841.1920858. 86
Sergio Greco and Carlo Zaniolo. Optimization of linear logic programs using counting methods.
In Advances in Database Technology, Proc. 3rd Int. Conf. on Extending Database Technology, pages
72–87, 1992. DOI: 10.1007/BFb0032424. 115, 126
Sergio Greco and Carlo Zaniolo. Eﬃcient execution of recursive queries through controlled
binding propagation. In Proc. 8th Int. Symposium on Methodologies for Intelligent Systems, pages
193–202, 1994. DOI: 10.1007/3-540-58495-1_20. 126

144
BIBLIOGRAPHY
Sergio Greco and Carlo Zaniolo. Greedy algorithms in datalog with choice and negation. In
Proc. 15th Int. Conf. Logic Programming, pages 294–309, 1998. 54, 57
Sergio Greco and Carlo Zaniolo. Greedy algorithms in datalog. eory & Practice of Logic Pro-
gram., 1(4):381–407, 2001. DOI: 10.1017/S1471068401001090. 48, 54
Sergio Greco, Carlo Zaniolo, and Sumit Ganguly.
Greedy by choice.
In Proc. 11th ACM
SIGACT-SIGMOD-SIGART Symp. on Principles of Database Systems, pages 105–113, 1992.
DOI: 10.1145/137097.137836. 54
Sergio Greco, Domenico Saccà, and Carlo Zaniolo. Datalog queries with stratiﬁed negation and
choice: from p to dp. In Proc. 5th Int. Conf. on Database eory, pages 82–96, 1995. DOI:
10.1007/3-540-58907-4_8. 60, 109
Sergio Greco, Carlo Zaniolo, and Sumit Ganguly. Optimization of logic queries with MIN and
MAX predicates. In Proc. 3rd Int. Conf. Flexible Query Answering Systems, pages 188–202,
1998. DOI: 10.1007/BFb0056001. 97
Sergio Greco, Domenico Saccà, and Carlo Zaniolo.
Grammars and automata to op-
timize chain logic queries.
Int. J. Found. Comput. Sci., 10(3):349–372, 1999. DOI:
10.1142/S0129054199000253. 109, 115, 116, 117, 119, 120, 124
Sergio Greco, Domenico Saccà, and Carlo Zaniolo.
Extending stratiﬁed datalog to capture
complexity classes ranging from p to qh.
Acta Informatica, 37(10):699–725, 2001. DOI:
10.1007/PL00013306. 60
Sergio Greco, Cristian Molinaro, and Irina Trubitsyna. Implementation and experimentation
of the logic language NP datalog. In Proc. 17th Int. Conf. on Database and Expert Systems
Applications, pages 622–633, 2006. DOI: 10.1007/11827405_61. 60
Sergio Greco, Cristian Molinaro, Irina Trubitsyna, and Ester Zumpano. NP datalog: A logic
language for expressing search and optimization problems. eory & Practice of Logic Program.,
10(2):125–166, 2010. DOI: 10.1017/S1471068409990251. 60
Sergio Greco, Francesca Spezzano, and Irina Trubitsyna. Stratiﬁcation criteria and rewriting
techniques for checking chase termination. Proc. VLDB Endowment, 4(11):1158–1168, 2011.
DOI: 10.1109/TKDE.2014.2339816. 86
Sergio Greco, Cristian Molinaro, and Francesca Spezzano. Incomplete Data and Data Dependen-
cies in Relational Databases. Synthesis Lectures on Data Management. Morgan & Claypool
Publishers, 2012a. DOI: 10.2200/S00435ED1V01Y201207DTM029. 12, 13, 86
Sergio Greco, Francesca Spezzano, and Irina Trubitsyna. On the termination of logic programs
with function symbols. In Proc. 28th Int. Conf. Logic Programming, pages 323–333, 2012b.
DOI: 10.4230/LIPIcs.ICLP.2012.323. 66, 68, 74, 86

BIBLIOGRAPHY
145
Sergio Greco, Cristian Molinaro, and Irina Trubitsyna. Bounded programs: A new decidable class
of logic programs with function symbols. In Proc. 23rd Int. Joint Conf. on AI, pages 926–932,
2013a. 70, 75, 86
Sergio Greco, Cristian Molinaro, and Irina Trubitsyna. Logic programming with function sym-
bols: Checking termination of bottom-up evaluation through program adornments. eory &
Practice of Logic Program., 13(4-5):737–752, 2013b. DOI: 10.1017/S147106841300046X. 76,
84
Todd J. Green, Shan Shan Huang, Boon au Loo, and Wenchao Zhou.
Datalog and
recursive query processing.
Found. and Trends in Databases, 5(2):105–195, 2013. DOI:
10.1561/1900000017. 126
Ramsey W. Haddad and Jeﬀrey F. Naughton. A counting algorithm for a cyclic binary query. J.
Comp. and System Sci., 43(1):145–169, 1991. DOI: 10.1016/0022-0000(91)90034-3. 110
John E. Hopcroft and Jeﬀrey D. Ullman. Introduction to Automata eory, Languages and Com-
putation. Addison-Wesley, 1979. 112, 115
Shan Shan Huang, Todd Jeﬀrey Green, and Boon au Loo. Datalog and emerging applications:
an interactive tutorial. In Proc. ACM SIGMOD Int. Conf. on Management of Data, pages 1213–
1216, 2011. DOI: 10.1145/1989323.1989456. 129
Yannis E. Ioannidis. Commutativity and its role in the processing of linear recursion. J. Logic
Program., 14(3&4):223–252, 1992. DOI: 10.1016/0743-1066(92)90012-R. 110
Yannis E. Ioannidis and Eugene Wong. Transforming nonlinear recursion into linear recursion.
In Expert Database Conf., pages 401–421, 1988. 110
David S. Johnson. A catalog of complexity classes. In Handbook of eoretical Computer Science,
Volume A: Algorithms and Complexity (A), pages 67–161. 1990. 14, 15
David B. Kemp and Kotagiri Ramamohanarao. Eﬃcient recursive aggregation and negation
in deductive databases.
IEEE Trans. Knowl. and Data Eng., 10(5):727–745, 1998. DOI:
10.1109/69.729729. 99
David B. Kemp and Peter J. Stuckey. Semantics of logic programs with aggregates. In Interna-
tional Symposium on Logic Programming, pages 387–401, 1991. 98
Michael Kifer, Raghu Ramakrishnan, and Abraham Silberschatz. An axiomatic approach to
deciding query safety in deductive databases. In Proc. 7th ACM SIGACT-SIGMOD-SIGART
Symp. on Principles of Database Systems, pages 52–60, 1988. DOI: 10.1145/308386.308412. 32
Phokion G. Kolaitis. e expressive power of stratiﬁed programs. Inform. and Comput., 90(1):
50–66, 1991. DOI: 10.1016/0890-5401(91)90059-B. 60

146
BIBLIOGRAPHY
Phokion G. Kolaitis and Christos H. Papadimitriou. Why not negation by ﬁxpoint? J. Comp.
and Syst. Sci., 43(1):125–144, 1991. DOI: 10.1016/0022-0000(91)90033-2. 43, 59
Phokion G. Kolaitis and Moshe Y. Vardi. On the expressive power of datalog: Tools and a case
study. J. Comp. and Syst. Sci., 51(1):110–134, 1995. DOI: 10.1006/jcss.1995.1055. 60
Robert Kowalski.
Logic for Problem-solving.
North-Holland Publishing Co., 1986. DOI:
10.1145/1005937.1005947. 32
Robert A. Kowalski. Predicate logic as programming language. In IFIP Congress, pages 569–574,
1974. 32
Ravi Krishnamurthy and Shamim A. Naqvi. Non-deterministic choice in datalog. In Proc. 3rd
International Conference on Data and Knowledge Bases, pages 416–424, 1988. 47, 60
Ravi Krishnamurthy, Raghu Ramakrishnan, and Oded Shmueli. A framework for testing safety
and eﬀective computability of extended datalog (extended abstract). In Proc. ACM SIGMOD
Int. Conf. on Management of Data, pages 154–163, 1988. DOI: 10.1145/971701.50219. 32
Markus Krötzsch and Sebastian Rudolph.
Extending decidable existential rules by joining
acyclicity and guardedness. In Proc. 22nd Int. Joint Conf. on AI, pages 963–968, 2011. DOI:
10.5591/978-1-57735-516-8/IJCAI11-166. 86
Bernard Lang. Datalog automata. In Proc. 3rd International Conference on Data and Knowledge
Bases, pages 389–404, 1988. 126
Maurizio Lenzerini. Data integration: A theoretical perspective. In Proc. 21st ACM SIGACT-
SIGMOD-SIGART Symp. on Principles of Database Systems, pages 233–246, 2002. DOI:
10.1145/543613.543644. 12
Nicola Leone, Gerald Pfeifer, Wolfgang Faber, omas Eiter, Georg Gottlob, Simona Perri, and
Francesco Scarcello. e dlv system for knowledge representation and reasoning. ACM Trans.
Comput. Log. DOI: 10.1145/1149114.1149117. 60
Yuliya Lierler and Vladimir Lifschitz. One more decidable class of ﬁnitely ground programs. In
International Conference on Logic Programming, pages 489–493, 2009. DOI: 10.1007/978-3-
642-02846-5_40. 66, 86
Vladimir Lifschitz. On the declarative semantics of logic programs with negation. In Foundations
of Deductive Databases and Logic Programming., pages 177–192. Morgan Kaufmann, 1988. 36
John W. Lloyd.
Foundations of Logic Programming, 2nd ed.
Springer-Verlag, 1987. DOI:
10.1007/978-3-642-83189-8. 15, 22
Jorge Lobo, Jack Minker, and Arcot Rajasekar. Foundations of Disjunctive Logic Programming.
Logic Programming. MIT Press, 1992. 60

BIBLIOGRAPHY
147
Boon au Loo, Tyson Condie, Joseph M. Hellerstein, Petros Maniatis, Timothy Roscoe, and
Ion Stoica. Implementing declarative overlays. In Proc. 20th ACM Symp. on Operating System
Principles, pages 75–90, 2005a. DOI: 10.1145/1095809.1095818. 129
Boon au Loo, Joseph M. Hellerstein, Ion Stoica, and Raghu Ramakrishnan. Declarative rout-
ing: extensible routing with declarative queries.
In Proc. 2005 Conf. on Applications, Tech-
nologies, Architectures, and Protocols for Computer Communication, pages 289–300, 2005b. DOI:
10.1145/1080091.1080126. 129
Boon au Loo, Tyson Condie, Minos N. Garofalakis, David E. Gay, Joseph M. Hellerstein,
Petros Maniatis, Raghu Ramakrishnan, Timothy Roscoe, and Ion Stoica. Declarative network-
ing: language, execution and optimization. In Proc. ACM SIGMOD Int. Conf. on Management
of Data, 2006. DOI: 10.1145/1142473.1142485. 129, 130
David Maier. e eory of Relational Databases. Computer Science Press, 1983. 15
Alberto Marchetti-Spaccamela, Antonella Pelaggi, and Domenico Saccà. Comparison of meth-
ods for logic-query implementation.
J. Logic Program., 10(3&4):333–360, 1991. DOI:
10.1016/0743-1066(91)90040-V. 110
Massimo Marchiori. Proving existential termination of normal logic programs. In Algebraic
Methodology and Software Technology, pages 375–390, 1996. DOI: 10.1007/BFb0014328. 86
William R. Marczak, Shan Shan Huang, Martin Bravenboer, Micah Sherr, Boon au Loo, and
Molham Aref. Secureblox: customizable secure distributed data processing. In Proc. ACM
SIGMOD Int. Conf. on Management of Data, 2010. DOI: 10.1145/1807167.1807246. 129,
130
V. Wiktor Marek and Miroslaw Truszczynski. Autoepistemic logic. J. ACM, 38(3):588–619,
1991. DOI: 10.1145/116825.116836. 43, 54
Bruno Marnette.
Generalized schema-mappings: from termination to tractability.
In Proc.
28th ACM SIGACT-SIGMOD-SIGART Symp. on Principles of Database Systems, pages 13–22,
2009a. DOI: 10.1145/1559795.1559799. 87
Bruno Marnette.
Generalized schema-mappings: from termination to tractability.
In Proc.
28th ACM SIGACT-SIGMOD-SIGART Symp. on Principles of Database Systems, pages 13–22,
2009b. DOI: 10.1145/1559795.1559799. 86
Mirjana Mazuran, Edoardo Serra, and Carlo Zaniolo. A declarative extension of horn clauses,
and its signiﬁcance for datalog and its applications. eory & Practice of Logic Program., 13
(4-5):609–623, 2013. DOI: 10.1017/S1471068413000380. 60
Michael Meier. On the Termination of the Chase Algorithm. Albert-Ludwigs-Universitat Freiburg
(Germany), 2010. 87

148
BIBLIOGRAPHY
Michael Meier, Michael Schmidt, and Georg Lausen. On chase termination beyond stratiﬁca-
tion. Proc. VLDB Endowment, 2(1):970–981, 2009. DOI: 10.14778/1687627.1687737. 86
Jack Minker, editor. Foundations of Deductive Databases and Logic Programming. Morgan Kauf-
mann, 1988. 32
Jack Minker. Overview of disjunctive logic programming. Ann. of Math. and Artiﬁcial Intell., 12
(1-2):1–24, 1994. DOI: 10.1007/BF01530759. 60
Jack Minker and Dietmar Seipel. Disjunctive logic programming: A survey and assessment. In
Computational Logic: Logic Programming and Beyond, Essays in Honour of Robert A. Kowalski,
Part I, pages 472–511, 2002. DOI: 10.1007/3-540-45628-7_18. 60
Jack Minker, Dietmar Seipel, and Carlo Zaniolo. Logic and databases: A history of deductive
databases. In Computational Logic, pages 571–627. 2014. DOI: 10.1016/B978-0-444-51624-
4.50013-7. 32
Inderpal Singh Mumick and Oded Shmueli. How expressive is statiﬁed aggregation? Ann. of
Math. and Artiﬁcial Intell., 15(3-4):407–434, 1995. DOI: 10.1007/BF01536403. 99
Inderpal Singh Mumick, Hamid Pirahesh, and Raghu Ramakrishnan. e magic of duplicates
and aggregates. In Proc. 16th Int. Conf. on Very Large Data Bases, pages 264–277, 1990. 90, 98
Shamim A. Naqvi and Shalom Tsur. A Logical Language for Data and Knowledge Bases. Computer
Science Press, 1989. 47
Jeﬀrey F. Naughton, Raghu Ramakrishnan, Yehoshua Sagiv, and Jeﬀrey D. Ullman. Argument
reduction by factoring. In Proc. 15th Int. Conf. on Very Large Data Bases, pages 173–182, 1989a.
DOI: 10.1016/0304-3975(94)00186-M. 110, 126
Jeﬀrey F. Naughton, Raghu Ramakrishnan, Yehoshua Sagiv, and Jeﬀrey D. Ullman. Eﬃcient
evaluation of right-, left-, and mult-linear rules. In Proc. ACM SIGMOD Int. Conf. on Man-
agement of Data, pages 235–242, 1989b. DOI: 10.1145/66926.66948. 109, 110, 126
Manh ang Nguyen, Jürgen Giesl, Peter Schneider-Kamp, and Danny De Schreye. Termination
analysis of logic programs based on dependency graphs. In Proc. International Symposium on
Logic-based Program Synthesis and Transformation, pages 8–22, 2007. DOI: 10.1007/978-3-
540-78769-3_2. 86
Naoki Nishida and Germán Vidal. Termination of narrowing via termination of rewriting. Applic.
Algebra in Eng., Commun. and Comput., 21(3):177–225, 2010. DOI: 10.1007/s00200-010-
0122-4. 86
Enno Ohlebusch. Termination of logic programs: Transformational methods revisited. Applic. Al-
gebra in Eng., Communic. and Comput., 12(1/2):73–116, 2001. DOI: 10.1007/s002000100064.
86

BIBLIOGRAPHY
149
Adrian Onet. e chase procedure and its applications in data exchange. In Data Exchange,
Integration, and Streams, pages 1–37. 2013. DOI: 10.4230/DFU.Vol5.10452.1. 87
Mauricio Osorio and Bharat Jayaraman. Aggregation and negation-as-failure. New Generation
Comput., 17(3):255–284, 1999. DOI: 10.1007/BF03037222. 99
Robert Paige and Jacob T. Schwartz. Reduction in strength of high level operations. In Proc. 4th
ACM SIGACT-SIGPLAN Symp. on Principles of Programming Languages, pages 58–71, 1977.
32
Luigi Palopoli. Testing logic programs for local stratiﬁcation. eor. Comp. Sci., 103(2):205–234,
1992. DOI: 10.1016/0304-3975(92)90013-6. 60
Christos H. Papadimitriou. Computational Complexity. Addison-Wesley, 1994. ISBN 978-0-
201-53082-7. 14, 15
Christos H. Papadimitriou and Kenneth Steiglitz. Combinatorial Optimization: Algorithms and
Complexity. Prentice-Hall, 1982. 57
Nikolay Pelov, Marc Denecker, and Maurice Bruynooghe. Well-founded and stable semantics
of logic programs with aggregates. eory & Practice of Logic Program., 7(3):301–353, 2007.
DOI: 10.1017/S1471068406002973. 99
Fernando C. N. Pereira and David H. D. Warren. Deﬁnite clause grammars for language analysis
- a survey of the formalism and a comparison with augmented transition networks. Artiﬁcial
Intell., 13(3):231–278, 1980. DOI: 10.1016/0004-3702(80)90003-X. 126
Halina Przymusinska and Teodor C. Przymusinski. Weakly perfect model semantics for logic
programs. In Proc. 5th Int. Conf. Logic Programming, pages 1106–1120, 1988. 59
Teodor C. Przymusinski. On the declarative semantics of deductive databases and logic pro-
grams. In Foundations of Deductive Databases and Logic Programming, pages 193–216. Morgan
Kaufmann, 1988. 39, 41, 59
Teodor C. Przymusinski. On the declarative and procedural semantics of logic programs. J.
Autom. Reasoning, 5(2):167–205, 1989. DOI: 10.1007/BF00243002. 41
Teodor C. Przymusinski. Stable semantics for disjunctive programs. New Generation Comput., 9
(3/4):401–424, 1991. DOI: 10.1007/BF03037171. 59
Raghu Ramakrishnan and Johannes Gehrke. Database Management Systems (3rd ed.). McGraw-
Hill, 2003. 15
Raghu Ramakrishnan, François Bancilhon, and Abraham Silberschatz. Safety of recursive horn
clauses with inﬁnite relations. In Proc. 6th ACM SIGACT-SIGMOD-SIGART Symp. on Prin-
ciples of Database Systems, pages 328–339, 1987. DOI: 10.1145/28659.28694. 32

150
BIBLIOGRAPHY
Raghu Ramakrishnan, Yehoshua Sagiv, Jeﬀrey D. Ullman, and Moshe Y. Vardi. Proof-tree trans-
formation theorems and their applications. In Proc. 8th ACM SIGACT-SIGMOD-SIGART
Symp. on Principles of Database Systems, pages 172–181, 1989. DOI: 10.1145/73721.73739.
126
Raghu Ramakrishnan, Divesh Srivastava, and S. Sudarshan. CORAL - control, relations and
logic. In Proc. 18th Int. Conf. on Very Large Data Bases, pages 238–250, 1992. 99
Raghu Ramakrishnan, Kenneth A. Ross, Divesh Srivastava, and S. Sudarshan. Eﬃcient incre-
mental evaluation of queries with aggregation. In International Symposium on Logic Program-
ming, pages 204–218, 1994. 99
Fabrizio Riguzzi and Terrance Swift. Terminating evaluation of logic programs with ﬁnite three-
valued models. ACM Trans. Comput. Log., 15(4):32:1–32:38, 2014. DOI: 10.1145/2629337.
86
John Alan Robinson. A machine-oriented logic based on the resolution principle. J. ACM, 12
(1):23–41, 1965. DOI: 10.1145/321250.321253. 32
Kenneth A. Ross. Modular stratiﬁcation and magic sets for datalog programs with negation. J.
ACM, 41(6):1216–1266, 1994. DOI: 10.1145/195613.195646. 126
Kenneth A. Ross and Yehoshua Sagiv. Monotonic aggregation in deductive database. J. Comp.
and System Sci., 54(1):79–97, 1997. DOI: 10.1006/jcss.1997.1453. 99
Domenico Saccà. Deterministic and non-deterministic stable model semantics for unbound dat-
alog queries. In Proc. 5th Int. Conf. on Database eory, pages 353–367, 1995. DOI: 10.1007/3-
540-58907-4_27. 59
Domenico Saccà. e expressive powers of stable models for bound and unbound datalog queries.
J. Comp. and System Sci., 54(3):441–464, 1997. DOI: 10.1006/jcss.1997.1446. 60
Domenico Saccà and Carlo Zaniolo. On the implementation of a simple class of logic queries
for databases. In Proc. 5th ACM SIGACT-SIGMOD Symp. on Principles of Database Systems,
pages 16–23, 1986. DOI: 10.1145/6012.6013. 125
Domenico Saccà and Carlo Zaniolo. Magic counting methods. In Proc. ACM SIGMOD Int.
Conf. on Management of Data, pages 49–59, 1987. DOI: 10.1145/38714.38725. 110
Domenico Saccà and Carlo Zaniolo. e generalized counting method for recursive logic queries.
eor. Comp. Sci., 62(1-2):187–220, 1988. DOI: 10.1007/3-540-17187-8_28. 110, 121
Domenico Saccà and Carlo Zaniolo. Stable models and non-determinism in logic programs
with negation. In Proc. 9th ACM SIGACT-SIGMOD-SIGART Symp. on Principles of Database
Systems, pages 205–217, 1990. DOI: 10.1145/298514.298572. 47

BIBLIOGRAPHY
151
Domenico Saccà and Carlo Zaniolo. Partial models and three-valued models in logic programs
with negation. In Proc. 1st Int. Conf. Logic Programming and Nonmonotonic Reasoning, pages
87–101, 1991. 59
Domenico Saccà and Carlo Zaniolo. Deterministic and non-deterministic stable models. J. of
Logic and Comput., 7(5):555–579, 1997. DOI: 10.1093/logcom/7.5.555. 59
Yehoshua Sagiv and Moshe Y. Vardi. Safety of datalog queries over inﬁnite databases. In Proc.
8th ACM SIGACT-SIGMOD-SIGART Symp. on Principles of Database Systems, pages 160–171,
1989. DOI: 10.1145/73721.73738. 32
Yatin P. Saraiya.
Linearizing nonlinear recursions in polynomial time.
In Proc. 8th ACM
SIGACT-SIGMOD-SIGART Symp. on Principles of Database Systems, pages 182–189, 1989.
DOI: 10.1145/73721.73740. 110
John S. Schlipf. e expressive powers of the logic programming semantics. J. Comp. and Syst.
Sci., 51(1):64–86, 1995. DOI: 10.1006/jcss.1995.1053. 43, 59
Peter Schneider-Kamp, Jürgen Giesl, and Manh ang Nguyen. e dependency triple frame-
work for termination of logic programs. In Proc. International Symposium on Logic-based Pro-
gram Synthesis and Transformation, pages 37–51, 2009a. DOI: 10.1007/978-3-642-12592-8_4.
86
Peter Schneider-Kamp, Jürgen Giesl, Alexander Serebrenik, and René iemann. Automated
termination proofs for logic programs by term rewriting. ACM Trans. Comput. Log., 11(1),
2009b. DOI: 10.1145/1614431.1614433. 86
Peter Schneider-Kamp, Jürgen Giesl, omas Ströder, Alexander Serebrenik, and René ie-
mann. Automated termination analysis for logic programs with cut. eory & Practice of Logic
Program., 10(4-6):365–381, 2010. DOI: 10.1017/S1471068410000165. 86
Jiwon Seo, Stephen Guo, and Monica S. Lam.
Socialite: Datalog extensions for eﬃ-
cient social network analysis.
In Proc. 29th Int. Conf. on Data Engineering, 2013. DOI:
10.1109/ICDE.2013.6544832. 129
Alexander Serebrenik and Danny De Schreye. On termination of meta-programs. eory &
Practice of Logic Program., 5(3):355–390, 2005. DOI: 10.1017/S1471068404002248. 86
Warren Shen, AnHai Doan, Jeﬀrey F. Naughton, and Raghu Ramakrishnan. Declarative infor-
mation extraction using datalog with embedded extraction predicates. In Proc. 33rd Int. Conf.
on Very Large Data Bases, pages 1033–1044, 2007. 129
Alexander Shkapsky, Mohan Yang, and Carlo Zaniolo. Optimizing recursive queries with mono-
tonic aggregates in deals. In Proc. 31st Int. Conf. on Data Engineering, pages 867–878, 2015.
DOI: 10.1007/BFb0056001. 60

152
BIBLIOGRAPHY
Abraham Silberschatz, Henry F. Korth, and S. Sudarshan. Database System Concepts, 6th ed.
McGraw-Hill Book Company, 2010. 15
Patrik Simons, Ilkka Niemelä, and Timo Soininen.
Extending and implementing the sta-
ble model semantics.
Artiﬁcial Intell., 138(1-2):181–234, 2002. DOI: 10.1016/S0004-
3702(02)00187-X. 60
Christian Sternagel and Aart Middeldorp. Root-labeling. In Rewriting Techniques and Applica-
tions, pages 336–350, 2008. DOI: 10.1007/978-3-540-70590-1_23. 86
S. Sudarshan and Raghu Ramakrishnan.
Aggregation and relevance in deductive
databases.
In Proc. 17th Int. Conf. on Very Large Data Bases, pages 501–511, 1991. DOI:
10.1006/jcss.1997.1453. 99
Tommi Syrjänen. Omega-restricted logic programs. In Proc. 6th Int. Conf. Logic Programming
and Nonmonotonic Reasoning, pages 267–279, 2001. DOI: 10.1007/3-540-45402-0_20. 86
Daniel Troy, Clement T. Yu, and Weining Zhang. Linearization of nonlinear recursive rules.
IEEE Trans. Software Eng., 15(9):1109–1119, 1989. DOI: 10.1109/32.31368. 110
Jeﬀrey D. Ullman. Principles of Database and Knowledge-Base Systems, Volume I. Computer Sci-
ence Press, 1988. 11, 15, 26, 32
Jeﬀrey D. Ullman. Principles of Database and Knowledge-Base Systems, Volume II. Computer
Science Press, 1989. 110, 126
Jeﬀrey D. Ullman. e interface between language theory and database theory. In eoretical
Studies in Computer Science, pages 133–151, 1992. 112, 126
Jeﬀrey D. Ullman and Allen Van Gelder. Parallel complexity of logical query programs. In
Proc. 27th Annual Symp. on Foundations of Computer Science, pages 438–454, 1986. DOI:
10.1109/SFCS.1986.40. 126
Maarten H. van Emden and Robert A. Kowalski. e semantics of predicate logic as a program-
ming language. J. ACM, 23(4):733–742, 1976. DOI: 10.1145/321978.321991. 32
Allen Van Gelder. Negation as failure using tight derivations for general logic programs. J. Logic
Program., 6(1&2):109–133, 1989. DOI: 10.1016/0743-1066(89)90032-0. 36
Allen Van Gelder. e well-founded semantics of aggregation. In Proc. 11th ACM SIGACT-
SIGMOD-SIGART Symp. on Principles of Database Systems, pages 127–138, 1992. DOI:
10.1145/137097.137854. 99
Allen Van Gelder, Kenneth A. Ross, and John S. Schlipf. Unfounded sets and well-founded
semantics for general logic programs. In Proc. 7th ACM SIGACT-SIGMOD-SIGART Symp.
on Principles of Database Systems, pages 221–230, 1988. DOI: 10.1145/308386.308444. 43

BIBLIOGRAPHY
153
Allen Van Gelder, Kenneth A. Ross, and John S. Schlipf. e well-founded semantics for general
logic programs. J. ACM, 38(3):620–650, 1991. DOI: 10.1145/116825.116838. 43, 45, 46, 47
Soﬁe Verbaeten, Danny De Schreye, and Konstantinos F. Sagonas.
Termination proofs
for logic programs with tabling.
ACM Trans. Comput. Log., 2(1):57–92, 2001. DOI:
10.1145/371282.371357. 86
Laurent Vieille. Recursive query processing: e power of logic. eor. Comp. Sci., 69(1):1–53,
1989. DOI: 10.1016/0304-3975(89)90088-1. 126
Dean Voets and Danny De Schreye.
Non-termination analysis of logic programs with in-
teger arithmetics.
eory & Practice of Logic Program., 11(4-5):521–536, 2011. DOI:
10.1017/S1471068411000159. 86
Peter T. Wood. Factoring augmented regular chain programs. In Proc. 16th Int. Conf. on Very
Large Data Bases, pages 255–263, 1990. 109, 110
Mihalis Yannakakis. Graph-theoretic methods in database theory. In Proc. 9th ACM SIGACT-
SIGMOD-SIGART Symp. on Principles of Database Systems, pages 230–242, 1990. DOI:
10.1145/298514.298576. 110, 126
Jia-Huai You and Li-Yan Yuan. On the equivalence of semantics for normal logic programs. J.
Logic Program., 22(3):211–222, 1995. DOI: 10.1016/0743-1066(94)00023-Y. 59
Carlo Zaniolo.
Safety and compilation of non-recursive horn clauses.
In Proc. 1st Inter-
national Conference on Expert Database Systems, pages 237–252, 1986. DOI: 10.1016/0304-
3975(86)90015-0. 32
Hans Zantema. Termination of term rewriting: Interpretation and type elimination. J. of Symbol.
Comput., 17(1):23–50, 1994. DOI: 10.1006/jsco.1994.1003. 86
Hans Zantema. Termination of term rewriting by semantic labelling. Fundamenta Informaticae,
24(1/2):89–105, 1995. DOI: 10.3233/FI-1995-24124. 86
Wenchao Zhou, Yun Mao, Boon au Loo, and Martín Abadi. Uniﬁed declarative platform
for secure netwoked information systems. In Proc. 25th Int. Conf. on Data Engineering, pages
150–161, 2009. DOI: 10.1109/ICDE.2009.58. 129, 130


155
Authors’ Biographies
SERGIO GRECO
Sergio Greco is a Full Professor and Chair of the DIMES Department at the University of Cal-
abria (Italy). Before that he was Assistant Professor (1989-1998) and Associate Professor (1998-
2000) at the University of Calabria and visiting researcher at the Microelectronics and Computer
Corporation of Austin (1990-1991) and at the of University of California at Los Angeles (1996
and 1998). Prof. Greco’s research interests include database theory, data integration, inconsistent
data, data mining, knowledge representation, logic programming, and computational logic.
CRISTIAN MOLINARO
Cristian Molinaro received his Ph.D. degree in Computer Science Engineering from the Uni-
versity of Calabria, Italy. He was a Visiting Scholar at the Department of Computer Science and
Engineering of the State University of New York at Buﬀalo. He was a Faculty Research Assistant
at the University of Maryland Institute for Advanced Computer Studies (2009-2011). Currently,
he is an Assistant Professor at the University of Calabria, Italy. His research interests include
database theory and logic programming.

