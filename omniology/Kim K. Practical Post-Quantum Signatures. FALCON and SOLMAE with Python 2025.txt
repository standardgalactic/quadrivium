SpringerBriefs in 
Information Security and Cryptography
Kwangjo¬†Kim
Practical Post-Quantum 
Signatures
FALCON and SOLMAE 
with¬†Python

SpringerBriefs in Information Security 
and Cryptography 
Editor-in-Chief 
Yang Xiang, Swinburne University of Technology, Melbourne, Australia 
Series Editors 
Liqun Chen 
, Department of Computer Science, University of Surrey, Guildford, 
UK 
Kim-Kwang Raymond Choo 
, Department of Information Systems, The Univer-
sity of Texas at San Antonio, San Antonio, USA 
Sherman S. M. Chow 
, Chinese University of Hong Kong, Hong Kong, Hong 
Kong 
Robert H. Deng 
, Singapore Management University, Singapore, Singapore 
Dieter Gollmann, FB 4-14, TU Hamburg-Harburg, Hamburg, Germany 
Kuan-Ching Li, Department of Computer Science and Information Engineering, 
Providence University, Taichung, Taiwan 
Javier Lopez, University of Malaga, Malaga, Spain 
Kui Ren, University at Buffalo, Buffalo, USA 
Jianying Zhou 
, Singapore University of Technology and Design (SUTD), 
Singapore, Singapore

The series aims to develop and disseminate an understanding of innovations, 
paradigms, techniques, and technologies in the contexts of information and cyber-
security systems, as well as developments in cryptography and related studies. 
It publishes concise, thorough and cohesive overviews of state-of-the-art topics in 
these Ô¨Åelds, as well as in-depth case studies. The series also provides a single point 
of coverage of advanced and timely, emerging topics and offers a forum for core 
concepts that may not have reached a level of maturity to warrant a comprehensive 
monograph or textbook. 
It addresses security, privacy, availability, and dependability issues, also welcom-
ing emerging technologies such as artiÔ¨Åcial intelligence, cloud computing, cyber 
physical systems, and big data analytics related to cybersecurity research. Among 
some core research topics: 
Fundamentals and theories 
‚Ä¢ 
Cryptography for cybersecurity 
‚Ä¢ 
Theories of cybersecurity 
‚Ä¢ 
Provable security 
Cyber Systems and Secure Networks 
‚Ä¢ 
Cyber systems security 
‚Ä¢ 
Network security 
‚Ä¢ 
Security services 
‚Ä¢ 
Social networks security and privacy 
‚Ä¢ 
Cyber attacks and defense 
‚Ä¢ 
Data-driven cyber security 
‚Ä¢ 
Trusted computing and systems 
Applications and others 
‚Ä¢ 
Hardware and device security 
‚Ä¢ 
Cyber application security 
‚Ä¢ 
Human and social aspects of cybersecurity

Kwangjo Kim 
Practical Post-Quantum 
Signatures 
FALCON and SOLMAE with Python

Kwangjo Kim 
School of Computing 
KAIST(Korea Advanced Institute for 
Science and Technology) /IRCS 
(International Research institute for Cyber 
Security) 
Daejeon, Korea (Republic of) 
ISSN 2731-9555
ISSN 2731-9563 
(electronic) 
SpringerBriefs in Information Security and Cryptography 
ISBN 978-3-031-81249-1
ISBN 978-3-031-81250-7 
(eBook) 
https://doi.org/10.1007/978-3-031-81250-7 
¬© The Editor(s) (if applicable) and The Author(s), under exclusive license to Springer Nature Switzerland 
AG 2025 
This work is subject to copyright. All rights are solely and exclusively licensed by the Publisher, whether 
the whole or part of the material is concerned, speciÔ¨Åcally the rights of reprinting, reuse of illustrations, 
recitation, broadcasting, reproduction on microÔ¨Ålms or in any other physical way, and transmission or 
information storage and retrieval, electronic adaptation, computer software, or by similar or dissimilar 
methodology now known or hereafter developed. 
The use of general descriptive names, registered names, trademarks, service marks, etc. in this publication 
does not imply, even in the absence of a speciÔ¨Åc statement, that such names are exempt from the relevant 
protective laws and regulations and therefore free for general use. 
The publisher, the authors and the editors are safe to assume that the advice and information in this book 
are believed to be true and accurate at the date of publication. Neither the publisher nor the authors or 
the editors give a warranty, expressed or implied, with respect to the material contained herein or for any 
errors or omissions that may have been made. The publisher remains neutral with regard to jurisdictional 
claims in published maps and institutional afÔ¨Åliations. 
This Springer imprint is published by the registered company Springer Nature Switzerland AG 
The registered company address is: Gewerbestrasse 11, 6330 Cham, Switzerland 
If disposing of this product, please recycle the paper.

Preface 
The current digital signature methods, such as RSA (Rivest-Shamir-Adleman), 
DSA (Digital Signature Algorithm), and ECDSA (Elliptic Curve Digital Signature 
Algorithm), are relatively straightforward in terms of mathematical understanding. 
While the signing and veriÔ¨Åcation processes differ depending on the key used, 
the time required for these operations is nearly the same across these algorithms. 
However, in the era of quantum computing, cryptographic methods must defend 
against both current classical and future quantum attacks. Achieving this requires 
a deeper understanding of algebraic geometry, lattice theory, Gaussian sampling, 
and efÔ¨Åcient polynomial computation techniques like FFT (Fast Fourier Transform) 
and NTT (Number Theoretic Transform), which are crucial for most lattice-based 
cryptosystems. 
The FALCON algorithm, selected as a Ô¨Ånalist in the NIST (National Institute 
of Standards and Technology) Post-Quantum Cryptography (PQC) standardization 
project after seven years of global evaluation, is a hash-and-sign digital signature 
scheme based on the NTRU (N-th degree TRUncated polynomial) lattice problem, 
within the GPV framework. Compared to other quantum-resistant signatures like 
DILITHIUM and SPHINCS+, FALCON offers a signiÔ¨Åcantly smaller combined size 
for its public key and signature. 
Following FALCON‚Äôs release, the SOLMAE algorithm was introduced in 2021. 
Like FALCON, SOLMAE is another hash-and-sign scheme that operates within 
the GPV (Genry Peikert Vaikuntanathan) framework but simpliÔ¨Åes FALCON‚Äôs 
complex signing process. Both FALCON and SOLMAE have been implemented 
in Python, making them easier to understand and work with compared to other low-
level programming languages. To enhance understanding of their functionality, we 
developed Python scripts that examine each algorithm step-by-step, breaking down 
the results and the underlying mathematical concepts. 
This monograph serves as an introductory or educational textbook for undergrad-
uate and graduate students, practitioners, engineers, and anyone interested in post-
quantum digital signatures. The material aims to present complex cryptographic 
concepts in an accessible manner. 
This monograph highlights:
v

vi
Preface
‚Ä¢ 
Clarity and Focus: The title clearly indicates that the book is about post-
quantum signatures, which is a critical and timely topic in the Ô¨Åeld of modern 
cryptography. 
‚Ä¢ 
Practical Approach: The word Practical suggests that the book will focus 
on hands-on, applicable knowledge, which is appealing to readers looking to 
implement these cryptographic techniques. 
‚Ä¢ 
SpeciÔ¨Åc Algorithms: Mentioning FALCON and SOLMAE directly in the title 
highlights the speciÔ¨Åc post-quantum signature schemes covered, attracting read-
ers who are speciÔ¨Åcally interested in these algorithms. 
‚Ä¢ 
Programming Language: Including with Python informs readers that the book 
will provide implementation examples or exercises using Python, which is a 
popular language for such purposes. 
YongIn, Republic of Korea
Kwangjo Kim 
December 2024 

Acknowledgments 
The author expresses his sincere gratitude to the volunteer group who designed 
the initial version of SOLMAE. This group includes Mehdi Tibouchi, Alexandre 
Wallet, Thomas Espitau, Akira Takahashi, and Yang Yu. The author is also grateful 
to Seungki Kim and YeonJun Kim for their contributions to preparing the revised 
speciÔ¨Åcation of SOLMAE. 
I would like to express my gratitude to my high school friends who accompanied 
me and helped inspire the concept for this monograph in part while trekking Mont 
Blanc for a week, starting in Chamonix, France, in August 2014. 
I dedicate this monograph to my late parents, whose love and sacriÔ¨Åces laid the 
foundation for my strength and resilience. Thanks to my wife, Nami Jang and my 
family for their strong support. On the hill overlooking Seoksung Mt. in Yongin.
vii

Contents 
1 
Introduction ................................................................... 
1 
2 
Notations and DeÔ¨Ånition ..................................................... 
5 
3 
FALCON Algorithm .......................................................... 
11 
4 
SOLMAE Algorithm ......................................................... 
19 
5 
Basics of Python ............................................................... 
27 
6 
Checking FALCON with Python ............................................ 
31 
7 
Checking SOLMAE with Python ........................................... 
61 
8 
Concluding Remarks ......................................................... 
79 
References.......................................................................... 
81 
Index................................................................................ 
85
ix

About the Author 
Kwangjo Kim received his B.Sc. and M.Sc. degrees in Electronic Engineering 
from Yonsei University, Korea, in 1980 and 1983, respectively, and his Ph.D. 
from the Division of Electrical and Computer Engineering, Yokohama National 
University, Japan, in 1991. From 1979 to 1997, he worked at the Electronics and 
Telecommunications Research Institute (ETRI), serving as the Head of Coding 
Section I. He has held various prestigious visiting positions, including Visiting 
Professor roles at the Massachusetts Institute of Technology (MIT), the University 
of California at San Diego (UCSD) in 2005, the Khalifa University of Science, 
Technology, and Research (KUSTAR), UAE, in 2012, and the Bandung Institute 
of Technology (ITB), Indonesia, in 2013. After retiring in August 2021 from the 
Korea Advanced Institute of Science and Technology (KAIST), Korea, where he 
had worked since 1998, Professor Kim has been serving as the President of the 
International Research Institute for Cyber Security (IRCS, https://ircs.re.kr), a non-
proÔ¨Åt organization approved by the Korean government. He is also an Emeritus 
Professor at the School of Computing and the Graduate School of Information 
Security at KAIST and the Honorary President of the Korea Institute of Infor-
mation Security and Cryptography (KIISC). Professor Kim has made signiÔ¨Åcant 
contributions to the Ô¨Åeld of cryptography. He served as a Board Member of the 
International Association for Cryptologic Research (IACR) from 2000 to 2004 and 
as Chairperson of the Asiacrypt Steering Committee from 2005 to 2008. He served 
as the President of KIISC in 2009 and the Korean representative to IFIP TC-11 from 
2017 to 2021. Recently he was appointed as Adjunct Faculty in the Department of 
Electrical and Computer Engineering at Cleveland State University for the Ô¨Åscal 
years 2025 through 2028. 
He was honored as the Ô¨Årst Korean Fellow of the IACR for his contributions 
to cryptographic design, education, and leadership, and for his exemplary service 
to the IACR and the Asia-PaciÔ¨Åc cryptographic community. In addition to his 
leadership roles, Professor Kim served as General Chair for Asiacrypt 2020 (online) 
and PQCrypto 2021 (hybrid), both held in Daejeon, Korea, including CHES2014 in 
Busan, Korea, and Asiacrypt2004, Jeju Island, Korea, etc.
xi

xii
About the Author
He coauthored with M.E. Aminanto, and H.C.Tanuwidjaja, Network Intrusion 
Detection using Deep Learning ‚Äì A Feature Learning Approach in 2018 and with 
H.C. Tanuwidjaja Privacy-Preserving Deep Learning ‚Äì A Comprehensive Survey in 
2021, both published by Springer Briefs on Cyber Security Systems and Networks. 
He was recognized as one of the World‚Äôs Top 2% Scientists by Stanford 
University in 2023 and a key Ô¨Ågure in the implementation of SOLMAE in Python, 
a quantum-secure signature scheme that is faster and more efÔ¨Åcient than FALCON, 
which was selected as a FIPS standard by NIST in 2021. Professor Kim has an 
H-index of 48 with 10,295 citations according to Google Scholar in 2024, and his 
most cited paper is ‚ÄúID-based blind signature and ring signature from pairings,‚Äù 
coauthored with F. Zhang and presented at Asiacrypt 2002, which has been cited 
814 times. 
Professor Kim‚Äôs current research interests include cryptologic theory and prac-
tice, cybersecurity, and their applications, holding 10 international patents and 20 
domestic patents. 
For more details, please visit: https://caislab.kaist.ac.kr/kkj.

Acronyms 
CRYSTALS 
CRYptographic SuiTe for Algebraic Lattices 
DH
DifÔ¨Åe Hellmam 
DS
Digital Signature 
DSA
Digital Signature Algorithm 
ECDSA
Elliptic Curve Digital Signature Algorithm 
FALCON
FAst Fourier Lattice-based COmpact signatures over NTRU 
FFT
Fast Fourier Transform 
FIPS
Federal Information Processing Standard 
GPV
Gentry Peikert Vaikuntanathan 
GSO
Gram Schmidt Orthogonalization 
KAT
Known Answer Test 
KEM
Key Encapsulation Mechanism 
NIST
National Institute of Standards and Technology 
NTRU
Number Theory aRe Us or N-th degree TRUncated polynomial 
NTT
Number Theoretic Transform 
PQC
Post-Quantum Cryptography 
RSA
Rivest Shamir Adelmann 
SAGA
Statistically Acceptable GAussians 
SOLMAE
Secure algOrithm for Long-term Message Authentication and 
Encryption
xiii

List of Algorithms 
1 
KeyGen of FALCON .......................................................... 
13 
2 
Sign of FALCON ............................................................. 
15 
3 
Compress ..................................................................... 
16 
4 
Decompress ................................................................... 
16 
5 
Verif of FALCON ........................................................... 
17 
6 
KeyGen of SOLMAE ......................................................... 
22 
7 
Sign of SOLMAE ............................................................ 
24 
8 
Verif of SOLMAE ........................................................... 
25
xv

List of Figures 
Fig. 3.1 
Genealogic tree of FALCON ......................................... 
12 
Fig. 3.2 
Flowchart of KeyGen for FALCON .................................. 
13 
Fig. 3.3 
Flowchart of Sign for FALCON ..................................... 
15 
Fig. 4.1 
Overview of SOLMAE ............................................... 
20 
Fig. 4.2 
Flowchart of KeyGen for SOLMAE .................................. 
21 
Fig. 4.3 
Flowchart of Sign for SOLMAE .................................... 
23 
Fig. 5.1 
Screen capture of Visual Studio Code ................................ 
29 
Fig. 5.2 
Installed packages in my PC environment ........................... 
30 
Fig. 6.1 
Output of test_split_and_merge() .............................. 
34 
Fig. 6.2 
phi16_roots used in Script 6.3 for FFT ............................ 
35 
Fig. 6.3 
Output of checking ftt.py .......................................... 
37 
Fig. 6.4 
phi16_roots used in Script 6.6 for NTT ........................... 
39 
Fig. 6.5 
Output of checking ntt.py .......................................... 
39 
Fig. 6.6 
Output of checking ntrugen.py ..................................... 
40 
Fig. 6.7 
Output of six test cases ............................................... 
42 
Fig. 6.8 
Description of parameters ............................................ 
43 
Fig. 6.9 
SpeciÔ¨Åc values of various parameters for both 
FALCON-512 and FALCON-1024 .................................. 
44 
Fig. 6.10 
Output of test_samplerz ........................................... 
45 
Fig. 6.11 
Comparison of generated random integers with ideal 
Gaussian ............................................................... 
46 
Fig. 6.12 
Output of 5 ffnp() tests for FALCON-512 ......................... 
48 
Fig. 6.13 
Output of 5 ffnp() tests for FALCON-1024 ....................... 
49 
Fig. 6.14 
Three examples of key pairs and signature executing 
FALCON-512 ......................................................... 
51 
Fig. 6.15 
Three examples of key pairs and signature executing 
FALCON-1024 ........................................................ 
52 
Fig. 6.16 
SpeciÔ¨Åcation of my test computer used in test.py ................ 
52 
Fig. 6.17 
Time consumed in msec executing test.py ........................ 
59 
Fig. 7.1 
Output of solmae_params.py ...................................... 
65 
Fig. 7.2 
Scatter plot of Unifcrown.py ....................................... 
66
xvii

xviii
List of Figures
Fig. 7.3 
Scatter and QQ plots of checking N_sampler.py .................. 
68 
Fig. 7.4 
Sample output from executing Pairgen.py for 
SOLMAE-512 ......................................................... 
70 
Fig. 7.5 
Sample output from executing Pairgen.py for 
SOLMAE-1024 ....................................................... 
71 
Fig. 7.6 
Sample output by executing keygen.py for 
SOLMAE-512 ......................................................... 
74 
Fig. 7.7 
Sample output by executing keygen.py for 
SOLMAE-1024 ....................................................... 
74 
Fig. 7.8 
Two tests of keygen, sign and verify procedures of 
SOLMAE-512 ......................................................... 
77 
Fig. 7.9 
Two tests of keygen, sign and verify procedures of 
SOLMAE-1024 ....................................................... 
78

Chapter 1 
Introduction 
The history of cryptography began with simple substitution of plaintext letters, such 
as the Caesar cipher [20]. During World War I and World War II, mechanical 
encryption devices using such as multiple rotors were employed. The modern 
cryptography has started from 1949 inÔ¨Çuenced by Shannon‚Äôs seminal paper entitled 
as ‚ÄúCommunication Theory of Secrecy Systems‚Äù [42]. 
The goal of modern cryptography is to secure information transmission, storage, 
and processing through the Internet or other channels, protecting against illegal 
eavesdropping, tampering, and forgery by unauthorized and malicious third parties. 
This cryptography involves an encryption process that takes plaintext and a key as 
inputs, and a decryption process that takes the ciphertext and a key as inputs to 
produce a decrypted message identical to the original plaintext. If the same key is 
used for both processes, it is called secret key or symmetric key cryptography. If 
different keys are used, one of which is made public, the other kept in private (or 
secret), it is called public key or asymmetric key cryptography. 
Cryptography provides several security services, such as Confidentiality, 
which ensures secure communication over a transmission medium or channel even 
if a third party is eavesdropping. It also provides Authentication, which protects 
against intentional tampering or forgery of messages by third parties, guaranteeing 
message Integrity and including IdentiÔ¨Åcation, which distinguishes between legiti-
mate and illegitimate entities. Cryptology consists of both cryptography, the design 
of cryptographic systems that are secure against various known attack methods, and 
cryptanalysis, which seeks to discover secret information by using attack algorithms 
and tools against publicly available data. Cryptographic designers must ensure that 
their systems are secure not only against known attacks but also against future 
attacks during the expected usage period. Cryptanalysts, on the other hand, use 
the best available computers to exploit cryptographic vulnerabilities and statistical 
properties to recover plaintext or secret keys from ciphertext within a feasible 
timeframe. For example, an n-bit secret key encryption requires a search space 
of O(2n)O(2^n), and if this search space cannot realistically be explored with current 
¬© The Author(s), under exclusive license to Springer Nature Switzerland AG 2025 
K. Kim, Practical Post-Quantum Signatures, SpringerBriefs in Information Security 
and Cryptography, https://doi.org/10.1007/978-3-031-81250-7_1
1

2
1
Introduction
technology, the cryptographic system is considered to be secure. Currently, the 
minimum key size is 128 bits, and up to 256 bits is commonly used. NIST has 
standardized AES-128 and AES-256 algorithms in FIPS 197 [31], which are widely 
used globally. 
On the other hand, public key cryptography was Ô¨Årst devised in 1976 by DifÔ¨Åe 
and Hellman(DH) [1] as a method where two parties who wish to communicate 
publicly by exchanging public keys each other, and using their private keys, they 
generate a shared secret known only to them. 
The security of this DH method relies on the fact that it must be infeasible to 
derive the private key from the public key, a problem known as the discrete logarithm 
problem. To remain secure against digital computer attacks, the modulus used in DH 
must be at least 2048 bits and can go up to 8192 bits. 
In 1977, RSA (Rivest Shamir Adleman) [40] method extended the DH method 
by proposing the RSA public key cryptosystem, which uses the product of two 
large prime numbers for modular exponentiation in the encryption and decryption 
processes. RSA‚Äôs security is based on the difÔ¨Åculty of the prime factorization 
problem, and currently, modulus sizes range from 2048 bits to 8192 bits to ensure 
security against digital attacks. In 1985 and 1987, Miller [29] and Koblitz [25] 
simultaneously proposed a key exchange system using elliptic curves, which 
reduces the modulus size of the DH method by a factor of six. This method is based 
on the elliptic curve discrete logarithm problem, and key sizes currently range from 
256 bits to 521 bits. 
Public key cryptography systems like RSA method are categorized into two 
types based on key usage: Key Encapsulation Mechanisms (KEM), used to securely 
share a randomly generated session key, and Digital Signatures (DS), which ensure 
message integrity. In KEM, a random session key is encrypted using the recipient‚Äôs 
public key and decrypted using their private key to share the session key. In DS, the 
sender (or signer) hashes the message to create a digest and then signs it using their 
private key. The recipient (or veriÔ¨Åer) veriÔ¨Åes the signature using the public key. If 
the veriÔ¨Åcation matches, the message is accepted; otherwise, it is rejected. Thus, the 
sender signs the message with a private key, while the recipient veriÔ¨Åes the signature 
with a public key. The current digital signature (DS) methods are categorized into 
the hash-and-sign [14] method and the Fiat-Shamir-with-aborts [27] method. 
The RSA-based signature method poses risks of forgery, so ElGamal [5] 
proposed a probabilistic signature scheme based on the discrete logarithm problem. 
NIST adopted this as a standard algorithm and deÔ¨Åned the Digital Signature 
Algorithm (DSA) in FIPS 186-4 [32], recommending a key size of at least 2048 
bits. NIST also extended DSA to elliptic curves in FIPS 186-4 [32], establishing the 
ECDSA algorithm, with key sizes ranging from 256 bits to 521 bits. 
In 1999, Shor [43] proposed an efÔ¨Åcient randomized algorithm on a hypothetical 
quantum computer in 1999 to integer factorization and discrete logarithm problems 
in a polynomial time. Building for the powerful computing environment at that 
time was beyond imagination. Currently the threat of attacking the current (or 
classical) secure system by using the quantum computer is expected to be right at 
our Ô¨Ångertips due to the aggressive road map by IBM quantum computing [19].

1
Introduction
3
We are very concerned about so-called Harvest Now, Decrypt Later attack [45] 
which is a surveillance strategy that relies on the acquisition and long-term 
storage of currently unreadable encrypted data awaiting possible breakthroughs in 
decryption technology that would render it readable in the future. 
Due to the substantial amount of research on quantum computers, large-scale 
quantum computers if built, can break many public-key cryptosystems based on 
the number-theoretic hard problems in use. In 2016, NIST [37] has initiated Post 
Quantum Cryptography (PQC) project to solicit, evaluate, and standardize one or 
more quantum-resistant cryptographic algorithms for KEM and DS globally. After 
several rounds, NIST has Ô¨Ånally selected CRYSTALS-KYBER [41] for KEM and 
CRYSTALS-DILITHIUM [28], FALCON [9]1 and SPHINCS+ [18] for DS in 2022. 
The FIPS PUB standard of KYBER, DILITHIUM and SPHINCS+ are available at 
[33, 34] and [35], respectively in 2024. As of writing this monograph, the FIPS 
PUB standard of FALCON is under process. 
InÔ¨Çuenced by this NIST PQC project, Korean cryptographic society led by KpqC 
task force [26] has called for soliciting Korean PQC candidates by the end of Oct. in 
2022. By the due of submission, 7 candidates KEM and 8 candidates DS for KpqC 
competition were submitted and their details are available at https://kpqc.or.kr/. 
SOLMAE which stands for an acronym of quantum-Secure algOrithm for Long-
term Message Authentication and Encryption was submitted to KpqC Competition 
as one of DS candidate algorithms which is a lattice-based signature scheme inspired 
by several pioneering works based on the hash-then-sign signature paradigm 
proposed by Gentry et al. [12]. SOLMAE is inspired from FALCON‚Äôs design. Some 
of the new theoretical foundations were laid out in the presentation of MITAKA [7] 
while keeping the security level of FALCON with 5 NIST levels of security I to 
V. At a high level, SOLMAE removes the inherent technicality of the sampling 
procedure, and most of its induced complexity from an implementation standpoint, 
for free, that is with no loss of efÔ¨Åciency. This theoretical simplicity translates into 
faster operations while preserving signatures and veriÔ¨Åcation key sizes, on top of 
allowing for additional features absent from FALCON, such as enjoying cheaper 
masking and being parallelizable. 
RSA and DH methods can be understood through number theoretic knowledge, 
but to comprehend FALCON and SOLMAE in depth, not only is it necessary 
to understand algebraic knowledge and Gaussian sampling techniques, but also 
a foundational understanding of lattice theory and polynomial arithematics. Even 
after reading the speciÔ¨Åcations for both signing methods, a signiÔ¨Åcant amount 
of mathematical background knowledge is required, making it difÔ¨Åcult to grasp. 
Since Python packages that implement both methods are publicly available, this 
monograph minimizes the mathematical explanations and instead aims to help 
anyone understand these two methods through Python scripts easily. 
The organization of this monograph is as follows: In Chap. 2, we deÔ¨Åne our 
notations and deÔ¨Ånition used in this monograph. In Chaps. 3 and 4, we overview
1 It stands for the acronym: Fast Fourier lattice-based compact signatures over NTRU. 

4
1
Introduction
the speciÔ¨Åcation of FALCON and SOLMAE including their keygen, signing and 
veriÔ¨Åcation procedures, respectively. After introducing the basics of Python and 
how to set up your test environment over Windows OS in Chap. 5, we describe 
how to perform the correctness of the common modules and functions, common.py, 
fft.py, ntt.py, ntrugen.py and encoding.py both used in FALCON and 
SOLMAE and check their correctness used only in FALCON, parameters.py, 
samplerz.py, ffnp() in ffsampling.py, falcon.py and test.py in Chap. 6. 
In Chap. 7, we describe the correctness of speciÔ¨Åc functions used in SOLMAE only 
which include parameters.py, Unifcrwon.py, N_sampler.py, Parigen.py, 
keygen.py and solmae.py by omitting the description of common modules used 
for FALCON and SOLMAE. 
Finally, we will give concluding remarks and suggest challenging issues in 
Chap. 8.

Chapter 2 
Notations and DeÔ¨Ånition 
2.1 
Matrices, Vectors, and Scalars 
Matrices will usually be in bold uppercase (e.g., B\mathbf{B}), vectors in bold lowercase 
(e.g., v\mathbf{v}), and scalars‚Äîwhich include polynomials‚Äîin italic (e.g. s). We use the 
row convention for vectors. The transpose of a matrix B\mathbf{B}may be noted Bt\mathbf{B}^{\mathrm{t}}. The  ùìÅ2\ell_2-
norm of a vector x = (x1, . . . , xd)\mathbf{x} = (x_1, \dots, x_d) is ‚Äñx‚Äñ =
(‚àë
i |xi|2)1/2
\| \mathbf{x} \| = \left( \sum_{i} |x_i|^2 \right)^{1/2} and its ùìÅ‚àû\ell_\infty-norm is 
‚Äñx‚Äñ‚àû= maxi |xi|\| \mathbf{x} \|_\infty = \max_i |x_i|. It is to be noted that for a polynomial f , we do  not use f 'f'to 
denote its derivative in this monograph. 
2.2 
Quotient Ring 
Let Z{\mathbb{Z}} and N{\mathbb{N}} denote a set of integers and a set of all numbers starting from 1, 
respectively. Q{\mathbb{Q}}and R{\mathbb{R}}denote a set of rational numbers and a set of real numbers, 
respectively. For q ‚ààN√óq \in {\mathbb{N}}^\times, we denote by Zq {\mathbb{Z}}_qthe quotient ring Z/qZ{\mathbb{Z}} /q{\mathbb{Z}}. In FALCON 
and SOLMAE, an integer modulus q = 12, 289q = 12,289is prime, so Zq {\mathbb{Z}}_qis also a Ô¨Ånite 
Ô¨Åeld. We denote by Z√ó
q {\mathbb{Z}}_q^\timesthe group of invertible elements of Zq {\mathbb{Z}}_q, and by œï\varphiEuler‚Äôs 
totient function: œï(q) = |Z√ó
q | = q ‚àí1 = 3 ¬∑ 212\varphi(q) = |{\mathbb{Z}}_q^\times| = q - 1 = 3 \cdot 2^{12} since q is prime. The rings 
Q[x]/(œÜ){\mathbb{Q}}[x]/(\phi), Z[x]/(œÜ){\mathbb{Z}}[x]/(\phi), and R[x]/(œÜ){\mathbb{R}}[x]/(\phi)where œÜ\phiis a monic minimal polynomial will 
be interchangeably written as Q{\mathcal{Q}}, Z{\mathcal{Z}}, and KRK_{{\mathbb{R}}}, respectively for the sake of our 
convenience. 
2.3 
Number Fields 
Let a = ‚àëd‚àí1
i=0 aixi a = \sum_{i=0}^{d-1} a_i x^iand b = ‚àëd‚àí1
i=0 bixi b = \sum_{i=0}^{d-1} b_i x^ibe arbitrary elements of the number Ô¨Åeld 
Q = Q[x]/(œÜ){\mathcal{Q}} = {\mathbb{Q}}[x] / (\phi). We note a‚àóa^*and call (Hermitian) adjoint of a the unique element 
¬© The Author(s), under exclusive license to Springer Nature Switzerland AG 2025 
K. Kim, Practical Post-Quantum Signatures, SpringerBriefs in Information Security 
and Cryptography, https://doi.org/10.1007/978-3-031-81250-7_2
5

6
2
Notations and DeÔ¨Ånition
of Q{\mathcal{Q}}such that for any root Œ∂ \zetaof œÜ\phi, a‚àó(Œ∂) = a(Œ∂)a^*(\zeta) = \overline{a(\zeta)}, where ¬∑\overline{\cdot}is the usual complex 
conjugation over C{\mathbb{C}}. For œÜ = xd + 1\phi = x^d + 1, the Hermitian adjoint a‚àóa^*can be expressed 
simply: 
a^* = a_0 - \sum_{i=1}^{d-1} a_i x^{d-i} a‚àó= a0 ‚àí
d‚àí1
‚é≤
i=1
aixd‚àíi
(2.1) 
We extend this deÔ¨Ånition to vectors and matrices: the adjoint B‚àó\mathbf{B}^*of a matrix B ‚àà
Qn√óm\mathbf{B} \in {\mathcal{Q}}^{n \times m}(resp. a vector v\mathbf{v}) is the component-wise adjoint of the transpose of B\mathbf{B}(resp. v\mathbf{v}): 
\mathbf{B} = \begin{bmatrix} a & b \\ c & d \end{bmatrix} \quad \Leftrightarrow \quad \mathbf{B}^* = \begin{bmatrix} a^* & c^* \\ b^* & d^* \end{bmatrix} B =
‚éæa b
c d
‚èã
‚áî
B‚àó=
‚éæa‚àóc‚àó
b‚àód‚àó
‚èã
(2.2) 
2.4 
Inner Product 
The inner product ‚å©¬∑, ¬∑‚å™\langle \cdot, \cdot \rangleover Q{\mathcal{Q}}and its associated norm ‚Äñ ¬∑ ‚Äñ\| \cdot \|are deÔ¨Åned as: 
\langle a, b \rangle = \frac{1}{\deg(\phi)} \sum_{0 < i \leq d} \varphi_i(a) \cdot \overline{\varphi_i(b)} ‚å©a, b‚å™=
1
deg(œÜ)
‚é≤
0<i‚â§d
œïi(a) ¬∑ œïi(b)
(2.3) 
\| a \| = \sqrt{\langle a, a \rangle} ‚Äña‚Äñ =
‚àö
‚å©a, a‚å™
(2.4) 
These deÔ¨Ånitions can be extended to vectors: for u = (ui)u = (u_i)and v = (vi)v = (v_i)in Qm{\mathcal{Q}}^m, 
‚å©u, v‚å™= ‚àë
i‚å©ui, vi‚å™\langle u, v \rangle = \sum_i \langle u_i, v_i \rangle. For our choice of œÜ\phi, the inner product coincides with the usual 
coefÔ¨Åcient-wise inner product: 
\langle a, b \rangle = \sum_{0 \leq i < d} a_i b_i; ‚å©a, b‚å™=
‚é≤
0‚â§i<d
aibi;
(2.5) 
From an algorithmic point of view, computing the inner product or the norm is 
most easily done using Eq. (2.3) if polynomials are in FFT representation, and using 
Eq. (2.5) if they are in coefÔ¨Åcient representation. By substituting b = ab=a in Eqs. (2.3) 
and (2.5), we get 
\|\varphi(a)\| = \sqrt{d}\cdot \|a\|. ‚Äñœï(a)‚Äñ =
‚àö
d ¬∑ ‚Äña‚Äñ.
(2.6) 
where ‚Äñ ¬∑ ‚Äñ\|\cdot \|is Euclidean norm. Since we know that 
\|\varphi(a)\| = \sqrt{2}\cdot \|(Re(\varphi_1(a)), Im(\varphi_1(a)), \cdots Re(\varphi_{d/2}(a)), Im(\varphi_{d/2}(a)))\|, ‚Äñœï(a)‚Äñ =
‚àö
2 ¬∑ ‚Äñ(Re(œï1(a)), Im(œï1(a)), ¬∑ ¬∑ ¬∑ Re(œïd/2(a)), Im(œïd/2(a)))‚Äñ,
(2.7)

2.7
NTRU Lattices
7
we get 
\|(Re(\varphi_1(a)), Im(\varphi_1(a)), \cdots Re(\varphi_{d/2}(a)), Im(\varphi_{d/2}(a)))\| = \sqrt{\frac{d}{2}}\cdot \|a\|. ‚Äñ(Re(œï1(a)), Im(œï1(a)), ¬∑ ¬∑ ¬∑ Re(œïd/2(a)), Im(œïd/2(a)))‚Äñ =
/
d
2 ¬∑ ‚Äña‚Äñ.
(2.8) 
If a ‚ààKRa \in K_{{\mathbb{R}}}follows the d-dimensional standard normal distribution, it is known that 
(Re(\varphi_1(a)), Im(\varphi_1(a)), \cdots Re(\varphi_{d/2}(a)), Im(\varphi_{d/2}(a)))\text{ follows } \mathcal{N}_{d/2}, (Re(œï1(a)), Im(œï1(a)), ¬∑ ¬∑ ¬∑ Re(œïd/2(a)), Im(œïd/2(a))) follows Nd/2,
(2.9) 
where Nd/2\mathcal{N}_{d/2}denotes continuous Gaussian distribution with zero mean and d
2 ¬∑Id \frac{d}{2}\cdot I_d(i.e., 
Identity matrix) variance. 
2.5 
Lattice 
A lattice is a discrete subgroup of Rn{\mathbb{R}}^n. Equivalently, it is the set of integer linear 
combinations obtained from a basis B\mathbf{B}of Rn{\mathbb{R}}^n. The volume of a lattice is det B\mathbf{B}for 
any of its basis. 
2.6 
Ring Lattices 
For the rings Q = Q[x]/(œÜ){\mathcal{Q}} = {\mathbb{Q}}[x]/(\phi)and Z = Z[x]/(œÜ){\mathcal{Z}} = {\mathbb{Z}}[x]/(\phi), positive integers m ‚â•nm \geq n, and a 
full-rank matrix B ‚ààQn√óm\mathbf{B} \in {\mathcal{Q}}^{n \times m}, we denote by Œõ(B)\varLambda(\mathbf{B})and call lattice generated by B\mathbf{B}, the  
set Zn ¬∑ B = {zB | z ‚ààZn}{\mathcal{Z}}^n \cdot \mathbf{B} = \{ z \mathbf{B} \mid z \in {\mathcal{Z}}^n \}. By extension, a set Œõ\varLambda is a lattice if there exists a matrix 
B\mathbf{B}such that Œõ = Œõ(B)\varLambda = \varLambda(\mathbf{B}). We may say that Œõ ‚äÜZm\varLambda \subseteq {\mathcal{Z}}^mis a q-ary lattice if qZm ‚äÜŒõq{\mathcal{Z}}^m \subseteq \varLambda. 
2.7 
NTRU Lattices 
Let q be an integer, and f ‚ààZ[x]/(xd + 1)f \in {\mathbb{Z}}[x] /(x^d +1)such that f is invertible modulo q 
(equivalently, det[f ]\det [f]is coprime to q). Let h = g/f mod qh = g/f \bmod qand consider the NTRU 
module associated to h: 
\mathcal M_{\textsc{NTRU}} = \{ (u,v) \in K_{{\mathbb{R}}}^2 : hu-v = 0 \bmod q\}, MNTRU = {(u, v) ‚ààK2
R : hu ‚àív = 0 mod q},
and its lattice version 
{\mathcal{L}}_{\textsc{NTRU}} = \{ (\mathbf{u},\mathbf{v}) \in {\mathbb{Z}}^{2d} : [h]\mathbf{u}-\mathbf{v} = 0 \bmod q\}. LNTRU = {(u, v) ‚ààZ2d : [h]u ‚àív = 0 mod q}.

8
2
Notations and DeÔ¨Ånition
This lattice has volume qd q^d. Over  KRK_{{\mathbb{R}}}, it is generated by (f, g)(f,g)and any (F, G)(F,G)such 
that f G ‚àígF = qfG-gF = q. For such a pair (f, g), (F, G)(f,g), (F,G), this means that LNTRU{\mathcal{L}}_{\textsc{NTRU}}has a 
basis of the form 
\mathbf{B}_{f,g} = \begin{bmatrix} [f] & [F] \\ {[g]} & [G]\end{bmatrix}. Bf,g =
‚éæ[f ] [F]
[g] [G]
‚èã
.
One checks that ([h], ‚àíIdd) ¬∑ Bf,g = 0 mod q([h], -\text{Id}_d) \cdot \mathbf{B}_{f,g} = 0 \bmod q, so the veriÔ¨Åcation key is h. The  
NTRU-search problem is : given h = g/f
mod qh = g/f \mod q, Ô¨Ånd any (f ' = xif, g' = xig)(f'= x^if,g' = x^ig). 
In its decision variant, one must distinguish h = g/f mod qh = g/f\bmod q from a uniformly 
random h ‚ààRq := Z[x]/(q, xd + 1) = (Z/qZ)[x]/(xd + 1)h \in R_q := {\mathbb{Z}}[x]/(q, x^d+1) = ({\mathbb{Z}}/q{\mathbb{Z}})[x]/(x^d+1). These problems 
are assumed to be intractable for large d. 
2.8 
DFT Representation 
For d = 2nd = 2^n, we use œÜ(x) = xd + 1\phi(x) = x^d + 1. It is a monic polynomial of Z[x]{\mathbb{Z}}[x], irreducible 
in Q[x]{\mathbb{Q}}[x] and with distinct roots over C{\mathbb{C}}. Then Œ∂j
= exp(i(2j ‚àí1)œÄ/d)\zeta_j = exp(i(2j-1)\pi /d) for 
j = 1, 2, ¬∑ ¬∑ ¬∑ dj= 1, 2, \cdots dare roots of œÜ(x)\phi(x). For f = Œ£fixi ‚ààKRf = \varSigma{f_ix^i} \in K_{{\mathbb{R}}}, we deÔ¨Åne the coefÔ¨Åcient 
representation as f = (f0, f1, ¬∑ ¬∑ ¬∑ fd‚àí1)\mathbf{f} = (f_0, f_1, \cdots f_{d-1}) and Discrete Fourier Transform (DFT) 
representation œï(f ) = (œï1(f ), ¬∑ ¬∑ ¬∑ , œïd(f ))\varphi(f) = (\varphi_1(f), \cdots , \varphi_d(f)). 
2.9 
Discrete Gaussians 
For œÉ, Œº ‚ààR\sigma, \mu \in {\mathbb{R}}with œÉ > 0\sigma > 0, we deÔ¨Åne the Gaussian function œÅœÉ,Œº\rho_{\sigma,\mu}as œÅœÉ,Œº(x) =
exp(‚àí|x‚àíŒº|2/2œÉ 2)\rho_{\sigma,\mu}(x) = \exp(-|x-\mu|^2/2\sigma^2), and the discrete Gaussian distribution DZ,œÉ,ŒºD_{{\mathbb{Z}},\sigma,\mu}over the integers 
as: 
D_{{\mathbb{Z}},\sigma,\mu}(x) = \frac{\rho_{\sigma,\mu}(x)}{ \sum_{z \in {\mathbb{Z}}} \rho_{\sigma,\mu}(z)} DZ,œÉ,Œº(x) =
œÅœÉ,Œº(x)
‚àë
z‚ààZ œÅœÉ,Œº(z)
(2.10) 
The parameter Œº\mumay be omitted when it is equal to zero. 
2.10 
Gram-Schmidt Orthogonalization 
Any matrix B ‚ààQn√óm\mathbf{B} \in {\mathcal{Q}}^{n \times m}can be decomposed as follows: 
\mathbf{B} = \mathbf{L} \times \tilde{\mathbf{B}} B = L √ó ÀúB
(2.11)

2.11
LDL* Decomposition
9
where L\mathbf{L}is lower triangular with 1‚Äôs on the diagonal, and the rows Àúbi \tilde{b_i}‚Äôs of ÀúB\tilde{\mathbf{B}}verify 
‚å©Àúbi, Àúbj‚å™= 0\langle \tilde{b_i}, \tilde{b_j} \rangle = 0for i /= j i \neq j. When B\mathbf{B}is full-rank, this decomposition is unique, and 
it is called the Gram-Schmidt orthogonalization (or GSO). We also call the Gram-
Schmidt norm of B\mathbf{B}the following value: 
\|\mathbf{B}\|_{GS} = \max_{\tilde{\mathbf{b}_i} \in \tilde{\mathbf{B}}} \| \tilde{\mathbf{b}_i} \| ‚ÄñB‚ÄñGS = max
Àúbi‚ààÀúB
‚Äñ Àúbi‚Äñ
(2.12) 
2.11 
LDL* Decomposition 
The LDL ‚àó{}^* decomposition writes any full-rank Gram matrix as a product LDL ‚àó{}^*, 
where L ‚ààQn√ón\mathbf{L} \in {\mathcal{Q}}^{n \times n}is lower triangular with 1‚Äôs on the diagonal, and D ‚ààQn√ón\mathbf{D} \in {\mathcal{Q}}^{n \times n}is 
diagonal. The LDL ‚àó{}^*decomposition and the GSO are closely related as for a basis B\mathbf{B}, 
there exists a unique GSO B = L¬∑ ÀúB\mathbf{B} = \mathbf{L} \cdot \tilde{\mathbf{B}}, and for a full-rank Gram matrix G\mathbf{G}, there exists 
a unique LDL ‚àó{}^* decomposition G = LDL‚àó\mathbf{G} = \mathbf{LDL}^*. If G = BB‚àó\mathbf{G} = \mathbf{BB}^*, then G = L ¬∑ ( ÀúB ÀúB‚àó) ¬∑ L‚àó\mathbf{G} = \mathbf{L} \cdot (\tilde{\mathbf{B}}\tilde{\mathbf{B}}^*) \cdot \mathbf{L}^* is 
a valid LDL ‚àó{}^* decomposition of G\mathbf{G}. As both decompositions are unique, the matrices 
L\mathbf{L}in both cases are actually the same. In a nutshell: 
[\mathbf{L} \cdot \tilde{\mathbf{B}} \text{ is the GSO of } \mathbf{B}] \Leftrightarrow [\mathbf{L} \cdot (\mathbf{B}\tilde{\mathbf{B}^*}) \cdot \mathbf{L}^* \text{ is the LDL}^*\text{ decomposition of } (\mathbf{BB}^*)]. [L ¬∑ ÀúB is the GSO of B] ‚áî[L ¬∑ (B ÀúB‚àó) ¬∑ L‚àóis the LDL‚àódecomposition of (BB‚àó)].
(2.13) 
The reason why we present both equivalent decompositions is that the GSO is 
a more familiar concept in lattice-based cryptography, whereas the use of LDL ‚àó{}^*
decomposition is faster and therefore makes more sense from an algorithmic point 
of view.

Chapter 3 
FALCON Algorithm 
3.1 
Overview 
Hoffstein et al. [16] suggested a new public-key cryptosystem based on a polynomial 
ring in 1997 as an alternative to RSA and DH 
whose difÔ¨Åculties are based on number-theoretic hard problems such as integer 
factorization and discrete log problem, respectively. They founded the company 
so-called as NTRU1 Cryptosystem with Lieman and initiated an open-source 
lattice-based cryptography consisting of two algorithms: NTRUENCRYPT used for 
encryption/decryption and NTRUSIGN used for digital signatures. Their security 
relies on the presumed difÔ¨Åculty of factoring certain polynomials in a truncated 
polynomial ring into a quotient of two polynomials having very small coefÔ¨Åcients. 
NTRUSIGN was designed based on the GGH signature scheme [13] which was 
proposed in 1995 based on solving the Closest Vector Problem (CVP) in a lattice and 
asymptotically is more efÔ¨Åcient than RSA in the computation time for encryption, 
decryption, signing, and verifying are all quadratic in the natural security parameter. 
The signer demonstrates knowledge of a good basis for the lattice by using it to solve 
CVP on a point representing the message; the veriÔ¨Åer uses a bad basis for the same 
lattice to verify that the signature under consideration is actually a lattice point and 
is sufÔ¨Åciently close to the message point. 
On the other hand, Min et al. [30] suggested a weak property of malleability of 
NTRUSIGN using the annihilating polynomial from a given message and signature 
pair to generate a valid signature. Nguyen and Regev [36] had cryptanalyzed 
the original GGH signature scheme including NTRUSIGN in 2006 successfully 
extracting secret information from many known signatures characterized by mul-
1 Number Theorists ‚ÄòR‚Äô Us, or Number Theory Research Unit, or N-th degree TRuncated 
polynomial Ring. 
¬© The Author(s), under exclusive license to Springer Nature Switzerland AG 2025 
K. Kim, Practical Post-Quantum Signatures, SpringerBriefs in Information Security 
and Cryptography, https://doi.org/10.1007/978-3-031-81250-7_3
11

12
3
FALCON Algorithm
tivariate optimization problems. Their experiments showed that 90,000 signatures 
are sufÔ¨Åcient to recover the NTRUSIGN-251 secret key. 
In a nutshell, FALCON follows a framework introduced in 2008 by Gentry et 
al. [12] which we call the GPV framework for short over the NTRU lattices and 
uses a typically hash-and-sign paradigm. Their high-level idea is the following: 
1. The public key is a long basis of a q-ary lattice. 
2. The private key is (essentially) a short basis of the same lattice. 
3. In the signing procedure, the signer: 
(a) generates a random value, salt; 
(b) computes a target c = H(M||salt)\mathbf{c}=H(M||salt), where H is a hash function sending input 
to a random-looking point (on the grid); 
(c) uses his knowledge of a short basis to compute a lattice point v\mathbf{v}close to the 
target c\mathbf{c}; 
(d) outputs (salt, s)(salt,\mathbf{s}), where s = c ‚àív.\mathbf{s}= \mathbf{c}- \mathbf{v}.
4. The veriÔ¨Åer accepts the signature (salt, s)(salt,\mathbf{s}) if and only if: 
(a) the vector s is short; 
(b) H(M||salt) ‚àí sH(M||salt)-\mathbf{s} is a point on the lattice generated by his public key. 
Only the signer should be able to efÔ¨Åciently compute v close enough to an 
arbitrary target. This is a decoding problem that can be solved when a basis of 
short vectors is known. On the other hand, anyone wanting to check the validity 
of a signature should be able to verify lattice membership. The KeyGen, Sign and 
Verif procedures for FALCON will be introduced brieÔ¨Çy in the later Section by 
restating the original speciÔ¨Åcation as in [9]. Fig. 3.1 shows the genealogic tree of 
FALCON. For details, the readers can refer to [9]. 
Fig. 3.1 Genealogic tree of FALCON

3.2
Key Generation of FALCON
13
3.2 
Key Generation of FALCON 
For the class of NTRU lattices, a trapdoor pair is (h, Bf,g)(h, \mathbf{B}_{f,g})where h = f ‚àí1g, Bf,gh = f^{-1}g,\mathbf{B}_{f,g}
is a trapdoor basis over LNTRU{\mathcal{L}}_{\textsc{NTRU}} and Pornin and Prest [38] showed that a completion 
(F, G)(F,G)can be computed in O(d log d)O(d\log d)time from short polynomials f, g ‚ààZf,g \in {\mathcal{Z}}. In  
practice, their implementation is as efÔ¨Åcient as can be for this technical procedure: it 
is called NtruSolve in FALCON. Their algorithm only depends on the underlying 
ring and has now a stable version for Z[x]/(xd + 1){\mathbb{Z}}[x]/(x^{d}+1), where d = 2nd=2^n. 
Fig. 3.2 illustrates the Ô¨Çowchart of the key generation procedure for FALCON. 
Algorithm 1 describes the pseudo-code for key generation of FALCON. Readers 
can refer to Algorithms 5 and 6 in [9] for details on how to perform ntrugen 
and ntrusolve, respectively. Additionally, Algorithms 8 and 9 in [9] explain the 
procedures for LDL* and ffLDL*, respectively. 
Fig. 3.2 Flowchart of KeyGen for FALCON 
Algorithm 1 KeyGen of FALCON 
Input: A monic polynomial œÜ ‚àà Z[x], a modulus q 
Output: A secret key sk, a public key pk 
1: f, g, F, G ‚ÜêNtruGen(œÜ, q)
// Solving the NTRU equation 
2: B ‚Üê
‚éæ
g ‚àíf 
G ‚àíF
‚èã
; 
3: ÀÜB ‚ÜêFFT(B)
// Compute FFT for each {g, ‚àíf, G, ‚àíF} 
4: G ‚Üê ÀÜB √ó ÀÜB‚àó; 
5: T ‚Üê ffLDL‚àó(G)
// Compute the LDL* tree 
6: for each leaf of T do 
7:
leaf.value ‚Üê œÉ/‚àöleaf.value
// Normalization step 
8: sk ‚Üê( ÀÜB, T); 
9: h ‚Üê gf ‚àí1mod q; 
10: pk ‚Üê h; 
11: return sk, pk 

14
3
FALCON Algorithm
3.3 
Signing of FALCON 
At a high level, the signing procedure in FALCON is at Ô¨Årst to compute a hashed 
value c ‚ààZq[x]/(œÜ)\mathbf{c} \in {\mathbb{Z}}_q[x]/(\phi)from the message, M and a salt r, then using the secret key, 
f, g, F, Gf,g,F,Gto generate two short values (s1, s2)(\mathbf{s}_1,\mathbf{s}_2)such that s1 + s2h = c mod q\mathbf{s}_1 + \mathbf{s}_2 h = \mathbf{c} \bmod {q}. An  
interesting feature is that only the Ô¨Årst half of the signature (s1, s2)(\mathbf{s}_1, \mathbf{s}_2)needs to be 
sent along the message, as long as h is available to the veriÔ¨Åer. This comes from 
the identity hs1 = s2 mod qh \mathbf{s}_1 = \mathbf{s}_2 \bmod qdeÔ¨Åning these lattices, as we will see in the Verif 
algorithm description. 
The core of FALCON signing is to use ffSampling (Algorithm 11 in [9]) which 
applies a randomizing rounding according to Gaussian distribution on the coefÔ¨Åcient 
of t = (t0, t1) ‚àà(Q[x]/(œÜ))2\mathbf{t} = (\mathbf{t}_0, \mathbf{t}_1) \in ({\mathbb{Q}} [x] /(\phi))^2 stored in the FALCON Tree, T at the KeyGen 
procedure of FALCON. 
This fast Fourier sampling algorithm can be seen as a recursive version of Klein‚Äôs 
well-known trapdoor sampler, but cannot be computed in parallel also known as 
the GPV sampler. Klein‚Äôs sampler uses a matrix L\mathbf{L}and the norm of Gram-Schmidt 
vectors as a trapdoor while FALCON are using a tree of non-trivial elements in 
such matrices. Note that Fouque et al. [10] suggested Gram-Schmidt norm leakage 
in FALCON by timing side channels in the implementation of the one-dimensional 
Gaussian samplers. 
FALCON cannot output two different signatures for a message. This well-
known concern of the GPV framework can be addressed in several ways, for 
example, making a stateful scheme or by hash randomization. FALCON chose 
the latter solution for efÔ¨Åciency purposes. In practice, Sign adds a random ‚Äúsalt‚Äù 
r ‚àà{0, 1}kr\in \{0,1\}^k, where k is large enough that an unfortunate collision of messages 
is unlikely to happen, that is, it hashes (r||M)(r||M)instead of M. A signature is then 
sig = (r, Compress(s1)){\mathtt{sig}} = (r, \mathtt{Compress}(\mathbf{s}_1)). 
Fig. 3.3 and Algorithm 2 sketches the signing procedure for FALCON and shows 
its pseudo-code for FALCON, respectively. 
Readers can refer to Algorithm 11 in [9] for details on how to perform 
ffsampling. SamplerZ illustrated at Algorithm 15 in [9], for given inputs Œº\muand 
œÉ '\sigma' in a certain range, outputs an integer z ‚àºDZ,œÉ ',Œºz \sim D_{{{\mathbb{Z}}},\sigma', \mu} in an isochronous manner.

3.3
Signing of FALCON
15
Fig. 3.3 Flowchart of Sign for FALCON 
Algorithm 2 Sign of FALCON 
Input: A message M ‚àà{0, 1}‚àó, secret key sk, a bound Œ≥ . 
Output: A pair  (r, Compress(s1)) with r ‚àà{0, 1}320 and ‚Äñ(s1, s2)‚Äñ ‚â§Œ≥ . 
1: r ‚ÜêU({0, 1}320) 
2: c ‚Üê HashToPoint(r||M, q, n) 
3: t ‚Üê(‚àí1 
q FFT(c) ‚äôFFT(F), 1 
q FFT(c) ‚äôFFT(f ))
// t = (FFT(c), FFT(0)) ¬∑ ÀÜB‚àí1 
4: do 
5:
do 
6:
z ‚Üê ffSamplingn(t, T) 
7:
s = (t ‚àí z) ÀÜB
// At this point, s follows Gaussian distribution. 
8:
while ||s||2 > Œ≥  
9:
(s1, s2) ‚ÜêFFT-1(s) 
10:
s ‚Üê Compress(s2, 8 ¬∑ sbytelen ‚àí 328) // Remove 1 byte for the header, and 40 bytes for 
r 
11: while(s = ‚ä•) 
12: return (r, s) 
3.3.1 
Compress and Decompress Algorithms 
The speciÔ¨Åcation [9] of FALCON suggests encoding and decoding algorithms to 
reduce the size of keys and signatures. For completeness, we provide a description

16
3
FALCON Algorithm
of the compression and decompression functions as depicted in Algorithms 3 and 4, 
respectively. Note that slen = 8 ¬∑ |sgn| ‚àí320slen = 8\cdot |sgn| - 320by default where |sgn||sgn|denotes the 
signature size in bytes. The Compress and Decompress techniques are generic and 
have no impact on the security level. 
Algorithm 3 Compress 
Input: A polynomial s = ‚àëd‚àí1 
i=0 siXi ‚àà R = Z[X]/(Xd + 1) and an integer  slen. 
Output: A compressed representation of str of s of bitsize slen, or  ‚ä• 
1: str ‚Üê{}  
2: for i = 0 to  d ‚àí1 do 
3:
str ‚Üê (str || b) where b = 1 if  si < 0, b = 0 otherwise; 
4:
str ‚Üê (str || b6b5 ¬∑ ¬∑ ¬∑ b0) where bj = (|si| ‚™¢j)&0x1; 
5:
k ‚Üê|si| ‚™¢7; 
6:
str ‚Üê (str || 0k1) 
7: end for 
8: if |str| > slen  then 
9:
str ‚Üê‚ä•; 
10: else 
11:
str ‚Üê(str || 0slen‚àí|str|) 
12: end if 
13: return str 
Algorithm 4 Decompress 
Input: A bitstring  str of bitsize slen 
Output: A polynomial s = ‚àëd‚àí1 
i=0 siXi ‚àà R = Z[X]/(Xd + 1) or ‚ä• 
1: if |str| /= slen then 
2: 
return ‚ä•; 
3: end if 
4: for i = 0 to  d ‚àí 1 do 
5:
s'
i ‚Üê‚àë6 
j=0 26‚àíj str[1 + j]; 
6:
k ‚Üê0; 
7: 
while str[8 + k] =  0 do 
8:
k ‚Üê k + 1 
9: 
end while 
10:
si ‚Üê(‚àí1)str[0] ¬∑ (s'
i + 27k); 
11: 
if si = 0 and  str[0] =  1 then 
12:
return ‚ä• 
13: 
end if 
14:
str ‚Üêstr[9 + k : ]  
15: end for 
16: if |str| /= 0|str| then 
17:
return ‚ä•; 
18: end if 
19: return s = ‚àëd‚àí1 
i=0 siXi 

3.4
VeriÔ¨Åcation of FALCON
17
3.4 
VeriÔ¨Åcation of FALCON 
The last step of the scheme is thankfully simpler to describe. Upon receiving a 
signature (r, s)(r,\mathbf{s})and message M, the veriÔ¨Åer decompresses s\mathbf{s}to a polynomial s1\mathbf{s}_1and 
c = (0, H(r||M))\mathbf{c} = (0, {\mathtt{H}}(r||M)), then wants to recover the full signature vector v = (s1, s2)\mathbf{v} =(\mathbf{s}_1, \mathbf{s}_2). If  v\mathbf{v} is 
a valid signature, the veriÔ¨Åcation identity is (h, ‚àí1) ¬∑ (c ‚àív) = ‚àíH(r||M) ‚àíhs1 +
s2 mod q = 0(h, -1)\cdot (\mathbf{c}-\mathbf{v}) = -{\mathtt{H}}(r||M) -h\mathbf{s}_1+ \mathbf{s}_2 \bmod q = 0, or equivalently the veriÔ¨Åer can compute 
\mathbf{s}_2 = {\mathtt{H}}(r||M) + h \mathbf{s}_1 \bmod q. s2 = H(r||M) + hs1 mod q.
This is computed in the ring Rq R_q, and can be done very efÔ¨Åciently for a good 
choice of modulus q using the Number Theoretic Transform (NTT). FALCON 
currently follow the standard choice of q = 12, 289q=12,289, as the multiplication in NTT 
format amounts to d integer multiplications in Z/qZ{\mathbb{Z}}/q{\mathbb{Z}}. The last step is to check that 
‚Äñ(s1, s2)‚Äñ2 ‚â§Œ≥ 2\|(\mathbf{s}_1, \mathbf{s}_2)\|^2 \leq {\gamma}^2: the signature is only accepted in this case. The rejection bound 
Œ≥ {\gamma}comes from the expected length of vectors outputted by Sample described as 
Algorithm 4 in [24]. 
Since they are morally Gaussian, they concentrate around their standard devi-
ation; a ‚Äúslack‚Äù parameter œÑ = 1.042\tau = 1.042is tuned to ensure that 90%90\%of the vectors 
generated by Sample will get through the loop: 
\gamma = \tau\cdot \sigma_{\protect\mathtt{sig}}\cdot \sqrt{2d}. Œ≥ = œÑ ¬∑ œÉsig ¬∑
‚àö
2d.
Algorithm 5 shows the pseudo-code of veriÔ¨Åcation procedure of FALCON. 
Algorithm 5 Verif of FALCON 
Input: A signature (r, s) on M, a public key pk = h, a bound Œ≥ . 
Output: Accept or Reject. 
1: s1 ‚Üê Decompress(s) 
2: c ‚ÜêH(r||M) 
3: s2 ‚Üê c + hs1 mod q 
4: 
5: if ‚Äñ(s1, s2)‚Äñ2 > Œ≥  2 then 
6:
return Reject. 
7: else 
8:
return Accept. 
9: end if 

Chapter 4 
SOLMAE Algorithm 
4.1 
Overview 
Inspired by FALCON‚Äôs design, Espitau et al. presented so-called MITAKA [6] to  
reduce some drawbacks of FALCON. At a high-level, it removes the inherent 
technicality of the sampling procedure, and most of its induced complexity from 
an implementation standpoint, for free, that is with no loss of efÔ¨Åciency. The 
simplicity of our design translates into faster operations while preserving signature 
and veriÔ¨Åcation key sizes, in addition to allowing for additional features absent from 
FALCON, such as enjoying less expensive masking, and being parallelizable. In 
2023, Espitau et al. [8] suggested so-called ANTRAG in order to improve MITAKA 
without loss of security covering all NIST level of security I to V using the degree 
of cyclotomic ring from 512 to 1024 over speciÔ¨Åc cyclotomic polynomials under 
the prime modulus but is not limited to the power of 2. 
Taking all advantages of FALCON, MITAKA and ANTRAG, SOLMAE is yet 
another quantum-safe signature based on NTRU trapdoor and achieves better 
performance for the same security and advantages as FALCON which focused 
only on NIST I and V levels of security. More precisely, SOLMAE offers the ‚Äúbest 
of three worlds‚Äù between FALCON, MITAKA and ANTRAG. Overall, SOLMAE is 
summarized in Fig. 4.1. For details on SOLMAE, refer to [24]. 
More details about all the objects mentioned in this section can be found later. 
Here, we focus on the big lines behind our scheme‚Äôs principles, keeping details at a 
minimum. While its predecessor FALCON could be summed up as ‚Äúan efÔ¨Åcient 
instantiation of the GPV framework‚Äù, SOLMAE takes it one step further. The 
ingredients behind the boxes in Fig. 4.1 are as follows: 
¬© The Author(s), under exclusive license to Springer Nature Switzerland AG 2025 
K. Kim, Practical Post-Quantum Signatures, SpringerBriefs in Information Security 
and Cryptography, https://doi.org/10.1007/978-3-031-81250-7_4
19

20
4
SOLMAE Algorithm
Fig. 4.1 Overview of SOLMAE
.
An optimally tuned key generation algorithm, enhancing the security of our 
new sampler to that of FALCON‚Äôs level;1 
.
The hybrid sampler is a faster, simpler, parallelizable and maskable Gaussian 
sampler to generate signatures;
.
Easy implementation by assembling all the advantages of MITAKA and 
ANTRAG to make faster and simpler for practical purposes. 
On the other hand, other techniques require tweaking the key generation and signing 
procedures. 
4.2 
Key Generation of SOLMAE 
An important concern here is that not all pairs (f, g), (F, G)(f,g), (F,G)gives good trapdoor 
pairs for Sample described as Algorithm 4 in [24]. Schemes such as FALCON 
and MITAKA solve this technicality essentially by sieving among all possible bases 
to Ô¨Ånd the ones that reach an acceptable quality for the Sample procedure. This 
technique is costly, and many tricks were used to achieve an acceptable KeyGen. 
This sieving routine was bypassed by redesigning completely how good quality 
bases can be found. This improves the running time of KeyGen and also increases 
the security offered by Sample. In any case, note that NtruSolve‚Äôs running time 
largely dominates the overall time for KeyGen: this is not avoidable as the basis 
completion algorithm requires working with quite large integers and relatively high-
precision Ô¨Çoating-point arithmetic. 
At the end of the procedure, the secret key contains not only the secret basis but 
also the necessary data for Sign and Sample. This additional information can be
1 This corresponds to the NIST-I and NIST-V requirements.

4.2
Key Generation of SOLMAE
21
represented by elements in KR{K_{{\mathbb{R}}}} and is computed during or at the end of NtruSolve. 
All-in-all, KeyGen outputs: 
{\mathtt{sk}} &= ( \mathbf{b}_1 = (f,g), \mathbf{b}_2 = (F,G), {\widetilde{\mathbf{b}}}_2 = ({\widetilde{F}}, {\widetilde{G}}), \varSigma_1, \varSigma_2, \beta_1, \beta_2)),\\ {\mathtt{pk}} &= (h, q,{\sigma_{{\mathtt{sig}}}}, \eta), sk = (b1 = (f, g), b2 = (F, G),~b2 = (~
F, ~
G), Œ£1, Œ£2, Œ≤1, Œ≤2)),
pk = (h, q, œÉsig, Œ∑),
where we recall that h = g/f mod qh=g/f\bmod q. These parameters and a table of their practical 
values are described more thoroughly in [24]. 
Informally, they correspond to the following:
.
(f, g), (F, G)(f,g), (F,G)is a good basis of the lattice LNTRU{\mathcal{L}}_{\textsc{NTRU}}associated to h, with quality 
Q(f, g) = Œ±\mathcal{Q}(f,g)=\alpha, and ~b2{\widetilde{\mathbf{b}}}_2 is the Gram-Schmidt orthogonalization of (F, G)(F,G) with 
respect to (f, g)(f,g);
.
œÉsig, Œ∑{\sigma_{{\mathtt{sig}}}}, \etaare respectively the standard deviation for signature vectors, and a tight 
upper bound on the ‚Äúsmoothing parameter of Zd {\mathbb{Z}}^d‚Äù;
.
Œ£1, Œ£2 ‚àà KR\varSigma_1,\varSigma_2 \in {K_{{\mathbb{R}}}} represent covariance matrices for two intermediate Gaussian 
samplings in Sample;
.
the vectors Œ≤1, Œ≤2 ‚ààKR2\beta_1, \beta_2 \in {K_{{\mathbb{R}}}}^2represent the orthogonal projections from KR2{K_{{\mathbb{R}}}}^2onto 
KR ¬∑b1{K_{{\mathbb{R}}}}\cdot \mathbf{b}_1 and KR ¬∑~b2{K_{{\mathbb{R}}}}\cdot {\widetilde{\mathbf{b}}}_2 respectively. In other words, they act as ‚ÄúgetCoordinates‚Äù for 
vectors in KR2{K_{{\mathbb{R}}}}^2. They are used by Sample and are precomputed for efÔ¨Åciency. 
Algorithm 6 computes the necessary data for signature sampling, then outputs 
the key pair. Note that NtruSolve could also compute the sampling data and the 
public key, but for clarity, the pseudo-code gives these tasks to KeyGen of SOLMAE. 
Fig. 4.2 sketches the key generation procedure of SOLMAE. 
Fig. 4.2 Flowchart of KeyGen for SOLMAE

22
4
SOLMAE Algorithm
Algorithm 6 KeyGen of SOLMAE 
Input: A modulus q, a target quality parameter 1 < Œ±, parameters œÉsig, Œ∑  >  0 
Output: A basis  ((f, g), (F, G)) ‚àà R2 of an NTRU lattice LNTRU with Q(f, g) = Œ±; 
1: while f is invertible modulo q do 
2:
b1 := (f, g) ‚Üê PairGen(q, Œ±, R‚àí, R+) // Secret basis computation between R‚àí and R+ 
3: end while 
4: b2 := (F, G) ‚ÜêNtruSolve(q, f, g): 
5: h ‚Üêg/f mod q
// Public key data computation 
6: Œ≥ ‚Üê1.1 ¬∑ œÉsig ¬∑
‚àö
2d
// tolerance for signature length 
7: Œ≤1 ‚Üê 
1
‚å©b1,b1‚å™K ¬∑ b1
// Sampling data computation, in Fourier domain 
8: Œ£1 ‚Üê
/
œÉsig2
‚å©b1,b1‚å™K ‚àí Œ∑2\varSigma_1 \gets \sqrt{ \frac{{\sigma_{{\mathtt{sig}}}}^2}{{\langle \mathbf{b}_1, \mathbf{b}_1 \rangle}_K} - \eta^2 }
9: ~b2 := (~
F, ~
G) ‚Üêb2 ‚àí‚å©Œ≤1, b2‚å™¬∑  b1 
10: Œ≤2 ‚Üê 
1
‚å©~b2,~b2‚å™K ¬∑~b2\beta_2 \gets \frac{1}{\vphantom{\frac{1}{1}}{\langle {\widetilde{\mathbf{b}}}_2, {\widetilde{\mathbf{b}}}_2 \rangle}_K}\cdot {\widetilde{\mathbf{b}}}_2
11: Œ£2 ‚Üê
/
œÉsig2
‚å©~b2,~b2‚å™K ‚àíŒ∑2\varSigma_2 \gets \sqrt{ \frac{{\sigma_{{\mathtt{sig}}}}^2}{\vphantom{\frac{1}{1}}{\langle {\widetilde{\mathbf{b}}}_2, {\widetilde{\mathbf{b}}}_2 \rangle}_K} - \eta^2 }
12: sk ‚Üê(b1, b2,~b2, Œ£1, Œ£2, Œ≤1, Œ≤2) 
13: pk ‚Üê (q, h, œÉsig, Œ∑, Œ≥  )  
14: return sk, pk 
The function of two subroutines PairGen and NtruSolve are described below: 
1. The PairGen algorithm generates d complex numbers (xjeiŒ∏j )j‚â§d/2,
(yjeiŒ∏j )j‚â§d/2(x_j e^{i\theta_j})_{j\leq d{/}2},\break (y_j e^{i\theta_j})_{j\leq d{/}2}to act as the FFT representations of two real polynomial f R, gRf^{\mathbb{R}}, g^{\mathbb{R}}
in KR{K_{{\mathbb{R}}}}. The magnitude of these complex numbers is sampled in a planar annulus 
whose small and big radii are set to match a target Q(f, g)\mathcal{Q}(f,g) with UnifCrown [24]. 
It then Ô¨Ånds close elements f, g ‚ààZf, g\in {\mathcal{Z}}by round-off, unless maybe the rounding 
error was too large. When the procedure ends, it outputs a pair (f, g)(f,g)such that 
Q(f, g) = Œ±\mathcal{Q}(f,g) = \alpha, where Œ±\alphadepends on the security level. 
2. NtruSolve is exactly Pornin and Prest‚Äôs algorithm and implementation [38]. It 
takes as input (f, g) ‚ààZ2(f,g)\in {\mathcal{Z}}^2and a modulus q, and outputs (F, G) ‚ààZ2(F,G) \in {\mathcal{Z}}^2such that 
(f, g), (F, G)(f,g), (F,G)is a basis of LNTRU{\mathcal{L}}_{\textsc{NTRU}}associated to h = g/f mod qh = g/f\bmod q. It does so by 
solving the B√©zout-like equation f G‚àígF = qfG-gF = q in Z{\mathcal{Z}} using recursively the tower 
of subÔ¨Åelds for optimal efÔ¨Åciency. 
4.3 
Signing of SOLMAE 
Recall that NTRU lattices live in R2d {\mathbb{R}}^{2d}. Their structure also helps to simplify the 
preimage computation. Indeed, the signer only needs to compute m = H(M) ‚àà
Rd \mathbf{m} ={\mathtt{H}}(M) \in {\mathbb{R}}^d, as then c = (0, m)\mathbf{c} = (0, \mathbf{m})is a valid preimage: the corresponding polynomials satisfy 
(h, 1) ¬∑ c = m(h,1)\cdot \mathbf{c} = \mathbf{m}. 
As the same with Sign procedure of FALCON, an interesting feature is that only 
the Ô¨Årst half of the signature (s1, s2) ‚ààLNTRU(\mathbf{s}_1,\mathbf{s}_2) \in {\mathcal{L}}_{\textsc{NTRU}}needs to be sent along the message,

4.3
Signing of SOLMAE
23
Fig. 4.3 Flowchart of Sign for SOLMAE 
as long as h is available to the veriÔ¨Åer. This comes from the identity hs1 = s2 mod qh \mathbf{s}_1 = \mathbf{s}_2 \bmod q
deÔ¨Åning these lattices, as we will see in the Verif algorithm description.2 
Because of their nature as Gaussian integer vectors, signatures can be encoded to 
reduce the size of their bit-representation. The standard deviation of Sample is large 
enough so that the ‚éølog ‚àöq‚èå\lfloor \log \sqrt{q}\rfloorleast signiÔ¨Åcant bits of one coordinate are essentially 
random. 
In practice, Sign adds a random ‚Äúsalt‚Äù r ‚àà{0, 1}kr\in \{0,1\}^k, where k is large enough that 
an unfortunate collision of messages is unlikely to happen, that is, it hashes (r||M)(r||M)
instead of M‚Äîour analysis in this regard is identical to FALCON. A signature is 
then sig = (r, Compress(s1)){\mathtt{sig}} = (r, \mathtt{Compress}(s_1))using Algorithm 3 stated in Sect. 3.3.1. SOLMAE  
cannot output two different signatures for a message like FALCON which was 
mentioned in Sect. 3.3. 
Fig. 4.3 sketches the signing procedure of SOLMAE and Algorithm 7 shows 
its pseudo-code. Z{{\mathbb{Z}}}-Sampler is equivalent to SamplerZ used in FALCON. 
N{\mathcal N}-Sampler (Algorithm 10 in [24]) refers to sampling from a Gaussian or normal 
distribution. For PeikertSampler, see Algorithm 5 in [24].
2 The same identity can also be used to check the validity of signatures only with a hash of the 
public key h, requiring this time send both s1\mathbf{s}_1 and s2\mathbf{s}_2, but we will not consider this setting here. 

24
4
SOLMAE Algorithm
Algorithm 7 Sign of SOLMAE 
Input: A message M ‚àà{0, 1}‚àó, a tuple sk = ((f, g), (F, G), (~
F, ~
G), œÉsig, Œ£1, Œ£2, Œ∑), a  
rejection parameter Œ≥ >  0. 
Output: A pair (r, Compress(s1)) with r ‚àà{0, 1}320 and ‚Äñ(s1, s2)‚Äñ ‚â§ Œ≥ . 
1: r ‚ÜêU({0, 1}320) 
2: c ‚Üê (0, H(r||M)) 
3: ÀÜc ‚ÜêFFT(c) 
4: while ‚Äñ(FFT-1(ÀÜs1), FFT-1(ÀÜs2))‚Äñ2 ‚â§ Œ≥ 2 do 
5:
(ÀÜs1, ÀÜs2) ‚Üê ÀÜc ‚àí Sample(ÀÜc, sk)
// (s1, s2) ‚ÜêDLNTRU,c,œÉsig (\mathbf{s}_1, \mathbf{s}_2) \gets D_{{\mathcal{L}}_{\textsc{NTRU}}, \mathbf{c}, {\sigma_{{\mathtt{sig}}}}}
6: end while 
7: s1 ‚Üê FFT-1(ÀÜs1) 
8: s ‚Üê Compress(s1) 
9: return (r, s) 
4.4 
VeriÔ¨Åcation of SOLMAE 
The last step of the scheme is thankfully simpler to describe as shown in Algo-
rithm 8. Upon receiving a signature (r, s)(r,s)and message M, the veriÔ¨Åer decompresses 
s to a polynomial s1s_1 and c = (0, H(r||M))\mathbf{c} = (0, {\mathtt{H}}(r||M)) to recover the full signature vector 
v = (s1, s2)\mathbf{v} =(s_1, s_2). If  v\mathbf{v}is a valid signature, the veriÔ¨Åcation identity is (h, ‚àí1) ¬∑ (c ‚àív) =
‚àíH(r||M) ‚àíhs1 + s2 mod q = 0(h, -1)\cdot (\mathbf{c}-\mathbf{v}) = -{\mathtt{H}}(r||M) -hs_1+s_2 \bmod q = 0, or equivalently the veriÔ¨Åer can compute 
s_2 = {\mathtt{H}}(r||M) + hs_1 \bmod q. s2 = H(r||M) + hs1 mod q.
This is computed in the ring Rq R_q, and can be performed very efÔ¨Åciently for a good 
choice of modulus q using the Number Theoretic Transform (NTT). We currently 
follow the standard choice (as in FALCON) of q = 12,289q=12{,}289, as the multiplication in 
NTT format amounts to d integer multiplications in Z/qZ{\mathbb{Z}}/q{\mathbb{Z}}. The last step is to check 
that ‚Äñ(s1, s2)‚Äñ2 ‚â§Œ≥ 2\|(\mathbf{s}_1, \mathbf{s}_2)\|^2 \leq {\gamma}^2: the signature is only accepted in this case. 
The rejection bound Œ≥ {\gamma}comes from the expected length of vectors outputted by 
Sample. Since they are morally Gaussian, they concentrate around their standard 
deviation; a ‚Äúslack‚Äù parameter œÑ = 1.042\tau = 1.042is tuned to ensure that 90%90\%of the vectors 
generated by Sample will pass through the loop: 
\gamma = \tau\cdot \sigma_{\mathtt{sig}}\cdot \sqrt{2d}. Œ≥ = œÑ ¬∑ œÉsig ¬∑
‚àö
2d.

4.4
VeriÔ¨Åcation of SOLMAE
25
Algorithm 8 Verif of SOLMAE 
Input: A signature (r, s) on M, a public key pk = h, a bound Œ≥ . 
Output: Accept or reject. 
1: s1 ‚Üê Decompress(s); 
2: c ‚ÜêH(r||M); 
3: s2 ‚Üê c + hs1 mod q; 
4: if ‚Äñ(s1, s2)‚Äñ2 > Œ≥  2 then 
5:
return Reject. 
6: else 
7:
return Accept. 
8: end if 

Chapter 5 
Basics of Python 
5.1 
Python Programming Language 
Python Programming Language, simply Python, is a high-level, interpreted pro-
gramming language known for its simplicity and readability. Created by Guido van 
Rossum in the late 1980s, Python has become one of the most popular programming 
languages, used across various domains, including web development, scientiÔ¨Åc 
computing, data analysis, artiÔ¨Åcial intelligence, and more. 
1. Key Features: 
‚Ä¢ 
Clear and Readable Syntax: Python‚Äôs simple, easy-to-learn syntax emphasizes 
readability, making it an excellent choice for beginners and reducing the cost 
of program maintenance. 
‚Ä¢ 
Dynamic Typing and Binding: These features allow Python to be highly 
Ô¨Çexible and suitable for rapid application development. 
‚Ä¢ 
Modularity and Code Reuse: Python supports modules and packages, encour-
aging program modularity and code reuse. 
‚Ä¢ 
Extensive Standard Library: Python comes with a vast standard library, 
providing tools and functionalities for virtually every task, with additional 
third-party modules available. 
‚Ä¢ 
Cross-Platform: Python code can run on different platforms without modiÔ¨Å-
cation, making it highly portable. Multiple Programming Paradigms: Python 
supports object-oriented, procedural, and functional programming styles, 
allowing developers to choose the best approach for their project. 
‚Ä¢ 
Exception-Based Error Handling: Python handles errors by raising excep-
tions, which makes debugging easier. A source-level debugger allows inspec-
tion of variables, setting breakpoints, and stepping through code. 
¬© The Author(s), under exclusive license to Springer Nature Switzerland AG 2025 
K. Kim, Practical Post-Quantum Signatures, SpringerBriefs in Information Security 
and Cryptography, https://doi.org/10.1007/978-3-031-81250-7_5
27

28
5
Basics of Python
‚Ä¢ 
Embeddable: Python can be embedded within applications as a scripting 
interface, adding Ô¨Çexibility to larger systems. Extensibility: Python can be 
extended with modules written in C, C++, Java (for Jython), or .NET 
languages (for IronPython). 
2. Productivity: Python‚Äôs fast edit-test-debug cycle enhances productivity. Since 
there is no compilation step, developers can quickly iterate on their code. 
Debugging is straightforward, and Python‚Äôs introspective capabilities allow 
developers to inspect and manipulate objects at runtime. 
3. Popular Frameworks and Libraries: 
‚Ä¢ 
Web Development: Flask and Django are popular frameworks for building 
web applications. 
‚Ä¢ 
ScientiÔ¨Åc Computing and Data Analysis: NumPy and Pandas are widely used 
for data manipulation and analysis. 
‚Ä¢ 
ArtiÔ¨Åcial Intelligence and Machine Learning: Libraries like TensorFlow, 
Keras, and PyTorch make Python a popular choice in AI/ML domains. 
In conclusion, Python‚Äôs simplicity, Ô¨Çexibility, and extensive library support make 
it a powerful language for a wide range of tasks, appealing to both beginners and 
experienced developers alike. 
5.2 
Python Environment for Windows OS 
You can download Visual Studio Code (or your favourable IDE application) 
for your platform-Windows OS 10 or 11, Debian, Ubuntu, or macOS 10.15+‚Äî 
from https://code.visualstudio.com/download. The installation process is straight-
forward; simply follow the provided instructions. Similarly to set up Visual 
Studio Code, unzip the VSCode-win32-arm64-1.92.2.zip archive (unpacked 
size: 391,456,013 bytes) and install it in your desired folder at your computer. It 
is convenient to install WSL (Windows Subsystem for Linux) at your personal 
computer working Windows OS to verify your program working Windows and 
Unix OS‚Äôs at one platform. WSL allows developers to use Linux command-line 
tools and utilities alongside Windows applications, making it easier to work in a 
Linux environment for tasks such as software development, system administration, 
and more, without leaving Windows ecosystem. It is better to install WSL 2.0 
which was introduced in 2019 and offers better compatibility with Linux software,

5.3
Useful Python Packages
29
Fig. 5.1 Screen capture of Visual Studio Code 
faster Ô¨Åle I/O performance, and full system call compatibility. For Unix or MacOS 
platform, it is also easy to set up Python environment. Fig. 5.1 shows the execution 
screen of Visual Studio Code on Windows 10. The leftmost window displays the 
Ô¨Åle folder information, the upper-right window shows the editing screen for the 
selected executable Ô¨Åle, and the lower-right window displays the execution terminal. 
In this screen, the Ô¨Åle test_merge_and_split.py is being run with Python 
3.8.9, and the lower-right window shows the execution results by displaying its 
outcome of Ô¨Åve test cases. Its details are described at Sect. 6.1.1. This setup makes 
it incredibly convenient to edit and execute your Python scripts directly on your 
personal computer. 
5.3 
Useful Python Packages 
To view the necessary packages installed, use the command pip install list in 
Microsoft Visual Studio Code, which will display the installed packages, as shown 
in Fig. 5.2. For example, you may need to install packages such as numpy.

30
5
Basics of Python
Fig. 5.2 Installed packages in my PC environment

Chapter 6 
Checking FALCON with Python 
https://github.com/tprest/falcon.py contains an implementation of the FALCON 
post-quantum cryptographic signature scheme in Python at github repository. This 
repository contains the following Ô¨Åles (roughly in order of dependency): 
1. common.py contains shared functions and constants 
2. encoding.py contains compression and decompression 
3. rng.py implements a ChaCha20-based PRNG, useful for KATs (standalone) 
4. samplerz.py implements a Gaussian sampler over the integers (standalone) 
5. fft_constants.py contains precomputed constants used in the FFT 
6. ntt_constants.py contains precomputed constants used in the NTT 
7. fft.py implements the FFT over R[x]/(xn + 1)R[x] / (x^n + 1)
8. ntt.py implements the NTT over Zq[x]/(xn + 1)Z_q[x] / (x^n + 1)
9. ntrugen.py generate polynomials f, g, F, Gf,g,F,Gin Z[x]/(xn + 1)Z[x] / (x^n + 1)such that f ¬∑
G ‚àíg ¬∑ F = qf\cdot G - g \cdot F = q
10. ffsampling.py implements the fast Fourier sampling algorithm 
11. falcon.py implements FALCON 
12. test.py implements tests to check that everything is properly implemented 
Under ..\scripts folder contains some Ô¨Åles that are helpful to implement 
FALCON, test it and understand where parameters/constants come from. This 
repository contains the following Ô¨Åles: 
1. generate_constants.sage can be used in SageMath to generate the FFT and 
NTT constants. 
2. parameters.py is a script that generates parameters used in the Round 3 
speciÔ¨Åcation as well as the C implementation. 
3. saga.py contains the SAGA (Statistically Acceptable GAussians) test [17] suite 
to test Gaussian samplers. It is used in test.py. 
4. samplerz_KAT512.py and samplerz_KAT1024.py contain test vectors for the 
sampler over the integers. They are used in test.py. 
¬© The Author(s), under exclusive license to Springer Nature Switzerland AG 2025 
K. Kim, Practical Post-Quantum Signatures, SpringerBriefs in Information Security 
and Cryptography, https://doi.org/10.1007/978-3-031-81250-7_6
31

32
6
Checking FALCON with Python
5. sign_KAT.py contains test vectors for the signing procedure. It is used in 
test.py. 
To execute generate_constants.sage, familiarity with the SageMath pro-
gramming language (https://www.sagemath.org) is required, which is beyond the 
scope of this monograph. For further details, please consult the appropriate refer-
ences. 
6.1 
Utility Modules for FALCON 
6.1.1 
Checking common.py 
The Python script in Script 6.1 is commonly used in other Python scripts when 
implementing FALCON or SOLMAE. The modular value q is Ô¨Åxed at 12,289 
but can be adjusted based on your speciÔ¨Åc application. Since FALCON employs 
polynomial arithmetic, the script enables splitting a polynomial into two equal 
parts and merging them back into a single polynomial, as shown in Script 6.1. The  
sqnorm(v) deÔ¨Ånition in common.py is not required for this test. 
1 
"""Contains methods and objects which are reused through 
multiple files.""" 
2 
"""q is the integer modulus which is used in Falcon.""" 
3 
q = 12 * 1024 + 1 
4 
def split(f): 
5
"""Split a polynomial f in two polynomials. 
6
Args: 
7
f: a polynomial 
8
Format: coefficient 
9
""" 
10
n =  len(f) 
11
f0  = [f[2  *  i +  0]  for i in range(n // 2)] 
12
f1  = [f[2  *  i +  1]  for i in range(n // 2)] 
13
return [f0, f1] 
14 
def merge(f_list): 
15
"""Merge two polynomials into a single polynomial f. 
16
Args: 
17
f_list: a list of polynomials 
18
Format: coefficient 
19
""" 
20
f0, f1 = f_list 
21
n = 2 *  len(f0) 
22
f =  [0]  * n  
23
for i in range(n // 2): 
24
f[2 *  i  +  0] = f0[i]  
25
f[2 *  i  +  1] = f1[i]  
26
return f 
27 
def sqnorm(v): 
28
"""Compute the square euclidean norm of the vector v."""

6.1
Utility Modules for FALCON
33
29
res = 0 
30
for elt in v: 
31
for coef in elt: 
32
res += coef ** 2 
33
return res 
Script 6.1 Script of test_split_and_merge() 
To verify the correctness of the split(f) and merge(f_list) functions 
shown in Script 6.1, you can run the test Python script provided in Script 6.2. 
This script checks four test cases with varying polynomial degrees to ensure 
proper functionality. The Python script can be executed in your environment as 
test_split_and_merge() function runs automatically under 
if __name__ == "__main__":. 
1 
def test_split_and_merge(): 
2
# Test case 1: Polynomial with even number of coefficients 
3
f1 = [3, 2, 1, 4, 5, 6] 
# Represents 3x^5 + 2x^4 + 1x^3 + 
4x^2 + 5x +6 
4
split_f1 = split(f1) 
5
merged_f1 = merge(split_f1) 
6
print("Test 1 - Original:", f1,  "-> Split:", split_f1 , "-> 
Merged:", merged_f1) 
7
# Check if merged is equal to original 
8
assert f1 == merged_f1 , "Test 1 failed: Merged one does not 
match the original" 
9
# Test case 2: Polynomial with odd number of coefficients 
10
f2 = [4, 2, 5, 7, 9, 11] 
# Represents 4x^5 + 2X^4+ 5x^3 + 
7x^2  + 9x +  11  
11
split_f2 = split(f2) 
12
merged_f2 = merge(split_f2) 
13
print("Test 2 - Original:", f2,  "-> Split:", split_f2 , "-> 
Merged:", merged_f2) 
14
# Check if merged is equal to original 
15
assert f2 == merged_f2 , "Test 2 failed: Merged one does not 
match the original" 
16
# Test case 3: Polynomial with minimal length 
17
f3 = [1, 2] 
# Represents 1x + 2 
18
split_f3 = split(f3) 
19
merged_f3 = merge(split_f3) 
20
print("Test 3 - Original:", f3,  "-> Split:", split_f3 , "-> 
Merged:", merged_f3) 
21
# Check if merged is equal to original 
22
assert f3 == merged_f3 , "Test 3 failed: Merged one does not 
match the original" 
23
# Test case 4: Empty polynomial 
24
f4 = [] 
# Represents an empty polynomial 
25
split_f4 = split(f4) 
26
merged_f4 = merge(split_f4) 
27
print("Test 4 - Original:", f4,  "-> Split:", split_f4 , "-> 
Merged:", merged_f4) 
28
# Check if merged is equal to original

34
6
Checking FALCON with Python
29
assert f4 == merged_f4 , "Test 4 failed: Merged one does not 
match the original" 
30
print("All tests passed!") 
31 
if __name__ =="__main__": 
32 
# Run the test case function 
33
test_split_and_merge() 
Script 6.2 test_split_and_merge.py 
Fig. 6.1 Output of test_split_and_merge() 
After executingtest_split_and_merge_test.py as shown in Script 6.2, the  
result obtained are displayed in Fig. 6.1. These results indicate that all four cases 
are working correctly by splitting and merging a given polynomial. 
6.1.2 
Checking fft.py 
In order to perform FFT (Fast Fourier Transform) and IFFT (Inverse Fast Fourier 
Transform), which reduce the complexity of polynomial multiplication from O(n2)O(n^2), 
as in the schoolbook method, to O(n log n)O(n\log n), we need to split and merge polynomials 
with real and complex values shown in Script 6.3 that we have once Ô¨Ånished to check 
before. 
1 
def split_fft(f_fft): 
2
"""Split a polynomial f in two polynomials. 
3
Args: 
4
f: a polynomial 
5
Format: FFT 
6
Corresponds to algorithm 1 (splitfft_2) of Falcon‚Äôs 
documentation. 
7
""" 
8
n =  len(f_fft) 
9
w = roots_dict[n] 
10
f0_fft = [0] * (n // 2) 
11
f1_fft = [0] * (n // 2) 
12
for i in range(n // 2): 
13
f0_fft[i] = 0.5 * (f_fft[2 * i] + f_fft[2 * i + 1]) 
14
f1_fft[i] = 0.5 * (f_fft[2 * i] - f_fft[2 * i + 1]) * 
w[2 * i].conjugate()

6.1
Utility Modules for FALCON
35
15
return [f0_fft, f1_fft] 
16 
17 
def merge_fft(f_list_fft): 
18
"""Merge two or three polynomials into a single polynomial f. 
19
Args: 
20
f_list: a list of polynomials 
21
Format: FFT 
22
Corresponds to algorithm 2 (mergefft_2) of Falcon‚Äôs 
documentation. 
23
""" 
24
f0_fft, f1_fft = f_list_fft 
25
n = 2 *  len(f0_fft) 
26
w = roots_dict[n] 
27
f_fft = [0] * n 
28
for i in range(n // 2): 
29
f_fft[2 * i + 0] = f0_fft[i] + w[2 * i] * f1_fft[i] 
30
f_fft[2 * i + 1] = f0_fft[i] - w[2 * i] * f1_fft[i] 
31
return f_fft 
Script 6.3 Functions of splitting and merging polynomials for fft.py 
Fig. 6.2 phi16_roots used in Script 6.3 for FFT 
To run Script 6.3 correctly, we need to call the computed list of the roots of 
phi_16 of x^8+1 for FFT which was precomputed by generate_constants.sage 
and stored at a part of fft_constants.py shown as Fig. 6.2. 
Script 6.4 presents the FFT and IFFT functions, which use merge_fft(), 
split_fft(), and other related functions to convert real numbers in the time 
domain into complex numbers in the frequency domain recursively, and vice versa. 
1 
def fft(f): 
2
"""Compute the FFT of a polynomial mod (x ** n + 1). 
3
Args: 
f: a polynomial 
4
Format: input as coefficients , output as FFT 
5
""" 
6
n =  len(f) 
7
if (n > 2): 
8
f0, f1 = split(f)

36
6
Checking FALCON with Python
9
f0_fft = fft(f0) 
10
f1_fft = fft(f1) 
11
f_fft = merge_fft([f0_fft, f1_fft]) 
12
elif (n == 2): 
13
f_fft = [0] * n 
14
f_fft[0] = f[0] + 1j * f[1] 
15
f_fft[1] = f[0] - 1j * f[1] 
16
return f_fft 
17 
18 
def ifft(f_fft): 
19
"""Compute the inverse FFT of a polynomial mod (x ** n + 1). 
20
Args:
f: a FFT of a polynomial 
21
Format: input as FFT, output as coefficients 
22
""" 
23
n =  len(f_fft) 
24
if (n > 2): 
25
f0_fft, f1_fft = split_fft(f_fft) 
26
f0 = ifft(f0_fft) 
27
f1 = ifft(f1_fft) 
28
f = merge([f0, f1]) 
29
elif (n == 2): 
30
f = [0] * n 
31
f[0] = f_fft[0].real 
32
f[1] = f_fft[0].imag 
33
return f 
Script 6.4 Python functions used in fft.py 
Script 6.5 presents a test program to verify the correct functioning of the FFT 
and IFFT implementations shown in Script 6.4. 
1 
from fft import fft,ifft 
2 
import numpy as np 
3 
def test_fft_ifft(): 
4
# Define a polynomial of degree 8 (which has 9 coefficients) 
5
poly = [1, 2, 3, 4, 5, 6, 7, 8] 
6
print("\nBefore FFT:") 
7
print(np.array(poly)) 
8
# Perform FFT 
9
fft_result = fft(poly) 
10
print("\nFFT Result:") 
11
print(np.array(fft_result)) 
12
# Perform IFFT 
13
ifft_result = ifft(fft_result) 
14
print("\nIFFT Result:") 
15
print(np.array(ifft_result)) 
16
# Check if IFFT result is close to original polynomial 
17
is_close = np.allclose(poly, ifft_result) 
18
print("\nTest passed:", is_close) 
19 
if __name__ =="__main__": 
20 
# Run the test 
21
test_fft_ifft() 
Script 6.5 Test program for fft.py

6.1
Utility Modules for FALCON
37
Fig. 6.3 Output of checking ftt.py 
Fig. 6.3 presents an example output from the test program, demonstrating the 
correct functionality of both FFT and IFFT. 
6.1.3 
Checking ntt.py 
Similarly to the FTT, the Number Theoretic Transform (NTT) and its inverse 
(INTT) perform various operations on polynomials in the number domain, utilizing 
modular arithmetic. The implementation details of these operations can be found in 
the ntt.py and ntt_constants.py Ô¨Åles within the FALCON Python package. 
Script 6.6 illustrates the operation of the NTT and INTT, utilizing modular 
arithmetic. It also includes a test program to verify their correctness. Fig. 6.5 
presents a test example to verify the correct functioning of the NTT and INTT. 
1 
from common import split, merge, q 
2 
from ntt_constants import roots_dict_Zq , inv_mod_q 
3 
import numpy as np 
4 
i2 = 6145 # modular inverse of 2 for a given q 
5 
sqr1 = roots_dict_Zq[2][0] 
6 
def split_ntt(f_ntt): 
7
"""Split a polynomial f in two or three polynomials.""" 
8
n =  len(f_ntt); w = roots_dict_Zq[n] 
9
f0_ntt = [0] * (n // 2); f1_ntt = [0] * (n // 2) 
10
for i in range(n // 2): 
11
f0_ntt[i] = (i2 * (f_ntt[2 * i] + f_ntt[2 * i + 1])) % q 
12
f1_ntt[i] = (i2 * (f_ntt[2 * i] - f_ntt[2 * i + 1]) * 
inv_mod_q[w[2 * i]]) % q 
13
return [f0_ntt, f1_ntt] 
14 
def merge_ntt(f_list_ntt): 
15
"""Merge two or three polynomials into a single 
polynomial.""" 
16
f0_ntt, f1_ntt = f_list_ntt

38
6
Checking FALCON with Python
17
n = 2 *  len(f0_ntt); w = roots_dict_Zq[n] 
18
f_ntt = [0] * n 
19
for i in range(n // 2): 
20
f_ntt[2 * i] = (f0_ntt[i] + w[2 * i] * f1_ntt[i]) % q 
21
f_ntt[2 * i + 1] = (f0_ntt[i] - w[2 * i] * f1_ntt[i]) % q 
22
return f_ntt 
23 
def ntt(f): 
24
"""Compute the NTT of a polynomial.""" 
25
n =  len(f) 
26
if n >  2:  
27
f0, f1 = split(f) 
28
f0_ntt = ntt(f0); f1_ntt = ntt(f1) 
29
f_ntt = merge_ntt([f0_ntt, f1_ntt]) 
30
elif n ==  2:  
31
f_ntt = [0] * n 
32
f_ntt[0] = (f[0] + sqr1 * f[1]) % q 
33
f_ntt[1] = (f[0] - sqr1 * f[1]) % q 
34
return f_ntt 
35 
def intt(f_ntt): 
36
"""Compute the inverse NTT of a polynomial.""" 
37
n =  len(f_ntt) 
38
if n >  2:  
39
f0_ntt, f1_ntt = split_ntt(f_ntt) 
40
f0 = intt(f0_ntt); f1 = intt(f1_ntt) 
41
f = merge([f0, f1]) 
42
elif n ==  2:  
43
f = [0] * n 
44
f[0] = (i2 * (f_ntt[0] + f_ntt[1])) % q 
45
f[1] = (i2 * inv_mod_q[1479] * (f_ntt[0] - f_ntt[1])) % q 
46
return f 
47 
def test_ntt_intt(): 
48
"""Test NTT and INTT functions for correctness.""" 
49
import random 
50
n = 8
# Random polynomials of length 8 (a power of 2) 
51
f = [random.randint(0, q-1) for _ in range(n)] 
52
print("\nBefore NTT:"); print(np.array(f)) 
53
# Compute NTT and then INTT 
54
f_ntt = ntt(f) 
55
print("\nNTT Result:"); print(np.array(f_ntt)) 
56
f_intt = intt(f_ntt) 
57
print("\nINTT Result:"); print(np.array(f_intt)) 
58
# Check if the INTT of NTT is the original polynomial 
59
assert f == f_intt, f"Test failed: {f} != {f_intt}" 
60
print(f"\nTest passed.") 
61 
if __name__ =="__main__": 
62 
# Run the test 
63
test_ntt_intt() 
Script 6.6 Test script for ntt.py 
To run Script 6.6 correctly, we need to call the computed list of the roots of 
phi_16 of x^8+1_Z for NTT which was precomputed by generate_constants. 
sage and stored at a part of ntt_constants.py shown as Fig. 6.4.

6.1
Utility Modules for FALCON
39
Fig. 6.4 phi16_roots used in Script 6.6 for NTT 
Fig. 6.5 Output of checking ntt.py 
6.1.4 
Checking ntrugen.py 
To generate a private signing key, two randomly generated polynomials, f and g 
are required. From these polynomials, two additional polynomials, F and G are 
derived using the extended Euclidean algorithm under the modulus q. This process 
is implemented in the function ntrugen.py, which is provided in part of the 
FALCON Python package. To verify the correctness of ntrugen.py, we developed 
a Python test script as illustrated in Script 6.7. This step can sometimes be time-
consuming. 
1 
from common import q 
2 
from fft import sub 
3 
from ntrugen import karamul , ntru_gen 
4 
import numpy as np 
5 
def polynomial_mod(a, mod): 
6
n = len(mod) 
7
result = np.polydiv(a, mod)[1] 
8
return np.round(result).astype(int).tolist() 
9 
def check_ntru_properties(f, g, F, G, q): 
10
n = len(f) 
11
x_n_plus_1 = [0] * (n + 1) 
12
x_n_plus_1[0] = 1; x_n_plus_1[n] = 1 
13
fG = karamul(f, G); gF = karamul(g, F) 
14
fG_minus_gF = sub(fG, gF) 
15
print("fG_minus_gF:") 
16
print(np.array(fG_minus_gF)) 
17
mod_result = polynomial_mod(fG_minus_gF , x_n_plus_1) 
18
q_poly = [q] + [0] * (n-1) 
19
return mod_result == q_poly 
20 
def test_ntru_gen(n): 
21
"""Test the ntru_gen function."""

40
6
Checking FALCON with Python
22
# Generate polynomials 
23
f, g, F, G = ntru_gen(n) 
24
print("f:"); print(np.array(f)) 
25
print("g:"); print(np.array(g)) 
26
print("F:"); print(np.array(F)); 
27
print("G:"); print(np.array(G)); 
28
# Check if f and g are non-zero 
29
if all(coef == 0 for coef in f) or all(coef == 0 for coef in 
g): 
30
raise AssertionError("Generated polynomials f or g are 
zero.") 
31
# Check if the NTRU property is satisfied 
32
if not check_ntru_properties(f, g, F, G, q): 
33
raise AssertionError("f * G - g  * F = q  mod(x^n+1)  is  
not satisfied.") 
34
print("NTRU generation test passed.") 
35 
if __name__ == "__main__": 
36
n =  16  # Fix polynomial degree to test 
37
test_ntru_gen(n) 
Script 6.7 Test script for ntrugen.py 
To verify the correctness of ntrugen.py, we set n = 16n=16and created a Python test 
script. This script, as shown in Fig. 6.6, generates an example set of the polynomials 
f, g, F, and Gf, g ,F, \textrm{and}\ G. 
6.1.5 
Checking encoding.py 
This section explains the correctness of the compress and decompress functions 
used to reduce the memory footprint of signature and other data, if needed. The 
deÔ¨Ånitions of compress(v,slen) and decompress(x,slen,n) functions are 
already provided in encoding.py module of FALCON Python package. Script 6.8 
Fig. 6.6 Output of checking ntrugen.py

6.1
Utility Modules for FALCON
41
illustrates the 6 test cases coded to verify the correctness of compress(v,slen) 
and decompress(x,slen,n) functions when used together. 
1 
from encoding import compress , decompress 
2 
def test_compress_decompress(): 
3
# Test cases 
4
test_cases = [ 
5
([-128, 127, 0], 5), 
# Mixed negative , positive , and 
zero values 
6
([0, 0, 0, 0], 2), 
# All zeros 
7
([1, 2, 3, 4, 5, 6, 7], 3), 
# Small positive integers 
8
([-1, -2, -3, -4, -5, -6, -7], 3), 
# Small negative 
integers 
9
([255, -255, 128, -128], 6), 
# Edge cases for low and 
high bits 
10
([32767, -32768], 6), 
# Large positive and negative 
integers 
11
] 
12
for i, (v, slen) in enumerate(test_cases): 
13
print(f"Test case {i + 1}: v = {v}, slen = {slen}") 
14
compressed = compress(v, slen) 
15
if compressed is False: 
16
print("Compression failed (encoding too long)") 
17
else: 
18
decompressed = decompress(compressed , slen, len(v)) 
19
if decompressed is False: 
20
print("Decompression failed (invalid encoding)") 
21
elif decompressed == v: 
22
print("Success! Decompressed list matches the 
original list.") 
23
else: 
24
print("Failure! Decompressed list does not match 
the original list.") 
25
print(f"Compressed data: {compressed}\nDecompressed 
data: {decompressed}") 
26
print("-" * 40) 
27 
28 
if __name__ == "__main__": 
29
test_compress_decompress() 
Script 6.8 Test program for encoding.py 
Fig. 6.7 displays the output of the six test cases after running those illustrated in 
Script 6.8. Two test cases succeeded, but other four cases failed due to encoding 
too long error. In practice, it is possible to handle longer data for compression and 
decompression.

42
6
Checking FALCON with Python
Fig. 6.7 Output of six test cases 
6.2 
FALCON-SpeciÔ¨Åc Modules 
This section outlines the speciÔ¨Åc functions and operations exclusive to both 
FALCON-512 and FALCON-1024. 
6.2.1 
Checking parameters.py 
parameters.py, located under folder ..\scripts in the FALCON Python pack-
age, is used to generate two crucial sets of security parameters for FALCON-512 
and FALCON-1024. It focuses on the parameters, metrics, and security aspects 
of these schemes. This section outlines its performance and output after executing 
parameters.py. 
Fig. 6.8 provides a summary of the key deÔ¨Ånitions related to the secure use of 
FALCON across three aspects‚ÄîParameters, Metrics and Security. All parameter 
values can be established during the setup phase and made available to authorized 
signers and veriÔ¨Åers. The values in parenthesis use the optimization in [2]. 
Fig. 6.9 illustrates the speciÔ¨Åc values of various parameters for both FALCON-
512 and FALCON-1024. Note that the value of beta and beta2beta^2 are approximated to 
the nearest integer value less than their actual values.

6.2
FALCON-SpeciÔ¨Åc Modules
43
Fig. 6.8 Description of parameters 
6.2.2 
Checking samplerz.py 
SamplerZ generates random integer according to a Gaussian distribution with the 
speciÔ¨Åed mean and standard deviation. It utilizes Basesampler(), Berexp() and 
other computations as outlined in Algorithm 15 in [9]. 
The test script for samplerz.py, shown in Script 6.9, veriÔ¨Åes whether 500 
generated random integers, with a given mean of 0 and a standard deviation of 2.0, 
conform to the ideal Gaussian distribution. 
1 
from samplerz import samplerz 
2 
import numpy as np 
3 
import matplotlib.pyplot as plt 
4 
from scipy.stats import norm 
5 
6 
def test_samplerz(): 
7
mu = 0.0
# Mean of the distribution 
8
sigma = 2.0 
# Standard deviation 
9
sigmin = 1.5 # sigmin scaling factor (must be 1 < sigmin < 
sigma < MAX_SIGMA) 
10 
11
# Run the sampler multiple times to generate samples 
12
samples = [samplerz(mu, sigma, sigmin) for _ in range(500)] 
13
# Print out the first few samples

44
6
Checking FALCON with Python
Fig. 6.9 SpeciÔ¨Åc values of various parameters for both FALCON-512 and FALCON-1024

6.2
FALCON-SpeciÔ¨Åc Modules
45
14
print("First 15 generated integers: ", f"{samples[:15]} 
...]") 
15 
16
# Calculate sample mean and sample standard deviation 
17
sample_mean = np.mean(samples) 
18
sample_std = np.std(samples) 
19 
20
# Generate a range of values for the theoretical Gaussian 
distribution 
21
x_values = np.linspace(min(samples), max(samples), 1000) 
22 
23
# Calculate the Gaussian probability density function (PDF) 
for comparison 
24
gaussian_pdf = norm.pdf(x_values , loc=mu, scale=sigma) 
25 
26
# Plot the histogram of the samples and overlay the 
theoretical Gaussian curve 
27
plt.figure(figsize=(8, 6)) 
28
plt.hist(samples , bins=20, density=True, edgecolor=‚Äôblack‚Äô, 
alpha=0.7, label=‚ÄôSample Histogram‚Äô) 
29
plt.plot(x_values , gaussian_pdf , ‚Äôr-‚Äô, label=‚ÄôTheoretical 
Gaussian PDF‚Äô, linewidth=2) 
30
plt.title(‚ÄôComparison of Sample Distribution with Gaussian 
Distribution‚Äô) 
31
plt.xlabel(‚ÄôSample Value‚Äô); plt.ylabel(‚ÄôDensity‚Äô) 
32
plt.legend(); plt.grid(True); plt.show() 
33 
34
# Print the sample mean and standard deviation 
35
print(f‚ÄôSample Mean: {sample_mean}‚Äô) 
36
print(f‚ÄôSample Standard Deviation: {sample_std}‚Äô) 
37 
38 
if __name__ == "__main__": 
39
test_samplerz() 
40 
print("\nTest passed:") 
Script 6.9 Test program for samplerz.py 
Fig. 6.10 presents the Ô¨Årst 10 generated integers following a Gaussian distribu-
tion, making it challenging to visually determine the underlying distribution. 
To compare the generated random integers with the ideal Gaussian distribution, 
which has a mean of 0.21 and a standard deviation of 1.870, Fig. 6.11 illustrates the 
comparison. The generated values appear consistent with the Gaussian distribution 
for the speciÔ¨Åed parameters. Since each test generates different random integers, the 
Fig. 6.10 Output of test_samplerz

46
6
Checking FALCON with Python
Fig. 6.11 Comparison of generated random integers with ideal Gaussian 
Ô¨Ågure will vary with each run. Sometimes the test fails. If this happens, retrying it 
might produce the desired result. 
6.2.3 
Checking ffnp() in ffsampling.py 
This section describes to test the correctness of ffnp() function used in  
ffsampling.py which samples the random value close to the theoretical bound in 
a Fourier domain. This is unique idea used in FALCON. Script 6.10 shows its test 
script in Python. 
1 
""" 
2 
This file tests ffnp() function used at ffsampling.py in Falcon 
Python package. 
3 
""" 
4 
from common import q, sqnorm 
5 
from fft import add, sub, mul, div, neg, fft, ifft 
6 
from ffsampling import ffldl, ffldl_fft , ffnp, ffnp_fft 
7 
from ffsampling import gram 
8 
from random import randint , random, gauss, uniform 
9 
from ntrugen import karamul , ntru_gen , gs_norm 
10 
from scripts.sign_KAT import sign_KAT 
11 
def vecmatmul(t, B): 
12
"""Compute the product t * B, where t is a vector and B is a 
square matrix. 
13
Args:

6.2
FALCON-SpeciÔ¨Åc Modules
47
14
B: a matrix 
15
Format: coefficient 
16
""" 
17
nrows = len(B) 
18
ncols = len(B[0]) 
19
deg = len(B[0][0]) 
20
assert(len(t) == nrows) 
21
v = [[0 for k in range(deg)] for j in range(ncols)] 
22
for j in range(ncols): 
23
for i in range(nrows): 
24
v[j] = add(v[j], mul(t[i], B[i][j])) 
25
return v 
26 
def test_ffnp(n, iterations): 
27
"""Test ffnp. 
28
This functions check that: 
29
1. the two versions (coefficient and FFT embeddings) of ffnp 
are consistent 
30
2. ffnp output lattice vectors close to the targets. 
31
""" 
32
f = sign_KAT[n][0]["f"] 
33
g = sign_KAT[n][0]["g"] 
34
F = sign_KAT[n][0]["F"] 
35
G = sign_KAT[n][0]["G"] 
36
B = [[g, neg(f)], [G, neg(F)]] 
37
G0 = gram(B) 
38
G0_fft = [[fft(elt) for elt in row] for row in G0] 
39
T = ffldl(G0) 
40
T_fft = ffldl_fft(G0_fft) 
41
sqgsnorm = gs_norm(f, g, q) 
42
m = 0  
43
for i in range(iterations): 
44
t = [[random() for i in range(n)], [random() for i in 
range(n)]] 
45
t_fft = [fft(elt) for elt in t] 
46
z = ffnp(t, T) 
47
z_fft = ffnp_fft(t_fft, T_fft) 
48
zb = [ifft(elt) for elt in z_fft] 
49
zb = [[round(coef) for coef in elt] for elt in zb] 
50
if z !=  zb:  
51
print("ffnp and ffnp_fft are not consistent") 
52
return False 
53
diff = [sub(t[0], z[0]), sub(t[1], z[1])] 
54
diffB = vecmatmul(diff, B) 
55
norm_zmc = int(round(sqnorm(diffB))) 
56
m =  max(m, norm_zmc) 
57
th_bound = (n / 4.) * sqgsnorm 
58
if m > th_bound: 
59
print("Warning: ffnp does not output vectors as short as 
expected") 
60
return False 
61
else: 
62
print("m={}, th_bound={:.3f}".format(m, th_bound)) 
63
print("ffnp output vectors as short as expected since m 
<= th_bound")

48
6
Checking FALCON with Python
64
return True 
65 
if __name__ == "__main__": 
66
n = 512 
# select Falcon -512 or Falcon -1024 
67
cases = 5 # Number of tests 
68
print("** Testing ffNP of Falcon-",n) 
69
for i in range(cases): 
70
print("\n<< Test Case :", i+1,">>") 
71
test_ffnp(n,i) 
72 
print("\nTest passed:") 
Script 6.10 Test program for ffnp() 
Fig. 6.12 Output of 5 ffnp() tests for FALCON-512 
The value of n is Ô¨Åxed at 512 or 1024 depending on which version of FALCON 
you are testing. Figs. 6.12 and 6.13 show the printout for 5 test cases ffnp() 
function used for FALCON-512 and FALCON-1024, respectively. 
6.2.4 
Checking falcon.py 
This section describes the correctness of executing FALCON-512 and FALCON-
1024 from the predetermined polynomials, f, g, F, and Gf,g, F, and\ G which is provided as 
falcon.py in the FALCON Python package simply. The test script is listed as 
Script 6.11. The  value of  n is Ô¨Åxed at 512 or 1024 depending on which version of 
FALCON you are verifying.

6.2
FALCON-SpeciÔ¨Åc Modules
49
Fig. 6.13 Output of 5 ffnp() tests for FALCON-1024 
1 
from common import q 
2 
from falcon import SecretKey , PublicKey 
3 
from scripts.sign_KAT import sign_KAT 
4 
5 
import random 
6 
import string 
7 
8 
# Function to generate a random message 
9 
def generate_random_message(length=26): 
10
letters = string.ascii_lowercase 
# Lowercase letters a-z 
11
message = ‚Äô‚Äô.join(random.choice(letters) for i in 
range(length)) 
12
return message.encode() 
# Encoding the message as bytes 
13 
14 
def test_f_signature(n, iterations=1): 
15
f = sign_KAT[n][0]["f"] 
16
g = sign_KAT[n][0]["g"] 
17
F = sign_KAT[n][0]["F"] 
18
G = sign_KAT[n][0]["G"] 
19 
20
sk = SecretKey(n, [f, g, F, G]) 
21
print("== Leading 10 values of private key") 
22
print("f = ".ljust(3) + "[" + ", ".join(["{}".format(x) for 
x in f[:10]]) + ", ...]") 
23
print("g = ".ljust(3) + "[" + ", ".join(["{}".format(x) for 
x in g[:10]]) + ", ...]") 
24
print("F = ".ljust(3) + "[" + ", ".join(["{}".format(x) for 
x in F[:10]]) + ", ...]") 
25
print("G = ".ljust(3) + "[" + ", ".join(["{}".format(x) for 
x in G[:10]]) + ", ...]")

50
6
Checking FALCON with Python
26 
27
pk = PublicKey(sk) 
28
print("== Leading 10 values of public key",) 
29
print("h = ".ljust(3) + "[" + ", ".join(["{}".format(x) for 
x in pk.h[:10]]) + ", ...]") 
30 
31
for i in range(iterations): 
32
message = generate_random_message() 
33
print("Messge 
= ",str(message)) 
34 
35
sig = sk.sign(message); sig_str= sig.hex() 
36
print("Signature =", sig_str[:30], ‚Äô...‚Äô, sig_str[-20:]) 
37
print("Length of Signature:", 
int(len(sig_str)/2),"Bytes"); 
38 
39
if (pk.verify(message , sig)== True): 
40
print("Verification passed!!") 
41
else: 
42
print("Verification failed!!") 
43
return False 
44
return True 
45 
if __name__ == "__main__": 
46
n = 512
# select Falcon -512 or Falcon -1024 
47
cases = 3 # Number of tests 
48
print("** Testing keygen, sign and verify procedures of 
Falcon-",n) 
49
for i in range(cases): 
50
print("\n<< Test Case :", i+1,">>") 
51
test_f_signature(n,i) # degree of cyclotomic poly. 
(power of 2) 
52 
print("\nTest passed:") 
Script 6.11 Test script for falcon.py 
By setting the value of n at line 46 of Script 6.11 at 512 or 1024, Figs. 6.14 
and 6.15 present three examples of built-in key pairs, a random message, its 
signature in hexadecimal notation, the veriÔ¨Åcation of signature for FALCON-512 
and FALCON-1024, respectively. 
6.2.5 
Checking test.py 
This section discusses the results of test.py provided in the FALCON Python 
package. Fig. 6.16 shows the speciÔ¨Åcations of the computer used in executing 
test.py, with the full Python script available in the FALCON Python package. 
1 
from common import q, sqnorm 
2 
from fft import add, sub, mul, div, neg, fft, ifft 
3 
from ntt import mul_zq, div_zq 
4 
from samplerz import samplerz , MAX_SIGMA 
5 
from ffsampling import ffldl, ffldl_fft , ffnp, ffnp_fft

6.2
FALCON-SpeciÔ¨Åc Modules
51
Fig. 6.14 Three examples of key pairs and signature executing FALCON-512

52
6
Checking FALCON with Python
Fig. 6.15 Three examples of key pairs and signature executing FALCON-1024 
Fig. 6.16 SpeciÔ¨Åcation of my test computer used in test.py

6.2
FALCON-SpeciÔ¨Åc Modules
53
6 
from ffsampling import gram 
7 
from random import randint , random, gauss, uniform 
8 
from math import sqrt, ceil 
9 
from ntrugen import karamul , ntru_gen , gs_norm 
10 
from falcon import SecretKey , PublicKey , Params 
11 
from falcon import SALT_LEN , HEAD_LEN , SHAKE256 
12 
from encoding import compress , decompress 
13 
from scripts import saga 
14 
from scripts.samplerz_KAT512 import sampler_KAT512 
15 
from scripts.sign_KAT import sign_KAT 
16 
from scripts.samplerz_KAT1024 import sampler_KAT1024 
17 
# https://stackoverflow.com/a/25823885/4143624 
18 
from timeit import default_timer as timer 
19 
20 
def vecmatmul(t, B): 
21
"""Compute the product t * B, where t is a vector and B is a 
square matrix. 
22 
23
Args: 
24
B: a matrix 
25 
26
Format: coefficient 
27
""" 
28
nrows = len(B) 
29
ncols = len(B[0]) 
30
deg = len(B[0][0]) 
31
assert(len(t) == nrows) 
32
v = [[0 for k in range(deg)] for j in range(ncols)] 
33
for j in range(ncols): 
34
for i in range(nrows): 
35
v[j] = add(v[j], mul(t[i], B[i][j])) 
36
return v 
37 
38 
def test_fft(n, iterations=10): 
39
"""Test the FFT.""" 
40
for i in range(iterations): 
41
f = [randint(-3, 4) for j in range(n)] 
42
g = [randint(-3, 4) for j in range(n)] 
43
h =  mul(f, g)  
44
k =  div(h, f)  
45
k = [int(round(elt)) for elt in k] 
46
if k != g:  
47
print("(f * g) / f =", k)  
48
print("g =", g)  
49
print("mismatch") 
50
return False 
51
return True 
52 
53 
def test_ntt(n, iterations=10): 
54
"""Test the NTT.""" 
55
for i in range(iterations): 
56
f = [randint(0, q - 1) for j in range(n)] 
57
g = [randint(0, q - 1) for j in range(n)] 
58
h = mul_zq(f, g)

54
6
Checking FALCON with Python
59
try: 
60
k = div_zq(h, f) 
61
if k != g:  
62
print("(f * g) / f =", k)  
63
print("g =", g)  
64
print("mismatch") 
65
return False 
66
except ZeroDivisionError: 
67
continue 
68
return True 
69 
70 
71 
def check_ntru(f, g, F, G): 
72
"""Check that f * G - g * F = q  mod  (x  **  n +  1)."""  
73
a = karamul(f, G) 
74
b = karamul(g, F) 
75
c = [a[i] - b[i] for i in range(len(f))] 
76
return ((c[0] == q) and all(coef == 0 for coef in c[1:])) 
77 
78 
def test_ntrugen(n, iterations=10): 
79
"""Test ntru_gen.""" 
80
for i in range(iterations): 
81
f, g, F, G = ntru_gen(n) 
82
if check_ntru(f, g, F, G) is False: 
83
return False 
84
return True 
85 
86 
def test_ffnp(n, iterations): 
87
"""Test ffnp. 
88 
89
This functions check that: 
90
1. the two versions (coefficient and FFT embeddings) of ffnp 
are consistent 
91
2. ffnp output lattice vectors close to the targets. 
92
""" 
93
f = sign_KAT[n][0]["f"] 
94
g = sign_KAT[n][0]["g"] 
95
F = sign_KAT[n][0]["F"] 
96
G = sign_KAT[n][0]["G"] 
97
B = [[g, neg(f)], [G, neg(F)]] 
98
G0 = gram(B) 
99
G0_fft = [[fft(elt) for elt in row] for row in G0] 
100
T = ffldl(G0) 
101
T_fft = ffldl_fft(G0_fft) 
102
sqgsnorm = gs_norm(f, g, q) 
103
m = 0  
104
for i in range(iterations): 
105
t = [[random() for i in range(n)], [random() for i in 
range(n)]] 
106
t_fft = [fft(elt) for elt in t] 
107
z = ffnp(t, T) 
108
z_fft = ffnp_fft(t_fft, T_fft) 
109 
110
zb = [ifft(elt) for elt in z_fft]

6.2
FALCON-SpeciÔ¨Åc Modules
55
111
zb = [[round(coef) for coef in elt] for elt in zb] 
112
if z !=  zb:  
113
print("ffnp and ffnp_fft are not consistent") 
114
return False 
115
diff = [sub(t[0], z[0]), sub(t[1], z[1])] 
116
diffB = vecmatmul(diff, B) 
117
norm_zmc = int(round(sqnorm(diffB))) 
118
m =  max(m, norm_zmc) 
119
th_bound = (n / 4.) * sqgsnorm 
120
if m > th_bound: 
121
print("Warning: ffnp does not output vectors as short as 
expected") 
122
return False 
123
else: 
124
return True 
125 
126 
def test_compress(n, iterations): 
127
"""Test compression and decompression.""" 
128
try: 
129
sigma = 1.5 * sqrt(q) 
130
slen = Params[n]["sig_bytelen"] - SALT_LEN - HEAD_LEN 
131
except KeyError: 
132
return True 
133
for i in range(iterations): 
134
while(1): 
135
initial = [int(round(gauss(0, sigma))) for coef in 
range(n)] 
136
compressed = compress(initial , slen) 
137
if compressed is not False: 
138
break 
139
decompressed = decompress(compressed , slen, n) 
140
if decompressed != initial: 
141
return False 
142
return True 
143 
144 
def test_samplerz(nb_mu=100, nb_sig=100, nb_samp=1000): 
145
""" 
146
Test our Gaussian sampler on a bunch of samples. 
147
This is done by using a light version of the SAGA test suite, 
148
see ia.cr/2019/1411. 
149
""" 
150
# Minimal size of a bucket for the chi-squared test (must be 
>= 5) 
151
chi2_bucket = 10 
152
assert(nb_samp >= 10 * chi2_bucket) 
153
sigmin = 1.3 
154
nb_rej = 0 
155
for i in range(nb_mu): 
156
mu = uniform(0, q) 
157
for j in range(nb_sig): 
158
sigma = uniform(sigmin, MAX_SIGMA) 
159
list_samples = [samplerz(mu, sigma, sigmin) for _ in 
range(nb_samp)] 
160
v = saga.UnivariateSamples(mu, sigma, list_samples)

56
6
Checking FALCON with Python
161
if (v.is_valid is False): 
162
nb_rej += 1 
163
return True 
164
if (nb_rej > 5 * ceil(saga.pmin * nb_mu * nb_sig)): 
165
return False 
166
else: 
167
return True 
168 
169 
170 
def KAT_randbytes(k): 
171
""" 
172
Use a fixed bytestring ‚Äôoctets‚Äô as a source of random bytes 
173
""" 
174
global octets 
175
oc = octets[: (2 * k)] 
176
if len(oc) != (2 * k): 
177
raise IndexError("Randomness string out of bounds") 
178
octets = octets[(2 * k):] 
179
return bytes.fromhex(oc)[::-1] 
180 
181 
def test_samplerz_KAT(unused, unused2): 
182
# octets is a global variable used as samplerz‚Äôs randomness. 
183
# It is set to many fixed values by test_samplerz_KAT , 
184
# then used as a randomness source via KAT_randbits. 
185
global octets 
186
for D in sampler_KAT512 + sampler_KAT1024: 
187
mu = D["mu"] 
188
sigma = D["sigma"] 
189
sigmin = D["sigmin"] 
190
# Hard copy. octets is the randomness source for samplez 
191
octets = D["octets"][:] 
192
exp_z = D["z"] 
193
try: 
194
z = samplerz(mu, sigma, sigmin, 
randombytes=KAT_randbytes) 
195
except IndexError: 
196
return False 
197
if (exp_z != z): 
198
print("SamplerZ does not match KATs") 
199
return False 
200
return True 
201 
202 
def test_signature(n, iterations=10): 
203
""" 
204
Test Falcon. 
205
""" 
206
f = sign_KAT[n][0]["f"] 
207
g = sign_KAT[n][0]["g"] 
208
F = sign_KAT[n][0]["F"] 
209
G = sign_KAT[n][0]["G"] 
210
sk = SecretKey(n, [f, g, F, G]) 
211
pk = PublicKey(sk) 
212
for i in range(iterations): 
213
message = b"abc"

6.2
FALCON-SpeciÔ¨Åc Modules
57
214
sig = sk.sign(message) 
215
if pk.verify(message , sig) is False: 
216
return False 
217
return True 
218 
219 
def test_sign_KAT(): 
220
""" 
221
Test the signing procedure against test vectors obtained from 
222
the Round 3 implementation of Falcon. 
223 
224
Starting from the same private key, same message , and same 
SHAKE256 
225
context (for randomness generation), we check that we obtain 
the 
226
same signatures. 
227
""" 
228
message = b"data1" 
229
shake = SHAKE256.new(b"external") 
230
for n in sign_KAT: 
231
sign_KAT_n = sign_KAT[n] 
232
for D in sign_KAT_n: 
233
f = D["f"] 
234
g = D["g"] 
235
F = D["F"] 
236
G = D["G"] 
237
sk = SecretKey(n, [f, g, F, G]) 
238
# The next line is done to synchronize the SHAKE256 
context 
239
# with the one in the Round 3 C implementation of 
Falcon. 
240
_ = shake.read(8 * D["read_bytes"]) 
241
sig = sk.sign(message , shake.read) 
242
if sig != bytes.fromhex(D["sig"]): 
243
return False 
244
return True 
245 
246 
def wrapper_test(my_test , name, n, iterations): 
247
""" 
248
Common wrapper for tests. Run the test, print whether it is 
successful , 
249
and if it is, print the running time of each execution. 
250
""" 
251
d = {True: "OK
", False: "Not OK"} 
252
start = timer() 
253
rep = my_test(n, iterations) 
254
end = timer() 
255
message = "Test {name}".format(name=name) 
256
message = message.ljust(20) + ": " + d[rep] 
257
if rep is True: 
258
diff = end - start 
259
msec = round(diff * 1000 / iterations , 3) 
260
message += " ({msec} msec / 
execution)".format(msec=msec).rjust(30) 
261
print(message)

58
6
Checking FALCON with Python
262 
263 
# Dirty trick to fit test_samplerz into our test wrapper 
264 
def test_samplerz_simple(n, iterations): 
265
return test_samplerz(10, 10, iterations // 100) 
266 
267 
def test(n, iterations=500): 
268
"""A battery of tests.""" 
269
wrapper_test(test_fft , "FFT", n, iterations) 
270
wrapper_test(test_ntt , "NTT", n, iterations) 
271
# test_ntrugen is super slow, hence performed over a single 
iteration 
272
wrapper_test(test_ntrugen , "NTRUGen", n,  1)  
273
wrapper_test(test_ffnp , "ffNP", n, iterations) 
274
# test_compress and test_signature are only performed 
275
# for parameter sets that are defined. 
276
if (n in Params): 
277
wrapper_test(test_compress , "Compress", n, iterations) 
278
wrapper_test(test_signature , "Signature", n, iterations) 
279
#
wrapper_test(test_sign_KAT , "Signature KATs", n, 
iterations) 
280
print("") 
281 
# Run all the tests 
282 
if (__name__ == "__main__"): 
283
print("Test Sig KATs
: ", end="") 
284
print("OK" if (test_sign_KAT() is True) else "Not OK") 
285
# wrapper_test(test_samplerz_simple , "SamplerZ", None, 
100000) 
286
# raise ValueError(msg) 
287
#ValueError: For each axis slice, the sum of the observed 
frequencies must agree with the sum of the expected 
frequencies to a relative tolerance of 1e-08, but the 
percent differences are: 
288
# 0.002004008016032064 
289
wrapper_test(test_samplerz_KAT , "SamplerZ KATs", None, 1) 
290
print("") 
291 
292
for i in range(9, 11): 
293
n =  (1  <<  i)  
294
it = 1000 
295
print("Test battery for n = {n}".format(n=n)) 
296
test(n, it) 
Script 6.12 Test script for falcon.py 
Fig. 6.17 shows the output from executing test.py, which includes testing the 
FALCON Signature Known Answer Test (KAT) and the FALCON SamplerZ KAT. 
The tests are conducted for rings of degree n = 512n=512and n = 1024n=1024. Also, Fig. 6.17 
displays the average time taken for various operations‚ÄîTest FFT, Test NTT, Test 
NTRUGen, Test ffNP, Test Compress, and Test Signature‚Äîafter iterating 1,000 
times. The time consumed may vary slightly depending on your test computer.

6.2
FALCON-SpeciÔ¨Åc Modules
59
Fig. 6.17 Time consumed in msec executing test.py

Chapter 7 
Checking SOLMAE with Python 
SOLMAE Python package is available at web page: https://solmae-sign.info. 
This repository contains the following Ô¨Åles (roughly in order of dependency): 
1. common.py contains shared functions and constants 
2. encoding.py implements compress and decompress 
3. rng.py implements a ChaCha20-based PRNG(standalone) 
4. samplerz.py implements a Gaussian sampler over the integers (standalone) 
5. fft_constants.py contains precomputed constants used in the FFT 
6. ntt_constants.py contains precomputed constants used in the NTT 
7. fft.py implements the FFT over R[x]/(xn + 1)R[x] / (x^n + 1)
8. ntt.py implements the NTT over Zq[x]/(xn + 1)Z_q[x] / (x^n + 1)
9. ntrugen.py generate polynomials f, g, F, Gf,g,F,Gin Z[x]/(xn + 1)Z[x] / (x^n + 1)such that f ¬∑
G ‚àíg ¬∑ F = qf\cdot G - g \cdot F = q
10. params.py contains security parameters 
11. Unifcrown.py implements Unifcrown sampler and its test script 
12. Pairgen.py implements Pairgen and its test script 
13. keygen.py implements keygen and its test script 
14. PeikertSampler.py implements Peikert Sampler 
15. N_sampler.py implements N-sampler 
16. Sampler.py implements Sampler 
17. solmae.py implements keygen, sign and verify procedures of SOLMAE-512 
or SOLMAE-1024 
18. test.py contains how to use and to check that everything is properly imple-
mented.(same as FALCON Python Package) 
To implement the SOLMAE in Python, the modules used for FALCON such 
as common.py, encoding.py, rng.py, samplerz.py, fft_constants.py, 
fft.py, ntt_constants.py, ntt.py, and ntrugen.py are re-used, as their 
functionalities are also essential for the operation of SOLMAE. 
¬© The Author(s), under exclusive license to Springer Nature Switzerland AG 2025 
K. Kim, Practical Post-Quantum Signatures, SpringerBriefs in Information Security 
and Cryptography, https://doi.org/10.1007/978-3-031-81250-7_7
61

62
7
Checking SOLMAE with Python
7.1 
SOLMAE-SpeciÔ¨Åc Modules 
This section outlines the speciÔ¨Åc functions and operations exclusive to both 
SOLMAE-512 and SOLMAE-1024. It includes generating security parameters, 
generating pairs f and g, creating private and public keys, employing a uniform 
crown sampler for random number, and Gaussian samplers including all procedure 
tests of SOLMAE-512 and SOLMAE-1024. 
7.1.1 
Checking parameters.py 
Under the folder ..\..\script, there is a Ô¨Åle named solmae_params.py as 
shown in Script 7.1. This script has been adapted from parameters.py in 
FALCON Python package to be suitable for SOLMAE. 
1 
from math import sqrt, exp, log, pi, floor 
2 
# Constants 
3 
e = exp(1) 
4 
q = 1024 * 12 + 1 
# Modulo 
5 
NB_QUERIES = 2 ** 64 
# NIST Recommendation 
6 
eta = 1 / (2 ** 41) 
7 
sigmax = 1.8205 
# Max. acceptable std. dev for Gaussian sampler 
8 
DEBUG = True 
9 
def smooth(eps, n, normalized=True): 
10
"""Calculate the smoothing parameter.""" 
11
rep = sqrt(log(2 * n * (1 + 1 / eps)) / pi) 
12
if normalized: 
13
return rep / sqrt(2 * pi) 
14
else: 
15
return rep 
16 
def ssmooth(eps, n): 
17
"""Estimation of the smoothing parameter of ZZ^n.""" 
18
return sqrt(log(2 * n * (1 + 1 / eps)) / pi) / sqrt(2 * pi) 
19 
def dimensionsforfree(B): 
20
"""Calculate dimensions for free.""" 
21
return round(B * log(4 / 3) / log(B / (2 * pi * exp(1)))) 
22 
def print_security(B): 
23
"""Print the security parameters.""" 
24
sec_qrec_classical = floor(B * 0.292) 
25
sec_qrec_quantum = floor(B * 0.265) 
26
print(f"BIKZ:\t{B}") 
27
print(f"Classical:\t{sec_qrec_classical}") 
28
print(f"Quantum:\t{sec_qrec_quantum}") 
29 
def compute_para(d, alp, delt, corr): 
30
"""Compute parameters based on input.""" 
31
gs_norm = alp * sqrt(q) 
32
smoothing = 1 / pi * sqrt(1 / 2 * log(2 * d * (1 + 1 / eta))) 
33
sigma_sig = smoothing * alp * sqrt(q) 
34
gamma = corr * sigma_sig * sqrt(2 * d)

7.1
SOLMAE-SpeciÔ¨Åc Modules
63
35
R_minus = (1 / alp + delt) * sqrt(q) 
36
R_plus = (alp - delt) * sqrt(q) 
37
return gs_norm , smoothing , sigma_sig , gamma, R_minus , R_plus 
38 
def solmae_security(n, sigma_offset , fg_norm , target_bitsec , 
target_rejection=0.1, verbose=True): 
39
"""Calculate security parameters for SOLMAE.""" 
40
eps = 1 / sqrt(target_bitsec * NB_QUERIES) 
41
sigma = sigma_offset * sqrt(q) * smooth(eps, 2 * n)  
42
tau = 1.1 
# Estimate of the signature size w.r.t rejection 
prob. 
43 
44
while True: 
45
max_sig_norm = floor(tau * sqrt(2 * n) * sigma) 
46
rejection_rate = exp(2 * n * (1 - tau ** 2) / 2) * tau 
** (2 * n) 
47
if rejection_rate > target_rejection: 
48
break 
49
else: 
50
tau -= 0.001 
51 
52
B = 100 
# Initial block for Key recovery 
53
sigma_fg = fg_norm / sqrt(2 * n) 
54 
55
while True: 
56
left = (B / (2 * pi * e)) ** (1 - n / B) * sqrt(q) 
57
right = sqrt(3 * B / 4) * sigma_fg 
58
if left > right: 
59
break 
60
else: 
61
B += 1  
62
if verbose: 
63
print(" -----[ Key Recovery ] -----") 
64
print_security(B) 
65 
66
B = 100 
# Signature forgery 
67 
68
def condition_LH(beta): 
69
return min([(((pi * B) ** (1 / B) * B /  (2  *  pi  *  e))  **  
((2  * n - k) /  (2  * B - 2))) *  
70
q  **  (n /  (2  * n - k))  for k in range(n)]) 
71
while condition_LH(B) > max_sig_norm: 
72
B += 1  
73
sec_forgery_classical = (B * 0.292) 
74
sec_forgery_quantum = (B * 0.265) 
75
if verbose: 
76
print(" -----[ Signature forgery ] -----") 
77
print_security(B) 
78
return 
79 
def para_gen(): 
80
input_para = [ 
81
{"d": 512, "alpha": 1.17, "delta": 0.065, "correction": 
1.04}, 
82
{"d": 1024, "alpha": 1.64, "delta": 0.3, "correction": 
1.04}

64
7
Checking SOLMAE with Python
83
] 
84
for params in input_para: 
85
d = params["d"] 
86
alp = params["alpha"] 
87
delt = params["delta"] 
88
corr = params["correction"] 
89
gs_norm , smoothing , sigma_sig , gamma, R_minus , R_plus = 
compute_para(d, alp, delt, corr) 
90 
91
if DEBUG: 
92
print(f"\n ** Security parameters for d = {d} **") 
93
print("alpha(quality)
= 
{:.3f}".format(alp).ljust(25)) 
94
print("GS_norm
= 
{:.3f}".format(gs_norm).ljust(25)) 
95
print("smoothing
= 
{:.3f}".format(smoothing).ljust(25)) 
96
print("sigma_sig(sig width) = 
{:.3f}".format(sigma_sig).ljust(25)) 
97
print("gamma
= 
{:.3f}".format(gamma).ljust(25)) 
98
print("gamma^2(sig. bound) = {:.3f}".format(gamma * 
gamma).ljust(25)) 
99
print("R_minus
= 
{:.3f}".format(R_minus).ljust(25)) 
100
print("R_plus
= 
{:.3f}".format(R_plus).ljust(25)) 
101
print("\n== C/Q security of SOLMAE_512 ==") 
102
solmae_security(512, 2.04, 1.17 * sqrt(q), 128, verbose=True) 
103
print("\n== C/Q security of SOLMAE_1014 ==") 
104
solmae_security(1024, 2.33, 1.17 * sqrt(q), 256, 
verbose=True) 
105 
if __name__ == "__main__": 
106
para_gen() 
107 
print("Test passed.") 
Script 7.1 solmae_params.py 
Fig. 7.1 displays the security parameters used to conÔ¨Ågure the programs for 
SOLMAE-512 and SOLMAE-1024 along with their estimated classical and quan-
tum security levels. 
7.1.2 
Checking Unifcrown.py 
The Python script shown in Script 7.2 is designed to efÔ¨Åciently generate random 
values in an annular region with a Ô¨Åxed radius. This approach ensures that the values 
are uniformly distributed within the speciÔ¨Åed annular region, making it suitable for 
applications that require random sampling within such geometric constraints.

7.1
SOLMAE-SpeciÔ¨Åc Modules
65
Fig. 7.1 Output of solmae_params.py 
1 
########################### 
2 
# This is for SOLMAE only. 
3 
########################### 
4 
import numpy as np 
5 
from rng import ChaCha20 
6 
from os import urandom 
7 
import matplotlib.pyplot as plt 
8 
def Unifcrown(R_min, R_max, randombytes=urandom):

66
7
Checking SOLMAE with Python
9
u_rho = int.from_bytes(randombytes(8), ‚Äôlittle‚Äô) 
10
u_theta = int.from_bytes(randombytes(8), ‚Äôlittle‚Äô) 
11
u_rho = (u_rho & 0x1fffffffffffff) * 2**(-53) 
12
u_theta = (u_theta & 0x1fffffffffffff) * 2**(-53) 
13
rho = np.sqrt(R_min**2+u_rho*(R_max**2-R_min**2)) 
14
x = rho*np.cos(np.pi/2*u_theta) 
15
y = rho*np.sin(np.pi/2*u_theta) # equivalent to Algorithm 9 
16
return x, y 
17 
if __name__ == ‚Äô__main__‚Äô: 
18
x_list = [] 
19
y_list = [] 
20
for _ in range(5000): 
21
x, y = Unifcrown(2, 5) 
22
x_list.append(x) 
23
y_list.append(y) 
24
plt.plot(x_list,y_list, ‚Äôo‚Äô, markersize=3) 
25
plt.show() 
Script 7.2 Unifcrown.py and its plotting script 
Fig. 7.2 Scatter plot of 
Unifcrown.py 
Fig. 7.2 illustrates a scatter plot of generated by executing Unifcrown.py 5,000 
times using matplotlib.pyplot, a widely used tools for creating various types 
of plots and visualizations. This demonstrates that efÔ¨Åcient random generation is 
effectively achieved. 
7.1.3 
Checking N_sampler.py 
The N_sampler.py script generates random numbers following a Gaussian (or 
Normal) distribution for the SOLMAE signing procedure, as depicted in Fig. 4.3. To

7.1
SOLMAE-SpeciÔ¨Åc Modules
67
verify the correctness of the N_sampler.py Python script, a test script is provided, 
shown in Script 7.3. without mentioning N_sampler.py Python module. 
1 
from rng import ChaCha20 
2 
from os import urandom 
3 
from params import SOLMAE_D 
4 
import numpy as np 
5 
import matplotlib.pyplot as plt 
6 
import scipy.stats as stats 
7 
if __name__ == ‚Äô__main__‚Äô: 
8
# generate datas 
9
x_list = []; y_list = []; datas = [] 
10
n = 1000 # Set the number of test 
11
for _ in range(n): 
12
coeffs = n_sampler(); data = [] 
13
for i in range(SOLMAE_D//2): 
14
x = coeffs[2*i]; y = coeffs[2*i+1] 
15
x_list.append(x); y_list.append(y) 
16
data.append(x);data.append(y) 
17
datas.append(data) 
18
# plot the data in 2D 
19
fig = plt.figure(figsize = (20, 40)); ax1 = 
fig.add_subplot(2, 1, 1) 
20
plt.title("Distribution represented in 2D") 
21
plt.plot(x_list,y_list, ‚Äôo‚Äô, markersize=3) 
22
plt.xlim([-80, 80]); plt.ylim([-80, 80]) 
23
# calculate sample mean and sample variance 
24
datas = np.array(datas); 
mu = np.array([0 for _ in 
range(SOLMAE_D)]) 
25
cov_matrix = SOLMAE_D/2*np.eye(SOLMAE_D) 
26
cov_matrix_inv = np.linalg.inv(cov_matrix) 
27
data_mean = np.mean(datas, axis = 0) 
28
print("mean:", data_mean) 
29
data_cov_matrix = np.cov(datas.T, ddof = 1) 
30
print("covariance: ", data_cov_matrix) 
31
data_cov_matrix_inv = np.linalg.inv(data_cov_matrix) 
32
# check if the datas follow the distribution N_{d/2} with qq 
plot 
33
ax2 = fig.add_subplot(2, 1, 2) 
34
Maha_dist = [] 
35
for data in datas: 
36
data = np.array(data) 
37
Maha_dist.append(float(np.dot(np.dot(data.T, 
cov_matrix_inv), data))) 
38
Maha_dist = np.array(Maha_dist) 
39
stats.probplot(Maha_dist , dist = stats.chi2(SOLMAE_D), 
plot=ax2) 
40
plt.title("chi-square QQ-plot") 
41
plt.show() 
Script 7.3 Test Python script of N_sampler.py 
A QQ (Quantile-Quantile) plot is a graphical tool used to compare two prob-
ability distributions by plotting their quantiles against each other. It‚Äôs commonly

68
7
Checking SOLMAE with Python
Fig. 7.3 Scatter and QQ plots of checking N_sampler.py 
used to assess if a dataset follows a speciÔ¨Åc theoretical distribution (e.g., normal 
distribution) provided by matplotlib.pyplot Python package. 
‚Ä¢ 
Data Quantiles: The quantiles from the sample data are plotted on the y-axis. 
‚Ä¢ 
Theoretical Quantiles: The corresponding quantiles from the theoretical distribu-
tion (e.g., normal distribution) are plotted on the x-axis. 
It the points fall approximately along a straight line (typically the 45 ‚ó¶^{\circ}line), the 
sample data likely follows the theoretical distribution. 
Fig. 7.3 shows its Scatter and QQ plots of checking N_sampler.py. The upper 
part of Fig. 7.3 displays a scatter plot of the data distribution in 2 dimensions, while 
the lower part shows a chi-square QQ plot. The QQ plot indicates that the generated 
data follows a Gaussian distribution closely. 
7.1.4 
Checking Pairgen.py 
Verifying the generated short two polynomials f and g used in Algorithm 4, 
Pairgen.py and its test script is shown in Script 7.4. 
1 
############################################################### 
2 
#This is (f,g) pair generation and its test program for SOLMAE. 
3 
###############################################################

7.1
SOLMAE-SpeciÔ¨Åc Modules
69
4 
import numpy as np 
5 
from params import SOLMAE_D , Params, SOLMAE_Q 
6 
from Unifcrown import Unifcrown 
7 
from os import urandom 
8 
from fft import fft , ifft 
9 
m_pi = 3.14159265358979323846 
10 
count = 0 
11 
def Pairgen(randombytes=urandom): 
12
global count 
13
R_min = Params[SOLMAE_D]["lower_radius"] 
14
R_max = Params[SOLMAE_D]["upper_radius"] 
15
while True: 
16
flag = True 
17
count+=1 
18
f_fft = [0 for _ in range(SOLMAE_D)] 
19
g_fft = [0 for _ in range(SOLMAE_D)] 
20
for i in range(SOLMAE_D//2): 
21
x, y = Unifcrown(R_min, R_max) 
22
u_1 = int.from_bytes(randombytes(8), ‚Äôlittle‚Äô) 
23
theta_x = 2* m_pi *(u_1 & 0x1fffffffffffff) * 
2**(-53) 
24
u_2 = int.from_bytes(randombytes(8), ‚Äôlittle‚Äô) 
25
theta_y = 2* m_pi *(u_2 & 0x1fffffffffffff) * 
2**(-53) 
26
# multiplied 2pi before this line 
27
x_re = x*np.cos(theta_x); x_im = x*np.sin(theta_x) 
28
y_re = y*np.cos(theta_y); y_im = y*np.sin(theta_y) 
29
f_fft[i] = complex(x_re, x_im) 
30
f_fft[i + SOLMAE_D//2] = complex(x_re, -x_im) 
31
g_fft[i] = complex(y_re, y_im) 
32
g_fft[i+SOLMAE_D//2] = complex(y_re, -y_im) 
33
f =  list(map(lambda n: round(n), ifft(f_fft))) 
34
g =  list(map(lambda n: round(n), ifft(g_fft))) 
35
res_f_fft = fft(f); 
res_g_fft = fft(g) 
36
for i in range(SOLMAE_D//2): 
37
norm_sq = res_f_fft[i].real**2 + 
res_f_fft[i].imag**2 +\ 
38
res_g_fft[i].real**2 + res_g_fft[i].imag**2 
39
if norm_sq < SOLMAE_Q/Params[SOLMAE_D]["quality"]**2 
or\ 
40
norm_sq > 
SOLMAE_Q*Params[SOLMAE_D]["quality"]**2: 
41
# 8977 16822 
42
flag = False 
43
continue 
44
if flag: 
45
return f, g 
46 
if __name__ == ‚Äô__main__‚Äô: 
47
print("==(f,g) pair generation for SOLMAE-", SOLMAE_D) 
48
cases = 5 # number pf tests 
49
for i in range(cases): 
50
count = 0 
51
f, g = Pairgen() 
52
print("\n << Test Cases :", i+1,  ">>")

70
7
Checking SOLMAE with Python
53
print("\count is ", count) 
54
print("Leading 10 coeffs of f = ".ljust(8) + "[" + 
",".join(["{}".format(x) for x in f[:10]]) + ", 
...]") 
55
print("Leading 10 coeffs of g = ".ljust(8) + "[" + 
",".join(["{}".format(x) for x in g[:10]]) + ", 
...]") 
56
print("Test passed!!") 
Script 7.4 Pairgen.py and its test script 
Fig. 7.4 presents sample output from executing Pairgen.py for SOLMAE-
1024 across Ô¨Åve cases by setting the value SOLMAE_D = 512 in params.py. Each 
generation involved rejection sampling, which was performed between 1 (very 
lucky!) and 106 (very bad!) trials. Despite the variability in the number of sampling 
attempts, the required short polynomials f and g were successfully generated in 
every instance. 
Similarly, Fig. 7.5 presents sample output from executing Pairgen.py for 
SOLMAE-1024 across Ô¨Åve cases by setting the value SOLMAE_D = 1024 in 
params.py. Each generation involved rejection sampling, which was performed 
1 trial only (very lucky cases). This experiment demonstrates that the required short 
polynomials f and g were successfully generated in every instance after a single 
sampling. 
Fig. 7.4 Sample output from executing Pairgen.py for SOLMAE-512

7.1
SOLMAE-SpeciÔ¨Åc Modules
71
Fig. 7.5 Sample output from executing Pairgen.py for SOLMAE-1024 
7.1.5 
Checking keygen.py 
This section describes an example of executing keygen.py, which is used for 
private and public keys of SOLMAE. The details of this example are illustrated 
in Script 7.5. 
1 
############################################################# 
2 
#This is to generate all keys and its test program for SOLMAE. 
3 
############################################################# 
4 
from Pairgen import Pairgen 
5 
from ntt import ntt, intt, div_ntt 
6 
from ntrugen import ntru_solve 
7 
from fft import fft, ifft, add_fft , sub_fft , mul_fft , div_fft , 
adj_fft , cut_half_fft 
8 
from numpy import sqrt 
9 
from params import Params, SOLMAE_D 
10 
from os import urandom 
11 
class secret_key: 
12
def __init__(self): 
13
self.f = []; self.g = []; self.F = []; self.G = [] 
14
self.Sigma1 = []; self.Sigma2 = [] 
15
self.b10_fft = []; self.b11_fft = []; self.b20_fft = []; 
self.b21_fft = [] 
16
self.beta10_fft = []; self.beta11_fft = [] 
17
self.beta20_fft = []; self.beta21_fft = []

72
7
Checking SOLMAE with Python
18 
class public_key: 
19
def __init__(self): 
20
self.h = [] 
21 
def keygen(randombytes=urandom): 
22
sk = secret_key() 
23
pk = public_key() 
24
while True: 
25
f, g = Pairgen(randombytes) 
26
try: 
27
f_ntt = ntt(f) 
28
g_ntt = ntt(g) 
29
h_ntt = div_ntt(g_ntt, f_ntt) 
30
except ZeroDivisionError: 
31
continue 
32
try: 
33
F, G = ntru_solve(f, g) 
34
except ValueError: 
35
continue 
36 
37
sk.f = f;  sk.g = g;  sk.F = F;  sk.G = G  
38
pk.h = intt(h_ntt) 
39
break 
40
# Consistency values (2023.8.10, kkj) 
41
eta_sq = Params[SOLMAE_D]["smoothing"] ** 2  
42
sig_width = Params[SOLMAE_D]["signature_width"] ** 2  
43
eta_sq_fft = [eta_sq for _ in range(SOLMAE_D)] 
44
sig_width_fft = [sig_width for _ in range(SOLMAE_D)] 
45 
46
sk.b10_fft = fft(f); sk.b11_fft = fft(g) 
47 
48
b1_norm = add_fft(mul_fft(adj_fft(sk.b10_fft), sk.b10_fft), 
mul_fft(adj_fft(sk.b11_fft), sk.b11_fft)) 
49
sk.beta10_fft = div_fft(sk.b10_fft , b1_norm) 
50
sk.beta11_fft = div_fft(sk.b11_fft , b1_norm) 
51
sk.Sigma1 = [sqrt(elem) for elem in 
cut_half_fft(sub_fft(div_fft(sig_width_fft , b1_norm), 
eta_sq_fft))] 
52
sk.b20_fft = fft(F); sk.b21_fft = fft(G) 
53
temp_fft = add_fft(mul_fft(adj_fft(sk.beta10_fft), 
sk.b20_fft), mul_fft(adj_fft(sk.beta11_fft), sk.b21_fft)) 
54
sk.b20_tild_fft = sub_fft(sk.b20_fft , mul_fft(temp_fft , 
sk.b10_fft)) 
55
sk.b21_tild_fft = sub_fft(sk.b21_fft , mul_fft(temp_fft , 
sk.b11_fft)) 
56
b2_tild_norm = add_fft(mul_fft(adj_fft(sk.b20_tild_fft), 
sk.b20_tild_fft), mul_fft(adj_fft(sk.b21_tild_fft), 
sk.b21_tild_fft)) 
57
sk.beta21_fft = div_fft(sk.b21_tild_fft , b2_tild_norm) 
58
sk.Sigma2 = [sqrt(elem) for elem in 
cut_half_fft(sub_fft(div_fft(sig_width_fft , 
b2_tild_norm), eta_sq_fft))] 
59
return sk, pk 
60 
61 
if __name__ == ‚Äô__main__‚Äô:

7.1
SOLMAE-SpeciÔ¨Åc Modules
73
62
sk, pk = keygen() 
63
print("== Leading 3 to 10 values of key pairs for 
SOLMAE_",SOLMAE_D ,"==") 
64
print("f
= ".ljust(8) + "[" + ", 
".join(["{}".format(x) for x in sk.f[:10]]) + ", ...]") 
65
print("g
= ".ljust(8) + "[" + ", 
".join(["{}".format(x) for x in sk.g[:10]]) + ", ...]") 
66
print("F
= ".ljust(8) + "[" + ", 
".join(["{}".format(x) for x in sk.F[:10]]) + ", ...]") 
67
print("G
= ".ljust(8) + "[" + ", 
".join(["{}".format(x) for x in sk.G[:10]]) + ", ...]") 
68
print("h
= ".ljust(8) + "[" + ", 
".join(["{}".format(x) for x in pk.h[:9]]) + ", ...]") 
69
print("f_fft
= ".ljust(8) + "[" + ", 
".join(["{:.3f}".format(x) for x in sk.b10_fft[:3]]) + 
", ...]") 
70
print("g_fft
= ".ljust(8) + "[" + ", 
".join(["{:.3f}".format(x) for x in sk.b11_fft[:3]]) + 
", ...]") 
71
print("F_fft
= ".ljust(8) + "[" + ", 
".join(["{:.3f}".format(x) for x in sk.b20_fft[:3]]) + 
", ...]") 
72
print("G_fft
= ".ljust(8) + "[" + ", 
".join(["{:.3f}".format(x) for x in sk.b21_fft[:3]]) + 
", ...]") 
73
print("beta10_fft
= ".ljust(8) + "[" + ", 
".join(["{:.3f}".format(x) for x in sk.b10_fft[:3]]) + 
", 
...]") 
74
print("beta11_fft
= ".ljust(8) + "[" + ", 
".join(["{:.3f}".format(x) for x in sk.b11_fft[:3]]) + 
", ...]") 
75
print("beta20_fft
= ".ljust(8) + "[" + ", 
".join(["{:.3f}".format(x) for x in sk.b20_fft[:3]]) + 
", ...]") 
76
print("beta21_fft
= ".ljust(8) + "[" + ", 
".join(["{:.3f}".format(x) for x in sk.b21_fft[:3]]) + 
", ...]") 
77
print("Sigma1
= ".ljust(8) + "[" + ", 
".join(["{:.3f}".format(x) for x in sk.Sigma1[:3]]) + ", 
...]") 
78
print("Sigma2
= ".ljust(8) + "[" + ", 
".join(["{:.3f}".format(x) for x in sk.Sigma2[:3]]) + ", 
...]") 
Script 7.5 keygen.py and its test script 
Fig. 7.6 shows sample output from executing keygen.py for SOLMAE-512 
by setting the value of SOLMAE_D = 512 in params.py including a set of typical 
values of f, g, F, G, h, f_fft, g_fft, F_fft, G_fft, beta10_fft, 
beta11_fft, beta20_fft, beta21_fft, Sigma1, and Sigma2. 
Similarly, Fig. 7.7 shows sample output from executing keygen.py for 
SOLMAE-1024 by setting the value of SOLMAE_D = 1024 in params.py 
including a set of typical values of f, g, F, G, h, f_fft, g_fft, F_fft,

74
7
Checking SOLMAE with Python
Fig. 7.6 Sample output by executing keygen.py for SOLMAE-512 
Fig. 7.7 Sample output by executing keygen.py for SOLMAE-1024 
G_fft, beta10_fft, beta11_fft, beta20_fft, beta21_fft, Sigma1, 
and Sigma2. 
7.1.6 
Checking solmae.py 
This section describes the keygen, sign, and veriÔ¨Åcation procedure of SOLMAE-
512 and SOLMAE-1024 from the randomly generated private and its corresponding 
public key.

7.1
SOLMAE-SpeciÔ¨Åc Modules
75
The test script is listed as Script 7.6. The  value of  SOLMAE_D in params.py is 
Ô¨Åxed at 512 or 1024 depending on which type of SOLMAE you are verifying. 
1 
############################################################### 
2 
# This is test of keygen, sign and verify procedures of SOLMAE 
3 
############################################################### 
4 
from solmae import sign, verify 
5 
from keygen import secret_key , public_key , keygen 
6 
from os import urandom 
7 
from params import SOLMAE_D 
8 
def test_s_signature(iterations=1): 
9
sk=secret_key() 
10
pk=public_key() 
11
sk, pk = keygen() 
12
print("==Leading 10 values of keygen function for 
SOLMAE-",SOLMAE_D) 
13
print("f
= ".ljust(8) + "[" + ", 
".join(["{}".format(x) for x in sk.f[:5]]) + ", ...]") 
14
print("g
= ".ljust(8) + "[" + ", 
".join(["{}".format(x) for x in sk.g[:5]]) + ", ...]") 
15
print("F
= ".ljust(8) + "[" + ", 
".join(["{}".format(x) for x in sk.F[:5]]) + ", ...]") 
16
print("G
= ".ljust(8) + "[" + ", 
".join(["{}".format(x) for x in sk.G[:5]]) + ", ...]") 
17
print("h
= ".ljust(8) + "[" + ", 
".join(["{}".format(x) for x in pk.h[:5]]) + ", ...]") 
18
print("f_fft
= ".ljust(8) + "[" + ", 
".join(["{:.3f}".format(x) for x in sk.b10_fft[:3]]) + 
", ...]") 
19
print("g_fft
= ".ljust(8) + "[" + ", 
".join(["{:.3f}".format(x) for x in sk.b11_fft[:3]]) + 
", ...]") 
20
print("F_fft
= ".ljust(8) + "[" + ", 
".join(["{:.3f}".format(x) for x in sk.b20_fft[:3]]) + 
", ...]") 
21
print("G_fft
= ".ljust(8) + "[" + ", 
".join(["{:.3f}".format(x) for x in sk.b21_fft[:3]]) + 
", ...]") 
22
print("beta10_fft
= ".ljust(8) + "[" + ", 
".join(["{:.3f}".format(x) for x in sk.b10_fft[:3]]) + 
", 
...]") 
23
print("beta11_fft
= ".ljust(8) + "[" + ", 
".join(["{:.3f}".format(x) for x in sk.b11_fft[:3]]) + 
", ...]") 
24
print("beta20_fft
= ".ljust(8) + "[" + ", 
".join(["{:.3f}".format(x) for x in sk.b20_fft[:3]]) + 
", ...]") 
25
print("beta21_fft
= ".ljust(8) + "[" + ", 
".join(["{:.3f}".format(x) for x in sk.b21_fft[:3]]) + 
", ...]") 
26
print("Sigma1
= ".ljust(8) + "[" + ", 
".join(["{:.3f}".format(x) for x in sk.Sigma1[:3]]) + ", 
...]")

76
7
Checking SOLMAE with Python
27
print("Sigma2
= ".ljust(8) + "[" + ", 
".join(["{:.3f}".format(x) for x in sk.Sigma2[:3]]) + ", 
...]") 
28
message=urandom(SOLMAE_D) #generate SOLMAE-D Bytes message 
randomly 
29
hex_message = message.hex() 
30
print("Message =",hex_message[:40], ‚Äô...‚Äô, hex_message[-17:]) 
31
print("Length of Message: ", len(message)) 
32
signature = sign(sk, message) # signing 
33
str_signature =signature.hex() 
34
print("Signature =",str_signature[:40], ‚Äô...‚Äô, 
str_signature[-17:]) 
35
print("Length of Sig. = ", len(signature)) 
36
if (verify(pk, message , signature)== True): # verifying 
37
print("Verification passed!!") 
38
else: 
39
print("Verification failed!!") 
40
return False 
41
return True 
42 
if __name__ == "__main__": 
43
cases = 2 # Number of tests 
44
print("**Testing of keygen, sign and verify procedures of 
SOLMAE-",SOLMAE_D) 
45
for i in range(cases): 
46
print("\n<< Test Case :", i+1,">>") 
47
test_s_signature(i) # degree of cyclotomic poly. (power 
of 2) 
48 
print("\nTest passed:") 
Script 7.6 Testing script of solmae.py 
Depending on the value of SOLMAE_D in params.py, Figs.  7.8 and 7.9 present 
two tests of randomly generated key data, a random 512 byte message, its 
signature in hexadecimal notation, the veriÔ¨Åcation of signature for SOLMAE-512 
and SOLMAE-1024, respectively.

7.1
SOLMAE-SpeciÔ¨Åc Modules
77
Fig. 7.8 Two tests of keygen, sign and verify procedures of SOLMAE-512

78
7
Checking SOLMAE with Python
Fig. 7.9 Two tests of keygen, sign and verify procedures of SOLMAE-1024

Chapter 8 
Concluding Remarks 
In this monograph, we encapsulate key insights into the comparative analysis 
between FALCON and SOLMAE, particularly within the evolving landscape of 
PQC. It underscores the growing necessity for secure algorithms resistant to 
quantum-based attacks, given the rapid advancements in quantum computing. While 
FALCON, selected as one of NIST‚Äôs PQC standard post-quantum signatures, has 
been widely recognized as a pioneering signature scheme, SOLMAE offers practical 
advantages such as simpler implementation and enhanced performance. 
Both FALCON and SOLMAE ensure message integrity against modiÔ¨Åcation or 
forgery by attackers, guaranteeing long-term security, even in the future quantum 
computing era. These schemes require a deeper understanding of algebra compared 
to DSA or ECDSA, which are based on number theory. To aid in understanding the 
detailed internal operations of FALCON and SOLMAE, main modules implemented 
in Python scripts are tested step-by-step, enhancing comprehension for readers with 
undergraduate-level knowledge. 
The key generation, signing, and veriÔ¨Åcation processes of FALCON and SOL-
MAE depend on a set of security parameters, generated and veriÔ¨Åed in the 
parameters.py module. The results of these parameters allow conÔ¨Ågurations for 
FALCON-512 and SOLMAE-512 (NIST level of security I), as well as FALCON-
1024 and SOLMAE-1024 (NIST level of security V). Visualizations of Gaussian 
and uniform distributions of randomly generated numbers are also provided using 
Python‚Äôs visualization and statistical measurement packages. 
One of the main concerns in PQC remains side-channel attacks, which are 
evolving alongside cryptographic algorithms. SOLMAE, by simplifying sampling 
procedures and introducing parallelizable features, appears better equipped to 
address these challenges with fewer complexities in masking techniques compared 
to FALCON. Continuous improvements in performance will be crucial to stay 
ahead of quantum threats. Moreover, ensuring security across different platform‚Äî 
particularly against power, timing, and EM attacks, etc.‚Äîremains a critical issue. 
¬© The Author(s), under exclusive license to Springer Nature Switzerland AG 2025 
K. Kim, Practical Post-Quantum Signatures, SpringerBriefs in Information Security 
and Cryptography, https://doi.org/10.1007/978-3-031-81250-7_8
79

80
8
Concluding Remarks
These considerations emphasize the need for ongoing research and optimization in 
developing robust PQC. 
Lastly, as research in this Ô¨Åeld continues, the cryptographic community must 
remain vigilant in addressing potential weaknesses, building systems that are not 
only quantum-resistant but also adaptable to the dynamic needs of an interconnected 
world. 
In Kim‚Äôs work [21], a performance comparison is presented between FALCON 
and SOLMAE based on their Python implementations. The study evaluates their 
efÔ¨Åciency by analyzing execution speed and overall performance to gain a compre-
hensive understanding. His companion paper in [22] has presented an asymptotic 
complexity and performance comparison between FALCON and SOLMAE using 
their C Implementation for a more realistic performance evaluation. 
Finally, SOLMAE was established as a Korean TTA standard on Dec. 6, 2024, 
under the title Quantum‚Äìsafe Digital Signature based on NTRU Lattices ‚Äì Part 1: 
General in Korean, TTAK.KO-12.0410-Part 1 [23] and its Part 2 is planned to be 
established as a TTA standard in 2025.

References 
1. DifÔ¨Åe, W., Hellman, M.E.: New directions in cryptography. IEEE Trans. Inf. Theory 22(6), 
644‚Äì654 (1976). https://doi.org/10.1109/TIT.1976.1055638 
2. Ducas, L.: Shortest vector from lattice sieving: a few dimensions for free. In: Nielsen, J.B., 
Rijmen, V. (eds.) EUROCRYPT 2018, Part I, vol. 10820, pp. 125‚Äì145. Springer, Heidelberg 
(2018) 
3. Ducas, L., Prest, T.: Fast Fourier orthogonalization. In: Abramov, S.A., Zima, E.V., Gao, 
X.S. (eds.) Proceedings of the ACM on International Symposium on Symbolic and Algebraic 
Computation, ISSAC 2016, pp. 191‚Äì198. ACM, Waterloo (2016) 
4. Ducas, L., Lyubashevsky, V., Prest, T.: EfÔ¨Åcient identity-based encryption over NTRU lattices. 
In: Sarkar, P., Iwata, T. (eds.) ASIACRYPT 2014, Part II. LNCS, vol. 8874, pp. 22‚Äì41. 
Springer, Heidelberg (2014) 
5. ElGamal, T.: A public key cryptosystem and a signature scheme based on discrete logarithms. 
IEEE Trans. Inf. Theory 31(4), 469‚Äì472 (1985). https://doi.org/10.1109/TIT.1985.1057074 
6. Espitau, T., Fouque, P.A., G√©rard, F., Rossi, M., Takahashi, A., Tibouchi, M., Wallet, A., 
Yu, Y.: Mitaka: a simpler, parallelizable, maskable variant of FALCON. In: Dunkelman, O., 
Dziembowski, S. (eds.) Advances in Cryptology ‚Äì EUROCRYPT 2022, pp. 222‚Äì253. Springer 
International Publishing, Cham (2022) 
7. Espitau, T., Fouque, P.A., G√©rard, F., Rossi, M., Takahashi, A., Tibouchi, M., Wallet, A., Yu, 
Y.: Mitaka: a simpler, parallelizable, maskable variant of Falcon. In: Advances in Cryptology, 
Proc. of EUROCRYPTO 2022, Part III, pp. 222‚Äì253 (2022) 
8. Espitau, T., Nguyen, T.T.Q., Sun, C., Tibouchi, M., Wallet, A.: Antrag: annular NTRU trapdoor 
generation. In: Proc. of Asiacrypt2023, Part VII, Guangzhou, pp. 3‚Äì32 (2023) 
9. Fouque, P.A., Hoffstein, J., Kirchner, P., Lyubashevsky, V., Pornin, T., Prest, T., Ricosset, T., 
Seiler, G., Whyte, W., Zhang, Z.: Falcon: Fast-fourier lattice-based compact signatures over 
NTRU. https://falcon-sign.info/ 
10. Fouque, P.A., Kirchner, P., Tibouchi, M., Wallet, A., Yu, Y.: Key recovery from Gram-Schmidt 
norm leakage in hash-and-sign signatures over NTRU lattices. Cryptology ePrint Archive, 
Paper 2019/1180 (2019). https://eprint.iacr.org/2019/1180 
11. Gentry, C., Peikert, C., Vaikuntanathan, V.: How to use a short basis: trapdoors for hard lattices 
and new cryptographic constructions. In: Proc. of 40th ACM STOC 2008, pp. 197‚Äì206 (2008) 
12. Gentry, C., Peikert, C., Vaikuntanathan, V.: Trapdoors for hard lattices and new cryptographic 
constructions. In: Proceedings of the 40th Annual ACM Symposium on Theory of Computing 
(STOC), pp. 197‚Äì206. ACM, Victoria (2008). https://doi.org/10.1145/1374376.1374407 
13. Goldreich, O., Goldwasser, S., Halevi, S.: Public-key cryptosystems from lattice reduction 
problems. In: Advances in Cryptology, Proc. of Crypto 1997, pp. 112‚Äì131 (1997) 
¬© The Author(s), under exclusive license to Springer Nature Switzerland AG 2025 
K. Kim, Practical Post-Quantum Signatures, SpringerBriefs in Information Security 
and Cryptography, https://doi.org/10.1007/978-3-031-81250-7
81

82
References
14. Goldwasser, S., Bellare, M.: Lecture Notes on Cryptography. Massachusetts Institute of 
Technology (2001). Available online at https://cseweb.ucsd.edu/~mihir/papers/gb.html 
15. Hoffstein, J., Pipher, J., Silverman, J.H.: NTRU: a ring-based public key cryptosystem. In: 
Algorithmic Number Theory, Third International Symposium, ANTS-III, Portland, June 21‚Äì 
25, 1998. Lecture Notes in Computer Science, vol. 1423, pp. 267‚Äì288. Springer, Berlin (1998) 
16. Hoffstein, J., Howgrave-Graham, N., Pipher, J., Silverman, J.H., Whyte, W.: NTRUSIGN: 
digital signatures using the NTRU lattice. In: Joye, M. (ed.) CT-RSA 2003. LNCS, vol. 2612, 
pp. 122‚Äì140. Springer, Heidelberg (2003) 
17. Howe, J., Prest, T., Ricosset, T., Rossi, M.: Isochronous gaussian sampling: from inception 
to implementation. Cryptology ePrint Archive, Paper 2019/1411 (2019). https://eprint.iacr.org/ 
2019/1411 
18. Hulsing, A., Bernstein, D.J., Dobraunig, C., Eichlseder, M., Fluhrer, S., Gazdag, S.L., Kam-
panakis, P., Kolbl, S., Lange, T., Lauridsen, M.M., Mendel, F., Niederhagen, R., Rechberger, 
C., Rijneveld, J., Schwabe, P., Aumasson, J.P., Westerbaan, B., Beullens, W.: Sphincs+. https:// 
sphincs.org/ 
19. IBM: Expanding the IBM quantum roadmap to anticipate the future of quantum-centric 
supercomputing (2022). https://research.ibm.com/blog/ibm-quantum-roadmap-2025 
20. Kahn, D.: The Codebreakers: The Comprehensive History of Secret Communication from 
Ancient Times to the Internet. Scribner, New York (1996) 
21. Kim, K.: Theoretical and empirical analysis of FALCON and SOLMAE using their python 
implementation. In: Seo, H., Kim, S. (eds.) Information Security and Cryptology ‚Äì ICISC 
2023, pp. 235‚Äì260. Springer Nature Singapore, Singapore (2024) 
22. Kim, K., Kim, Y.: Asymptotic complexity and performance comparison of FALCON and SOL-
MAE using their c implementation. Springer Briefs in Information Security and Cryptography, 
ISBN 978-3-031-81249-1, Springer 
23. Kim, K., Kim, Y.: Quantum-safe digital signature based on ntru lattices - part 1: General(in 
korean). TTAK.KO-12.0410-Part1 (2024) 
24. Kim, K., Tibouchi, M., Espitau, T., Takashima, A., Wallet, A., Yu, Y., Guilley, S., Kim, S.: 
Solmae: algorithm speciÔ¨Åcation. Updated SOLMAE, IRCS Blog (2023). https://ircs.re.kr/?p= 
1714 
25. Koblitz, N.: Elliptic curve cryptosystems. Math. Comput. 48(177), 203‚Äì209 (1987). https:// 
doi.org/10.2307/2007884 
26. KpqC: Korean post-quantum crytography (2020). https://kpqc.or.kr/ 
27. Lyubashevsky, V.: Fiat-shamir with aborts: applications to lattice and factoring-based signa-
tures. In: Advances in Cryptology - ASIACRYPT 2009. Lecture Notes in Computer Science, 
vol. 5912, pp. 598‚Äì616. Springer (2009). https://doi.org/10.1007/978-3-642-10366-7_35 
28. Lyubashevsky, V., Ducas, L., Kiltz, E., Lepoint, T., Schwabe, P., Seiler, G., Stehle, D., Bai, S.: 
Crystal‚Äìdilithum. https://pq-crystals.org/dilithium/index.shtml 
29. Miller, V.S.: Use of elliptic curves in cryptography. In: Advances in Cryptology ‚Äì CRYPTO 
‚Äô85. Lecture Notes in Computer Science, vol. 218, pp. 417‚Äì426. Springer (1986). https://doi. 
org/10.1007/3-540-39799-X_31 
30. Min, S., Yamamoto, G., Kim, K.: Weak property of malleability in NTRUSign. In: Proc. of 
ACISP 2004. LNCS, vol. 3108, pp. 379‚Äì390 (2004) 
31. National Institute of Standards and Technology: FIPS 197: Advanced Encryption Standard 
(AES) (November 2001). https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197.pdf 
32. National Institute of Standards and Technology: FIPS 186-4: Digital Signature Standard (DSS) 
(July 2013). https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf 
33. National Institute of Standards and Technology: FIPS 203: Module-Lattice-Based Key-
Encapsulation Mechanism Standard (August 2024). https://doi.org/10.6028/NIST.FIPS.203 
34. National Institute of Standards and Technology: FIPS 204: Module-Lattice-Based Digital 
Signature Standard (August 2024). https://doi.org/10.6028/NIST.FIPS.204 
35. National Institute of Standards and Technology: FIPS 205: Stateless Hash-Based Digital 
Signature Standard (August 2024). https://doi.org/10.6028/NIST.FIPS.205

References
83
36. Nguyen, P.Q., Regev, O.: Learning a parallelepiped: cryptanalysis of GGH and NTRU 
signatures. J. Cryptol. 22(2), 139‚Äì160 (2009) 
37. NIST: 
Post-quantum 
crytography 
(2016). 
https://csrc.nist.gov/projects/post-quantum-
cryptography 
38. Pornin, T., Prest, T.: More efÔ¨Åcient algorithms for the NTRU key generation using the Ô¨Åeld 
norm. In: Lin, D., Sako, K. (eds.) Public-Key Cryptography ‚Äì PKC 2019, pp. 504‚Äì533. 
Springer International Publishing, Cham (2019) 
39. Prest, T.: Gaussian Sampling in lattice-based cryptography. Ph.D. thesis, √âcole Normale 
Sup√©rieure, Paris (2015) 
40. Rivest, R.L., Shamir, A., Adleman, L.: A method for obtaining digital signatures and public-
key cryptosystems. Commun. ACM 21(2), 120‚Äì126 (1978). https://doi.org/10.1145/359340. 
359342 
41. Schwabe, P., Avanzi, R., Bos, J., Ducas, L., Kiltz, E., Lepoint, T., Lyubashevsky, V., Schanck, 
J.M., Seiler, G., Stehle, D., Ding, J.: Crystal‚Äìkyber. https://pq-crystals.org/kyber/index.shtml 
42. Shannon, C.E.: Communication theory of secrecy systems. Bell Syst. Tech. J. 28(4), 656‚Äì715 
(1949) 
43. Shor, P.W.: Polynomial-time algorithms for prime factorization and discrete logarithms on a 
quantum computer. SIAM Rev. 41(2), 303‚Äì332 (1999) 
44. Stehl√©, D., Steinfeld, R.: Making NTRU as secure as worst-case problems over ideal lattices. In: 
Paterson, K.G. (ed.) EUROCRYPT 2011. LNCS, vol. 6632, pp. 27‚Äì47. Springer, Heidelberg 
(2011) 
45. Wikipedia: Harvest now, decrypt later (2023). https://en.wikipedia.org/wiki/Harvest_now_ 
decrypt_later

Index 
Symbols 
ùìÅ2\ell_2-norm, 5 
ùìÅ‚àû\ell_\infty-norm, 5 
q-ary lattice, 7 
ANTRAG, 19 
DILITHIUM, 3 
FALCON-512, 42 
FALCON-1024, 42 
KYBER, 3 
MITAKA, 19 
NTRUENCRYPT, 11 
NTRUSIGN, 11 
NtruSolve, 22 
SOLMAE-512, 61 
SOLMAE-1024, 61 
SPHINCS+, 3 
B 
B√©zout-like equation, 22 
C 
Closest Vector Problem (CVP), 11 
Cyclotomic polynomials, 19 
Cyclotomic ring, 19 
D 
DifÔ¨Åe and Hellman (DH), 2 
Digital Signature Algorithm (DSA), 2 
Digital Signatures (DS), 2 
Discrete Fourier Transform (DFT), 8 
Discrete Gaussians, 8 
E 
ElGamal, 2 
Euler‚Äôs totient function, 5 
F 
Fast Fourier Transform (FFT), 22 
ffSampling, 14 
Fiat-Shamir-with-aborts, 2 
Full-rank matrix, 7 
G 
GGH, 11 
Gram-Schmidt orthogonalization (GSO), 8 
H 
Hash-and-sign, 2 
I 
Inner product, 6 
K 
Key Encapsulation Mechanisms (KEM), 2 
L 
Lattices, 7 
LDL ‚àó^* decomposition, 9 
¬© The Editor(s) (if applicable) and The Author(s), under exclusive license to 
Springer Nature Switzerland AG 2025 
K. Kim, Practical Post-Quantum Signatures, SpringerBriefs in Information Security 
and Cryptography, https://doi.org/10.1007/978-3-031-81250-7
85

86
Index
M 
Matrices, 5 
N 
NTRU Lattices, 7 
NTRU decision problem, 8 
NTRU search problem, 8 
Number Ô¨Åelds, 5 
Number Theoretic Transform (NTT), 17, 24 
Number Theory aRe Us/N-th degree 
TRUncated polynomial (NTRU), 11 
P 
Post Quantum Cryptography (PQC), 3 
Python, 27 
Q 
Quotient rings, 5 
R 
Ring lattices, 7 
Rivest Shamir Adleman (RSA), 2 
S 
Scalars, 5 
Shor, P.W., 2 
Side-channel attacks, 79 
V 
Vectors, 5 
Volume, of a lattice, 7

