Numerical Methods in Engineering with Python
Numerical Methods in Engineering with Python is a text for engineer-
ing students and a reference for practicing engineers, especially those
who wish to explore the power and efﬁciency of Python. The choice of
numerical methods was based on their relevance to engineering prob-
lems. Every method is discussed thoroughly and illustrated with prob-
lems involving both hand computation and programming. Computer
code accompanies each method and is available on the book web site.
This code is made simple and easy to understand by avoiding complex
book-keeping schemes, while maintaining the essential features of the
method Python was chosen as the example language because it is ele-
gant, easy to learn and debug, and its facilities for handling arrays are
unsurpassed. Moreover, it is an open-source software package that can
be downloaded freely on the web. Python is a great language for teaching
scientiﬁc computation.
Jaan Kiusalaas is a Professor Emeritus in the Department of Engineer-
ing Science and Mechanics at the Pennsylvania State University. He has
taught computer methods, including ﬁnite element and boundary ele-
ment methods, for over 30 years. He is also the co-author of four other
books—EngineeringMechanics:Statics,EngineeringMechanics:Dynam-
ics, Mechanics of Materials, and an alternate version of this work with
MATLAB® code.


NUMERICAL METHODS IN
ENGINEERING WITH
Python
Jaan Kiusalaas
The Pennsylvania State University


Cambridge, New York, Melbourne, Madrid, Cape Town, Singapore, São Paulo
Cambridge University Press
The Edinburgh Building, Cambridge , UK
First published in print format
-
----
-
----
© Jaan Kiusalaas 2005
2005
Information on this title: www.cambridg e.org /9780521852876
This publication is in copyright. Subject to statutory exception and to the provision of
relevant collective licensing agreements, no reproduction of any part may take place
without the written permission of Cambridge University Press.
-
---
-
---
Cambridge University Press has no responsibility for the persistence or accuracy of s
for external or third-party internet websites referred to in this publication, and does not
guarantee that any content on such websites is, or will remain, accurate or appropriate.
Published in the United States of America by Cambridge University Press, New York
www.cambridge.org
hardback
eBook (NetLibrary)
eBook (NetLibrary)
hardback

Contents
Preface . . . . . . . . . vii
1. Introduction to Python . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1
2. Systems of Linear Algebraic Equations . . . . . . . . . . . . . 27
3. Interpolation and Curve Fitting . . . . . . . . . . . . . . . . . . . . . 103
4. Roots of Equations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .142
5. Numerical Differentiation . . . . . . . . . . . . . . . . . . . . . . . . . . . 181
6. Numerical Integration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198
7. Initial Value Problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 248
8. Two-Point Boundary Value Problems . . . . . . . . . . . . . . . 295
9. Symmetric Matrix Eigenvalue Problems . . . . . . . . . . . .324
10. Introduction to Optimization . . . . . . . . . . . . . . . . . . . . . . . 381
Appendices . . . . 409
Index . . . . . . . . . . . 419
v


Preface
This book is targeted primarily toward engineers and engineering students of ad-
vanced standing (sophomores, seniors and graduate students). Familiarity with a
computer language is required; knowledge of basic engineering mechanics is useful,
but not essential.
The text attempts to place emphasis on numerical methods, not programming.
Most engineers are not programmers, but problem solvers. They want to know what
methods can be applied to a given problem, what are their strengths and pitfalls and
how to implement them. Engineers are not expected to write computer code for basic
tasks from scratch; they are more likely to utilize functions and subroutines that have
been already written and tested. Thus programming by engineers is largely conﬁned
to assembling existing pieces of code into a coherent package that solves the problem
at hand.
The “piece” of code is usually a function that implements a speciﬁc task. For the
user the details of the code are unimportant. What matters is the interface (what goes
in and what comes out) and an understanding of the method on which the algorithm
is based. Since no numerical algorithm is infallible, the importance of understanding
the underlying method cannot be overemphasized; it is, in fact, the rationale behind
learning numerical methods.
This book attempts to conform to the views outlined above. Each numerical
method is explained in detail and its shortcomings are pointed out. The examples that
follow individual topics fall into two categories: hand computations that illustrate the
innerworkingsofthemethodandsmallprogramsthatshowhowthecomputercodeis
utilized in solving a problem. Problems that require programming are marked with ■.
The material consists of the usual topics covered in an engineering course on
numerical methods: solution of equations, interpolation and data ﬁtting, numerical
differentiation and integration, solution of ordinary differential equations and eigen-
value problems. The choice of methods within each topic is tilted toward relevance
to engineering problems. For example, there is an extensive discussion of symmetric,
vii

viii
Preface
sparsely populated coefﬁcient matrices in the solution of simultaneous equations.
In the same vein, the solution of eigenvalue problems concentrates on methods that
efﬁciently extract speciﬁc eigenvalues from banded matrices.
An important criterion used in the selection of methods was clarity. Algorithms
requiring overly complex bookkeeping were rejected regardless of their efﬁciency and
robustness. This decision, which was taken with great reluctance, is in keeping with
the intent to avoid emphasis on programming.
The selection of algorithms was also inﬂuenced by current practice. This disqual-
iﬁed several well-known historical methods that have been overtaken by more recent
developments. For example, the secant method for ﬁnding roots of equations was
omitted as having no advantages over Brent’s method. For the same reason, the mul-
tistep methods used to solve differential equations (e.g., Milne and Adams methods)
were left out in favor of the adaptive Runge–Kutta and Bulirsch–Stoer methods.
Notably absent is a chapter on partial differential equations. It was felt that this
topicisbesttreatedbyﬁniteelementorboundaryelementmethods,whichareoutside
the scope of this book. The ﬁnite difference model, which is commonly introduced
in numerical methods texts, is just too impractical in handling multidimensional
boundary value problems.
As usual, the book contains more material than can be covered in a three-credit
course. The topics that can be skipped without loss of continuity are tagged with an
asterisk (*).
The programs listed in this book were tested with Python 2.2.2 and 2.3.4 under
Windows XP and Red Hat Linux. The source code can be downloaded from the book’s
website at
www.cambridge.org/0521852870
The author wishes to express his gratitude to the anonymous reviewers and
Professor Andrew Pytel for their suggestions for improving the manuscript. Credit
is also due to the authors of Numerical Recipes (Cambridge University Press) whose
presentation of numerical methods was inspirational in writing this book.

1
Introduction to Python
1.1
General Information
Quick Overview
This chapter is not a comprehensive manual of Python. Its sole aim is to provide
sufﬁcient information to give you a good start if you are unfamiliar with Python. If you
know another computer language, and presumably you do, it is not difﬁcult to pick
up the rest as you go.
Python is an object-oriented language that was developed in late 1980s as a
scripting language (the name is derived from the British television show Monty
Python’s Flying Circus). Although Python is not as well known in engineering cir-
cles as some other languages, it has a considerable following in the programming
community—in fact, Python is considerably more widespread than Fortran. Python
may be viewed as an emerging language, since it is still being developed and re-
ﬁned. In the current state, it is an excellent language for developing engineering
applications—it possesses a simple elegance that other programming languages can-
not match.
Python programs are not compiled into machine code, but are run by an inter-
preter1. The great advantage of an interpreted language is that programs can be tested
and debugged quickly, allowing the user to concentrate more on the principles be-
hind the program and less on programming itself. Since there is no need to compile,
link and execute after each correction, Python programs can be developed in a much
shorter time than equivalent Fortran or C programs. On the negative side, interpreted
programs do not produce stand-alone applications. Thus a Python program can be
run only on computers that have the Python interpreter installed.
1 The Python interpreter also compiles byte code, which helps to speed up execution somewhat.
1

2
Introduction to Python
Python has other advantages over mainstream languages that are important in a
learning environment:
r Python is open-source software, which means that it is free; it is included in most
Linux distributions.
r Pythonisavailableforallmajoroperatingsystems(Linux,Unix,Windows,MacOS
etc.). A program written on one system runs without modiﬁcation on all systems.
r Python is easier to learn and produces more readable code than other languages.
r Python and its extensions are easy to install.
Development of Python was clearly inﬂuenced by Java and C++, but there is also
a remarkable similarity to MATLAB® (another interpreted language, very popular
in scientiﬁc computing). Python implements the usual concepts of object-oriented
languages such as classes, methods, inheritance etc. We will forego these concepts
and use Python strictly as a procedural language.
To get an idea of the similarities between MATLAB and Python, let us look at the
codes written in the two languages for solution of simultaneous equations Ax = b by
Gauss elimination. Here is the function written in MATLAB:
function [x,det] = gaussElimin(a,b)
n = length(b);
for k = 1:n-1
for i = k+1:n
if a(i,k) ˜= 0
lam = a(i,k)/a(k,k);
a(i,k+1:n) = a(i,k+1:n) - lam*a(k,k+1:n);
b(i)= b(i) - lam*b(k);
end
end
end
det = prod(diag(a));
for k = n:-1:1
b(k) = (b(k) - a(k,k+1:n)*b(k+1:n))/a(k,k);
end
x = b;
The equivalent Python function is:
from numarray import dot
def gaussElimin(a,b):
n = len(b)

3
1.1 General Information
for k in range(0,n-1):
for i in range(k+1,n):
if a[i,k] != 0.0:
lam = a [i,k]/a[k,k]
a[i,k+1:n] = a[i,k+1:n] - lam*a[k,k+1:n]
b[i] = b[i] - lam*b[k]
for k in range(n-1,-1,-1):
b[k] = (b[k] - dot(a[k,k+1:n],b[k+1:n]))/a[k,k]
return b
The command from numarray import dot instructs the interpreter to load
the function dot (which computes the dot product of two vectors) from the module
numarray. The colon (:) operator, known as the slicing operator in Python, works the
same way it does in MATLAB and Fortran90—it deﬁnes a section of an array.
The statement for k = 1:n-1 in MATLAB creates a loop that is executed with
k = 1, 2, . . . , n−1. The same loop appears in Python as for k in range(n-1).
Here the function range(n-1) creates the list [0, 1, . . . , n−2]; k then loops over
the elements of the list. The differences in the ranges of k reﬂect the native off-
sets used for arrays. In Python all sequences have zero offset, meaning that the in-
dex of the ﬁrst element of the sequence is always 0. In contrast, the native offset in
MATLAB is 1.
Also note that Python has no end statements to terminate blocks of code (loops,
conditionals,subroutinesetc.).Thebodyofablockisdeﬁnedbyitsindentation;hence
indentation is an integral part of Python syntax.
Like MATLAB, Python is case sensitive. Thus the names n and N would represent
different objects.
Obtaining Python
Python interpreter can be downloaded from the Python Language Website
www.python.org. It normally comes with a nice code editor called Idle that allows
you to run programs directly from the editor. For scientiﬁc programming we also
need the Numarray module which contains various tools for array operations. It is
obtainable from the Numarray Home Page http://www.stsci.edu/resources/
software hardware/numarray. Both sites also provide documentation for down-
loading. If you use Linux or Mac OS, it is very likely that Python is already installed on
your machine (but you must still download Numarray).
You should acquire other printed material to supplement the on-line documen-
tation. A commendable teaching guide is Python by Chris Fehly, Peachpit Press, CA
(2002). As a reference, Python Essential Reference by David M. Beazley, New Riders

4
Introduction to Python
Publishing (2001) is recommended. By the time you read this, newer editions may be
available.
1.2
Core Python
Variables
In most computer languages the name of a variable represents a value of a given
type stored in a ﬁxed memory location. The value may be changed, but not the
type. This it not so in Python, where variables are typed dynamically. The follow-
ing interactive session with the Python interpreter illustrates this (>>> is the Python
prompt):
>>> b = 2
# b is integer type
>>> print b
2
>>> b = b * 2.0
# Now b is float type
>>> print b
4.0
The assignment b = 2 creates an association between the name b and the integer
value 2. The next statement evaluates the expression b * 2.0 and associates the
result with b; the original association with the integer 2 is destroyed. Now b refers to
the ﬂoating point value 4.0.
The pound sign (#) denotes the beginning of a comment—all characters between
# and the end of the line are ignored by the interpreter.
Strings
A string is a sequence of characters enclosed in single or double quotes. Strings are
concatenated with the plus (+) operator, whereas slicing (:) is used to extract a portion
of the string. Here is an example:
>>> string1 = ’Press return to exit’
>>> string2 = ’the program’
>>> print string1 + ’ ’ + string2
# Concatenation
Press return to exit the program
>>> print string1[0:12]
# Slicing
Press return

5
1.2 Core Python
Astringisanimmutableobject—itsindividualcharacterscannotbemodiﬁedwith
an assignment statement and it has a ﬁxed length. An attempt to violate immutability
will result in TypeError, as shown below.
>>> s = ’Press return to exit’
>>> s[0] = ’p’
Traceback (most recent call last):
File ’’<pyshell#1>’’, line 1, in ?
s[0] = ’p’
TypeError: object doesn’t support item assignment
Tuples
A tuple is a sequence of arbitrary objects separated by commas and enclosed in paren-
theses. If the tuple contains a single object, the parentheses may be omitted. Tuples
support the same operations as strings; they are also immutable. Here is an example
where the tuple rec contains another tuple (6,23,68):
>>> rec = (’Smith’,’John’,(6,23,68))
# This is a tuple
>>> lastName,firstName,birthdate = rec
# Unpacking the tuple
>>> print firstName
John
>>> birthYear = birthdate[2]
>>> print birthYear
68
>>> name = rec[1] + ’ ’ + rec[0]
>>> print name
John Smith
>>> print rec[0:2]
(’Smith’, ’John’)
Lists
A list is similar to a tuple, but it is mutable, so that its elements and length can be
changed. A list is identiﬁed by enclosing it in brackets. Here is a sampling of operations
that can be performed on lists:
>>> a = [1.0, 2.0, 3.0]
# Create a list
>>> a.append(4.0)
# Append 4.0 to list
>>> print a
[1.0, 2.0, 3.0, 4.0]

6
Introduction to Python
>>> a.insert(0,0.0)
# Insert 0.0 in position 0
>>> print a
[0.0, 1.0, 2.0, 3.0, 4.0]
>>> print len(a)
# Determine length of list
5
>>> a[2:4] = [1.0, 1.0] # Modify selected elements
>>> print a
[0.0, 1.0, 1.0, 1.0, 1.0, 4.0]
If a is a mutable object, such as a list, the assignment statement b = a does not
result in a new object b, but simply creates a new reference to a. Thus any changes
made to b will be reﬂected in a. To create an independent copy of a list a, use the
statement c = a[:], as illustrated below.
>>> a = [1.0, 2.0, 3.0]
>>> b = a
# ’b’ is an alias of ’a’
>>> b[0] = 5.0
# Change ’b’
>>> print a
[5.0, 2.0, 3.0]
# The change is reflected in ’a’
>>> c = a[:]
# ’c’ is an independent copy of ’a’
>>> c[0] = 1.0
# Change ’c’
>>> print a
[5.0, 2.0, 3.0]
# ’a’ is not affected by the change
Matrices can represented as nested lists with each row being an element of the
list. Here is a 3 × 3 matrix a in the form of a list:
>>> a = [[1, 2, 3], \
[4, 5, 6], \
[7, 8, 9]]
>>> print a[1]
# Print second row (element 1)
[4, 5, 6]
>>> print a[1][2]
# Print third element of second row
6
Thebackslash(\)isPython’scontinuationcharacter.RecallthatPythonsequences
have zero offset, so that a[0] represents the ﬁrst row, a[1] the second row, etc. With
veryfewexceptionswedonotuselistsfornumericalarrays.Itismuchmoreconvenient

7
1.2 Core Python
to employ array objects provided by the numarray module, (an extension of Python
language). Array objects will be discussed later.
Arithmetic Operators
Python supports the usual arithmetic operators:
+
Addition
−
Subtraction
∗
Multiplication
/
Division
∗∗
Exponentiation
%
Modular division
Some of these operators are also deﬁned for strings and sequences as illustrated
below.
>>> s = ’Hello ’
>>> t = ’to you’
>>> a = [1, 2, 3]
>>> print 3*s
# Repetition
Hello Hello Hello
>>> print 3*a
# Repetition
[1, 2, 3, 1, 2, 3, 1, 2, 3]
>>> print a + [4, 5]
# Append elements
[1, 2, 3, 4, 5]
>>> print s + t
# Concatenation
Hello to you
>>> print 3 + s
# This addition makes no sense
Traceback (most recent call last):
File ’’<pyshell#9>’’, line 1, in ?
print n + s
TypeError: unsupported operand types for +: ’int’ and ’str’
Python 2.0 and later versions also have augmented assignment operators, such as
a + = b, that are familiar to the users of C. The augmented operators and the equiv-
alent arithmetic expressions are shown in the following table.

8
Introduction to Python
a += b
a = a + b
a -= b
a = a - b
a *= b
a = a*b
a /= b
a = a/b
a **= b
a = a**b
a %= b
a = a%b
Comparison Operators
Thecomparison(relational)operatorsreturn1fortrueand0forfalse.Theseoperators
are
<
Less than
>
Greater than
<=
Less than or equal to
>=
Greater than or equal to
==
Equal to
!=
Not equal to
Numbersofdifferenttype(integer,ﬂoatingpointetc.)areconvertedtoacommontype
before the comparison is made. Otherwise, objects of different type are considered to
be unequal. Here are a few examples:
>>> a = 2
# Integer
>>> b = 1.99
# Floating point
>>> c = ’2’
# String
>>> print a > b
1
>>> print a == c
0
>>> print (a > b) and (a != c)
1
>>> print (a > b) or (a == b)
1

9
1.2 Core Python
Conditionals
The if construct
if condition:
block
executes a block of statements (which must be indented) if the condition returns true.
If the condition returns false, the block skipped. The if conditional can be followed
by any number of elif (short for “else if”) constructs
elif condition:
block
which work in the same manner. The else clause
else:
block
can be used to deﬁne the block of statements which are to be executed if none of
the if-elif clauses are true. The function sign of a below illustrates the use of the
conditionals.
def sign_of_a(a):
if a < 0.0:
sign = ’negative’
elif a > 0.0:
sign = ’positive’
else:
sign = ’zero’
return sign
a = 1.5
print ’a is ’ + sign_of_a(a)
Running the program results in the output
a is positive

10
Introduction to Python
Loops
The while construct
while condition:
block
executes a block of (indented) statements if the condition is true. After execution of
the block, the condition is evaluated again. If it is still true, the block is executed again.
This process is continued until the condition becomes false. The else clause
else:
block
can be used to deﬁne the block of statements which are to be executed if condition is
false. Here is an example that creates the list [1, 1/2, 1/3, . . .]:
nMax = 5
n = 1
a = []
# Create empty list
while n < nMax:
a.append(1.0/n)
# Append element to list
n = n + 1
print a
The output of the program is
[1.0, 0.5, 0.33333333333333331, 0.25]
We met the for statement before in Art. 1.1. This statement requires a target and
a sequence (usually a list) over which the target loops. The form of the construct is
for target in sequence:
block
You may add an else clause which is executed after the for loop has ﬁnished. The
previous program could be written with the for construct as

11
1.2 Core Python
nMax = 5
a = []
for n in range(1,nMax):
a.append(1.0/n)
print a
Here n is the target and the list [1,2, ...,nMax-1], created by calling the range
function, is the sequence.
Any loop can be terminated by the break statement. If there is an else cause
associated with the loop, it is not executed. The following program, which searches
for a name in a list, illustrates the use of break and else in conjunction with a for
loop:
list = [’Jack’, ’Jill’, ’Tim’, ’Dave’]
name = eval(raw_input(’Type a name: ’))
# Python input prompt
for i in range(len(list)):
if list[i] == name:
print name,’is number’,i + 1,’on the list’
break
else:
print name,’is not on the list’
Here are the results of two searches:
Type a name: ’Tim’
Tim is number 3 on the list
Type a name: ’June’
June is not on the list
Type Conversion
If an arithmetic operation involves numbers of mixed types, the numbers are au-
tomatically converted to a common type before the operation is carried out. Type
conversions can also achieved by the following functions:

12
Introduction to Python
int(a)
Converts a to integer
long(a)
Converts a to long integer
float(a)
Converts a to ﬂoating point
complex(a)
Converts to complex a + 0 j
complex(a,b)
Converts to complex a + bj
The above functions also work for converting strings to numbers as long as the
literal in the string represents a valid number. Conversion from ﬂoat to an integer is
carried out by truncation, not by rounding off. Here are a few examples:
>>> a = 5
>>> b = -3.6
>>> d = ’4.0’
>>> print a + b
1.4
>>> print int(b)
-3
>>> print complex(a,b)
(5-3.6j)
>>> print float(d)
4.0
>>> print int(d)
# This fails: d is not Int type
Traceback (most recent call last):
File ’’<pyshell#7>’’, line 1, in ?
print int(d)
ValueError: invalid literal for int(): 4.0
Mathematical Functions
Core Python supports only a few mathematical functions. They are:
abs(a)
Absolute value of a
max(sequence)
Largest element of sequence
min(sequence)
Smallest element of sequence
round(a,n)
Round a to n decimal places
cmp(a,b)
Returns



−1 if a < b
0 if a
= b
1 if a > b

13
1.2 Core Python
The majority of mathematical functions are available in the math module.
Reading Input
The intrinsic function for accepting user input is
raw input(prompt)
It displays the prompt and then reads a line of input which is converted to a string. To
convert the string into a numerical value use the function
eval(string)
The following program illustrates the use of these functions:
a = raw_input(’Input a: ’)
print a, type(a)
# Print a and its type
b = eval(a)
print b,type(b)
# Print b and its type
The function type(a) returns the type of the object a; it is a very useful tool in
debugging. The program was run twice with the following results:
Input a: 10.0
10.0 <type ’str’>
10.0 <type ’float’>
Input a: 11**2
11**2 <type ’str’>
121 <type ’int’>
A convenient way to input a number and assign it to the variable a is
a = eval(raw input(prompt))

14
Introduction to Python
Printing Output
Output can be displayed with the print statement:
print object1, object2, . . .
which converts object1, object2 etc. to strings and prints them on the same line, sep-
arated by spaces. The newline character ’\n’ can be uses to force a new line. For
example,
>>> a = 1234.56789
>>> b = [2, 4, 6, 8]
>>> print a,b
1234.56789 [2, 4, 6, 8]
>>> print ’a =’,a, ’\nb =’,b
a = 1234.56789
b = [2, 4, 6, 8]
The modulo operator (%) can be used to format a tuple. The form of the conversion
statement is
’%format1 %format2 · · · ’ % tuple
where format1, format2 · · · are the format speciﬁcations for each object in the tuple.
Typically used format speciﬁcations are
wd
Integer
w.df
Floating point notation
w.de
Exponential notation
where w is the width of the ﬁeld and d is the number of digits after the decimal
point. The output is right-justiﬁed in the speciﬁed ﬁeld and padded with blank spaces
(there are provisions for changing the justiﬁcation and padding). Here are a couple of
examples:
>>> a = 1234.56789
>>> n = 9876
>>> print ’%7.2f’ % a
1234.57
>>> print ’n = %6d’ % n
# Pad with 2 spaces
n =
9876

15
1.3 Functions and Modules
>>> print ’n = %06d’ %n
# Pad with 2 zeroes
n = 009876
>>> print ’%12.4e %6d’ % (a,n)
1.2346e+003
9876
Error Control
When an error occurs during execution of a program an exception is raised and the
program stops. Exceptions can be caught with try and except statements:
try:
do something
except error:
do something else
where error is the name of a built-in Python exception. If the exception error is not
raised, the try block is executed; otherwise the execution passes to the except block.
All exceptions can be caught by omitting error from the except statement.
Here is a statement that raises the exception ZeroDivisionError:
>>> c = 12.0/0.0
Traceback (most recent call last):
File ’’<pyshell#0>’’, line 1, in ?
c = 12.0/0.0
ZeroDivisionError: float division
This error can be caught by
try:
c = 12.0/0.0
except ZeroDivisionError:
print ’Division by zero’
1.3
Functions and Modules
Functions
The structure of a Python function is
def func name(param1, param2,. . .):
statements
return return values

16
Introduction to Python
where param1, param2,. . . are the parameters. A parameter can be any Python ob-
ject, including a function. Parameters may be given default values, in which case the
parameter in the function call is optional. If the return statement or return values
are omitted, the function returns the null object.
The following example computes the ﬁrst two derivatives of arctan(x) by ﬁnite
differences:
from math import arctan
def
finite_diff(f,x,h=0.0001):
# h has a default value
df =(f(x+h) - f(x-h))/(2.0*h)
ddf =(f(x+h) - 2.0*f(x) + f(x-h))/h**2
return df,ddf
x = 0.5
df,ddf = finite_diff(arctan,x)
# Uses default value of h
print ’First derivative
=’,df
print ’Second derivative =’,ddf
Note that arctan is passed to finite diff as a parameter. The output from the
program is
First derivative
= 0.799999999573
Second derivative = -0.639999991892
If a mutable object, such as a list, is passed to a function where it is modiﬁed, the
changes will also appear in the calling program. Here is an example:
def squares(a):
for i in range(len(a)):
a[i] = a[i]**2
a = [1, 2, 3, 4]
squares(a)
print a
The output is
[1, 4, 9, 16]

17
1.4 Mathematics Modules
Modules
It is sound practice to store useful functions in modules. A module is simply a ﬁle
where the functions reside; the name of the module is the name of the ﬁle. A module
can be loaded into a program by the statement
from module name import *
Pythoncomeswithalargenumberofmodulescontainingfunctionsandmethods
for various tasks. Two of the modules are described brieﬂy in the next section. Addi-
tional modules, including graphics packages, are available for downloading on the
Web.
1.4
Mathematics Modules
math Module
Most mathematical functions are not built into core Python, but are available by
loading the math module. There are three ways of accessing the functions in a module.
The statement
from math import *
loads all the function deﬁnitions in the math module into the current function or
module. The use of this method is discouraged because it is not only wasteful, but can
also lead to conﬂicts with deﬁnitions loaded from other modules.
You can load selected deﬁnitions by
from math import func1, func2,. . .
as illustrated below.
>>> from math import log,sin
>>> print log(sin(0.5))
-0.735166686385

18
Introduction to Python
The third method, which is used by the majority of programmers, is to make the
module available by
import math
The functions in the module can then be accessed by using the module name as a
preﬁx:
>>> import math
>>> print math.log(math.sin(0.5))
-0.735166686385
The contents of a module can be printed by calling dir(module). Here is how to
obtain a list of the functions in the math module:
>>> import math
>>> dir(math)
[’__doc__’, ’__name__’, ’acos’, ’asin’, ’atan’,
’atan2’, ’ceil’, ’cos’, ’cosh’, ’e’, ’exp’, ’fabs’,
’floor’, ’fmod’, ’frexp’, ’hypot’, ’ldexp’, ’log’,
’log10’, ’modf’, ’pi’, ’pow’, ’sin’, ’sinh’, ’sqrt’,
’tan’, ’tanh’]
Most of these functions are familiar to programmers. Note that the module in-
cludes two constants: π and e.
cmath Module
The cmath module provides many of the functions found in the math module, but
these accept complex numbers. The functions in the module are:
[’__doc__’, ’__name__’, ’acos’, ’acosh’, ’asin’, ’asinh’,
’atan’, ’atanh’, ’cos’, ’cosh’, ’e’, ’exp’, ’log’,
’log10’, ’pi’, ’sin’, ’sinh’, ’sqrt’, ’tan’, ’tanh’]
Here are examples of complex arithmetic:
>>> from cmath import sin
>>> x = 3.0 -4.5j
>>> y = 1.2 + 0.8j
>>> z = 0.8

19
1.5 numarray Module
>>> print x/y
(-2.56205313375e-016-3.75j)
>>> print sin(x)
(6.35239299817+44.5526433649j)
>>> print sin(z)
(0.7173560909+0j)
1.5
numarray Module
General Information
The numarray module2 is not a part of the standard Python release. As pointed out
before, it must be obtained separately and installed (the installation is very easy). The
module introduces array objects which are similar to lists, but can be manipulated by
numerous functions contained in the module. The size of the array is immutable and
no empty elements are allowed.
The complete set of functions in numarray is too long to be printed in its entirety.
The list below is limited to the most commonly used functions.
[’Complex’, ’Complex32’, ’Complex64’, ’Float’,
’Float32’, ’Float64’, ’abs’, ’arccos’,
’arccosh’, ’arcsin’, ’arcsinh’, ’arctan’,
’arctan2’, ’arctanh’, ’argmax’, ’argmin’,
’cos’, ’cosh’, ’diagonal’, ’dot’, ’e’, ’exp’,
’floor’, ’identity’, ’innerproduct’, ’log’,
’log10’, ’matrixmultiply’, ’maximum’, ’minimum’,
’numarray’, ’ones’, ’pi’, ’product’ ’sin’, ’sinh’,
’size’, ’sqrt’, ’sum’, ’tan’, ’tanh’, ’trace’,
’transpose’, ’zeros’]
Creating an Array
Arrays can be created in several ways. One of them is to use the array function to
turn a list into an array:
array(list,type = type speciﬁcation)
2 Numarray is based on an older Python array module called Numeric. Their interfaces and capa-
bilities are very similar and they are largely compatible. Although Numeric is still available, it is no
longer supported.

20
Introduction to Python
Here are two examples of creating a 2 × 2 array with ﬂoating-point elements:
>>> from numarray import array,Float
>>> a = array([[2.0, -1.0],[-1.0, 3.0]])
>>> print a
[[ 2. -1.]
[-1.
3.]]
>>> b = array([[2, -1],[-1, 3]],type = Float)
>>> print b
[[ 2. -1.]
[-1.
3.]]
Other available functions are
zeros((dim1,dim2),type = type speciﬁcation)
which creates a dim1 × dim2 array and ﬁlls it with zeroes, and
ones((dim1,dim2),type = type speciﬁcation)
which ﬁlls the array with ones. The default type in both cases is Int.
Finally, there is the function
arange(from,to,increment)
which works just like the range function, but returns an array rather than a list. Here
are examples of creating arrays:
>>> from numarray import arange,zeros,ones,Float
>>> a = arange(2,10,2)
>>> print a
[2 4 6 8]
>>> b = arange(2.0,10.0,2.0)
>>> print b
[ 2.
4.
6.
8.]
>>> z = zeros((4))
>>> print z
[0 0 0 0]

21
1.5 numarray Module
>>> y = ones((3,3),type= Float)
>>> print y
[[ 1.
1.
1.]
[ 1.
1.
1.]
[ 1.
1.
1.]]
Accessing and Changing Array Elements
If a is a rank-2 array, then a[i, j] accesses the element in row i and column j, whereas
a[i] refers to row i. The elements of an array can be changed by assignment as shown
below.
>>> from numarray import *
>>> a = zeros((3,3),type=Float)
>>> a[0] = [2.0, 3.1, 1.8]
# Change a row
>>> a[1,1] = 5.2
# Change an element
>>> a[2,0:2] = [8.0, -3.3]
# Change part of a row
>>> print a
[[ 2.
3.1
1.8]
[ 0.
5.2
0. ]
[ 8.
-3.3
0. ]]
Operations on Arrays
Arithmetic operators work differently on arrays than they do on tuples and lists—the
operation is broadcast to all the elements of the array; that is, the operation is applied
to each element in the array. Here are examples:
>>> from numarray import array
>>> a = array([0.0, 4.0, 9.0, 16.0])
>>> print a/16.0
[ 0.
0.25
0.5625
1.
]
>>> print a - 4.0
[ -4.
0.
5.
12.]
The mathematical functions available in numarray are also broadcast, as illus-
trated below
>>> from numarray import array,sqrt,sin
>>> a = array([1.0, 4.0, 9.0, 16.0])

22
Introduction to Python
>>> print sqrt(a)
[ 1.
2.
3.
4.]
>>> print sin(a)
[ 0.84147098 -0.7568025
0.41211849 -0.28790332]
Functions imported from the math module will work on the individual elements,
of course, but not on the array itself. Here is an example:
>>> from numarray import array
>>> from math import sqrt
>>> a = array([1.0, 4.0, 9.0, 16.0])
>>> print sqrt(a[1])
2.0
>>> print sqrt(a)
Traceback (most recent call last):
...
TypeError: Only rank-0 arrays can be cast to floats.
Array Functions
There are numerous array functions in numarray that perform matrix operations and
other useful tasks. Here are a few examples:
>>> from numarray import *
>>> a = array([[ 4.0, -2.0,
1.0], \
[-2.0,
4.0, -2.0], \
[ 1.0, -2.0,
3.0]])
>>> b = array([1.0, 4.0, 2.0])
>>> print dot(b,b)
# Dot product
21.0
>>> print matrixmultiply(a,b)
# Matrix multiplication
[ -2.
10.
-1.]
>>> print diagonal(a)
# Principal diagonal
[ 4.
4.
3.]
>>> print diagonal(a,1)
# First subdiagonal
[-2. -2.]
>>> print trace(a)
# Sum of diagonal elements
11.0

23
1.6 Scoping of Variables
>>> print argmax(b)
# Index of largest element
1
>>> print identity(3)
# Identity matrix
[[1 0 0]
[0 1 0]
[0 0 1]]
Copying Arrays
We explained before that if a is a mutable object, such as a list, the assignment state-
ment b = a does not result in a new object b, but simply creates a new reference to
a, called a deep copy. This also applies to arrays. To make an independent copy of an
array a, use the copy method in the numarray module:
b = a.copy()
1.6
Scoping of Variables
Namespace is a dictionary that contains the names of the variables and their values.
The namespaces are automatically created and updated as a program runs. There are
three levels of namespaces in Python:
r Local namespace, which is created when a function is called. It contains the
variables passed to the function as arguments and the variables created within
thefunction.Thenamespaceisdeletedwhenthefunctionterminates.Ifavariable
is created inside a function, its scope is the function’s local namespace. It is not
visible outside the function.
r A global namespace is created when a module is loaded. Each module has its own
namespace. Variables assigned in a global namespace are visible to any function
within the module.
r Built-innamespaceiscreatedwhentheinterpreterstarts.Itcontainsthefunctions
that come with the Python interpreter. These functions can be accessed by any
program unit.
When a name is encountered during execution of a function, the interpreter
tries to resolve it by searching the following in the order shown: (1) local namespace,
(2) global namespace, and (3) built-in namespace. If the name cannot be resolved,
Python raises a NameError exception.
Since the variables residing in a global namespace are visible to functions within
the module, it is not necessary to pass them to the functions as arguments (although
is good programming practice to do so), as the following program illustrates.

24
Introduction to Python
def divide():
c = a/b
print ’a/b =’,c
a = 100.0
b = 5.0
divide()
>>>
a/b = 20.0
Note that the variable c is created inside the function divide and is thus not
accessible to statements outside the function. Hence an attempt to move the print
statement out of the function fails:
def divide():
c = a/b
a = 100.0
b = 5.0
divide()
print ’a/b =’,c
>>>
Traceback (most recent call last):
File ’’C:\Python22\scope.py’’, line 8, in ?
print c
NameError: name ’c’ is not defined
1.7
Writing and Running Programs
When the Python editor Idle is opened, the user is faced with the prompt >>>, in-
dicating that the editor is in interactive mode. Any statement typed into the edi-
tor is immediately processed upon pressing the enter key. The interactive mode is a
good way to learn the language by experimentation and to try out new programming
ideas.
Opening a new window places Idle in the batch mode, which allows typing and
saving of programs. One can also use a text editor to enter program lines, but Idle has
Python-speciﬁcfeatures,suchascolorcodingofkeywordsandautomaticindentation,
that make work easier. Before a program can be run, it must be saved as a Python ﬁle
with the .py extension, e.g., myprog.py. The program can then be executed by typing

25
1.7 Writing and Running Programs
python myprog.py;inWindows,double-clickingontheprogramiconwillalsowork.
But beware: the program window closes immediately after execution, before you get
a chance to read the output. To prevent this from happening, conclude the program
with the line
raw input(’press return’)
Double-clicking the program icon also works in Unix and Linux if the ﬁrst line
of the program speciﬁes the path to the Python interpreter (or a shell script that
provides a link to Python). The path name must be preceded by the symbols #!. On my
computer the path is /usr/bin/python, so that all my programs start with the line
#!/usr/bin/python
On multiuser systems the path is usually /usr/local/bin/python.
When a module is loaded into a program for the ﬁrst time with the import state-
ment, it is compiled into bytecode and written in a ﬁle with the extension .pyc. The
next time the program is run, the interpreter loads the bytecode rather than the origi-
nalPythonﬁle.Ifinthemeantimechangeshavebeenmadetothemodule,themodule
is automatically recompiled. A program can also be run from Idle using edit/run script
menu, but automatic recompilation of modules will not take place, unless the existing
bytecode ﬁle is deleted and the program window is closed and reopened.
Python’s error messages can sometimes be confusing, as seen in the following
example:
from numarray import array
a = array([1.0, 2.0, 3.0]
print a
raw_input(’press return’)
The output is
File ’’C:\Python22\test_module.py’’, line 3
print a
ˆ
SyntaxError: invalid syntax
What could possibly be wrong with the line print a? The answer is nothing. The
problem is actually in the preceding line, where the closing parenthesis is missing,

26
Introduction to Python
making the statement incomplete. Consequently, the interpreter views the third line
as continuation of the second line, so that it tries to interpret the statement
a = array([1.0, 2.0, 3.0]print a
The lesson is this: when faced with a SyntaxError, look at the line preceding the
alleged offender. It can save a lot of frustration.
It is a good idea to document your modules by adding a docstring the beginning of
each module. The docstring, which is enclosed in triple quotes, should explain what
the module does. Here is an example that documents the module error (we use this
module in several of our programs):
## module error
’’’ err(string).
Prints ’string’ and terminates program.
’’’
import sys
def err(string):
print string
raw_input(’Press return to exit’)
sys.exit()
The docstring of a module can be printed with the statement
print module name.
doc
For example, the docstring of error is displayed by
>>> import error
>>> print error.__doc__
err(string).
Prints ’string’ and terminates program.

2
Systems of Linear Algebraic Equations
Solve the simultaneous equations Ax = b
2.1
Introduction
In this chapter we look at the solution of nlinear, algebraic equations in nunknowns.
It is by far the longest and arguably the most important topic in the book. There is a
goodreasonforthis—itisalmostimpossibletocarryoutnumericalanalysisofanysort
without encountering simultaneous equations. Moreover, equation sets arising from
physical problems are often very large, consuming a lot of computational resources.
It usually possible to reduce the storage requirements and the run time by exploiting
special properties of the coefﬁcient matrix, such as sparseness (most elements of a
sparse matrix are zero). Hence there are many algorithms dedicated to the solution of
large sets of equations, each one being tailored to a particular form of the coefﬁcient
matrix (symmetric, banded, sparse etc.). A well-known collection of these routines is
LAPACK—Linear Algebra PACKage, originally written in Fortran773.
We cannot possibly discuss all the special algorithms in the limited space avail-
able. The best we can do is to present the basic methods of solution, supplemented
by a few useful algorithms for banded and sparse coefﬁcient matrices.
Notation
A system of algebraic equations has the form
A11x1 + A12x2 + · · · + A1nxn = b1
3 LAPACK is the successor of LINPACK, a 1970s and 80s collection of Fortran subroutines.
27

28
Systems of Linear Algebraic Equations
A21x1 + A22x2 + · · · + A2nxn = b2
(2.1)
...
An1x1 + An2x2 + · · · + Annxn = bn
where the coefﬁcients Aij and the constants bj are known, and xi represent the un-
knowns. In matrix notation the equations are written as


A11
A12
· · ·
A1n
A21
A22
· · ·
A2n
...
...
...
...
An1
An2
· · ·
Ann




x1
x2
...
xn


=


b1
b2
...
bn


(2.2)
or, simply
Ax = b
(2.3)
A particularly useful representation of the equations for computational purposes
is the augmented coefﬁcient matrix obtained by adjoining the constant vector b to the
coefﬁcient matrix A in the following fashion:

A
b

=


A11
A12
· · ·
A1n
b1
A21
A22
· · ·
A2n
b2
...
...
...
...
...
An1
An2
· · ·
Ann
bn


(2.4)
Uniqueness of Solution
A system of n linear equations in n unknowns has a unique solution, provided that
the determinant of the coefﬁcient matrix is nonsingular; that is, |A| ̸= 0. The rows and
columns of a nonsingular matrix are linearly independent in the sense that no row (or
column) is a linear combination of other rows (or columns).
If the coefﬁcient matrix is singular, the equations may have an inﬁnite number of
solutions, or no solutions at all, depending on the constant vector. As an illustration,
take the equations
2x + y = 3
4x + 2y = 6
Since the second equation can be obtained by multiplying the ﬁrst equation by two,
any combination of x and y that satisﬁes the ﬁrst equation is also a solution of the

29
2.1 Introduction
second equation. The number of such combinations is inﬁnite. On the other hand,
the equations
2x + y = 3
4x + 2y = 0
have no solution because the second equation, being equivalent to 2x + y = 0, con-
tradicts the ﬁrst one. Therefore, any solution that satisﬁes one equation cannot satisfy
the other one.
Ill-Conditioning
An obvious question is: what happens when the coefﬁcient matrix is almost singular;
i.e.,if|A|isverysmall?Inordertodeterminewhetherthedeterminantofthecoefﬁcient
matrixis“small,”weneedareferenceagainstwhichthedeterminantcanbemeasured.
This reference is called the norm of the matrix and is denoted by ∥A∥. We can then say
that the determinant is small if
|A| << ∥A∥
Several norms of a matrix have been deﬁned in existing literature, such as
∥A∥=




n

i=1
n

j=1
A2
ij
∥A∥= max
1≤i≤n
n

j=1
Aij

(2.5a)
A formal measure of conditioning is the matrix condition number, deﬁned as
cond(A) = ∥A∥
A−1
(2.5b)
If this number is close to unity, the matrix is well-conditioned. The condition number
increases with the degree of ill-conditioning, reaching inﬁnity for a singular matrix.
Notethattheconditionnumberisnotunique,butdependsonthechoiceofthematrix
norm. Unfortunately, the condition number is expensive to compute for large matri-
ces. In most cases it is sufﬁcient to gauge conditioning by comparing the determinant
with the magnitudes of the elements in the matrix.
If the equations are ill-conditioned, small changes in the coefﬁcient matrix result
in large changes in the solution. As an illustration, consider the equations
2x + y = 3
2x + 1.001y = 0
that have the solution x = 1501.5, y = −3000. Since |A| = 2(1.001) −2(1) = 0.002 is
much smaller than the coefﬁcients, the equations are ill-conditioned. The effect of
ill-conditioning can be veriﬁed by changing the second equation to 2x + 1.002y = 0
and re-solving the equations. The result is x = 751.5, y = −1500. Note that a 0.1%
change in the coefﬁcient of y produced a 100% change in the solution!

30
Systems of Linear Algebraic Equations
Numericalsolutionsofill-conditionedequationsarenottobetrusted.Thereason
is that the inevitable roundoff errors during the solution process are equivalent to in-
troducingsmallchangesintothecoefﬁcientmatrix.Thisinturnintroduceslargeerrors
into the solution, the magnitude of which depends on the severity of ill-conditioning.
In suspect cases the determinant of the coefﬁcient matrix should be computed so that
the degree of ill-conditioning can be estimated. This can be done during or after the
solution with only a small computational effort.
Linear Systems
Linear, algebraic equations occur in almost all branches of numerical analysis. But
their most visible application in engineering is in the analysis of linear systems (any
system whose response is proportional to the input is deemed to be linear). Linear
systems include structures, elastic solids, heat ﬂow, seepage of ﬂuids, electromagnetic
ﬁelds and electric circuits, i.e., most topics taught in an engineering curriculum.
If the system is discrete, such as a truss or an electric circuit, then its analysis
leads directly to linear algebraic equations. In the case of a statically determinate
truss, for example, the equations arise when the equilibrium conditions of the joints
are written down. The unknowns x1, x2, . . . , xn represent the forces in the members
and the support reactions, and the constants b1, b2, . . . , bn are the prescribed external
loads.
The behavior of continuous systems is described by differential equations, rather
than algebraic equations. However, because numerical analysis can deal only with
discrete variables, it is ﬁrst necessary to approximate a differential equation with a
system of algebraic equations. The well-known ﬁnite difference, ﬁnite element and
boundary element methods of analysis work in this manner. They use different ap-
proximationstoachievethe“discretization,”butineachcasetheﬁnaltaskisthesame:
solve a system (often a very large system) of linear, algebraic equations.
In summary, the modeling of linear systems invariably gives rise to equations of
the form Ax = b, where b is the input and x represents the response of the system. The
coefﬁcient matrix A, which reﬂects the characteristics of the system, is independent
of the input. In other words, if the input is changed, the equations have to be solved
again with a different b, but the same A. Therefore, it is desirable to have an equa-
tion solving algorithm that can handle any number of constant vectors with minimal
computational effort.
Methods of Solution
There are two classes of methods for solving systems of linear, algebraic equations:
direct and iterative methods. The common characteristic of direct methods is that they

31
2.1 Introduction
transform the original equations into equivalent equations (equations that have the
same solution) that can be solved more easily. The transformation is carried out by
applying the three operations listed below. These so-called elementary operations do
not change the solution, but they may affect the determinant of the coefﬁcient matrix
as indicated in parenthesis.
r Exchanging two equations (changes sign of |A|).
r Multiplying an equation by a nonzero constant (multiplies |A| by the same
constant).
r Multiplying an equation by a nonzero constant and then subtracting it from an-
other equation (leaves |A| unchanged).
Iterative, or indirect methods, start with a guess of the solution x, and then re-
peatedly reﬁne the solution until a certain convergence criterion is reached. Iterative
methods are generally less efﬁcient than their direct counterparts due to the large
number of iterations required. But they do have signiﬁcant computational advan-
tages if the coefﬁcient matrix is very large and sparsely populated (most coefﬁcients
are zero).
Overview of Direct Methods
Table2.1liststhreepopulardirectmethods,eachofwhichuseselementaryoperations
to produce its own ﬁnal form of easy-to-solve equations.
Method
Initial form
Final form
Gauss elimination
Ax = b
Ux = c
LU decomposition
Ax = b
LUx = b
Gauss–Jordan elimination
Ax = b
Ix = c
Table 2.1
In the above table U represents an upper triangular matrix, L is a lower triangular
matrix and I denotes the identity matrix. A square matrix is called triangular if it
contains only zero elements on one side of the leading diagonal. Thus a 3 × 3 upper
triangular matrix has the form
U =


U11
U12
U13
0
U22
U23
0
0
U33



32
Systems of Linear Algebraic Equations
and a 3 × 3 lower triangular matrix appears as
L =


L11
0
0
L21
L22
0
L31
L32
L33


Triangular matrices play an important role in linear algebra, since they simplify
many computations. For example, consider the equations Lx = c, or
L11x1 = c1
L21x1 + L22x2 = c2
L31x1 + L32x2 + L33x3 = c3
...
If we solve the equations forward, starting with the ﬁrst equation, the computations
are very easy, since each equation contains only one unknown at a time. The solution
would thus proceed as follows:
x1 = c1/L11
x2 = (c2 −L21x1)/L22
x3 = (c3 −L31x1 −L32x2)/L33
...
Thisprocedureisknownasforwardsubstitution.Inasimilarway,Ux = c,encountered
in Gauss elimination, can easily be solved by back substitution, which starts with the
last equation and proceeds backward through the equations.
The equations LUx = b, which are associated with LU decomposition, can also
be solved quickly if we replace them with two sets of equivalent equations: Ly = b
and Ux = y. Now Ly = b can be solved for y by forward substitution, followed by the
solution of Ux = y by means of back substitution.
The equations Ix = c, which are produced by Gauss–Jordan elimination, are
equivalent to x = c (recall the identity Ix = x), so that c is already the solution.
EXAMPLE 2.1
Determine whether the following matrix is singular:
A =


2.1
−0.6
1.1
3.2
4.7
−0.8
3.1
−6.5
4.1



33
2.2 Gauss Elimination Method
Solution Laplace’s development of the determinant (see Appendix A2) about the ﬁrst
row of A yields
|A| = 2.1

4.7
−0.8
−6.5
4.1
 −(−0.6)

3.2
−0.8
3.1
4.1
 + 1.1

3.2
4.7
3.1
−6.5

= 2.1(14.07) + 0.6(15.60) + 1.1(−35.37) = 0
Since the determinant is zero, the matrix is singular. It can be veriﬁed that the singu-
larity is due to the following row dependency: (row 3) = (3 × row 1) −(row 2).
EXAMPLE 2.2
Solve the equations Ax = b, where
A =


8
−6
2
−4
11
−7
4
−7
6


b =


28
−40
33


knowing that the LU decomposition of the coefﬁcient matrix is (you should verify this)
A = LU =


2
0
0
−1
2
0
1
−1
1




4
−3
1
0
4
−3
0
0
2


Solution We ﬁrst solve the equations Ly = b by forward substitution:
2y1 = 28
y1 = 28/2 = 14
−y1 + 2y2 = −40
y2 = (−40 + y1)/2 = (−40 + 14)/2 = −13
y1 −y2 + y3 = 33
y3 = 33 −y1 + y2 = 33 −14 −13 = 6
The solution x is then obtained from Ux = y by back substitution:
2x3 = y3
x3 = y3/2 = 6/2 = 3
4x2 −3x3 = y2
x2 = (y2 + 3x3)/4 = [−13 + 3(3)] /4 = −1
4x1 −3x2 + x3 = y1
x1 = (y1 + 3x2 −x3)/4 = [14 + 3(−1) −3] /4 = 2
Hence the solution is x =

2
−1
3
T
2.2
Gauss Elimination Method
Introduction
Gauss elimination is the most familiar method for solving simultaneous equations. It
consists of two parts: the elimination phase and the solution phase. As indicated in
Table 2.1, the function of the elimination phase is to transform the equations into the

34
Systems of Linear Algebraic Equations
form Ux = c. The equations are then solved by back substitution. In order to illustrate
the procedure, let us solve the equations
4x1 −2x2 + x3 = 11
(a)
−2x1 + 4x2 −2x3 = −16
(b)
x1 −2x2 + 4x3 = 17
(c)
Elimination phase The elimination phase utilizes only one of the elementary op-
erations listed in Table 2.1—multiplying one equation (say, equation j) by a constant
λ and subtracting it from another equation (equation i). The symbolic representation
of this operation is
Eq. (i) ←Eq. (i) −λ × Eq. ( j)
(2.6)
The equation being subtracted, namely Eq. ( j), is called the pivot equation.
We start the elimination by taking Eq. (a) to be the pivot equation and choosing
the multipliers λ so as to eliminate x1 from Eqs. (b) and (c):
Eq. (b) ←Eq. (b) −( −0.5) × Eq. (a)
Eq. (c) ←Eq. (c) −0.25 × Eq. (a)
After this transformation, the equations become
4x1 −2x2 + x3 = 11
(a)
3x2 −1.5x3 = −10.5
(b)
−1.5x2 + 3.75x3 = 14.25
(c)
This completes the ﬁrst pass. Now we pick (b) as the pivot equation and eliminate x2
from (c):
Eq. (c) ←Eq. (c) −( −0.5) × Eq.(b)
which yields the equations
4x1 −2x2 + x3 = 11
(a)
3x2 −1.5x3 = −10.5
(b)
3x3 = 9
(c)
The elimination phase is now complete. The original equations have been replaced
by equivalent equations that can be easily solved by back substitution.
As pointed out before, the augmented coefﬁcient matrix is a more conve-
nient instrument for performing the computations. Thus the original equations

35
2.2 Gauss Elimination Method
would be written as


4
−2
1
11
−2
4
−2
−16
1
−2
4
17


and the equivalent equations produced by the ﬁrst and the second passes of Gauss
elimination would appear as


4
−2
1
11.00
0
3
−1.5
−10.50
0
−1.5
3.75
14.25




4
−2
1
11.0
0
3
−1.5
−10.5
0
0
3
9.0


It is important to note that the elementary row operation in Eq. (2.6) leaves the de-
terminant of the coefﬁcient matrix unchanged. This is rather fortunate, since the de-
terminant of a triangular matrix is very easy to compute—it is the product of the
diagonal elements. In other words,
|A| = |U| = U11 × U22 × · · · × Unn
(2.7)
Back substitution phase The unknowns can now be computed by back substitu-
tion in the manner described in the previous article. Solving Eqs. (c), (b) and (a) in
that order, we get
x3 = 9/3 = 3
x2 = (−10.5 + 1.5x3)/3 = [−10.5 + 1.5(3)]/3 = −2
x1 = (11 + 2x2 −x3)/4 = [11 + 2(−2) −3]/4 = 1
Algorithm for Gauss Elimination Method
Elimination phase
Letuslookattheequationsatsomeinstantduringtheeliminationphase.Assumethat
theﬁrstkrowsofAhavealreadybeentransformedtouppertriangularform.Therefore,
the current pivot equation is the kth equation, and all the equations below it are still to
be transformed. This situation is depicted by the augmented coefﬁcient matrix shown
below. Note that the components of A are not the coefﬁcients of the original equations
(except for the ﬁrst row), since they have been altered by the elimination procedure.

36
Systems of Linear Algebraic Equations
The same applies to the components of the constant vector b.


A11
A12
A13
· · ·
A1k
· · ·
A1 j
· · ·
A1n
b1
0
A22
A23
· · ·
A2k
· · ·
A2 j
· · ·
A2n
b2
0
0
A33
· · ·
A3k
· · ·
A3 j
· · ·
A3n
b3
...
...
...
...
...
...
...
0
0
0
· · ·
Akk
· · ·
Akj
· · ·
Akn
bk
...
...
...
...
...
...
...
0
0
0
· · ·
Aik
· · ·
Aij
· · ·
Ain
bi
...
...
...
...
...
...
...
0
0
0
· · ·
Ank
· · ·
Anj
· · ·
Ann
bn


←pivot row
←row being
transformed
Let the ith row be a typical row below the pivot equation that is to be transformed,
meaning that the element Aik is to be eliminated. We can achieve this by multiplying
the pivot row by λ = Aik/Akk and subtracting it from the ith row. The corresponding
changes in the ith row are
Aij ←Aij −λAkj,
j = k, k + 1, . . . , n
(2.8a)
bi ←bi −λbk
(2.8b)
To transform the entire coefﬁcient matrix to upper triangular form, kand i in Eqs. (2.8)
must have the ranges k = 1, 2, . . . , n−1 (chooses the pivot row), i = k + 1, k + 2 . . . , n
(chooses the row to be transformed). The algorithm for the elimination phase now
almost writes itself:
for k in range(0,n-1):
for i in range(k+1,n):
if a[i,k] != 0.0:
lam = a[i,k]/a[k,k]
a[i,k+1:n] = a[i,k+1:n] - lam*a[k,k+1:n]
b[i] = b[i] - lam*b[k]
In order to avoid unnecessary operations, the above algorithm departs slightly
from Eqs. (2.8) in the following ways:
r If Aik happens to be zero, the transformation of row i is skipped.
r The index j in Eq. (2.8a) starts with k + 1 rather than k. Therefore, Aik is not
replacedbyzero,butretainsitsoriginalvalue.Asthesolutionphaseneveraccesses
the lower triangular portion of the coefﬁcient matrix anyway, its contents are
irrelevant.

37
2.2 Gauss Elimination Method
Back Substitution Phase
After Gauss elimination the augmented coefﬁcient matrix has the form

A
b

=


A11
A12
A13
· · ·
A1n
b1
0
A22
A23
· · ·
A2n
b2
0
0
A33
· · ·
A3n
b3
...
...
...
...
...
0
0
0
· · ·
Ann
bn


The last equation, Annxn = bn, is solved ﬁrst, yielding
xn = bn/Ann
(2.9)
Consider now the stage of back substitution where xn, xn−1, . . . , xk+1 have been
already been computed (in that order), and we are about to determine xk from the kth
equation
Akkxk + Ak,k+1xk+1 + · · · + Aknxn = bk
The solution is
xk =

bk −
n

j=k+1
Akjxj

1
Akk
,
k = n−1, n−2, . . . , 1
(2.10)
The corresponding algorithm for back substitution is:
for k in range(n-1,-1,-1):
x[k]=(b[k] - dot(a[k,k+1:n],x[k+1:n]))/a[k,k]
■gaussElimin
The function gaussElimin combines the elimination and the back substitution
phases. During back substitution b is overwritten by the solution vector x, so that
b contains the solution upon exit.
## module gaussElimin
’’’ x = gaussElimin(a,b).
Solves [a]{b}
= {x}
by Gauss elimination.
’’’
from numarray import dot
def gaussElimin(a,b):
n = len(b)
# Elimination phase

38
Systems of Linear Algebraic Equations
for k in range(0,n-1):
for i in range(k+1,n):
if a[i,k] != 0.0:
lam = a [i,k]/a[k,k]
a[i,k+1:n] = a[i,k+1:n] - lam*a[k,k+1:n]
b[i] = b[i] - lam*b[k]
# Back substitution
for k in range(n-1,-1,-1):
b[k] = (b[k] - dot(a[k,k+1:n],b[k+1:n]))/a[k,k]
return b
Multiple Sets of Equations
Asmentionedbefore,itisfrequentlynecessarytosolvetheequationsAx = bforseveral
constant vectors. Let there be msuch constant vectors, denoted by b1, b2, . . . , bm and
let the corresponding solution vectors be x1, x2, . . . , xm. We denote multiple sets of
equations by AX = B, where
X =

x1
x2
· · ·
xm

B =

b1
b2
· · ·
bm

are n× mmatrices whose columns consist of solution vectors and constant vectors,
respectively.
An economical way to handle such equations during the elimination phase is
to include all m constant vectors in the augmented coefﬁcient matrix, so that they
are transformed simultaneously with the coefﬁcient matrix. The solutions are then
obtained by back substitution in the usual manner, one vector at a time. It would
be quite easy to make the corresponding changes in gaussElimin. However, the LU
decomposition method, described in the next article, is more versatile in handling
multiple constant vectors.
EXAMPLE 2.3
Use Gauss elimination to solve the equations AX = B, where
A =


6
−4
1
−4
6
−4
1
−4
6


B =


−14
22
36
−18
6
7


Solution The augmented coefﬁcient matrix is


6
−4
1
−14
22
−4
6
−4
36
−18
1
−4
6
6
7



39
2.2 Gauss Elimination Method
The elimination phase consists of the following two passes:
row 2 ←row 2 + (2/3) × row 1
row 3 ←row 3 −(1/6) × row 1


6
−4
1
−14
22
0
10/3
−10/3
80/3
−10/3
0
−10/3
35/6
25/3
10/3


and
row 3 ←row 3 + row 2


6
−4
1
−14
22
0
10/3
−10/3
80/3
−10/3
0
0
5/2
35
0


In the solution phase, we ﬁrst compute x1 by back substitution:
X31 = 35
5/2 = 14
X21 = 80/3 + (10/3)X31
10/3
= 80/3 + (10/3)14
10/3
= 22
X11 = −14 + 4X21 −X31
6
= −14 + 4(22) −14
6
= 10
Thus the ﬁrst solution vector is
x1 =

X11
X21
X31
T
=

10
22
14
T
The second solution vector is computed next, also using back substitution:
X32 = 0
X22 = −10/3 + (10/3)X32
10/3
= −10/3 + 0
10/3
= −1
X12 = 22 + 4X22 −X32
6
= 22 + 4(−1) −0
6
= 3
Therefore,
x2 =

X12
X22
X32
T
=

3
−1
0
T

40
Systems of Linear Algebraic Equations
EXAMPLE 2.4
An n× n Vandermode matrix A is deﬁned by
Aij = vn−j
i
,
i = 1, 2, . . . , n,
j = 1, 2, . . . , n
where v is a vector. Use the function gaussElimin to compute the solution of Ax = b,
where A is the 6 × 6 Vandermode matrix generated from the vector
v =

1.0
1.2
1.4
1.6
1.8
2.0
T
and
b =

0
1
0
1
0
1
T
Also evaluate the accuracy of the solution (Vandermode matrices tend to be ill-
conditioned).
Solution
#!/usr/bin/python
## example2_4
from numarray import zeros,Float64,array,product, \
diagonal,matrixmultiply
from gaussElimin import *
def vandermode(v):
n = len(v)
a = zeros((n,n),type=Float64)
for j in range(n):
a[:,j] = v**(n-j-1)
return a
v = array([1.0, 1.2, 1.4, 1.6, 1.8, 2.0])
b = array([0.0, 1.0, 0.0, 1.0, 0.0, 1.0])
a = vandermode(v)
aOrig = a.copy()
# Save original matrix
bOrig = b.copy()
# and the constant vector
x = gaussElimin(a,b)
det = product(diagonal(a))
print ’x =\n’,x
print ’\ndet =’,det

41
2.3 LU Decomposition Methods
print ’\nCheck result: [a]{x}
- b =\n’, \
matrixmultiply(aOrig,x) - bOrig
raw_input(’’\nPress return to exit’’)
The program produced the following results:
x =
[ 416.66666667
-3125.00000004
9250.00000012 -13500.00000017
9709.33333345
-2751.00000003]
det = -1.13246207999e-006
Check result: [a]{x}
- b =
[-4.54747351e-13
4.54747351e-13 -1.36424205e-12
4.54747351e-13
-3.41060513e-11
9.54969437e-12]
As the determinant is quite small relative to the elements of A (you may want to
print A to verify this), we expect detectable roundoff error. Inspection of x leads us to
suspect that the exact solution is
x =

1250/3
−3125
9250
−13500
29128/3
−2751
T
in which case the numerical solution would be accurate to about 10 decimal places.
Another way to gauge the accuracy of the solution is to compute Ax −b (the result
should be 0). The printout indicates that the solution is indeed accurate to at least
10 decimal places.
2.3
LU Decomposition Methods
Introduction
It is possible to show that any square matrix A can be expressed as a product of a lower
triangular matrix L and an upper triangular matrix U:
A = LU
(2.11)
The process of computing L and U for a given A is known as LU decomposition or
LU factorization. LU decomposition is not unique (the combinations of L and U for
a prescribed A are endless), unless certain constraints are placed on L or U. These
constraints distinguish one type of decomposition from another. Three commonly
used decompositions are listed in Table 2.2.

42
Systems of Linear Algebraic Equations
Name
Constraints
Doolittle’s decomposition
Lii = 1,
i = 1, 2, . . . , n
Crout’s decomposition
Uii = 1,
i = 1, 2, . . . , n
Choleski’s decomposition
L = UT
Table 2.2
After decomposing A, it is easy to solve the equations Ax = b, as pointed out in
Art. 2.1. We ﬁrst rewrite the equations as LUx = b. Upon using the notation Ux = y,
the equations become
Ly = b
which can be solved for y by forward substitution. Then
Ux = y
will yield x by the back substitution process.
The advantage of LU decomposition over the Gauss elimination method is that
once A is decomposed, we can solve Ax = b for as many constant vectors b as we
please. The cost of each additional solution is relatively small, since the forward and
back substitution operations are much less time consuming than the decomposition
process.
Doolittle’s Decomposition Method
Decomposition Phase
Doolittle’s decomposition is closely related to Gauss elimination. In order to illustrate
the relationship, consider a 3 × 3 matrix A and assume that there exist triangular
matrices
L =


1
0
0
L21
1
0
L31
L32
1


U =


U11
U12
U13
0
U22
U23
0
0
U33


such that A = LU. After completing the multiplication on the right hand side, we get
A =


U11
U12
U13
U11L21
U12L21 + U22
U13L21 + U23
U11L31
U12L31 + U22L32
U13L31 + U23L32 + U33


(2.12)
Let us now apply Gauss elimination to Eq. (2.12). The ﬁrst pass of the elimina-
tion procedure consists of choosing the ﬁrst row as the pivot row and applying the

43
2.3 LU Decomposition Methods
elementary operations
row 2 ←row 2 −L21 × row 1 (eliminates A21)
row 3 ←row 3 −L31 × row 1 (eliminates A31)
The result is
A′ =


U11
U12
U13
0
U22
U23
0
U22L32
U23L32 + U33


In the next pass we take the second row as the pivot row, and utilize the operation
row 3 ←row 3 −L32 × row 2 (eliminates A32)
ending up with
A′′ = U =


U11
U12
U13
0
U22
U23
0
0
U33


The foregoing illustration reveals two important features of Doolittle’s decompo-
sition:
r The matrix U is identical to the upper triangular matrix that results from Gauss
elimination.
r The off-diagonal elements of L are the pivot equation multipliers used during
Gauss elimination; that is, Lij is the multiplier that eliminated Aij.
It is usual practice to store the multipliers in the lower triangular portion of the
coefﬁcient matrix, replacing the coefﬁcients as they are eliminated (Lij replacing Aij).
The diagonal elements of L do not have to be stored, since it is understood that each
of them is unity. The ﬁnal form of the coefﬁcient matrix would thus be the following
mixture of L and U:
[L\U] =


U11
U12
U13
L21
U22
U23
L31
L32
U33


(2.13)
The algorithm for Doolittle’s decomposition is thus identical to the Gauss elimi-
nation procedure in gaussElimin, except that each multiplier λ is now stored in the
lower triangular portion of A:
for k in range(0,n-1):
for i in range(k+1,n):

44
Systems of Linear Algebraic Equations
if a[i,k] != 0.0:
lam = a[i,k]/a[k,k]
a[i,k+1:n] = a[i,k+1:n] - lam*a[k,k+1:n]
a[i,k] = lam
Solution Phase
Consider now the procedure for solving Ly = b by forward substitution. The scalar
form of the equations is (recall that Lii = 1)
y1 = b1
L21y1 + y2 = b2
...
Lk1y1 + Lk2y2 + · · · + Lk,k−1yk−1 + yk = bk
...
Solving the kth equation for yk yields
yk = bk −
k−1

j=1
Lkj yj,
k = 2, 3, . . . , n
(2.14)
Therefore, the forward substitution algorithm is
y[0] = b[0]
for k in range(1,n):
y[k] = b[k] - dot(a[k,0:k],y[0:k])
The back substitution phase for solving Ux = y is identical to that used in the
Gauss elimination method.
■LUdecomp
This module contains both the decomposition and solution phases. The decompo-
sition phase returns the matrix [L\U] shown in Eq. (2.13). In the solution phase, the
contents of b are replaced by y during forward substitution. Similarly, back substitu-
tion overwrites y with the solution x.
## module LUdecomp
’’’ a = LUdecomp(a).
LU decomposition: [L][U] = [a]. The returned matrix

45
2.3 LU Decomposition Methods
[a] = [L\U] contains [U] in the upper triangle and
the nondiagonal terms of [L] in the lower triangle.
x = LUsolve(a,b).
Solves [L][U]{x}
= b, where [a] = [L\U] is the matrix
returned from LUdecomp.
’’’
from numarray import dot
def LUdecomp(a):
n = len(a)
for k in range(0,n-1):
for i in range(k+1,n):
if a[i,k] != 0.0:
lam = a [i,k]/a[k,k]
a[i,k+1:n] = a[i,k+1:n] - lam*a[k,k+1:n]
a[i,k] = lam
return a
def LUsolve(a,b):
n = len(a)
for k in range(1,n):
b[k] = b[k] - dot(a[k,0:k],b[0:k])
for k in range(n-1,-1,-1):
b[k] = (b[k] - dot(a[k,k+1:n],b[k+1:n]))/a[k,k]
return b
Choleski’s Decomposition
Choleski’s decomposition A = LLT has two limitations:
r Since LLT is always a symmetric matrix, Choleski’s decomposition requires A to
be symmetric.
r The decomposition process involves taking square roots of certain combinations
of the elements of A. It can be shown that in order to avoid square roots of negative
numbers A must be positive deﬁnite.
Although the number of multiplications in all the decomposition methods is
about the same, Choleski’s decomposition is not a particularly popular means of

46
Systems of Linear Algebraic Equations
solving simultaneous equations due to the restrictions listed above. We study it here
because it is invaluable in certain applications that we encounter later on.
Let us start by looking at Choleski’s decomposition
A = LLT
(2.15)
of a 3 × 3 matrix:


A11
A12
A13
A21
A22
A23
A31
A32
A33

=


L11
0
0
L21
L22
0
L31
L32
L33




L11
L21
L31
0
L22
L32
0
0
L33


After completing the matrix multiplication on the right hand side, we get


A11
A12
A13
A21
A22
A23
A31
A32
A33

=


L2
11
L11L21
L11L31
L11L21
L2
21 + L2
22
L21L31 + L22L32
L11L31
L21L31 + L22L32
L2
31 + L2
32 + L2
33


(2.16)
Notethattheright-hand-sidematrixissymmetric,aspointedoutbefore.Equatingthe
matrices A and LLT element-by-element, we obtain six equations (due to symmetry
only lower or upper triangular elements have to be considered) in the six unknown
components of L. By solving these equations in a certain order, it is possible to have
only one unknown in each equation.
Consider the lower triangular portion of each matrix in Eq. (2.16) (the upper
triangular portion would do as well). By equating the elements in the ﬁrst column,
starting with the ﬁrst row and proceeding downward, we can compute L11, L21 and
L31 in that order:
A11 = L2
11
L11 =

A11
A21 = L11L21
L21 = A21/L11
A31 = L11L31
L31 = A31/L11
The second column, starting with second row, yields L22 and L32:
A22 = L2
21 + L2
22
L22 =

A22 −L2
21
A32 = L21L31 + L22L32
L32 = (A32 −L21L31)/L22
Finally the third column, third row gives us L33:
A33 = L2
31 + L2
32 + L2
33
L33 =

A33 −L2
31 −L2
32

47
2.3 LU Decomposition Methods
We can now extrapolate the results for an n× n matrix. We observe that a typical
element in the lower-triangular portion of LLT is of the form
(LLT)ij = Li1L j1 + Li2L j2 + · · · + Lij L jj =
j

k=1
LikL jk,
i ≥j
Equating this term to the corresponding element of A yields
Aij =
j

k=1
LikL jk,
i = j, j + 1, . . . , n,
j = 1, 2, . . . , n
(2.17)
The range of indices shown limits the elements to the lower triangular part. For the
ﬁrst column ( j = 1), we obtain from Eq. (2.17)
L11 =

A11
Li1 = Ai1/L11,
i = 2, 3, . . . , n
(2.18)
Proceeding to other columns, we observe that the unknown in Eq. (2.17) is Lij (the
other elements of L appearing in the equation have already been computed). Taking
the term containing Lij outside the summation in Eq. (2.17), we obtain
Aij =
j−1

k=1
LikL jk + Lij L jj
If i = j (a diagonal term) , the solution is
L jj =



A jj −
j−1

k=1
L2
jk,
j = 2, 3, . . . , n
(2.19)
For a nondiagonal term we get
Lij =

Aij −
j−1

k=1
LikL jk

/L jj,
j = 2, 3, . . . , n−1,
i = j + 1, j + 2, . . . , n
(2.20)
■choleski(a)
BeforepresentingthealgorithmforCholeski’sdecomposition,wemakeausefulobser-
vation: Aij appearsonlyintheformulafor Lij.Therefore,once Lij hasbeencomputed,
Aij is no longer needed. This makes it possible to write the elements of L over the lower
triangular portion of A as they are computed. The elements above the leading diag-
onal of A will remain untouched. The function listed below implements Choleski’s
decomposition. If a negative diagonal term is encountered during decomposition, an
error message is printed and the program is terminated.
## module choleski
’’’ L = choleski(a).

48
Systems of Linear Algebraic Equations
Choleski decomposition: [L][L]transpose = [a].
’’’
from numarray import dot
from math import sqrt
import error
def choleski(a):
n = len(a)
for k in range(n):
try:
a[k,k] = sqrt(a[k,k] - dot(a[k,0:k],a[k,0:k]))
except ValueError:
error.err(’Matrix is not positive definite’)
for i in range(k+1,n):
a[i,k] = (a[i,k] - dot(a[i,0:k],a[k,0:k]))/a[k,k]
for k in range(1,n): a[0:k,k] = 0.0
return a
We could also write the algorithm for forward and back substitutions that are
necessary in the solution of Ax = b. But since Choleski’s decomposition has no ad-
vantages over Doolittle’s decomposition in the solution of simultaneous equations,
we will skip that.
EXAMPLE 2.5
Use Doolittle’s decomposition method to solve the equations Ax = b, where
A =


1
4
1
1
6
−1
2
−1
2


b =


7
13
5


Solution We ﬁrst decompose A by Gauss elimination. The ﬁrst pass consists of the
elementary operations
row 2 ←row 2 −1 × row 1 (eliminates A21)
row 3 ←row 3 −2 × row 1 (eliminates A31)
Storing the multipliers L21 = 1 and L31 = 2 in place of the eliminated terms, we obtain
A′ =


1
4
1
1
2
−2
2
−9
0



49
2.3 LU Decomposition Methods
The second pass of Gauss elimination uses the operation
row 3 ←row 3 −(−4.5) × row 2 (eliminates A32)
Storing the multiplier L32 = −4.5 in place of A32, we get
A′′ = [L\U] =


1
4
1
1
2
−2
2
−4.5
−9


The decomposition is now complete, with
L =


1
0
0
1
1
0
2
−4.5
1


U =


1
4
1
0
2
−2
0
0
−9


SolutionofLy = bbyforwardsubstitutioncomesnext.Theaugmentedcoefﬁcient
form of the equations is

L
b

=


1
0
0
7
1
1
0
13
2
−4.5
1
5


The solution is
y1 = 7
y2 = 13 −y1 = 13 −7 = 6
y3 = 5 −2y1 + 4.5y2 = 5 −2(7) + 4.5(6) = 18
Finally, the equations Ux = y, or

U
y

=


1
4
1
7
0
2
−2
6
0
0
−9
18


are solved by back substitution. This yields
x3 = 18
−9 = −2
x2 = 6 + 2x3
2
= 6 + 2(−2)
2
= 1
x1 = 7 −4x2 −x3 = 7 −4(1) −(−2) = 5

50
Systems of Linear Algebraic Equations
EXAMPLE 2.6
Compute Choleski’s decomposition of the matrix
A =


4
−2
2
−2
2
−4
2
−4
11


Solution First we note that A is symmetric. Therefore, Choleski’s decomposition is
applicable,providedthatthematrixisalsopositivedeﬁnite.Anaprioritestforpositive
deﬁniteness is not needed, since the decomposition algorithm contains its own test: if
the square root of a negative number is encountered, the matrix is not positive deﬁnite
and the decomposition fails.
Substituting the given matrix for A in Eq. (2.16), we obtain


4
−2
2
−2
2
−4
2
−4
11

=


L2
11
L11L21
L11L31
L11L21
L2
21 + L2
22
L21L31 + L22L32
L11L31
L21L31 + L22L32
L2
31 + L2
32 + L2
33


Equating the elements in the lower (or upper) triangular portions yields
L11 =
√
4 = 2
L21 = −2/L11 = −2/2 = −1
L31 = 2/L11 = 2/2 = 1
L22 =

2 −L2
21 =

2 −12 = 1
L32 = −4 −L21L31
L22
= −4 −(−1)(1)
1
= −3
L33 =

11 −L2
31 −L2
32 =

11 −(1)2 −(−3)2 = 1
Therefore,
L =


2
0
0
−1
1
0
1
−3
1


The result can easily be veriﬁed by performing the multiplication LLT.
EXAMPLE 2.7
Write a program that solves AX = B with Doolittle’s decomposition method and com-
putes |A|. Utilize the functions LUdecomp and LUsolve. Test the program with
A =


3
−1
4
−2
0
5
7
2
−2


B =


6
−4
3
2
7
−5



51
2.3 LU Decomposition Methods
Solution The program listed below decomposes A and then prompts for the constant
vectors. After a constant vector is entered, the corresponding solution is computed
and the program prompts for another constant vector. The program is terminated
when a SyntaxError is encountered in input (e.g., when the “return” key is pressed).
#!/usr/bin/python
## example2_7
from numarray import zeros,array,Float64,product,diagonal
from LUdecomp import *
a = array([[ 3.0, -1.0,
4.0], \
[-2.0,
0.0,
5.0], \
[ 7.0,
2.0, -2.0]])
a = LUdecomp(a)
det = product(diagonal(a))
print ’’\nDeterminant =’’,det
while 1:
print ’’\nInput constant vector (press return to exit):’’
try:
b = array(eval(raw_input(’’==> ’’)),type=Float64)
except SyntaxError: break
x = LUsolve(a,b)
print ’’The solution is:\n’’,x
raw_input(’’\nPress return to exit’’)
Running the program produced the following display:
Determinant = -77.0
Input constant vector (press return to exit):
==> [6.0, 3.0, 7.0]
The solution is:
[ 1.
1.
1.]
Input constant vector (press return to exit):
==> [-4.0, 2.0, -5.0]
The solution is:
[ -1.00000000e+00
1.00000000e+00
2.30695693e-17]
Input constant vector (press return to exit):
==>

52
Systems of Linear Algebraic Equations
EXAMPLE 2.8
Test the function choleski by decomposing
A =


1.44
−0.36
5.52
0.00
−0.36
10.33
−7.78
0.00
5.52
−7.78
28.40
9.00
0.00
0.00
9.00
61.00


Solution
#!/usr/bin/python
## example2_8
from numarray import array,matrixmultiply,transpose
from choleski import *
a = array([[ 1.44, -0.36,
5.52,
0.0], \
[-0.36, 10.33, -7.78,
0.0], \
[ 5.52, -7.78, 28.40,
9.0], \
[ 0.0,
0.0,
9.0,
61.0]])
L = choleski(a)
print ’L =\n’,L
print ’\nCheck: L*L_transpose =\n’, \
matrixmultiply(L,transpose(L))
raw_input(’’\nPress return to exit’’)
The output is:
L =
[[ 1.2
0.
0.
0. ]
[-0.3
3.2
0.
0. ]
[ 4.6 -2.
1.8
0. ]
[ 0.
0.
5.
6. ]]
Check: L*L_transpose =
[[
1.44
-0.36
5.52
0.
]
[ -0.36
10.33
-7.78
0.
]
[
5.52
-7.78
28.4
9.
]
[
0.
0.
9.
61.
]]

53
2.3 LU Decomposition Methods
PROBLEM SET 2.1
1. By evaluating the determinant, classify the following matrices as singular, ill-
conditioned, or well-conditioned.
(a)
A =


1
2
3
2
3
4
3
4
5


(b)
A =


2.11
−0.80
1.72
−1.84
3.03
1.29
−1.57
5.25
4.30


(c)
A =


2
−1
0
−1
2
−1
0
−1
2


(d)
A =


4
3
−1
7
−2
3
5
−18
13


2. Given the LU decomposition A = LU, determine A and |A| .
(a)
L =


1
0
0
1
1
0
1
5/3
1


U =


1
2
4
0
3
21
0
0
0


(b)
L =


2
0
0
−1
1
0
1
−3
1


U =


2
−1
1
0
1
−3
0
0
1


3. Utilize the results of LU decomposition
A = LU =


1
0
0
3/2
1
0
1/2
11/13
1




2
−3
−1
0
13/2
−7/2
0
0
32/13


to solve Ax = b, where bT =

1
−1
2

.
4. Use Gauss elimination to solve the equations Ax = b, where
A =


2
−3
−1
3
2
−5
2
4
−1


b =


3
−9
−5


5. Solve the equations AX = B by Gauss elimination, where
A =


2
0
−1
0
0
1
2
0
−1
2
0
1
0
0
1
−2


B =


1
0
0
0
0
1
0
0



54
Systems of Linear Algebraic Equations
6. Solve the equations Ax = b by Gauss elimination, where
A =


0
0
2
1
2
0
1
0
2
−1
1
2
0
−2
0
0
0
0
−1
1
0
1
−1
1
−1


b =


1
1
−4
−2
−1


Hint: reorder the equations before solving.
7. Find L and U so that
A = LU =


4
−1
0
−1
4
−1
0
−1
4


using (a) Doolittle’s decomposition; (b) Choleski’s decomposition.
8. Use Doolittle’s decomposition method to solve Ax = b, where
A =


−3
6
−4
9
−8
24
−12
24
−26


b =


−3
65
−42


9. Solve the equations Ax = b by Doolittle’s decomposition method, where
A =


2.34
−4.10
1.78
−1.98
3.47
−2.22
2.36
−15.17
6.18


b =


0.02
−0.73
−6.63


10. Solve the equations AX = B by Doolittle’s decomposition method, where
A =


4
−3
6
8
−3
10
−4
12
−10


B =


1
0
0
1
0
0


11. Solve the equations Ax = b by Choleski’s decomposition method, where
A =


1
1
1
1
2
2
1
2
3


b =


1
3/2
3


12. Solve the equations


4
−2
−3
12
4
−10
−16
28
18




x1
x2
x3

=


1.1
0
−2.3


by Doolittle’s decomposition method.

55
2.3 LU Decomposition Methods
13. Determine L that results from Choleski’s decomposition of the diagonal matrix
A =


α1
0
0
· · ·
0
α2
0
· · ·
0
0
α3
· · ·
...
...
...
...


14. ■Modify the function gaussElimin so that it will work with m constant vectors.
Test the program by solving AX = B, where
A =


2
−1
0
−1
2
−1
0
−1
1


B =


1
0
0
0
1
0
0
0
1


15. ■A well-known example of an ill-conditioned matrix is the Hilbert matrix
A =


1
1/2
1/3
· · ·
1/2
1/3
1/4
· · ·
1/3
1/4
1/5
· · ·
...
...
...
...


Write a program that specializes in solving the equations Ax = b by Doolittle’s
decomposition method, where A is the Hilbert matrix of arbitrary size n× n, and
bi =
n

j=1
Aij
The program should have no input apart from n. By running the program, deter-
mine the largest nfor which the solution is within 6 signiﬁcant ﬁgures of the exact
solution
x =

1
1
1
· · ·
T
16. ■Write a function for the solution phase of Choleski’s decomposition method.
Test the function by solving the equations Ax = b, where
A =


4
−2
2
−2
2
−4
2
−4
11


b =


6
−10
27


Use the function choleski for the decomposition phase.
17. ■Determine the coefﬁcients of the polynomial y = a0 + a1x + a2x2 + a3x3 that
pass through the points (0, 10), (1, 35), (3, 31) and (4, 2).
18. ■Determine the 4th degree polynomial y(x) that passes through the points
(0, −1), (1, 1), (3, 3), (5, 2) and (6, −2).

56
Systems of Linear Algebraic Equations
19. ■Find the 4th degree polynomial y(x) that passes through the points (0, 1),
(0.75, −0.25) and (1, 1), and has zero curvature at (0, 1) and (1, 1).
20. ■Solve the equations Ax = b, where
A =


3.50
2.77
−0.76
1.80
−1.80
2.68
3.44
−0.09
0.27
5.07
6.90
1.61
1.71
5.45
2.68
1.71


b =


7.31
4.23
13.85
11.55


By computing |A| and Ax comment on the accuracy of the solution.
2.4
Symmetric and Banded Coefﬁcient Matrices
Introduction
Engineering problems often lead to coefﬁcient matrices that are sparsely populated,
meaning that most elements of the matrix are zero. If all the nonzero terms are clus-
tered about the leading diagonal, then the matrix is said to be banded. An example of
a banded matrix is
A =


X
X
0
0
0
X
X
X
0
0
0
X
X
X
0
0
0
X
X
X
0
0
0
X
X


where X’s denote the nonzero elements that form the populated band (some of these
elements may be zero). All the elements lying outside the band are zero. The matrix
shown above has a bandwidth of three, since there are at most three nonzero elements
in each row (or column). Such a matrix is called tridiagonal.
If a banded matrix is decomposed in the form A = LU, both L and U will retain
the banded structure of A. For example, if we decomposed the matrix shown above,
we would get
L =


X
0
0
0
0
X
X
0
0
0
0
X
X
0
0
0
0
X
X
0
0
0
0
X
X


U =


X
X
0
0
0
0
X
X
0
0
0
0
X
X
0
0
0
0
X
X
0
0
0
0
X


The banded structure of a coefﬁcient matrix can be exploited to save storage and
computation time. If the coefﬁcient matrix is also symmetric, further economies are

57
2.4 Symmetric and Banded Coefﬁcient Matrices
possible. In this section we show how the methods of solution discussed previously
can be adapted for banded and symmetric coefﬁcient matrices.
Tridiagonal Coefﬁcient Matrix
Consider the solution of Ax = b by Doolittle’s decomposition, where A is the n× n
tridiagonal matrix
A =


d1
e1
0
0
· · ·
0
c1
d2
e2
0
· · ·
0
0
c2
d3
e3
· · ·
0
0
0
c3
d4
· · ·
0
...
...
...
...
...
...
0
0
. . .
0
cn−1
dn


As the notation implies, we are storing the nonzero elements of A in the vectors
c =


c1
c2
...
cn−1


d =


d1
d2
...
dn−1
dn


e =


e1
e2
...
en−1


The resulting saving of storage can be signiﬁcant. For example, a 100 × 100 tridiag-
onal matrix, containing 10,000 elements, can be stored in only 99 + 100 + 99 = 298
locations, which represents a compression ratio of about 33:1.
Let us now apply LU decomposition to the coefﬁcient matrix. We reduce row k by
getting rid of ck−1 with the elementary operation
row k ←row k −(ck−1/dk−1) × row (k −1),
k = 2, 3, . . . , n
The corresponding change in dk is
dk ←dk −(ck−1/dk−1)ek−1
(2.21)
whereas ek is not affected. To ﬁnish up with Doolittle’s decomposition of the form
[L\U], we store the multiplier λ = ck−1/dk−1 in the location previously occupied by
ck−1:
ck−1 ←ck−1/dk−1
(2.22)

58
Systems of Linear Algebraic Equations
Thus the decomposition algorithm is
for k in range(1,n):
lam = c[k-1]/d[k-1]
d[k] = d[k] - lam*e[k-1]
c[k-1] = lam
Next we look at the solution phase, i.e., the solution of the Ly = b, followed by
Ux = y. The equations Ly = b can be portrayed by the augmented coefﬁcient matrix

L
b

=


1
0
0
0
· · ·
0
b1
c1
1
0
0
· · ·
0
b2
0
c2
1
0
· · ·
0
b3
0
0
c3
1
. . .
0
b4
...
...
...
...
· · ·
...
...
0
0
· · ·
0
cn−1
1
bn


Note that the original contents of c were destroyed and replaced by the multipliers
during the decomposition. The solution algorithm for y by forward substitution is
y[0] = b[0]
for k in range(1,n):
y[k] = b[k] - c[k-1]*y[k-1]
The augmented coefﬁcient matrix representing Ux = y is

U
y

=


d1
e1
0
· · ·
0
0
y1
0
d2
e2
· · ·
0
0
y2
0
0
d3
· · ·
0
0
y3
...
...
...
...
...
...
0
0
0
· · ·
dn−1
en−1
yn−1
0
0
0
· · ·
0
dn
yn


Note again that the contents of d were altered from the original values during the
decomposition phase (but e was unchanged). The solution for x is obtained by back
substitution using the algorithm
x[n-1] = y[n-1]/d[n-1]
for k in range(n-2,-1,-1):
x[k] = (y[k] - e[k]*x[k+1])/d[k]
end do

59
2.4 Symmetric and Banded Coefﬁcient Matrices
■LUdecomp3
This module contains the functions LUdecomp3 and LUsolve3 for the decomposition
and solution phases of a tridiagonal matrix. In LUsolve3, the vector y writes over
the constant vector b during forward substitution. Similarly, the solution vector x
overwrites y in the back substitution process. In other words, b contains the solution
upon exit from LUsolve3.
## module LUdecomp3
’’’ c,d,e = LUdecomp3(c,d,e).
LU decomposition of tridiagonal matrix [c\d\e]. On output
{c},{d}
and {e}
are the diagonals of the decomposed matrix.
x = LUsolve3(c,d,e,b).
Solves [c\d\e]{x}
= {b}, where {c}, {d}
and {e}
are the
vectors returned from LUdecomp3.
’’’
def LUdecomp3(c,d,e):
n = len(d)
for k in range(1,n):
lam = c[k-1]/d[k-1]
d[k] = d[k] - lam*e[k-1]
c[k-1] = lam
return c,d,e
def LUsolve3(c,d,e,b):
n = len(d)
for k in range(1,n):
b[k] = b[k] - c[k-1]*b[k-1]
b[n-1] = b[n-1]/d[n-1]
for k in range(n-2,-1,-1):
b[k] = (b[k] - e[k]*b[k+1])/d[k]
return b
Symmetric Coefﬁcient Matrices
More often than not, coefﬁcient matrices that arise in engineering problems are
symmetric as well as banded. Therefore, it is worthwhile to discover special prop-
erties of such matrices and learn how to utilize them in the construction of efﬁcient
algorithms.

60
Systems of Linear Algebraic Equations
If the matrix A is symmetric, then the LU decomposition can be presented in the
form
A = LU = LDLT
(2.23)
whereDisadiagonalmatrix.AnexampleisCholeski’sdecompositionA = LLT thatwas
discussed in the previous section (in this case D = I). For Doolittle’s decomposition
we have
U = DLT =


D1
0
0
· · ·
0
0
D2
0
· · ·
0
0
0
D3 · · ·
0
...
...
...
· · ·
...
0
0
0
· · · Dn




1
L21
L31
· · ·
Ln1
0
1
L32
· · ·
Ln2
0
0
1
· · ·
Ln3
...
...
...
· · ·
...
0
0
0
· · ·
1


which gives
U =


D1
D1L21
D1L31
· · ·
D1Ln1
0
D2
D2L32
· · ·
D2Ln2
0
0
D3
· · ·
D3L3n
...
...
...
· · ·
...
0
0
0
· · ·
Dn


(2.24)
We now see that during decomposition of a symmetric matrix only U has to be stored,
since D and L can be easily recovered from U. Thus Gauss elimination, which results in
an upper triangular matrix of the form shown in Eq. (2.24), is sufﬁcient to decompose
a symmetric matrix.
There is an alternative storage scheme that can be employed during LU decom-
position. The idea is to arrive at the matrix
U∗=


D1
L21
L31
· · ·
Ln1
0
D2
L32
· · ·
Ln2
0
0
D3
· · ·
Ln3
...
...
...
...
...
0
0
0
· · ·
Dn


(2.25)
Here U can be recovered from Uij = DiL ji. It turns out that this scheme leads to a
computationally more efﬁcient solution phase; therefore, we adopt it for symmetric,
banded matrices.

61
2.4 Symmetric and Banded Coefﬁcient Matrices
Symmetric, Pentadiagonal Coefﬁcient Matrix
We encounter pentadiagonal (bandwidth = 5) coefﬁcient matrices in the solution of
fourth-order,ordinarydifferentialequationsbyﬁnitedifferences.Oftenthesematrices
are symmetric, in which case an n× n coefﬁcient matrix has the form
A =


d1
e1
f1
0
0
0
· · ·
0
e1
d2
e2
f2
0
0
· · ·
0
f1
e2
d3
e3
f3
0
· · ·
0
0
f2
e3
d4
e4
f4
· · ·
0
...
...
...
...
...
...
...
...
0
· · ·
0
fn−4
en−3
dn−2
en−2
fn−2
0
· · ·
0
0
fn−3
en−2
dn−1
en−1
0
· · ·
0
0
0
fn−2
en−1
dn


(2.26)
As in the case of tridiagonal matrices, we store the nonzero elements in the three
vectors
d =


d1
d2
...
dn−2
dn−1
dn


e =


e1
e2
...
en−2
en−1


f =


f1
f2
...
fn−2


Let us now look at the solution of the equations Ax = b by Doolittle’s decomposi-
tion. The ﬁrst step is to transform A to upper triangular form by Gauss elimination. If
elimination has progressed to the stage where the kth row has become the pivot row,
we have the following situation:
A =


...
...
...
...
...
...
...
...
· · ·
0
dk
ek
fk
0
0
0
· · ·
· · ·
0
ek
dk+1
ek+1
fk+1
0
0
· · ·
· · ·
0
fk
ek+1
dk+2
ek+2
fk+2
0
· · ·
· · ·
0
0
fk+1
ek+2
dk+3
ek+3
fk+3
· · ·
...
...
...
...
...
...
...
...


←
The elements ek and fk below the pivot row (the kth row) are eliminated by the
operations
row (k + 1) ←row (k + 1) −(ek/dk) × row k
row (k + 2) ←row (k + 2) −( fk/dk) × row k

62
Systems of Linear Algebraic Equations
The only terms (other than those being eliminated) that are changed by the above
operations are
dk+1 ←dk+1 −(ek/dk)ek
ek+1 ←ek+1 −(ek/dk) fk
(2.27a)
dk+2 ←dk+2 −( fk/dk) fk
Storage of the multipliers in the upper triangular portion of the matrix results in
ek ←ek/dk
fk ←fk/dk
(2.27b)
At the conclusion of the elimination phase the matrix has the form (do not confuse d,
e and f with the original contents of A)
U∗=


d1
e1
f1
0
· · ·
0
0
d2
e2
f2
· · ·
0
0
0
d3
e3
· · ·
0
...
...
...
...
· · ·
...
0
0
· · ·
0
dn−1
en−1
0
0
· · ·
0
0
dn


Next comes the solution phase. The equations Ly = b have the augmented coef-
ﬁcient matrix

L
b

=


1
0
0
0
· · ·
0
b1
e1
1
0
0
· · ·
0
b2
f1
e2
1
0
· · ·
0
b3
0
f2
e3
1
· · ·
0
b4
...
...
...
...
· · ·
...
...
0
0
0
fn−2
en−1
1
bn


Solution by forward substitution yields
y1 = b1
y2 = b2 −e1y1
(2.28)
...
yk = bk −fk−2yk−2 −ek−1yk−1,
k = 3, 4, . . . , n

63
2.4 Symmetric and Banded Coefﬁcient Matrices
The equations to be solved by back substitution, namely Ux = y, have the augmented
coefﬁcient matrix

U
y

=


d1
d1e1
d1 f1
0
· · ·
0
y1
0
d2
d2e2
d2 f2
· · ·
0
y2
0
0
d3
d3e3
· · ·
0
y3
...
...
...
...
· · ·
...
...
0
0
· · ·
0
dn−1
dn−1en−1
yn−1
0
0
· · ·
0
0
dn
yn


the solution of which is obtained by back substitution:
xn = yn/dn
xn−1 = yn−1/dn−1 −en−1xn
xk = yk/dk −ekxk+1 −fkxk+2,
k = n−2, n−3, . . . , 1
(2.29)
■LUdecomp5
The function LUdecomp5 below decomposes a symmetric, pentadiagonal matrix A of
the form A = [f\e\d\e\f]. The original vectors d, e and f are destroyed and replaced
by the vectors of the decomposed matrix. After decomposition, the solution of Ax = b
can be obtained by LUsolve5. During forward substitution, the original b is replaced
by y. Similarly, y is written over by x in the back substitution phase, so that b contains
the solution vector upon exit from LUsolve5.
## module LUdecomp5
’’’ d,e,f = LUdecomp5(d,e,f).
LU decomposition of symetric pentadiagonal matrix
[f\e\d\e\f]. On output {d},{e}
and {f}
are the
diagonals of the decomposed matrix.
x = LUsolve5(d,e,f,b).
Solves [f\e\d\e\f]{x}
= {b}, where {d}, {e}
and {f}
are the vectors returned from LUdecomp5.
’’’
def LUdecomp5(d,e,f):
n = len(d)
for k in range(n-2):
lam = e[k]/d[k]
d[k+1] = d[k+1] - lam*e[k]

64
Systems of Linear Algebraic Equations
e[k+1] = e[k+1] - lam*f[k]
e[k] = lam
lam = f[k]/d[k]
d[k+2] = d[k+2] - lam*f[k]
f[k] = lam
lam = e[n-2]/d[n-2]
d[n-1] = d[n-1] - lam*e[n-2]
e[n-2] = lam
return d,e,f
def LUsolve5(d,e,f,b):
n = len(d)
b[1] = b[1] - e[0]*b[0]
for k in range(2,n):
b[k] = b[k] - e[k-1]*b[k-1] - f[k-2]*b[k-2]
b[n-1] = b[n-1]/d[n-1]
b[n-2] = b[n-2]/d[n-2] - e[n-2]*b[n-1]
for k in range(n-3,-1,-1):
b[k] = b[k]/d[k] - e[k]*b[k+1] - f[k]*b[k+2]
return b
EXAMPLE 2.9
As a result of Gauss elimination, a symmetric matrix A was transformed to the upper
triangular form
U =


4
−2
1
0
0
3
−3/2
1
0
0
3
−3/2
0
0
0
35/12


Determine the original matrix A.
Solution First we ﬁnd L in the decomposition A = LU. Dividing each row of U by its
diagonal element yields
LT =


1
−1/2
1/4
0
0
1
−1/2
1/3
0
0
1
−1/2
0
0
0
1



65
2.4 Symmetric and Banded Coefﬁcient Matrices
Therefore, A = LU becomes
A =


1
0
0
0
−1/2
1
0
0
1/4
−1/2
1
0
0
1/3
−1/2
1




4
−2
1
0
0
3
−3/2
1
0
0
3
−3/2
0
0
0
35/12


=


4
−2
1
0
−2
4
−2
1
1
−2
4
−2
0
1
−2
4


EXAMPLE 2.10
Determine L and D that result from Doolittle’s decomposition A = LDLT of the sym-
metric matrix
A =


3
−3
3
−3
5
1
3
1
10


Solution We use Gauss elimination, storing the multipliers in the upper triangular
portion of A. At the completion of elimination, the matrix will have the form of U∗in
Eq. (2.25).
The terms to be eliminated in the ﬁrst pass are A21 and A31 using the elementary
operations
row 2 ←row 2 −(−1) × row 1
row 3 ←row 3 −(1) × row 1
Storing the multipliers (−1 and 1) in the locations occupied by A12 and A13, we get
A′ =


3
−1
1
0
2
4
0
4
7


The second pass is the operation
row 3 ←row 3 −2 × row 2
which yields, after overwriting A23 with the multiplier 2
A′′ =

0\D\LT
=


3
−1
1
0
2
2
0
0
−1



66
Systems of Linear Algebraic Equations
Hence
L =


1
0
0
−1
1
0
1
2
1


D =


3
0
0
0
2
0
0
0
−1


EXAMPLE 2.11
Utilize the functions LUdecmp3 and LUsolve3 to solve Ax = b, where
A =


2
−1
0
0
0
−1
2
−1
0
0
0
−1
2
−1
0
0
0
−1
2
−1
0
0
0
−1
2


b =


5
−5
4
−5
5


Solution
#!/usr/bin/python
## example2_11
from numarray import array,ones
from LUdecomp3 import *
d = ones((5))*2.0
c = ones((4))*(-1.0)
b = array([5.0, -5.0, 4.0, -5.0, 5.0])
e = c.copy()
c,d,e = LUdecomp3(c,d,e)
x = LUsolve3(c,d,e,b)
print ’’\nx =\n’’,x
raw_input(’’\nPress return to exit’’)
The output is:
x =
[ 2. -1.
1. -1.
2.]
2.5
Pivoting
Introduction
Sometimes the order in which the equations are presented to the solution algorithm
has a profound effect on the results. For example, consider the equations
2x1 −x2 = 1
−x1 + 2x2 −x3 = 0
−x2 + x3 = 0

67
2.5 Pivoting
The corresponding augmented coefﬁcient matrix is

A
b

=


2
−1
0
1
−1
2
−1
0
0
−1
1
0


(a)
Equations(a)areinthe“rightorder”inthesensethatwewouldhavenotroubleobtain-
ing the correct solution x1 = x2 = x3 = 1 by Gauss elimination or LU decomposition.
Now suppose that we exchange the ﬁrst and third equations, so that the augmented
coefﬁcient matrix becomes

A
b

=


0
−1
1
0
−1
2
−1
0
2
−1
0
1


(b)
Sincewedidnotchangetheequations(onlytheirorderwasaltered),thesolutionisstill
x1 = x2 = x3 = 1. However, Gauss elimination fails immediately due to the presence
of the zero pivot element (the element A11).
The above example demonstrates that it is sometimes essential to reorder the
equations during the elimination phase. The reordering, or row pivoting, is also re-
quired if the pivot element is not zero, but very small in comparison to other elements
in the pivot row, as demonstrated by the following set of equations:

A
b

=


ε
−1
1
0
−1
2
−1
0
2
−1
0
1


(c)
These equations are the same as Eqs. (b), except that the small number ε replaces the
zero element A11 in Eq. (b). Therefore, if we let ε →0, the solutions of Eqs. (b) and (c)
should become identical. After the ﬁrst phase of Gauss elimination, the augmented
coefﬁcient matrix becomes

A′
b′
=


ε
−1
1
0
0
2 −1/ε
−1 + 1/ε
0
0
−1 + 2/ε
−2/ε
1


(d)
Because the computer works with a ﬁxed word length, all numbers are rounded off
to a ﬁnite number of signiﬁcant ﬁgures. If ε is very small, then 1/ε is huge, and an
element such as 2 −1/ε is rounded to −1/ε. Therefore, for sufﬁciently small ε, the
Eqs. (d) are actually stored as

A′
b′
=


ε
−1
1
0
0
−1/ε
1/ε
0
0
2/ε
−2/ε
1



68
Systems of Linear Algebraic Equations
Because the second and third equations obviously contradict each other, the solution
process fails again. This problem would not arise if the ﬁrst and second, or the ﬁrst
and the third equations were interchanged in Eqs. (c) before the elimination.
The last example illustrates the extreme case where ε was so small that roundoff
errors resulted in total failure of the solution. If we were to make ε somewhat bigger
so that the solution would not “bomb” any more, the roundoff errors might still be
large enough to render the solution unreliable. Again, this difﬁculty could be avoided
by pivoting.
Diagonal Dominance
An n× nmatrix A is said to be diagonally dominant if each diagonal element is larger
thanthesumoftheotherelementsinthesamerow(wearetalkinghereaboutabsolute
values). Thus diagonal dominance requires that
|Aii| >
n

j=1
j̸=i
Aij
 (i = 1, 2, ..., n)
(2.30)
For example, the matrix


−2
4
−1
1
−1
3
4
−2
1


is not diagonally dominant, but if we rearrange the rows in the following manner


4
−2
1
−2
4
−1
1
−1
3


then we have diagonal dominance.
It can be shown that if the coefﬁcient matrix of the equations Ax = b is diagonally
dominant, then the solution does not beneﬁt from pivoting; that is, the equations are
already arranged in the optimal order. It follows that the strategy of pivoting should be
toreordertheequationssothatthecoefﬁcientmatrixisasclosetodiagonaldominance
as possible. This is the principle behind scaled row pivoting, discussed next.
Gauss Elimination with Scaled Row Pivoting
Consider the solution of Ax = b by Gauss elimination with row pivoting. Recall that
pivoting aims at improving diagonal dominance of the coefﬁcient matrix, i.e., making
the pivot element as large as possible in comparison to other elements in the pivot

69
2.5 Pivoting
row. The comparison is made easier if we establish an array s with the elements
si = max
j
Aij
 ,
i = 1, 2, . . . , n
(2.31)
Thus si, called the scale factor of row i, contains the absolute value of the largest
element in the ith row of A. The vector s can be obtained with the algorithm
for i in range(n):
s[i] = max(abs(a[i,:]))
The relative size of an element Aij (that is, relative to the largest element in the
ith row) is deﬁned as the ratio
rij =
Aij

si
(2.32)
Suppose that the elimination phase has reached the stage where the kth row has
become the pivot row. The augmented coefﬁcient matrix at this point is shown below.


A11
A12
A13
A14
· · ·
A1n
b1
0
A22
A23
A24
· · ·
A2n
b2
0
0
A33
A34
· · ·
A3n
b3
...
...
...
...
· · ·
...
...
0
· · ·
0
Akk
· · ·
Akn
bk
...
· · ·
...
...
· · ·
...
...
0
· · ·
0
Ank
· · ·
Ann
bn


←
Wedon’tautomaticallyaccept Akkasthenextpivotelement,butlookinthekthcolumn
below Akk for a “better” pivot. The best choice is the element Apk that has the largest
relative size; that is, we choose p such that
rpk = max
j
r jk,
j ≥k
If we ﬁnd such an element, then we interchange the rows k and p, and proceed with
the elimination pass as usual. Note that the corresponding row interchange must also
be carried out in the scale factor array s. The algorithm that does all this is
for k in range(0,n-1):
# Find row containing element with largest relative size
p = int(argmax(abs(a[k:n,k])/s[k:n])) + k
# If this element is very small, matrix is singular
if abs(a[p,k]) < tol: error.err(’Matrix is singular’)

70
Systems of Linear Algebraic Equations
# Check whether rows k and p must be interchanged
if p != k:
# Interchange rows if needed
swap.swapRows(b,k,p)
swap.swapRows(s,k,p)
swap.swapRows(a,k,p)
# Proceed with elimination
The Python statement int(argmax(v)) returns the index of the largest element
in the vector v. The algorithms for exchanging rows (and columns) are included in the
module swap shown below.
■swap
The function swapRows interchanges rows i and j of a matrix or vector v, whereas
swapCols interchanges columns i and j of a matrix.
## module swap
’’’ swapRows(v,i,j).
Swaps rows i and j of vector or matrix [v].
swapCols(v,i,j).
Swaps columns i and j of matrix [v].
’’’
def swapRows(v,i,j):
if len(v.getshape()) == 1:
v[i],v[j] = v[j],v[i]
else:
temp = v[i].copy()
v[i] = v[j]
v[j] = temp
def swapCols(v,i,j):
temp = v[:,j].copy()
v[:,j] = v[:,i]
v[:,i] = temp

71
2.5 Pivoting
■gaussPivot
The function gaussPivot performs Gauss elimination with row pivoting. Apart from
row swapping, the elimination and solution phases are identical to gaussElimin in
Art. 2.2.
## module gaussPivot
’’’ x = gaussPivot(a,b,tol=1.0e-9).
Solves [a]{x}
= {b}
by Gauss elimination with
scaled row pivoting
’’’
from numarray import *
import swap
import error
def gaussPivot(a,b,tol=1.0e-9):
n = len(b)
# Set up scale factors
s = zeros((n),type=Float64)
for i in range(n):
s[i] = max(abs(a[i,:]))
for k in range(0,n-1):
# Row interchange, if needed
p = int(argmax(abs(a[k:n,k])/s[k:n])) + k
if abs(a[p,k]) < tol:
error.err(’Matrix is singular’)
if p != k:
swap.swapRows(b,k,p)
swap.swapRows(s,k,p)
swap.swapRows(a,k,p)
# Elimination
for i in range(k+1,n):
if a[i,k] != 0.0:
lam = a[i,k]/a[k,k]
a[i,k+1:n] = a [i,k+1:n] - lam*a[k,k+1:n]
b[i] = b[i] - lam*b[k]

72
Systems of Linear Algebraic Equations
if abs(a[n-1,n-1]) < tol:
error.err(’Matrix is singular’)
# Back substitution
for k in range(n-1,-1,-1):
b[k] = (b[k] - dot(a[k,k+1:n],b[k+1:n]))/a[k,k]
return b
■LUpivot
The Gauss elimination algorithm can be changed to Doolittle’s decomposition with
minor changes. The most important of these is keeping a record of the row inter-
changes during the decomposition phase. In LUdecomp this record is kept in the array
seq. Initially seq contains [0, 1, 2, . . .]. Whenever two rows are interchanged, the cor-
responding interchange is also carried out in seq. Thus seq shows the order in which
of the original rows have been rearranged. This information is passed on to the so-
lution phase (LUsolve), which rearranges the elements of the constant vector in the
same order before proceeding to forward and back substitutions.
## module LUpivot
’’’ a,seq = LUdecomp(a,tol=1.0e-9).
LU decomposition of matrix [a] using scaled row pivoting.
The returned matrix [a] = [L\U] contains [U] in the upper
triangle and the nondiagonal terms of [L] in the lower triangle.
Note that [L][U] is a row-wise permutation of the original [a];
the permutations are recorded in the vector {seq}.
x = LUsolve(a,b,seq).
Solves [L][U]{x}
= {b}, where the matrix [a] = [L\U] and the
permutation vector {seq}
are returned from LUdecomp.
’’’
from numarray import argmax,abs,dot,zeros,Float64,array
import swap
import error
def LUdecomp(a,tol=1.0e-9):
n = len(a)
seq = array(range(n))

73
2.5 Pivoting
# Set up scale factors
s = zeros((n),type=Float64)
for i in range(n):
s[i] = max(abs(a[i,:]))
for k in range(0,n-1):
# Row interchange, if needed
p = int(argmax(abs(a[k:n,k])/s[k:n])) + k
if abs(a[p,k]) <
tol:
error.err(’Matrix is singular’)
if p != k:
swap.swapRows(s,k,p)
swap.swapRows(a,k,p)
swap.swapRows(seq,k,p)
# Elimination
for i in range(k+1,n):
if a[i,k] != 0.0:
lam = a[i,k]/a[k,k]
a[i,k+1:n] = a[i,k+1:n] - lam*a[k,k+1:n]
a[i,k] = lam
return a,seq
def LUsolve(a,b,seq):
n = len(a)
# Rearrange constant vector; store it in [x]
x = b.copy()
for i in range(n):
x[i] = b[seq[i]]
# Solution
for k in range(1,n):
x[k] = x[k] - dot(a[k,0:k],x[0:k])
for k in range(n-1,-1,-1):
x[k] = (x[k] - dot(a[k,k+1:n],x[k+1:n]))/a[k,k]
return x

74
Systems of Linear Algebraic Equations
When to Pivot
Pivoting hasa couple of drawbacks. One of these is the increased time of computation;
the other is the destruction of the symmetry and banded structure of the coefﬁcient
matrix. The latter is of particular concern in engineering computing, where the co-
efﬁcient matrices are frequently banded and symmetric, a property that is utilized
in the solution, as seen in the previous chapter. Fortunately, these matrices are often
diagonally dominant as well, so that they would not beneﬁt from pivoting anyway.
There are no infallible rules for determining when pivoting should be used. Expe-
rience indicates that pivoting is likely to be counterproductive if the coefﬁcient matrix
is banded. Positive deﬁnite and, to a lesser degree, symmetric matrices also seldom
gain from pivoting. And we should not forget that pivoting is not the only means of
controlling roundoff errors—there is also double precision arithmetic.
It should be strongly emphasized that the above rules of thumb are only meant
for equations that stem from real engineering problems. It is not difﬁcult to concoct
“textbook” examples that do not conform to these rules.
EXAMPLE 2.12
Employ Gauss elimination with scaled row pivoting to solve the equations Ax = b,
where
A =


2
−2
6
−2
4
3
−1
8
4


b =


16
0
−1


Solution The augmented coefﬁcient matrix and the scale factor array are

A
b

=


2
−2
6
16
−2
4
3
0
−1
8
4
−1


s =


6
4
8


Note that s contains the absolute value of the largest element in each row of A. At this
stage, all the elements in the ﬁrst column of A are potential pivots. To determine the
best pivot element, we calculate the relative sizes of the elements in the ﬁrst column:


r11
r21
r31

=


|A11| /s1
|A21| /s2
|A31| /s3

=


1/3
1/2
1/8


Since r21 is the largest element, we conclude that A21 makes the best pivot element.
Therefore, we exchange rows 1 and 2 of the augmented coefﬁcient matrix and the

75
2.5 Pivoting
scale factor array, obtaining

A
b

=


−2
4
3
0
2
−2
6
16
−1
8
4
−1


←
s =


4
6
8


Now the ﬁrst pass of Gauss elimination is carried out (the arrow points to the pivot
row), yielding

A′
b′
=


−2
4
3
0
0
2
9
16
0
6
5/2
−1


s =


4
6
8


The potential pivot elements for the next elimination pass are A′
22 and A′
32. We
determine the “winner” from


∗
r22
r32

=


∗
|A22| /s2
|A32| /s3

=


∗
1/3
3/4


Note that r12 is irrelevant, since row 1 already acted as the pivot row. Therefore, it is
excluded from further consideration. Asr32 is larger thanr22, the third row is the better
pivot row. After interchanging rows 2 and 3, we have

A′
b′
=


−2
4
3
0
0
6
5/2
−1
0
2
9
16

←
s =


4
8
6


The second elimination pass now yields

A′′
b′′
=

U
c

=


−2
4
3
0
0
6
5/2
−1
0
0
49/6
49/3


This completes the elimination phase. It should be noted that U is the matrix that
would result from LU decomposition of the following row-wise permutation of A (the
ordering of rows is the same as achieved by pivoting):


−2
4
3
−1
8
4
2
−2
6


Since the solution of Ux = c by back substitution is not affected by pivoting, we skip
the detailed of the computation. The result is xT =

1
−1
2

.

76
Systems of Linear Algebraic Equations
Alternate Solution
It it not necessary to physically exchange equations during pivoting. We could accom-
plish Gauss elimination just as well by keeping the equations in place. The elimination
would then proceed as follows (for the sake of brevity, we skip repeating the details of
choosing the pivot equation):

A
b

=


2
−2
6
16
−2
4
3
0
−1
8
4
−1

←

A′
b′
=


0
2
9
16
−2
4
3
0
0
6
5/2
−1


←

A′′
b′′
=


0
0
49/6
49/3
−2
4
3
0
0
6
5/2
−1


But now the back substitution phase is a little more involved, since the order in which
the equations must be solved has become scrambled. In hand computations this is
not a problem, because we can determine the order by inspection. Unfortunately,
“by inspection” does not work on a computer. To overcome this difﬁculty, we have
to maintain an integer array p that keeps track of the row permutations during the
elimination phase. The contents of p indicate the order in which the pivot rows were
chosen. In this example, we would have at the end of Gauss elimination
p =


2
3
1


showing that row 2 was the pivot row in the ﬁrst elimination pass, followed by row 3
in the second pass. The equations are solved by back substitution in the reverse
order: Eq. (1) is solved ﬁrst for x3, then Eq. (3) is solved for x2, and ﬁnally Eq. (2)
yields x1.
By dispensing with swapping of equations, the scheme outlined above would
probably result in a faster (and more complex) algorithm than gaussPivot, but the
number of equations would have to be quite large before the difference becomes
noticeable.

77
2.5 Pivoting
PROBLEM SET 2.2
1. Solve the equations Ax = b by utilizing Doolittle’s decomposition, where
A =


3
−3
3
−3
5
1
3
1
5


b =


9
−7
12


2. Use Doolittle’s decomposition to solve Ax = b, where
A =


4
8
20
8
13
16
20
16
−91


b =


24
18
−119


3. Determine L and D that result from Doolittle’s decomposition of the symmetric
matrix
A =


2
−2
0
0
0
−2
5
−6
0
0
0
−6
16
12
0
0
0
12
39
−6
0
0
0
−6
14


4. Solve the tridiagonal equations Ax = b by Doolittle’s decomposition method,
where
A =


6
2
0
0
0
−1
7
2
0
0
0
−2
8
2
0
0
0
3
7
−2
0
0
0
3
5


b =


2
−3
4
−3
1


5. Use Gauss elimination with scaled row pivoting to solve


4
−2
1
−2
1
−1
−2
3
6




x1
x2
x3

=


2
−1
0


6. Solve Ax = b by Gauss elimination with scaled row pivoting, where
A =


2.34
−4.10
1.78
−1.98
3.47
−2.22
2.36
−15.17
6.81


b =


0.02
−0.73
−6.63



78
Systems of Linear Algebraic Equations
7. Solve the equations


2
−1
0
0
0
0
−1
1
0
−1
2
−1
−1
2
−1
0




x1
x2
x3
x4

=


1
0
0
0


by Gauss elimination with scaled row pivoting.
8. ■Solve the equations


0
2
5
−1
2
1
3
0
−2
−1
3
1
3
3
−1
2




x1
x2
x3
x4

=


−3
3
−2
5


9. ■Solve the symmetric, tridiagonal equations
4x1 −x2 = 9
−xi−1 + 4xi −xi+1 = 5,
i = 2, . . . , n−1
−xn−1 + 4xn = 5
with n = 10.
10. ■Solve the equations Ax = b, where
A =


1.3174
2.7250
2.7250
1.7181
0.4002
0.8278
1.2272
2.5322
0.8218
1.5608
0.3629
2.9210
1.9664
2.0011
0.6532
1.9945


b =


8.4855
4.9874
5.6665
6.6152


11. ■Solve the equations


10
−2
−1
2
3
1
−4
7
5
11
3
10
−3
3
3
−4
7
12
1
5
3
−12
2
3
8
7
−2
1
3
2
2
4
2
−15
−1
1
4
−1
8
3
4
2
9
1
12
−1
4
1
−1
4
−7
−1
1
1
−1
−3
−1
3
4
1
3
−4
7
6




x1
x2
x3
x4
x5
x6
x7
x8


=


0
12
−5
3
−25
−26
9
−7


12. ■The system shown in Fig. (a) consists of nlinear springs that support nmasses.
The spring stiffnesses are denoted by ki, the weights of the masses are Wi and
xi are the displacements of the masses (measured from the positions where the
springs are undeformed). The so-called displacement formulation is obtained by

79
2.5 Pivoting
writing the equilibrium equation of each mass and substituting Fi = ki(xi+1 −xi)
for the spring forces. The result is the symmetric, tridiagonal set of equations
(k1 + k2)x1 −k2x2 = W1
−kixi−1 + (ki + ki+1)xi −ki+1xi+1 = Wi,
i = 2, 3, . . . , n−1
−knxn−1 + knxn = Wn
Write a program that solves these equations for given values of n, k and W. Run
the program with n = 5 and
k1 = k2 = k3 = 10 N/mm
k4 = k5 = 5 N/mm
W1 = W3 = W5 = 100 N
W2 = W4 = 50 N
x1
k
x
k
x
k
k
2
n
W
2
3
n
1
W
W
n
1
2
W1
k1
x
x1
x
W2
k2
k3
x2
x
W
k
k
3
4
5
3
(a)
(b)
13. ■The displacement formulation for the mass–spring system shown in Fig. (b)
results in the following equilibrium equations of the masses:


k1 + k2 + k3 + k5
−k3
−k5
−k3
k3 + k4
−k4
−k5
−k4
k4 + k5




x1
x2
x3

=


W1
W2
W3


where ki are the spring stiffnesses, Wi represent the weights of the masses, and
xi are the displacements of the masses from the undeformed conﬁguration of
the system. Write a program that solves these equations, given k and W. Use the
program to ﬁnd the displacements if
k1 = k3 = k4 = k
k2 = k5 = 2k
W1 = W3 = 2W
W2 = W

80
Systems of Linear Algebraic Equations
14. ■
45 kN
1.8 m
2.4 m
u1
u 2
u3
u5
u4
The displacement formulation for a plane truss is similar to that of a mass–spring
system. The differences are: (1) the stiffnesses of the members are ki = (E A/L)i,
where E is the modulus of elasticity, A represents the cross-sectional area and L is
the length of the member; (2) there are two components of displacement at each
joint. For the statically indeterminate truss shown the displacement formulation
yields the symmetric equations Ku = p, where
K =


27.58
7.004
−7.004
0.0000
0.0000
7.004
29.57
−5.253
0.0000
−24.32
−7.004
−5.253
29.57
0.0000
0.0000
0.0000
0.0000
0.0000
27.58
−7.004
0.0000
−24.32
0.0000
−7.004
29.57


MN/m
p =

0
0
0 0 −45

T kN
Determine the displacements ui of the joints.
15. ■
P
P
P
P
P
P
1
2
3
4
5
6
P
P2
P3
P4
P5
P6
18 kN
12 kN
45
45
1
In the force formulation of a truss, the unknowns are the member forces Pi. For
the statically determinate truss shown, the equilibrium equations of the joints
are:


−1
1
−1/
√
2
0
0
0
0
0
1/
√
2
1
0
0
0
−1
0
0
−1/
√
2
0
0
0
0
0
1/
√
2
0
0
0
0
0
1/
√
2
1
0
0
0
−1
−1/
√
2
0




P1
P2
P3
P4
P5
P6


=


0
18
0
12
0
0



81
2.5 Pivoting
where the units of Pi are kN. (a) Solve the equations as they are with a computer
program. (b) Rearrange the rows and columns so as to obtain a lower triangular
coefﬁcient matrix, and then solve the equations by back substitution using a
calculator.
16. ■
P
P
P
P
1
2
3
4
P1
P1
P1
P2
P2
P2
P3
P3
P3
P4
P5
P5
Load = 1
The force formulation of the symmetric truss shown results in the joint equilib-
rium equations


c
1
0
0
0
0
s
0
0
1
0
0
2s
0
0
0
−c
c
1
0
0
s
s
0
0




P1
P2
P3
P4
P5


=


0
0
1
0
0


where s = sin θ, c = cos θ and Pi are the unknown forces. Write a program that
computes the forces, given the angle θ. Run the program with θ = 53◦.
17. ■
i1
i 2
i3
20
10
R
220 V
0 V
15
5
5
The electrical network shown can be viewed as consisting of three loops. Apply-
ing Kirchoff’s law (voltage drops = voltage sources) to each loop yields the
following equations for the loop currents i1, i2 and i3:
5i1 + 15(i1 −i3) = 220 V
R(i2 −i3) + 5i2 + 10i2 = 0
20i3 + R(i3 −i2) + 15(i3 −i1) = 0
Compute the three loop currents for R = 5, 10 and 20 .

82
Systems of Linear Algebraic Equations
18. ■
50
30
15
15
20
30
10
5
10 Ω
25
i
i
i
i
2
1
3
4
-120 V
+120 V
Determine the loop currents i1 to i4 in the electrical network shown.
19. ■Consider the n simultaneous equations Ax = b, where
Aij = (i + j)2
bi =
n−1

j=0
Aij,
i = 0, 1, . . . , n−1,
j = 0, 1, . . . , n−1
The solution is x =

1
1
· · ·
1
T
. Write a program that solves these equations
for any given n(pivoting is recommended). Run the program with n = 2, 3 and 4,
and comment on the results.
∗2.6
Matrix Inversion
Computing the inverse of a matrix and solving simultaneous equations are related
tasks. The most economical way to invert an n× n matrix A is to solve the equations
A X = I
(2.33)
where I is the n× nidentity matrix. The solution X, also of size n× n, will be the inverse
of A. The proof is simple: after we premultiply both sides of Eq. (2.33) by A−1 we have
A−1A X = A−1I, which reduces to X = A−1.
Inversion of large matrices should be avoided whenever possible due its high
cost. As seen from Eq. (2.33), inversion of A is equivalent to solving Axi= bi with
i = 1, 2, . . . , n, where bi is the ith column of I. If LU decomposition is employed in
the solution, the solution phase (forward and back substitution) must be repeated n
times, once for each bi. Since the cost of computation is proportional to n3 for the
decompositionphaseandn2 foreachvectorofthesolutionphase,thecostofinversion
is considerably more expensive than the solution of Ax = b (single constant vector b).
Matrix inversion has another serious drawback—a banded matrix loses its struc-
ture during inversion. In other words, if A is banded or otherwise sparse, then A−1 is
fully populated. However, the inverse of a triangular matrix remains triangular.

83
2.6 Matrix Inversion
EXAMPLE 2.13
Write a function that inverts a matrix using LU decomposition with pivoting. Test the
function by inverting
A =


0.6
−0.4
1.0
−0.3
0.2
0.5
0.6
−1.0
0.5


Solution The function matInv listed below uses the decomposition and solution
procedures in the module LUpivot.
#!/usr/bin/python
## example2_13
from numarray import array,identity, matrixmultiply
from LUpivot import *
def matInv(a):
n = len(a[0])
aInv = identity(n)*1.0
a,seq = LUdecomp(a)
for i in range(n):
aInv[:,i] = LUsolve(a,aInv[:,i],seq)
return aInv
a = array([[ 0.6, -0.4,
1.0],\
[-0.3,
0.2,
0.5],\
[ 0.6, -1.0,
0.5]])
aOrig = a.copy()
# Save original [a]
aInv = matInv(a)
# Invert [a] (original [a] is destroyed)
print ’’\naInv =\n’’,aInv
print ’’\nCheck: a*aInv =\n’’, matrixmultiply(aOrig,aInv)
raw_input(’’\nPress return to exit’’)
The output is
aInv =
[[ 1.66666667 -2.22222222 -1.11111111]
[ 1.25
-0.83333333 -1.66666667]
[ 0.5
1.
0.
]]
Check: a*aInv =
[[
1.00000000e+00
-4.44089210e-16
-1.11022302e-16]
[
0.00000000e+00
1.00000000e+00
5.55111512e-17]
[
0.00000000e+00
-3.33066907e-16
1.00000000e+00]]

84
Systems of Linear Algebraic Equations
EXAMPLE 2.14
Invert the matrix
A =


2
−1
0
0
0
0
−1
2
−1
0
0
0
0
−1
2
−1
0
0
0
0
−1
2
−1
0
0
0
0
−1
2
−1
0
0
0
0
−1
5


Solution Since the matrix is tridiagonal, we solve AX = I using the functions in the
module LUdecomp3 (LU decomposition of tridiagonal matrices).
#!/usr/bin/python
## example2_14
from numarray import array,ones,identity,Float64
from LUdecomp3 import *
n = 6
d = ones((n))*2.0
e = ones((n-1))*(-1.0)
c = e.copy()
d[n-1] = 5.0
aInv = identity(n)*1.0
c,d,e = LUdecomp3(c,d,e)
for i in range(n):
aInv[:,i] = LUsolve3(c,d,e,aInv[:,i])
print ’’\nThe inverse matrix is:\n’’,aInv
raw_input(’’\nPress return to exit’’)
Running the program results in the following output:
The inverse matrix is:
[[ 0.84
0.68
0.52
0.36
0.2
0.04]
[ 0.68
1.36
1.04
0.72
0.4
0.08]
[ 0.52
1.04
1.56
1.08
0.6
0.12]
[ 0.36
0.72
1.08
1.44
0.8
0.16]
[ 0.2
0.4
0.6
0.8
1.
0.2 ]
[ 0.04
0.08
0.12
0.16
0.2
0.24]]]
Note that A is tridiagonal, whereas A−1 is fully populated.

85
2.7 Iterative Methods
∗2.7
Iterative Methods
Introduction
So far, we have discussed only direct methods of solution. The common characteristic
of these methods is that they compute the solution with a ﬁnite number of operations.
Moreover, if the computer were capable of inﬁnite precision (no roundoff errors), the
solution would be exact.
Iterative, or indirect methods, start with an initial guess of the solution x and then
repeatedly improve the solution until the change in x becomes negligible. Since the
requirednumberofiterationscanbelarge,theindirectmethodsare,ingeneral,slower
than their direct counterparts. However, iterative methods do have the following ad-
vantages that make them attractive for certain problems:
1.
It is feasible to store only the nonzero elements of the coefﬁcient matrix. This
makes it possible to deal with very large matrices that are sparse, but not neces-
sarily banded. In many problems, there is no need to store the coefﬁcient matrix
at all.
2.
Iterative procedures are self-correcting, meaning that roundoff errors (or even
arithmetic mistakes) in one iterative cycle are corrected in subsequent cycles.
A serious drawback of iterative methods is that they do not always converge to the
solution. It can be shown that convergence is guaranteed only if the coefﬁcient matrix
is diagonally dominant. The initial guess for x plays no role in determining whether
convergence takes place—if the procedure converges for one starting vector, it would
do so for any starting vector. The initial guess affects only the number of iterations
that are required for convergence.
Gauss–Seidel Method
The equations Ax = b are in scalar notation
n

j=1
Aijxj = bi,
i = 1, 2, . . . , n
Extracting the term containing xi from the summation sign yields
Aiixi +
n

j=1
j̸=i
Aijxj = bi,
i = 1, 2, . . . , n

86
Systems of Linear Algebraic Equations
Solving for xi, we get
xi = 1
Aii

bi −
n

j=1
j̸=i
Aijxj

,
i = 1, 2, . . . , n
The last equation suggests the following iterative scheme
xi ←1
Aii

bi −
n

j=1
j̸=i
Aijxj

,
i = 1, 2, . . . , n
(2.34)
We start by choosing the starting vector x. If a good guess for the solution is not
available, x can be chosen randomly. Equation (2.34) is then used to recompute each
elementofx,alwaysusingthelatestavailablevaluesof xj.Thiscompletesoneiteration
cycle. The procedure is repeated until the changes in x between successive iteration
cycles become sufﬁciently small.
Convergence of the Gauss–Seidel method can be improved by a technique known
asrelaxation.Theideaistotakethenewvalueof xi asaweightedaverageofitsprevious
value and the value predicted by Eq. (2.34). The corresponding iterative formula is
xi ←ω
Aii

bi −
n

j=1
j̸=i
Aijxj

+ (1 −ω)xi,
i = 1, 2, . . . , n
(2.35)
where the weight ω is called the relaxation factor. It can be seen that if ω = 1, no re-
laxation takes place, since Eqs. (2.34) and (2.35) produce the same result. If ω < 1, Eq.
(2.35) represents interpolation between the old xi and the value given by Eq. (2.34).
This is called underrelaxation. In cases where ω > 1, we have extrapolation, or over-
relaxation.
There is no practical method of determining the optimal value of ω beforehand;
however, a good estimate can be computed during run time. Let x(k) =
x(k−1) −x(k)
be the magnitude of the change in x during the kth iteration (carried out without
relaxation, i.e., with ω = 1). If k is sufﬁciently large (say k ≥5), it can be shown4 that
an approximation of the optimal value of ω is
ωopt ≈
2
1 +

1 −

x(k+p)/x(k) 1/p
(2.36)
where p is a positive integer.
4 See, for example, Terrence J. Akai, Applied Numerical Methods for Engineers, John Wiley & Sons
(1994), p. 100.

87
2.7 Iterative Methods
The essential elements of a Gauss–Seidel algorithm with relaxation are:
1. Carry out k iterations with ω = 1 (k = 10 is reasonable). After the kth iteration
record x(k).
2. Perform an additional p iterations and record x(k+p) for the last iteration.
3. Perform all subsequent iterations with ω = ωopt, where ωopt is computed from
Eq. (2.36).
■gaussSeidel
The function gaussSeidel is an implementation of the Gauss–Seidel method with
relaxation. It automatically computes ωopt from Eq. (2.36) using k = 10 and p = 1.
The user must provide the function iterEqs that computes the improved x from the
iterative formulas in Eq. (2.35)—see Example 2.17. The function returns the solution
vector x, the number of iterations carried out and the value of ωopt used.
## module gaussSeidel
’’’ x,numIter,omega = gaussSeidel(iterEqs,x,tol = 1.0e-9)
Gauss-Seidel method for solving [A]{x}
= {b}.
The matrix [A] should be sparse. User must supply the
function iterEqs(x,omega) that returns the improved {x},
given the current {x}
(’omega’ is the relaxation factor).
’’’
from numarray import dot
from math import sqrt
def gaussSeidel(iterEqs,x,tol = 1.0e-9):
omega = 1.0
k = 10
p = 1
for i in range(1,501):
xOld = x.copy()
x = iterEqs(x,omega)
dx = sqrt(dot(x-xOld,x-xOld))
if dx < tol: return x,i,omega
# Compute of relaxation factor after k+p iterations
if i == k: dx1 = dx
if i == k + p:
dx2 = dx
omega = 2.0/(1.0 + sqrt(1.0 - (dx2/dx1)**(1.0/p)))
print ’Gauss-Seidel failed to converge’

88
Systems of Linear Algebraic Equations
Conjugate Gradient Method
Consider the problem of ﬁnding the vector x that minimizes the scalar function
f (x) = 1
2xTAx −bTx
(2.37)
where the matrix A is symmetric and positive deﬁnite. Because f (x) is minimized
when its gradient ∇f = Ax −b is zero, we see that minimization is equivalent to
solving
Ax = b
(2.38)
Gradient methods accomplish the minimization by iteration, starting with an
initial vector x0. Each iterative cycle k computes a reﬁned solution
xk+1 = xk + αksk
(2.39)
The step length αk is chosen so that xk+1 minimizes f (xk+1) in the search direction sk.
That is, xk+1 must satisfy Eq. (2.38):
A(xk + αksk) = b
(a)
Introducing the residual
rk = b −Axk
(2.40)
Eq. (a) becomes αAsk = rk. Premultiplying both sides by sT
k and solving for αk, we
obtain
αk = sT
k rk
sT
k Ask
(2.41)
We are still left with the problem of determining the search direction sk. Intuition
tells us to choose sk = −∇f = rk, since this is the direction of the largest negative
change in f (x). The resulting procedure is known as the method of steepest descent.
It is not a popular algorithm since its convergence can be slow. The more efﬁcient
conjugate gradient method uses the search direction
sk+1 = rk+1 + βksk
(2.42)
The constant βk is chosen so that the two successive search directions are conjugate
to each other, meaning
sT
k+1Ask = 0
(b)

89
2.7 Iterative Methods
The great attraction of conjugate gradients is that minimization in one conjugate
direction does not undo previous minimizations (minimizations do not interfere with
one another).
Substituting sk+1 from Eq. (2.42) into Eq. (b), we get

rT
k+1 + βksT
k
 
Ask = 0
which yields
βk = −rT
k+1Ask
sT
k Ask
(2.43)
Here is the outline of the conjugate gradient algorithm:
r Choose x0 (any vector will do, but one close to solution results in fewer iterations)
r r0 ←b −Ax0
r s0 ←r0 (lacking a previous search direction, choose the direction of steepest
descent)
r do with k = 0, 1, 2, . . .
αk ←sT
k rk
sT
k Ask
xk+1 ←xk + αksk
rk+1 ←b −Axk+1
if |rk+1| ≤ε exit loop (ε is the error tolerance)
βk ←−rT
k+1Ask
sT
k Ask
sk+1 ←rk+1 + βksk
end do
It can be shown that the residual vectors r1, r2, r3, . . . produced by the algorithm
aremutuallyorthogonal;thatis,ri · r j = 0,i ̸= j.Nowsupposethatwehavecarriedout
enough iterations to have computed the whole set of n residual vectors. The residual
resulting from the next iteration must be the null vector (rn+1 = 0), indicating that the
solution has been obtained. It thus appears that the conjugate gradient algorithm is
not an iterative method at all, since it reaches the exact solution after ncomputational
cycles. In practice, however, convergence is usually achieved in less than niterations.
The conjugate gradient method is not competitive with direct methods in the
solution of small sets of equations. Its strength lies in the handling of large, sparse
systems (where most elements of A are zero). It is important to note that A enters the
algorithm only through its multiplication by a vector; that is, in the form Av, where v is
avector(eitherxk+1 orsk).IfAissparse,itispossibletowriteanefﬁcientsubroutinefor
the multiplication and pass it, rather than A itself, to the conjugate gradient algorithm.

90
Systems of Linear Algebraic Equations
■conjGrad
The function conjGrad shown below implements the conjugate gradient algorithm.
The maximum allowable number of iterations is set to n (the number of unknowns).
Note that conjGrad calls the function Av which returns the product Av. This func-
tion must be supplied by the user (see Example 2.18). We must also supply the starting
vector x0 and the constant (right-hand-side) vector b. The function returns the solu-
tion vector x and the number of iterations:
## module conjGrad
’’’ x, numIter = conjGrad(Av,x,b,tol=1.0e-9)
Conjugate gradient method for solving [A]{x}
= {b}.
The matrix [A] should be sparse. User must supply
the function Av(v) that returns the vector [A]{v}.
’’’
from numarray import dot
from math import sqrt
def conjGrad(Av,x,b,tol=1.0e-9):
n = len(b)
r = b - Av(x)
s = r.copy()
for i in range(n):
u = Av(s)
alpha = dot(s,r)/dot(s,u)
x = x + alpha*s
r = b - Av(x)
if(sqrt(dot(r,r))) < tol:
break
else:
beta = -dot(r,u)/dot(s,u)
s = r + beta*s
return x,i
EXAMPLE 2.15
Solve the equations


4
−1
1
−1
4
−2
1
−2
4




x1
x2
x3

=


12
−1
5


by the Gauss–Seidel method without relaxation.

91
2.7 Iterative Methods
Solution With the given data, the iteration formulas in Eq. (2.34) become
x1 = 1
4 (12 + x2 −x3)
x2 = 1
4 (−1 + x1 + 2x3)
x3 = 1
4 (5 −x1 + 2x2)
Choosing the starting values x1 = x2 = x3 = 0, we have for the ﬁrst iteration
x1 = 1
4 (12 + 0 −0) = 3
x2 = 1
4 [−1 + 3 + 2(0)] = 0.5
x3 = 1
4 [5 −3 + 2(0.5)] = 0.75
The second iteration yields
x1 = 1
4 (12 + 0.5 −0.75) = 2.9375
x2 = 1
4 [−1 + 2.9375 + 2(0.75)] = 0.859 38
x3 = 1
4 [5 −2.9375 + 2(0.859 38)] = 0 .945 31
and the third iteration results in
x1 = 1
4 (12 + 0.85938 −0 .94531) = 2.978 52
x2 = 1
4 [−1 + 2.97852 + 2(0 .94531)] = 0.967 29
x3 = 1
4 [5 −2.97852 + 2(0.96729)] = 0.989 02
After ﬁve more iterations the results would agree with the exact solution x1 = 3,
x2 = x3 = 1 within ﬁve decimal places.
EXAMPLE 2.16
Solve the equations in Example 2.15 by the conjugate gradient method.
Solution The conjugate gradient method should converge after three iterations.
Choosing again for the starting vector
x0 =

0
0
0
T

92
Systems of Linear Algebraic Equations
the computations outlined in the text proceed as follows:
First iteration
r0 = b −Ax0 =


12
−1
5

−


4
−1
1
−1
4
−2
1
−2
4




0
0
0

=


12
−1
5


s0 = r0 =


12
−1
5


As0 =


4
−1
1
−1
4
−2
1
−2
4




12
−1
5

=


54
−26
34


α0 = sT
0 r0
sT
0 As0
=
122 + (−1)2 + 52
12(54) + (−1)(−26) + 5(34) = 0.201 42
x1 = x0 + α0s0 =


0
0
0

+ 0.201 42


12
−1
5

=


2.41 704
−0. 201 42
1.007 10


Second iteration
r1 = b −Ax1 =


12
−1
5

−


4
−1
1
−1
4
−2
1
−2
4




2.417 04
−0. 201 42
1.007 10

=


1.123 32
4.236 92
−1.848 28


β0 = −rT
1 As0
sT
0 As0
= −1.123 32(54) + 4.236 92(−26) −1.848 28(34)
12(54) + (−1)(−26) + 5(34)
= 0.133 107
s1 = r1 + β0s0 =


1.123 32
4.236 92
−1.848 28

+ 0.133 107


12
−1
5

=


2.720 76
4.103 80
−1.182 68


As1 =


4
−1
1
−1
4
−2
1
−2
4




2.720 76
4.103 80
−1.182 68

=


5.596 56
16.059 80
−10.217 60



93
2.7 Iterative Methods
α1 = sT
1 r1
sT
1 As1
=
2.720 76(1.123 32) + 4.103 80(4.236 92) + (−1.182 68)(−1.848 28)
2.720 76(5.596 56) + 4.103 80(16.059 80) + (−1.182 68)(−10.217 60)
= 0.24276
x2 = x1 + α1s1 =


2.417 04
−0. 201 42
1.007 10

+ 0.24276


2. 720 76
4. 103 80
−1. 182 68

=


3.077 53
0.794 82
0.719 99


Third iteration
r2 = b −Ax2 =


12
−1
5

−


4
−1
1
−1
4
−2
1
−2
4




3.077 53
0.794 82
0.719 99

=


−0.235 29
0.338 23
0.632 15


β1 = −rT
2 As1
sT
1 As1
= −(−0.235 29)(5.596 56) + 0.338 23(16.059 80) + 0.632 15(−10.217 60)
2.720 76(5.596 56) + 4.103 80(16.059 80) + (−1.182 68)(−10.217 60)
= 0.0251 452
s2 = r2 + β1s1 =


−0.235 29
0.338 23
0.632 15

+ 0.025 1452


2.720 76
4.103 80
−1.182 68

=


−0.166 876
0.441 421
0.602 411


As2 =


4
−1
1
−1
4
−2
1
−2
4




−0.166 876
0.441 421
0.602 411

=
−0.506 514
0.727 738
1.359 930
α2 = rT
2 s2
sT
2 As2
=
(−0.235 29)(−0.166 876) + 0.338 23(0.441 421) + 0.632 15(0.602 411)
(−0.166 876)(−0.506 514) + 0.441 421(0.727 738) + 0.602 411(1.359 930)
= 0.464 80
x3 = x2 + α2s2 =


3.077 53
0.794 82
0.719 99

+ 0.464 80


−0.166 876
0.441 421
0.602 411

=


2.999 97
0.999 99
0.999 99


The solution x3 is correct to almost ﬁve decimal places. The small discrepancy is
caused by roundoff errors in the computations.

94
Systems of Linear Algebraic Equations
EXAMPLE 2.17
Write a computer program to solve the following n simultaneous equations by the
Gauss–Seidel method with relaxation (the program should work with any value of n)5.


2
−1
0
0
. . .
0
0
0
1
−1
2
−1
0
. . .
0
0
0
0
0
−1
2
−1
. . .
0
0
0
0
...
...
...
...
...
...
...
...
0
0
0
0
. . .
−1
2
−1
0
0
0
0
0
. . .
0
−1
2
−1
1
0
0
0
. . .
0
0
−1
2




x1
x2
x3
...
xn−2
xn−1
xn


=


0
0
0
...
0
0
1


Run the program with n = 20. The exact solution can be shown to be xi = −n/4 + i/2,
i = 1, 2, . . . , n.
Solution In this case the iterative formulas in Eq. (2.35) are
x1 = ω(x2 −xn)/2 + (1 −ω)x1
xi = ω(xi−1 + xi+1)/2 + (1 −ω)xi,
i = 2, 3, . . . , n−1
(a)
xn = ω(1 −x1 + xn−1)/2 + (1 −ω)xn
These formulas are evaluated in the function iterEqs.
#!/usr/bin/python
## example2_17
from numarray import zeros,Float64
from gaussSeidel import *
def iterEqs(x,omega):
n = len(x)
x[0] = omega*(x[1] - x[n-1])/2.0 + (1.0 - omega)*x[0]
for i in range(1,n-1):
x[i] = omega*(x[i-1] + x[i+1])/2.0 + (1.0 - omega)*x[i]
x[n-1] = omega*(1.0 - x[0] + x[n-2])/2.0 \
+ (1.0 - omega)*x[n-1]
return x
n = eval(raw_input(’’Number of equations ==> ’’))
x = zeros((n),type=Float64)
x,numIter,omega = gaussSeidel(iterEqs,x)
5 Equations of this form are called cyclic tridiagonal. They occur in the ﬁnite difference formulation
of second-order differential equations with periodic boundary conditions.

95
2.7 Iterative Methods
print ’’\nNumber of iterations =’’,numIter
print ’’\nRelaxation factor =’’,omega
print ’’\nThe solution is:\n’’,x
raw_input(’’\nPress return to exit’’)
The output from the program is:
Number of equations ==> 20
Number of iterations = 259
Relaxation factor = 1.70545231071
The solution is:
[-4.50000000e+00 -4.00000000e+00 -3.50000000e+00 -3.00000000e+00
-2.50000000e+00 -2.00000000e+00 -1.50000000e+00 -9.99999997e-01
-4.99999998e-01
2.14046747e-09
5.00000002e-01
1.00000000e+00
1.50000000e+00
2.00000000e+00
2.50000000e+00
3.00000000e+00
3.50000000e+00
4.00000000e+00
4.50000000e+00
5.00000000e+00]
The convergence is very slow, because the coefﬁcient matrix lacks diagonal
dominance—substitutingtheelementsofAintoEq.(2.30)producesanequalityrather
than the desired inequality. If we were to change each diagonal term of the coefﬁcient
matrix from 2 to 4, A would be diagonally dominant and the solution would converge
in about 20 iterations.
EXAMPLE 2.18
Solve Example 2.17 with the conjugate gradient method, also using n = 20.
Solution The program shown below utilizes the function conjGrad. The solution
vector x is initialized to zero in the program, which also sets up the constant vector b.
The function Av(v) returns the product Av, where A is the coefﬁcient matrix and v is
a vector. For the given A, the components of the vector Av are
(Av)1 = 2v1 −v2 + vn
(Av)i = −vi−1 + 2vi −vi+1,
i = 2, 3, . . . , n−1
(Av)n = −vn−1 + 2vn + v1
which are evaluated by the function Av(v).
#!/usr/bin/python
## example2_18

96
Systems of Linear Algebraic Equations
from numarray import zeros,Float64,sqrt
from conjGrad import *
def Ax(v):
n = len(v)
Ax = zeros((n),type=Float64)
Ax[0] = 2.0*v[0] - v[1] + v[n-1]
Ax[1:n-1] = -v[0:n-2] + 2.0*v[1:n-1] - v[2:n]
Ax[n-1] = -v[n-2] + 2.0*v[n-1] + v[0]
return Ax
n = eval(raw_input(’’Number of equations ==> ’’))
b = zeros((n),type=Float64)
b[n-1] = 1.0
x = zeros((n),type=Float64)
x,numIter = conjGrad(Ax,x,b)
print ’’\nThe solution is:\n’’,x
print ’’\nNumber of iterations =’’,numIter
raw_input(’’\nPress return to exit’’)
Running the program results in
Number of equations ==> 20
The solution is:
[-4.5 -4. -3.5 -3. -2.5 -2. -1.5 -1. -0.5
0.
0.5
1.
1.5
2.
2.5
3.
3.5
4.
4.5
5. ]
Number of iterations = 9
Note that convergence was reached in only 9 iterations, whereas 259 iterations
were required in the Gauss–Seidel method.
PROBLEM SET 2.3
1. Let
A =


3
−1
2
0
1
3
−2
2
−4


B =


0
1
3
3
−1
2
−2
2
−4



97
2.7 Iterative Methods
(note that B is obtained by interchanging the ﬁrst two rows of A). Knowing that
A−1 =


0.5
0
0.25
0.3
0.4
0.45
−0.1
0.2
−0.15


determine B−1.
2. Invert the triangular matrices
A =


2
4
3
0
6
5
0
0
2


B =


2
0
0
3
4
0
4
5
6


3. Invert the triangular matrix
A =


1
1/2
1/4
1/8
0
1
1/3
1/9
0
0
1
1/4
0
0
0
1


4. Invert the following matrices:
(a) A =


1
2
4
1
3
9
1
4
16


(b) B =


4
−1
0
−1
4
−1
0
−1
4


5. Invert the matrix
A =


4
−2
1
−2
1
−1
1
−2
4


6. ■Invert the following matrices with any method:
A =


5
−3
−1
0
−2
1
1
1
3
−5
1
2
0
8
−4
−3


B =


4
−1
0
0
−1
4
−1
0
0
−1
4
−1
0
0
−1
4


7. ■Invert the matrix with any method:
A =


1
3
−9
6
4
2
−1
6
7
1
3
2
−3
15
5
8
−1
1
4
2
11
1
−2
18
7


and comment on the reliability of the result.

98
Systems of Linear Algebraic Equations
8. ■The joint displacements u of the plane truss in Prob. 14, Problem Set 2.2 are
related to the applied joint forces p by
Ku = p
(a)
where
K =


27.580
7.004
−7.004
0.000
0.000
7.004
29.570
−5.253
0.000
−24.320
−7.004
−5.253
29.570
0.000
0.000
0.000
0.000
0.000
27.580
−7.004
0.000
−24.320
0.000
−7.004
29.570


MN/m
is called the stiffness matrix of the truss. If Eq. (a) is inverted by multiplying each
side by K−1, we obtain u = K−1p, where K−1 is known as the ﬂexibility matrix. The
physical meaning of the elements of the ﬂexibility matrix is: K −1
ij
= displacements
ui (i = 1, 2, . . . , 5) produced by the unit load pj = 1. Compute (a) the ﬂexibility
matrix of the truss; (b) the displacements of the joints due to the load p5 = −45
kN (the load shown in Prob. 14, Problem Set 2.2).
9. ■Invert the matrices
A =


3
−7
45
21
12
11
10
17
6
25
−80
−24
17
55
−9
7


B =


1
1
1
1
1
2
2
2
2
3
4
4
4
5
6
7


10. ■Write a program for inverting an n× n lower triangular matrix. The inversion
procedure should contain only forward substitution. Test the program by invert-
ing the matrix
A =


36
0
0
0
18
36
0
0
9
12
36
0
5
4
9
36


11. Use the Gauss–Seidel method to solve


−2
5
9
7
1
1
−3
7
−1




x1
x2
x3

=


1
6
−26



99
2.7 Iterative Methods
12. Solve the following equations with the Gauss–Seidel method:


12
−2
3
1
−2
15
6
−3
1
6
20
−4
0
−3
2
9




x1
x2
x3
x4

=


0
0
20
0


13. Use the Gauss–Seidel method with relaxation to solve Ax = b, where
A =


4
−1
0
0
−1
4
−1
0
0
−1
4
−1
0
0
−1
3


b =


15
10
10
10


Take xi = bi/Aii as the starting vector and use ω = 1.1 for the relaxation factor.
14. Solve the equations


2
−1
0
−1
2
−1
0
−1
1




x1
x2
x3

=


1
1
1


by the conjugate gradient method. Start with x = 0.
15. Use the conjugate gradient method to solve


3
0
−1
0
4
−2
−1
−2
5




x1
x2
x3

=


4
10
−10


starting with x = 0.
16. ■Solve the simultaneous equations Ax = b and Bx = b by the Gauss–Seidel
method with relaxation, where
b =

10
−8
10
10
−8
10
T
A =


3
−2
1
0
0
0
−2
4
−2
1
0
0
1
−2
4
−2
1
0
0
1
−2
4
−2
1
0
0
1
−2
4
−2
0
0
0
1
−2
3



100
Systems of Linear Algebraic Equations
B =


3
−2
1
0
0
1
−2
4
−2
1
0
0
1
−2
4
−2
1
0
0
1
−2
4
−2
1
0
0
1
−2
4
−2
1
0
0
1
−2
3


Note that A is not diagonally dominant, but that does not necessarily preclude
convergence.
17. ■Modify the program in Example 2.17 (Gauss–Seidel method) so that it will solve
the following equations:


4
−1
0
0
· · ·
0
0
0
1
−1
4
−1
0
· · ·
0
0
0
0
0
−1
4
−1
· · ·
0
0
0
0
...
...
...
...
· · ·
...
...
...
...
0
0
0
0
· · ·
−1
4
−1
0
0
0
0
0
· · ·
0
−1
4
−1
1
0
0
0
· · ·
0
0
−1
4




x1
x2
x3
...
xn−2
xn−1
xn


=


0
0
0
...
0
0
100


Runtheprogramwith n = 20andcomparethenumberofiterationswithExample
2.17.
18. ■Modify the program in Example 2.18 to solve the equations in Prob. 17 by the
conjugate gradient method. Run the program with n = 20.
19. ■
T = 0
T = 200
T = 100
T = 0
0
0
0
0
1
2
3
4
5
6
7
8
9
The edges of the square plate are kept at the temperatures shown. Assuming
steady-stateheatconduction,thedifferentialequationgoverningthetemperature
T in the interior is
∂2T
∂x2 + ∂2T
∂y2 = 0

101
2.8 Other Methods
If this equation is approximated by ﬁnite differences using the mesh shown, we
obtain the following algebraic equations for temperatures at the mesh points:


−4
1
0
1
0
0
0
0
0
1
−4
1
0
1
0
0
0
0
0
1
−4
0
0
1
0
0
0
1
0
0
−4
1
0
1
0
0
0
1
0
1
−4
1
0
1
0
0
0
1
0
1
−4
0
0
1
0
0
0
1
0
0
−4
1
0
0
0
0
0
1
0
1
−4
1
0
0
0
0
0
1
0
1
−4




T1
T2
T3
T4
T5
T6
T7
T8
T9


= −


0
0
100
0
0
100
200
200
300


Solve these equations with the conjugate gradient method.
∗2.8
Other Methods
A matrix can be decomposed in numerous ways, some of which are generally useful,
whereas others ﬁnd use in special applications. The most important of the latter are
the QR factorization and the singular value decomposition.
The QR decomposition of a matrix A is
A = QR
where Q is an orthogonal matrix (recall that the matrix Q is orthogonal if Q−1 = QT)
and R is an upper triangular matrix. Unlike LU factorization, QR decomposition does
not require pivoting to sustain stability, but it does involve about twice as many op-
erations. Due to its relative inefﬁciency, the QR factorization is not used as a general-
purpose tool, but ﬁnds its niche in applications that put a premium on stabiliy (e.g.,
solution of eigenvalue problems).
The singular value decomposition is useful in dealing with singular or ill-
conditioned matrices. Here the factorization is
A = UΛVT
where U and V are orthogonal matrices and
Λ =


λ1
0
0
· · ·
0
λ2
0
· · ·
0
0
λ3
· · ·
...
...
...
...



102
Systems of Linear Algebraic Equations
is a diagonal matrix. The elements λi of Λ can be shown to be positive or zero. If
A is symmetric and positive deﬁnite, then the λ’s are the eigenvalues of A. A nice
characteristic of the singular value decomposition is that it works even if A is singular
or ill-conditioned. The conditioning of A can be diagnosed from magnitudes of the
λ’s: the matrix is singular if one or more of the λ’s are zero, and it is ill-conditioned if
the condition number
cond(A) = λmax/λmin
is very large.

3
Interpolation and Curve Fitting
Given the n+ 1 data points (xi, yi), i = 0, 1, . . . , n, estimate y(x).
3.1
Introduction
Discrete data sets, or tables of the form
x0
x1
x2
· · ·
xn
y0
y1
y2
· · ·
yn
are commonly involved in technical calculations. The source of the data may be ex-
perimental observations or numerical computations. There is a distinction between
interpolation and curve ﬁtting. In interpolation we construct a curve through the data
points. In doing so, we make the implicit assumption that the data points are accurate
and distinct. Curve ﬁtting is applied to data that contain scatter (noise), usually due to
measurement errors. Here we want to ﬁnd a smooth curve that approximates the data
in some sense. Thus the curve does not necessarily hit the data points. The difference
between interpolation and curve ﬁtting is illustrated in Fig. 3.1.
x
y
Data points
Interpolation
Curve fitting
Figure 3.1. Interpolation and curve ﬁtting of data.
103

104
Interpolation and Curve Fitting
3.2
Polynomial Interpolation
Lagrange’s Method
The simplest form of an interpolant is a polynomial. It is always possible to construct
a unique polynomial of degree n that passes through n+ 1 distinct data points. One
means of obtaining this polynomial is the formula of Lagrange
Pn(x) =
n

i=0
yiℓi(x)
(3.1a)
where the subscript n denotes the degree of the polynomial and
ℓi(x) = x −x0
xi −x0
· x −x1
xi −x1
· · · x −xi−1
xi −xi−1
· x −xi+1
xi −xi+1
· · · x −xn
xi −xn
=
n
!
j=0
j̸=i
x −xj
xi −xj
,
i = 0, 1, . . . , n
(3.1b)
are called the cardinal functions.
For example, if n = 1, the interpolant is the straight line P1(x) = y0ℓ0(x) + y1ℓ1(x),
where
ℓ0(x) = x −x1
x0 −x1
ℓ1(x) = x −x0
x1 −x0
With n = 2, interpolation is parabolic: P2(x) = y0ℓ0(x) + y1ℓ1(x) + y2ℓ2(x), where now
ℓ0(x) =
(x −x1)(x −x2)
(x0 −x1)(x0 −x2)
ℓ1(x) =
(x −x0)(x −x2)
(x1 −x0)(x1 −x2)
ℓ2(x) =
(x −x0)(x −x1)
(x2 −x0)(x2 −x1)
The cardinal functions are polynomials of degree n and have the property
ℓi(xj) =
"
0 if i ̸= j
1 if i = j
#
= δij
(3.2)
where δij is the Kronecker delta. This property is illustrated in Fig. 3.2 for three-point
interpolation (n = 2) with x0 = 0, x1 = 2 and x2 = 3.
0
1
2
3
0
1
0
2
1
x
l
l
l
Figure 3.2. Example of quadratic cardinal functions.

105
3.2 Polynomial Interpolation
To prove that the interpolating polynomial passes through the data points, we
substitute x = xj into Eq. (3.1a) and then utilize Eq. (3.2). The result is
Pn(xj) =
n

i=0
yiℓi(xj) =
n

i=0
yiδij = yj
It can be shown that the error in polynomial interpolation is
f (x) −Pn(x) = (x −x0)(x −x1) · · · (x −xn)
(n+ 1)!
f (n+1)(ξ)
(3.3)
where ξ lies somewhere in the interval (x0, xn); its value is otherwise unknown. It is
instructive to note that the farther a data point is from x, the more it contributes to
the error at x.
Newton’s Method
Although Lagrange’s method is conceptually simple, it does not lend itself to an efﬁ-
cientalgorithm.AbettercomputationalprocedureisobtainedwithNewton’smethod,
where the interpolating polynomial is written in the form
Pn(x) = a0 + (x −x0)a1 + (x −x0)(x −x1)a2 + · · · + (x −x0)(x −x1) · · · (x −xn−1)an
This polynomial lends itself to an efﬁcient evaluation procedure. Consider, for
example, four data points (n = 3). Here the interpolating polynomial is
P3(x) = a0 + (x −x0)a1 + (x −x0)(x −x1)a2 + (x −x0)(x −x1)(x −x2)a3
= a0 + (x −x0) {a1 + (x −x1) [a2 + (x −x2)a3]}
which can be evaluated backwards with the following recurrence relations:
P0(x) = a3
P1(x) = a2 + (x −x2)P0(x)
P2(x) = a1 + (x −x1)P1(x)
P3(x) = a0 + (x −x0)P2(x)
For arbitrary n we have
P0(x) = an
Pk(x) = an−k + (x −xn−k)Pk−1(x),
k = 1, 2, . . . , n
(3.4)
Denoting the x-coordinate array of the data points by xData and the degree of the
polynomial by n, we have the following algorithm for computing Pn(x):

106
Interpolation and Curve Fitting
p = a[n]
for k in range(1,n+1):
p = a[n-k] + (x - xData[n-k])*p
The coefﬁcients of Pn are determined by forcing the polynomial to pass through
each data point: yi = Pn(xi),
i = 0, 1, . . . , n. This yields the simultaneous equations
y0 = a0
y1 = a0 + (x1 −x0)a1
y2 = a0 + (x2 −x0)a1 + (x2 −x0)(x2 −x1)a2
(a)
...
yn = a0 + (xn −x0)a1 + · · · + (xn −x0)(xn −x1) · · · (xn −xn−1)an
Introducing the divided differences
∇yi = yi −y0
xi −x0
,
i = 1, 2, . . . , n
∇2yi = ∇yi −∇y1
xi −x1
,
i = 2, 3, . . . , n
∇3yi = ∇2yi −∇2y2
xi −x2
,
i = 3, 4, . . . n
(3.5)
...
∇nyn = ∇n−1yn −∇n−1yn−1
xn −xn−1
the solution of Eqs. (a) is
a0 = y0
a1 = ∇y1
a2 = ∇2y2
· · ·
an = ∇nyn
(3.6)
If the coefﬁcients are computed by hand, it is convenient to work with the format in
Table 3.1 (shown for n = 4).
x0
y0
x1
y1
∇y1
x2
y2
∇y2
∇2y2
x3
y3
∇y3
∇2y3
∇3y3
x4
y4
∇y4
∇2y4
∇3y4
∇4y4
Table 3.1

107
3.2 Polynomial Interpolation
Thediagonalterms(y0,∇y1,∇2y2,∇3y3 and∇4y4)inthetablearethecoefﬁcientsof
the polynomial. If the data points are listed in a different order, the entries in the table
will change, but the resultant polynomial will be the same—recall that a polynomial
of degree n interpolating n+ 1 distinct data points is unique.
Machine computations can be carried out within a one-dimensional array a em-
ploying the following algorithm (we use the notation m= n+ 1 = number of data
points):
a = yData.copy()
for k in range(1,m):
for i in range(k,m):
a[i] = (a[i] - a[k-1])/(xData[i] - xData[k-1])
Initially, a contains the y-coordinates of the data, so that it is identical to the
second column in Table 3.1. Each pass through the outer loop generates the entries in
the next column, which overwrite the corresponding elements of a. Therefore, a ends
up containing the diagonal terms of Table 3.1, i.e., the coefﬁcients of the polynomial.
■newtonPoly
This module contains the two functions required for interpolation by Newton’s
method. Given the data point arrays xData and yData, the function coeffts re-
turns the coefﬁcient array a. After the coefﬁcients are found, the interpolant Pn(x) can
be evaluated at any value of x with the function evalPoly.
## module newtonPoly
’’’ p = evalPoly(a,xData,x).
Evaluates Newton’s polynomial p at x. The coefficient
vector {a}
can be computed by the function ’coeffts’.
a = coeffts(xData,yData).
Computes the coefficients of Newton’s polynomial.
’’’
def evalPoly(a,xData,x):
n = len(xData) - 1
# Degree of polynomial
p = a[n]
for k in range(1,n+1):
p = a[n-k] + (x -xData[n-k])*p
return p
def coeffts(xData,yData):
m = len(xData)
# Number of data points

108
Interpolation and Curve Fitting
a = yData.copy()
for k in range(1,m):
a[k:m] = (a[k:m] - a[k-1])/(xData[k:m] - xData[k-1])
return a
Neville’s Method
Newton’s method of interpolation involves two steps: computation of the coefﬁcients,
followedbyevaluationofthepolynomial.Thisworkswelliftheinterpolationiscarried
out repeatedly at different values of x using the same polynomial. If only one point
is to interpolated, a method that computes the interpolant in a single step, such as
Neville’s algorithm, is a better choice.
Let Pk[xi, xi+1, . . . , xi+k] denote the polynomial of degree kthat passes through the
k + 1 data points (xi, yi), (xi+1, yi+1), . . . , (xi+k, yi+k). For a single data point, we have
P0[xi] = yi
(3.7)
The interpolant based on two data points is
P1[xi, xi+1] = (x −xi+1)P0[xi] + (xi −x)P0[xi+1]
xi −xi+1
It is easily veriﬁed that P1[xi, xi+1] passes through the two data points; that is,
P1[xi, xi+1] = yi when x = xi, and P1[xi, xi+1] = yi+1 when x = xi+1.
The three-point interpolant is
P2[xi, xi+1, xi+2] = (x −xi+2)P1[xi, xi+1] + (xi −x)P1[xi+1, xi+2]
xi −xi+2
To show that this interpolant does intersect the data points, we ﬁrst substitute x = xi,
obtaining
P2[xi, xi+1, xi+2] = P1[xi, xi+1] = yi
Similarly, x = xi+2 yields
P2[xi, xi+1, xi+2] = P1[xi+1, xi+2] = yi+2
Finally, when x = xi+1 we have
P1[xi, xi+1] = P1[xi+1, xi+2] = yi+1
so that
P2[xi, xi+1, xi+2] = (xi+1 −xi+2)yi+1 + (xi −xi+1)yi+1
xi −xi+2
= yi+1

109
3.2 Polynomial Interpolation
Havingestablishedthepattern,wecannowdeducethegeneralrecursiveformula:
Pk[xi, xi+1, . . . , xi+k]
= (x −xi+k)Pk−1[xi,xi+1, . . . , xi+k−1] + (xi −x)Pk−1[xi+1,xi+2, . . . , xi+k]
xi −xi+k
(3.8)
Given the value of x, the computations can be carried out in the following tabular
format (shown for four data points):
k = 0
k = 1
k = 2
k = 3
x0
P0[x0] = y0
P1[x0, x1]
P2[x0, x1, x2]
P3[x0, x1, x2, x3]
x1
P0[x1] = y1
P1[x1, x2]
P2[x1,x2, x3]
x2
P0[x2] = y2
P1[x2, x3]
x3
P0[x3] = y3
Table 3.2
If the number of data points is m, the algorithm that computes the elements of
the table is
y = yData.copy()
for k in range (1,m):
for i in range(m-k):
y[i] = ((x - xData[i+k])*y[i] + (xData[i] - x)*y[i+1])/ \
(xData[i] - xData[i+k])
This algorithm works with the one-dimensional array y, which initially contains
the y-values of the data (the second column in Table 3.2). Each pass through the outer
loop computes the elements of y in the next column, which overwrite the previous
entries. At the end of the procedure, y contains the diagonal terms of the table. The
value of the interpolant (evaluated at x) that passes through all the data points is the
ﬁrst element of y.
■neville
The following function implements Neville’s method; it returns Pn(x)
## module neville
’’’ p = neville(xData,yData,x).
Evaluates the polynomial interpolant p(x) that passes
trough the specified data points by Neville’s method.
’’’

110
Interpolation and Curve Fitting
def neville(xData,yData,x):
m = len(xData)
# number of data points
y = yData.copy()
for k in range(1,m):
y[0:m-k] = ((x - xData[k:m])*y[0:m-k] +
\
(xData[0:m-k] - x)*y[1:m-k+1])/
\
(xData[0:m-k] - xData[k:m])
return y[0]
Limitations of Polynomial Interpolation
Polynomial interpolation should be carried out with the fewest feasible number of
data points. Linear interpolation, using the nearest two points, is often sufﬁcient
if the data points are closely spaced. Three to six nearest-neighbor points produce
good results in most cases. An interpolant intersecting more than six points must be
viewed with suspicion. The reason is that the data points that are far from the point
of interest do not contribute to the accuracy of the interpolant. In fact, they can be
detrimental.
The danger of using too many points is illustrated in Fig. 3.3. There are 11 equally
spaced data points represented by the circles. The solid line is the interpolant, a poly-
nomial of degree ten, that intersects all the points. As seen in the ﬁgure, a polynomial
of such a high degree has a tendency to oscillate excessively between the data points.
A much smoother result would be obtained by using a cubic interpolant spanning
four nearest-neighbor points.
x
-6.0
-4.0
-2.0
0.0
2.0
4.0
6.0
y
-0.20
0.00
0.20
0.40
0.60
0.80
1.00
Figure 3.3. Polynomial interpolant displaying oscillations.
Polynomial extrapolation (interpolating outside the range of data points) is dan-
gerous. As an example, consider Fig. 3.4. There are six data points, shown as circles.

111
3.2 Polynomial Interpolation
The ﬁfth-degree interpolating polynomial is represented by the solid line. The inter-
polant looks ﬁne within the range of data points, but drastically departs from the
obvious trend when x > 12. Extrapolating y at x = 14, for example, would be absurd
in this case.
x
2.0
4.0
6.0
8.0
10.0
12.0
14.0
16.0
y
-100
0
100
200
300
400
Figure 3.4. Extrapolation may not follow the trend of data.
If extrapolation cannot be avoided, the following two measures can be useful:
r Plot the data and visually verify that the extrapolated value makes sense.
r Use a low-order polynomial based on nearest-neighbor data points. A linear or
quadratic interpolant, for example, would yield a reasonable estimate of y(14) for
the data in Fig. 3.4.
r Work with a plot of log x vs. log y, which is usually much smoother than the x–y
curve, and thus safer to extrapolate. Frequently this plot is almost a straight line.
This is illustrated in Fig. 3.5, which represents the logarithmic plot of the data in
Fig. 3.4.
x
1
10
y
10
100
Figure 3.5. Logarithmic plot of the data in Fig. 3.4.

112
Interpolation and Curve Fitting
EXAMPLE 3.1
Given the data points
x
0
2
3
y
7
11
28
use Lagrange’s method to determine y at x = 1.
Solution
ℓ0 =
(x −x1)(x −x2)
(x0 −x1)(x0 −x2) = (1 −2)(1 −3)
(0 −2)(0 −3) = 1
3
ℓ1 =
(x −x0)(x −x2)
(x1 −x0)(x1 −x2) = (1 −0)(1 −3)
(2 −0)(2 −3) = 1
ℓ2 =
(x −x0)(x −x1)
(x2 −x0)(x2 −x1) = (1 −0)(1 −2)
(3 −0)(3 −2) = −1
3
y = y0ℓ0 + y1ℓ1 + y2ℓ2 = 7
3 + 11 −28
3 = 4
EXAMPLE 3.2
The data points
x
−2
1
4
−1
3
−4
y
−1
2
59
4
24
−53
lie on a polynomial. Determine the degree of this polynomial by constructing the
divided difference table, similar to Table 3.1.
Solution
i
xi
yi
∇yi
∇2yi
∇3yi
∇4yi
∇5yi
0
−2
−1
1
1
2
1
2
4
59
10
3
3
−1
4
5
−2
1
4
3
24
5
2
1
0
5
−4
−53
26
−5
1
0
0
Here are a few sample calculations used in arriving at the ﬁgures in the table:
∇y2 = y2 −y0
x2 −x0
= 59 −(−1)
4 −(−2) = 10
∇2y2 = ∇y2 −∇y1
x2 −x1
= 10 −1
4 −1 = 3
∇3y5 = ∇2y5 −∇2y2
x5 −x2
= −5 −3
−4 −4 = 1

113
3.2 Polynomial Interpolation
From the table we see that the last nonzero coefﬁcient (last nonzero diagonal term)
of Newton’s polynomial is ∇3y3, which is the coefﬁcient of the cubic term. Hence the
polynomial is a cubic.
EXAMPLE 3.3
Given the data points
x
4.0
3.9
3.8
3.7
y
−0.06604
−0.02724
0.01282
0.05383
determine the root of y(x) = 0 by Neville’s method.
Solution This is an example of inverse interpolation, where the roles of x and y are
interchanged. Instead of computing y at a given x, we are ﬁnding x that corresponds
to a given y (in this case, y = 0). Employing the format of Table 3.2 (with x and y
interchanged, of course), we obtain
i
yi
P0[ ] = xi
P1[ , ]
P2[ , , ]
P3[ , , , ]
0
−0.06604
4.0
3.8298
3.8316
3.8317
1
−0.02724
3.9
3.8320
3.8318
2
0.01282
3.8
3.8313
3
0.05383
3.7
The following are sample computations used in the table:
P1[y0, y1] = (y −y1)P0[y0] + (y0 −y)P0[y1]
y0 −y1
= (0 + 0.02724)(4.0) + (−0.06604 −0)(3.9)
−0.06604 + 0.02724
= 3.8298
P2[y1, y2, y3] = (y −y3)P1[y1, y2] + (y1 −y)P1[y2, y3]
y1 −y3
= (0 −0.05383)(3.8320) + (−0.02724 −0)(3.8313)
−0.02724 −0.05383
= 3.8318
All the P’s in the table are estimates of the root resulting from different orders
of interpolation involving different data points. For example, P1[y0, y1] is the root
obtained from linear interpolation based on the ﬁrst two points, and P2[y1, y2, y3] is
the result from quadratic interpolation using the last three points. The root obtained
from cubic interpolation over all four data points is x = P3[y0, y1, y2, y3] = 3.8317.

114
Interpolation and Curve Fitting
EXAMPLE 3.4
The data points in the table lie on the plot of f (x) = 4.8 cos πx
20. Interpolate this data by
Newton’s method at x = 0, 0.5, 1.0, . . . , 8.0 and compare the results with the “exact”
values yi = f (xi).
x
0.15
2.30
3.15
4.85
6.25
7.95
y
4.79867
4.49013
4.2243
3.47313
2.66674
1.51909
Solution
#!/usr/bin/python
## example3_4
from numarray import array,arange
from math import pi,cos
from newtonPoly import *
xData = array([0.15,2.3,3.15,4.85,6.25,7.95])
yData = array([4.79867,4.49013,4.2243,3.47313,2.66674,1.51909])
a = coeffts(xData,yData)
print ’’ x
yInterp
yExact’’
print ’’-----------------------’’
for x in arange(0.0,8.1,0.5):
y = evalPoly(a,xData,x)
yExact = 4.8*cos(pi*x/20.0)
print ’’%3.1f %9.5f %9.5f’’% (x,y,yExact)
raw_input(’’\nPress return to exit’’)
The results are:
x
yInterp
yExact
-----------------------
0.0
4.80003
4.80000
0.5
4.78518
4.78520
1.0
4.74088
4.74090
1.5
4.66736
4.66738
2.0
4.56507
4.56507
2.5
4.43462
4.43462
3.0
4.27683
4.27683
3.5
4.09267
4.09267
4.0
3.88327
3.88328

115
3.3 Interpolation with Cubic Spline
4.5
3.64994
3.64995
5.0
3.39411
3.39411
5.5
3.11735
3.11735
6.0
2.82137
2.82137
6.5
2.50799
2.50799
7.0
2.17915
2.17915
7.5
1.83687
1.83688
8.0
1.48329
1.48328
3.3
Interpolation with Cubic Spline
If there are more than a few data points, a cubic spline is hard to beat as a global
interpolant. It is considerably “stiffer” than a polynomial in the sense that it has less
tendency to oscillate between data points.
Elastic strip
Pins (data points)
x
y
Figure 3.6. Mechanical model of natural cubic spline.
The mechanical model of a cubic spline is shown in Fig. 3.6. It is a thin, elastic
beam that is attached with pins to the data points. Because the beam is unloaded
between the pins, each segment of the spline curve is a cubic polynomial—recall from
beam theory that d4y/dx4 = q/(E I), so that y(x) is a cubic since q = 0. At the pins, the
slope and bending moment (and hence the second derivative) are continuous. There
is no bending moment at the two end pins; consequently, the second derivative of
the spline is zero at the end points. Since these end conditions occur naturally in the
beam model, the resulting curve is known as the natural cubic spline. The pins, i.e.,
the data points, are called the knots of the spline.
x
y
0
1
i
n
i - 1
i + 1
n- 1
x
x
x
0
1
i
i + 1
x
x
xi - 1
n
n- 1
y
y
y
y
y
y
i, i+ 1
f
(x)
x
y
Figure 3.7. Cubic spline.
Figure 3.7 shows a cubic spline that spans n+ 1 knots. We use the notation
fi,i+1(x) for the cubic polynomial that spans the segment between knots i and i + 1.

116
Interpolation and Curve Fitting
Note that the spline is a piecewise cubic curve, put together from the n cubics
f0,1(x), f1,2(x), . . . , fn−1,n(x), all of which have different coefﬁcients.
Ifwedenotethesecondderivativeofthesplineatknoti byki,continuityofsecond
derivatives requires that
f ′′
i−1,i(xi) = f ′′
i,i+1(xi) = ki
(a)
At this stage, each k is unknown, except for
k0 = kn = 0
(3.9)
The starting point for computing the coefﬁcients of fi,i+1(x) is the expression for
f ′′
i,i+1(x), which we know to be linear. Using Lagrange’s two-point interpolation, we
can write
f ′′
i,i+1(x) = kiℓi(x) + ki+1ℓi+1(x)
where
ℓi(x) = x −xi+1
xi −xi+1
ℓ1+1(x) =
x −xi
xi+1 −xi
Therefore,
f ′′
i,i+1(x) = ki(x −xi+1) −ki+1(x −xi)
xi −xi+1
(b)
Integrating twice with respect to x, we obtain
fi,i+1(x) = ki(x −xi+1)3 −ki+1(x −xi)3
6(xi −xi+1)
+ A(x −xi+1) −B(x −xi)
(c)
where A and B are constants of integration. The terms arising from the integration
would usually be written as Cx + D. By letting C = A −B and D = −Axi+1 + Bxi, we
end up with the last two terms of Eq. (c), which are more convenient to use in the
computations that follow.
Imposing the condition fi,i+1(xi) = yi, we get from Eq. (c)
ki(xi −xi+1)3
6(xi −xi+1) + A(xi −xi+1) = yi
Therefore,
A =
yi
xi −xi+1
−ki
6 (xi −xi+1)
(d)
Similarly, fi,i+1(xi+1) = yi+1 yields
B =
yi+1
xi −xi+1
−ki+1
6 (xi −xi+1)
(e)

117
3.3 Interpolation with Cubic Spline
Substituting Eqs. (d) and (e) into Eq. (c) results in
fi,i+1(x) = ki
6
$(x −xi+1)3
xi −xi+1
−(x −xi+1)(xi −xi+1)
%
−ki+1
6
$(x −xi)3
xi −xi+1
−(x −xi)(xi −xi+1)
%
(3.10)
+ yi(x −xi+1) −yi+1(x −xi)
xi −xi+1
The second derivatives ki of the spline at the interior knots are obtained from
the slope continuity conditions f ′
i−1,i(xi) = f ′
i,i+1(xi), where i = 1, 2, . . . , n−1. After a
little algebra, this results in the simultaneous equations
ki−1(xi−1 −xi) + 2ki(xi−1 −xi+1) + ki+1(xi −xi+1)
= 6
& yi−1 −yi
xi−1 −xi
−yi −yi+1
xi −xi+1
'
,
i = 1, 2, · · · , n−1
(3.11)
Because Eqs. (3.11) have a tridiagonal coefﬁcient matrix, they can be solved econom-
ically with the functions in module LUdecomp3 described in Section 2.4.
If the data points are evenly spaced at intervals h, then xi−1 −xi = xi −xi+1 = −h,
and the Eqs. (3.11) simplify to
ki−1 + 4ki + ki+1 = 6
h2 (yi−1 −2yi + yi+1),
i = 1, 2, . . . , n−1
(3.12)
■cubicSpline
The ﬁrst stage of cubic spline interpolation is to set up Eqs. (3.11) and solve them
for the unknown k’s (recall that k0 = kn = 0). This task is carried out by the func-
tion curvatures. The second stage is the computation of the interpolant at x from
Eq. (3.10). This step can be repeated any number of times with different values
of x using the function evalSpline. The function findSegment embedded in
evalSpline ﬁnds the segment of the spline that contains x using the method of
bisection. It returns the segment number; that is, the value of the subscript i in
Eq. (3.10).
## module cubicSpline
’’’ k = curvatures(xData,yData).
Returns the curvatures {k}of cubic spline at the knots.
y = evalSpline(xData,yData,k,x).
Evaluates cubic spline at x. The curvatures {k}
can be

118
Interpolation and Curve Fitting
computed with the function ’curvatures’.
’’’
from numarray import zeros,ones,Float64,array
from LUdecomp3 import *
def curvatures(xData,yData):
n = len(xData) - 1
c = zeros((n),type=Float64)
d = ones((n+1),type=Float64)
e = zeros((n),type=Float64)
k = zeros((n+1),type=Float64)
c[0:n-1] = xData[0:n-1] - xData[1:n]
d[1:n] = 2.0*(xData[0:n-1] - xData[2:n+1])
e[1:n] = xData[1:n] - xData[2:n+1]
k[1:n] =6.0*(yData[0:n-1] - yData[1:n]) \
/(xData[0:n-1] - xData[1:n]) \
-6.0*(yData[1:n] - yData[2:n+1])
\
/(xData[1:n] - xData[2:n+1])
LUdecomp3(c,d,e)
LUsolve3(c,d,e,k)
return k
def evalSpline(xData,yData,k,x):
def findSegment(xData,x):
iLeft = 0
iRight = len(xData)- 1
while 1:
if (iRight-iLeft) <= 1: return iLeft
i =(iLeft + iRight)/2
if x < xData[i]: iRight = i
else: iLeft = i
i = findSegment(xData,x)
# Find the segment spanning x
h = xData[i] - xData[i+1]
y = ((x - xData[i+1])**3/h - (x - xData[i+1])*h)*k[i]/6.0 \
- ((x - xData[i])**3/h - (x - xData[i])*h)*k[i+1]/6.0
\
+ (yData[i]*(x - xData[i+1])
\
- yData[i+1]*(x - xData[i]))/h
return y

119
3.3 Interpolation with Cubic Spline
EXAMPLE 3.5
Use natural cubic spline to determine y at x = 1.5. The data points are
x
1
2
3
4
5
y
0
1
0
1
0
Solution The ﬁve knots are equally spaced at h = 1. Recalling that the second deriva-
tive of a natural spline is zero at the ﬁrst and last knot, we have k0 = k4 = 0. The second
derivatives at the other knots are obtained from Eq. (3.12). Using i = 1, 2, 3 results in
the simultaneous equations
0 + 4k1 + k2 = 6 [0 −2(1) + 0] = −12
k1 + 4k2 + k3 = 6 [1 −2(0) + 1] = 12
k2 + 4k3 + 0 = 6 [0 −2(1) + 0] = −12
The solution is k1 = k3 = −30/7, k2 = 36/7.
The point x = 1.5 lies in the segment between knots 0 and 1. The corresponding
interpolant is obtained from Eq. (3.10) by setting i = 0. With xi −xi+1 = −h = −1, we
obtain from Eq. (3.10)
f0,1(x) = −k0
6

(x −x1)3 −(x −x1)

+ k1
6

(x −x0)3 −(x −x0)

−[y0(x −x1) −y1(x −x0)]
Therefore,
y(1.5) = f0,1(1.5)
= 0 + 1
6
&
−30
7
' 
(1.5 −1)3 −(1.5 −1)

−[0 −1(1.5 −1)]
= 0.7679
The plot of the interpolant, which in this case is made up of four cubic segments, is
shown in the ﬁgure.
x
1.00
1.50
2.00
2.50
3.00
3.50
4.00
4.50
5.00
y
0.00
0.20
0.40
0.60
0.80
1.00

120
Interpolation and Curve Fitting
EXAMPLE 3.6
Sometimes it is preferable to replace one or both of the end conditions of the cu-
bic spline with something other than the natural conditions. Use the end condition
f ′
0,1(0) = 0(zeroslope),ratherthan f ′′
0,1(0) = 0(zerocurvature),todeterminethecubic
spline interpolant at x = 2.6, given the data points
x
0
1
2
3
y
1
1
0.5
0
Solution WemustﬁrstmodifyEqs.(3.12)toaccountforthenewendcondition.Setting
i = 0 in Eq. (3.10) and differentiating, we get
f ′
0,1(x) = k0
6
$
3(x −x1)2
x0 −x1
−(x0 −x1)
%
−k1
6
$
3(x −x0)2
x0 −x1
−(x0 −x1)
%
+ y0 −y1
x0 −x1
Thus the end condition f ′
0,1(x0) = 0 yields
k0
3 (x0 −x1) + k1
6 (x0 −x1) + y0 −y1
x0 −x1
= 0
or
2k0 + k1 = −6 y0 −y1
(x0 −x1)2
From the given data we see that y0 = y1 = 1, so that the last equation becomes
2k0 + k1 = 0
(a)
The other equations in Eq. (3.12) are unchanged. Knowing that k3 = 0, we have
k0 + 4k1 + k2 = 6 [1 −2(1) + 0.5] = −3
(b)
k1 + 4k2 = 6 [1 −2(0.5) + 0] = 0
(c)
The solution of Eqs. (a)–(c) is k0 = 0.4615, k1 = −0.9231, k2 = 0.2308.
The interpolant can now be evaluated from Eq. (3.10). Substituting i = 2 and
xi −xi+1 = −1, we obtain
f2,3(x) = k2
6

−(x −x3)3 + (x −x3)

−k3
6

−(x −x2)3 + (x −x2)

−y2(x −x3) + y3(x −x2)
Therefore,
y(2.6) = f2,3(2.6) = 0.2308
6

−(−0.4)3 + (−0.4)

−0 −0.5(−0.4) + 0
= 0.1871

121
3.3 Interpolation with Cubic Spline
EXAMPLE 3.7
Utilize the module cubicSpline to write a program that interpolates between given
data points with natural cubic spline. The program must be able to evaluate the
interpolantformorethanonevalueof x.Asatest,usedatapointsspeciﬁedinExample
3.4 and compute the interpolant at x = 1.5 and x = 4.5 (due to symmetry, these values
should be equal).
Solution
#!/usr/bin/python
## example3_7
from numarray import array,Float64
from cubicSpline import *
xData = array([1,2,3,4,5],type=Float64)
yData = array([0,1,0,1,0],type=Float64)
k = curvatures(xData,yData)
while 1:
try: x = eval(raw_input(’’\nx ==> ’’))
except SyntaxError: break
print ’’y =’’,evalSpline(xData,yData,k,x)
raw_input(’’Done. Press return to exit’’)
Running the program produces the following result:
x ==> 1.5
y = 0.767857142857
x ==> 4.5
y = 0.767857142857
x ==>
Done. Press return to exit
PROBLEM SET 3.1
1. Given the data points
x
−1.2
0.3
1.1
y
−5.76
−5.61
−3.69
determine y at x = 0 using (a) Neville’s method; and (b) Lagrange’s method.

122
Interpolation and Curve Fitting
2. Find the zero of y(x) from the following data:
x
0
0.5
1
1.5
2
2.5
3
y
1.8421
2.4694
2.4921
1.9047
0.8509
−0.4112
−1.5727
Use Lagrange’s interpolation over (a) three; and (b) four nearest-neighbor data
points. Hint: after ﬁnishing part (a), part (b) can be computed with a relatively
small effort.
3. The function y(x) represented by the data in Prob. 2 has a maximum at x = 0.7679.
Compute this maximum by Neville’s interpolation over four nearest-neighbor
data points.
4. Use Neville’s method to compute y at x = π/4 from the data points
x
0
0.5
1
1.5
2
y
−1.00
1.75
4.00
5.75
7.00
5. Given the data
x
0
0.5
1
1.5
2
y
−0.7854
0.6529
1.7390
2.2071
1.9425
ﬁnd y at x = π/4 and at π/2. Use the method that you consider to be most
convenient.
6. The points
x
−2
1
4
−1
3
−4
y
−1
2
59
4
24
−53
lie on a polynomial. Use the divided difference table of Newton’s method to de-
termine the degree of the polynomial.
7. Use Newton’s method to ﬁnd the polynomial that ﬁts the following points:
x
−3
2
−1
3
1
y
0
5
−4
12
0
8. Use Neville’s method to determine the equation of the quadratic that passes
through the points
x
−1
1
3
y
17
−7
−15

123
3.3 Interpolation with Cubic Spline
9. The density of air ρ varies with elevation h in the following manner:
h (km)
0
3
6
ρ (kg/m3)
1.225
0.905
0.652
Express ρ(h) as a quadratic function using Lagrange’s method.
10. Determine the natural cubic spline that passes through the data points
x
0
1
2
y
0
2
1
Note that the interpolant consists of two cubics, one valid in 0 ≤x ≤1, the other
in 1 ≤x ≤2. Verify that these cubics have the same ﬁrst and second derivatives
at x = 1.
11. Given the data points
x
1
2
3
4
5
y
13
15
12
9
13
determine the natural cubic spline interpolant at x = 3.4.
12. Compute the zero of the function y(x) from the following data:
x
0.2
0.4
0.6
0.8
1.0
y
1.150
0.855
0.377
−0.266
−1.049
Use inverse interpolation with the natural cubic spline. Hint: reorder the data so
that the values of y are in ascending order.
13. Solve Example 3.6 with a cubic spline that has constant second derivatives within
its ﬁrst and last segments (the end segments are parabolic). The end conditions
for this spline are k0 = k1 and kn−1 = kn.
14. ■Write a computer program for interpolation by Neville’s method. The program
must be able to compute the interpolant at several user-speciﬁed values of x.
Test the program by determining y at x = 1.1, 1.2 and 1.3 from the following
data:
x
−2.0
−0.1
−1.5
0.5
y
2.2796
1.0025
1.6467
1.0635
x
−0.6
2.2
1.0
1.8
y
1.0920
2.6291
1.2661
1.9896
(Answer: y = 1.3262, 1.3938, 1.4693)

124
Interpolation and Curve Fitting
15. ■The speciﬁc heat cp of aluminum depends on temperature T as follows:6
T (◦C)
−250
−200
−100
0
100
300
cp (kJ/kg·K)
0.0163
0.318
0.699
0.870
0.941
1.04
Determine cp at T = 200◦C and 400◦C.
16. ■Find y at x = 0.46 from the data
x
0
0.0204
0.1055
0.241
0.582
0.712
0.981
y
0.385
1.04
1.79
2.63
4.39
4.99
5.27
17. ■The table shows the drag coefﬁcient cD of a sphere as a function of Reynolds
number Re.7 Use natural cubic spline to ﬁnd cD at Re = 5, 50, 500 and 5000. Hint:
use log–log scale.
Re
0.2
2
20
200
2000
20 000
cD
103
13.9
2.72
0.800
0.401
0.433
18. ■Solve Prob. 17 using a polynomial interpolant intersecting four nearest-
neighbor data points.
19. ■The kinematic viscosity µk of water varies with temperature T in the following
manner:
T (◦C)
0
21.1
37.8
54.4
71.1
87.8
100
µk (10−3 m2/s)
1.79
1.13
0.696
0.519
0.338
0.321
0.296
Interpolate µk at T = 10◦, 30◦, 60◦and 90◦C.
20. ■Thetableshowshowtherelativedensityρ ofairvarieswithaltitudeh.Determine
the relative density of air at 10.5 km.
h (km)
0
1.525
3.050
4.575
6.10
7.625
9.150
ρ
1
0.8617
0.7385
0.6292
0.5328
0.4481
0.3741
3.4
Least-Squares Fit
Overview
If the data are obtained from experiments, they typically contain a signiﬁcant amount
of random noise due to measurement errors. The task of curve ﬁtting is to ﬁnd a
6 Source: Black, Z. B., and Hartley, J. G., Thermodynamics, Harper & Row, 1985.
7 Source: Kreith, F., Principles of Heat Transfer, Harper & Row, 1973.

125
3.4 Least-Squares Fit
smooth curve that ﬁts the data points “on the average.” This curve should have a
simple form (e.g., a low-order polynomial), so as to not reproduce the noise.
Let
f (x) = f (x; a0, a1, . . . , am)
be the function that is to be ﬁtted to the n+ 1 data points (xi, yi), i = 0, 1, . . . , n. The
notation implies that we have a function of x that contains m+ 1 variable parameters
a0, a1, . . . , am, where m< n. The form of f (x) is determined beforehand, usually from
the theory associated with the experiment from which the data is obtained. The only
means of adjusting the ﬁt is the parameters. For example, if the data represent the
displacements yi of an overdamped mass–spring system at time ti, the theory suggests
the choice f (t) = a0te−a1t. Thus curve ﬁtting consists of two steps: choosing the form
of f (x), followed by computation of the parameters that produce the best ﬁt to the
data.
This brings us to the question: what is meant by “best” ﬁt? If the noise is conﬁned
to the y-coordinate, the most commonly used measure is the least-squares ﬁt, which
minimizes the function
S(a0, a1, . . . , am) =
n

i=0
[yi −f (xi)]2
(3.13)
with respect to each aj. Therefore, the optimal values of the parameters are given by
the solution of the equations
∂S
∂ak
= 0,
k = 0, 1, . . . , m
(3.14)
The terms ri = yi −f (xi) in Eq. (3.13) are called residuals; they represent the discrep-
ancy between the data points and the ﬁtting function at xi. The function S to be
minimized is thus the sum of the squares of the residuals. Equations (3.14) are gen-
erally nonlinear in aj and may thus be difﬁcult to solve. Often the ﬁtting function is
chosen as a linear combination of speciﬁed functions f j(x):
f (x) = a0 f0(x) + a1 f1(x) + · · · + am fm(x)
in which case Eqs. (3.14) are linear. If the ﬁtting function is a polynomial, we have
f0(x) = 1, f1(x) = x, f2(x) = x2, etc.
The spread of the data about the ﬁtting curve is quantiﬁed by the standard devi-
ation, deﬁned as
σ =
(
S
n−m
(3.15)
Note that if n = m, we have interpolation, not curve ﬁtting. In that case both the
numerator and the denominator in Eq. (3.15) are zero, so that σ is indeterminate.

126
Interpolation and Curve Fitting
Fitting a Straight Line
Fitting a straight line
f (x) = a + bx
(3.16)
to data is also known as linear regression. In this case the function to be minimized is
S(a, b) =
n

i=0
[yi −f (xi)]2 =
n

i=0
(yi −a −bxi)2
Equations (3.14) now become
∂S
∂a =
n

i=0
−2(yi −a −bxi) = 2
)
a (n+ 1) + b
n

i=0
xi −
n

i=0
yi
*
= 0
∂S
∂b =
n

i=0
−2(yi −a −bxi)xi = 2

a
n

i=0
xi + b
n

i=0
x2
i −
n

i=0
xi yi

= 0
Dividing both equations by 2 (n+ 1) and rearranging terms, we get
a +¯xb = ¯y
¯xa +

1
n+ 1
n

i=0
x2
i

b =
1
n+ 1
n

i=0
xi yi
where
¯x =
1
n+ 1
n

i=0
xi
¯y =
1
n+ 1
n

i=0
yi
(3.17)
are the mean values of the x and y data. The solution for the parameters is
a = ¯y  x2
i −¯x  xi yi
 x2
i −(n+ 1)¯x2
b =
 xi yi −¯x  yi
 x2
i −(n+ 1)¯x2
(3.18)
Theseexpressionsaresusceptibletoroundofferrors(thetwotermsineachnumerator
as well as in each denominator can be roughly equal). It is better to compute the
parameters from
b =
 yi(xi −¯x)
 xi(xi −¯x)
a = ¯y −¯xb
(3.19)
which are equivalent to Eqs. (3.18), but much less affected by rounding off.
Fitting Linear Forms
Consider the least-squares ﬁt of the linear form
f (x) = a0 f0(x) + a1 f1(x) + · · · + am fm(x) =
m

j=0
aj f j(x)
(3.20)

127
3.4 Least-Squares Fit
where each f j(x) is a predetermined function of x, called a basis function. Substitution
in Eq. (3.13) yields
S =
n

i=0
)
yi −
m

j=0
aj f j(xi)
*2
Thus Eqs. (3.14) are
∂S
∂ak
= −2
" n

i=0
)
yi −
m

j=0
aj f j(xi)
*
fk(xi)
#
= 0,
k = 0, 1, . . . , m
Dropping the constant (−2) and interchanging the order of summation, we get
m

j=0
) n

i=0
f j(xi) fk(xi)
*
aj =
n

i=0
fk(xi)yi,
k = 0, 1, . . . , m
In matrix notation these equations are
Aa = b
(3.21a)
where
Akj =
n

i=0
f j(xi) fk(xi)
bk =
n

i=0
fk(xi)yi
(3.21b)
Equations (3.21a), known as the normal equations of the least-squares ﬁt, can be
solved with the methods discussed in Chapter 2. Note that the coefﬁcient matrix is
symmetric, i.e., Akj = A jk.
Polynomial Fit
A commonly used linear form is a polynomial. If the degree of the polynomial is m,
we have f (x) = m
j=0 ajx j. Here the basis functions are
f j(x) = x j
( j = 0, 1, . . . , m)
(3.22)
so that Eqs. (3.21b) become
Akj =
n

i=0
x j+k
i
bk =
n

i=0
xk
i yi
or
A =


n
 xi
 x2
i
. . .
 xm
i
 xi
 x2
i
 x3
i
. . .
 xm+1
i
...
...
...
...
...
 xm−1
i
 xm
i
 xm+1
i
. . .
 x2m
i


b =


 yi
 xi yi
... xm
i yi


(3.23)

128
Interpolation and Curve Fitting
wherestandsforn
i=0.Thenormalequationsbecomeprogressivelyill-conditioned
with increasing m. Fortunately, this is of little practical consequence, because only
low-order polynomials are useful in curve ﬁtting. Polynomials of high order are
not recommended, because they tend to reproduce the noise inherent in the
data.
■polyFit
The function polyFit in this module sets up and solves the normal equations for
the coefﬁcients of a polynomial of degree m. It returns the coefﬁcients of the poly-
nomial. To facilitate computations, the terms n,  xi,  x2
i , . . . ,  x2m
i
that make up
the coefﬁcient matrix in Eq. (3.23) are ﬁrst stored in the vector s and then inserted
into A. The normal equations are then solved by Gauss elimination with pivoting.
Following the solution, the standard deviation σ can be computed with the func-
tion stdDev. The polynomial evaluation in stdDev is carried out by the embedded
function evalPoly—see Section 4.7 for an explanation of the algorithm.
## module polyFit
’’’ c = polyFit(xData,yData,m).
Returns coefficients of the polynomial
p(x) = c[0] + c[1]x + c[2]xˆ2 +...+ c[m]xˆm
that fits the specified data in the least
squares sense.
sigma = stdDev(c,xData,yData).
Computes the std. deviation between p(x)
and the data.
’’’
from numarray import zeros,Float64
from math import sqrt
from gaussPivot import *
def polyFit(xData,yData,m):
a = zeros((m+1,m+1),type=Float64)
b = zeros((m+1),type=Float64)
s = zeros((2*m+1),type=Float64)
for i in range(len(xData)):
temp = yData[i]
for j in range(m+1):
b[j] = b[j] + temp
temp = temp*xData[i]

129
3.4 Least-Squares Fit
temp = 1.0
for j in range(2*m+1):
s[j] = s[j] + temp
temp = temp*xData[i]
for i in range(m+1):
for j in range(m+1):
a[i,j] = s[i+j]
return gaussPivot(a,b)
def stdDev(c,xData,yData):
def evalPoly(c,x):
m = len(c) - 1
p = c[m]
for j in range(m):
p = p*x + c[m-j-1]
return p
n = len(xData) - 1
m = len(c) - 1
sigma = 0.0
for i in range(n+1):
p = evalPoly(c,xData[i])
sigma = sigma + (yData[i] - p)**2
sigma = sqrt(sigma/(n - m))
return sigma
Weighting of Data
There are occasions when our conﬁdence in the accuracy of data varies from point to
point. For example, the instrument taking the measurements may be more sensitive
in a certain range of data. Sometimes the data represent the results of several exper-
iments, each carried out under different conditions. Under these circumstances we
may want to assign a conﬁdence factor, or weight, to each data point and minimize
the sum of the squares of the weighted residuals ri = Wi [yi −f (xi)], where Wi are the
weights. Hence the function to be minimized is
S(a0, a1, . . . , am) =
n

i=0
W2
i [yi −f (xi)]2
(3.24)
This procedure forces the ﬁtting function f (x) closer to the data points that have
higher weights.

130
Interpolation and Curve Fitting
Weighted linear regression
If the ﬁtting function is the straight line f (x) = a + bx, Eq. (3.24) becomes
S(a, b) =
n

i=0
W2
i (yi −a −bxi)2
(3.25)
The conditions for minimizing S are
∂S
∂a = −2
n

i=0
W2
i (yi −a −bxi) = 0
∂S
∂b = −2
n

i=0
W2
i (yi −a −bxi)xi = 0
or
a
n

i=0
W2
i + b
n

i=0
W2
i xi =
n

i=0
W2
i yi
(3.26a)
a
n

i=0
W2
i xi + b
n

i=0
W2
i x2
i =
n

i=0
W2
i xi yi
(3.26b)
Dividing Eq. (3.26a) by  W2
i and introducing the weighted averages
ˆx =
 W2
i xi
 W2
i
ˆy =
 W2
i yi
 W2
i
(3.27)
we obtain
a = ˆy −b ˆx
(3.28a)
Substituting into Eq. (3.26b) and solving for b yields after some algebra
b =
 W2
i yi(xi −ˆx)
 W2
i xi(xi −ˆx)
(3.28b)
Note that Eqs. (3.28) are quite similar to Eqs. (3.19) for unweighted data.
Fitting exponential functions
A special application of weighted linear regression arises in ﬁtting various exponential
functions to data. Consider as an example the ﬁtting function
f (x) = aebx
Normally, the least-squares ﬁt would lead to equations that are nonlinear in a and b.
But if we ﬁt ln y rather than y, the problem is transformed to linear regression: ﬁt the
function
F(x) = ln f (x) = ln a + bx

131
3.4 Least-Squares Fit
to the data points (xi, ln yi), i = 0, 1, . . . , n. This simpliﬁcation comes at a price: least-
squares ﬁt to the logarithm of the data is not quite the same as the least-squares ﬁt to
the original data. The residuals of the logarithmic ﬁt are
Ri = ln yi −F(xi) = ln yi −

ln a + bxi
 
(3.29a)
whereas the residuals used in ﬁtting the original data are
ri = yi −f (xi) = yi −aebxi
(3.29b)
This discrepancy can be largely eliminated by weighting the logarithmic ﬁt. From
Eq. (3.29b) we obtain ln(ri −yi) = ln(aebxi) = ln a + bxi, so that Eq. (3.29a) can be writ-
ten as
Ri = ln yi −ln(ri −yi) = ln
&
1 −ri
yi
'
If the residuals ri are sufﬁciently small (ri << yi), we can use the approximation
ln(1 −ri/yi) ≈ri/yi, so that
Ri ≈ri/yi
We can now see that by minimizing  R2
i , we have inadvertently introduced the
weights 1/yi. This effect can be negated if we apply the weights Wi = yi when ﬁtting
F(x) to (ln yi, xi). That is, minimizing
S =
n

i=0
y2
i R2
i
(3.30)
is a good approximation to minimizing r2
i .
Other examples that also beneﬁt from the weights Wi = yi are given in Table 3.3.
f (x)
F(x)
Data to be ﬁtted by F(x)
axebx
ln [ f (x)/x] = ln a + bx

xi, ln(yi/xi)

axb
ln f (x) = ln a + bln(x)

ln xi, ln yi
 
Table 3.3
EXAMPLE 3.8
Fit a straight line to the data shown and compute the standard deviation.
x
0.0
1.0
2.0
2.5
3.0
y
2.9
3.7
4.1
4.4
5.0

132
Interpolation and Curve Fitting
Solution The averages of the data are
¯x = 1
5

xi = 0.0 + 1.0 + 2.0 + 2.5 + 3.0
5
= 1.7
¯y = 1
5

yi = 2.9 + 3.7 + 4.1 + 4.4 + 5.0
5
= 4. 02
The intercept a and slope b of the interpolant can now be determined from Eq. (3.19):
b =
 yi(xi −¯x)
 xi(xi −¯x)
= 2.9(−1.7) + 3.7(−0.7) + 4.1(0.3) + 4.4(0.8) + 5.0(1.3)
0.0(−1.7) + 1.0(−0.7) + 2.0(0.3) + 2.5(0.8) + 3.0(1.3)
= 3. 73
5. 8 = 0. 6431
a = ¯y −¯xb = 4.02 −1.7(0.6431) = 2. 927
Therefore, the regression line is f (x) = 2.927 + 0.6431x, which is shown in the ﬁgure
together with the data points.
x
0.00
0.50
1.00
1.50
2.00
2.50
3.00
y
2.50
3.00
3.50
4.00
4.50
5.00
We start the evaluation of the standard deviation by computing the residuals:
x
0.000
1.000
2.000
2.500
3.000
y
2.900
3.700
4.100
4.400
5.000
f (x)
2.927
3.570
4.213
4.535
4.856
y −f (x)
−0.027
0.130
−0.113
−0.135
0.144

133
3.4 Least-Squares Fit
The sum of the squares of the residuals is
S =

[yi −f (xi)]2
= (−0.027)2 + (0.130)2 + (−0.113)2 + (−0.135)2 + (0.144)2 = 0.06936
so that the standard deviation in Eq. (3.15) becomes
σ =
(
S
n−m =
+
0.06936
5 −2
= 0.1520
EXAMPLE 3.9
Determine the parameters a and b so that f (x) = aebx ﬁts the following data in the
least-squares sense.
x
1.2
2.8
4.3
5.4
6.8
7.9
y
7.5
16.1
38.9
67.0
146.6
266.2
Use two different methods: (1) ﬁt ln yi; and (2) ﬁt ln yi with weights Wi = yi. Compute
the standard deviation in each case.
Solution of Part (1) The problem is to ﬁt the function ln(aebx) = ln a + bx to the data
x
1.2
2.8
4.3
5.4
6.8
7.9
z = ln y
2.015
2.779
3.661
4.205
4.988
5.584
We are now dealing with linear regression, where the parameters to be found are
A = ln a and b. Following the steps in Example 3.8, we get (skipping some of the
arithmetic details)
¯x = 1
6

xi = 4. 733
¯z = 1
6

zi = 3. 872
b =
 zi(xi −¯x)
 xi(xi −¯x) = 16.716
31.153 = 0. 5366
A = ¯z −¯xb = 1. 3323
Therefore, a = eA = 3. 790 and the ﬁtting function becomes f (x) = 3.790e0.5366. The
plots of f (x) and the data points are shown in the ﬁgure.

134
Interpolation and Curve Fitting
x
1
2
3
4
5
6
7
8
y
0
50
100
150
200
250
300
Here is the computation of standard deviation:
x
1.20
2.80
4.30
5.40
6.80
7.90
y
7.50
16.10
38.90
67.00
146.60
266.20
f (x)
7.21
17.02
38.07
68.69
145.60
262.72
y −f (x)
0.29
−0.92
0.83
−1.69
1.00
3.48
S =

[yi −f (xi)]2 = 17.59
σ =
(
S
6 −2 = 2.10
As pointed out before, this is an approximate solution of the stated problem, since
we did not ﬁt yi, but ln yi. Judging by the plot, the ﬁt seems to be quite good.
Solution of Part (2) We again ﬁt ln(aebx) = ln a + bx to z = ln y, but this time the
weights Wi = yi are used. From Eqs. (3.27) the weighted averages of the data are (recall
that we ﬁt z = ln y)
ˆx =
 y2
i xi
 y2
i
= 737.5 × 103
98.67 × 103 = 7.474
ˆz =
 y2
i zi
 y2
i
= 528.2 × 103
98.67 × 103 = 5.353
and Eqs. (3.28) yield for the parameters
b =
 y2
i zi(xi −ˆx)
 y2
i xi(xi −ˆx) = 35.39 × 103
65.05 × 103 = 0.5440
ln a = ˆz −b ˆx = 5.353 −0.5440(7.474) = 1. 287

135
3.4 Least-Squares Fit
Therefore,
a = eln a = e1.287 = 3. 622
so that the ﬁtting function is f (x) = 3.622e0.5440x. As expected, this result is somewhat
different from that obtained in Part (1).
The computations of the residuals and the standard deviation are as follows:
x
1.20
2.80
4.30
5.40
6.80
7.90
y
7.50
16.10
38.90
67.00
146.60
266.20
f (x)
6.96
16.61
37.56
68.33
146.33
266.20
y −f (x)
0.54
−0.51
1.34
−1.33
0.267
0.00
S =

[yi −f (xi)]2 = 4.186
σ =
(
S
6 −2 = 1.023
Observe that the residuals and standard deviation are smaller than in Part (1), indi-
cating a better ﬁt, as expected.
It can be shown that ﬁtting yi directly (which involves the solution of a transcen-
dentalequation)resultsin f (x) = 3.614e0.5442x.Thecorrespondingstandarddeviation
is σ = 1.022, which is very close to the result in Part (2).
EXAMPLE 3.10
Write a program that ﬁts a polynomial of arbitrary degree mto the data points shown
below. Use the program to determine m that best ﬁts this data in the least-squares
sense.
x
−0.04
0.93
1.95
2.90
3.83
5.00
y
−8.66
−6.44
−4.36
−3.27
−0.88
0.87
x
5.98
7.05
8.21
9.08
10.09
y
3.31
4.63
6.19
7.40
8.85
Solution The program shown below prompts for m. Execution is terminated by en-
tering an invalid character (e.g., the “return” character).
#!/usr/bin/python
## example3_10

136
Interpolation and Curve Fitting
from numarray import array
from polyFit import *
xData = array([-0.04,0.93,1.95,2.90,3.83,5.0,
\
5.98,7.05,8.21,9.08,10.09])
yData = array([-8.66,-6.44,-4.36,-3.27,-0.88,0.87, \
3.31,4.63,6.19,7.4,8.85])
while 1:
try:
m = eval(raw_input(’’\nDegree of polynomial ==> ’’))
coeff = polyFit(xData,yData,m)
print ’’Coefficients are:\n’’,coeff
print ’’Std. deviation =’’,stdDev(coeff,xData,yData)
except SyntaxError: break
raw_input(’’Finished. Press return to exit’’)
The results are:
Degree of polynomial ==> 1
Coefficients are:
[-7.94533287
1.72860425]
Std. deviation = 0.511278836737
Degree of polynomial ==> 2
Coefficients are:
[-8.57005662
2.15121691 -0.04197119]
Std. deviation = 0.310992072855
Degree of polynomial ==> 3
Coefficients are:
[-8.46603423e+00
1.98104441e+00
2.88447008e-03 -2.98524686e-03]
Std. deviation = 0.319481791568
Degree of polynomial ==> 4
Coefficients are:
[ -8.45673473e+00
1.94596071e+00
2.06138060e-02
-5.82026909e-03
1.41151619e-04]
Std. deviation = 0.344858410479
Degree of polynomial ==>
Finished. Press return to exit

137
3.4 Least-Squares Fit
Because the quadratic f (x) = −8.5700 + 2.1512x −0.041971x2 produces the
smallest standard deviation, it can be considered as the “best” ﬁt to the data. But
be warned—the standard deviation is not a reliable measure of the goodness-of-ﬁt.
It is always a good idea to plot the data points and f (x) before ﬁnal determination
is made. The plot of our data indicates that the quadratic (solid line) is indeed a
reasonable choice for the ﬁtting function.
x
-2.0
0.0
2.0
4.0
6.0
8.0
10.0
12.0
y
-10.0
-5.0
0.0
5.0
10.0
PROBLEM SET 3.2
Instructions
Plot the data points and the ﬁtting function whenever appropriate.
1. Showthatthestraightlineobtainedbyleast-squaresﬁtofunweighteddataalways
passes through the point ( ¯x, ¯y).
2. Use linear regression to ﬁnd the line that ﬁts the data
x
−1.0
−0.5
0
0.5
1.0
y
−1.00
−0.55
0.00
0.45
1.00
and determine the standard deviation.
3. Three tensile tests were carried out on an aluminum bar. In each test the strain
was measured at the same values of stress. The results were
Stress (MPa)
34.5
69.0
103.5
138.0
Strain (Test 1)
0.46
0.95
1.48
1.93
Strain (Test 2)
0.34
1.02
1.51
2.09
Strain (Test 3)
0.73
1.10
1.62
2.12
wheretheunitsofstrainaremm/m.Uselinearregressiontoestimatethemodulus
of elasticity of the bar (modulus of elasticity = stress/strain).
4. Solve Prob. 3 assuming that the third test was performed on an inferior machine,
so that its results carry only half the weight of the other two tests.

138
Interpolation and Curve Fitting
5. ■Fit a straight line to the following data and compute the standard deviation.
x
0
0.5
1
1.5
2
2.5
y
3.076
2.810
2.588
2.297
1.981
1.912
x
3
3.5
4
4.5
5
y
1.653
1.478
1.399
1.018
0.794
6. ■Thetabledisplaysthemass Mandaveragefuelconsumptionφ ofmotorvehicles
manufactured by Ford and Honda in 1999. Fit a straight line φ = a + bM to the
data and compute the standard deviation.
Model
M (kg)
φ (km/liter)
Contour
1310
10.2
Crown Victoria
1810
8.1
Escort
1175
11.9
Expedition
2360
5.5
Explorer
1960
6.8
F-150
2020
6.8
Ranger
1755
7.7
Taurus
1595
8.9
Accord
1470
9.8
CR-V
1430
10.2
Civic
1110
13.2
Passport
1785
7.7
7. ■The relative density ρ of air was measured at various altitudes h. The results
were:
h (km)
0
1.525
3.050
4.575
6.10
7.625
9.150
ρ
1
0.8617
0.7385
0.6292
0.5328
0.4481
0.3741
Use a quadratic least-squares ﬁt to determine the relative air density at h =
10.5 km. (This problem was solved by interpolation in Prob. 20, Problem
Set 3.1.)
8. ■The kinematic viscosity µk of water varies with temperature T as shown in the
table. Determine the cubic that best ﬁts the data, and use it to compute µk at

139
3.4 Least-Squares Fit
T = 10◦, 30◦, 60◦and 90◦C. (This problem was solved in Prob. 19, Problem Set 3.1
by interpolation.)
T (◦C)
0
21.1
37.8
54.4
71.1
87.8
100
µk (10−3 m2/s)
1.79
1.13
0.696
0.519
0.338
0.321
0.296
9. ■Fit a straight line and a quadratic to the data
x
1.0
2.5
3.5
4.0
1.1
1.8
2.2
3.7
y
6.008
15.722
27.130
33.772
5.257
9.549
11.098
28.828
Which is a better ﬁt?
10. ■Thetabledisplaysthermalefﬁcienciesofsomeearlysteamengines.8 Determine
thepolynomialthatprovidesthebestﬁttothedataanduseittopredictthethermal
efﬁciency in the year 2000.
Year
Efﬁciency (%)
Type
1718
0.5
Newcomen
1767
0.8
Smeaton
1774
1.4
Smeaton
1775
2.7
Watt
1792
4.5
Watt
1816
7.5
Woolf compound
1828
12.0
Improved Cornish
1834
17.0
Improved Cornish
1878
17.2
Corliss compound
1906
23.0
Triple expansion
11. Thetableshowsthevariationoftherelativethermalconductivitykofsodiumwith
temperature T. Find the quadratic that ﬁts the data in the least-squares sense.
T (◦C)
79
190
357
524
690
k
1.00
0.932
0.839
0.759
0.693
12. Let f (x) = axb be the least-squares ﬁt of the data (xi, yi), i = 0, 1, . . . , n, and let
F(x) = ln a + bln xbetheleast-squaresﬁtof(ln xi, ln yi)—seeTable3.3.Provethat
8 Source: Singer, C., Holmyard, E. J., Hall, A. R., and Williams, T. H., A History of Technology, Oxford
University Press, 1958.

140
Interpolation and Curve Fitting
Ri ≈ri/yi, where the residuals are ri = yi −f (xi) and Ri = ln yi −F(xi). Assume
that ri << yi.
13. Determine a and b for which f (x) = a sin(πx/2) + bcos(πx/2) ﬁts the following
data in the least-squares sense.
x
−0.5
−0.19
0.02
0.20
0.35
0.50
y
−3.558
−2.874
−1.995
−1.040
−0.068
0.677
14. Determine a and b so that f (x) = axb ﬁts the following data in the least-squares
sense.
x
0.5
1.0
1.5
2.0
2.5
y
0.49
1.60
3.36
6.44
10.16
15. Fit the function f (x) = axebx to the data and compute the standard deviation.
x
0.5
1.0
1.5
2.0
2.5
y
0.541
0.398
0.232
0.106
0.052
16. ■The intensity of radiation of a radioactive substance was measured at half-year
intervals. The results were:
t (years)
0
0.5
1
1.5
2
2.5
γ
1.000
0.994
0.990
0.985
0.979
0.977
t (years)
3
3.5
4
4.5
5
5.5
γ
0.972
0.969
0.967
0.960
0.956
0.952
where γ is the relative intensity of radiation. Knowing that radioactivity decays
exponentially with time: γ (t) = ae−bt, estimate the radioactive half-life of the
substance.
3.5
Other Methods
Somedataarebetterinterpolatedbyrationalfunctionsthanbypolynomials.Arational
function R(x) is the quotient of two polynomials:
R(x) = Pm(x)
Qn(x) = a0 + a1x + a2x2 + · · · amxm
b0 + b1x + b2x2 + · · · bnxn

141
3.5 Other Methods
Since R(x)isaratio,itscoefﬁcientscanbescaledsothatoneofthecoefﬁcients(usually
b0) is unity. That leaves m+ n+ 1 undetermined coefﬁcients which can be computed
by passing R(x) through m+ n+ 1 data points.
The following data set is an ideal candidate for rational function interpolation:
x
0
0.6
0.8
0.95
y
0
1.3764
3.0777
12.7062
From the plot of the data points (open circles in Fig. 3.8) it appears that y tends
to inﬁnity near x = 1. That makes the data ill suited for polynomial interpolation.
However, the rational function interpolant
f (x) = 1.3668x −0.7515x2
1 −1.0013x
(the solid line in Fig. 3.8) has no trouble handling the singularity.
x
0.0
0.2
0.4
0.6
0.8
1.0
y
0.0
2.0
4.0
6.0
8.0
10.0
12.0
14.0
Figure 3.8. Rational function interpolation.

4
Roots of Equations
Find the solutions of f (x) = 0, where the function f is given
4.1
Introduction
A common problem encountered in engineering analysis is this: given a function f (x),
determine the values of x for which f (x) = 0. The solutions (values of x) are known as
the roots of the equation f (x) = 0, or the zeroes of the function f (x).
Before proceeding further, it might be helpful to review the concept of a function.
The equation
y = f (x)
containsthreeelements:aninputvalue x,anoutputvalue y,andtherule f forcomput-
ing y. The function is said to be given if the rule f is speciﬁed. In numerical computing
the rule is invariably a computer algorithm. It may be a function statement, such as
f (x) = cosh(x) cos(x) −1
or a complex procedure containing hundreds or thousands of lines of code. As long
as the algorithm produces an output y for each input x, it qualiﬁes as a function.
The roots of equations may be real or complex. The complex roots are seldom
computed,sincetheyrarelyhavephysicalsigniﬁcance.Anexceptionisthepolynomial
equation
a0 + a1x + a1x2 + · · · + anxn = 0
where the complex roots may be meaningful (as in the analysis of damped vibrations,
for example). For the time being, we will concentrate on ﬁnding the real roots of
equations. Complex zeroes of polynomials are treated near the end of this chapter.
142

143
4.2 Incremental Search Method
In general, an equation may have any number of (real) roots, or no roots at all.
For example,
sin x −x = 0
has a single root, namely x = 0, whereas
tan x −x = 0
has an inﬁnite number of roots (x = 0, ±4.493, ±7.725, . . .).
All methods of ﬁnding roots are iterative procedures that require a starting point,
i.e., an estimate of the root. This estimate can be crucial; a bad starting value may
fail to converge, or it may converge to the “wrong” root (a root different from the one
sought).Thereisnouniversalrecipeforestimatingthevalueofaroot.Iftheequationis
associated with a physical problem, then the context of the problem (physical insight)
mightsuggesttheapproximatelocationoftheroot.Otherwise,asystematicnumerical
search for the roots can be carried out. One such search method is described in the
next article. The roots can also be located visually by plotting the function.
It is highly advisable to go a step further and bracket the root (determine its lower
and upper bounds) before passing the problem to a root ﬁnding algorithm. Prior
bracketing is, in fact, mandatory in the methods described in this chapter.
4.2
Incremental Search Method
The approximate locations of the roots are best determined by plotting the function.
Oftenaveryroughplot,basedonafewpoints,issufﬁcienttogiveusreasonablestarting
values.Anotherusefultoolfordetectingandbracketingrootsistheincrementalsearch
method. It can also be adapted for computing roots, but the effort would not be
worthwhile, since other methods described in this chapter are more efﬁcient for that.
The basic idea behind the incremental search method is simple: if f (x1) and f (x2)
have opposite signs, then there is at least one root in the interval (x1, x2). If the interval
is small enough, it is likely to contain a single root. Thus the zeroes of f (x) can be
detected by evaluating the function at intervals x and looking for change in sign.
There are several potential problems with the incremental search method:
r It is possible to miss two closely spaced roots if the search increment x is larger
than the spacing of the roots.
r A double root (two roots that coincide) will not be detected.
r Certain singularities of f (x) can be mistaken for roots. For example, f (x) = tan x
changes sign at x = ± 1
2nπ, n = 1, 3, 5, . . . , as shown in Fig. 4.1. However, these
locations are not true zeroes, since the function does not cross the x-axis.

144
Roots of Equations
x
0
1
2
3
4
5
6
-10.0
-5.0
0.0
5.0
10.0
Figure 4.1. Plot of tan x.
■rootsearch
This function searches for a zero of the user-supplied function f (x) in the interval
(a, b) in increments of dx. It returns the bounds (x1,x2) of the root if the search
was successful; x1 = x2 = None indicates that no roots were detected. After the
ﬁrst root (the root closest to a) has been detected, rootsearch can be called again
with a replaced by x2 in order to ﬁnd the next root. This can be repeated as long as
rootsearch detects a root.
## module rootsearch
’’’ x1,x2 = rootsearch(f,a,b,dx).
Searches the interval (a,b) in increments dx for
the bounds (x1,x2) of the smallest root of f(x).
Returns x1 = x2 = None if no roots were detected.
’’’
def rootsearch(f,a,b,dx):
x1 = a; f1 = f(a)
x2 = a + dx; f2 = f(x2)
while f1*f2 > 0.0:
if x1
>=
b: return None,None
x1 = x2; f1 = f2
x2 = x1 + dx; f2 = f(x2)
else:
return x1,x2
EXAMPLE 4.1
Use incremental search with x = 0.2 to bracket the smallest positive zero of f (x) =
x3 −10x2 + 5.

145
4.3 Method of Bisection
Solution We evaluate f (x) at intervals x = 0.2, staring at x = 0, until the function
changes its sign (value of the function is of no interest to us; only its sign is relevant).
This procedure yields the following results:
x
f (x)
0.0
5.000
0.2
4.608
0.4
3.464
0.6
1.616
0.8
−0.888
From the sign change of the function we conclude that the smallest positive zero lies
between x = 0.6 and x = 0.8.
4.3
Method of Bisection
After a root of f (x) = 0 has been bracketed in the interval (x1, x2), several methods can
be used to close in on it. The method of bisection accomplishes this by successively
halving the interval until it becomes sufﬁciently small. This technique is also known
as the interval halving method. Bisection is not the fastest method available for com-
puting roots, but it is the most reliable. Once a root has been bracketed, bisection will
always close in on it.
The method of bisection uses the same principle as incremental search: if there
is a root in the interval (x1, x2), then f (x1) · f (x2) < 0. In order to halve the interval, we
compute f (x3), where x3 = 1
2(x1 + x2) is the midpoint of the interval. If f (x2) · f (x3) <
0, then the root must be in (x2, x3) and we record this by replacing the original bound
x1 by x3. Otherwise, the root lies in (x1, x3), in which case x2 is replaced by x3. In either
case, the new interval (x1, x2) is half the size of the original interval. The bisection is
repeated until the interval has been reduced to a small value ε, so that
|x2 −x1| ≤ε
Itiseasytocomputethenumberofbisectionsrequiredtoreachaprescribedε.The
original interval x is reduced to x/2 after one bisection, x/22 after two bisections,
and after n bisections it is x/2n. Setting x/2n = ε and solving for n, we get
n = ln (|x| /ε)
ln 2
(4.1)
■bisect
This function uses the method of bisection to compute the root of f(x) = 0 that is
known to lie in the interval (x1,x2). The number of bisections n required to reduce

146
Roots of Equations
the interval to tol is computed from Eq. (4.1). By setting switch = 1, we force the
routine to check whether the magnitude of f(x) decreases with each interval halving.
If it does not, something may be wrong (probably the “root” is not a root at all, but a
singularity) and root = None is returned. Since this feature is not always desirable,
the default value is switch = 0. The function error.err, which we use to terminate
a program, is listed in Art. 1.6.
## module bisect
’’’ root = bisect(f,x1,x2,switch=0,tol=1.0e-9).
Finds a root of f(x) = 0 by bisection.
The root must be bracketed in (x1,x2).
Setting switch = 1 returns root = None if
f(x) increases as a result of a bisection.
’’’
from math import log,ceil
import error
def bisect(f,x1,x2,switch=0,epsilon=1.0e-9):
f1 = f(x1)
if f1 == 0.0: return x1
f2 = f(x2)
if f2 == 0.0: return x2
if f1*f2 > 0.0: error.err(’Root is not bracketed’)
n = ceil(log(abs(x2 - x1)/epsilon)/log(2.0))
for i in range(n):
x3 = 0.5*(x1 + x2); f3 = f(x3)
if (switch == 1) and (abs(f3) >abs(f1)) \
and (abs(f3) > abs(f2)):
return None
if f3 == 0.0: return x3
if f2*f3 < 0.0:
x1 = x3; f1 = f3
else:
x2 =x3; f2 = f3
return (x1 + x2)/2.0
EXAMPLE 4.2
Use bisection to ﬁnd the root of f (x) = x3 −10x2 + 5 = 0 that lies in the interval
(0.6, 0.8).
Solution The best way to implement the method is to use the following table. Note
that the interval to be bisected is determined by the sign of f (x), not its magnitude.

147
4.3 Method of Bisection
x
f (x)
Interval
0.6
1.616
−
0.8
−0.888
(0.6, 0.8)
(0.6 + 0.8)/2 = 0.7
0.443
(0.7, 0.8)
(0.8 + 0.7)/2 = 0.75
−0. 203
(0.7, 0.75)
(0.7 + 0.75)/2 = 0.725
0.125
(0.725, 0.75)
(0.75 + 0.725)/2 = 0.7375
−0.038
(0.725, 0.7375)
(0.725 + 0.7375)/2 = 0.73125
0.044
(0.7375, 0.73125)
(0.7375 + 0.73125)/2 = 0.73438
0.003
(0.7375, 0.73438)
(0.7375 + 0.73438)/2 = 0.73594
−0.017
(0.73438, 0.73594)
(0.73438 + 0.73594)/2 = 0.73516
−0.007
(0.73438, 0.73516)
(0.73438 + 0.73516)/2 = 0.73477
−0.002
(0.73438, 0.73477)
(0.73438 + 0.73477)/2 = 0.73458
0.000
−
The ﬁnal result x = 0.7346 is correct within four decimal places.
EXAMPLE 4.3
Find all the zeros of f (x) = x −tan x in the interval (0, 20) by the method of bisection.
Utilize the functions rootsearch and bisect.
Solution Note that tan x is singular and changes sign at x = π/2, 3π/2, . . . . To pre-
vent bisect from mistaking these point for roots, we set switch = 1. The close-
ness of roots to the singularities is another potential problem that can be alleviated
by using small x in rootsearch. Choosing x = 0.01, we arrive at the following
program:
#!/usr/bin/python
## example4_3
from math import tan
from rootsearch import *
from bisect import *
def f(x): return x - tan(x)
a,b,dx = (0.0, 20.0, 0.01)
print ’’The roots are:’’
while 1:
x1,x2 = rootsearch(f,a,b,dx)

148
Roots of Equations
if x1 != None:
a = x2
root = bisect(f,x1,x2,1)
if root != None: print root
else:
print ’’\nDone’’
break
raw_input(’’Press return to exit’’)
The output from the program is:
The roots are:
0.0
4.4934094581
7.72525183707
10.9041216597
14.0661939129
17.2207552722
Done
4.4
Brent’s Method
Brent’s method9 combines bisection and quadratic interpolation into an efﬁcient
root-ﬁnding algorithm. In most problems the method is much faster than bisection
alone, but it can become sluggish if the function is not smooth. It is the recommended
method of root solving if the derivative of the function is difﬁcult or impossible to
compute.
x
x
x
x
1
2
3
3
Old interval
New
interval
f(x)
x
x1
x3
x2
x
Old interval
New
interval
x
f(x)
(b) Case of x > x3
(a) Case of x < x
Figure 4.2. Inverse quadratic iteration.
9 Brent, R. P., Algorithms for Minimization without Derivatives, Prentice-Hall, 1973.

149
4.4 Brent’s Method
Brent’s method assumes that a root of f (x) = 0 has been initially bracketed in
the interval (x1, x2). The root-ﬁnding process starts with a bisection step that halves
the interval to either (x1, x3) or (x3, x2), where x3 = (x1 + x2)/2, as shown in Figs. 4.2(a)
and (b). In the course of bisection we had to compute f1 = f (x1), f2 = f (x2) and
f3 = f (x3), so that we now know three points on the f (x) curve (the open circles in
the ﬁgure). These points allow us to carry out the next iteration of the root by inverse
quadratic interpolation (viewing x as a quadratic function of f ). If the result x of the
interpolation falls inside the latest bracket (as is the case in Figs. 4.2) we accept the
result. Otherwise, another round of bisection is applied.
x
x
x
1
2
3
f(x)
f(x)
x
x1 x3
x2 x
(a)
(b)
Figure 4.3. Relabeling roots after an iteration.
The next step is to relabel x as x3 and rename the limits of the new interval
x1 and x2 (x1 < x3 < x2), as indicated in Figs. 4.3. We have now recovered the orig-
inal sequencing of points in Figs. 4.2, but the interval (x1, x2) containing the root
has been reduced. This completes the ﬁrst iteration cycle. In the next cycle an-
other inverse quadratic interpolation is attempted and the process is repeated un-
til the convergence criterion |x −x3| < ε is satisﬁed, where ε is a prescribed error
tolerance.
The inverse quadratic interpolation is carried out with Lagrange’s three-point
interpolant described in Section 3.2. Interchanging the roles of x and f , we have
x( f ) = ( f −f2)( f −f3)
( f1 −f2)( f1 −f3) x1 + ( f −f1)( f −f3)
( f2 −f1)( f2 −f3) x2 + ( f −f1)( f −f2)
( f3 −f1)( f3 −f2) x3
Setting f = 0 and simplifying, we obtain for the estimate of the root
x = x(0) = −f2 f3x1( f2 −f3) + f3 f1x2( f3 −f1) + f1 f2x3( f1 −f2)
( f1 −f2)( f2 −f3)( f3 −f1)
The change in the root is
x = x −x3 = f3
x3( f1 −f2)( f2 −f3 + f1) + f2x1( f2 −f3) + f1x2( f3 −f1)
( f2 −f1)( f3 −f1)( f2 −f3)
(4.2)

150
Roots of Equations
■brent
The function brent listed below is a simpliﬁed version of the algorithm proposed by
Brent. It omits some of Brent’s safeguards against slow convergence; it also uses a less
sophisticated convergence criterion.
## module brent
’’’ root = brent(f,a,b,tol=1.0e-9).
Finds root of f(x) = 0 by combining quadratic interpolation
with bisection (simplified Brent’s method).
The root must be bracketed in (a,b).
Calls user-supplied function f(x).
’’’
import error
def brent(f,a,b,tol=1.0e-9):
x1 = a; x2 = b;
f1 = f(x1)
if f1 == 0.0: return x1
f2 = f(x2)
if f2 == 0.0: return x2
if f1*f2 > 0.0: error.err(’Root is not bracketed’)
x3 = 0.5*(a + b)
for i in range(30):
f3 = f(x3)
if abs(f3) < tol: return x3
# Tighten the brackets on the root
if f1*f3 < 0.0: b = x3
else: a = x3
if (b - a) < tol*max(abs(b),1.0): return 0.5*(a + b)
# Try quadratic interpolation
denom = (f2 - f1)*(f3 - f1)*(f2 - f3)
numer = x3*(f1 - f2)*(f2 - f3 + f1)
\
+ f2*x1*(f2 - f3) + f1*x2*(f3 - f1)
# If division by zero, push x out of bounds
try: dx = f3*numer/denom
except ZeroDivisionError: dx = b - a
x = x3 + dx
# If iterpolation goes out of bounds, use bisection
if (b - x)*(x - a) < 0.0:

151
4.4 Brent’s Method
dx = 0.5*(b - a)
x = a + dx
# Let x3 <-- x & choose new x1 and x2 so that x1 < x3 < x2
if x < x3:
x2 = x3; f2 = f3
else:
x1 = x3; f1 = f3
x3 = x
print ’Too many iterations in brent’
EXAMPLE 4.4
Determine the root of f (x) = x3 −10x2 + 5 = 0 that lies in (0.6, 0.8) with Brent’s
method.
Solution
Bisection The starting points are
x1 = 0.6
f1 = 0.63 −10(0.6)2 + 5 = 1.616
x2 = 0.8
f2 = 0.83 −10(0.8)2 + 5 = −0.888
Bisection yields the point
x3 = 0.7
f3 = 0.73 −10(0.7)2 + 5 = 0.443
Byinspectingthesignsof f weconcludethatthenewbracketsontherootare(x3, x2) =
(0.7, 0.8).
First interpolation cycle The numerator of the quotient in Eq. (4.2) is
num = x3( f1 −f2)( f2 −f3 + f1) + f2x1( f2 −f3) + f1x2( f3 −f1)
= 0.7(1.616 + 0.888)(−0.888 −0.443 + 1.616)
−0.888(0.6)(−0.888 −0.443) + 1.616(0.8)(0.443 −1.616)
= −0.307 75
and the denominator is
den = ( f2 −f1)( f3 −f1)( f2 −f3)
= (−0.888 −1.616)(0.443 −1.616)(−0.888 −0.443) = −3.9094

152
Roots of Equations
Therefore,
x = f3
num
den = 0.443(−0.307 75)
(−3.9094) = 0.034 87
and
x = x3 + x = 0.7 + 0.034 87 = 0.734 87
Since the result is within the established brackets, we accept it.
Relabel points As x > x3, the points are relabeled as illustrated in Figs. 4.2(b) and
4.3(b):
x1 ←x3 = 0.7
f1 ←f3 = 0.443
x3 ←x = 0.734 87
f3 = 0.734 873 −10(0.734 87)2 + 5 = −0.00348
The new brackets on the root are (x1, x3) = (0.7, 0.734 87)
Second interpolation cycle ApplyingtheinterpolationinEq.(4.2)again,weobtain
(skipping the arithmetical details)
x = −0.000 27
x = x3 + x = 0.734 87 −0.000 27 = 0.734 60
Again x falls within the latest brackets, so the result is acceptable. At this stage, x is
correct to ﬁve decimal places.
EXAMPLE 4.5
Compute the zero of
f (x) = x |cos x| −1
that lies in the interval (0, 4) with Brent’s method.

153
4.5 Newton–Raphson Method
Solution
x
0.00
0.50
1.00
1.50
2.00
2.50
3.00
3.50
4.00
f (x)
-1.00
-0.50
0.00
0.50
1.00
1.50
2.00
2.50
The plot of f (x) shows that this is a rather nasty function within the speciﬁed interval,
containing a slope discontinuity and two local maxima. The sensible approach is
to avoid the potentially troublesome regions of the function by bracketing the root
as tightly as possible from a visual inspection of the plot. In this case, the interval
(a, b) = (2.0, 2.2) would be a good starting point for Brent’s algorithm.
Is Brent’s method robust enough to handle the problem with the original brackets
(0, 4)? Well, here is the program and its output:
#!/usr/bin/python
## example4_5
from math import cos
from brent import *
def f(x): return x*abs(cos(x)) - 1.0
print ’’root =’’,brent(f,0.0,4.0)
raw_input(’’Press return to exit’’)
root = 2.0739328091
The result was obtained in only ﬁve iterations.
4.5
Newton–Raphson Method
The Newton–Raphson algorithm is the best-known method of ﬁnding roots for a
good reason: it is simple and fast. The only drawback of the method is that it uses

154
Roots of Equations
the derivative f ′(x) of the function as well as the function f (x) itself. Therefore,
the Newton–Raphson method is usable only in problems where f ′(x) can be readily
computed.
The Newton–Raphson formula can be derived from the Taylor series expansion
of f (x) about x:
f (xi+1) = f (xi) + f ′(xi)(xi+1 −xi) + O(xi+1 −xi)2
(a)
where O(z) is to be read as “of the order of z”—see Appendix A1. If xi+1 is a root of
f (x) = 0, Eq. (a) becomes
0 = f (xi) + f ′(xi) (xi+1 −xi) + O(xi+1 −xi)2
(b)
Assuming that xi is a close to xi+1, we can drop the last term in Eq. (b) and solve for
xi+1. The result is the Newton–Raphson formula
xi+1 = xi −f (xi)
f ′(xi)
(4.3)
If x denotes the true value of the root, the error in xi is Ei = x −xi. It can be shown
that if xi+1 is computed from Eq. (4.3), the corresponding error is
Ei+1 = −f ′′(xi)
2 f ′(xi) E2
i
indicating that Newton–Raphson method converges quadratically (the error is the
square of the error in the previous step). As a consequence, the number of signif-
icant ﬁgures is roughly doubled in every iteration, provided that xi is close to the
root.
Tangent line
f (xi)
i
ix
x +1
x
f (x)
Figure 4.4. Graphical interpretation of the Newton–Raphson
formula.
A graphical depiction of the Newton–Raphson formula is shown in Fig. 4.4. The for-
mula approximates f (x) by the straight line that is tangent to the curve at xi. Thus xi+1
is at the intersection of the x-axis and the tangent line.
The algorithm for the Newton–Raphson method is simple: it repeatedly applies
Eq. (4.3), starting with an initial value x0, until the convergence criterion
|xi+1 −x1| < ε
is reached, ε being the error tolerance. Only the latest value of x has to be stored. Here
is the algorithm:

155
4.5 Newton–Raphson Method
1.
Let x be a guess for the root of f (x) = 0.
2.
Compute x = −f (x)/f ′(x).
3.
Let x ←x + x and repeat steps 2–3 until |x| < ε.
x
x
f (x)
f (x)
0
x
x
x
x
0
2
1
(a)
(b)
Figure 4.5. Examples where the Newton–Raphson method
diverges.
Although the Newton–Raphson method converges fast near the root, its global
convergence characteristics are poor. The reason is that the tangent line is not always
an acceptable approximation of the function, as illustrated in the two examples in
Fig. 4.5. But the method can be made nearly fail-safe by combining it with bisection,
as in Brent’s method.
■newtonRaphson
The following safe version of the Newton–Raphson method assumes that the root to
be computed is initially bracketed in (a,b). The midpoint of the bracket is used as the
initial guess of the root. The brackets are updated after each iteration. If a Newton–
Raphson iteration does not stay within the brackets, it is disregarded and replaced
with bisection. Since newtonRaphson uses the function f(x) as well as its derivative,
function routines for both (denoted by f and df in the listing) must be provided by
the user.
## module newtonRaphson
’’’ root = newtonRaphson(f,df,a,b,tol=1.0e-9).
Finds a root of f(x) = 0 by combining the Newton-Raphson
method with bisection. The root must be bracketed in (a,b).
Calls user-supplied functions f(x) and its derivative df(x).
’’’
def newtonRaphson(f,df,a,b,tol=1.0e-9):
import error
fa = f(a)
if fa == 0.0: return a
fb = f(b)

156
Roots of Equations
if fb == 0.0: return b
if fa*fb > 0.0: error.err(’Root is not bracketed’)
x = 0.5*(a + b)
for i in range(30):
fx = f(x)
if abs(fx) < tol: return x
# Tighten the brackets on the root
if fa*fx < 0.0:
b = x
else:
a = x; fa = fx
# Try a Newton-Raphson step
dfx = df(x)
# If division by zero, push x out of bounds
try: dx = -fx/dfx
except ZeroDivisionError: dx = b - a
x = x + dx
# If the result is outside the brackets, use bisection
if (b - x)*(x - a) < 0.0:
dx = 0.5*(b-a)
x = a + dx
# Check for convergence
if abs(dx) < tol*max(abs(b),1.0): return x
print ’Too many iterations in Newton-Raphson’
EXAMPLE 4.6
A root of f (x) = x3 −10x2 + 5 = 0 lies close to x = 0.7. Compute this root with the
Newton–Raphson method.
Solution The derivative of the function is f ′(x) = 3x2 −20x, so that the Newton–
Raphson formula in Eq. (4.3) is
x ←x −f (x)
f ′(x) = x −x3 −10x2 + 5
3x2 −20x
= 2x3 −10x2 −5
x (3x −20)
It takes only two iterations to reach ﬁve decimal place accuracy:
x ←2(0.7)3 −10(0.7)2 −5
0.7 [3(0.7) −20]
= 0.735 36
x ←2(0.735 36)3 −10(0.735 36)2 −5
0.735 36 [3(0.735 36) −20]
= 0.734 60

157
4.5 Newton–Raphson Method
EXAMPLE 4.7
Find the smallest positive zero of
f (x) = x4 −6.4x3 + 6.45x2 + 20.538x −31.752
Solution
x
0
1
2
3
4
5
f (x)
-40
-20
0
20
40
60
Inspecting the plot of the function, we suspect that the smallest positive zero is a
double root near x = 2. Bisection and Brent’s method would not work here, since they
depend on the function changing its sign at the root. The same argument applies to
the function newtonRaphson. But there no reason why the unreﬁned version of the
Newton–Raphson method should not succeed. We used the following program, which
prints the number of iterations in addition to the root:
#!/usr/bin/python
## example4_7
def f(x): return x**4 - 6.4*x**3 + 6.45*x**2 + 20.538*x - 31.752
def df(x): return 4.0*x**3 - 19.2*x**2 + 12.9*x + 20.538
def newtonRaphson(x,tol=1.0e-9):
for i in range(30):
dx = -f(x)/df(x)
x = x + dx
if abs(dx) < tol: return x,i
print ’Too many iterations\n’
root,numIter = newtonRaphson(2.0)
print ’Root =’,root
print ’Number of iterations =’,numIter
raw_input(’’Press return to exit’’)

158
Roots of Equations
The output is
Root = 2.09999998403
Number of iterations = 23
The true value of the root is x = 2.1. It can be shown that near a multiple root the
convergence of the Newton–Raphson method is linear, rather than quadratic, which
explainsthelargenumberofiterations.Convergencetoamultiplerootcanbespeeded
up by replacing the Newton–Raphson formula in Eq. (4.3) with
xi+1 = xi −m f (xi)
f ′(xi)
wherem isthemultiplicityoftheroot(m= 2inthisproblem).Aftermakingthechange
in the above program, we obtained the result in only 5 iterations.
4.6
Systems of Equations
Introduction
Up to this point, we conﬁned our attention to solving the single equation f (x) = 0.
Let us now consider the n-dimensional version of the same problem, namely
f(x) = 0
or, using scalar notation
f1(x1, x2, . . . , xn) = 0
f2(x1, x2, . . . , xn) = 0
(4.4)
...
fn(x1, x2, . . . , xn) = 0
The solution of nsimultaneous, nonlinear equations is a much more formidable task
thanﬁndingtherootofasingleequation.Thetroubleisthelackofareliablemethodfor
bracketing the solution vector x. Therefore, we cannot provide the solution algorithm
with a guaranteed good starting value of x, unless such a value is suggested by the
physics of the problem.
ThesimplestandthemosteffectivemeansofcomputingxistheNewton–Raphson
method. It works well with simultaneous equations, provided that it is supplied with

159
4.6 Systems of Equations
a good starting point. There are other methods that have better global convergence
characteristics, but all of then are variants of the Newton–Raphson method.
Newton–Raphson Method
In order to derive the Newton–Raphson method for a system of equations, we start
with the Taylor series expansion of fi(x) about the point x:
fi(x + ∆x) = fi(x) +
n

j=1
∂fi
∂xj
∆xj + O(x2)
(4.5a)
Dropping terms of order x2, we can write Eq. (4.5a) as
f(x + ∆x) = f(x) + J(x) ∆x
(4.5b)
where J(x) is the Jacobian matrix (of size n× n) made up of the partial derivatives
Jij = ∂fi
∂xj
(4.6)
Note that Eq. (4.5b) is a linear approximation (vector ∆x being the variable) of the
vector-valued function f in the vicinity of point x.
Let us now assume that x is the current approximation of the solution of f(x) = 0,
andletx + xbetheimprovedsolution.Toﬁndthecorrectionx,wesetf(x + ∆x) = 0
in Eq. (4.5b). The result is a set of linear equations for ∆x :
J(x)∆x = −f(x)
(4.7)
The following steps constitute the Newton–Raphson method for simultaneous,
nonlinear equations:
1.
Estimate the solution vector x.
2.
Evaluate f(x).
3.
Compute the Jacobian matrix J(x) from Eq. (4.6).
4.
Set up the simultaneous equations in Eq. (4.7) and solve for ∆x.
5.
Let x ←x + ∆x and repeat steps 2–5.
The above process is continued until |∆x| < ε, where ε is the error tolerance. As
in the one-dimensional case, success of the Newton–Raphson procedure depends
entirely on the initial estimate of x. If a good starting point is used, convergence to the
solution is very rapid. Otherwise, the results are unpredictable.
Because analytical derivation of each ∂fi/∂xj can be difﬁcult or impractical, it
is preferable to let the computer calculate the partial derivatives from the ﬁnite

160
Roots of Equations
difference approximation
∂fi
∂xj
≈fi(x + e jh) −fi(x)
h
(4.8)
where h is a small increment and e j represents a unit vector in the direction of xj.
This formula can be obtained from Eq. (4.5a) after dropping the terms of order x2
and setting ∆x = e jh. We get away with the approximation in Eq. (4.8) because the
Newton–Raphson method is rather insensitive to errors in J(x). By using this ap-
proximation, we also avoid the tedium of typing the expressions for ∂fi/∂xj into the
computer code.
■newtonRaphson2
This function is an implementation of the Newton–Raphson method. The nested
function jacobian computes the Jacobian matrix from the ﬁnite difference approx-
imation in Eq. (4.8). The simultaneous equations in Eq. (4.7) are solved by Gauss
elimination with row pivoting using the function gaussPivot. listed in Section 2.5.
The function subroutine f that returns the array f(x) must be supplied by the user.
## module newtonRaphson2
’’’ soln = newtonRaphson2(f,x,tol=1.0e-9).
Solves the simultaneous equations f(x) = 0 by
the Newton-Raphson method using {x}
as the initial
guess. Note that {f}
and {x}
are vectors.
’’’
from numarray import zeros,Float64,dot,sqrt
from gaussPivot import *
def newtonRaphson2(f,x,tol=1.0e-9):
def jacobian(f,x):
h = 1.0e-4
n = len(x)
jac = zeros((n,n),type=Float64)
f0 = f(x)
for i in range(n):
temp = x[i]
x[i] = temp + h
f1 = f(x)
x[i] = temp

161
4.6 Systems of Equations
jac[:,i] = (f1 - f0)/h
return jac,f0
for i in range(30):
jac,f0 = jacobian(f,x)
if sqrt(dot(f0,f0)/len(x)) < tol: return x
dx = gaussPivot(jac,-f0)
x = x + dx
if sqrt(dot(dx,dx)) < tol*max(abs(x),1.0): return x
print ’Too many iterations’
Note that the Jacobian matrix J(x) is recomputed in each iterative loop. Since each
calculation of J(x) involves n+ 1 evaluations of f(x) (nis the number of equations), the
expense of computation can be high depending on n and the complexity of f(x). It is
often possible to save computer time by neglecting the changes in the Jacobian matrix
between iterations, thus computing J(x) only once. This will work provided that the
initial x is sufﬁciently close to the solution.
EXAMPLE 4.8
Determine the points of intersection between the circle x2 + y2 = 3 and the hyperbola
xy = 1.
Solution The equations to be solved are
f1(x, y) = x2 + y2 −3 = 0
(a)
f2(x, y) = xy −1 = 0
(b)
The Jacobian matrix is
J(x, y) =
)
∂f1/∂x
∂f1/∂y
∂f2/∂x
∂f2/∂y
*
=
)
2x
2y
y
x
*
Thus the linear equations J(x)∆x = −f(x) associated with the Newton–Raphson
method are
)
2x
2y
y
x
* )
x
y
*
=
)
−x2 −y2 + 3
−xy + 1
*
(c)
By plotting the circle and the hyperbola, we see that there are four points of
intersection. It is sufﬁcient, however, to ﬁnd only one of these points, as the others
can be deduced from symmetry. From the plot we also get a rough estimate of the
coordinates of an intersection point: x = 0.5, y = 1.5, which we use as the starting
values.

162
Roots of Equations
x
y
3
1
2
1
2
-1
-2
-1
-2
The computations then proceed as follows.
First iteration Substituting x = 0.5, y = 1.5 in Eq. (c), we get
)
1.0
3.0
1.5
0.5
* )
x
y
*
=
)
0.50
0.25
*
the solution of which is x = y = 0.125. Therefore, the improved coordinates of the
intersection point are
x = 0.5 + 0.125 = 0.625
y = 1.5 + 0.125 = 1.625
Second iteration Repeating the procedure using the latest values of x and y, we
obtain
)
1.250
3.250
1.625
0.625
* )
x
y
*
=
)
−0.031250
−0.015625
*
which yields x = y = −0.00694. Thus
x = 0.625 −0.006 94 = 0.618 06
y = 1.625 −0.006 94 = 1.618 06
Third iteration Substitution of the latest x and y into Eq. (c) yields
)
1.236 12
3.23612
1.618 06
0.61806
* )
x
y
*
=
)
−0.000 116
−0.000 058
*
The solution is x = y = −0.00003, so that
x = 0.618 06 −0.000 03 = 0.618 03
y = 1.618 06 −0.000 03 = 1.618 03
Subsequent iterations would not change the results within ﬁve signiﬁcant ﬁgures.
Therefore, the coordinates of the four intersection points are
±(0.618 03, 1.618 03) and ± (1.618 03, 0.618 03)

163
4.6 Systems of Equations
Alternate solution If there are only a few equations, it may be possible to eliminate
all but one of the unknowns. Then we would be left with a single equation which can
be solved by the methods described in Sections 4.2–4.5. In this problem, we obtain
from Eq. (b)
y = 1
x
which upon substitution into Eq. (a) yields x2 + 1/x2 −3 = 0, or
x4 −3x2 + 1 = 0
The solutions of this biquadratic equation: x = ±0.618 03 and ±1.618 03 agree with
the results obtained by the Newton–Raphson method.
EXAMPLE 4.9
Find a solution of
sin x + y2 + ln z −7 = 0
3x + 2y −z3 + 1 = 0
x + y + z −5 = 0
using newtonRaphson2. Start with the point (1, 1, 1).
Solution Letting x0 = x, x1 = y and x2 = z, we obtain the following program:
#!/usr/bin/python
## example4_9
from numarray import zeros,array
from math import sin,log
from newtonRaphson2 import *
def f(x):
f = zeros((len(x)),type=Float64)
f[0] = sin(x[0]) + x[1]**2 + log(x[2]) - 7.0
f[1] = 3.0*x[0] + 2.0**x[1] - x[2]**3 + 1.0
f[2] = x[0] + x[1] + x[2] - 5.0
return f
x = array([1.0, 1.0, 1.0])
print newtonRaphson2(f,x)
raw_input (’’\nPress return to exit’’)
The output from this program is
[0.59905376
2.3959314
2.00501484]

164
Roots of Equations
PROBLEM SET 4.1
1. Use the Newton–Raphson method and a four-function calculator (+ −×÷ oper-
ations only) to compute
3√
75 with four signiﬁcant ﬁgure accuracy.
2. Find the smallest positive (real) root of x3 −3.23x2 −5.54x + 9.84 = 0 by the
method of bisection.
3. Thesmallestpositive,nonzerorootofcosh x cos x −1 = 0liesintheinterval(4, 5).
Compute this root by Brent’s method.
4. Solve Prob. 3 by the Newton–Raphson method.
5. A root of the equation tan x −tanh x = 0 lies in (7.0, 7.4). Find this root with three
decimal place accuracy by the method of bisection.
6. Determine the two roots of sin x + 3 cos x −2 = 0 that lie in the interval (−2, 2).
Use the Newton–Raphson method.
7. A popular method in hand computation is thesecant formula where the improved
estimate of the root (xi+1) is obtained by linear interpolation based two previous
estimates (xi and xi−1):
xi+1 = xi −
xi −xi−1
f (xi) −f (xi−1) f (xi)
Solve Prob. 6 using the secant formula.
8. Draw a plot of f (x) = cosh x cos x −1 in the range 4 ≤x ≤8. (a) Verify from the
plot that the smallest positive, nonzero root of f (x) = 0 lies in the interval (4, 5).
(b) Show graphically that the Newton–Raphson formula would not converge to
this root if it is started with x = 4.
9. The equation x3 −1.2x2 −8.19x + 13.23 = 0 has a double root close to x = 2.
Determine this root with the Newton–Raphson method within four decimal
places.
10. ■Write a program that computes all the roots of f (x) = 0 in a given interval with
Brent’s method. Utilize the functions rootsearch and brent. You may use the
program in Example 4.3 as a model. Test the program by ﬁnding the roots of
x sin x + 3 cos x −x = 0 in (−6, 6).
11. ■Solve Prob. 10 with the Newton–Raphson method.
12. ■Determine all real roots of x4 + 0.9x3 −2.3x2 + 3.6x −25.2 = 0.
13. ■Compute all positive real roots of x4 + 2x3 −7x2 + 3 = 0.
14. ■Find all positive, nonzero roots of sin x −0.1x = 0.

165
4.6 Systems of Equations
15. ■The natural frequencies of a uniform cantilever beam are related to the roots
βi of the frequency equation f (β) = cosh β cos β + 1 = 0, where
β4
i = (2π fi)2 mL3
E I
fi = ith natural frequency (cps)
m = mass of the beam
L = length of the beam
E = modulus of elasticity
I = moment of inertia of the cross section
Determine the lowest two frequencies of a steel beam 0.9 m. long, with a rectan-
gular cross section 25 mm wide and 2.5 mm in. high. The mass density of steel is
7850 kg/m3 and E = 200 GPa.
16. ■
L
2
Length =s
O
L
2
A steel cable of length s is suspended as shown in the ﬁgure. The maximum tensile
stress in the cable, which occurs at the supports, is
σ max = σ 0 cosh β
where
β = γ L
2σ 0
σ 0 = tensile stress in the cable at O
γ = weight of the cable per unit volume
L = horizontal span of the cable
The length to span ratio of the cable is related to β by
s
L = 1
β sinh β
Find σ max if γ = 77 × 103 N/m3 (steel), L = 1000 m and s = 1100 m.
17. ■
P
e
c
L
P

166
Roots of Equations
ThealuminumW310 × 202(wideﬂange)columnissubjectedtoaneccentricaxial
load P as shown. The maximum compressive stress in the column is given by the
so-called secant formula:
σ max = ¯σ
)
1 + ec
r2 sec

L
2r
(
¯σ
E
*
where
¯σ = P/A = average stress
A = 25 800 mm2 = cross-sectional area of the column
e = 85 mm = eccentricity of the load
c = 170 mm = half-depth of the column
r = 142 mm = radius of gyration of the cross section
L = 7100 mm = length of the column
E = 71 × 109 Pa = modulus of elasticity
Determine the maximum load P that the column can carry if the maximum stress
is not to exceed 120 × 106 Pa.
18. ■
h
Q
H
ho
Bernoulli’s equation for ﬂuid ﬂow in an open channel with a small bump is
Q2
2gb2h2
0
+ h0 =
Q2
2gb2h2 + h + H
where
Q = 1.2 m3/s = volume rate of ﬂow
g = 9.81 m/s2 = gravitational acceleration
b = 1.8 m = width of channel
h0 = 0.6 m = upstream water level
H = 0.075 m = height of bump
h = water level above the bump
Determine h.

167
4.6 Systems of Equations
19. ■The speed v of a Saturn V rocket in vertical ﬂight near the surface of earth can
be approximated by
v = uln
M0
M0 −˙
mt −gt
where
u = 2510 m/s = velocity of exhaust relative to the rocket
M0 = 2.8 × 106 kg = mass of rocket at liftoff
˙
m = 13.3 × 103 kg/s = rate of fuel consumption
g = 9.81 m/s2 = gravitational acceleration
t = time measured from liftoff
Determine the time when the rocket reaches the speed of sound (335 m/s).
20. ■
Isothermal
expansion
Volume reduced
by cooling
Heating at
constant volume
P
V
V
V
P
P
T
T
T
1
1
1
2
2
2
2
The ﬁgure shows the thermodynamic cycle of an engine. The efﬁciency of this
engine for monoatomic gas is
η =
ln(T2/T1) −(1 −T1/T2)
ln(T2/T1) + (1 −T1/T2)/(γ −1)
where T is the absolute temperature and γ = 5/3. Find T2/T1 that results in 30%
efﬁciency (η = 0.3).
21. ■Gibb’s free energy of one mole of hydrogen at temperature T is
G = −RT ln

(T/T0)5/2
J
where R = 8.314 41 J/K is the gas constant and T0 = 4.444 18 K. Determine the
temperature at which G = −105 J.

168
Roots of Equations
22. ■The chemical equilibrium equation in the production of methanol from CO
and H2 is10
ξ(3 −2ξ)2
(1 −ξ)3
= 249.2
where ξ is the equilibrium extent of the reaction. Determine ξ.
23. ■Determine the coordinates of the two points where the circles (x −2)2 + y2 = 4
and x2 + (y −3)2 = 4intersect.Startbyestimatingthelocationsofthepointsfrom
a sketch of the circles, and then use the Newton–Raphson method to compute
the coordinates.
24. ■The equations
sin x + 3 cos x −2 = 0
cos x −sin y + 0.2 = 0
haveasolutioninthevicinityofthepoint(1, 1).UsetheNewton–Raphsonmethod
to reﬁne the solution.
25. ■Use any method to ﬁnd all real solutions in 0 < x < 1.5 of the simultaneous
equations
tan x −y = 1
cos x −3 sin y = 0
26. ■The equation of a circle is
(x −a)2 + (y −b)2 = R2
where R is the radius and (a, b) are the coordinates of the center. If the coordinates
of three points on the circle are
x
8.21
0.34
5.96
y
0.00
6.62
−1.12
determine R, a and b.
27. ■
O
R
10 From Alberty, R. A., Physical Chemistry, 7th ed., Wiley, 1987.

169
4.6 Systems of Equations
The trajectory of a satellite orbiting the earth is
R =
C
1 + e sin(θ + α)
where (R, θ) are the polar coordinates of the satellite, and C, e and α are constants
(e is known as the eccentricity of the orbit). If the satellite was observed at the
following three positions
θ
−30◦
0◦
30◦
R (km)
6870
6728
6615
determine the smallest R of the trajectory and the corresponding value of θ.
28. ■
300 m
61 m
45
y
x
O
v
A projectile is launched at O with the velocity v at the angle θ to the horizontal.
The parametric equations of the trajectory are
x = (v cos θ)t
y = −1
2gt2 + (v sin θ)t
where t is the time measured from the instant of launch, and g = 9.81 m/s2 rep-
resents the gravitational acceleration. If the projectile is to hit the target at the 45◦
angle shown in the ﬁgure, determine v, θ and the time of ﬂight.
29. ■
200 mm
150 mm
180 mm
200 mm
1
2
3
y
x
The three angles shown in the ﬁgure of the four-bar linkage are related by
150 cos θ1 + 180 cos θ2 −200 cos θ3 = 200
150 sin θ1 + 180 sin θ2 −200 sin θ3 = 0
Determine θ1 and θ2 when θ3 = 75◦. Note that there are two solutions.

170
Roots of Equations
∗4.7
Zeroes of Polynomials
Introduction
A polynomial of degree n has the form
Pn(x) = a0 + a1x + a2x2 + · · · + anxn
(4.9)
where the coefﬁcients ai may be real or complex. We will concentrate on polynomials
with real coefﬁcients, but the algorithms presented in this chapter also work with
complex coefﬁcients.
The polynomial equation Pn(x) = 0 has exactly n roots, which may be real or
complex. If the coefﬁcients are real, the complex roots always occur in conjugate pairs
(xr + ixi, xr −ixi), where xr and xi are the real and imaginary parts, respectively. For
real coefﬁcients, the number of real roots can be estimated from the rule of Descartes:
r The number of positive, real roots equals the number of sign changes in the
expression for Pn(x), or less by an even number.
r The number of negative, real roots is equal to the number of sign changes in
Pn(−x), or less by an even number.
As an example, consider P3(x) = x3 −2x2 −8x + 27. Since the sign changes twice,
P3(x) = 0 has either two or zero positive real roots. On the other hand, P3(−x) =
−x3 −2x2 + 8x + 27containsasinglesignchange;hence P3(x)possessesonenegative
real zero.
The real zeros of polynomials with real coefﬁcients can always be computed by
one of the methods already described. But if complex roots are to be computed, it is
best to use a method that specializes in polynomials. Here we present a method due to
Laguerre, which is reliable and simple to implement. Before proceeding to Laguerre’s
method, we must ﬁrst develop two numerical tools that are needed in any method
capable of determining the zeroes of a polynomial. The ﬁrst of these is an efﬁcient
algorithm for evaluating a polynomial and its derivatives. The second algorithm we
need is for the deﬂation of a polynomial, i.e., for dividing the Pn(x) by x −r, where r is
a root of Pn(x) = 0.
Evaluation of Polynomials
It is tempting to evaluate the polynomial in Eq. (4.9) from left to right by the following
algorithm (we assume that the coefﬁcients are stored in the array a):
p = 0.0
for i in range(n+1):
p = p + a[i]*x**i

171
4.7 Zeroes of Polynomials
Since xk is evaluated as x × x × · · · × x (k −1 multiplications), we deduce that the
number of multiplications in this algorithm is
1 + 2 + 3 + · · · + n−1 = 1
2n(n−1)
If nis large, the number of multiplications can be reduced considerably if we evaluate
the polynomial from right to left. For an example, take
P4(x) = a0 + a1x + a2x2 + a3x3 + a4x4
After rewriting the polynomial as
P4(x) = a0 + x {a1 + x [a2 + x (a3 + xa4)]}
the preferred computational sequence becomes obvious:
P0(x) = a4
P1(x) = a3 + xP0(x)
P2(x) = a2 + xP1(x)
P3(x) = a1 + xP2(x)
P4(x) = a0 + xP3(x)
For a polynomial of degree n, the procedure can be summarized as
P0(x) = an
Pi(x) = an−i + xPi−1(x),
i = 1, 2, . . . , n
(4.10)
leading to the algorithm
p = a[n]
for i in range(1,n+1):
p = a[n-i] + p*x
The last algorithm involves only n multiplications, making it more efﬁcient for
n > 3. But computational economy is not the prime reason why this algorithm should
be used. Because the result of each multiplication is rounded off, the procedure with
the least number of multiplications invariably accumulates the smallest roundoff
error.
Some root-ﬁnding algorithms, including Laguerre’s method, also require evalua-
tion of the ﬁrst and second derivatives of Pn(x). From Eq. (4.10) we obtain by differ-
entiation
P′
0(x) = 0
P′
i (x) = Pi−1(x) + xP′
i−1(x),
i = 1, 2, . . . , n
(4.11a)
P′′
0 (x) = 0
P′′
i (x) = 2P′
i−1(x) + xP′′
i−1(x),
i = 1, 2, . . . , n
(4.11b)

172
Roots of Equations
■evalPoly
Here is the function that evaluates a polynomial and its derivatives:
## module evalPoly
’’’ p,dp,ddp = evalPoly(a,x).
Evaluates the polynomial
p = a[0] + a[1]*x + a[2]*xˆ2 +...+ a[n]*xˆn
with its derivatives dp = p’ and ddp = p’’
at x.
’’’
def evalPoly(a,x):
n = len(a) - 1
p = a[n]
dp = 0.0 + 0.0j
ddp = 0.0 + 0.0j
for i in range(1,n+1):
ddp = ddp*x + 2.0*dp
dp = dp*x + p
p = p*x + a[n-i]
return p,dp,ddp
Deﬂation of Polynomials
After a root r of Pn(x) = 0 has been computed, it is desirable to factor the polynomial
as follows:
Pn(x) = (x −r)Pn−1(x)
(4.12)
This procedure, known as deﬂation or synthetic division, involves nothing more than
computing the coefﬁcients of Pn−1(x). Since the remaining zeros of Pn(x) are also the
zeros of Pn−1(x), the root-ﬁnding procedure can now be applied to Pn−1(x) rather than
Pn(x). Deﬂation thus makes it progressively easier to ﬁnd successive roots, because
the degree of the polynomial is reduced every time a root is found. Moreover, by
eliminating the roots that have already been found, the chances of computing the
same root more than once are eliminated.
If we let
Pn−1(x) = b0 + b1x + b2x2 + · · · + bn−1xn−1
then Eq. (4.12) becomes
a0 + a1x + a2x2 + · · · + an−1xn−1 + anxn
= (x −r)(b0 + b1x + b2x2 + · · · + bn−1xn−1)

173
4.7 Zeroes of Polynomials
Equating the coefﬁcients of like powers of x, we obtain
bn−1 = an
bn−2 = an−1 + rbn−1
· · ·
b0 = a1 + rb1
(4.13)
which leads to the Horner’s deﬂation algorithm:
b[n-1] = a[n]
for i in range(n-2,-1,-1):
b[i] = a[i+1] + r*b[i+1]
Laguerre’s Method
Laguerre’s formulas are not easily derived for a general polynomial Pn(x). However,
the derivation is greatly simpliﬁed if we consider the special case where the poly-
nomial has a zero at x = r and (n−1) zeros at x = q. Hence the polynomial can be
written as
Pn(x) = (x −r)(x −q)n−1
(a)
Our problem is now this: given the polynomial in Eq. (a) in the form
Pn(x) = a0 + a1x + a2x2 + · · · + anxn
determine r (note that q is also unknown). It turns out that the result, which is ex-
act for the special case considered here, works well as an iterative formula with any
polynomial.
Differentiating Eq. (a) with respect to x, we get
P′
n(x) = (x −q)n−1 + (n−1)(x −r)(x −q)n−2
= Pn(x)
&
1
x −r + n−1
x −q
'
Thus
P′
n(x)
Pn(x) =
1
x −r + n−1
x −q
(b)
which upon differentiation yields
P′′
n(x)
Pn(x) −
$ P′
n(x)
Pn(x)
%2
= −
1
(x −r)2 −
n−1
(x −q)2
(c)
It is convenient to introduce the notation
G(x) = P′
n(x)
Pn(x)
H(x) = G2(x) −P′′
n(x)
Pn(x)
(4.14)

174
Roots of Equations
so that Eqs. (b) and (c) become
G(x) =
1
x −r + n−1
x −q
(4.15a)
H(x) =
1
(x −r)2 +
n−1
(x −q)2
(4.15b)
If we solve Eq. (4.15a) for x −q and substitute the result into Eq. (4.15b), we obtain a
quadratic equation for x −r. The solution of this equation is the Laguerre’s formula
x −r =
n
G(x) ±

(n−1)

nH(x) −G2(x)

(4.16)
The procedure for ﬁnding a zero of a general polynomial by Laguerre’s formula is:
1.
Let x be a guess for the root of Pn(x) = 0 (any value will do).
2.
Evaluate Pn(x), P′
n(x) and P′′
n(x) using the procedure outlined in Eqs. (4.10) and
(4.11).
3.
Compute G(x) and H(x) from Eqs. (4.14).
4.
Determine the improved root r from Eq. (4.16) choosing the sign that results
in the larger magnitude of the denominator (this can be shown to improve
convergence).
5.
Let x ←r and repeat steps 2–5 until |Pn(x)| < ε or |x −r| < ε, where ε is the error
tolerance.
One nice property of Laguerre’s method is that it converges to a root, with very
few exceptions, from any starting value of x.
■polyRoots
The function polyRoots in this module computes all the roots of Pn(x) = 0, where
the polynomial Pn(x) deﬁned by its coefﬁcient array a = [a0, a1, . . . , an]. After the ﬁrst
root is computed by the nested function laguerre, the polynomial is deﬂated using
deflPoly and the next zero computed by applying laguerre to the deﬂated polyno-
mial. This process is repeated until all nroots have been found. If a computed root has
a very small imaginary part, it is very likely that it represents roundoff error. Therefore,
polyRoots replaces a tiny imaginary part by zero.
## module polyRoots
’’’ roots = polyRoots(a).
Uses Laguerre’s method to compute all the roots of
a[0] + a[1]*x + a[2]*xˆ2 +...+ a[n]*xˆn = 0.
The roots are returned in the vector {roots},

175
4.7 Zeroes of Polynomials
’’’
from evalPoly import *
from numarray import zeros,Complex64
from cmath import sqrt
from random import random
def polyRoots(a,tol=1.0e-12):
def laguerre(a,tol):
x = random()
# Starting value (random number)
n = len(a) - 1
for i in range(30):
p,dp,ddp = evalPoly(a,x)
if abs(p) < tol: return x
g = dp/p
h = g*g - ddp/p
f = sqrt((n - 1)*(n*h - g*g))
if abs(g + f) > abs(g - f): dx = n/(g + f)
else: dx = n/(g - f)
x = x - dx
if abs(dx) < tol*max(abs(x),1.0): return x
print ’Too many iterations in Laguerre’
def deflPoly(a,root):
# Deflates a polynomial
n = len(a)-1
b = [(0.0 + 0.0j)]*n
b[n-1] = a[n]
for i in range(n-2,-1,-1):
b[i] = a[i+1] + root*b[i+1]
return b
n = len(a) - 1
roots = zeros((n),type=Complex64)
for i in range(n):
x = laguerre(a,tol)
if abs(x.imag) < tol: x = x.real
roots[i] = x
a = deflPoly(a,x)
return roots
raw_input(’’\nPress return to exit’’)

176
Roots of Equations
Sincetherootsarecomputedwithﬁniteaccuracy,eachdeﬂationintroducessmall
errors in the coefﬁcients of the deﬂated polynomial. The accumulated roundoff error
increaseswiththedegreeofthepolynomialandcanbecomesevereifthepolynomialis
ill-conditioned (small changes in the coefﬁcients produce large changes in the roots).
Hence the results should be viewed with caution when dealing with polynomials of
high degree.
The errors caused by deﬂation can be reduced by recomputing each root using
the original, undeﬂated polynomial. The roots obtained previously in conjunction
with deﬂation are employed as the starting values.
EXAMPLE 4.10
A zero of the polynomial P4(x) = 3x4 −10x3 −48x2 −2x + 12 is x = 6. Deﬂate the
polynomial with Horner’s algorithm, i.e., ﬁnd P3(x) so that (x −6)P3(x) = P4(x).
Solution With r = 6 and n = 4, Eqs. (4.13) become
b3 = a4 = 3
b2 = a3 + 6b3 = −10 + 6(3) = 8
b1 = a2 + 6b2 = −48 + 6(8) = 0
b0 = a1 + 6b1 = −2 + 6(0) = −2
Therefore,
P3(x) = 3x3 + 8x2 −2
EXAMPLE 4.11
A root of the equation P3(x) = x3 −4.0x2 −4.48x + 26.1 is approximately x = 3 −i.
Find a more accurate value of this root by one application of Laguerre’s iterative
formula.
Solution Use the given estimate of the root as the starting value. Thus
x = 3 −i
x2 = 8 −6i
x3 = 18 −26i
Substituting these values in P3(x) and its derivatives, we get
P3(x) = x3 −4.0x2 −4.48x + 26.1
= (18 −26i) −4.0(8 −6i) −4.48(3 −i) + 26.1 = −1.34 + 2.48i
P′
3(x) = 3.0x2 −8.0x −4.48
= 3.0(8 −6i) −8.0(3 −i) −4.48 = −4.48 −10.0i
P′′
3 (x) = 6.0x −8.0 = 6.0(3 −i) −8.0 = 10.0 −6.0i

177
4.7 Zeroes of Polynomials
Equations (4.14) then yield
G(x) = P′
3(x)
P3(x) = −4.48 −10.0i
−1.34 + 2.48i = −2.36557 + 3.08462i
H(x) = G2(x) −P′′
3 (x)
P3(x) = (−2.36557 + 3.08462i)2 −
10.0 −6.0i
−1.34 + 2.48i
= 0.35995 −12.48452i
The term under the square root sign of the denominator in Eq. (4.16) becomes
F(x) =

(n−1)

n H(x) −G2(x)

=

2

3(0.35995 −12.48452i) −(−2.36557 + 3.08462i)2
=
√
5.67822 −45.71946i = 5.08670 −4.49402i
Now we must ﬁnd which sign in Eq. (4.16) produces the larger magnitude of the
denominator:
|G(x) + F(x)| = |(−2.36557 + 3.08462i) + (5.08670 −4.49402i)|
= |2.72113 −1.40940i| = 3.06448
|G(x) −F(x)| = |(−2.36557 + 3.08462i) −(5.08670 −4.49402i)|
= |−7.45227 + 7.57864i| = 10.62884
Usingtheminussign,weobtainfromEq.(4.16)thefollowingimprovedapproximation
for the root
r = x −
n
G(x) −F(x) = (3 −i) −
3
−7.45227 + 7.57864i
= 3.19790 −0.79875i
Thanks to the good starting value, this approximation is already quite close to the
exact value r = 3.20 −0.80i.
EXAMPLE 4.12
Use polyRoots to compute all the roots of x4 −5x3 −9x2 + 155x −250 = 0.
Solution The commands
>>> from polyRoots import *
>>> print polyRoots([-250.0,155.0,-9.0,-5.0,1.0])
resulted in the output
[2.+0.j
4.-3.j
4.+3.j -5.+0.j]

178
Roots of Equations
PROBLEM SET 4.2
Problems 1–5 A zero x = r of Pn(x) is given. Verify that r is indeed a zero, and then
deﬂate the polynomial, i.e., ﬁnd Pn−1(x) so that Pn(x) = (x −r)Pn−1(x).
1. P3(x) = 3x3 + 7x2 −36x + 20, r = −5.
2. P4(x) = x4 −3x2 + 3x −1, r = 1.
3. P5(x) = x5 −30x4 + 361x3 −2178x2 + 6588x −7992, r = 6.
4. P4(x) = x4 −5x3 −2x2 −20x −24, r = 2i.
5. P3(x) = 3x3 −19x2 + 45x −13, r = 3 −2i.
Problems 6–9 A zero x = r of Pn(x) is given. Determine all the other zeros of Pn(x)
by using a calculator. You should need no tools other than deﬂation and the quadratic
formula.
6. P3(x) = x3 + 1.8x2 −9.01x −13.398, r = −3.3.
7. P3(x) = x3 −6.64x2 + 16.84x −8.32, r = 0.64.
8. P3(x) = 2x3 −13x2 + 32x −13, r = 3 −2i.
9. P4(x) = x4 −3x3 + 10x2 −6x −20, r = 1 + 3i.
Problems 10–15 Find all the zeros of the given Pn(x).
10. ■P4(x) = x4 + 2.1x3 −2.52x2 + 2.1x −3.52.
11. ■P5(x) = x5 −156x4 −5x3 + 780x2 + 4x −624.
12. ■P6(x) = x6 + 4x5 −8x4 −34x3 + 57x2 + 130x −150.
13. ■P7(x) = 8x7 + 28x6 + 34x5 −13x4 −124x3 + 19x2 + 220x −100.
14. ■P8(x) = x8 −7x7 + 7x6 + 25x5 + 24x4 −98x3 −472x2 + 440x + 800.
15. ■P4(x) = x4 + (5 + i)x3 −(8 −5i)x2 + (30 −14i)x −84.
16. ■
k
m
m
c
x
x
1
2
k

179
4.8 Other Methods
The two blocks of mass m each are connected by springs and a dashpot. The
stiffness of each spring is k, and c is the coefﬁcient of damping of the dashpot.
Whenthesystemisdisplacedandreleased,thedisplacementofeachblockduring
the ensuing motion has the form
xk(t) = Akeωrt cos(ωit + φk), k = 1, 2
where Ak and φk are constants, and ω = ωr ± iωi are the roots of
ω4 + 2 c
mω3 + 3 k
mω2 + c
m
k
mω +
& k
m
'2
= 0
Determine the two possible combinations of ωr and ωi if c/m= 12 s−1 and k/m=
1500 s−2.
4.8
Other Methods
The most prominent root-ﬁnding algorithms omitted from this chapter are the secant
method and its close relative, the false position method. Both methods compute the
improvedvalue of the root by linear interpolation. They differ only by how they choose
the points involved in the interpolation. The secant method always uses the two most
recentestimatesoftheroot,whereasthefalsepositionmethodemploysthepointsthat
keep the root bracketed. The secant method is faster of the two, but the false position
method is more stable. Since both are considerably slower than Brent’s method, there
is little reason to use them.
There are many methods for ﬁnding zeros of polynomials. Of these, the Jenkins–
Traub algorithm11 deserves special mention due to its robustness and widespread use
in packaged software.
The zeros of a polynomial can also be obtained by calculating the eigenvalues of
the n× n “companion matrix”
A =


−an−1/an
−a2/an
· · ·
−a1/an
−a0/an
1
0
· · ·
0
0
0
1
0
0
...
...
...
...
...
0
0
· · ·
1
0


11 Jenkins, M., and Traub, J., SIAM Journal on Numerical Analysis, Vol. 7 (1970), p. 545.

180
Roots of Equations
where ai are the coefﬁcients of the polynomial. The characteristic equation (see
Section 9.1) of this matrix is
xn + an−1
an
xn−1 + an−2
an
xn−2 + · · · + a1
an
x + a0
an
= 0
which is equivalent to Pn(x) = 0. Thus the eigenvalues of A are the zeroes of Pn(x). The
eigenvalue method is robust, but considerably slower than Laguerre’s method. But it
is worthy of consideration if a good program for eigenvalue problems is available.

5
Numerical Differentiation
Given the function f (x), compute dn f/dxn at given x
5.1
Introduction
Numerical differentiation deals with the following problem: we are given the function
y = f (x) and wish to obtain one of its derivatives at the point x = xk. The term “given”
means that we either have an algorithm for computing the function, or possess a
set of discrete data points (xi, yi), i = 0, 1, . . . , n. In either case, we have access to a
ﬁnite number of (x, y) data pairs from which to compute the derivative. If you suspect
by now that numerical differentiation is related to interpolation, you are right—one
means of ﬁnding the derivative is to approximate the function locally by a polynomial
and then differentiate it. An equally effective tool is the Taylor series expansion of f (x)
about the point xk, which has the advantage of providing us with information about
the error involved in the approximation.
Numerical differentiation is not a particularly accurate process. It suffers from
a conﬂict between roundoff errors (due to limited machine precision) and errors
inherent in interpolation. For this reason, a derivative of a function can never be
computed with the same precision as the function itself.
5.2
Finite Difference Approximations
The derivation of the ﬁnite difference approximations for the derivatives of f (x) is
based on forward and backward Taylor series expansions of f (x) about x, such as
181

182
Numerical Differentiation
f (x + h) = f (x) + hf ′(x) + h2
2! f ′′(x) + h3
3! f ′′′(x) + h4
4! f (4)(x) + · · ·
(a)
f (x −h) = f (x) −hf ′(x) + h2
2! f ′′(x) −h3
3! f ′′′(x) + h4
4! f (4)(x) −· · ·
(b)
f (x + 2h) = f (x) + 2hf ′(x) + (2h)2
2!
f ′′ (x) + (2h)3
3!
f ′′′(x) + (2h)4
4!
f (4)(x) + · · ·
(c)
f (x −2h) = f (x) −2hf ′(x) + (2h)2
2!
f ′′ (x) −(2h)3
3!
f ′′′(x) + (2h)4
4!
f (4)(x) −· · ·
(d)
We also record the sums and differences of the series:
f (x + h) + f (x −h) = 2 f (x) + h2 f ′′(x) + h4
12 f (4)(x) + · · ·
(e)
f (x + h) −f (x −h) = 2hf ′(x) + h3
3 f ′′′(x) + · · ·
(f)
f (x + 2h) + f (x −2h) = 2 f (x) + 4h2 f ′′(x) + 4h4
3
f (4)(x) + · · ·
(g)
f (x + 2h) −f (x −2h) = 4hf ′(x) + 8h3
3
f ′′′(x) + · · ·
(h)
Note that the sums contain only even derivatives, whereas the differences retain just
the odd derivatives. Equations (a)–(h) can be viewed as simultaneous equations that
can be solved for various derivatives of f (x). The number of equations involved and
the number of terms kept in each equation depend on the order of the derivative and
the desired degree of accuracy.
First Central Difference Approximations
The solution of Eq. (f) for f ′(x) is
f ′(x) = f (x + h) −f (x −h)
2h
−h2
6 f ′′′(x) −· · ·
or
f ′(x) = f (x + h) −f (x −h)
2h
+ O(h2)
(5.1)
which is called the ﬁrst central difference approximation for f ′(x). The term O(h2)
reminds us that the truncation error behaves as h2.

183
5.2 Finite Difference Approximations
Similarly, Eq. (e) yields the ﬁrst central difference approximation for f ′′(x):
f ′′(x) = f (x + h) −2 f (x) + f (x −h)
h2
+ h2
12 f (4)(x) + · · ·
or
f ′′(x) = f (x + h) −2 f (x) + f (x −h)
h2
+ O(h2)
(5.2)
Central difference approximations for other derivatives can be obtained from
Eqs. (a)–(h) in the same manner. For example, eliminating f ′(x) from Eqs. (f) and (h)
and solving for f ′′′(x) yield
f ′′′(x) = f (x + 2h) −2 f (x + h) + 2 f (x −h) −f (x −2h)
2h3
+ O(h2)
(5.3)
The approximation
f (4)(x) = f (x + 2h) −4 f (x + h) + 6 f (x) −4 f (x −h) + f (x −2h)
h4
+ O(h2)
(5.4)
is available from Eqs. (e) and (g) after eliminating f ′′(x). Table 5.1 summarizes the
results.
f (x −2h)
f (x −h)
f (x)
f (x + h)
f (x + 2h)
2hf ′(x)
−1
0
1
h2 f ′′(x)
1
−2
1
2h3 f ′′′(x)
−1
2
0
−2
1
h4 f (4)(x)
1
−4
6
−4
1
Table 5.1. Coefﬁcients of central ﬁnite difference approximations
of O(h2)
First Noncentral Finite Difference Approximations
Central ﬁnite difference approximations are not always usable. For example, con-
sider the situation where the function is given at the n discrete points x0, x1, . . . , xn.
Since central differences use values of the function on each side of x, we would
be unable to compute the derivatives at x0 and xn. Clearly, there is a need for ﬁ-
nite difference expressions that require evaluations of the function only on one
side of x. These expressions are called forward and backward ﬁnite difference
approximations.

184
Numerical Differentiation
NoncentralﬁnitedifferencescanalsobeobtainedfromEqs.(a)–(h).SolvingEq.(a)
for f ′(x) we get
f ′(x) = f (x + h) −f (x)
h
−h
2 f ′′(x) −h2
6 f ′′′(x) −h3
4! f (4)(x) −· · ·
Keeping only the ﬁrst term on the right-hand side leads to the ﬁrst forward difference
approximation
f ′(x) = f (x + h) −f (x)
h
+ O(h)
(5.5)
Similarly, Eq. (b) yields the ﬁrst backward difference approximation
f ′(x) = f (x) −f (x −h)
h
+ O(h)
(5.6)
Note that the truncation error is now O(h), which is not as good as O(h2) in central
difference approximations.
We can derive the approximations for higher derivatives in the same manner. For
example, Eqs. (a) and (c) yield
f ′′(x) = f (x + 2h) −2 f (x + h) + f (x)
h2
+ O(h)
(5.7)
The third and fourth derivatives can be derived in a similar fashion. The results are
shown in Tables 5.2a and 5.2b.
f (x)
f (x + h)
f (x + 2h)
f (x + 3h)
f (x + 4h)
hf ′(x)
−1
1
h2 f ′′(x)
1
−2
1
h3 f ′′′(x)
−1
3
−3
1
h4 f (4)(x)
1
−4
6
−4
1
Table 5.2a. Coefﬁcients of forward ﬁnite difference approximations
of O(h)
f (x −4h)
f (x −3h)
f (x −2h)
f (x −h)
f (x)
hf ′(x)
−1
1
h2 f ′′(x)
1
−2
1
h3 f ′′′(x)
−1
3
−3
1
h4 f (4)(x)
1
−4
6
−4
1
Table 5.2b. Coefﬁcients of backward ﬁnite difference approxima-
tions of O(h)

185
5.2 Finite Difference Approximations
Second Noncentral Finite Difference Approximations
Finite difference approximations of O(h) are not popular due to reasons that will be
explained shortly. The common practice is to use expressions of O(h2). To obtain
noncentral difference formulas of this order, we have to retain more terms in the
Taylor series. As an illustration, we will derive the expression for f ′(x). We start with
Eqs. (a) and (c), which are
f (x + h) = f (x) + hf ′(x) + h2
2 f ′′(x) + h3
6 f ′′′(x) + h4
24 f (4)(x) + · · ·
f (x + 2h) = f (x) + 2hf ′(x) + 2h2 f ′′ (x) + 4h3
3
f ′′′(x) + 2h4
3
f (4)(x) + · · ·
We eliminate f ′′(x) by multiplying the ﬁrst equation by 4 and subtracting it from the
second equation. The result is
f (x + 2h) −4 f (x + h) = −3 f (x) −2hf ′(x) + 2h3
3
f ′′′(x) + · · ·
Therefore,
f ′(x) = −f (x + 2h) + 4 f (x + h) −3 f (x)
2h
+ h2
3 f ′′′(x) + · · ·
or
f ′(x) = −f (x + 2h) + 4 f (x + h) −3 f (x)
2h
+ O(h2)
(5.8)
Equation (5.8) is called the second forward ﬁnite difference approximation.
Derivation of ﬁnite difference approximations for higher derivatives involve ad-
ditional Taylor series. Thus the forward difference approximation for f ′′(x) utilizes
series for f (x + h), f (x + 2h) and f (x + 3h); the approximation for f ′′′(x) involves
Taylor expansions for f (x + h), f (x + 2h), f (x + 3h) and f (x + 4h), etc. As you can see,
the computations for high-order derivatives can become rather tedious. The results
for both the forward and backward ﬁnite differences are summarized in Tables 5.3a
and 5.3b.
f (x)
f (x + h)
f (x + 2h)
f (x + 3h)
f (x + 4h)
f (x + 5h)
2hf ′(x)
−3
4
−1
h2 f ′′(x)
2
−5
4
−1
2h3 f ′′′(x)
−5
18
−24
14
−3
h4 f (4)(x)
3
−14
26
−24
11
−2
Table 5.3a. Coefﬁcients of forward ﬁnite difference approximations of O(h2)

186
Numerical Differentiation
f (x −5h)
f (x −4h)
f (x −3h)
f (x −2h)
f (x −h)
f (x)
2hf ′(x)
1
−4
3
h2 f ′′(x)
−1
4
−5
2
2h3 f ′′′(x)
3
−14
24
−18
5
h4 f (4)(x)
−2
11
−24
26
−14
3
Table 5.3b. Coefﬁcients of backward ﬁnite difference approximations of O(h2)
Errors in Finite Difference Approximations
Observe that in all ﬁnite difference expressions the sum of the coefﬁcients is zero.
The effect on the roundoff error can be profound. If h is very small, the values of f (x),
f (x ± h), f (x ± 2h) etc. will be approximately equal. When they are multiplied by the
coefﬁcients and added, several signiﬁcant ﬁgures can be lost. On the other hand, we
cannot make h too large, because then the truncation error would become excessive.
This unfortunate situation has no remedy, but we can obtain some relief by taking
the following precautions:
r Use double-precision arithmetic.
r Employ ﬁnite difference formulas that are accurate to at least O(h2).
To illustrate the errors, let us compute the second derivative of f (x) = e−x at x = 1
from the central difference formula, Eq. (5.2). We carry out the calculations with six-
and eight-digit precision, using different values of h. The results, shown in Table 5.4,
should be compared with f ′′(1) = e−1 = 0.367 879 44.
h
6-digit precision
8-digit precision
0.64
0.380 610
0.380 609 11
0.32
0.371 035
0.371 029 39
0.16
0.368 711
0.368 664 84
0.08
0.368 281
0.368 076 56
0.04
0.368 75
0.367 831 25
0.02
0.37
0.3679
0.01
0.38
0.3679
0.005
0.40
0.3676
0.0025
0.48
0.3680
0.00125
1.28
0.3712
Table 5.4. (e−x)′′ at x = 1 from central ﬁnite dif-
ference approximation

187
5.3 Richardson Extrapolation
In the six-digit computations, the optimal value of h is 0.08, yielding a result
accurate to three signiﬁcant ﬁgures. Hence three signiﬁcant ﬁgures are lost due to
a combination of truncation and roundoff errors. Above optimal h, the dominant
error is due to truncation; below it, the roundoff error becomes pronounced. The
best result obtained with the eight-digit computation is accurate to four signiﬁcant
ﬁgures. Because the extra precision decreases the roundoff error, the optimal h is
smaller (about 0.02) than in the six-ﬁgure calculations.
5.3
Richardson Extrapolation
Richardson extrapolation is a simple method for boosting the accuracy of certain
numerical procedures, including ﬁnite difference approximations (we also use it later
in other applications).
Suppose that we have an approximate means of computing some quantity G.
Moreover, assume that the result depends on a parameter h. Denoting the approxi-
mation by g(h), we have G = g(h) + E(h), where E(h) represents the error. Richardson
extrapolation can remove the error, provided that it has the form E(h) = chp, c and p
being constants. We start by computing g(h) with some value of h, say h = h1. In that
case we have
G = g(h1) + chp
1
(i)
Then we repeat the calculation with h = h2, so that
G = g(h2) + chp
2
(j)
Eliminating c and solving for G, we obtain from Eqs. (i) and (j)
G = (h1/h2)pg(h2) −g(h1)
(h1/h2)p −1
(5.9a)
whichistheRichardsonextrapolationformula.Itiscommonpracticetouseh2 = h1/2,
in which case Eq. (5.9a) becomes
G = 2pg(h1/2) −g(h1)
2p −1
(5.9b)
Let us illustrate Richardson extrapolation by applying it to the ﬁnite differ-
ence approximation of (e−x)′′ at x = 1. We work with six-digit precision and uti-
lize the results in Table 5.4. Since the extrapolation works only on the truncation
error, we must conﬁne h to values that produce negligible roundoff. In Table 5.4
we have
g(0.64) = 0.380 610
g(0.32) = 0.371 035

188
Numerical Differentiation
The truncation error in the central difference approximation is E(h) = O(h2) = c1h2 +
c2h4 + c3h6 + · · · · Therefore, we can eliminate the ﬁrst (dominant) error term if we
substitute p = 2 and h1 = 0.64 in Eq. (5.9b). The result is
G = 22g(0.32) −g(0.64)
22 −1
= 4(0.371 035) −0.380 610
3
= 0. 367 84 3
which is an approximation of (e−x)′′ with the error O(h4). Note that it is as accurate as
the best result obtained with eight-digit computations in Table 5.4.
EXAMPLE 5.1
Given the evenly spaced data points
x
0
0.1
0.2
0.3
0.4
f (x)
0.0000
0.0819
0.1341
0.1646
0.1797
compute f ′(x) and f ′′(x) at x = 0 and 0.2 using ﬁnite difference approximations of
O(h2).
Solution We will use ﬁnite difference approximations of O(h2). From the forward
difference tables in Table 5.3a we get
f ′(0) = −3 f (0) + 4 f (0.1) −f (0.2)
2(0.1)
= −3(0) + 4(0.0819) −0.1341
0.2
= 0.967
f ′′(0) = 2 f (0) −5 f (0.1) + 4 f (0.2) −f (0.3)
(0.1)2
= 2(0) −5(0.0819) + 4(0.1341) −0.1646
(0.1)2
= −3.77
The central difference approximations in Table 5.1 yield
f ′(0.2) = −f (0.1) + f (0.3)
2(0.1)
= −0.0819 + 0.1646
0.2
= 0.4135
f ′′(0.2) = f (0.1) −2 f (0.2) + f (0.3)
(0.1)2
= 0.0819 −2(0.1341) + 0.1646
(0.1)2
= −2.17
EXAMPLE 5.2
Use the data in Example 5.1 to compute f ′(0) as accurately as you can.
Solution One solution is to apply Richardson extrapolation to ﬁnite difference ap-
proximations. We start with two forward difference approximations of O(h2) for f ′(0):
one using h = 0.2 and the other one using h = 0.1. Referring to the formulas of O(h2)

189
5.3 Richardson Extrapolation
in Table 5.3a, we get
g(0.2) = −3 f (0) + 4 f (0.2) −f (0.4)
2(0.2)
= 3(0) + 4(0.1341) −0.1797
0.4
= 0.8918
g(0.1) = −3 f (0) + 4 f (0.1) −f (0.2)
2(0.1)
= −3(0) + 4(0.0819) −0.1341
0.2
= 0.9675
Recall that the error in both approximations is of the form E(h) = c1h2 + c2h4 +
c3h6 + · · · . We can now use Richardson extrapolation, Eq. (5.9), to eliminate the dom-
inant error term. With p = 2 we obtain
f ′(0) ≈G = 22g(0.1) −g(0.2)
22 −1
= 4(0.9675) −0.8918
3
= 0.9927
which is a ﬁnite difference approximation of O(h4˙).
EXAMPLE 5.3
α
β
A
B
C
D
a
b
c
d
The linkage shown has the dimensions a = 100 mm, b = 120 mm, c = 150 mm
and d = 180 mm. It can be shown by geometry that the relationship between the
angles α and β is
(d −a cos α −bcos β)2 + (a sin α + bsin β)2 −c2 = 0
For a given value of α, we can solve this transcendental equation for β by one of the
root-ﬁnding methods in Chapter 4. This was done with α = 0◦, 5◦, 10◦, . . . , 30◦, the
results being
α (deg)
0
5
10
15
20
25
30
β (rad)
1.6595
1.5434
1.4186
1.2925
1.1712
1.0585
0.9561
If link AB rotates with the constant angular velocity of 25 rad/s, use ﬁnite difference
approximations of O(h2) to tabulate the angular velocity dβ/dt of link BC against α.
Solution The angular speed of BC is
dβ
dt = dβ
dα
dα
dt = 25dβ
dα rad/s

190
Numerical Differentiation
where dβ/dα can be computed from ﬁnite difference approximations using the data
in the table. Forward and backward differences of O(h2) are used at the endpoints,
central differences elsewhere. Note that the increment of α is
h =

5 deg
 , π
180rad/deg
-
= 0.087 266 rad
The computations yield
˙β(0◦) = 25−3β(0◦) + 4β(5◦) −β(10◦)
2h
= 25−3(1.6595) + 4(1.5434) −1.4186
2 (0.087 266)
= −32.01 rad/s
˙β(5◦) = 25β(10◦) −β(0◦)
2h
= 251.4186 −1.6595
2(0.087 266)
= −34.51 rad/s
etc.
The complete set of results is
α (deg)
0
5
10
15
20
25
30
˙β (rad/s)
−32.01
−34.51
−35.94
−35.44
−33.52
−30.81
−27.86
5.4
Derivatives by Interpolation
If f (x) is given as a set of discrete data points, interpolation can be a very effective
means of computing its derivatives. The idea is to approximate the derivative of f (x)
bythederivativeoftheinterpolant.Thismethodisparticularlyusefulifthedatapoints
are located at uneven intervals of x, when the ﬁnite difference approximations listed
in the last article are not applicable.12
Polynomial Interpolant
The idea here is simple: ﬁt the polynomial of degree n
Pn−1(x) = a0 + a1x + a2x2 + · · · + anxn
through n+ 1 data points and then evaluate its derivatives at the given x. As pointed
out in Section 3.2, it is generally advisable to limit the degree of the polynomial to
less than six in order to avoid spurious oscillations of the interpolant. Since these
oscillations are magniﬁed with each differentiation, their effect can devastating. In
12 It is possible to derive ﬁnite difference approximations for unevenly spaced data, but they would
not be as accurate as the formulas derived in Section 5.2.

191
5.4 Derivatives by Interpolation
view of the above limitation, the interpolation is usually a local one, involving no more
than a few nearest-neighbor data points.
For evenly spaced data points, polynomial interpolation and ﬁnite difference
approximations produce identical results. In fact, the ﬁnite difference formulas are
equivalent to polynomial interpolation.
Several methods of polynomial interpolation were introduced in Section 3.2. Un-
fortunately, none of them is suited for the computation of derivatives of the inter-
polant. The method that we need is one that determines the coefﬁcients a0, a1, . . . , an
of the polynomial. There is only one such method discussed in Chapter 3: the least-
squares ﬁt. Although this method is designed mainly for smoothing of data, it will
carry out interpolation if we use m= nin Eq. (3.22)—recall that mis the degree of the
interpolating polynomial and n+ 1 represents the number of data points to be ﬁtted.
If the data contains noise, then the least-squares ﬁt should be used in the smoothing
mode, that is, with m< n. After the coefﬁcients of the polynomial have been found,
the polynomial and its ﬁrst two derivatives can be evaluated efﬁciently by the function
evalPoly listed in Section 4.7.
Cubic Spline Interpolant
Due to its stiffness, cubic spline is a good global interpolant; moreover, it is easy to
differentiate. The ﬁrst step is to determine the second derivatives ki of the spline at
the knots by solving Eqs. (3.11). This can be done with the function curvatures in
the module cubicSpline listed in Section 3.3. The ﬁrst and second derivatives are
then computed from
f ′
i,i+1(x) = ki
6
$3(x −xi+1)2
xi −xi+1
−(xi −xi+1)
%
−ki+1
6
$3(x −xi)2
xi −xi+1
−(xi −xi+1)
%
+ yi −yi+1
xi −xi+1
(5.10)
f ′′
i,i+1(x) = ki
x −xi+1
xi −xi+1
−ki+1
x −xi
xi −xi+1
(5.11)
which are obtained by differentiation of Eq. (3.10).
EXAMPLE 5.4
Given the data
x
1.5
1.9
2.1
2.4
2.6
3.1
f (x)
1.0628
1.3961
1.5432
1.7349
1.8423
2.0397

192
Numerical Differentiation
compute f ′(2) and f ′′(2) using (1) polynomial interpolation over three nearest-
neighbor points, and (2) natural cubic spline interpolant spanning all the data
points.
Solution of Part (1) The interpolant is P2(x) = a0 + a1x + a2x2 passing through the
points at x = 1.9, 2.1 and 2.4. The normal equations, Eqs. (3.23), of the least-squares
ﬁt are


n
 xi
 x2
i
 xi
 x2
i
 x3
i
 x2
i
 x3
i
 x4
i




a0
a1
a2

=


 yi
 yixi
 yix2
i


After substituting the data, we get


3
6.4
13.78
6.4
13.78
29.944
13.78
29.944
65.6578




a0
a1
a2

=


4.6742
10.0571
21.8385


which yields a =

−0.7714
1.5075
−0.1930
T
.
The derivatives of the interpolant are P′
2(x) = a1 + 2a2x and P′′
2 (x) = 2a2.
Therefore,
f ′(2) ≈P′
2(2) = 1.5075 + 2(−0.1930)(2) = 0.7355
f ′′(2) ≈P′′
2 (2) = 2(−0.1930) = −0.3860
Solution of Part (2) We must ﬁrst determine the second derivatives ki of the spline
at its knots, after which the derivatives of f (x) can be computed from Eqs. (5.10) and
(5.11). The ﬁrst part can be carried out by the following small program:
#!/usr/bin/python
## example5_4
from cubicSpline import curvatures
from LUdecomp3 import *
from numarray import array
xData = array([1.5, 1.9, 2.1, 2.4, 2.6, 3.1])
yData = array([1.0628, 1.3961, 1.5432, 1.7349, 1.8423, 2.0397])
print curvatures(LUdecomp3,LUsolve3,xData,yData)
raw_input(’’Press return to exit’’)
The output of the program, consisting of k0 to k5, is
[ 0.
-0.4258431 -0.37744139 -0.38796663 -0.55400477
0.
]
Press return to exit

193
5.4 Derivatives by Interpolation
Since x = 2 lies between knots 1 and 2, we must use Eqs. (5.10) and (5.11) with
i = 1. This yields
f ′(2) ≈f ′
1,2(2) = k1
6
$3(x −x2)2
x1 −x2
−(x1 −x2)
%
−k2
6
$3(x −x1)2
x1 −x2
−(x1 −x2)
%
+ y1 −y2
x1 −x2
= (−0.4258)
6
$3(2 −2.1)2
(−0.2)
−(−0.2)
%
−(−0.3774)
6
$3(2 −1.9)2
(−0.2)
−(−0.2)
%
+ 1.3961 −1.5432
(−0.2)
= 0.7351
f ′′(2) ≈f ′′
1,2(2) = k1
x −x2
x1 −x2
−k2
x −x1
x1 −x2
= (−0.4258) 2 −2.1
(−0.2) −(−0.3774)2 −1.9
(−0.2) = −0. 4016
Note that the solutions for f ′(2) in parts (1) and (2) differ only in the fourth signiﬁcant
ﬁgure, but the values of f ′′(2) are much farther apart. This is not unexpected, consid-
ering the general rule: the higher the order of the derivative, the lower the precision
with which it can be computed. It is impossible to tell which of the two results is
better without knowing the expression for f (x). In this particular problem, the data
points fall on the curve f (x) = x2e−x/2, so that the “true” values of the derivatives are
f ′(2) = 0.7358 and f ′′(2) = −0.3679.
EXAMPLE 5.5
Determine f ′(0) and f ′(1) from the following noisy data
x
0
0.2
0.4
0.6
f (x)
1.9934
2.1465
2.2129
2.1790
x
0.8
1.0
1.2
1.4
f (x)
2.0683
1.9448
1.7655
1.5891
Solution We used the program listed in Example 3.10 to ﬁnd the best polynomial ﬁt
(in the least-squares sense) to the data. The program was run three times with the
following results:
Degree of polynomial ==> 2
Coefficients are:
[2.0261875
0.64703869 -0.70239583]

194
Numerical Differentiation
Std. deviation = 0.0360968935809
Degree of polynomial ==> 3
Coefficients are:
[1.99215
1.09276786 -1.55333333
0.40520833]
Std. deviation = 0.0082604082973
Degree of polynomial ==> 4
Coefficients are:
[1.99185568
1.10282373 -1.59056108
0.44812973 -0.01532907]
Std. deviation = 0.00951925073521
Degree of polynomial ==>
Finished. Press return to exit
Based on standard deviation, the cubic seems to be the best candidate for the
interpolant. Before accepting the result, we compare the plots of the data points and
the interpolant—see the ﬁgure. The ﬁt does appear to be satisfactory
x
0.00
0.20
0.40
0.60
0.80
1.00
1.20
1.40
f (x)
1.5
1.6
1.7
1.8
1.9
2.0
2.1
2.2
2.3
Approximating f (x) by the interpolant, we have
f (x) ≈a0 + a1x + a2x2 + a3x3
so that
f ′(x) ≈a1 + 2a2x + 3a3x2
Therefore,
f ′(0) ≈a1 = 1.093
f ′(1) = a1 + 2a2 + 3a3 = 1.093 + 2(−1.553) + 3(0.405) = −0. 798

195
5.4 Derivatives by Interpolation
Ingeneral,derivativesobtainedfromnoisydataareatbestroughapproximations.
In this problem, the data represent f (x) = (x + 2)/ cosh x with added random noise.
Thus f ′(x) =

1 −(x + 2) tanh x

/ cosh x, so that the “correct” derivatives are f ′(0) =
1.000 and f ′(1) = −0.833.
PROBLEM SET 5.1
1. Given the values of f (x) at the points x, x −h1 and x + h2, where h1 ̸= h2, de-
termine the ﬁnite difference approximation for f ′′(x). What is the order of the
truncation error?
2. Given the ﬁrst backward ﬁnite difference approximations for f ′(x) and f ′′(x),
derive the ﬁrst backward ﬁnite difference approximation for f ′′′(x) using the
operation f ′′′(x) =

f ′′(x)
′.
3. Derive the central difference approximation for f ′′(x) accurate to O(h4) by apply-
ing Richardson extrapolation to the central difference approximation of O(h2).
4. Derive the second forward ﬁnite difference approximation for f ′′′(x) from the
Taylor series.
5. Derive the ﬁrst central difference approximation for f (4)(x) from the Taylor series.
6. Use ﬁnite difference approximations of O(h2) to compute f ′(2.36) and f ′′(2.36)
from the data
x
2.36
2.37
2.38
2.39
f (x)
0.85866
0.86289
0.86710
0.87129
7. Estimate f ′(1) and f ′′(1) from the following data:
x
0.97
1.00
1.05
f (x)
0.85040
0.84147
0.82612
8. Given the data
x
0.84
0.92
1.00
1.08
1.16
f (x)
0.431711
0.398519
0.367879
0.339596
0.313486
calculate f ′′(1) as accurately as you can.

196
Numerical Differentiation
9. Use the data in the table to compute f ′(0.2) as accurately as possible.
x
0
0.1
0.2
0.3
0.4
f (x)
0.000 000
0.078 348
0.138 910
0.192 916
0.244 981
10. Using ﬁve signiﬁcant ﬁgures in the computations, determine d(sin x)/dx at
x = 0.8 from (a) the ﬁrst forward difference approximation and (b) the ﬁrst central
difference approximation. In each case, use h that gives the most accurate result
(this requires experimentation).
11. ■Use polynomial interpolation to compute f ′ and f ′′ at x = 0, using the data
x
−2.2
−0.3
0.8
1.9
f (x)
15.180
10.962
1.920
−2.040
12. ■
θ
R
2.5R
A
B
C
x
The crank AB of length R = 90 mm is rotating at the constant angular speed of
dθ/dt = 5000 rev/min. The position of the piston C can be shown to vary with the
angle θ as
x = R
&
cos θ +

2.52 −sin2 θ
'
Writeaprogramthatcomputestheaccelerationofthepistonat θ = 0◦,5◦,10◦,. . . ,
180◦by numerical differentiation.
13. ■
γ
α
β
C
v
y
x
a
A
B

197
5.4 Derivatives by Interpolation
The radar stations A and B, separated by the distance a = 500 m, track the plane
C by recording the angles α and β at one-second intervals. If three successive
readings are
t (s)
9
10
11
α
54.80◦
54.06◦
53.34◦
β
65.59◦
64.59◦
63.62◦
calculatethespeedvoftheplaneandtheclimbangleγ att = 10s.Thecoordinates
of the plane can be shown to be
x = a
tan β
tan β −tan α
y = a tan α tan β
tan β −tan α
14. ■
β
θ
α
B
A
D
C
20
70
190
190
60
Dimensions
in mm
Geometric analysis of the linkage shown resulted in the following table relating
the angles θ and β:
θ (deg)
0
30
60
90
120
150
β (deg)
59.96
56.42
44.10
25.72
−0.27
−34.29
Assuming that member AB of the linkage rotates with the constant angular ve-
locity dθ/dt = 1 rad/s, compute dβ/dt in rad/s at the tabulated values of θ. Use
cubic spline interpolation.

6
Numerical Integration
Compute
. b
a f (x) dx, where f (x) is a given function
6.1
Introduction
Numerical integration, also known as quadrature, is intrinsically a much more accu-
rate procedure than numerical differentiation. Quadrature approximates the deﬁnite
integral
/ b
a
f (x) dx
by the sum
I =
n

i=0
Ai f (xi)
where the nodal abscissas xi and weights Ai depend on the particular rule used for the
quadrature. All rules of quadrature are derived from polynomial interpolation of the
integrand. Therefore, they work best if f (x) can be approximated by a polynomial.
Methods of numerical integration can be divided into two groups: Newton–Cotes
formulas and Gaussian quadrature. Newton–Cotes formulas are characterized by
equally spaced abscissas, and include well-known methods such as the trapezoidal
rule and Simpson’s rule. They are most useful if f (x) has already been computed at
equal intervals, or can be computed at low cost. Since Newton–Cotes formulas are
based on local interpolation, they require only a piecewise ﬁt to a polynomial.
In Gaussian quadrature the locations of the abscissas are chosen to yield the best
possible accuracy. Because Gaussian quadrature requires fewer evaluations of the in-
tegrand for a given level of precision, it is popular in cases where f (x) is expensive
198

199
6.2 Newton–Cotes Formulas
to evaluate. Another advantage of Gaussian quadrature is its ability to handle inte-
grable singularities, enabling us to evaluate expressions such as
/ 1
0
g(x)
√
1 −x2 dx
provided that g(x) is a well-behaved function.
6.2
Newton–Cotes Formulas
x0
x1
x2
x3
xn
xn-1
h
a
b
f (x)
Pn(x)
x
Figure 6.1. Polynomial approximation of f (x).
Consider the deﬁnite integral
/ b
a
f (x) dx
(6.1)
We divide the range of integration (a, b) into nequal intervals of length h = (b −a)/n,
as shown in Fig. 6.1, and denote the abscissas of the resulting nodes by x0, x1, . . . , xn.
Next we approximate f (x) by a polynomial of degree n that intersects all the nodes.
Lagrange’s form of this polynomial, Eq. (3.1a), is
Pn(x) =
n

i=0
f (xi)ℓi(x)
where ℓi(x) are the cardinal functions deﬁned in Eq. (3.1b). Therefore, an approxima-
tion to the integral in Eq. (6.1) is
I =
/ b
a
Pn(x)dx =
n

i=0
$
f (xi)
/ b
a
ℓi(x)dx
%
=
n

i=0
Ai f (xi)
(6.2a)
where
Ai =
/ b
a
ℓi(x)dx,
i = 0, 1, . . . , n
(6.2b)
Equations (6.2) are the Newton–Cotes formulas. Classical examples of these formu-
las are the trapezoidal rule (n = 1), Simpson’s rule (n = 2) and Simpson’s 3/8 rule
(n = 3). The most important of these is the trapezoidal rule. It can be combined with
Richardson extrapolation into an efﬁcient algorithm known as Romberg integration,
which makes the other classical rules somewhat redundant.

200
Numerical Integration
Trapezoidal Rule
E
f(x)
x  = a
x  = b x
h
0
Area=I
1
Figure 6.2. Trapezoidal rule.
If n = 1 (one panel), as illustrated in Fig. 6.2, we have ℓ0 = (x −x1)/(x0 −x1) =
−(x −b)/h. Therefore,
A0 = 1
h
/ b
a
(x −b) dx = 1
2h(b −a)2 = h
2
Also ℓ1 = (x −x0)/(x1 −x0) = (x −a)/h, so that
A1 = 1
h
/ b
a
(x −a) dx = 1
2h(b −a)2 = h
2
Substitution in Eq. (6.2a) yields
I = [ f (a) + f (b)] h
2
(6.3)
whichisknownasthetrapezoidalrule.ItrepresentstheareaofthetrapezoidinFig.6.2.
The error in the trapezoidal rule
E =
/ b
a
f (x)dx −I
is the area of the region between f (x) and the straight-line interpolant, as indicated
in Fig. 6.2. It can be obtained by integrating the interpolation error in Eq. (3.3):
E = 1
2!
/ b
a
(x −x0)(x −x1) f ′′(ξ)dx = 1
2 f ′′(ξ)
/ b
a
(x −a)(x −b)dx
= −1
12(b −a)3 f ′′(ξ) = −h3
12 f ′′(ξ)
(6.4)
Composite Trapezoidal Rule
x0
x1
xi
xi+1
xn
xn-1
h
a
b
f (x)
x
iI
Figure 6.3. Composite trapezoidal rule.

201
6.2 Newton–Cotes Formulas
In practice the trapezoidal rule is applied in a piecewise fashion. Figure 6.3 shows
the region (a, b) divided into n panels, each of width h. The function f (x) to be inte-
grated is approximated by a straight line in each panel. From the trapezoidal rule we
obtain for the approximate area of a typical (ith) panel
Ii = [ f (xi) + f (xi+1)] h
2
Hence total area, representing
. b
a f (x) dx, is
I =
n−1

i=0
Ii = [ f (x0) + 2 f (x1) + 2 f (x2) + · · · + 2 f (xn−1) + f (xn)] h
2
(6.5)
which is the composite trapezoidal rule.
The truncation error in the area of a panel is, from Eq. (6.4),
Ei = −h3
12 f ′′(ξ i)
where ξi lies in (xi, xi+1). Hence the truncation error in Eq. (6.5) is
E =
n−1

i=0
Ei = −h3
12
n−1

i=0
f ′′(ξ i)
(a)
But
n−1

i=0
f ′′(ξ i) = n ¯f ′′
where ¯f ′′ is the arithmetic mean of the second derivatives. If f ′′(x) is continuous, there
must be a point ξ in (a, b) at which f ′′(ξ) = ¯f ′′, enabling us to write
n−1

i=0
f ′′(ξ i) = nf ′′(ξ) = b −a
h
f ′′(ξ)
Therefore, Eq. (a) becomes
E = −(b −a)h2
12
f ′′(ξ)
(6.6)
It would be incorrect to conclude from Eq. (6.6) that E = ch2 (c being a constant),
because f ′′(ξ) is not entirely independent of h. A deeper analysis of the error13 shows
that if f (x) and its derivatives are ﬁnite in (a, b), then
E = c1h2 + c2h4 + c3h6 + · · ·
(6.7)
13 The analysis requires familiarity with the Euler–Maclaurin summation formula, which is covered
in advanced texts.

202
Numerical Integration
Recursive Trapezoidal Rule
Let Ik be the integral evaluated with the composite trapezoidal rule using 2k−1 panels.
Note that if k is increased by one, the number of panels is doubled. Using the notation
H = b −a
we obtain from Eq. (6.5) the following results for k = 1, 2 and 3.
k = 1 (1 panel):
I1 = [ f (a) + f (b)] H
2
(6.8)
k = 2 (2 panels):
I2 =
$
f (a) + 2 f
&
a + H
2
'
+ f (b)
% H
4 = 1
2 I1 + f
&
a + H
2
' H
2
k = 3 (4 panels):
I3 =
$
f (a) + 2 f
&
a + H
4
'
+ 2 f
&
a + H
2
'
+ 2 f
&
a + 3H
4
'
+ f (b)
% H
8
= 1
2 I2 +
$
f
&
a + H
4
'
+ f
&
a + 3H
4
'% H
4
We can now see that for arbitrary k >1 we have
Ik = 1
2 Ik−1 +
H
2k−1
2k−2

i=1
f
$
a + (2i −1)H
2k−1
%
,
k = 2, 3, . . .
(6.9a)
which is the recursive trapezoidal rule. Observe that the summation contains only the
new nodes that were created when the number of panels was doubled. Therefore,
the computation of the sequence I1, I2, I3, . . . , Ik from Eqs. (6.8) and (6.9) involves
the same amount of algebra as the calculation of Ik directly from Eq. (6.5). The advan-
tage of using the recursive trapezoidal rule is that it allows us to monitor convergence
and terminate the process when the difference between Ik−1 and Ik becomes sufﬁ-
ciently small. A form of Eq. (6.9a) that is easier to remember is
I(h) = 1
2 I(2h) + h

f (xnew)
(6.9b)
where h = H/n is the width of each panel.
■trapezoid
The function trapezoid computes Ik (Inew), given Ik−1 (Iold) from Eqs. (6.8) and
(6.9). We can compute
. b
a f (x) dx by calling trapezoid with k = 1, 2, . . . until the
desired precision is attained.

203
6.2 Newton–Cotes Formulas
## module trapezoid
’’’ Inew = trapezoid(f,a,b,Iold,k).
Recursive trapezoidal rule:
Iold = Integral of f(x) from x = a to b computed by
trapezoidal rule with 2ˆ(k-1) panels.
Inew = Same integral computed with 2ˆk panels.
’’’
def trapezoid(f,a,b,Iold,k):
if k == 1:Inew = (f(a) + f(b))*(b - a)/2.0
else:
n = 2**(k -2 )
# Number of new points
h = (b - a)/n
# Spacing of new points
x = a + h/2.0
# Coord. of 1st new point
sum = 0.0
for i in range(n):
sum = sum + f(x)
x = x + h
Inew = (Iold + h*sum)/2.0
return Inew
Simpson’s Rules
f(x)
x   =  a
x  = b x
0
x 1
h
h
ξ
Parabola
2
Figure 6.4. Simpson’s 1/3 rule.
Simpson’s 1/3 rule can be obtained from Newton–Cotes formulas with n = 2; that
is, by passing a parabolic interpolant through three adjacent nodes, as shown in
Fig.6.4.Theareaundertheparabola,whichrepresentsanapproximationof
. b
a f (x) dx,
is (see derivation in Example 6.1)
I =
$
f (a) + 4 f
&a + b
2
'
+ f (b)
% h
3
(a)
x0
xi
xi +1
xn
h
a
b
f(x)
x
xi +2
h
Figure 6.5. Composite Simpson’s 1/3 rule.

204
Numerical Integration
To obtain the composite Simpson’s 1/3 rule, the integration range (a, b) is divided into
npanels (neven) of width h = (b −a)/neach, as indicated in Fig. 6.5. Applying Eq. (a)
to two adjacent panels, we have
/ xi+2
xi
f (x) dx ≈[ f (xi) + 4 f (xi+1) + f (xi+2)] h
3
(b)
Substituting Eq. (b) into
/ b
a
f (x)dx =
/ xm
x0
f (x) dx =
n

i=0,2,...
$/ xi+2
xi
f (x)dx
%
yields
/ b
a
f (x) dx ≈I = [ f (x0) + 4 f (x1) + 2 f (x2) + 4 f (x3) + · · ·
(6.10)
· · · + 2 f (xn−2) + 4 f (xn−1) + f (xn)]h
3
The composite Simpson’s 1/3 rule in Eq. (6.10) is perhaps the best-known method of
numerical integration. Its reputation is somewhat undeserved, since the trapezoidal
rule is more robust, and Romberg integration is more efﬁcient.
The error in the composite Simpson’s rule is
E = (b −a)h4
180
f (4)(ξ)
(6.11)
from which we conclude that Eq. (6.10) is exact if f (x) is a polynomial of degree three
or less.
Simpson’s 1/3 rule requires the number of panels n to be even. If this condition
is not satisﬁed, we can integrate over the ﬁrst (or last) three panels with Simpson’s
3/8 rule:
I = [ f (x0) + 3 f (x1) + 3 f (x2) + f (x3)] 3h
8
(6.12)
and use Simpson’s 1/3 rule for the remaining panels. The error in Eq. (6.12) is of the
same order as in Eq. (6.10).
EXAMPLE 6.1
Derive Simpson’s 1/3 rule from Newton–Cotes formulas.
Solution Referring to Fig. 6.4, we see that Simpson’s 1/3 rule uses three nodes located
at x0 = a, x1 = (a + b) /2 and x2 = b. The spacing of the nodes is h = (b −a)/2. The
cardinal functions of Lagrange’s three-point interpolation are (see Section 3.2)
ℓ0(x) = (x −x1)(x −x2)
(x0 −x1)(x0 −x2)
ℓ1(x) = (x −x0)(x −x2)
(x1 −x0)(x1 −x2)
ℓ2(x) = (x −x0)(x −x1)
(x2 −x0)(x2 −x1)

205
6.2 Newton–Cotes Formulas
The integration of these functions is easier if we introduce the variable ξ with origin
at x1. Then the coordinates of the nodes are ξ 0 = −h, ξ 1 = 0, ξ 2 = h, and Eq. (6.2b)
becomes Ai =
. b
a ℓi(x)dx =
. h
−h ℓi(ξ)dξ. Therefore,
A0 =
/ h
−h
(ξ −0)(ξ −h)
(−h)(−2h)
dξ =
1
2h2
/ h
−h
(ξ 2 −hξ)dξ = h
3
A1 =
/ h
−h
(ξ + h)(ξ −h)
(h)(−h)
dξ = −1
h2
/ h
−h
(ξ 2 −h2)dξ = 4h
3
A2 =
/ h
−h
(ξ + h)(ξ −0)
(2h)(h)
dξ =
1
2h2
/ h
−h
(ξ 2 + hξ)dξ = h
3
Equation (6.2a) then yields
I =
2

i=0
Ai f (xi) =
$
f (a) + 4 f
&a + b
2
'
+ f (b)
% h
3
which is Simpson’s 1/3 rule.
EXAMPLE 6.2
Evaluate the bounds on
. π
0 sin(x) dx with the composite trapezoidal rule using (1)
eight panels and (2) sixteen panels.
Solution of Part (1) With 8 panels there are 9 nodes spaced at h = π/8. The abscissas
of the nodes are xi = iπ/8, i = 0, 1, . . . , 8. From Eq. (6.5) we get
I =
)
sin 0 + 2
7

i=1
sin iπ
8 + sin π
*
π
16 = 1.97423
The error is given by Eq. (6.6):
E = −(b −a)h2
12
f ′′(ξ) = −(π −0)(π/8)2
12
(−sin ξ) = π3
768 sin ξ
where 0 < ξ < π. Since we do not know the value of ξ, we cannot evaluate E, but we
can determine its bounds:
Emin = π3
768 sin(0) = 0
Emax = π3
768 sin π
2 = 0.040 37
Therefore, I + Emin <
. π
0 sin(x) dx < I + Emax, or
1.974 23 <
/ π
0
sin(x) dx < 2.014 60
The exact integral is, of course, 2.
Solution of Part (2) The new nodes created by the doubling of panels are located at
midpoints of the old panels. Their abscissas are
xj = π/16 + jπ/8 = (1 + 2 j)π/16,
j = 0, 1, . . . , 7

206
Numerical Integration
Using the recursive trapezoidal rule in Eq. (6.9b), we get
I = 1.974 23
2
+ π
16
7

j=0
sin (1 + 2 j)π
16
= 1. 993 58
and the bounds on the error become (note that E is quartered when h is halved)
Emin = 0, Emax = 0.040 37/4 = 0.010 09. Hence
1.993 58 <
/ π
0
sin(x) dx < 2.003 67
EXAMPLE 6.3
Estimate
. 2.5
0
f (x) dx from the data
x
0
0.5
1.0
1.5
2.0
2.5
f (x)
1.5000
2.0000
2.0000
1.6364
1.2500
0.9565
Solution We will use Simpson’s rules, since they are more accurate than the trape-
zoidal rule. Because the number of panels is odd, we compute the integral over the
ﬁrst three panels by Simpson’s 3/8 rule, and use the 1/3 rule for the last two panels:
I = [ f (0) + 3 f (0.5) + 3 f (1.0) + f (1.5)] 3(0.5)
8
+ [ f (1.5) + 4 f (2.0) + f (2.5)] 0.5
3
= 2.8381 + 1.2655 = 4.1036
EXAMPLE 6.4
Use the recursive trapezoidal rule to evaluate
. π
0
√x cos x dx to six decimal places.
How many panels are needed to achieve this result?
Solution The program listed below utilizes the function trapezoid.
#!/usr/bin/python
## example6_4
from math import sqrt,cos,pi
from trapezoid import *
def f(x): return sqrt(x)*cos(x)
Iold = 0.0
for k in range(1,21):
Inew = trapezoid(f,0.0,pi,Iold,k)
if (k > 1) and (abs(Inew - Iold)) < 1.0e-6: break
Iold = Inew

207
6.3 Romberg Integration
print ’’Integral =’’,Inew
print ’’nPanels =’’,2**(k-1)
raw_input(’’\nPress return to exit’’)
The output from the program is:
Integral = -0.894831664853
nPanels = 32768
Hence
. π
0
√x cos x dx = −0.894 832 requiring 32 768 panels. The slow conver-
gence is the result of all the derivatives of f (x) being singular at x = 0. Consequently,
the error does not behave as shown in Eq. (6.7): E = c1h2 + c2h4 + · · ·, but is unpre-
dictable. Difﬁculties of this nature can often be remedied by a change in variable. In
this case, we introduce t = √x, so that dt = dx/(2√x) = dx/(2t), or dx = 2t dt. Thus
/ π
0
√x cos x dx =
/ √π
0
2t2 cos t2dt
Evaluation of the integral on the right-hand side was completed with 4096 panels.
6.3
Romberg Integration
Romberg integration combines the trapezoidal rule with Richardson extrapolation
(see Section 5.3). Let us ﬁrst introduce the notation
Ri,1 = Ii
where, as before, Ii represents the approximate value of
. b
a f (x)dx computed by the
recursive trapezoidal rule using 2i−1 panels. Recall that the error in this approximation
is E = c1h2 + c2h4 + · · ·, where
h = b −a
2i−1
is the width of a panel.
Romberg integration starts with the computation of R1,1 = I1 (one panel) and
R2,1 = I2 (two panels) from the trapezoidal rule. The leading error term c1h2 is then
eliminated by Richardson extrapolation. Using p = 2 (the exponent in the leading
error term) in Eq. (5.9) and denoting the result by R2,2, we obtain
R2,2 = 22R2,1 −R1,1
22 −1
= 4
3 R2,1 −1
3 R1,1
(a)

208
Numerical Integration
It is convenient to store the results in an array of the form
)
R1,1
R2,1
R2,2
*
The next step is to calculate R3,1 = I3 (four panels) and repeat Richardson extrap-
olation with R2,1 and R3,1, storing the result as R3,2:
R3,2 = 4
3 R3,1 −1
3 R2,1
(b)
The elements of array R calculated so far are


R1,1
R2,1
R2,2
R3,1
R3,2


Both elements of the second column have an error of the form c2h4, which can also
be eliminated with Richardson extrapolation. Using p = 4 in Eq. (5.9), we get
R3,3 = 24R3,2 −R2,2
24 −1
= 16
15 R3,2 −1
15 R2,2
(c)
This result has an error of O(h6). The array has now expanded to


R1,1
R2,1
R2,2
R3,1
R3,2
R3,3


After another round of calculations we get


R1,1
R2,1
R2,2
R3,1
R3.2
R3,3
R4,1
R4,2
R4,3
R4,4


where the error in R4,4 is O(h8). Note that the most accurate estimate of the integral is
always the last diagonal term of the array. This process is continued until the differ-
ence between two successive diagonal terms becomes sufﬁciently small. The general
extrapolation formula used in this scheme is
Ri, j = 4 j−1Ri, j−1 −Ri−1, j−1
4 j−1 −1
,
i > 1,
j = 2, 3, . . . , i
(6.13a)
A pictorial representation of Eq. (6.13a) is

209
6.3 Romberg Integration
Ri−1, j−1
↘
α
↘
Ri, j−1
→β →Ri, j
(6.13b)
where the multipliers α and β depend on j in the following manner:
j
2
3
4
5
6
α
−1/3
−1/15
−1/63
−1/255
−1/1023
β
4/3
16/15
64/63
256/255
1024/1023
(6.13c)
The triangular array is convenient for hand computations, but computer imple-
mentation of the Romberg algorithm can be carried out within a one-dimensional
array R′. After the ﬁrst extrapolation—see Eq. (a)—R1,1 is never used again, so that it
can be replaced with R2,2. As a result, we have the array
)
R′
1 = R2,2
R′
2 = R2,1
*
In the second extrapolation round, deﬁned by Eqs. (b) and (c), R3,2 overwrites R2,1,
and R3,3 replaces R2,2, so that the array contains


R′
1 = R3,3
R′
2 = R3,2
R′
3 = R3,1


andsoon.Inthismanner, R′
1 alwayscontainsthebestcurrentresult.Theextrapolation
formula for the kth round is
R′
j =
4k−j R′
j+1 −R′
j
4k−j −1
,
j = k −1, k −2, . . . , 1
(6.14)
■romberg
The algorithm for Romberg integration is implemented in the function romberg. It
returns the integral and the number of panels used. Richardson’s extrapolation is
carried out by the subfunction richardson.
## module romberg
’’’ I,nPanels = romberg(f,a,b,tol=1.0e-6).
Romberg integration of f(x) from x = a to b.
Returns the integral and the number of panels used.

210
Numerical Integration
’’’
from numarray import zeros,Float64
from trapezoid import *
def romberg(f,a,b,tol=1.0e-6):
def richardson(r,k):
for j in range(k-1,0,-1):
const = 4.0**(k-j)
r[j] = (const*r[j+1] - r[j])/(const - 1.0)
return r
r = zeros((21),type=Float64)
r[1] = trapezoid(f,a,b,0.0,1)
r_old = r[1]
for k in range(2,21):
r[k] = trapezoid(f,a,b,r[k-1],k)
r = richardson(r,k)
if abs(r[1]-r_old) < tol*max(abs(r[1]),1.0):
return r[1],2**(k-1)
r_old = r[1]
print ’’Romberg quadrature did not converge’’
EXAMPLE 6.5
Show that Rk,2 in Romberg integration is identical to the composite Simpson’s 1/3 rule
in Eq. (6.10) with 2k−1 panels.
Solution Recall that in Romberg integration Rk,1 = Ik denoted the approximate inte-
gral obtained by the composite trapezoidal rule with n = 2k−1 panels. Denoting the
abscissas of the nodes by x0, x1, . . . , xn, we have from the composite trapezoidal rule
in Eq. (6.5)
Rk,1 = Ik =
)
f (x0) + 2
n−1

i=1
f (xi) + 1
2 f (xn)
*
h
2
When we halve the number of panels (panel width 2h), only the even-numbered
abscissas enter the composite trapezoidal rule, yielding
Rk−1,1 = Ik−1 =
)
f (x0) + 2
n−2

i=2,4,...
f (xi) + f (xn)
*
h

211
6.3 Romberg Integration
Applying Richardson extrapolation yields
Rk,2 = 4
3 Rk,1 −1
3 Rk−1,1
=
)
1
3 f (x0) + 4
3
n−1

i=1,3,...
f (xi) + 2
3
n−2

i=2,4,...
f (xi) + 1
3 f (xn)
*
h
which agrees with Eq. (6.10).
EXAMPLE 6.6
Use Romberg integration to evaluate
. π
0 f (x) dx, where f (x) = sin x. Work with four
decimal places.
Solution From the recursive trapezoidal rule in Eq. (6.9b) we get
R1,1 = I(π) = π
2 [ f (0) + f (π)] = 0
R2,1 = I(π/2) = 1
2 I(π) + π
2 f (π/2) = 1.5708
R3,1 = I(π/4) = 1
2 I(π/2) + π
4 [ f (π/4) + f (3π/4)] = 1.8961
R4,1 = I(π/8) = 1
2 I(π/4) + π
8 [ f (π/8) + f (3π/8) + f (5π/8) + f (7π/8)]
= 1.9742
Using the extrapolation formulas in Eqs. (6.13), we can now construct the following
table:


R1,1
R2,1
R2,2
R3,1
R3.2
R3,3
R4,1
R4,2
R4,3
R4,4

=


0
1.5708 2.0944
1.8961 2.0046 1.9986
1.9742 2.0003 2.0000 2.0000


It appears that the procedure has converged. Therefore,
. π
0 sin x dx = R4,4 = 2.0000,
which is, of course, the correct result.
EXAMPLE 6.7
Use Romberg integration to evaluate
. √π
0
2x2 cos x2 dx and compare the results with
Example 6.4.
Solution
#!/usr/bin/python
## example6_7
from math import cos,sqrt,pi

212
Numerical Integration
from romberg import *
def f(x): return 2.0*(x**2)*cos(x**2)
I,n = romberg(f,0,sqrt(pi))
print ’’Integral =’’,I
print ’’nPanels =’’,n
raw_input(’’\nPress return to exit’’)
The results of running the program are:
Integral = -0.894831469504
nPanels = 64
It is clear that Romberg integration is considerably more efﬁcient than the trape-
zoidal rule—it required 64 panels as compared to 4096 panels for the trapezoidal rule
in Example 6.4.
PROBLEM SET 6.1
1. Use the recursive trapezoidal rule to evaluate
. π/4
0
ln(1 + tan x)dx. Explain the
results.
2. The table shows the power P supplied to the driving wheels of a car as a function
of the speed v. If the mass of the car is m= 2000 kg, determine the time t it
takes for the car to accelerate from 1 m/s to 6 m/s. Use the trapezoidal rule for
integration. Hint:
t = m
/ 6s
1s
(v/P) dv
whichcanbederivedfromNewton’slaw F = m(dv/dt)andthedeﬁnitionofpower
P = Fv.
v (m/s)
0
1.0
1.8
2.4
3.5
4.4
5.1
6.0
P (kW)
0
4.7
12.2
19.0
31.8
40.1
43.8
43.2
3. Evaluate
. 1
−1 cos(2 cos−1 x)dx with Simpson’s 1/3 rule using 2, 4 and 6 panels.
Explain the results.
4. Determine
. ∞
1 (1 + x4)−1dx with the trapezoidal rule using ﬁve panels and com-
pare the result with the “exact” integral 0.243 75. Hint: use the transformation
x3 = 1/t.

213
6.3 Romberg Integration
5.
x
F
The table below gives the pull F of the bow as a function of the draw x. If the bow
is drawn 0.5 m, determine the speed of the 0.075-kg arrow when it leaves the bow.
Hint: the kinetic energy of arrow equals the work done in drawing the bow; that
is, mv2/2 =
. 0.5m
0
F dx.
x (m)
0.00
0.05
0.10
0.15
0.20
0.25
F (N)
0
37
71
104
134
161
x (m)
0.30
0.35
0.40
0.45
0.50
F (N)
185
207
225
239
250
6. Evaluate
. 2
0

x5 + 3x3 −2
 
dx by Romberg integration.
7. Estimate
. π
0 f (x) dx as accurately as possible, where f (x) is deﬁned by the data
x
0
π/4
π/2
3π/4
π
f (x)
1.0000
0.3431
0.2500
0.3431
1.0000
8. Evaluate
/ 1
0
sin x
√x dx
with Romberg integration. Hint: use transformation of variable to eliminate the
indeterminacy at x = 0.
9. Newton–Cotes formulas for evaluating
. b
a f (x) dx were based on polynomial ap-
proximations of f (x). Show that if y = f (x) is approximated by a natural cubic
spline with evenly spaced knots at x0, x1, . . . , xn, the quadrature formula becomes
I = h
2 (y0 + 2y1 + 2y2 + · · · + 2yn−1 + yn)
−h3
24 (k0 + 2k1 + k2 + · · · + 2kn−1 + kn)

214
Numerical Integration
where h is the distance between the knots and ki = y ′′
i . Note that the ﬁrst part is
the composite trapezoidal rule; the second part may be viewed as a “correction”
for curvature.
10. ■Evaluate
/ π/4
0
dx
√
sin x
with Romberg integration. Hint: use the transformation sin x = t2.
11. ■The period of a simple pendulum of length L is τ = 4√L/g h(θ0), where g is the
gravitational acceleration, θ0 represents the angular amplitude and
h(θ0) =
/ π/2
0
dθ

1 −sin2(θ0/2) sin2 θ
Compute h(15◦), h(30◦) and h(45◦), and compare these values with h(0) = π/2 (the
approximation used for small amplitudes).
12. ■
a
r
P
q
The ﬁgure shows an elastic half-space that carries uniform loading of intensity q
over a circular area of radius a. The vertical displacement of the surface at point
P can be shown to be
w(r) = w0
/ π/2
0
cos2 θ

(r/a)2 −sin2 θ
dθ
r ≥a
where w0 is the displacement at r = a. Use numerical integration to determine
w/w0 at r = 2a.
13. ■
b
m
k
x

215
6.4 Gaussian Integration
The mass m is attached to a spring of free length b and stiffness k. The coefﬁcient
of friction between the mass and the horizontal rod is µ. The acceleration of the
mass can be shown to be (you may wish to prove this) ¨x = −f (x), where
f (x) = µg + k
m(µb + x)
&
1 −
b
√
b2 + x2
'
If the mass is released from rest at x = b, its speed at x = 0 is given by
v0 =
+
2
/ b
0
f (x)dx
Computev0 bynumericalintegrationusingthedatam= 0.8kg,b = 0.4m,µ = 0.3,
k = 80 N/m and g = 9.81 m/s2.
14. ■Debye’s formula for the heat capacity CV of a solid is CV = 9Nkg(u), where
g(u) = u3
/ 1/u
0
x4ex
(ex −1)2 dx
The terms in this equation are
N = number of particles in the solid
k = Boltzmann constant
u = T/D
T = absolute temperature
D = Debye temperature
Compute g(u) from u = 0 to 1.0 in intervals of 0.05 and plot the results.
15. ■A power spike in an electric circuit results in the current
i(t) = i0e−t/t0 sin(2t/t0)
across a resistor. The energy E dissipated by the resistor is
E =
/ ∞
0
R [i(t)]2 dt
Find E using the data i0 = 100 A, R = 0.5  and t0 = 0.01 s.
6.4
Gaussian Integration
Gaussian Integration Formulas
We found that Newton–Cotes formulas for approximating
. b
a f (x)dx work best if
f (x) is a smooth function, such as a polynomial. This is also true for Gaussian

216
Numerical Integration
quadrature. However, Gaussian formulas are also good at estimating integrals of the
form
/ b
a
w(x) f (x)dx
(6.15)
where w(x), called the weighting function, can contain singularities, as long as they
are integrable. An example of such an integral is
. 1
0 (1 + x2) ln x dx. Sometimes inﬁnite
limits, as in
. ∞
0 e−x sin x dx, can also be accommodated.
Gaussian integration formulas have the same form as Newton–Cotes rules:
I =
n

i=0
Ai f (xi)
(6.16)
where, as before, I represents the approximation to the integral in Eq. (6.15). The
difference lies in the way that the weights Ai and nodal abscissas xi are determined. In
Newton–Cotes integration the nodes were evenly spaced in (a, b), i.e., their locations
were predetermined. In Gaussian quadrature the nodes and weights are chosen so
that Eq. (6.16) yields the exact integral if f (x) is a polynomial of degree 2n+ 1 or less;
that is,
/ b
a
w(x)Pm(x)dx =
n

i=0
Ai Pm(xi),
m≤2n+ 1
(6.17)
One way of determining the weights and abscissas is to substitute P0(x) = 1,
P1(x) = x, . . . , P2n+1(x) = x2n+1 in Eq. (6.17) and solve the resulting 2n+ 2 equations
/ b
a
w(x)x jdx =
n

i=0
Aix j
i ,
j = 0, 1, . . . , 2n+ 1
for the unknowns Ai and xi.
As an illustration, let w(x) = e−x, a = 0, b = ∞and n = 1. The four equations
determining x0, x1, A0 and A1 are
/ ∞
0
e−xdx = A0 + A1
/ ∞
0
e−xx dx = A0x0 + A1x1
/ ∞
0
e−xx2dx = A0x2
0 + A1x2
1
/ ∞
0
e−xx3dx = A0x3
0 + A1x3
1

217
6.4 Gaussian Integration
After evaluating the integrals, we get
A0 + A1 = 1
A0x0 + A1x1 = 1
A0x2
0 + A1x2
1 = 2
A0x3
0 + A1x3
1 = 6
The solution is
x0 = 2 −
√
2
A0 =
√
2 + 1
2
√
2
x1 = 2 +
√
2
A1 =
√
2 −1
2
√
2
so that the integration formula becomes
/ ∞
0
e−x f (x)dx ≈
1
2
√
2

(
√
2 + 1) f
,
2 −
√
2
-
+ (
√
2 −1) f
,
2 +
√
2
-
Due to the nonlinearity of the equations, this approach will not work well for large
n. Practical methods of ﬁnding xi and Ai require some knowledge of orthogonal poly-
nomials and their relationship to Gaussian quadrature. There are, however, several
“classical” Gaussian integration formulas for which the abscissas and weights have
been computed with great precision and tabulated. These formulas can be used with-
out knowing the theory behind them, since all one needs for Gaussian integration are
the values of xi and Ai. If you do not intend to venture outside the classical formulas,
you can skip the next two topics of this chapter.
∗Orthogonal Polynomials
Orthogonal polynomials are employed in many areas of mathematics and numerical
analysis. They have been studied thoroughly and many of their properties are known.
What follows is a very small compendium of a large topic.
The polynomials ϕn(x), n = 0, 1, 2, . . . (n is the degree of the polynomial) are said
to form an orthogonal set in the interval (a, b) with respect to the weighting func-
tion w(x) if
/ b
a
w(x)ϕm(x)ϕn(x)dx = 0,
m̸= n
(6.18)
The set is determined, except for a constant factor, by the choice of the weighting
function and the limits of integration. That is, each set of orthogonal polynomials
is associated with certain w(x), a and b. The constant factor is speciﬁed by stan-
dardization. Some of the classical orthogonal polynomials, named after well-known

218
Numerical Integration
mathematicians, are listed in Table 6.1. The last column in the table shows the
standardization used.
Name
Symbol
a
b
w(x)
. b
a w(x)

ϕn(x)
2 dx
Legendre
pn(x)
−1
1
1
2/(2n+ 1)
Chebyshev
Tn(x)
−1
1
(1 −x2)−1/2
π/2 (n > 0)
Laguerre
Ln(x)
0
∞
e−x
1
Hermite
Hn(x)
−∞
∞
e−x2
√π2nn!
Table 6.1
Orthogonal polynomials obey recurrence relations of the form
anϕn+1(x) = (bn + cnx)ϕn(x) −dnϕn−1(x)
(6.19)
If the ﬁrst two polynomials of the set are known, the other members of the set can be
computed from Eq. (6.19). The coefﬁcients in the recurrence formula, together with
ϕ0(x) and ϕ1(x), are given in Table 6.2.
Name
ϕ0(x)
ϕ1(x)
an
bn
cn
dn
Legendre
1
x
n+ 1
0
2n+ 1
n
Chebyshev
1
x
1
0
2
1
Laguerre
1
1 −x
n+ 1
2n+ 1
−1
n
Hermite
1
2x
1
0
2
2
Table 6.2
The classical orthogonal polynomials are also obtainable from the formulas
pn(x) = (−1)n
2nn!
dn
dxn


1 −x2 n
Tn(x) = cos(ncos−1 x),
n > 0
Ln(x) = ex
n!
dn
dxn

xne−x 
(6.20)
Hn(x) = (−1)nex2 dn
dxn(e−x2)
and their derivatives can be calculated from
(1 −x2)p′
n(x) = n[−xpn(x) + pn−1(x)]
(1 −x2)T′
n(x) = n[−xTn(x) + nTn−1(x)]
xL′
n(x) = n[Ln(x) −Ln−1(x)]
(6.21)
H′
n(x) = 2nHn−1(x)

219
6.4 Gaussian Integration
Other properties of orthogonal polynomials that have relevance to Gaussian in-
tegration are:
r ϕn(x) has n real, distinct zeroes in the interval (a, b).
r The zeros of ϕn(x) lie between the zeros of ϕn+1(x).
r Any polynomial Pn(x) of degree n can be expressed in the form
Pn(x) =
n

i=0
ciϕi(x)
(6.22)
r It follows from Eq. (6.22) and the orthogonality property in Eq. (6.18) that
/ b
a
w(x)Pn(x)ϕn+m(x)dx = 0,
m≥0
(6.23)
∗Determination of Nodal Abscissas and Weights
Theorem
The nodal abscissas x0, x1, . . . , xn are the zeros of the polynomial ϕn+1(x)
that belongs to the orthogonal set deﬁned in Eq. (6.18).
Proof
We start the proof by letting f (x) = P2n+1(x) be a polynomial of degree 2n+ 1.
Since the Gaussian integration with n+ 1 nodes is exact for this polynomial, we
have
/ b
a
w(x)P2n+1(x)dx =
n

i=0
Ai P2n+1(xi)
(a)
A polynomial of degree 2n+ 1 can always written in the form
P2n+1(x) = Qn(x) + Rn(x)ϕn+1(x)
(b)
where Qn(x), Rn(x) and ϕn+1(x) are polynomials of the degree indicated by the
subscripts.14 Therefore,
/ b
a
w(x)P2n+1(x)dx =
/ b
a
w(x)Qn(x)dx +
/ b
a
w(x)Rn(x)ϕn+1(x)dx
But according to Eq. (6.23) the second integral on the right-hand side vanishes,
so that
/ b
a
w(x)P2n+1(x)dx =
/ b
a
w(x)Qn(x)dx
(c)
Because a polynomial of degree nis uniquely deﬁned by n+ 1 points, it is always
possible to ﬁnd Ai such that
/ b
a
w(x)Qn(x)dx =
n

i=0
Ai Qn(xi)
(d)
14 It can be shown that Qn(x) and Rn(x) are unique for given P2n+1(x) and ϕn+1(x).

220
Numerical Integration
In order to arrive at Eq. (a), we must choose for the nodal abscissas xi the roots
of ϕn+1(x) = 0. According to Eq. (b) we then have
P2n+1(xi) = Qn(xi),
i = 0, 1, . . . , n
(e)
which together with Eqs. (c) and (d) leads to
/ b
a
w(x)P2n+1(x)dx =
/ b
a
w(x)Qn(x)dx =
n

i=0
Ai P2n+1(xi)
This completes the proof.
Theorem
Ai =
/ b
a
w(x)ℓi(x)dx,
i = 0, 1, . . . , n
(6.24)
where ℓi(x) are the Lagrange’s cardinal functions spanning the nodes at
x0, x1, . . . xn. These functions were deﬁned in Eq. (3.2).
Proof
Applying Lagrange’s formula, Eq. (3.1a), to Qn(x) yields
Qn(x) =
n

i=0
Qn(xi)ℓi(x)
which upon substitution in Eq. (d) gives us
n

i=0
$
Qn(xi)
/ b
a
w(x)ℓi(x)dx
%
=
n

i=0
Ai Qn(xi)
or
n

i=0
Qn(xi)
$
Ai −
/ b
a
w(x)ℓi(x)dx
%
= 0
This equation can be satisﬁed for arbitrary Q(x) of degree n only if
Ai −
/ b
a
w(x)ℓi(x)dx = 0,
i = 0, 1, . . . , n
which is equivalent to Eq. (6.24).
It is not difﬁcult to compute the zeros xi, i = 0, 1, . . . , n of a polynomial ϕn+1(x)
belonging to an orthogonal set by one of the methods discussed in Chapter 4. Once
the zeros are known, the weights Ai, i = 0, 1, . . . , n could be found from Eq. (6.24).
However the following formulas (given without proof) are easier to compute

221
6.4 Gaussian Integration
Gauss–Legendre
Ai =
2
(1 −x2
i )

p′
n+1(xi)
2
Gauss–Laguerre
Ai =
1
xi

L′
n+1(xi)
2
(6.25)
Gauss–Hermite
Ai = 2n+2 (n+ 1)!√π

H′
n+1(xi)
2
Abscissas and Weights for Classical Gaussian Quadratures
Here we list some classical Gaussian integration formulas. The tables of nodal ab-
scissas and weights, covering n = 1 to 5, have been rounded off to six decimal places.
These tables should be adequate for hand computation, but in programming you
may need more precision or a larger number of nodes. In that case you should consult
other references,15 or use a subroutine to compute the abscissas and weights within
the integration program.16
The truncation error in Gaussian quadrature
E =
/ b
a
w(x) f (x)dx −
n

i=0
Ai f (xi)
has the form E = K (n) f (2n+2)(c), where a < c < b (the value of c is unknown; only
its bounds are given). The expression for K (n) depends on the particular quadrature
being used. If the derivatives of f (x) can be evaluated, the error formulas are useful
in estimating the error bounds.
Gauss–Legendre Quadrature
/ 1
−1
f (ξ)dξ ≈
n

i=0
Ai f (ξ i)
(6.26)
±ξ i
Ai
±ξ i
Ai
n = 1
n = 4
0.577 350
1.000 000
0.000 000
0.568 889
n = 2
0.538 469
0.478 629
0.000 000
0.888 889
0.906 180
0.236 927
0.774 597
0.555 556
n = 5
n = 3
0.238 619
0.467 914
0.339 981
0.652 145
0.661 209
0.360 762
0.861 136
0.347 855
0.932 470
0.171 324
Table 6.3
15 Abramowitz, M., and Stegun, I. A., Handbook of Mathematical Functions, Dover Publications, 1965;
Stroud, A. H., and Secrest, D., Gaussian Quadrature Formulas, Prentice-Hall, 1966.
16 Several such subroutines are listed in W. H. Press et al., Numerical Recipes in Fortran 90, Cambridge
University Press, 1996.

222
Numerical Integration
This is the most often used Gaussian integration formula. The nodes are arranged
symmetrically about ξ = 0, and the weights associated with a symmetric pair of nodes
are equal. For example, for n = 1 we have ξ 0 = −ξ 1 and A0 = A1. The truncation error
in Eq. (6.26) is
E =
22n+3 [(n+ 1)!]4
(2n+ 3) [(2n+ 2)!]3 f (2n+2)(c),
−1 < c < 1
(6.27)
To apply Gauss–Legendre quadrature to the integral
. b
a f (x)dx, we must ﬁrst map
the integration range (a, b) into the “standard” range (−1, 1˙). We can accomplish this
by the transformation
x = b + a
2
+ b −a
2
ξ
(6.28)
Now dx = dξ(b −a)/2, and the quadrature becomes
/ b
a
f (x)dx ≈b −a
2
n

i=0
Ai f (xi)
(6.29)
where the abscissas xi must be computed from Eq. (6.28). The truncation error
here is
E = (b −a)2n+3 [(n+ 1)!]4
(2n+ 3) [(2n+ 2)!]3 f (2n+2)(c),
a < c < b
(6.30)
Gauss–Chebyshev Quadrature
/ 1
−1

1 −x2 −1/2 f (x)dx ≈
π
n+ 1
n

i=0
f (xi)
(6.31)
Note that all the weights are equal: Ai = π/ (n+ 1). The abscissas of the nodes, which
are symmetric about x = 0, are given by
xi = cos (2i + 1)π
2n+ 2
(6.32)
The truncation error is
E =
2π
22n+2(2n+ 2)! f (2n+2)(c),
−1 < c < 1
(6.33)
Gauss–Laguerre Quadrature
/ ∞
0
e−x f (x)dx ≈
n

i=0
Ai f (xi)
(6.34)

223
6.4 Gaussian Integration
xi
Ai
xi
Ai
n = 1
n = 4
0.585 786
0.853 554
0.263 560
0.521 756
3.414 214
0.146 447
1.413 403
0.398 667
n = 2
3.596 426
(−1)0.759 424
0.415 775
0.711 093
7.085 810
(−2)0.361 175
2.294 280
0.278 517
12.640 801
(−4)0.233 670
6.289 945
(−1)0.103 892
n = 5
n = 3
0.222 847
0.458 964
0.322 548
0.603 154
1.188 932
0.417 000
1.745 761
0.357 418
2.992 736
0.113 373
4.536 620
(−1)0.388 791
5.775 144
(−1)0.103 992
9.395 071
(−3)0.539 295
9.837 467
(−3)0.261 017
15.982 874
(−6)0.898 548
Table 6.4. Multiply numbers by 10k, where k is given in parentheses
E = [(n+ 1)!]2
(2n+ 2)! f (2n+2)(c),
0 < c < ∞
(6.35)
Gauss–Hermite Quadrature
/ ∞
−∞
e−x2 f (x)dx ≈
n

i=0
Ai f (xi)
(6.36)
The nodes are placed symmetrically about x = 0, each symmetric pair having the
same weight.
±xi
Ai
±xi
Ai
n = 1
n = 4
0.707 107
0.886 227
0.000 000
0.945 308
n = 2
0.958 572
0.393 619
0.000 000
1.181 636
2.020 183
(−1) 0.199 532
1.224745
0.295 409
n = 5
n = 3
0.436 077
0.724 629
0.524 648
0.804 914
1.335 849
0.157 067
1.650 680
(−1)0.813 128
2.350 605
(−2)0.453 001
Table 6.5. Multiply numbers by 10k, where k is given in parentheses
E =
√π(n+ 1)!
22(2n+ 2)! f (2n+2)(c),
0 < c < ∞
(6.37)

224
Numerical Integration
Gauss Quadrature with Logarithmic Singularity
/ 1
0
f (x) ln(x)dx ≈−
n

i=0
Ai f (xi)
(6.38)
xi
Ai
xi
Ai
n = 1
n = 4
0.112 009
0.718 539
(−1)0.291 345
0.297 893
0.602 277
0.281 461
0.173 977
0.349 776
n = 2
0.411 703
0.234 488
(−1)0.638 907
0.513 405
0.677314
(−1)0.989 305
0.368 997
0.391 980
0.894 771
(−1)0.189 116
0.766 880
(−1)0.946 154
n = 5
n = 3
(−1)0.216 344
0.238 764
(−1)0.414 485
0.383 464
0.129 583
0.308 287
0.245 275
0.386 875
0.314 020
0.245 317
0.556 165
0.190 435
0.538 657
0.142 009
0.848 982
(−1)0.392 255
0.756 916
(−1)0.554 546
0.922 669
(−1)0.101 690
Table 6.6. Multiply numbers by 10k, where k is given in parentheses
E =
k(n)
(2n+ 1)! f (2n+1)(c),
0 < c < 1
(6.39)
where k(1) = 0.00 285, k(2) = 0.000 17, k(3) = 0.000 01.
■gaussNodes
The function gaussNodes listed below17 computes the nodal abscissas xi and the
corresponding weights Ai used in Gauss–Legendre quadrature over the “standard”
interval (−1, 1). It can be shown that the approximate values of the abscissas are
xi = cos π(i + 0.75)
m+ 0.5
where m= n+ 1 is the number of nodes, also called the integration order. Using these
approximationsasthestartingvalues,thenodalabscissasarecomputedbyﬁndingthe
nonnegative zeros of the Legendre polynomial pm(x) with Newton’s method (the neg-
ative zeros are obtained from symmetry). Note that gaussNodes calls the subfunction
legendre, which returns pm(t) and its derivative as the tuple (p,dp).
17 This function is an adaptation of a routine in Press, W. H. et al., Numerical Recipes in Fortran 90,
Cambridge University Press, 1996.

225
6.4 Gaussian Integration
## module gaussNodes
’’’ x,A = gaussNodes(m,tol=10e-9)
Returns nodal abscissas {x}
and weights {A}
of
Gauss-Legendre m-point quadrature.
’’’
from math import cos,pi
from numarray import zeros,Float64
def gaussNodes(m,tol=10e-9):
def legendre(t,m):
p0 = 1.0; p1 = t
for k in range(1,m):
p = ((2.0*k + 1.0)*t*p1 - k*p0)/(1.0 + k)
p0 = p1; p1 = p
dp = m*(p0 - t*p1)/(1.0 - t**2)
return p,dp
A = zeros((m),type=Float64)
x = zeros((m),type=Float64)
nRoots = (m + 1)/2
# Number of non-neg. roots
for i in range(nRoots):
t = cos(pi*(i + 0.75)/(m + 0.5))
# Approx. root
for j in range(30):
p,dp = legendre(t,m)
# Newton-Raphson
dt = -p/dp; t = t + dt
# method
if abs(dt) < tol:
x[i] = t; x[m-i-1] = -t
A[i] = 2.0/(1.0 - t**2)/(dp**2) # Eq.(6.25)
A[m-i-1] = A[i]
break
return x,A
■gaussQuad
The function gaussQuad utilizes gaussNodes to evaluate
. b
a f (x) dx with Gauss–
Legendre quadrature using mnodes. The function routine for f (x) must be supplied
by the user.
## module gaussQuad
’’’ I = gaussQuad(f,a,b,m).
Computes the integral of f(x) from x = a to b

226
Numerical Integration
with Gauss-Legendre quadrature using m nodes.
’’’
from gaussNodes import *
def gaussQuad(f,a,b,m):
c1 = (b + a)/2.0
c2 = (b - a)/2.0
x,A = gaussNodes(m)
sum = 0.0
for i in range(len(x)):
sum = sum + A[i]*f(c1 + c2*x[i])
return c2*sum
EXAMPLE 6.8
Evaluate
. 1
−1(1 −x2)3/2dx as accurately as possible with Gaussian integration.
Solution As the integrand is smooth and free of singularities, we could use Gauss–
Legendre quadrature. However, the exact integral can obtained with the Gauss–
Chebyshev formula. We write
/ 1
−1

1 −x2 3/2 dx =
/ 1
−1

1 −x2 2
√
1 −x2 dx
The numerator f (x) = (1 −x2)2 is a polynomial of degree four, so that Gauss–
Chebyshev quadrature is exact with three nodes.
The abscissas of the nodes are obtained from Eq. (6.32). Substituting n = 2,
we get
xi = cos (2i + 1)π
6
,
i = 0, 1, 2
Therefore,
x0 = cos π
6 =
√
3
2
x1 = cos π
2 = 0
x2 = cos 5π
6 =
√
3
2
and Eq. (6.31) yields
/ 1
−1

1 −x2 3/2 dx ≈π
3
2

i=0

1 −x2
i
 2
= π
3
)&
1 −3
4
'2
+ (1 −0)2 +
&
1 −3
4
'2*
= 3π
8

227
6.4 Gaussian Integration
EXAMPLE 6.9
Use Gaussian integration to evaluate
. 0.5
0
cos πx ln x dx.
Solution We split the integral into two parts:
/ 0.5
0
cos πx ln x dx =
/ 1
0
cos πx ln x dx −
/ 1
0.5
cos πx ln x dx
The ﬁrst integral on the right-hand side, which contains a logarithmic singularity at
x = 0, can be computed with the special Gaussian quadrature in Eq. (6.38). Choosing
n = 3, we have
/ 1
0
cos πx ln x dx ≈−
3

i=0
Ai cos πxi
The sum is evaluated in the following table:
xi
cos πxi
Ai
Ai cos πxi
0.041 448
0.991 534
0.383 464
0.380 218
0.245 275
0.717 525
0.386 875
0.277 592
0.556 165
−0.175 533
0.190 435
−0.033 428
0.848 982
−0.889 550
0.039 225
−0.034 892
 = 0.589 490
Thus
/ 1
0
cos πx ln x dx ≈−0.589 490
The second integral is free of singularities, so that it can be evaluated with Gauss–
Legendre quadrature. Choosing n = 3, we have
/ 1
0.5
cos πx ln x dx ≈0.25
3

i=0
Ai cos πxi ln xi
where the nodal abscissas are (see Eq. (6.28))
xi = 1 + 0.5
2
+ 1 −0.5
2
ξ i = 0.75 + 0.25ξi
Looking up ξ i and Ai in Table 6.3 leads to the following computations:
ξ i
xi
cos πxi ln xi
Ai
Ai cos πxi ln xi
−0.861 136
0.534 716
0.068 141
0.347 855
0.023 703
−0.339 981
0.665 005
0.202 133
0.652 145
0.131 820
0.339 981
0.834 995
0.156 638
0.652 145
0.102 151
0.861 136
0.965 284
0.035 123
0.347 855
0.012 218
 = 0.269 892

228
Numerical Integration
from which
/ 1
0.5
cos πx ln x dx ≈0.25(0.269 892) = 0.067 473
Therefore,
/ 1
0
cos πx ln x dx ≈−0. 589 490 −0.067 473 = −0. 656 96 3
which is correct to six decimal places.
EXAMPLE 6.10
Evaluate as accurately as possible
F =
/ ∞
0
x + 3
√x e−xdx
Solution In its present form, the integral is not suited to any of the Gaussian quadra-
tures listed in this chapter. But using the transformation
x = t2
dx = 2t dt
we have
F = 2
/ ∞
0
(t2 + 3)e−t2dt =
/ ∞
−∞
(t2 + 3)e−t2dt
which can be evaluated exactly with Gauss–Hermite formula using only two nodes
(n = 1). Thus
F = A0(t2
0 + 3) + A1(t2
1 + 3)
= 0.886 227

(0.707 107)2 + 3

+ 0.886 227

(−0.707 107)2 + 3

= 6. 203 59
EXAMPLE 6.11
Determine how many nodes are required to evaluate
/ π
0
&sin x
x
'2
dx
with Gauss–Legendre quadrature to six decimal places. The exact integral, rounded
to six places, is 1.418 15.
Solution The integrand is a smooth function; hence it is suited for Gauss–Legendre
integration. There is an indeterminacy at x = 0, but this does not bother the quadra-
ture since the integrand is never evaluated at that point. We used the following pro-
gram that computes the quadrature with 2, 3, . . . nodes until the desired accuracy is
reached:

229
6.4 Gaussian Integration
## example 6_11
from math import pi,sin
from gaussQuad import *
def f(x): return (sin(x)/x)**2
a = 0.0; b = pi;
Iexact = 1.41815
for m in range(2,12):
I = gaussQuad(f,a,b,m)
if abs(I - Iexact) < 0.00001:
print ’’Number of nodes =’’,m
print ’’Integral =’’, gaussQuad(f,a,b,m)
break
raw_input(’’\nPress return to exit’’)
The program output is
Number of nodes = 5
Integral = 1.41815026778
EXAMPLE 6.12
Evaluate numerically
. 3
1.5 f (x) dx, where f (x) is represented by the unevenly spaced
data
x
1.2
1.7
2.0
2.4
2.9
3.3
f (x)
−0.362 36
0.128 84
0.416 15
0.737 39
0.970 96
0.987 48
Knowing that the data points lie on the curve f (x) = −cos x, evaluate the accuracy of
the solution.
Solution We approximate f (x) by the polynomial P5(x) that intersects all the data
points, and then evaluate
. 3
1.5 f (x)dx ≈
. 3
1.5 P5(x)dx with the Gauss–Legendre formula.
Since the polynomial is of degree ﬁve, only three nodes (n = 2) are required in the
quadrature.
From Eq. (6.28) and Table 6.3, we obtain for the abscissas of the nodes
x0 = 3 + 1.5
2
+ 3 −1.5
2
(−0.774597) = 1. 6691
x1 = 3 + 1.5
2
= 2.25
x2 = 3 + 1.5
2
+ 3 −1.5
2
(0.774597) = 2. 8309

230
Numerical Integration
We now compute the values of the interpolant P5(x) at the nodes. This can be done
using the modules newtonPoly or neville listed in Section 3.2. The results are
P5(x0) = 0.098 08
P5(x1) = 0.628 16
P5(x2) = 0.952 16
From Gauss–Legendre quadrature
I =
/ 3
1.5
P5(x)dx = 3 −1.5
2
2

i=0
Ai P5(xi)
we get
I = 0.75 [0.555 556(0.098 08) + 0.888 889(0.628 16) + 0.555 556(0.952 16)]
= 0.856 37
Comparison with −
. 3
1.5 cos x dx = 0. 856 38 shows that the discrepancy is within the
roundoff error.
PROBLEM SET 6.2
1. Evaluate
/ π
1
ln x
x2 −2x + 2dx
with Gauss–Legendre quadrature. Use (a) two nodes and (b) four nodes.
2. Use Gauss–Laguerre quadrature to evaluate
. ∞
0 (1 −x2)3e−x dx.
3. Use Gauss–Chebyshev quadrature with six nodes to evaluate
/ π/2
0
dx
√
sin x
Compare the result with the “exact” value 2.62206. Hint: substitute sin x = t2.
4. The integral
. π
0 sin x dx is evaluated with Gauss–Legendre quadrature using four
nodes.Whataretheboundsonthetruncationerrorresultingfromthequadrature?
5. How many nodes are required in Gauss–Laguerre quadrature to evaluate
. ∞
0 e−x
sin x dx to six decimal places?
6. Evaluate as accurately as possible
/ 1
0
2x + 1
√x(1 −x)dx
Hint: substitute x = (1 + t)/2.
7. Compute
. π
0 sin x ln x dx to four decimal places.
8. Calculate the bounds on the truncation error if
. π
0 x sin x dx is evaluated with
Gauss–Legendre quadrature using three nodes. What is the actual error?

231
6.4 Gaussian Integration
9. Evaluate
. 2
0

sinh x/x
 
dx to four decimal places.
10. Evaluate the integral
/ ∞
0
x dx
ex + 1
to six decimal places. Hint: substitute ex = 1/t.
11. ■The equation of an ellipse is x2/a2 + y2/b2 = 1. Write a program that computes
the length
S = 2
/ a
−a

1 + (dy/dx)2 dx
of the circumference to ﬁve decimal places for given a and b. Test the program
with a = 2 and b = 1.
12. ■The error function, which is of importance in statistics, is deﬁned as
erf(x) =
2
√π
/ x
0
e−t2dt
Write a program that uses Gauss–Legendre quadrature to evaluate erf(x) for a
given x to six decimal places. Note that erf(x) = 1.000 000 (correct to 6 decimal
places) when x > 5. Test the program by verifying that erf(1.0) = 0.842 701.
13. ■
m
k
L
L
A
B
The sliding weight of mass m is attached to a spring of stiffness k that has an
undeformed length L. When the mass is released from rest at B, the time it takes
to reach A can be shown to be t = C√m/k, where
C =
/ 1
0
$,√
2 −1
-2
−
,
1 + z2 −1
-2%−1/2
dz
Compute C to six decimal places. Hint: the integrand has a singularity at z = 1
that behaves as (1 −z2)−1/2.

232
Numerical Integration
14. ■
x
P
y
A
h
b
B
A uniform beam forms the semiparabolic cantilever arch AB. The vertical dis-
placement of A due to the force P can be shown to be
δ A = Pb3
E I C
&h
b
'
where E I is the bending rigidity of the beam and
C
&h
b
'
=
/ 1
0
z2
+
1 +
&2h
b z
'2
dz
Write a program that computes C(h/b) for any given value of h/b to four decimal
places. Use the program to compute C(0.5), C(1.0) and C(2.0).
15. ■Thereisnoelegantwaytocompute I =
. π/2
0
ln(sin x) dx.A“bruteforce”method
that works is to split the integral into several parts: from x = 0 to 0.01, from 0.01
to 0.2 and from x = 0.2 to π/2. In the ﬁrst part we can use the approximation
sin x ≈x, which allows us to obtain the integral analytically. The other two parts
can be evaluated with Gauss–Legendre quadrature. Use this method to evaluate
I to six decimal places.
16. ■
p (Pa)
620
612
575
530
425
310
0
15
35
52
80
112
h (m)
The pressure of wind was measured at various heights on a vertical wall, as shown
on the diagram. Find the height of the pressure center, which is deﬁned as
¯h =
. 112 m
0
h p(h) dh
. 112 m
0
p(h) dh

233
6.5 Multiple Integrals
Hint: ﬁt a cubic polynomial to the data and then apply Gauss–Legendre
quadrature.
∗6.5
Multiple Integrals
Multiple integrals, such as the area integral
. .
A f (x, y) dx dy, can also be evaluated
by quadrature. The computations are straightforward if the region of integration has a
simple geometric shape, such as a triangle or a quadrilateral. Due to complications in
specifying the limits of integration on x and y, quadrature is not a practical means of
evaluating integrals over irregular regions. However, an irregular region A can always
be approximated as an assembly of triangular or quadrilateral subregions A1, A2, . . . ,
calledﬁniteelements,asillustratedinFig.6.6.Theintegralover Acanthenbeevaluated
by summing the integrals over the ﬁnite elements:
/ /
A
f (x, y) dx dy ≈

i
/ /
Ai
f (x, y) dx dy
Volume integrals can computed in a similar manner, using tetrahedra or rectangular
prisms for the ﬁnite elements.
Boundary of region A
Ai
Figure 6.6. Finite element model of an irregular
region.
Gauss–Legendre Quadrature over a Quadrilateral Element
ξ
η
1
1
1
1
0
0
x
y
1
2
3
4
η = 1
η = −1
ξ = 1
ξ = −1
(b)
(a)
Figure 6.7. Mapping a quadrilateral into the standard rectangle.

234
Numerical Integration
Consider the double integral
I =
/ 1
−1
/ 1
−1
f (ξ, η) dξ dη
over the rectangular element shown in Fig. 6.7(a). Evaluating each integral in turn by
Gauss–Legendre quadrature using n+ 1 integration points in each coordinate direc-
tion, we obtain
I =
/ 1
−1
n

i=0
Ai f (ξi, η) dη =
n

j=0
A j
) n

i=0
Ai f (ξi, ηi)
*
or
I =
n

i=0
n

j=0
Ai A j f (ξ i, η j)
(6.40)
As noted previously, the number of integration points in each coordinate direction,
m= n+ 1, is called the integration order. Figure 6.7(a) shows the locations of the
integration points used in third-order integration (m= 3). Because the integration
limits were the “standard” limits (−1, 1) of Gauss–Legendre quadrature, the weights
and the coordinates of the integration points are as listed Table 6.3.
In order to apply quadrature to the quadrilateral element in Fig. 6.7(b), we must
ﬁrst map the quadrilateral into the “standard” rectangle in Fig. 6.7(a). By mapping
we mean a coordinate transformation x = x(ξ, η), y = y(ξ, η) that results in one-to-
one correspondence between points in the quadrilateral and in the rectangle. The
transformation that does the job is
x(ξ, η) =
4

k=1
Nk(ξ, η)xk
y(ξ, η) =
4

k=1
Nk(ξ, η)yk
(6.41)
where (xk, yk) are the coordinates of corner k of the quadrilateral and
N1(ξ, η) = 1
4(1 −ξ)(1 −η)
N2(ξ, η) = 1
4(1 + ξ)(1 −η)
(6.42)
N3(ξ, η) = 1
4(1 + ξ)(1 + η)
N4(ξ, η) = 1
4(1 −ξ)(1 + η)
The functions Nk(ξ, η), known as the shape functions, are bilinear (linear in each
coordinate).Consequently,straightlinesremainstraightuponmapping.Inparticular,
note that the sides of the quadrilateral are mapped into the lines ξ = ±1 and η = ±1.

235
6.5 Multiple Integrals
Because mapping distorts areas, an inﬁnitesimal area element dA = dx dy of the
quadrilateral is not equal to its counterpart dA′ = dξ dη of the rectangle. It can be
shown that the relationship between the areas is
dx dy = |J(ξ, η)| dξ dη
(6.43)
where
J(ξ, η) =


∂x
∂ξ
∂y
∂ξ
∂x
∂η
∂y
∂η


(6.44a)
is known as the Jacobian matrix of the mapping. Substituting from Eqs. (6.41) and
(6.42) and differentiating, we ﬁnd that the components of the Jacobian matrix are
J11 = 1
4 [−(1 −η)x1 + (1 −η)x2 + (1 + η)x3 −(1 −η)x4]
J12 = 1
4 [−(1 −η)y1 + (1 −η)y2 + (1 + η)y3 −(1 −η)y4]
(6.44b)
J21 = 1
4 [−(1 −ξ)x1 −(1 + ξ)x2 + (1 + ξ)x3 + (1 −ξ)x4]
J22 = 1
4 [−(1 −ξ)y1 −(1 + ξ)y2 + (1 + ξ)y3 + (1 −ξ)y4]
We can now write
/ /
A
f (x, y) dx dy =
/ 1
−1
/ 1
−1
f [x(ξ, η), y(ξ, η)] |J(ξ, η)| dξ dη
(6.45)
Since the right-hand-side integral is taken over the “standard” rectangle, it can be
evaluated using Eq. (6.40). Replacing f (ξ, η) in Eq. (6.40) by the integrand in Eq. (6.45),
we get the following formula for Gauss–Legendre quadrature over a quadrilateral
region:
I =
n

i=0
n

j=0
Ai A j f

x(ξ i, η j), y(ξ i, η j)
 J(ξi, η j)

(6.46)
The ξ and η-coordinates of the integration points and the weights can again be ob-
tained from Table 6.3.
■gaussQuad2
The function gaussQuad2 in this module computes
. .
A f (x, y) dx dy over a quadri-
lateral element with Gauss–Legendre quadrature of integration order m. The quadri-
lateral is deﬁned by the arrays x and y, which contain the coordinates of the four
corners ordered in a counterclockwise direction around the element. The determinant

236
Numerical Integration
of the Jacobian matrix is obtained by calling the function jac; mapping is performed
by map. The weights and the values of ξ and η at the integration points are computed
by gaussNodes listed in the previous article (note that ξ and η appear as s and t in the
listing).
## module gaussQuad2
’’’ I = gaussQuad2(f,xc,yc,m).
Gauss-Legendre integration of f(x,y) over a
quadrilateral using integration order m.
{xc},{yc}
are the corner coordinates of the quadrilateral.
’’’
from gaussNodes import *
from numarray import zeros,Float64,dot
def gaussQuad2(f,x,y,m):
def jac(x,y,s,t):
J = zeros((2,2),type=Float64)
J[0,0] = -(1.0 - t)*x[0] + (1.0 - t)*x[1]
\
+ (1.0 + t)*x[2] - (1.0 + t)*x[3]
J[0,1] = -(1.0 - t)*y[0] + (1.0 - t)*y[1]
\
+ (1.0 + t)*y[2] - (1.0 + t)*y[3]
J[1,0] = -(1.0 - s)*x[0] - (1.0 + s)*x[1]
\
+ (1.0 + s)*x[2] + (1.0 - s)*x[3]
J[1,1] = -(1.0 - s)*y[0] - (1.0 + s)*y[1]
\
+ (1.0 + s)*y[2] + (1.0 - s)*y[3]
return (J[0,0]*J[1,1] - J[0,1]*J[1,0])/16.0
def map(x,y,s,t):
N = zeros((4),type=Float64)
N[0] = (1.0 - s)*(1.0 - t)/4.0
N[1] = (1.0 + s)*(1.0 - t)/4.0
N[2] = (1.0 + s)*(1.0 + t)/4.0
N[3] = (1.0 - s)*(1.0 + t)/4.0
xCoord = dot(N,x)
yCoord = dot(N,y)
return xCoord,yCoord
s,A = gaussNodes(m)
sum = 0.0

237
6.5 Multiple Integrals
for i in range(m):
for j in range(m):
xCoord,yCoord = map(x,y,s[i],s[j])
sum = sum + A[i]*A[j]*jac(x,y,s[i],s[j])
\
*f(xCoord,yCoord)
return sum
EXAMPLE 6.13
x
y
1
2
3
4
2
2
3
Evaluate the integral
I =
/ /
A

x2 + y
 
dx dy
analytically by ﬁrst transforming it from the quadrilateral region A shown to the “stan-
dard” rectangle.
Solution The corner coordinates of the quadrilateral are
xT =

0
2
2
0

yT =

0
0
3
2

The mapping is
x(ξ, η) =
4

k=1
Nk(ξ, η)xk
= 0 + (1 + ξ)(1 −η)
4
(2) + (1 + ξ)(1 + η)
4
(2) + 0
= 1 + ξ
y(ξ, η) =
4

k=1
Nk(ξ, η)yk
= 0 + 0 + (1 + ξ)(1 + η)
4
(3) + (1 −ξ)(1 + η)
4
(2)
= (5 + ξ)(1 + η)
4

238
Numerical Integration
which yields for the Jacobian matrix
J(ξ, η) =


∂x
∂ξ
∂y
∂ξ
∂x
∂η
∂y
∂η

=


1
1 + η
4
0
5 + ξ
4


Thus the area scale factor is
|J(ξ, η)| = 5 + ξ
4
Now we can map the integral from the quadrilateral to the standard rectangle. Refer-
ring to Eq. (6.45), we obtain
I =
/ 1
−1
/ 1
−1
$
(1 + ξ)2 + (5 + ξ)(1 + η)
4
% 5 + ξ
4
dξ dη
=
/ 1
−1
/ 1
−1
&45
16 + 27
8 ξ + 29
16ξ 2 + 1
4ξ 3 + 25
16η + 5
8ξη + 1
16ξ 2η
'
dξ dη
Noting that only even powers of ξ and η contribute to the integral, we can simplify the
integral to
I =
/ 1
−1
/ 1
−1
&45
16 + 29
16ξ 2
'
dξ dη = 41
3
EXAMPLE 6.14
Evaluate the integral
/ 1
−1
/ 1
−1
cos πx
2 cos π y
2 dx dy
by Gauss–Legendre quadrature of order three.
Solution From the quadrature formula in Eq. (6.40), we have
I =
2

i=0
2

j=0
Ai A j cos πxi
2 cos π yj
2
a
a
a
a
b
b
b
b
y
−1
1
0
1
−1
0
x
The integration points are shown in the ﬁgure; their coordinates and the correspond-
ing weights are listed in Table 6.3. Note that the integrand, the integration points and

239
6.5 Multiple Integrals
the weights are all symmetric about the coordinate axes. It follows that the points
labeled a contribute equal amounts to I; the same is true for the points labeled b.
Therefore,
I = 4(0.555 556)2 cos2 π(0.774 597)
2
+ 4(0.555 556)(0.888 889) cos π(0.774 597)
2
cos π(0)
2
+ (0.888 889)2 cos2 π(0)
2
= 1.623 391
The exact value of the integral is 16/π2 ≈1.621 139.
EXAMPLE 6.15
x
y
1
3
4
2
3
4
4
1
1
Utilize gaussQuad2 to evaluate I =
. .
A f (x, y) dx dy over the quadrilateral shown,
where
f (x, y) = (x −2)2(y −2)2
Use enough integration points for an “exact” answer.
Solution The required integration order is determined by the integrand in
Eq. (6.45):
I =
/ 1
−1
/ 1
−1
f [x(ξ, η), y(ξ, η)] |J(ξ, η)| dξ dη
(a)
We note that |J (ξ, η)|, deﬁned in Eqs. (6.44), is biquadratic. Since the speciﬁed f (x, y)
is also biquadratic, the integrand in Eq. (a) is a polynomial of degree 4 in both ξ and
η. Thus third-order integration is sufﬁcient for an “exact” result.
#!/usr/bin/python
## example 6_15
from gaussQuad2 import *
from numarray import array

240
Numerical Integration
def f(x,y): return ((x - 2.0)**2)*((y - 2.0)**2)
x = array([0.0, 4.0, 4.0, 1.0])
y = array([0.0, 1.0, 4.0, 3.0])
m = eval(raw_input(’’Integration order ==> ’’))
print ’’Integral =’’, gaussQuad2(f,x,y,m)
raw_input(’’\nPress return to exit’’
Running the above program produced the following result:
Integration order ==> 3
Integral = 11.3777777778
Quadrature over a Triangular Element
1
2
3
4
Figure 6.8. Degenerate quadrilateral.
A triangle may be viewed as a degenerate quadrilateral with two of its corners
occupying the same location, as illustrated in Fig. 6.8. Therefore, the integration for-
mulas over a quadrilateral region can also be used for a triangular element. However,
it is computationally advantageous to use integration formulas specially developed
for triangles, which we present without derivation.18
P
A
A
A
1
2
1
2
3
3
x
y
Figure 6.9. Triangular element.
Consider the triangular element in Fig. 6.9. Drawing straight lines from the point
P in the triangle to each of the corners, we divide the triangle into three parts with
areas A1, A2 and A3. The so-called area coordinates of P are deﬁned as
αi = Ai
A ,
i = 1, 2, 3
(6.47)
18 The triangle formulas are extensively used in the ﬁnite method analysis. See, for example,
Zienkiewicz, O. C., and Taylor, R. L., The Finite Element Method, Vol. 1, 4th ed., McGraw-Hill,
1989.

241
6.5 Multiple Integrals
where A is the area of the element. Since A1 + A2 + A3 = A, the area coordinated are
related by
α1 + α2 + α3 = 1
(6.48)
Note that αi ranges from 0 (when P lies on the side opposite to corner i) to 1 (when P
is at corner i).
A convenient formula of computing A from the corner coordinates (xi, yi) is
A = 1
2

1
1
1
x1
x2
x3
y1
y2
y3

(6.49)
The area coordinates are mapped into the Cartesian coordinates by
x(α1, α2, α3) =
3

i=1
αixi
y(α1, α2, α3) =
3

i=1
αi yi
(6.50)
The integration formula over the element is
/ /
A
f [x(α), y(α)] dA = A

k
Wk f [x(αk), y(αk)]
(6.51)
where αk represents the area coordinates of the integration point k, and Wk are the
weights. The locations of the integration points are shown in Fig. 6.10, and the corre-
sponding values of αk and Wk are listed in Table 6.7. The quadrature in Eq. (6.51) is
exact if f (x, y) is a polynomial of the degree indicated.
a
a
b
c
b
c
d
a
(a) Linear
(b) Quadratic
(c) Cubic
Figure6.10. Integrationpointsoftrian-
gular elements.
Degree of f (x, y)
Point
αk
Wk
(a) Linear
a
1/3, 1/3, 1/3
1
(b) Quadratic
a
1/2, 0 , 1/2
1/3
b
1/2, 1/2, 0
1/3
c
0, 1/2 , 1/2
1/3
(c) Cubic
a
1/3, 1/3, 1/3
−27/48
b
1/5, 1/5, 3/5
25/48
c
3/5. 1/5 , 1/5
25/48
d
1/5, 3/5 , 1/5
25/48
Table 6.7

242
Numerical Integration
■triangleQuad
The function triangleQuad computes
. .
A f (x, y) dx dy over a triangular region us-
ing the cubic formula—case (c) in Fig. 6.10. The triangle is deﬁned by its corner coor-
dinate arrays xc and yc, where the coordinates are listed in a counterclockwise order
around the triangle.
## module triangleQuad
’’’ I = triangleQuad(f,xc,yc).
Integration of f(x,y) over a triangle using
the cubic formula.
{xc},{yc}
are the corner coordinates of the triangle.
’’’
from numarray import array,matrixmultiply
def triangleQuad(f,xc,yc):
alpha = array([[1.0/3, 1.0/3.0, 1.0/3.0],
\
[0.2, 0.2, 0.6],
\
[0.6, 0.2, 0.2],
\
[0.2, 0.6, 0.2]])
W = array([-27.0/48.0 ,25.0/48.0, 25.0/48.0, 25.0/48.0])
x = matrixmultiply(alpha,xc)
y = matrixmultiply(alpha,yc)
A = (xc[1]*yc[2] - xc[2]*yc[1]
\
- xc[0]*yc[2] + xc[2]*yc[0]
\
+ xc[0]*yc[1] - xc[1]*yc[0])/2.0
sum = 0.0
for i in range(4):
sum = sum + W[i] * f(x[i],y[i])
return A*sum
EXAMPLE 6.16
3
1
x
y
1
3
2

243
6.5 Multiple Integrals
Evaluate I =
. .
A f (x, y) dx dy over the equilateral triangle shown, where19
f (x, y) = 1
2(x2 + y2) −1
6(x3 −3xy2) −2
3
Use the quadrature formulas for (1) a quadrilateral; and (2) a triangle.
Solution of Part (1) Let the triangle be formed by collapsing corners 3 and 4 of a
quadrilateral. The corner coordinates of this quadrilateral are x = [−1, −1, 2, 2]T
and y =

√3, −
√
3, 0, 0
T
. To determine the minimum required integration order
for an exact result, we must examine f [x(ξ, η), y(ξ, η)] |J(ξ, η)|, the integrand in (6.45).
Since |J(ξ, η)| is biquadratic, and f (x, y) is cubic in x, the integrand is a polynomial of
degree 5 in x. Therefore, third-order integration will sufﬁce. The program used for the
computations is similar to the one in Example 6.15:
#!/usr/bin/python
## example6_16a
from gaussQuad2 import *
from numarray import array
from math import sqrt
def f(x,y):
return (x**2 + y**2)/2.0
\
- (x**3 - 3.0*x*y**2)/6.0
\
- 2.0/3.0
x = array([-1.0,-1.0,2.0,2.0])
y = array([sqrt(3.0),-sqrt(3.0),0.0,0.0])
m = eval(raw_input(’’Integration order ==> ’’))
print ’’Integral =’’, gaussQuad2(f,x,y,m)
raw_input(’’\nPress return to exit’’)
Here is the output:
Integration order ==> 3
Integral = -1.55884572681
Solution of Part (2) The following program utilizes triangleQuad:
#!/usr/bin/python
# example6_16b
19 This function is identical to the Prandtl stress function for torsion of a bar with the cross section
shown; the integral is related to the torsional stiffness of the bar. See, for example Timoshenko,
S. P., and Goodier, J. N., Theory of Elasticity, 3rd ed., McGraw-Hill, 1970.

244
Numerical Integration
from numarray import array
from math import sqrt
from triangleQuad import *
def f(x,y):
return (x**2 + y**2)/2.0
\
- (x**3 - 3.0*x*y**2)/6.0
\
- 2.0/3.0
xCorner = array([-1.0, -1.0, 2.0])
yCorner = array([sqrt(3.0), -sqrt(3.0), 0.0])
print ’’Integral =’’,triangleQuad(f,xCorner,yCorner)
raw_input(’’Press return to
exit’’)
Since the integrand is a cubic, this quadrature is also exact, the result being
Integral = -1.55884572681
Note that only four function evaluations were required when using the triangle
formulas. In contrast, the function had to be evaluated at nine points in part (1).
EXAMPLE 6.17
The corner coordinates of a triangle are (0, 0), (16, 10) and (12, 20). Compute
. .
A

x2 −y2 
dx dy over this triangle.
Solution
12
4
10
10
a
b
c
x
y
Because f (x, y) is quadratic, quadrature over the three integration points shown
in Fig. 6.10(b) will be sufﬁcient for an “exact” result. Note that the integration points
lie in the middle of each side; their coordinates are (6, 10), (8, 5) and (14, 15). The area
of the triangle is obtained from Eq. (6.49):
A = 1
2

1
1
1
x1
x2
x3
y1
y2
y3

= 1
2

1
1
1
0 16 12
0 10 20

= 100

245
6.5 Multiple Integrals
From Eq. (6.51) we get
I = A
c

k=a
Wk f (xk, yk)
= 100
$1
3 f (6, 10) + 1
3 f (8, 5) + 1
3 f (14, 15)
%
= 100
3

(62 −102) + (82 −52) + (142 −152)

= 1800
PROBLEM SET 6.3
1. Use Gauss–Legendre quadrature to compute
/ 1
−1
/ 1
−1
(1 −x2)(1 −y2) dx dy
2. Evaluate the following integral with Gauss–Legendre quadrature:
/ 2
y=0
/ 3
x=0
x2y2 dx dy
3. Compute the approximate value of
/ 1
−1
/ 1
−1
e−(x2+y2) dx dy
with Gauss–Legendre quadrature. Use integration order (a) two and (b) three.
(The “exact” value of the integral is 2.230 985.)
4. Use third-order Gauss–Legendre quadrature to obtain an approximate value of
/ 1
−1
/ 1
−1
cos π(x −y)
2
dx dy
(The “exact” value of the integral is 1.621 139.)
5.
4
4
2
x
y
Map the integral
. .
A xy dx dy from the quadrilateral region shown to the “stan-
dard” rectangle and then evaluate it analytically.

246
Numerical Integration
6.
4
4
3
2
x
y
Compute
. .
A x dx dy over the quadrilateral region shown by ﬁrst mapping it into
the “standard” rectangle and then integrating analytically.
7.
4
2
3
x
y
Use quadrature to compute
. .
A x2 dx dy over the triangle shown.
8. Evaluate
. .
A x3 dx dy over the triangle shown in Prob. 7.
9.
4
x
y
3
Evaluate
. .
A(3 −x)y dx dy over the region shown.
10. Evaluate
. .
A x2y dx dy over the triangle shown in Prob. 9.
11. ■
1
3
x
y
2
1
3
2
Evaluate
. .
A xy(2 −x2)(2 −xy) dx dy over the region shown.
12. ■Compute
. .
A xy exp(−x2) dx dy over the region shown in Prob. 11 to four dec-
imal places.

247
6.5 Multiple Integrals
13. ■
1
1
x
y
Evaluate
. .
A(1 −x)(y −x)y dx dy over the triangle shown.
14. ■Estimate
. .
A sin πx dx dy over the region shown in Prob. 13. Use the cubic
integration formula for a triangle. (The exact integral is 1/π.)
15. ■Compute
. .
A sin πx sin π(y −x) dx dy to six decimal places, where A is
the triangular region shown in Prob. 13. Consider the triangle as a degenerate
quadrilateral.
16. ■
1
1
1
1
y
x
Write a program to evaluate
. .
A f (x, y) dx dy over an irregular region that has
been divided into several triangular elements. Use the program to compute
. .
A xy(y −x) dx dy over the region shown.

7
Initial Value Problems
Solve y′ = F(x, y) with the auxiliary conditions y(a) = α
7.1
Introduction
The general form of a ﬁrst-order differential equation is
y′ = f (x, y)
(7.1a)
where y′ = dy/dxand f (x, y)isagivenfunction.Thesolutionofthisequationcontains
anarbitraryconstant(theconstantofintegration).Toﬁndthisconstant,wemustknow
a point on the solution curve; that is, y must be speciﬁed at some value of x, say at
x = a. We write this auxiliary condition as
y(a) = α
(7.1b)
An ordinary differential equation of order n
y(n) = f

x, y, y′, . . . , y(n−1) 
(7.2)
can always transformed into n ﬁrst-order equations. Using the notation
y0 = y
y1 = y′
y2 = y′′
. . .
yn−1 = y(n−1)
(7.3)
the equivalent ﬁrst-order equations are
y′
0 = y1
y′
1 = y2
y′
2 = y3
. . .
y′
n = f (x, y0, y1, . . . , yn−1)
(7.4a)
The solution now requires the knowledge n auxiliary conditions. If these conditions
are speciﬁed at the same value of x, the problem is said to be an initial value problem.
Then the auxiliary conditions, called initial conditions, have the form
y0(a) = α0
y1(a) = α1
. . .
yn−1(a) = αn−1
(7.4b)
248

249
7.2 Taylor Series Method
If yi are speciﬁed at different values of x, the problem is called a boundary value
problem.
For example,
y′′ = −y
y(0) = 1
y′(0) = 0
is an initial value problem since both auxiliary conditions imposed on the solution
are given at x = 0. On the other hand,
y′′ = −y
y(0) = 1
y(π) = 0
is a boundary value problem because the two conditions are speciﬁed at different
values of x.
In this chapter we consider only initial value problems. The more difﬁcult bound-
ary value problems are discussed in the next chapter. We also make extensive use of
vector notation, which allows us manipulate sets of ﬁrst-order equations in a concise
form. For example, Eqs. (7.4) are written as
y′ = F(x, y)
y(a) = α
(7.5a)
where
F(x, y) =


y1
y2
...
f (x, y)


(7.5b)
A numerical solution of differential equations is essentially a table of x- and y-values
listed at discrete intervals of x.
7.2
Taylor Series Method
The Taylor series method is conceptually simple and capable of high accuracy. Its
basis is the truncated Taylor series for y about x:
y(x + h) ≈y(x) + y′(x)h + 1
2!y′′(x)h2 + 1
3!y′′′(x)h3 + · · · + 1
m!y(m)(x)hm
(7.6)
Because Eq. (7.6) predicts y at x + h from the information available at x, it is also a
formula for numerical integration. The last term kept in the series determines the
order of integration. For the series in Eq. (7.6) the integration order is m.
The truncation error, due to the terms omitted from the series, is
E =
1
(m+ 1)!y(m+1)(ξ)hm+1,
x < ξ < x + h

250
Initial Value Problems
Using the ﬁnite difference approximation
y(m+1)(ξ) ≈y(m)(x + h) −y(m)(x)
h
we obtain the more usable form
E ≈
hm
(m+ 1)!

y(m)(x + h) −y(m)(x)

(7.7)
which could be incorporated in the algorithm to monitor the error in each integration
step.
■taylor
Thefunction taylorimplementstheTaylorseriesmethodofintegrationoforderfour.
It can handle any number of ﬁrst-order differential equations y′
i = fi(x, y0, y1, . . .),
i = 0, 1, . . . . The user is required to supply the function deriv that returns the 4 × n
array
D =


(y′)T
(y′′)T
(y′′′)T
(y(4))T

=


y′
0
y′
1
· · ·
y′
n−1
y′′
0
y′′
1
· · ·
y′′
n−1
y′′′
0
y′′′
1
· · ·
y′′′
n−1
y(4)
0
y(4)
1
· · ·
y(4)
n−1


The function returns the arrays X and Y that contain the values of x and y at intervals h.
## module taylor
’’’ X,Y = taylor(deriv,x,y,xStop,h).
4th-order Taylor series method for solving the initial
value problem {y}’ = {F(x,{y})}, where
{y}
= {y[0],y[1],...y[n-1]}.
x,y
= initial conditions
xStop = terminal value of x
h
= increment of x used in integration
deriv = user-supplied function that returns the 4 x n array
[y’[0]
y’[1]
y’[2] ...
y’[n-1]
y’’[0]
y’’[1]
y’’[2] ...
y’’[n-1]
y’’’[0]
y’’’[1]
y’’’[2] ... y’’’[n-1]
y’’’’[0]
y’’’’[1]
y’’’’[2] ... y’’’’[n-1]]
’’’
from numarray import array
def taylor(deriv,x,y,xStop,h):
X = []

251
7.2 Taylor Series Method
Y = []
X.append(x)
Y.append(y)
while x < xStop:
# Loop over integration steps
h = min(h,xStop - x)
D = deriv(x,y)
# Derivatives of y
H = 1.0
for j in range(4):
# Build Taylor series
H = H*h/(j + 1)
y = y + D[j]*H
# H = hˆj/j!
x = x + h
X.append(x)
# Append results to
Y.append(y)
# lists X and Y
return array(X),array(Y)
# Convert lists into arrays
■printSoln
Weusethisfunctiontoprint Xand Yobtainedfromnumericalintegration.Theamount
of data is controlled by the parameter freq. For example, if freq = 5, every 5th
integration step would be displayed. If freq = 0, only the initial and ﬁnal values will
be shown.
## module printSoln
’’’ printSoln(X,Y,freq).
Prints X and Y returned from the differential
equation solvers using printput frequency ’freq’.
freq = n prints every nth step.
freq = 0 prints initial and final values only.
’’’
def printSoln(X,Y,freq):
def printHead(n):
print ’’\n
x
’’,
for i in range (n):
print ’’
y[’’,i,’’] ’’,
print
def printLine(x,y,n):
print ’’%13.4e’’% x,
for i in range (n):

252
Initial Value Problems
print ’’%13.4e’’% y[i],
print
m = len(Y)
try: n = len(Y[0])
except TypeError: n = 1
if freq == 0: freq = m
printHead(n)
for i in range(0,m,freq):
printLine(X[i],Y[i],n)
if i != m - 1: printLine(X[m - 1],Y[m - 1],n)
EXAMPLE 7.1
Given that
y′ + 4y = x2
y(0) = 1
determine y(0.1) with the fourth-order Taylor series method using a single integration
step. Also compute the estimated error from Eq. (7.7) and compare it with the actual
error. The analytical solution of the differential equation is
y = 31
32e−4x + 1
4 x2 −1
8 x + 1
32
Solution The Taylor series up to and including the term with h4 is
y(h) = y(0) + y′(0)h + 1
2! y′′(0)h2 + 1
3! y′′′(0)h3 + 1
4! y(4)(0)h4
(a)
Differentiation of the differential equation yields
y′ = −4y + x2
y′′ = −4y′ + 2x = 16y −4x2 + 2x
y′′′ = 16y′ −8x + 2 = −64y + 16x2 −8x + 2
y(4) = −64y′ + 32x −8 = 256y −64x2 + 32x −8
Thus at x = 0 we have
y′(0) = −4(1) = −4
y′′(0) = 16(1) = 16
y′′′(0) = −64(1) + 2 = −62
y(4)(0) = 256(1) −8 = 248

253
7.2 Taylor Series Method
With h = 0.1 Eq. (a) becomes
y(0.1) = 1 + (−4)(0.1) + 1
2!(16)(0.1)2 + 1
3!(−62)(0.1)3 + 1
4!(248)(0.1)4
= 0.670700
According to Eq. (7.7) the approximate truncation error is
E = h4
5!

y(4)(0.1) −y(4)(0)

where
y(4)(0) = 248
y(4)(0.1) = 256(0.6707) −64(0.1)2 + 32(0.1) −8 = 166.259
Therefore,
E = (0.1)4
5!
(166.259 −248) = −6.8 × 10−5
The analytical solution yields
y(0.1) = 31
32e−4(0.1) + 1
4(0.1)2 −1
8(0.1) + 1
32 = 0.670623
so that the actual error is 0.670623 −0.670700 = −7.7 × 10−5.
EXAMPLE 7.2
Solve
y′′ = −0.1y′ −x
y(0) = 0
y′(0) = 1
from x = 0 to 2 with the Taylor series method of order four. Use h = 0.25 and utilize
the functions taylor and printSoln.
Solution With the notation y0 = y and y1 = y′ the equivalent ﬁrst-order equations
and the initial conditions are
y′ =
)
y′
0
y′
1
*
=
)
y1
−0.1y1 −x
*
y(0) =
)
0
1
*
Repeated differentiation of the differential equations yields
y′′ =
)
y′
1
−0.1y′
1 −1
*
=
)
−0.1y1 −x
0.01y1 + 0.1x −1
*
y′′′ =
)
−0.1y′
1 −1
0.01y′
1 + 0.1
*
=
)
0.01y1 + 0.1x −1
−0.001y1 −0.01x + 0.1
*
y(4) =
)
0.01y′
1 + 0.1
−0.001y′
1 −0.01
*
=
)
−0.001y1 −0.01x + 0.1
0.0001y1 + 0.001x −0.01
*

254
Initial Value Problems
Thus the derivative array that has to be computed by the function deriv is
D =


y1
−0.1y1 −x
−0.1y1 −x
0.01y1 + 0.1x −1
0.01y1 + 0.1x −1
−0.001y1 −0.01x + 0.1
−0.001y1 −0.01x + 0.1
0.0001y1 + 0.001x −0.01


Here is the program that performs the integration:
#!/usr/bin/python
## example7_2
from printSoln import *
from taylor import *
def deriv(x,y):
D = zeros((4,2),type=Float64)
D[0] = [y[1]
, -0.1*y[1] - x]
D[1] = [D[0,1],
0.01*y[1] + 0.1*x - 1.0]
D[2] = [D[1,1], -0.001*y[1] - 0.01*x + 0.1]
D[3] = [D[2,1],
0.0001*y[1] + 0.001*x - 0.01]
return D
x = 0.0
# Start of integration
xStop = 2.0
# End of integration
y = array([0.0, 1.0]) # Initial values of {y}
h = 0.25
# Step size
freq = 1
# Printout frequency
X,Y = taylor(deriv,x,y,xStop,h)
printSoln(X,Y,freq)
raw_input(’’\nPress return to exit’’)
The results are:
x
y[ 0 ]
y[ 1 ]
0.0000e+000
0.0000e+000
1.0000e+000
2.5000e-001
2.4431e-001
9.4432e-001
5.0000e-001
4.6713e-001
8.2829e-001
7.5000e-001
6.5355e-001
6.5339e-001
1.0000e+000
7.8904e-001
4.2110e-001
1.2500e+000
8.5943e-001
1.3281e-001
1.5000e+000
8.5090e-001
-2.1009e-001
1.7500e+000
7.4995e-001
-6.0625e-001
2.0000e+000
5.4345e-001
-1.0543e+000

255
7.3 Runge–Kutta Methods
The analytical solution of the problem is
y = 100x −5x2 + 990(e−0.1x −1)
fromwhichweobtain y(2) = 0.543 446,whichagreeswellwiththenumericalsolution.
7.3
Runge–Kutta Methods
The main drawback of the Taylor series method is that it requires repeated differen-
tiation of the dependent variables. These expressions may become very long and are,
therefore, error-prone and tedious to compute. Moreover, there is the extra work of
coding each of the derivatives. The aim of Runge–Kutta methods is to eliminate the
need for repeated differentiation of the differential equations. Since no such differen-
tiation is involved in the ﬁrst-order Taylor series integration formula
y(x + h) = y(x) + y′(x)h = y(x) + F(x, y)h
(7.8)
it can also be considered as the ﬁrst-order Runge–Kutta method; it is also called Euler’s
method. Due to excessive truncation error, this method is rarely used in practice.
y' (x)
x
x
x + h
Euler's formula
Error
f (x,y)
Figure 7.1. Graphical representation of Euler’s formula.
Let us now take a look at the graphical interpretation of Euler’s formula. For the
sake of simplicity, we assume that there is a single dependent variable y, so that
the differential equation is y′ = f (x, y). The change in the solution y between x and
x + h is
y(x + h) −y(h) =
/ x+h
x
y′ dx =
/ x+h
x
f (x, y)dx
which is the area of the panel under the y′(x) plot, shown in Fig. 7.1. Euler’s formula
approximates this area by the area of the cross-hatched rectangle. The area between
the rectangle and the plot represents the truncation error. Clearly, the truncation error
is proportional to the slope of the plot; that is, proportional to y′′(x).
Second-Order Runge–Kutta Method
To arrive at the second-order method, we assume an integration formula of the form
y(x + h) = y(x) + c0F(x, y)h + c1F

x + ph, y + qhF(x, y)

h
(a)

256
Initial Value Problems
and attempt to ﬁnd the parameters c0, c1, p and q by matching Eq. (a) to the Taylor
series
y(x + h) = y(x) + y′(x)h + 1
2!y′′(x)h2 + O(h3)
= y(x) + F(x, y)h + 1
2F′(x, y)h2 + O(h3)
(b)
Noting that
F′(x, y) = ∂F
∂x +
n−1

i=0
∂F
∂yi
y′
i = ∂F
∂x +
n−1

i=0
∂F
∂yi
Fi(x, y)
where n is the number of ﬁrst-order equations, we can write Eq. (b) as
y(x + h) = y(x) + F(x, y)h + 1
2

∂F
∂x +
n−1

i=0
∂F
∂yi
Fi(x, y)

h2 + O(h3)
(c)
Returning to Eq. (a), we can rewrite the last term by applying a Taylor series in
several variables:
F

x + ph, y + qhF(x, y)

= F(x, y) + ∂F
∂x ph + qh
n−1

i=1
∂F
∂yi
Fi(x, y) + O(h2)
so that Eq. (a) becomes
y(x + h) = y(x) + (c0 + c1) F(x, y)h + c1
)
∂F
∂x ph + qh
n−1

i=1
∂F
∂yi
Fi(x, y)
*
h + O(h3)
(d)
Comparing Eqs. (c) and (d), we ﬁnd that they are identical if
c0 + c1 = 1
c1 p = 1
2
c1q = 1
2
(e)
BecauseEqs.(e)representthreeequationsinfourunknownparameters,wecanassign
any value to one of the parameters. Some of the popular choices and the names
associated with the resulting formulas are:
c0 = 0
c1 = 1
p = 1/2
q = 1/2
Modiﬁed Euler’s method
c0 = 1/2
c1 = 1/2
p = 1
q = 1
Heun’s method
c0 = 1/3
c1 = 2/3
p = 3/4
q = 3/4
Ralston’s method
All these formulas are classiﬁed as second-order Runge–Kutta methods, with no for-
mula having a numerical superiority over the others. Choosing the modiﬁed Euler’s
method, we substitute the corresponding parameters into Eq. (a) to yield
y(x + h) = y(x) + F
$
x + h
2, y + h
2F(x, y)
%
h
(f)

257
7.3 Runge–Kutta Methods
This integration formula can be conveniently evaluated by the following sequence of
operations
K0 = hF(x, y)
K1 = hF
&
x + h
2, y + 1
2K0
'
(7.9)
y(x + h) = y(x) + K1
Second-order methods are not popular in computer application. Most programmers
prefer integration formulas of order four, which achieve a given accuracy with less
computational effort.
y'(x )
x
x
x + h
h/2
h/2
f (x,y)
f(x + h/2, y + K0/2)
Figure 7.2. Graphical representation of modiﬁed Euler
formula.
Figure 7.2 displays the graphical interpretation of modiﬁed Euler’s formula for
a single differential equation y′ = f (x, y). The ﬁrst of Eqs. (7.9) yields an estimate of
y at the midpoint of the panel by Euler’s formula: y(x + h/2) = y(x) + f (x, y)h/2 =
y(x) + K0/2. The second equation then approximates the area of the panel by the area
K1 of the cross-hatched rectangle. The error here is proportional to the curvature y′′′
of the plot.
Fourth-Order Runge–Kutta Method
The fourth-order Runge–Kutta method is obtained from the Taylor series along the
samelinesasthesecond-ordermethod.Sincethederivationisratherlongandnotvery
instructive, we skip it. The ﬁnal form of the integration formula again depends on the
choiceoftheparameters;thatis,thereisnouniqueRunge–Kuttafourth-orderformula.
The most popular version, which is known simply as the Runge–Kutta method, entails
the following sequence of operations:
K0 = hF(x, y)
K1 = hF
&
x + h
2, y + K0
2
'
K2 = hF
&
x + h
2, y + K1
2
'
(7.10)
K3 = hF(x + h, y + K2)
y(x + h) = y(x) + 1
6(K0 + 2K1 + 2K2 + K3)

258
Initial Value Problems
Themaindrawbackofthismethodisthatitdoesnotlenditselftoanestimateofthe
truncation error. Therefore, we must guess the integration step size h, or determine
it by trial and error. In contrast, the so-called adaptive methods can evaluate the
truncation error in each integration step and adjust the value of h accordingly (but at
a higher cost of computation). One such adaptive method is introduced in the next
article.
■run kut4
The function integrate in this module implements the Runge–Kutta method of
order four. The user must provide integrate with the function F(x,y) that deﬁnes
the ﬁrst-order differential equations y′ = F(x, y).
## module run_kut4
’’’ X,Y = integrate(F,x,y,xStop,h).
4th-order Runge-Kutta method for solving the
initial value problem {y}’ = {F(x,{y})}, where
{y}
= {y[0],y[1],...y[n-1]}.
x,y
= initial conditions.
xStop = terminal value of x.
h
= increment of x used in integration.
F
= user-supplied function that returns the
array F(x,y) = {y’[0],y’[1],...,y’[n-1]}.
’’’
from numarray import array
def integrate(F,x,y,xStop,h):
def run_kut4(F,x,y,h):
# Computes increment of y from Eqs. (7.10)
K0 = h*F(x,y)
K1 = h*F(x + h/2.0, y + K0/2.0)
K2 = h*F(x + h/2.0, y + K1/2.0)
K3 = h*F(x + h, y + K2)
return (K0 + 2.0*K1 + 2.0*K2 + K3)/6.0
X = []
Y = []
X.append(x)
Y.append(y)
while x < xStop:
h = min(h,xStop - x)
y = y + run_kut4(F,x,y,h)

259
7.3 Runge–Kutta Methods
x = x + h
X.append(x)
Y.append(y)
return array(X),array(Y)
EXAMPLE 7.3
Use the second-order Runge–Kutta method to integrate
y′ = sin y
y(0) = 1
from x = 0 to 0.5 in steps of h = 0.1. Keep four decimal places in the computations.
Solution In this problem we have
F(x, y) = sin y
so that the integration formulas in Eqs. (7.9) are
K0 = hF(x, y) = 0.1 sin y
K1 = hF
&
x + h
2, y + 1
2 K0
'
= 0.1 sin
&
y + 1
2 K0
'
y(x + h) = y(x) + K1
Noting that y(0) = 1, we may proceed with the integration as follows:
K0 = 0.1 sin 1.0000 = 0.0841
K1 = 0.1 sin
&
1.0000 + 0.0841
2
'
= 0.0863
y(0.1) = 1.0 + 0.0863 = 1.0863
K0 = 0.1 sin 1.0863 = 0.0885
K1 = 0.1 sin
&
1.0863 + 0.0885
2
'
= 0.0905
y(0.2) = 1.0863 + 0.0905 = 1.1768
and so on. A summary of the computations is shown in the table below.
x
y
K0
K1
0.0
1.0000
0.0841
0.0863
0.1
1.0863
0.0885
0.0905
0.2
1.1768
0.0923
0.0940
0.3
1.2708
0.0955
0.0968
0.4
1.3676
0.0979
0.0988
0.5
1.4664

260
Initial Value Problems
The exact solution can be shown to be
x(y) = ln(csc y −cot y) + 0.604582
which yields x(1.4664) = 0.5000. Therefore, up to this point the numerical solution is
accurate to four decimal places. However, it is unlikely that this precision would be
maintained if we were to continue the integration. Since the errors (due to truncation
androundoff)tendtoaccumulate,longerintegrationrangesrequirebetterintegration
formulas and more signiﬁcant ﬁgures in the computations.
EXAMPLE 7.4
Solve
y′′ = −0.1y′ −x
y(0) = 0
y′(0) = 1
from x = 0 to 2 in increments of h = 0.25 with the Runge–Kutta method of order four.
(This problem was solved by the Taylor series method in Example 7.2.)
Solution Letting y0 = y and y1 = y′, we write the equivalent ﬁrst-order equations as
y′ = F(x, y) =
)
y′
0
y′
1
*
=
)
y1
−0.1y1 −x
*
Comparing the function F(x,y)here with deriv(x,y)in Example 7.2 we note that it
is much simpler to input the differential equations in the Runge–Kutta method than
in the Taylor series method.
#!/usr/bin/python
## example7_4
from numarray import array,zeros,Float64
from printSoln import *
from run_kut4 import *
def F(x,y):
F = zeros((2),type=Float64)
F[0] = y[1]
F[1] = -0.1*y[1] - x
return F
x = 0.0
# Start of integration
xStop = 2.0
# End of integration
y = array([0.0, 1.0])
# Initial values of {y}
h = 0.25
# Step size
freq = 1
# Printout frequency

261
7.3 Runge–Kutta Methods
X,Y = integrate(F,x,y,xStop,h)
printSoln(X,Y,freq)
raw_input(’’Press return to exit’’)
The output from the fourth-order method is shown below. The results are the
same as obtained by the Taylor series method in Example 7.2. This was expected,
since both methods are of the same order.
x
y[ 0 ]
y[ 1 ]
0.0000e+000
0.0000e+000
1.0000e+000
2.5000e-001
2.4431e-001
9.4432e-001
5.0000e-001
4.6713e-001
8.2829e-001
7.5000e-001
6.5355e-001
6.5339e-001
1.0000e+000
7.8904e-001
4.2110e-001
1.2500e+000
8.5943e-001
1.3281e-001
1.5000e+000
8.5090e-001
-2.1009e-001
1.7500e+000
7.4995e-001
-6.0625e-001
2.0000e+000
5.4345e-001
-1.0543e+000
EXAMPLE 7.5
Use the fourth-order Runge–Kutta method to integrate
y′ = 3y −4e−x
y(0) = 1
from x = 0 to 10 in steps of h = 0.1. Compare the result with the analytical solution
y = e−x.
Solution We used the program shown below. Recalling that run kut4 assumes y to
be an array, we speciﬁed the initial value as y = array([1.0]) rather than y = 1.0.
#!/usr/bin/python
## example7_5
from numarray import zeros,Float64,array
from run_kut4 import *
from printSoln import *
from math import exp
def F(x,y):
F = zeros((1),type=Float64)
F[0] = 3.0*y[0] - 4.0*exp(-x)
return F

262
Initial Value Problems
x = 0.0
# Start of integration
xStop = 10.0
# End of integration
y = array([1.0])
# Initial values of {y}
h = 0.1
# Step size
freq = 20
# Printout frequency
X,Y = integrate(F,x,y,xStop,h)
printSoln(X,Y,freq)
raw_input(’’\nPress return to exit’’)
Running the program produced the following output:
x
y[ 0 ]
0.0000e+000
1.0000e+000
2.0000e+000
1.3250e-001
4.0000e+000
-1.1237e+000
6.0000e+000
-4.6056e+002
8.0000e+000
-1.8575e+005
1.0000e+001
-7.4912e+007
It is clear that something went wrong. According to the analytical solution, y
should approach zero with increasing x, but the output shows the opposite trend:
after an initial decrease, the magnitude of y increases dramatically. The explanation
is found by taking a closer look at the analytical solution. The general solution of the
given differential equation is
y = Ce3x + e−x
which can be veriﬁed by substitution. The initial condition y(0) = 1 yields C = 0, so
that the solution to the problem is indeed y = e−x.
The cause of trouble in the numerical solution is the dormant term Ce3x. Suppose
that the initial condition contains a small error ε, so that we have y(0) = 1 + ε. This
changes the analytical solution to
y = εe3x + e−x
We now see that the term containing the error ε becomes dominant as x is increased.
Sinceerrorsinherentinthenumericalsolutionhavethesameeffectassmallchangesin
initial conditions, we conclude that our numerical solution is the victim of numerical
instability due to sensitivity of the solution to initial conditions. The lesson is: do not
blindly trust the results of numerical integration.

263
7.3 Runge–Kutta Methods
EXAMPLE 7.6
Re
r
v0
H
A spacecraft is launched at altitude H = 772 km above sea level with the speed
v0 = 6700 m/s in the direction shown. The differential equations describing the mo-
tion of the spacecraft are
¨r = r ˙θ
2 −GMe
r2
¨θ = −2˙r ˙θ
r
where r and θ are the polar coordinates of the spacecraft. The constants involved in
the motion are
G = 6.672 × 10−11 m3kg−1s−2 = universal gravitational constant
Me = 5.9742 × 1024 kg = mass of the earth
Re = 6378.14 km = radius of the earth at sea level
(1) Derive the ﬁrst-order differential equations and the initial conditions of the form
˙y = F(t, y), y(0) = b. (2) Use the fourth-order Runge–Kutta method to integrate the
equations from the time of launch until the spacecraft hits the earth. Determine θ at
the impact site.
Solution of Part (1) We have
GMe =

6.672 × 10−11 
5.9742 × 1024 
= 3.9860 × 1014 m3s−2
Letting
y =


y0
y1
y2
y3

=


r
˙r
θ
˙θ


the equivalent ﬁrst-order equations become
˙y =


˙y0
˙y1
˙y2
˙y3

=


y1
y0y2
3 −3.9860 × 1014/y2
0
y3
−2y1y3/y0



264
Initial Value Problems
and the initial conditions are
r(0) = Re + H = Re = (6378.14 + 772) × 103 = 7. 15014 × 106 m
˙r(0) = 0
θ(0) = 0
˙θ(0) = v0/r(0) = (6700) /(7.15014 × 106) = 0.937045 × 10−3 rad/s
Therefore,
y(0) =


7. 15014 × 106
0
0
0.937045 × 10−3


Solution of Part (2) The program used for numerical integration is listed below.
Note that the independent variable t is denoted by x. The period of integration
xStop (the time when the spacecraft hits) was estimated from a previous run of the
program.
#!/usr/bin/python
## example7_6
from numarray import zeros,Float64,array
from run_kut4 import *
from printSoln import *
def F(x,y):
F = zeros((4),type=Float64)
F[0] = y[1]
F[1] = y[0]*(y[3]**2) - 3.9860e14/(y[0]**2)
F[2] = y[3]
F[3] = -2.0*y[1]*y[3]/y[0]
return F
x = 0.0
xStop = 1200.0
y = array([7.15014e6, 0.0, 0.0, 0.937045e-3])
h = 50.0
freq = 2
X,Y = integrate(F,x,y,xStop,h)
printSoln(X,Y,freq)
raw_input(’’\nPress return to exit’’)

265
7.3 Runge–Kutta Methods
Here is the output:
x
y[ 0 ]
y[ 1 ]
y[ 2 ]
y[ 3 ]
0.0000e+000
7.1501e+006
0.0000e+000
0.0000e+000
9.3704e-004
1.0000e+002
7.1426e+006 -1.5173e+002
9.3771e-002
9.3904e-004
2.0000e+002
7.1198e+006 -3.0276e+002
1.8794e-001
9.4504e-004
3.0000e+002
7.0820e+006 -4.5236e+002
2.8292e-001
9.5515e-004
4.0000e+002
7.0294e+006 -5.9973e+002
3.7911e-001
9.6951e-004
5.0000e+002
6.9622e+006 -7.4393e+002
4.7697e-001
9.8832e-004
6.0000e+002
6.8808e+006 -8.8389e+002
5.7693e-001
1.0118e-003
7.0000e+002
6.7856e+006 -1.0183e+003
6.7950e-001
1.0404e-003
8.0000e+002
6.6773e+006 -1.1456e+003
7.8520e-001
1.0744e-003
9.0000e+002
6.5568e+006 -1.2639e+003
8.9459e-001
1.1143e-003
1.0000e+003
6.4250e+006 -1.3708e+003
1.0083e+000
1.1605e-003
1.1000e+003
6.2831e+006 -1.4634e+003
1.1269e+000
1.2135e-003
1.2000e+003
6.1329e+006 -1.5384e+003
1.2512e+000
1.2737e-003
The spacecraft hits the earth when r equals Re = 6.378 14 × 106 m. This occurs
betweent = 1000and1100s.Amoreaccuratevalueoft canbeobtainedbypolynomial
interpolation. If no great precision is needed, linear interpolation will do. Letting
1000 + t be the time of impact, we can write
r(1000 + t) = Re
Expanding r in a two-term Taylor series, we get
r(1000) + ˙r(1000)t = Re
6.4250 × 106 +

−1.3708 × 103 
t = 6378.14 × 103
from which
t = 34.184 s
Thus the time of impact is 1034.25.
The coordinate θ of the impact site can be estimated in a similar manner. Using
again two terms of the Taylor series, we have
θ(1000 + t) = θ(1000) + ˙θ(1000)t
= 1.0083 +

1.1605 × 10−3 
(34.184)
= 1.0480 rad = 60.00◦

266
Initial Value Problems
PROBLEM SET 7.1
1. Given
y′ + 4y = x2
y(0) = 1
compute y(0.1) using two steps of the Taylor series method of order two. Compare
the result with Example 7.1.
2. SolveProb.1withonestepoftheRunge–Kuttamethodoforder(a)twoand(b)four.
3. Integrate
y′ = sin y
y(0) = 1
from x = 0 to 0.5 with the second-order Taylor series method using h = 0.1. Com-
pare the result with Example 7.3.
4. Verify that the problem
y′ = y1/3
y(0) = 0
has two solutions: y = 0 and y = (2x/3)3/2. Which of the solutions would be re-
produced by numerical integration if the initial condition is set at (a) y = 0 and
(b) y = 10−16? Verify your conclusions by integrating with any numerical method.
5. Convert the following differential equations into ﬁrst-order equations of the form
y′ = F(x, y):
(a)
ln y′ + y = sin x
(b)
y′′y −xy′ −2y2 = 0
(c)
y(4) −4y′′
1 −y2 = 0
(d)

y
′′ 2 =
32y′x −y2
6. In the following sets of coupled differential equations t is the independent vari-
able. Convert these equations into ﬁrst-order equations of the form ˙y = F(t, y):
(a)
¨y = x −2y
¨x = y −x
(b)
¨y = −y

˙y2 + ˙x2 1/4
¨x = −x

˙y2 + ˙x
 1/4 −32
(c)
¨y2 + t sin y = 4 ˙x
x ¨x + t cos y = 4 ˙y
7. ■The differential equation for the motion of a simple pendulum is
d2θ
dt2 = −g
L sin θ
where
θ = angular displacement from the vertical
g = gravitational acceleration
L = length of the pendulum

267
7.3 Runge–Kutta Methods
With the transformation τ = t

g/L the equation becomes
d2θ
dτ 2 = −sin θ
Use numerical integration to determine the period of the pendulum if the ampli-
tudeisθ0 = 1rad.Notethatforsmallamplitudes(sin θ ≈θ)theperiodis2π

L/g.
8. ■A skydiver of mass m in a vertical free fall experiences an aerodynamic drag
force FD = cD ˙y2, where y is measured downward from the start of the fall. The
differential equation describing the fall is
¨y = g −cD
m ˙y2
Determine the time of a 500 m fall. Use g = 9.80665 m/s2, cD = 0.2028 kg/m and
m= 80 kg.
9. ■
P(t)
m
k
y
The spring–mass system is at rest when the force P(t) is applied, where
P(t) =
"
10t N
when t < 2 s
20 N
when t ≥2 s
The differential equation of the ensuing motion is
¨y = P(t)
m −k
my
Determine the maximum displacement of the mass. Use m= 2.5 kg and k =
75 N/m.
10. ■
y
Water level
The conical ﬂoat is free to slide on a vertical rod. When the ﬂoat is disturbed
from its equilibrium position, it undergoes oscillating motion described by the
differential equation
¨y = g

1 −ay3 

268
Initial Value Problems
where a = 16 m−3 (determined by the density and dimensions of the ﬂoat) and
g = 9.80665 m/s2. If the ﬂoat is raised to the position y = 0.1 m and released,
determine the period and the amplitude of the oscillations.
11. ■
y(t)
L
m
The pendulum is suspended from a sliding collar. The system is at rest when the
oscillating motion y(t) = Y sin ωt is imposed on the collar, starting at t = 0. The
differential equation describing the motion of the pendulum is
¨θ = −g
L sin θ + ω2
L Y cos θ sin ωt
Plot θ vs. t from t = 0 to 10 s and determine the largest θ during this period. Use
g = 9.80665 m/s2, L = 1.0 m, Y = 0.25 m and ω = 2.5 rad/s.
12. ■
2 m
r
(t)
The system consisting of a sliding mass and a guide rod is at rest with the mass
at r = 0.75 m. At time t = 0 a motor is turned on that imposes the motion θ(t) =
(π/12) cos πt ontherod.Thedifferentialequationdescribingtheresultingmotion
of the slider is
¨r =
&π2
12
'2
r sin2 πt −g sin
, π
12 cos πt
-
Determine the time when the slider reaches the tip of the rod. Use g =
9.80665 m/s2.
13. ■
30
v0
m
R
y
x

269
7.3 Runge–Kutta Methods
A ball of mass m= 0.25 kg is launched with the velocity v0 = 50 m/s in the direc-
tion shown. If the aerodynamic drag force acting on the ball is FD = CDv3/2, the
differential equations describing the motion are
¨x = −CD
m ˙xv1/2
¨y = −CD
m ˙yv1/2 −g
where v =

˙x2 + ˙y2. Determine the time of ﬂight and the range R. Use CD =
0.03 kg/(m·s)1/2 and g = 9.80665 m/s2.
14. ■The differential equation describing the angular position θ of a mechanical arm
is
¨θ = a(b −θ) −θ ˙θ
2
1 + θ2
where a = 100 s−2 and b = 15. If θ(0) = 2π and ˙θ(0) = 0, compute θ and ˙θ when
t = 0.5 s.
15. ■
r
m
L = undeformed length
k = stiffness
The mass m is suspended from an elastic cord with an extensional stiffness k and
undeformed length L. If the mass is released from rest at θ = 60◦with the cord
unstretched, ﬁnd the length r of the cord when the position θ = 0 is reached for
the ﬁrst time. The differential equations describing the motion are
¨r = r ˙θ
2 + g cos θ −k
m(r −L)
¨θ = −2˙r ˙θ −g sin θ
r
Use g = 9.80665 m/s2, k = 40 N/m, L = 0.5 m and m= 0.25 kg.
16. ■Solve Prob. 15 if the mass is released from the position θ = 60◦with the cord
stretched by 0.075 m.
17. ■
m
k
y
µ

270
Initial Value Problems
Consider the mass–spring system where dry friction is present between the block
and the horizontal surface. The frictional force has a constant magnitude µmg
(µ is the coefﬁcient of friction) and always opposes the motion. The differential
equation for the motion of the block can be expressed as
¨y = −k
my −µg ˙y
| ˙y|
where y ismeasuredfromthepositionwherethespringisunstretched.Iftheblock
isreleasedfromrestat y = y0,verifybynumericalintegrationthatthenextpositive
peak value of y is y0 −4µ mg/k (this relationship can be derived analytically). Use
k = 3000 N/m, m= 6 kg, µ = 0.5, g = 9.80665 m/s2 and y0 = 0.1 m.
18. ■Integrate the following problems from x = 0 to 20 and plot y vs. x:
(a)
y′′ + 0.5(y2 −1)y′ + y = 0
y(0) = 1
y′(0) = 0
(b)
y′′ = y cos 2x
y(0) = 0
y′(0) = 1
These differential equations arise in nonlinear vibration analysis.
19. ■The solution of the problem
y′′ + 1
x y′ + y
y(0) = 1
y′(0) = 0
is the Bessel function J0(x). Use numerical integration to compute J0(5) and com-
pare the result with −0.17760, the value listed in mathematical tables. Hint: to
avoid singularity at x = 0, start the integration at x = 10−12.
20. ■Consider the initial value problem
y′′ = 16.81y
y(0) = 1.0
y′(0) = −4.1
(a) Derive the analytical solution. (b) Do you anticipate difﬁculties in numerical
solution of this problem? (c) Try numerical integration from x = 0 to 8 to see if
your concerns were justiﬁed.
21. ■
R
R
C
2R
i2
i1
i1
i2
L
E(t)
Kirchoff’s equations for the circuit shown are
L di1
dt + Ri1 + 2R(i1 + i2) = E(t)
(a)
q2
C + Ri2 + 2R(i2 + i1) = E(t)
(b)

271
7.4 Stability and Stiffness
where i1 and i2 are the loop currents, and q2 is the charge of the condenser.
Differentiating Eq. (b) and substituting the charge–current relationship dq2/dt =
i2, we get
di1
dt = −3Ri1 −2Ri2 + E(t)
L
(c)
di2
dt = −2
3
di1
dt −
i2
3RC + 1
3R
dE
dt
(d)
Wecouldsubstitutedi1/dt fromEq.(c)intoEq.(d),sothatthelatterwouldassume
theusualformdi2/dt = f (t, i1, i2),butitismoreconvenienttoleavetheequations
as they are. Assuming that the voltage source is turned on at time t = 0, plot the
loop currents i1 and i2 from t = 0 to 0.05 s. Use E(t) = 240 sin(120πt) V, R = 1.0 ,
L = 0.2 × 10−3 H and C = 3.5 × 10−3 F.
22. ■
L
L
R
R
C
C
E
i1
i2
i1
i2
The constant voltage source of the circuit shown is turned on at t = 0, causing
transientcurrentsi1 andi2 inthetwoloopsthatlastabout0.05s.Plotthesecurrents
fromt = 0to0.05s,usingthefollowingdata: E = 9V, R = 0.25 , L = 1.2 × 10−3 H
and C = 5 × 10−3 F. Kirchoff’s equations for the two loops are
L di1
dt + Ri1 + q1 −q2
C
= E
L di2
dt + Ri2 + q2 −q1
C
+ q2
C = 0
Additional two equations are the current–charge relationships
dq1
dt = i1
dq2
dt = i2
7.4
Stability and Stiffness
Loosely speaking, a method of numerical integration is said to be stable if the effects
of local errors do not accumulate catastrophically; that is, if the global error remains
bounded. If the method is unstable, the global error will increase exponentially, even-
tually causing numerical overﬂow. Stability has nothing to do with accuracy; in fact,
an inaccurate method can be very stable.

272
Initial Value Problems
Stability is determined by three factors: the differential equations, the method of
solution and the value of the increment h. Unfortunately, it is not easy to determine
stability beforehand, unless the differential equation is linear.
Stability of Euler’s Method
As a simple illustration of stability, consider the linear problem
y′ = −λy
y(0) = β
(7.11)
where λ is a positive constant. The exact solution of this problem is
y(x) = βe−λx
Let us now investigate what happens when we attempt to solve Eq. (7.11) numer-
ically with Euler’s formula
y(x + h) = y(x) + hy′(x)
(7.12)
Substituting y′(x) = −λy(x), we get
y(x + h) = (1 −λh)y(x)
If |1 −λh| > 1, the method is clearly unstable since |y| increases in every integration
step. Thus Euler’s method is stable only if |1 −λh| ≤1, or
h ≤2/λ
(7.13)
The results can be extended to a system of n differential equations of the form
y′ = −Λy
(7.14)
where Λ is a constant matrix with the positive eigenvalues λi,
i = 1, 2, . . . , n. It can
be shown that Euler’s method of integration is stable only if
h < 2/λmax
(7.15)
where λmax is the largest eigenvalue of Λ.
Stiffness
An initial value problem is called stiff if some terms in the solution vector y(x) vary
much more rapidly with x than others. Stiffness can be easily predicted for the differ-
ential equations y′ = −Λy with constant coefﬁcient matrix Λ. The solution of these
equations is y(x) = 
i Civi exp(−λix), where λi are the eigenvalues of Λ and vi are
the corresponding eigenvectors. It is evident that the problem is stiff if there is a large
disparity in the magnitudes of the positive eigenvalues.

273
7.4 Stability and Stiffness
Numerical integration of stiff equations requires special care. The step size h
needed for stability is determined by the largest eigenvalue λmax, even if the terms
exp(−λmaxx) in the solution decay very rapidly and become insigniﬁcant as we move
away from the origin.
For example, consider the differential equation20
y′′ + 1001y′ + 1000y = 0
(7.16)
Using y0 = y and y1 = y1, the equivalent ﬁrst-order equations are
y′ =
)
y1
−1000y0 −1001y1
*
In this case
Λ =
)
0
−1
1000
1001
*
The eigenvalues of Λ are the roots of
|Λ −λI| =

−λ
−1
1000
1001 −λ
 = 0
Expanding the determinant we get
−λ(1001 −λ) + 1000 = 0
which has the solutions λ1 = 1 and λ2 = 1000. These equation are clearly stiff. Accord-
ing to Eq. (7.15) we would need h < 2/λ2 = 0.002 for Euler’s method to be stable. The
Runge–Kutta method would have approximately the same limitation on the step size.
When the problem is very stiff, the usual methods of solution, such as the Runge–
Kuttaformulas,becomeimpracticalduetotheverysmallhrequiredforstability.These
problems are best solved with methods that are specially designed for stiff equations.
Stiff problem solvers, which are outside the scope of this text, have much better stabil-
ity characteristics; some of them are even unconditionally stable. However, the higher
degree of stability comes at a cost—the general rule is that stability can be improved
only by reducing the order of the method (and thus increasing the truncation error).
EXAMPLE 7.7
(1) Show that the problem
y′′ = −19
4 y −10y′
y(0) = −9
y′(0) = 0
20 This example is taken from C. E. Pearson, Numerical Methods in Engineering and Science, van
Nostrand and Reinhold (1986).

274
Initial Value Problems
is moderately stiff and estimate hmax, the largest value of hfor which the Runge–Kutta
method would be stable. (2) Conﬁrm the estimate by computing y(10) with h ≈hmax/2
and h ≈2hmax.
Solution of Part (1) With the notation y = y0 and y′ = y1 the equivalent ﬁrst-order
differential equations are
y′ =


y1
−19
4 y0 −10y1

= −Λ
)
y0
y1
*
where
Λ =


0
−1
19
4
10


The eigenvalues of Λ are given by
|Λ −λI| =

−λ
−1
19
4
10 −λ

= 0
which yields λ1 = 1/2 and λ2 = 19/2. Because λ2 is quite a bit larger than λ1, the
equations are moderately stiff.
Solution of Part (2) An estimate for the upper limit of the stable range of h can be
obtained from Eq. (7.15):
hmax =
2
λmax
=
2
19/2 = 0.2153
Although this formula is strictly valid for Euler’s method, it is usually not too far off
for higher-order integration formulas.
Here are the results from the Runge–Kutta method with h = 0.1 (by specifying
freq = 0 in printSoln, only the initial and ﬁnal values were printed):
x
y[ 0 ]
y[ 1 ]
0.0000e+000
-9.0000e+000
0.0000e+000
1.0000e+001
-6.4011e-002
3.2005e-002
The analytical solution is
y(x) = −19
2 e−x/2 + 1
2e−19x/2
yielding y(10) = −0.0640 11, which agrees with the value obtained numerically.

275
7.5 Adaptive Runge–Kutta Method
With h = 0.5 we encountered instability, as expected:
x
y[ 0 ]
y[ 1 ]
0.0000e+000
-9.0000e+000
0.0000e+000
1.0000e+001
2.7030e+020
-2.5678e+021
7.5
Adaptive Runge–Kutta Method
Determination of a suitable step size hcan be a major headache in numerical integra-
tion. If his too large, the truncation error may be unacceptable; if his too small, we are
squandering computational resources. Moreover, a constant step size may not be ap-
propriate for the entire range of integration. For example, if the solution curve starts
off with rapid changes before becoming smooth (as in a stiff problem), we should
use a small h at the beginning and increase it as we reach the smooth region. This is
where adaptive methods come in. They estimate the truncation error at each integra-
tion step and automatically adjust the step size to keep the error within prescribed
limits.
The adaptive Runge–Kutta methods use so-called embedded integration formu-
las. These formulas come in pairs: one formula has the integration order m, the
other one is of order m+ 1. The idea is to use both formulas to advance the solution
from x to x + h. Denoting the results by ym(x + h) and ym+1(x + h), we may estimate
the truncation error in the formula of order m:
E(h) = ym+1(x + h) −ym(x + h)
(7.17)
What makes the embedded formulas attractive is that they share the points where
F(x, y) is evaluated. This means that once ym(x + h) has been computed, relatively
small additional effort is required to calculate ym+1(x + h).
Here are the Runge–Kutta embedded formulas of orders 5 and 4 that were
originally derived by Fehlberg; hence they are known as Runge–Kutta–Fehlberg
formulas:
K0 = hF(x, y)
Ki = hF

x + Aih, y +
i−1

j=0
BijK j

,
i = 1, 2, . . . , 5
(7.18)
y5(x + h) = y(x) +
5

i=0
CiKi
(ﬁfth-order formula)
(7.19a)
y4(x + h) = y(x) +
5

i=0
DiKi
(fourth-order formula)
(7.19b)

276
Initial Value Problems
The coefﬁcients appearing in these formulas are not unique. Table 6.1 gives the coef-
ﬁcients proposed by Cash and Karp21 which are claimed to be an improvement over
Fehlberg’s original values.
i
Ai
Bij
Ci
Di
0
−
−
−
−
−
−
37
378
2825
27 648
1
1
5
1
5
−
−
−
−
0
0
2
3
10
3
40
9
40
−
−
−
250
621
18 575
48 384
3
3
5
3
10
−9
10
6
5
−
−
125
594
13 525
55 296
4
1
−11
54
5
2
−70
27
35
27
−
0
277
14 336
5
7
8
1631
55296
175
512
575
13824
44275
110592
253
4096
512
1771
1
4
Table 6.1. Cash–Karp coefﬁcients for Runge–Kutta-Fehlberg formulas
The solution is advanced with the ﬁfth-order formula in Eq. (7.19a). The fourth-
order formula is used only implicitly in estimating the truncation error
E(h) = y5(x + h) −y4(x + h) =
5

i=0
(Ci −Di)Ki
(7.20)
Since Eq. (7.20) actually applies to the fourth-order formula, it tends to overestimate
the error in the ﬁfth-order formula.
Note that E(h) is a vector, its components Ei(h) representing the errors in the
dependent variables yi. This brings up the question: what is the error measure e(h)
that we wish to control? There is no single choice that works well in all problems. If
we want to control the largest component of E(h), the error measure would be
e(h) = max
i
|Ei(h)|
(7.21)
We could also control some gross measure of the error, such as the root-mean-square
21 Cash, J. R., and Carp, A. H., ACM Transactions on Mathematical Software, Vol. 16, p. 201 (1990).

277
7.5 Adaptive Runge–Kutta Method
error deﬁned by
¯E(h) =



1
n
n−1

i=0
E2
i (h)
(7.22)
where n is the number of ﬁrst-order equations. Then we would use
e(h) = ¯E(h)
(7.23)
for the error measure. Since the root-mean-square error is easier to handle, we adopt
it for our program.
Error control is achieved by adjusting the increment h so that the per-step error
e(h) is approximately equal to a prescribed tolerance ε. Noting that the truncation
error in the fourth-order formula is O(h5), we conclude that
e(h1)
e(h2) ≈
&h1
h2
'5
(a)
Let us suppose that we performed an integration step with h1 that resulted in the error
e(h1). The step size h2 that we should have used can now be obtained from Eq. (a) by
setting e(h2) = ε:
h2 = h1
$
ε
e(h1)
%1/5
(b)
If h2 ≥h1, we could repeat the integration step with h2, but since the error was below
the tolerance, that would be a waste of a perfectly good result. So we accept the
current step and try h2 in the next step. On the other hand, if h2 < h1, we must scrap
the current step and repeat it with h2. As Eq. (b) is only an approximation, it is prudent
to incorporate a small margin of safety. In our program we use the formula
h2 = 0.9h1
$
ε
e(h1)
%1/5
(7.24)
Recallthate(h)appliestoasingleintegrationstep;thatis,itisameasureofthelocal
truncation error. The all-important global truncation error is due to the accumulation
of the local errors. What should ε be set at in order to achieve a global error tolerance
εglobal? Since e(h) is a conservative estimate of the actual error, setting ε = εglobal will
usually be adequate. If the number integration steps is large, it is advisable to decrease
ε accordingly.
Is there any reason to use the nonadaptive methods at all? Usually no; however,
there are special cases where adaptive methods break down. For example, adaptive
methods generally do not work if F(x, y) contains discontinuities. Because the error
behaveserraticallyatthepointofdiscontinuity,theprogramcangetstuckinaninﬁnite
looptryingtoﬁndtheappropriatevalueofh.Wewouldalsouseanonadaptivemethod
if the output is to have evenly spaced values of x.

278
Initial Value Problems
■run kut5
This module is compatible with run kut4 listed in the previous chapter. Any program
that calls integrate can choose between the adaptive and the nonadaptive methods
by importing either run kut5 or run kut4. The input argument h is the trial value of
the increment for the ﬁrst integration step.
## module run_kut5
’’’ X,Y = integrate(F,x,y,xStop,h,tol=1.0e-6).
Adaptive Runge-Kutta method for solving the
initial value problem {y}’ = {F(x,{y})}, where
{y}
= {y[0],y[1],...y[n-1]}.
x,y
= initial conditions
xStop = terminal value of x
h
= initial increment of x used in integration
tol
= per-step error tolerance
F
= user-supplied function that returns the
array F(x,y) = {y’[0],y’[1],...,y’[n-1]}.
’’’
from numarray import array,sum,zeros,Float64
from math import sqrt
def integrate(F,x,y,xStop,h,tol=1.0e-6):
def run_kut5(F,x,y,h):
# Runge-Kutta-Fehlberg formulas
C = array([37./378, 0., 250./621, 125./594,
\
0., 512./1771])
D = array([2825./27648, 0., 18575./48384,
\
13525./55296, 277./14336, 1./4])
n = len(y)
K = zeros((6,n),type=Float64)
K[0] = h*F(x,y)
K[1] = h*F(x + 1./5*h, y + 1./5*K[0])
K[2] = h*F(x + 3./10*h, y + 3./40*K[0] + 9./40*K[1])
K[3] = h*F(x + 3./5*h, y + 3./10*K[0]- 9./10*K[1]
\
+ 6./5*K[2])
K[4] = h*F(x + h, y - 11./54*K[0] + 5./2*K[1]
\
- 70./27*K[2] + 35./27*K[3])
K[5] = h*F(x + 7./8*h, y + 1631./55296*K[0]
\

279
7.5 Adaptive Runge–Kutta Method
+ 175./512*K[1] + 575./13824*K[2]
\
+ 44275./110592*K[3] + 253./4096*K[4])
# Initialize arrays {dy}
and {E}
E = zeros((n),type=Float64)
dy = zeros((n),type=Float64)
# Compute solution increment {dy}
and per-step error {E}
for i in range(6):
dy = dy + C[i]*K[i]
E = E + (C[i] - D[i])*K[i]
# Compute RMS error e
e = sqrt(sum(E**2)/n)
return dy,e
X = []
Y = []
X.append(x)
Y.append(y)
stopper = 0
# Integration stopper(0 = off, 1 = on)
for i in range(10000):
dy,e = run_kut5(F,x,y,h)
# Accept integration step if error e is within tolerance
if
e <= tol:
y = y + dy
x = x + h
X.append(x)
Y.append(y)
# Stop if end of integration range is reached
if stopper == 1: break
# Compute next step size from Eq. (7.24)
if e != 0.0:
hNext = 0.9*h*(tol/e)**0.2
else: hNext = h
# Check if next step is the last one; is so, adjust h
if (h > 0.0) == ((x + hNext) >= xStop):
hNext = xStop - x
stopper = 1
h = hNext
return array(X),array(Y)

281
7.5 Adaptive Runge–Kutta Method
from printSoln import *
from math import exp
def F(x,y):
F = zeros((2),type=Float64)
F[0] = y[1]
F[1] = -9.80665 + 65.351e-3 * y[1]**2 * exp(-10.53e-5*y[0])
return F
x = 0.0
xStop = 10.0
y = array([9000, 0.0])
h = 0.5
freq = 1
X,Y = integrate(F,x,y,xStop,h,1.0e-2)
printSoln(X,Y,freq)
raw_input(’’\nPress return to exit’’)
Running the program resulted in the following output:
x
y[ 0 ]
y[ 1 ]
0.0000e+000
9.0000e+003
0.0000e+000
5.0000e-001
8.9988e+003
-4.8043e+000
2.0584e+000
8.9821e+003
-1.5186e+001
3.4602e+000
8.9581e+003
-1.8439e+001
4.8756e+000
8.9312e+003
-1.9322e+001
6.5347e+000
8.8989e+003
-1.9533e+001
8.6276e+000
8.8580e+003
-1.9541e+001
1.0000e+001
8.8312e+003
-1.9519e+001
The ﬁrst step was carried out with the prescribed trial value h = 0.5 s. Apparently
the error was well within the tolerance, so that the step was accepted. Subsequent
step sizes, determined from Eq. (7.24), were considerably larger.
Inspecting the output, we see that at t = 10 s the object is moving with the speed
v = −˙y = 19.52 m/s at an elevation of y = 8831 m.
EXAMPLE 7.9
Integrate the moderately stiff problem
y′′ = −19
4 y −10y′
y(0) = −9
y′(0) = 0
from x = 0 to 10 with the adaptive Runge–Kutta method and plot the results (this
problem also appeared in Example 7.7).

282
Initial Value Problems
Solution Since we use an adaptive method, there is no need to worry about the stable
range of h, as we did in Example 7.7. As long as we specify a reasonable tolerance for
the per-step error (in this case the default value 10−6 is ﬁne), the algorithm will ﬁnd
the appropriate step size. Here is the program and its output:
#!/usr/bin/python
## example7_9
from numarray import array,zeros,Float64
from run_kut5 import *
from printSoln import *
def F(x,y):
F = zeros((2),type=Float64)
F[0] = y[1]
F[1] = -4.75*y[0] - 10.0*y[1]
return F
x = 0.0
xStop = 10.0
y = array([-9.0, 0.0])
h = 0.1
freq = 4
X,Y = integrate(F,x,y,xStop,h)
printSoln(X,Y,freq)
raw_input(’’\nPress return to exit’’)
x
y[ 0 ]
y[ 1 ]
0.0000e+000
-9.0000e+000
0.0000e+000
9.8941e-002
-8.8461e+000
2.6651e+000
2.1932e-001
-8.4511e+000
3.6653e+000
3.7058e-001
-7.8784e+000
3.8061e+000
5.7229e-001
-7.1338e+000
3.5473e+000
8.6922e-001
-6.1513e+000
3.0745e+000
1.4009e+000
-4.7153e+000
2.3577e+000
2.8558e+000
-2.2783e+000
1.1391e+000
4.3990e+000
-1.0531e+000
5.2656e-001
5.9545e+000
-4.8385e-001
2.4193e-001
7.5596e+000
-2.1685e-001
1.0843e-001
9.1159e+000
-9.9591e-002
4.9794e-002
1.0000e+001
-6.4010e-002
3.2005e-002

280
Initial Value Problems
EXAMPLE 7.8
The aerodynamic drag force acting on a certain object in free fall can be approximated
by
FD = av2e−by
where
v = velocity of the object in m/s
y = elevation of the object in meters
a = 7.45 kg/m
b = 10.53 × 10−5 m−1
The exponential term accounts for the change of air density with elevation. The dif-
ferential equation describing the fall is
m¨y = −mg + FD
where g = 9.80665 m/s2 and m= 114 kg is the mass of the object. If the object is
released at an elevation of 9 km, determine its elevation and speed after a 10–s fall
with the adaptive Runge–Kutta method.
Solution The differential equation and the initial conditions are
¨y = −g + a
m ˙y2 exp(−by)
= −9.80665 + 7.45
114 ˙y2 exp(−10.53 × 10−5y)
y(0) = 9000 m
˙y(0) = 0
Letting y0 = y and y1 = ˙y, we obtain the equivalent ﬁrst-order equations as
˙y =
)
˙y0
˙y1
*
=
)
y1
−9.80665 +

65.351 × 10−3 
y2
1 exp(−10.53 × 10−5y0)
*
y(0) =
)
9000 m
0
*
The driver program for run kut5 is listed below. We speciﬁed a per-step error toler-
ance of 10−2 in integrate. Considering the magnitude of y, this should be enough
for ﬁve decimal point accuracy in the solution.
#!/usr/bin/python
## example7_8
from numarray import array,zeros,Float64
from run_kut5 import *

283
7.6 Bulirsch–Stoer Method
The results are in agreement with the analytical solution.
The plots of y and y′ show every fourth integration step. Note the high density of
points near x = 0 where y′ changes rapidly. As the y′-curve becomes smoother, the
distance between the points increases.
x
0.0
2.0
4.0
6.0
8.0
10.0
-10.0
-8.0
-6.0
-4.0
-2.0
0.0
2.0
4.0
y'
y
7.6
Bulirsch–Stoer Method
Midpoint Method
The midpoint formula of numerical integration of y′ = F(x, y) is
y(x + h) = y(x −h) + 2hF

x, y(x)

(7.25)
It is a second-order formula, like the modiﬁed Euler’s formula. We discuss it here
because it is the basis of the powerful Bulirsch–Stoer method, which is the technique
of choice in problems where high accuracy is required.
x - h
x
x + h x
y'(x)
f (x,y)
h
h
Figure 7.3. Graphical repesentation of the midpoint
formula.
Figure 7.3 illustrates the midpoint formula for a single differential equation
y′ = f (x, y). The change in y over the two panels shown is
y(x + h) −y(x −h) =
/ x+h
x−h
y′(x)dx
which equals the area under the y′(x) curve. The midpoint method approximates this
area by the area 2hf (x, y) of the cross-hatched rectangle.

284
Initial Value Problems
x0
xn
xn - 1
x1
x2
x3
h
x
H
Figure 7.4. Mesh used in the midpoint method.
Consider now advancing the solution of y′(x) = F(x, y) from x = x0 to x0 + H with
the midpoint formula. We divide the interval of integration into n steps of length
h = H/n each, as shown in Fig. 7.4, and carry out the computations
y1 = y0 + hF0
y2 = y0 + 2hF1
y3 = y1 + 2hF2
(7.26)
...
yn = yn−2 + 2hFn−1
Here we used the notation yi = y(xi) and Fi = F(xi, yi). The ﬁrst of Eqs. (7.26) uses
the Euler formula to “seed” the midpoint method; the other equations are midpoint
formulas. The ﬁnal result is obtained by averaging yn in Eq. (7.26) and the estimate
yn ≈yn−1 + hFn available from Euler formula:
y(x0 + H) = 1
2

yn +

yn−1 + hFn
 
(7.27)
Richardson Extrapolation
It can be shown that the error in Eq. (7.27) is
E = c1h2 + c2h4 + c3h6 + · · ·
Herein lies the great utility of the midpoint method: we can eliminate as many of the
leading error terms as we wish by Richardson’s extrapolation. For example, we could
compute y(x0 + H) with a certain value of h and then repeat the process with h/2.
Denoting the corresponding results by g(h) and g(h/2), Richardson’s extrapolation—
see Eq. (5.9)—then yields the improved result
ybetter(x0 + H) = 4g(h/2) −g(h)
3
which is fourth-order accurate. Another round of integration with h/4 followed by
Richardson’s extrapolation get us sixth-order accuracy, etc.
The y’s in Eqs. (7.26) should be viewed as a intermediate variables, because unlike
y(x0 + H), they cannot be reﬁned by Richardson’s extrapolation.

285
7.6 Bulirsch–Stoer Method
■midpoint
The function midpoint in this module combines the midpoint method with
Richardson extrapolation. The ﬁrst application of the midpoint method uses two
integration steps. The number of steps is doubled in successive integrations, each
integration being followed by Richardson extrapolation. The procedure is stopped
when two successive solutions differ (in the root-mean-square sense) by less than a
prescribed tolerance.
## module midpoint
’’’ yStop = integrate (F,x,y,xStop,tol=1.0e-6)
Modified midpoint method for solving the
initial value problem y’ = F(x,y}.
x,y
= initial conditions
xStop = terminal value of x
yStop = y(xStop)
F
= user-supplied function that returns the
array F(x,y) = {y’[0],y’[1],...,y’[n-1]}.
’’’
from numarray import zeros,Float64,sum
from math import sqrt
def integrate(F,x,y,xStop,tol):
def midpoint(F,x,y,xStop,nSteps):
# Midpoint formulas
h = (xStop - x)/nSteps
y0 = y
y1 = y0 + h*F(x,y0)
for i in range(nSteps-1):
x = x + h
y2 = y0 + 2.0*h*F(x,y1)
y0 = y1
y1 = y2
return 0.5*(y1 + y0 + h*F(x,y2))
def richardson(r,k):
# Richardson’s extrapolation
for j in range(k-1,0,-1):
const = 4.0**(k-j)

286
Initial Value Problems
r[j] = (const*r[j+1] - r[j])/(const - 1.0)
return
kMax = 51
n = len(y)
r = zeros((kMax,n),type=Float64)
# Start with two integration steps
nSteps = 2
r[1] = midpoint(F,x,y,xStop,nSteps)
r_old = r[1].copy()
# Double the number of integration points
# and refine result by Richardson extrapolation
for k in range(2,kMax):
nSteps = nSteps*2
r[k] = midpoint(F,x,y,xStop,nSteps)
richardson(r,k)
# Compute RMS change in solution
e = sqrt(sum((r[1] - r_old)**2)/n)
# Check for convergence
if e < tol: return r[1]
r_old = r[1].copy()
print ’’Midpoint method did not converge’’
Bulirsch–Stoer Algorithm
When used on its own, the module midpoint has a major shortcoming: the solution
at points between the initial and ﬁnal values of x cannot be reﬁned by Richardson
extrapolation, so that y is usable only at the last point. This deﬁciency is rectiﬁed in
the Bulirsch–Stoer method. The fundamental idea behind the method is simple: apply
the midpoint method in a piecewise fashion. That is, advance the solution in stages of
length H, using the midpoint method with Richardson extrapolation to perform the
integration in each stage. The value of H can be quite large, since the precision of the
result is determined by the step length h in the midpoint method, not by H.
The original Bulirsch and Stoer technique22 is a complex procedure that incorpo-
rates many reﬁnements missing in our algorithm. However, the function bulStoer
given below retains the essential ideas of Bulirsch and Stoer.
What are the relative merits of adaptive Runge–Kutta and Bulirsch–Stoer meth-
ods?TheRunge–Kuttamethodis more robust,havinghigher tolerancefor nonsmooth
22 Stoer, J., and Bulirsch, R., Introduction to Numerical Analysis, Springer, 1980.

287
7.6 Bulirsch–Stoer Method
functionsandstiffproblems.Inmostapplicationswherehighprecisionisnotrequired,
it also tends to be more efﬁcient. However, this is not the case in the computation of
high-accuracy solutions involving smooth functions, where the Bulirsch–Stoer algo-
rithm shines.
■bulStoer
This function contains a simpliﬁed algorithm for the Bulirsch–Stoer method.
## module bulStoer
’’’ X,Y = bulStoer(F,x,y,xStop,H,tol=1.0e-6).
Simplified Bulirsch-Stoer method for solving the
initial value problem {y}’ = {F(x,{y})}, where
{y}
= {y[0],y[1],...y[n-1]}.
x,y
= initial conditions
xStop = terminal value of x
H
= increment of x at which results are stored
F
= user-supplied function that returns the
array F(x,y) = {y’[0],y’[1],...,y’[n-1]}.
’’’
from numarray import array
from midpoint import *
def bulStoer(F,x,y,xStop,H,tol=1.0e-6):
X = []
Y = []
X.append(x)
Y.append(y)
while x < xStop:
H = min(H,xStop - x)
y = integrate(F,x,y,x + H,tol) # Midpoint method
x = x + H
X.append(x)
Y.append(y)
return array(X),array(Y)
EXAMPLE 7.10
Compute the solution of the initial value problem
y′ = sin y
y(0) = 1

288
Initial Value Problems
at x = 0.5 with the midpoint formulas using n = 2 and n = 4, followed by Richardson
extrapolation (this problem was solved with the second-order Runge–Kutta method
in Example 7.3).
Solution With n = 2 the step length is h = 0.25. The midpoint formulas, Eqs. (7.26)
and (7.27), yield
y1 = y0 + hf0 = 1 + 0.25 sin 1.0 = 1.210 368
y2 = y0 + 2hf1 = 1 + 2(0.25) sin 1.210 368 = 1.467 87 3
yh(0.5) = 1
2(y1 + y0 + hf2)
= 1
2(1.210 368 + 1.467 87 3 + 0.25 sin 1.467 87 3)
= 1.463 459
Using n = 4 we have h = 0.125 and the midpoint formulas become
y1 = y0 + hf0 = 1 + 0.125 sin 1.0 = 1.105 184
y2 = y0 + 2hf1 = 1 + 2(0.125) sin 1.105 184 = 1.223 387
y3 = y1 + 2hf2 = 1.105 184 + 2(0.125) sin 1.223 387 = 1.340 248
y4 = y2 + 2hf3 = 1.223 387 + 2(0.125) sin 1.340 248 = 1.466 772
yh/2(0.5) = 1
2(y4 + y3 + hf4)
= 1
2(1.466 772 + 1.340 248 + 0.125 sin 1.466 772)
= 1.465 672
Richardson extrapolation results in
y(0.5) = 4yh/2(0.5) −yh(0.5)
3
= 4(1.465 672) −1.463 459
3
= 1.466 410
which compares favorably with the “true” solution y(0.5) = 1.466 404.
EXAMPLE 7.11
R
C
L
i
i
E(t)

289
7.6 Bulirsch–Stoer Method
The differential equations governing the loop current i and the charge q on the ca-
pacitor of the electric circuit shown are
L di
dt + Ri + q
C = E(t)
dq
dt = i
If the applied voltage E is suddenly increased from zero to 9 V, plot the resulting loop
current during the ﬁrst ten seconds. Use R = 1.0 , L = 2 H and C = 0.45 F.
Solution Letting
y =
)
y0
y1
*
=
)
q
i
*
and substituting the given data, the differential equations become
˙y =
)
˙y0
˙y1
*
=
)
y1
(−Ry1 −y0/C + E) /L
*
The initial conditions are
y(0) =
)
0
0
*
We solved the problem with the function bulStoer with the increment
H = 0.5 s:
## example7_11
from bulStoer import *
from numarray import array,zeros,Float64
from printSoln import *
def F(x,y):
F = zeros((2),type=Float64)
F[0] = y[1]
F[1] = (-y[1] - y[0]/0.45 + 9.0)/2.0
return F
H = 0.5
xStop = 10.0
x = 0.0
y = array([0.0, 0.0])
X,Y = bulStoer(F,x,y,xStop,H)
printSoln(X,Y,1)
raw_input(’’\nPress return to exit’’)

290
Initial Value Problems
Skipping the numerical output, the plot of the current is
t (s)
0.0
2.0
4.0
6.0
8.0
10.0
i (A)
-2
-1
0
1
2
3
4
Recall that in each interval H (the spacing of open circles) the integration was per-
formed by the modiﬁed midpoint method and reﬁned by Richardson’s extrapolation.
PROBLEM SET 7.2
1. Derive the analytical solution of the problem
y′′ + y′ −380y = 0
y(0) = 1
y′(0) = −20
Would you expect difﬁculties in solving this problem numerically?
2. Consider the problem
y′ = x −10y
y(0) = 10
(a) Verify that the analytical solution is y(x) = 0.1x −0.01 + 10.01e−10x.
(b) Determine the step size h that you would use in numerical solution with
the (nonadaptive) Runge–Kutta method.
3. ■Integrate the initial value problem in Prob. 2 from x = 0 to 5 with the Runge–
Kutta method using (a) h = 0.1, (b) h = 0.25 and (c) h = 0.5. Comment on the
results.
4. ■Integrate the initial value problem in Prob. 2 from x = 0 to 10 with the adaptive
Runge–Kutta method.
5. ■
m
k
c
y

291
7.6 Bulirsch–Stoer Method
The differential equation describing the motion of the mass–spring–dashpot sys-
tem is
¨y + c
m ˙y + k
my = 0
where m= 2 kg, c = 460 N·s/m and k = 450 N/m. The initial conditions are y(0) =
0.01 m and ˙y(0) = 0. (a) Show that this is a stiff problem and determine a value of
hthat you would use in numerical integration with the nonadaptive Runge–Kutta
method. (b) Carry out the integration from t = 0 to 0.2 s with the chosen h and
plot ˙y vs. t.
6. ■Integrate the initial value problem speciﬁed in Prob. 5 with the adaptive Runge–
Kutta method from t = 0 to 0.2 s and plot ˙y vs. t.
7. ■Compute the numerical solution of the differential equation
y′′ = 16.81y
from x = 0 to 2 with the adaptive Runge–Kutta method. Use the initial conditions
(a) y(0) = 1.0, y′(0) = −4.1; and (b) y(0) = 1.0, y′(0) = −4.11. Explain the large
difference in the two solutions. Hint: derive the analytical solutions.
8. ■Integrate
y′′ + y′ −y2 = 0
y(0) = 1
y′(0) = 0
from x = 0 to 3.5. Is the sudden increase in y near the upper limit is real or an
artifact caused by instability?
9. ■Solve the stiff problem—see Eq. (7.16)
y′′ + 1001y′ + 1000y = 0
y(0) = 1
y′(0) = 0
from x = 0 to 0.2 with the adaptive Runge–Kutta method and plot y′ vs. x.
10. ■Solve
y′′ + 2y′ + 3y = 0
y(0) = 0
y′(0) =
√
2
with the adaptive Runge–Kutta method from x = 0 to 5 (the analytical solution is
y = e−x sin
√
2x).
11. ■Solve the differential equation
y′′ = 2yy′
from x = 0 to 10 with the initial conditions y(0) = 1, y′(0) = −1. Plot y vs. x.
12. ■Repeat Prob. 11 with the initial conditions y(0) = 0, y′(0) = 1 and the integration
range x = 0 to 1.5.

292
Initial Value Problems
13. ■Use the adaptive Runge–Kutta method to integrate
y′ =
&9
y −y
'
x
y(0) = 5
from x = 0 to 4 and plot y vs. x.
14. ■Solve Prob. 13 with the Bulirsch–Stoer method using H = 0.5.
15. ■Integrate
x2y′′ + xy′ + y = 0
y(1) = 0
y′(1) = −2
from x = 1 to 20, and plot y and y′ vs. x. Use the Bulirsch–Stoer method.
16. ■
k
m
x
The magnetized iron block of mass m is attached to a spring of stiffness k and
free length L. The block is at rest at x = L when the electromagnet is turned on,
exerting the repulsive force F = c/x2 on the block. The differential equation of
the resulting motion is
m¨x = c
x2 −k(x −L)
Determine the amplitude and the period of the motion by numerical integration
with the adaptive Runge–Kutta method. Use c = 5 N·m2, k = 120 N/m, L = 0.2 m
and m= 1.0 kg.
17. ■
A
B
C
The bar ABC is attached to the vertical rod with a horizontal pin. The assembly
is free to rotate about the axis of the rod. In the absence of friction, the equations
of motion of the system are
¨θ = ˙φ
2 sin θ cos θ
¨φ = −2˙θ ˙φ cot θ
The system is set into motion with the initial conditions θ(0) = π/12 rad,
˙θ(0) = 0, φ(0) = 0 and ˙φ(0) = 20 rad/s. Obtain a numerical solution with the
adaptive Runge–Kutta method from t = 0 to 1.5 s and plot ˙φ vs. t.

293
7.6 Bulirsch–Stoer Method
18. ■Solve the circuit problem in Example 7.11 if R = 0 and
E(t) =
"
0 when t < 0
9 sin πt when t ≥0
19. ■Solve Prob. 21 in Problem Set 1 if E = 240 V (constant).
20. ■
R1
L
L
R2
C
i1
i2
E(t)
i2
i1
Kirchoff’s equations for the circuit in the ﬁgure are
L di1
dt + R1i1 + R2(i1 −i2) = E(t)
L di2
dt + R2(i2 −i1) + q2
C = 0
where
dq2
dt = i2
Using the data R1 = 4 , R2 = 10 , L = 0.032 H, C = 0.53 F and
E(t) =
"
20 V if 0 < t < 0.005 s
0 otherwise
plot the transient loop currents i1 and i2 from t = 0 to 0.05 s.
21. ■Consider a closed biological system populated by M number of prey and N
number of predators. Volterra postulated that the two populations are related by
the differential equations
˙M = aM −bMN
˙N = −cN + dMN
where a, b, c and d are constants. The steady-state solution is M0 = c/d, N0 = a/b;
if numbers other than these are introduced into the system, the populations
undergo periodic ﬂuctuations. Introducing the notation
y0 = M/M0
y1 = N/N0

294
Initial Value Problems
allows us to write the differential equations as
˙y0 = a(y0 −y0y1)
˙y1 = b(−y1 + y0y1)
Using a = 1.0/year, b = 0.2/year, y0(0) = 0.1 and y1(0) = 1.0, plot the two popu-
lations from t = 0 to 50 years.
22. ■The equations
˙u = −au + av
˙v = cu −v −uw
˙w = −bw + uv
known as the Lorenz equations, are encountered in theory of ﬂuid dynamics.
Letting a = 5.0, b = 0.9 and c = 8.2, solve these equations from t = 0 to 10 with
the initial conditions u(0) = 0, v(0) = 1.0, w(0) = 2.0 and plot u(t). Repeat the
solution with c = 8.3. What conclusions can you draw from the results?
7.7
Other Methods
The methods described so far belong to a group known as single-step methods. The
name stems from the fact that the information at a single point on the solution curve
is sufﬁcient to compute the next point. There are also multistep methods that utilize
several points on the curve to extrapolate the solution at the next step. Well-known
members of this group are the methods of Adams, Milne, Hamming and Gere. These
methods were popular once, but have lost some of their luster in the last few years.
Multistep methods have two shortcomings that complicate their implementation:
r The methods are not self-starting, but must be provided with the solution at the
ﬁrst few points by a single-step method.
r The integration formulas assume equally spaced steps, which makes it makes it
difﬁcult to change the step size.
Bothofthesehurdlescanbeovercome,butthepriceiscomplexityofthealgorithm
that increases with the sophistication of the method. The beneﬁts of multistep meth-
ods are minimal—the best of them can outperform their single-step counterparts in
certain problems, but these occasions are rare.

8
Two-Point Boundary Value Problems
Solve y′′ = f (x, y, y′),
y(a) = α,
y(b) = β
8.1
Introduction
In two-point boundary value problems the auxiliary conditions associated with the
differential equation, called the boundary conditions, are speciﬁed at two different
values of x. This seemingly small departure from initial value problems has a major
repercussion—itmakesboundaryvalueproblemsconsiderablymoredifﬁculttosolve.
In an initial value problem we were able to start at the point where the initial values
were given and march the solution forward as far as needed. This technique does not
work for boundary value problems, because there are not enough starting conditions
available at either end point to produce a unique solution.
One way to overcome the lack of starting conditions is to guess the missing values.
The resulting solution is very unlikely to satisfy boundary conditions at the other end,
but by inspecting the discrepancy we can estimate what changes to make to the initial
conditions before integrating again. This iterative procedure is known as the shooting
method. The name is derived from analogy with target shooting—take a shot and
observe where it hits the target, then correct the aim and shoot again.
Another means of solving two-point boundary value problems is the ﬁnite differ-
ence method, where the differential equations are approximated by ﬁnite differences
atevenlyspacedmeshpoints.Asaconsequence,adifferentialequationistransformed
into set of simultaneous algebraic equations.
The two methods have a common problem: they give rise to nonlinear sets of
equations if the differential equations are not linear. As we noted in Chapter 2, all
methods of solving nonlinear equations are iterative procedures that can consume a
lot of computational resources. Thus solution of nonlinear boundary value problems
295

296
Two-Point Boundary Value Problems
is not cheap. Another complication is that iterative methods need reasonably good
startingvaluesinordertoconverge.Sincethereisnosetformulafordeterminingthese,
an algorithm for solving nonlinear boundary value problems requires informed input;
it cannot be treated as a “black box.”
8.2
Shooting Method
Second-Order Differential Equation
The simplest two-point boundary value problem is a second-order differential equa-
tionwithoneconditionspeciﬁedat x = aandanotheroneat x = b.Hereisanexample
of such a problem:
y′′ = f (x, y, y′),
y(a) = α,
y(b) = β
(8.1)
Let us now attempt to turn Eqs. (8.1) into the initial value problem
y′′ = f (x, y, y′),
y(a) = α,
y′(a) = u
(8.2)
The key to success is ﬁnding the correct value of u. This could be done by trial and
error: guess u and solve the initial value problem by marching from x = a to b. If
the solution agrees with the prescribed boundary condition y(b) = β, we are done;
otherwise we have to adjust u and try again. Clearly, this procedure is very tedious.
More systematic methods become available to us if we realize that the determi-
nation of uis a root-ﬁnding problem. Because the solution of the initial value problem
depends on u, the computed value of y(b) is a function of u; that is
y(b) = θ(u)
Hence u is a root of
r(u) = θ(u) −β = 0
(8.3)
where r(u) is the boundary residual (difference between the computed and speciﬁed
boundary value at x = b). Equation (8.3) can be solved by one of the root-ﬁnding
methods discussed in Chapter 4. We reject the method of bisection because it involves
toomanyevaluationsofθ(u).IntheNewton–Raphsonmethodwerunintotheproblem
of having to compute dθ/du, which can be done, but not easily. That leaves Brent’s
algorithm as our method of choice.
Here is the procedure we use in solving nonlinear boundary value problems:
1.
Specify the starting values u1 and u2 which must bracket the root u of Eq. (8.3).
2.
Apply Brent’s method to solve Eq. (8.3) for u. Note that each iteration requires
evaluation of θ(u) by solving the differential equation as an initial value problem.

297
8.2 Shooting Method
3.
Having determined the value of u, solve the differential equations once more and
record the results.
If the differential equation is linear, any root-ﬁnding method will need only one
interpolation to determine u. But since Brent’s method uses quadratic interpolation,
it needs three points: u1, u2 and u3, the latter being provided by a bisection step. This
is wasteful, since linear interpolation with u1 and u2 would also result in the correct
value of u. Therefore, we replace Brent’s method with linear interpolation whenever
the differential equation is linear.
■linInterp
Here is the algorithm we use for linear interpolation:
## module linInterp
’’’ root = linInterp(f,x1,x2).
Finds the zero of the linear function f(x) by straight
line interpolation based on x = x1 and x2.
’’’
def linInterp(f,x1,x2):
f1 = f(x1)
f2 = f(x2)
return = x2 - f2*(x2 - x1)/(f2 - f1)
EXAMPLE 8.1
Solve the boundary value problem
y′′ + 3yy′ = 0
y(0) = 0
y(2) = 1
Solution The equivalent ﬁrst-order equations are
y′ =
)
y′
0
y′
1
*
=
)
y1
−3y0y1
*
with the boundary conditions
y0(0) = 0
y0(2) = 1
Now comes the daunting task of determining the trial values of y′(0). We could
always pick two numbers at random and hope for the best. However, it is possible
to reduce the element of chance with a little detective work. We start by making the
reasonable assumption that y is smooth (does not wiggle) in the interval 0 ≤x ≤2.
Next we note that y has to increase from 0 to 1, which requires y′ > 0. Since both y and

298
Two-Point Boundary Value Problems
y′ are positive, we conclude that y′′ must be negative in order to satisfy the differential
equation. Now we are in a position to make a rough sketch of y:
0
2
1
x
y
Looking at the sketch it is clear that y′(0) > 0.5, so that y′(0) = 1 and 2 appear to be
reasonable values for the brackets of y′(0); if they are not, Brent’s method will display
an error message.
In the program listed below we chose the fourth-order Runge–Kutta method
for integration. It can be replaced by the adaptive version by substituting run kut5
for run kut4 in the import statement. Note that three user-supplied functions are
needed to describe the problem at hand. Apart from the function F(x,y) that de-
ﬁnes the differential equations, we also need the functions initCond(u) to specify
the initial conditions for integration, and r(u) to provide Brent’s method with the
boundary condition residual. By changing a few statements in these functions, the
program can be applied to any second-order boundary value problem. It also works
for third-order equations if integration is started at the end where two of the three
boundary conditions are speciﬁed.
#!/usr/bin/python
## example8_1
from numarray import zeros,Float64,array
from run_kut4 import *
from brent import *
from printSoln import *
def initCond(u):
# Init. values of [y, y’]; use ’u’ if unknown
return array([0.0, u])
def r(u):
# Boundary condition residual--see Eq. (8.3)
X,Y = integrate(F,xStart,initCond(u),xStop,h)
y = Y[len(Y) - 1]
r = y[0] - 1.0
return r
def F(x,y):
# First-order differential equations
F = zeros((2),type=Float64)
F[0] = y[1]

299
8.2 Shooting Method
F[1] = -3.0*y[0]*y[1]
return F
xStart = 0.0
# Start of integration
xStop = 2.0
# End of integration
u1 = 1.0
# 1st trial value of unknown init. cond.
u2 = 2.0
# 2nd trial value of unknown init. cond.
h = 0.1
# Step size
freq = 2
# Printout frequency
u = brent(r,u1,u2)
# Compute the correct initial condition
X,Y = integrate(F,xStart,initCond(u),xStop,h)
printSoln(X,Y,freq)
raw_input(’’\nPress return to exit’’)
Here is the solution :
x
y[ 0 ]
y[ 1 ]
0.0000e+000
0.0000e+000
1.5145e+000
2.0000e-001
2.9404e-001
1.3848e+000
4.0000e-001
5.4170e-001
1.0743e+000
6.0000e-001
7.2187e-001
7.3287e-001
8.0000e-001
8.3944e-001
4.5752e-001
1.0000e+000
9.1082e-001
2.7013e-001
1.2000e+000
9.5227e-001
1.5429e-001
1.4000e+000
9.7572e-001
8.6471e-002
1.6000e+000
9.8880e-001
4.7948e-002
1.8000e+000
9.9602e-001
2.6430e-002
2.0000e+000
1.0000e+000
1.4522e-002
Note that y′(0) = 1.5145, so that our starting values of 1.0 and 2.0 were on the
mark.
EXAMPLE 8.2
Numerical integration of the initial value problem
y′′ + 4y = 4x
y(0) = 0
y′(0) = 0
yielded y′(2) =1.653 64.Usethisinformationtodeterminethevalueof y′(0)thatwould
result in y′(2) = 0.
Solution We use linear interpolation
u = u2 −θ(u2)
u2 −u1
θ(u2) −θ(u1)

300
Two-Point Boundary Value Problems
where in our case u = y′(0) and θ(u) = y′(2). So far we are given u1 = 0 and θ(u1) =
1.653 64. To obtain the second point, we need another solution of the initial value
problem. An obvious solution is y = x, which gives us y(0) = 0 and y′(0) = y′(2) = 1.
Thus the second point is u2 = 1 and θ(u2) = 1. Linear interpolation now yields
y′(0) = u = 1 −(1)
1 −0
1 −1.653 64 = 2.529 89
EXAMPLE 8.3
Solve the third-order boundary value problem
y′′′ = 2y′′ + 6xy
y(0) = 2
y(5) = y′(5) = 0
and plot y vs. x.
Solution The ﬁrst-order equations and the boundary conditions are
y′ =


y′
0
y′
1
y′
2

=


y1
y2
2y2 + 6xy0


y0(0) = 2
y0(5) = y1(5) = 0
The program listed below is based on example8 1. Because two of the three
boundary conditions are speciﬁed at the right end, we start the integration at x = 5
and proceed with negative h toward x = 0. Two of the three initial conditions are pre-
scribed: y0(5) = y1(5) = 0, whereas the third condition y2(5) is unknown. Because the
differential equation is linear, we replaced brent with linInterp. In linear interpo-
lation the two guesses for y2(5) (u1 and u2) are not important, so we left them as they
were in Example 8.1. The adaptive Runge-Kutta method (run kut5) was chosen for
the integration.
#!/usr/bin/python
## example8_3
from numarray import zeros,Float64,array
from run_kut5 import *
from linInterp import *
from printSoln import *
def initCond(u):
# Initial values of [y,y’,y’’];
# use ’u’ if unknown
return array([0.0, 0.0, u])
def r(u):
# Boundary condition residual--see Eq. (8.3)
X,Y = integrate(F,xStart,initCond(u),xStop,h)

301
8.2 Shooting Method
y = Y[len(Y) - 1]
r = y[0] - 2.0
return r
def F(x,y):
# First-order differential equations
F = zeros((3),type=Float64)
F[0] = y[1]
F[1] = y[2]
F[2] = 2.0*y[2] + 6.0*x*y[0]
return F
xStart = 5.0
# Start of integration
xStop = 0.0
# End of integration
u1 = 1.0
# 1st trial value of unknown init. cond.
u2 = 2.0
# 2nd trial value of unknown init. cond.
h = -0.1
# initial step size
freq = 2
# printout frequency
u = linInterp(r,u1,u2)
X,Y = integrate(F,xStart,initCond(u),xStop,h)
printSoln(X,Y,freq)
raw_input(’’\nPress return to exit’’)
We forgo the rather long printout of the solution and show just the plot:
x
0
1
2
3
4
5
y
-2
0
2
4
6
8
Higher-Order Equations
Let us consider the fourth-order differential equation
y(4) = f (x, y, y′, y′′, y′′′)
(8.4a)

302
Two-Point Boundary Value Problems
with the boundary conditions
y(a) = α1
y′′(a) = α2
y(b) = β1
y′′(b) = β2
(8.4b)
To solve Eq. (8.4a) with the shooting method, we need four initial conditions at x = a,
only two of which are speciﬁed. Denoting the unknown initial values by u1 and u2, we
have the set of initial conditions
y(a) = α1
y′(a) = u1
y′′(a) = α2
y′′′(a) = u2
(8.5)
If Eq. (8.4a) is solved with the shooting method using the initial conditions in Eq. (8.5),
the computed boundary values at x = bdepend on the choice of u1 and u2. We denote
this dependence as
y(b) = θ1(u1, u2)
y′′(b) = θ2(u1, u2)
(8.6)
The correct values u1 and u2 satisfy the given boundary conditions at x = b:
θ1(u1, u2) = β1
θ2(u1, u2) = β2
or, using vector notation
θ(u) = β
(8.7)
These are simultaneous (generally nonlinear) equations that can be solved by the
Newton–Raphson method discussed in Section 4.6. It must be pointed out again that
intelligent estimates of u1 and u2 are needed if the differential equation is not linear.
EXAMPLE 8.4
x
w0
v
L
The displacement v of the simply supported beam can be obtained by solving the
boundary value problem
d4v
dx4 = w0
E I
x
L
v = d2v
dx2 = 0 at x = 0 and x = L
where E I is the bending rigidity. Determine by numerical integration the slopes at
the two ends and the displacement at mid-span.
Solution Introducing the dimensionless variables
ξ = x
L
y =
E I
w0L4 v

303
8.2 Shooting Method
the problem is transformed to
d4y
dξ 4 = ξ
y = d2y
dξ 2 = 0 at ξ = 0 and 1
The equivalent ﬁrst-order equations and the boundary conditions are (the prime
denotes d/dξ)
y′ =


y′
0
y′
1
y′
2
y′
3

=


y1
y2
y3
ξ


y0(0) = y2(0) = y0(1) = y2(1) = 0
The program listed below is similar to the one in Example 8.1. With appropri-
ate changes in functions F(x,y), initCond(u) and r(u) the program can solve
boundary value problems of any order greater than two. For the problem at hand
we chose the Bulirsch–Stoer algorithm to do the integration because it gives us con-
trol over the printout (we need y precisely at mid-span). The nonadaptive Runge–
Kutta method could also be used here, but we would have to guess a suitable step
size h.
As the differential equation is linear, the solution requires only one iteration with
the Newton–Raphson method. In this case the initial values u1 = dy/dξ|x=0 and u2 =
d3y/dξ 3|x=0 are irrelevant; convergence always occurs in one iteration.
#!/usr/bin/python
## example8_4
from numarray import zeros,Float64,array
from bulStoer import *
from newtonRaphson2 import *
from printSoln import *
def initCond(u):
# Initial values of [y,y’,y’’,y’’’];
# use ’u’ if unknown
return array([0.0, u[0], 0.0, u[1]])
def r(u):
# Boundary condition residuals--see Eq. (8.7)
r = zeros(len(u),type=Float64)
X,Y = bulStoer(F,xStart,initCond(u),xStop,H)
y = Y[len(Y) - 1]
r[0] = y[0]

304
Two-Point Boundary Value Problems
r[1] = y[2]
return r
def F(x,y):
# First-order differential equations
F = zeros((4),type=Float64)
F[0] = y[1]
F[1] = y[2]
F[2] = y[3]
F[3] = x
return F
xStart = 0.0
# Start of integration
xStop = 1.0
# End of integration
u = array([0.0, 1.0])
# Initial guess for {u}
H = 0.5
# Printout increment
freq = 1
# Printout frequency
u = newtonRaphson2(r,u,1.0e-4)
X,Y = bulStoer(F,xStart,initCond(u),xStop,H)
printSoln(X,Y,freq)
raw_input(’’\nPress return to exit’’)
Here is the output:
x
y[ 0 ]
y[ 1 ]
y[ 2 ]
y[ 3 ]
0.0000e+000
0.0000e+000
1.9444e-002
0.0000e+000 -1.6667e-001
5.0000e-001
6.5104e-003
1.2153e-003 -6.2500e-002 -4.1667e-002
1.0000e+000 -2.4670e-014 -2.2222e-002 -2.7190e-012
3.3333e-001
Noting that
dv
dx = dv
dξ
dξ
dx =
&w0L4
E I
dy
dξ
' 1
L = w0L3
E I
dy
dξ
we obtain
dv
dx

x=0
= 19.444 × 10−3 w0L3
E I
dv
dx

x=L
= −22.222 × 10−3 w0L3
E I
v|x=0.5L = 6.5104 × 10−3 w0L4
E I

305
8.2 Shooting Method
which agree with the analytical solution (easily obtained by direct integration of the
differential equation).
EXAMPLE 8.5
Solve
y(4) + 4
x y3 = 0
with the boundary conditions
y(0) = y′(0) = 0
y′′(1) = 0
y′′′(1) = 1
and plot y vs. x.
Solution Our ﬁrst task is to handle the indeterminacy of the differential equation
at the origin, where x = y = 0. The problem is resolved by applying L’Hospital’s rule:
4y3/x →12y2y′ as x →0. Thus the equivalent ﬁrst-order equations and the boundary
conditions that we use in the solution are
y′ =


y′
0
y′
1
y′
2
y′
3

=


y1
y2
y3
"
−12y2
0 y1
if x = 0
−4y3
0/x
otherwise


y0(0) = y1(0) = 0
y2(1) = 0
y3(1) = 1
Because the problem is nonlinear, we need reasonable estimates for y′′(0) and
y′′′(0). On the basis of the boundary conditions y′′(1) = 0 and y′′′(1) = 1, the plot of y′′
is likely to look something like this:
1
1
1
0
y
x
"
If we are right, then y′′(0) < 0 and y′′′(0) > 0. Based on this rather scanty information,
we try y′′(0) = −1 and y′′′(0) = 1.
The following program uses the adaptive Runge-Kutta method (run kut5) for
integration:
#!/usr/bin/python
## example8_5
from numarray import zeros,Float64,array

306
Two-Point Boundary Value Problems
from run_kut5 import *
from newtonRaphson2 import *
from printSoln import *
def initCond(u):
# Initial values of [y,y’,y’’,y’’’];
# use ’u’ if unknown
return array([0.0, 0.0, u[0], u[1]])
def r(u):
# Boundary condition residuals-- see Eq. (8.7)
r = zeros(len(u),type=Float64)
X,Y = integrate(F,x,initCond(u),xStop,h)
y = Y[len(Y) - 1]
r[0] = y[2]
r[1] = y[3] - 1.0
return r
def F(x,y):
# First-order differential equations
F = zeros((4),type=Float64)
F[0] = y[1]
F[1] = y[2]
F[2] = y[3]
if x < 10.e-4: F[3] = -12.0*y[1]*y[0]**2
else:
F[3] = -4.0*(y[0]**3)/x
return F
x = 0.0
# Start of integration
xStop = 1.0
# End of integration
u = array([-1.0, 1.0])
# Initial guess for u
h = 0.1
# Initial step size
freq = 1
# Printout frequency
u = newtonRaphson2(r,u,1.0e-5)
X,Y = integrate(F,x,initCond(u),xStop,h)
printSoln(X,Y,freq)
raw_input(’’\nPress return to exit’’)
The results are:
x
y[ 0 ]
y[ 1 ]
y[ 2 ]
y[ 3 ]
0.0000e+000
0.0000e+000
0.0000e+000 -9.7607e-001
9.7131e-001
1.0000e-001 -4.7184e-003 -9.2750e-002 -8.7893e-001
9.7131e-001

307
8.2 Shooting Method
3.9576e-001 -6.6403e-002 -3.1022e-001 -5.9165e-001
9.7152e-001
7.0683e-001 -1.8666e-001 -4.4722e-001 -2.8896e-001
9.7627e-001
9.8885e-001 -3.2061e-001 -4.8968e-001 -1.1144e-002
9.9848e-001
1.0000e+000 -3.2607e-001 -4.8975e-001 -6.7428e-011
1.0000e+000
x
0.00
0.20
0.40
0.60
0.80
1.00
y
-0.350
-0.300
-0.250
-0.200
-0.150
-0.100
-0.050
0.000
By good fortune, our initial estimates y′′(0) = −1 and y′′′(0) = 1 were very close to the
ﬁnal values.
PROBLEM SET 8.1
1. Numerical integration of the initial value problem
y′′ + y′ −y = 0
y(0) = 0
y′(0) = 1
yielded y(1) = 0.741028. What is the value of y′(0) that would result in y(1) = 1,
assuming that y(0) is unchanged?
2. The solution of the differential equation
y′′′ + y′′ + 2y′ = 6
with the initial conditions y(0) = 2, y′(0) = 0 and y′′(0) = 1, yielded y(1) =
3.03765. When the solution was repeated with y′′(0) = 0 (the other conditions
being unchanged), the result was y(1) = 2.72318. Determine the value of y′′(0) so
that y(1) = 0.
3. Roughly sketch the solution of the following boundary value problems. Use the
sketch to estimate y′(0) for each problem.
(a)
y′′ = −e−y
y(0) = 1
y(1) = 0.5
(b)
y′′ = 4y2
y(0) = 10
y′(1) = 0
(c)
y′′ = cos(xy)
y(0) = 1
y(1) = 2

308
Two-Point Boundary Value Problems
4. Using a rough sketch of the solution estimate of y(0) for the following boundary
value problems.
(a)
y′′ = y2 + xy
y′(0) = 0
y(1) = 2
(b)
y′′ = −2
x y′ −y2
y′(0) = 0
y(1) = 2
(c)
y′′ = −x(y′)2
y′(0) = 2
y(1) = 1
5. Obtain a rough estimate of y′′(0) for the boundary value problem
y′′′ + 5y′′y2 = 0
y(0) = 0
y′(0) = 1
y(1) = 0
6. Obtain rough estimates of y′′(0) and y′′′(0) for the boundary value problem
y(4) + 2y′′ + y′ sin y = 0
y(0) = y′(0) = 0
y(1) = 5
y′(1) = 0
7. Obtain rough estimates of ˙x(0) and ˙y(0) for the boundary value problem
¨x + 2x2 −y = 0
x(0) = 1
x(1) = 0
¨y + y2 −2x = 1
y(0) = 0
y(1) = 1
8. ■Solve the boundary value problem
y′′ + (1 −0.2x) y2 = 0
y(0) = 0
y(π/2) = 1
9. ■Solve the boundary value problem
y′′ + 2y′ + 3y2 = 0
y(0.01) = 0
y(2) = −1
10. ■Solve the boundary value problem
y′′ + sin y + 1 = 0
y(0) = 0
y(π) = 0
11. ■Solve the boundary value problem
y′′ + 1
x y′ + y = 0
y(0.01) = 1
y′(2) = 0
and plot y vs. x. Warning: y changes very rapidly near x = 0.
12. ■Solve the boundary value problem
y′′ −

1 −e−x 
y = 0
y(0) = 1
y(∞) = 0
and plot y vs. x. Hint: Replace the inﬁnity by a ﬁnite value β. Check your choice of
β by repeating the solution with 1.5β. If the results change, you must increase β.

309
8.2 Shooting Method
13. ■Solve the boundary value problem
y′′′ = −1
x y′′ + 1
x2 y′ + 0.1(y′)3
y(1) = 0
y′′(1) = 0
y(2) = 1
14. ■Solve the boundary value problem
y′′′ + 4y′′ + 6y′ = 10
y(0) = y′′(0) = 0
y(3) −y′(3) = 5
15. ■Solve the boundary value problem
y′′′ + 2y′′ + sin y = 0
y(−1) = 0
y′(−1) = −1
y′(1) = 1
16. ■Solve the differential equation in Prob. 15 with the boundary conditions
y(−1) = 0
y(0) = 0
y(1) = 1
(this is a three-point boundary value problem).
17. ■Solve the boundary value problem
y(4) = −xy2
y(0) = 5
y′′(0) = 0
y′(1) = 0
y′′′(1) = 2
18. ■Solve the boundary value problem
y(4) = −2yy′′
y(0) = y′(0) = 0
y(4) = 0
y′(4) = 1
19. ■
y
x
v0
8000 m
t =10 s
t =0
A projectile of mass m in free ﬂight experiences the aerodynamic drag force
FD = cv2, where v is the velocity. The resulting equations of motion are
¨x = −c
mv ˙x
¨y = −c
mv ˙y −g
v =

˙x2 + ˙y2
If the projectile hits a target 8 km away after a 10-s ﬂight, determine the launch
velocity v0 and its angle of inclination θ. Use m= 20 kg, c = 3.2 × 10−4 kg/m and
g = 9.80665 m/s2.

310
Two-Point Boundary Value Problems
20. ■
N
x
L
w0
N
v
The simply supported beam carries a uniform load of intensity w0 and the tensile
force N. The differential equation for the vertical displacement v can be shown
to be
d4v
dx4 −N
E I
d2v
dx2 = w0
E I
where E I is the bending rigidity. The boundary conditions are v = d2v/dx2 = 0 at
x = 0 and L. Changing the variables to ξ = x/L and y = (E I/w0L4)v transforms
the problem to the dimensionless form
d4y
dξ 4 −β d2y
dξ 2 = 1
β = NL2
E I
y|ξ=0 = d2y
dξ 2

ξ=0
= y|ξ=1 = d2y
dξ 2

ξ=1
= 0
Determine the maximum displacement if (a) β = 1.65929; and (b) β = −1.65929
(N is compressive).
21. ■Solve the boundary value problem
y′′′ + yy′′ = 0
y(0) = y′(0) = 0, y′(∞) = 2
and plot y(x) and y′(x). This problem arises in determining the velocity proﬁle of
the boundary layer in incompressible ﬂow (Blasius solution).
8.3
Finite Difference Method
x0
x-1
x1
xm - 2 xm - 1xm
xm + 1
a
b
y-1
y0
y1
ym - 2 ym - 1
ym + 1
ym
x
y
y2
x2
Figure 8.1. Finite difference mesh.

311
8.3 Finite Difference Method
In the ﬁnite difference method we divide the range of integration (a, b) into m
equal subintervals of length h each, as shown in Fig. 8.1. The values of the numerical
solution at the mesh points are denoted by yi, i = 0, 1, . . . , m; the purpose of the two
points outside (a, b) will be explained shortly. We now make two approximations:
1.
Thederivativesof y inthedifferentialequationarereplacedbytheﬁnitedifference
expressions. It is common practice to use the ﬁrst central difference approxima-
tions (see Chapter 5):
y′
i = yi+1 −yi−1
2h
y′′
i = yi−1 −2yi + yi+1
h2
etc.
(8.8)
2.
The differential equation is enforced only at the mesh points.
As a result, the differential equations are replaced by m+ 1 simultaneous alge-
braic equations, the unknowns being yi, i = 0, 1, . . . .m. If the differential equation is
nonlinear, the algebraic equations will also be nonlinear and must be solved by the
Newton–Raphson method.
Since the truncation error in a ﬁrst central difference approximation is O(h2), the
ﬁnite difference method is not nearly as accurate as the shooting method—recall that
the Runge–Kutta method has a truncation error of O(h5). Therefore, the convergence
criterion speciﬁed in the Newton–Raphson method should not be too severe.
Second-Order Differential Equation
Consider the second-order differential equation
y′′ = f (x, y, y′)
with the boundary conditions
y(a) = α
or
y′(a) = α
y(b) = β
or
y′(b) = β
Approximating the derivatives at the mesh points by ﬁnite differences, the prob-
lem becomes
yi−1 −2yi + yi+1
h2
= f
&
xi, yi, yi+1 −yi−1
2h
'
,
i = 0, 1, . . . , m
(8.9)
y0 = α
or
y1 −y−1
2h
= α
(8.10a)
ym = β
or
ym+1 −ym−1
2h
= β
(8.10b)
Note the presence of y−1 and ym+1, which are associated with points outside the
solution domain (a, b). This “spillover” can be eliminated by using the boundary

312
Two-Point Boundary Value Problems
conditions. But before we do that, let us rewrite Eqs. (8.9) as
y−1 −2y0 + y1 −h2 f
&
x0, y0, y1 −y−1
2h
'
= 0
(a)
yi−1 −2yi + yi+1 −h2 f
&
xi, yi, yi+1 −yi−1
2h
'
= 0,
i = 1, 2, . . . , m−1
(b)
ym−1 −2ym + ym+1 −h2 f
&
xm, ym, ym+1 −ym−1
2h
'
= 0
(c)
The boundary conditions on y are easily dealt with: Eq. (a) is simply replaced
by y0 −α = 0 and Eq. (c) is replaced by ym −β = 0. If y′ are prescribed, we obtain
from Eqs. (8.10) y−1 = y1 −2hα and ym+1 = ym−1 + 2hβ, which are then substituted
into Eqs. (a) and (c), respectively. Hence we ﬁnish up with m+ 1 equations in the
unknowns y0, y1, . . . , ym:
y0 −α = 0
if y(a) = α
−2y0 + 2y1 −h2 f (x0, y0, α) −2hα = 0
if y′(a) = α
#
(8.11a)
yi−1 −2yi + yi+1 −h2 f
&
xi, yi, yi+1 −yi−1
2h
'
= 0
i = 1, 2, . . . , m−1
(8.11b)
ym −β = 0
if y(b) = β
2ym−1 −2ym −h2 f (xm, ym, β) + 2hβ = 0
if y′(b) = β
#
(8.11c)
EXAMPLE 8.6
Write out Eqs. (8.11) for the following linear boundary value problem using m= 10:
y′′ = −4y + 4x
y(0) = 0
y′(π/2) = 0
Solve these equations with a computer program.
Solution In this case α = y(0) = 0, β = y′(π/2) = 0 and f (x, y, y′) = −4y + 4x. Hence
Eqs. (8.11) are
y0 = 0
yi−1 −2yi + yi+1 −h2 (−4yi + 4xi) = 0,
i = 1, 2, . . . , 9
2y9 −2y10 −h2(−4y10 + 4x10) = 0

313
8.3 Finite Difference Method
or, using matrix notation


1
0
1
−2 + 4h2
1
...
...
...
1
−2 + 4h2
1
2
−2 + 4h2




y0
y1
...
y9
y10


=


0
4h2x1
...
4h2x9
4h2x10


Note that the coefﬁcient matrix is tridiagonal, so that the equations can be
solved efﬁciently by the decomposition and back substitution routines in module
LUdecomp3, described in Section 2.4. Recalling that in LUdecomp3 the diagonals
of the coefﬁcient matrix are stored in vectors c, d and e, we arrive at the following
program:
#!/usr/bin/python
## example8_6
from numarray import zeros,ones,Float64,array,arange
from LUdecomp3 import *
from math import pi
def equations(x,h,m): # Set up finite difference eqs.
h2 = h*h
d = ones((m + 1))*(-2.0 + 4.0*h2)
c = ones((m),type = Float64)
e = ones((m),type = Float64)
b = ones((m+1))*4.0*h2*x
d[0] = 1.0
e[0] = 0.0
b[0] = 0.0
c[m-1] = 2.0
return c,d,e,b
xStart = 0.0
# x at left end
xStop = pi/2.0
# x at right end
m = 10
# Number of mesh spaces
h = (xStop - xStart)/m
x = arange(xStart,xStop + h,h)
c,d,e,b = equations(x,h,m)
c,d,e = LUdecomp3(c,d,e)
y = LUsolve3(c,d,e,b)

314
Two-Point Boundary Value Problems
print ’’\n
x
y’’
for i in range(m + 1):
print ’’%14.5e %14.5e’’ %(x[i],y[i])
raw_input(’’\nPress return to exit’’)
The solution is
x
y
0.00000e+000
0.00000e+000
1.57080e-001
3.14173e-001
3.14159e-001
6.12841e-001
4.71239e-001
8.82030e-001
6.28319e-001
1.11068e+000
7.85398e-001
1.29172e+000
9.42478e-001
1.42278e+000
1.09956e+000
1.50645e+000
1.25664e+000
1.54995e+000
1.41372e+000
1.56451e+000
1.57080e+000
1.56418e+000
The exact solution of the problem is
y = x −sin 2x
which yields y(π/2) = π/2 = 1. 57080. Thus the error in the numerical solution is
about 0.4%. More accurate results can be achieved by increasing m. For example, with
m= 100, we would get y(π/2) = 1.57073, which is in error by only 0.0002%.
EXAMPLE 8.7
Solve the boundary value problem
y′′ = −3yy′
y(0) = 0
y(2) = 1
with the ﬁnite difference method. Use m= 10 and compare the output with the results
of the shooting method in Example 8.1.
Solution As the problem is nonlinear, Eqs. (8.11) must be solved by the Newton–
Raphson method. The program listed below can be used as a model for other second-
order boundary value problems. The function residual(y) returns the residuals
of the ﬁnite difference equations, which are the left-hand sides of Eqs. (8.11). The
differential equation y′′ = f (x, y, y′) is deﬁned in the function F(x,y,yPrime). In

315
8.3 Finite Difference Method
this problem we chose for the initial solution yi = 0.5xi, which corresponds to the
dashed straight line shown in the rough plot of y in Example 8.1. The starting values
of y0, y1, . . . , ym are speciﬁed by function startSoln(x). Note that we relaxed the
convergence criterion in the Newton–Raphson method to 1.0 × 10−5, which is more
in line with the truncation error in the ﬁnite difference method.
#!/usr/bin/python
## example8_7
from numarray import zeros,Float64,array,arange
from newtonRaphson2 import *
def residual(y):
# Residuals of finite diff. Eqs. (8.11)
r = zeros((m + 1),type=Float64)
r[0] = y[0]
r[m] = y[m] - 1.0
for i in range(1,m):
r[i] = y[i-1] - 2.0*y[i] + y[i+1]
\
- h*h*F(x[i],y[i],(y[i+1] - y[i-1])/(2.0*h)
return r
def F(x,y,yPrime):
# Differential eqn. y’’ = F(x,y,y’)
F = -3.0*y*yPrime
return F
def startSoln(x): # Starting solution y(x)
y = zeros((m + 1),type=Float64)
for i in range(m + 1): y[i] = 0.5*x[i]
return y
xStart = 0.0
# x at left end
xStop = 2.0
# x at right end
m = 10
# Number of mesh intervals
h = (xStop - xStart)/m
x = arange(xStart,xStop + h,h)
y = newtonRaphson2(residual,startSoln(x),1.0e-5)
print ’’\n
x
y’’
for i in range(m + 1):
print ’’%14.5e %14.5e’’ %(x[i],y[i])
raw_input(’’\nPress return to exit’’)

316
Two-Point Boundary Value Problems
Here is the output from our program together with the solution obtained in
Example 8.1.
x
y
y from Ex. 8.1
0.00000e+000
0.00000e+000
0.00000e+000
2.00000e-001
3.02404e-001
2.94050e-001
4.00000e-001
5.54503e-001
5.41710e-001
6.00000e-001
7.34691e-001
7.21875e-001
8.00000e-001
8.49794e-001
8.39446e-001
1.00000e+000
9.18132e-001
9.10824e-001
1.20000e+000
9.56953e-001
9.52274e-001
1.40000e+000
9.78457e-001
9.75724e-001
1.60000e+000
9.90201e-001
9.88796e-001
1.80000e+000
9.96566e-001
9.96023e-001
2.00000e+000
1.00000e+000
1.00000e+000
The maximum discrepancy between the solutions is 1.8% occurring at x = 0.6.
As the shooting method used in Example 8.1 is considerably more accurate than the
ﬁnite difference method, the discrepancy can be attributed to truncation errors in
the ﬁnite difference solution. This error would be acceptable in many engineering
problems. Again, accuracy can be increased by using a ﬁner mesh. With m= 100 we
can reduce the error to 0.07%, but we must question whether the tenfold increase in
computation time is really worth the extra precision.
Fourth-Order Differential Equation
For the sake of brevity we limit our discussion to the special case where y′ and y′′′ do
not appear explicitly in the differential equation; that is, we consider
y(4) = f (x, y, y′′)
We assume that two boundary conditions are prescribed at each end of the so-
lution domain (a, b). Problems of this form are commonly encountered in beam
theory.
Again we divide the solution domain into m intervals of length h each. Replacing
the derivatives of y by ﬁnite differences at the mesh points, we get the ﬁnite difference
equations
yi−2 −4yi−1 + 6yi −4yi+1 + yi+2
h4
= f
&
xi, yi, yi−1 −2yi + yi+1
h2
'
(8.12)

317
8.3 Finite Difference Method
where i = 0, 1, . . . , m. It is more revealing to write these equations as
y−2 −4y−1 + 6y0 −4y1 + y2 −h4 f
&
x0, y0, y−1 −2y0 + y1
h2
'
= 0
(8.13a)
y−1 −4y0 + 6y1 −4y2 + y3 −h4 f
&
x1, y1, y0 −2y1 + y2
h2
'
= 0
(8.13b)
y0 −4y1 + 6y2 −4y3 + y4 −h4 f
&
x2, y2, y1 −2y2 + y3
h2
'
= 0
(8.13c)
...
ym−3 −4ym−2 + 6ym−1 −4ym + ym+1 −h4 f
&
xm−1, ym−1, ym−2 −2ym−1 + ym
h2
'
= 0
(8.13d)
ym−2 −4ym−1 + 6ym −4ym+1 + ym+2 −h4 f
&
xm, ym, ym−1 −2ym + ym+1
h2
'
= 0
(8.13e)
We now see that there are four unknowns y−2, y−1, ym+1 and ym+2 that lie outside the
solution domain that must be eliminated by applying the boundary conditions, a task
that is facilitated by Table 8.1.
Bound. cond.
Equivalent ﬁnite difference expression
y(a) = α
y0 = α
y′(a) = α
y−1 = y1 −2hα
y′′(a) = α
y−1 = 2y0 −y1 + h2α
y′′′(a) = α
y−2 = 2y−1 −2y1 + y2 −2h3α
y(b) = β
ym = β
y′(b) = β
ym+1 = ym−1 + 2hβ
y′′(b) = β
ym+1 = 2ym −ym−1 + h2β
y′′′(b) = β
ym+2 = 2ym+1 −2ym−1 + ym−2 + 2h3β
Table 8.1
The astute observer may notice that some combinations of boundary conditions
will not work in eliminating the “spillover.” One such combination is clearly y(a) = α1
and y′′′(a) = α2. The other one is y′(a) = α1 and y′′(a) = α2. In the context of beam
theory, this makes sense: we can impose either a displacement y or a shear force E Iy′′′
at a point, but it is impossible to enforce both of them simultaneously. Similarly, it
makes no physical sense to prescribe both the slope y′ and the bending moment E Iy′′
at the same point.

318
Two-Point Boundary Value Problems
EXAMPLE 8.8
P
L
v
x
Theuniformbeamoflength L andbendingrigidity E I isattachedtorigidsupports
at both ends. The beam carries a concentrated load P at its mid-span. If we utilize
symmetryandmodelonlythelefthalfofthebeam,thedisplacementvcanbeobtained
by solving the boundary value problem
E I d4v
dx4 = 0
v|x=0 = 0
dv
dx

x=0
= 0
dv
dx

x=L/2
= 0
E I d3v
dx3

x=L/2
= −P/2
Use the ﬁnite difference method to determine the displacement and the bending
moment M = −E I (d2v/dx2) at the mid-span (the exact values are v = PL3/(192E I)
and M = PL/8).
Solution By introducing the dimensionless variables
ξ = x
L
y = E I
PL3 v
the problem becomes
d4y
dξ 4 = 0
y|ξ=0 = 0
dy
dξ

ξ=0
= 0
dy
dξ

ξ=1/2
= 0
d3y
dξ 3

ξ=1/2
= −1
2
We now proceed to writing Eqs. (8.13) taking into account the boundary condi-
tions. Referring to Table 8.1, we obtain the ﬁnite difference expressions of the bound-
ary conditions at the left end as y0 = 0 and y−1 = y1. Hence Eqs. (8.13a) and (8.13b)
become
y0 = 0
(a)
0
−−→
−4y0 + 7y1 −4y2 + y3 = 0
(b)
Equation (8.13c) is
0
−−→
y0 −4y1 + 6y2 −4y3 + y4 = 0
(c)
At the midspan the boundary conditions are equivalent to ym+1 = ym−1 and
ym+2 = 2ym+1 + ym−2 −2ym−1 + 2h3(−1/2) = ym−2 −h3

319
8.3 Finite Difference Method
Substitution into Eqs. (8.13d) and (8.13e) yields
ym−3 −4ym−2 + 7ym−1 −4ym = 0
(d)
2ym−2 −8ym−1 + 6ym = h3
(e)
The coefﬁcient matrix of Eqs. (a)–(e) can be made symmetric by dividing Eq. (e) by 2.
The result is


1
0
0
0
7
−4
1
0
−4
6
−4
1
...
...
...
...
...
1
−4
6
−4
1
1
−4
7
−4
1
−4
3




y0
y1
y2
...
ym−2
ym−1
ym


=


0
0
0
...
0
0
0.5h3


The above system of equations can be solved with the decomposition and back
substitution routines in module LUdecomp5—see Section 2.4. Recall that LUdecomp5
works with the vectors d, e and f that form the diagonals of the upper half of the
matrix. The constant vector is denoted by b. The program that sets up and solves the
equations is
#!/usr/bin/python
## example8_8
from numarray import zeros,ones,Float64,array,arange
from LUdecomp5 import *
def equations(x,h,m): # Set up finite difference eqs.
h4 = h**4
d = ones((m + 1),type = Float64)*6.0
e = ones((m),type = Float64)*(-4.0)
f = ones((m-1),type = Float64)
b = zeros((m+1),type=Float64)
d[0] = 1.0
d[1] = 7.0
e[0] = 0.0
f[0] = 0.0
d[m-1] = 7.0
d[m] = 3.0
b[m] = 0.5*h**3
return d,e,f,b
xStart = 0.0
# x at left end

320
Two-Point Boundary Value Problems
xStop = 0.5
# x at right end
m = 20
# Number of mesh spaces
h = (xStop - xStart)/m
x = arange(xStart,xStop + h,h)
d,e,f,b = equations(x,h,m)
d,e,f = LUdecomp5(d,e,f)
y = LUsolve5(d,e,f,b)
print ’’\n
x
y’’
for i in range(m + 1):
print ’’%14.5e %14.5e’’ %(x[i],y[i])
raw_input(’’\nPress return to exit’’)
When we ran the program with m= 20, the last two lines of the output were
x
y
4.75000e-001
5.19531e-003
5.00000e-001
5.23438e-003
Thus at the mid-span we have
v|x=0.5L = PL3
E I y|ξ=0.5 = 5.234 38 × 10−3 PL3
E I
d2v
dx2

x=0.5L
= PL3
E I

1
L2
d2y
dξ 2

ξ=0.5

≈PL
E I
ym−1 −2ym + ym+1
h2
= PL
E I
(5.19531 −2(5.23438) + 5.19531) × 10−3
0.0252
= −0.125 024 PL
E I
M|x=0.5L = −E I d2v
dx2

ξ=0.5
= 0.125 024 PL
In comparison, the exact solution yields
v|x=0.5L = 5.208 33 × 10−3 PL3
E I
M|x=0.5L = = 0.125 000 PL
PROBLEM SET 8.2
Problems 1–5 Useﬁrstcentraldifferenceapproximationstotransformtheboundary
value problem shown into simultaneous equations Ay = b.
1. y′′ = (2 + x)y,
y(0) = 0,
y′(1) = 5.
2. y′′ = y + x2,
y(0) = 0,
y(1) = 1.

321
8.3 Finite Difference Method
3. y′′ = e−xy′,
y(0) = 1,
y(1) = 0.
4. y(4) = y′′ −y,
y(0) = 0,
y′(0) = 1,
y(1) = 0,
y′(1) = −1.
5. y(4) = −9y + x,
y(0) = y′′(0) = 0,
y′(1) = y′′′(1) = 0.
Problems 6–10 Solve the given boundary value problem with the ﬁnite difference
method using m= 20.
6. ■y′′ = xy,
y(1) = 1.5
y(2) = 3.
7. ■y′′ + 2y′ + y = 0,
y(0) = 0,
y(1) = 1. Exact solution is y = xe1−x.
8. ■x2y′′ + xy′ + y = 0,
y(1) = 0,
y(2) = 0.638961. Exact solution is y = sin(ln x).
9. ■y′′ = y2 sin y,
y′(0) = 0,
y(π) = 1.
10. ■y′′ + 2y(2xy′ + y) = 0,
y(0) = 1/2,
y′(1) = −2/9. Exact solution is
y = (2 + x2)−1.
11. ■
v
x
w0
L/2
L/4
L/4
I0
I1
I0
The simply supported beam consists of three segments with the moments of
inertia I0 and I1 as shown. A uniformly distributed load of intensity w0 acts over
the middle segment. Modeling only the left half of the beam, we can show that
the differential equation
d2v
dx2 = −M
E I
for the displacement v is
d2v
dx2 = −w0L2
4E I0
×



x
L
in 0 < x < L
4
I0
I1
)
x
L −2
& x
L −1
4
'2*
in L
4 < x < L
2
Introducing the dimensionless variables
ξ = x
L
y =
E I0
w0L4 v
γ = I1
I0
the differential equation changes to
d2y
dξ 2 =



−1
4ξ
in 0 < ξ < 1
4
−1
4γ
)
ξ −2
&
ξ −1
4
'2*
in 1
4 < ξ < 1
2

322
Two-Point Boundary Value Problems
with the boundary conditions
y|ξ=0 = dy
dξ

ξ=1/2
= 0
Use the ﬁnite difference method to determine the maximum displacement of the
beam using m= 20 and γ = 1.5 and compare it with the exact solution
vmax =
61
9216
w0L4
E I0
12. ■
d0
M0
d1
d
x
v
L
The simply supported, tapered beam has a circular cross section. A couple of
magnitude M0 is applied to the left end of the beam. The differential equation for
the displacement v is
d2v
dx2 = −M
E I = −M0(1 −x/L)
E I0(d/d0)4
where
d = d0
$
1 +
&d1
d0
−1
' x
L
%
I0 = πd4
0
64
Substituting
ξ = x
L
y =
E I0
M0L2 v
δ = d1
d0
the differential equation changes to
d2y
dξ 2 = −
1 −ξ
[1 + (δ −1)ξ]4
with the boundary conditions
y|ξ=0 = y|ξ=1 = 0
Solve the problem with the ﬁnite difference method using δ = 1.5 and m= 20;
plot y vs. ξ. The exact solution is
y = −(3 + 2δξ −3ξ)ξ 2
6(1 + δξ −ξ)2
+ ξ
3δ
13. ■Solve Example 8.4 by the ﬁnite difference method with m= 20. Hint: Compute
the end slopes from the second noncentral differences in Tables 5.3.
14. ■Solve Prob. 20 in Problem Set 8.1 with the ﬁnite difference method. Use m= 20.

323
8.3 Finite Difference Method
15. ■
L
w0
x
v
The simply supported beam of length L is resting on an elastic foundation of
stiffness kN/m2. The displacement v of the beam due to the uniformly distributed
load of intensity w0 N/m is given by the solution of the boundary value problem
E I d4v
dx4 + kv = w0,
v|x=0 = d2y
dx2

x=0
= v|x=L = d2v
dx2

x=L
= 0
The nondimensional form of the problem is
d4y
dξ 4 + γ y = 1,
y|ξ=0 = d2y
dx2

ξ=0
= y|ξ=1 = d2y
dx2

ξ=1
= 0
where
ξ = x
L
y =
E I
w0L4 v
γ = kL4
E I
Solve this problem by the ﬁnite difference method with γ = 105 and plot y vs. ξ.
16. ■Solve Prob. 15 if the ends of the beam are free and the load is conﬁned to the
middle half of the beam. Consider only the left half of the beam, in which case
the nondimensional form of the problem is
d4y
dξ 4 + γy =
"
0
in 0 < ξ < 1/4
1
in 1/4 < ξ < 1/2
d2y
dξ 2

ξ=0
= d3y
dξ 3

ξ=0
= dy
dξ

ξ=1/2
= d3y
dξ 3

ξ=1/2
= 0
17. ■The general form of a linear, second-order boundary value problem is
y′′ = r(x) + s(x)y + t(x)y′
y(a) = α or y′(a) = α
y(b) = β or y′(b) = β
Write a program that solves this problem with the ﬁnite difference method for
any user-speciﬁed r(x), s(x) and t(x). Test the program by solving Prob. 8.

9
Symmetric Matrix Eigenvalue Problems
Find λ for which nontrivial solutions of Ax =λx exist.
9.1
Introduction
The standard form of the matrix eigenvalue problem is
Ax = λx
(9.1)
where A is a given n× n matrix. The problem is to ﬁnd the scalar λ and the vector x.
Rewriting Eq. (9.1) in the form
(A −λI) x = 0
(9.2)
it becomes apparent that we are dealing with a system of n homogeneous equations.
An obvious solution is the trivial one x = 0. A nontrivial solution can exist only if the
determinant of the coefﬁcient matrix vanishes; that is, if
|A −λI| = 0
(9.3)
Expansion of the determinant leads to the polynomial equation, also known as the
characteristic equation
a0 + a1λ + a2λ2 + · · · + anλn = 0
which has the roots λi, i = 1, 2, . . . , n, called the eigenvalues of the matrix A. The
solutions xi of (A −λiI) x = 0 are known as the eigenvectors.
As an example, consider the matrix
A =


1
−1
0
−1
2
−1
0
−1
1


(a)
324

325
9.1 Introduction
The characteristic equation is
|A −λI| =

1 −λ
−1
0
−1
2 −λ
−1
0
−1
1 −λ

= −3λ + 4λ2 −λ3 = 0
(b)
The roots of this equation are λ1 = 0, λ2 = 1, λ3 = 3. To compute the eigenvector
corresponding the λ3, we substitute λ = λ3 into Eq. (9.2), obtaining


−2
−1
0
−1
−1
−1
0
−1
−2




x1
x2
x3

=


0
0
0


(c)
We know that the determinant of the coefﬁcient matrix is zero, so that the equations
are not linearly independent. Therefore, we can assign an arbitrary value to any one
component of x and use two of the equations to compute the other two components.
Choosing x1 = 1, the ﬁrst equation of Eq. (c) yields x2 = −2 and from the third equa-
tion we get x3 = 1. Thus the eigenvector associated with λ3 is
x3 =


1
−2
1


The other two eigenvectors
x2 =


1
0
−1


x1 =


1
1
1


can be obtained in the same manner.
It is sometimes convenient to display the eigenvectors as columns of a matrix X.
For the problem at hand, this matrix is
X =

x1
x2
x3

=


1
1
1
1
0
−2
1
−1
1


It is clear from the above example that the magnitude of an eigenvector is indeter-
minate; only its direction can be computed from Eq. (9.2). It is customary to normalize
the eigenvectors by assigning a unit magnitude to each vector. Thus the normalized
eigenvectors in our example are
X =


1/
√
3
1/
√
2
1/
√
6
1/
√
3
0
−2/
√
6
1/
√
3
−1/
√
2
1/
√
6


Throughout this chapter we assume that the eigenvectors are normalized.

326
Symmetric Matrix Eigenvalue Problems
Here are some useful properties of eigenvalues and eigenvectors, given without
proof:
r All eigenvalues of a symmetric matrix are real.
r All eigenvalues of a symmetric, positive-deﬁnite matrix are real and positive.
r The eigenvectors of a symmetric matrix are orthonormal; that is, XTX = I.
r If the eigenvalues of A are λi, then the eigenvalues of A−1 are λ−1
i .
Eigenvalue problems that originate from physical problems often end up with a
symmetric A. This is fortunate, because symmetric eigenvalue problems are easier to
solve than their nonsymmetric counterparts (which may have complex eigenvalues).
In this chapter we largely restrict our discussion to eigenvalues and eigenvectors of
symmetric matrices.
Common sources of eigenvalue problems are the analysis of vibrations and sta-
bility. These problems often have the following characteristics:
r The matrices are large and sparse (e.g., have a banded structure).
r We need to know only the eigenvalues; if eigenvectors are required, only a few of
them are of interest.
Ausefuleigenvaluesolvermustbeabletoutilizethesecharacteristicstominimize
the computations. In particular, it should be ﬂexible enough to compute only what
we need and no more.
9.2
Jacobi Method
Jacobimethodisarelativelysimpleiterativeprocedurethatextractsalltheeigenvalues
and eigenvectors of a symmetric matrix. Its utility is limited to small matrices (less
than 20 × 20), because the computational effort increases very rapidly with the size
of the matrix. The main strength of the method is its robustness—it seldom fails to
deliver.
Similarity Transformation and Diagonalization
Consider the standard matrix eigenvalue problem
Ax = λx
(9.4)
where A is symmetric. Let us now apply the transformation
x = Px∗
(9.5)

327
9.2 Jacobi Method
wherePisanonsingularmatrix.SubstitutingEq.(9.5)intoEq.(9.4)andpremultiplying
each side by P−1, we get
P−1APx∗= λP−1Px∗
or
A∗x∗= λx∗
(9.6)
whereA∗= P−1AP.Becauseλwasuntouchedbythetransformation,theeigenvaluesof
AarealsotheeigenvaluesofA∗.Matricesthathavethesameeigenvaluesaredeemedto
besimilar,andthetransformationbetweenthemiscalledasimilaritytransformation.
Similarity transformations are frequently used to change an eigenvalue problem
to a form that is easier to solve. Suppose that we managed by some means to ﬁnd a P
that diagonalizes A∗. Equations (9.6) then are


A∗
11 −λ
0
· · ·
0
0
A∗
22 −λ
· · ·
0
...
...
...
...
0
0
· · ·
A∗
nn −λ




x∗
1
x∗
2
...
x∗
n


=


0
0
...
0


which have the solutions
λ1 = A∗
11
λ2 = A∗
22
· · ·
λn = A∗
nn
(9.7)
x∗
1 =


1
0
...
0


x∗
2 =


0
1
...
0


· · ·
x∗
n =


0
0
...
1


or
X∗=

x∗
1
x∗
2
· · ·
x∗
n

= I
According to Eq. (9.5) the eigenvectors of A are
X = PX∗= PI = P
(9.8)
HencethetransformationmatrixPcontainstheeigenvectorsofA,andtheeigenvalues
of A are the diagonal terms of A∗.
Jacobi Rotation
A special similarity transformation is the plane rotation
x = Rx∗
(9.9)

328
Symmetric Matrix Eigenvalue Problems
where
k
ℓ
R =


1
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
c
0
0
s
0
0
0
0
0
1
0
0
0
0
0
0
0
0
1
0
0
0
0
0
−s
0
0
c
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
1


k
ℓ
(9.10)
is called the Jacobi rotation matrix. Note that R is an identity matrix modiﬁed by the
terms c = cos θ and s = sin θ appearing at the intersections of columns/rows k and
ℓ, where θ is the rotation angle. The rotation matrix has the useful property of being
orthogonal, meaning that
R−1 = RT
(9.11)
One consequence of orthogonality is that the transformation in Eq. (9.9) has the
essential characteristic of a rotation: it preserves the magnitude of the vector; that is,
|x| = |x∗|.
The similarity transformation corresponding to the plane rotation in Eq. (9.9) is
A∗= R−1AR = RTAR
(9.12)
The matrix A∗not only has the same eigenvalues as the original matrix A, but thanks
to orthogonality of R, it is also symmetric. The transformation in Eq. (9.12) changes
only the rows/columns k and ℓof A. The formulas for these changes are
A∗
kk = c2 Akk + s2 Aℓℓ−2cs Akℓ
A∗
ℓℓ= c2 Aℓℓ+ s2 Akk + 2cs Akℓ
A∗
kℓ= A∗
ℓk = (c2 −s2)Akℓ+ cs(Akk −Aℓℓ)
(9.13)
A∗
ki = A∗
ik = cAki −s Aℓi,
i ̸= k,
i ̸= ℓ
A∗
ℓi = A∗
iℓ= cAℓi + s Aki,
i ̸= k,
i ̸= ℓ
Jacobi Diagonalization
The angle θ in the Jacobi rotation matrix can be chosen so that A∗
kℓ= A∗
ℓk = 0. This
suggests the following idea: why not diagonalize A by looping through all the off-
diagonal terms and zero them one by one? This is exactly what Jacobi diagonaliza-
tion does. However, there is a major snag—the transformation that annihilates an

329
9.2 Jacobi Method
off-diagonal term also undoes some of the previously created zeroes. Fortunately, it
turns out that the off-diagonal terms that reappear will be smaller than before. Thus
Jacobi method is an iterative procedure that repeatedly applies Jacobi rotations until
the off-diagonal terms have virtually vanished. The ﬁnal transformation matrix P is
the accumulation of individual rotations Ri:
P = R1·R2·R3 . . .
(9.14)
The columns of P ﬁnish up being the eigenvectors of A and the diagonal elements of
A∗= PTAP become the eigenvectors.
Let us now look at the details of a Jacobi rotation. From Eq. (9.13) we see that
A∗
kℓ= 0 if
(c2 −s2)Akℓ+ cs(Akk −Aℓℓ) = 0
(a)
Using
the
trigonometric
identities
c2 −s2 = cos2 θ −sin2 θ = cos 2θ
and
cs =
cos θ sin θ = (1/2) sin 2θ, we obtain from Eq. (a)
tan 2θ = −
2Akℓ
Akk −Aℓℓ
(b)
which could be solved for θ, followed by computation of c = cos θ and s = sin θ. How-
ever, the procedure described below leads to better algorithm.23
Introducing the notation
φ = cot 2θ = −Akk −Aℓℓ
2Akℓ
(9.15)
and utilizing the trigonometric identity
tan 2θ =
2t
(1 −t2)
where t = tan θ, we can write Eq. (b) as
t2 + 2φt −1 = 0
which has the roots
t = −φ ±

φ2 + 1
It has been found that the root |t| ≤1, which corresponds to |θ| ≤45◦, leads to the
more stable transformation. Therefore, we choose the plus sign if φ > 0 and the minus
sign if φ ≤0, which is equivalent to using
t = sgn(φ)
&
−|φ| +

φ2 + 1
'
23 The procedure is adapted from Press, W. H., et al., Numerical Recipes in Fortran, 2nd ed, Cambridge
University Press, 1992.

330
Symmetric Matrix Eigenvalue Problems
To forestall excessive roundoff error if φ is large, we multiply both sides of the equation
by |φ| +

φ2 + 1 and solve for t, which yields
t =
sgn(φ)
|φ| +

φ2 + 1
(9.16a)
In the case of very large φ, we should replace Eq. (9.16a) by the approximation
t = 1
2φ
(9.16b)
to prevent overﬂow in the computation of φ2. Having computed t, we can use the
trigonometric relationship tan θ = sin θ/ cos θ =
√
1 −cos2 θ/ cos θ to obtain
c =
1
√
1 + t2
s = tc
(9.17)
We now improve the transformation formulas in Eqs. (9.13). Solving Eq. (a) for
Aℓℓ, we obtain
Aℓℓ= Akk + Akℓ
c2 −s2
cs
(c)
Replacing all occurrences of Aℓℓby Eq. (c) and simplifying, we can write the transfor-
mation formulas in Eqs.(9.13) as
A∗
kk = Akk −tAkℓ
A∗
ℓℓ= Aℓℓ+ tAkℓ
A∗
kℓ= A∗
ℓk = 0
(9.18)
A∗
ki = A∗
ik = Aki −s(Aℓi + τ Aki),
i ̸= k,
i ̸= ℓ
A∗
ℓi = A∗
iℓ= Aℓi + s(Aki −τ Aℓi),
i ̸= k,
i ̸= ℓ
where
τ =
s
1 + c
(9.19)
The introduction of τ allowed us to express each formula in the form (original value)
+ (change), which is helpful in reducing the roundoff error.
At the start of Jacobi’s diagonalization process the transformation matrix P is
initialized to the identity matrix. Each Jacobi’s rotation changes this matrix from P to
P∗= PR. The corresponding changes in the elements of P can be shown to be (only
the columns k and ℓare affected)
P∗
ik = Pik −s(Piℓ+ τ Pik)
(9.20)
P∗
iℓ= Piℓ+ s(Pik −τ Piℓ)

331
9.2 Jacobi Method
We still have to decide the order in which the off-diagonal elements of A are to be
eliminated. Jacobi’s original idea was to attack the largest element since this results
in fewest number of rotations. The problem here is that A has to be searched for
the largest element after every rotation, which is a time-consuming process. If the
matrix is large, it is faster to sweep through it by rows or columns and annihilate
every element above some threshold value. In the next sweep the threshold is lowered
and the process repeated. We adopt Jacobi’s original scheme because of its simpler
implementation.
In summary, the Jacobi diagonalization procedure, which uses only the upper half
of the matrix, is:
1.
Find the largest (absolute value) off-diagonal element Akℓin the upper half of A.
2.
Compute φ, t, c and s from Eqs. (9.15)–(9.17).
3.
Compute τ from Eq. (9.19).
4.
Modify the elements in the upper half of A according to Eqs. (9.18).
5.
Update the transformation matrix P using Eqs. (9.20).
6.
Repeat steps 1–5 until the Akℓ< ε, where ε is the error tolerance.
■jacobi
This function computes all eigenvalues λi and eigenvectors xi of a symmetric,
n× nmatrix A by the Jacobi method. The algorithm works exclusively with the upper
triangular part of A, which is destroyed in the process. The principal diagonal of A is
replaced by the eigenvalues, and the columns of the transformation matrix P become
the normalized eigenvectors.
## module jacobi
’’’ lam,x = jacobi(a,tol = 1.0e-9).
Solution of std. eigenvalue problem [a]{x}
= lambda{x}
by Jacobi’s method. Returns eigenvalues in vector {lam}
and the eigenvectors as columns of matrix [x].
’’’
from numarray import array,identity,diagonal
from math import sqrt
def jacobi(a,tol = 1.0e-9):
def maxElem(a): # Find largest off-diag. element a[k,l]
n = len(a)
aMax = 0.0

332
Symmetric Matrix Eigenvalue Problems
for i in range(n-1):
for j in range(i+1,n):
if abs(a[i,j]) >= aMax:
aMax = abs(a[i,j])
k = i; l = j
return aMax,k,l
def rotate(a,p,k,l): # Rotate to make a[k,l] = 0
n = len(a)
aDiff = a[l,l] - a[k,k]
if abs(a[k,l]) < abs(aDiff)*1.0e-36: t = a[k,l]/aDiff
else:
phi = aDiff/(2.0*a[k,l])
t = 1.0/(abs(phi) + sqrt(phi**2 + 1.0))
if phi < 0.0: t = -t
c = 1.0/sqrt(t**2 + 1.0); s = t*c
tau = s/(1.0 + c)
temp = a[k,l]
a[k,l] = 0.0
a[k,k] = a[k,k] - t*temp
a[l,l] = a[l,l] + t*temp
for i in range(k):
# Case of i < k
temp = a[i,k]
a[i,k] = temp - s*(a[i,l] + tau*temp)
a[i,l] = a[i,l] + s*(temp - tau*a[i,l])
for i in range(k+1,l):
# Case of k < i < l
temp = a[k,i]
a[k,i] = temp - s*(a[i,l] + tau*a[k,i])
a[i,l] = a[i,l] + s*(temp - tau*a[i,l])
for i in range(l+1,n):
# Case of i > l
temp = a[k,i]
a[k,i] = temp - s*(a[l,i] + tau*temp)
a[l,i] = a[l,i] + s*(temp - tau*a[l,i])
for i in range(n):
# Update transformation matrix
temp = p[i,k]
p[i,k] = temp - s*(p[i,l] + tau*p[i,k])
p[i,l] = p[i,l] + s*(temp - tau*p[i,l])
n = len(a)
maxRot = 5*(n**2)
# Set limit on number of rotations

333
9.2 Jacobi Method
p = identity(n)*1.0
# Initialize transformation matrix
for i in range(maxRot): # Jacobi rotation loop
aMax,k,l = maxElem(a)
if aMax < tol: return diagonal(a),p
rotate(a,p,k,l)
print ’Jacobi method did not converge’
■sortJacobi
Theeigenvalues/eigenvectorsreturnedby jacobiarenotordered.Thefunctionlisted
below can be used to sort the eigenvalues and eigenvectors into ascending order of
eigenvalues.
## module sortJacobi
’’’ sortJacobi(lam,x).
Sorts the eigenvalues {lam}
and eigenvectors [x]
in order of ascending eigenvalues.
’’’
import swap
def sortJacobi(lam,x):
n = len(lam)
for i in range(n-1):
index = i
val = lam[i]
for j in range(i+1,n):
if lam[j] < val:
index = j
val = lam[j]
if index != i:
swap.swapRows(lam,i,index)
swap.swapCols(x,i,index)
Transformation to Standard Form
Physical problems often give rise to eigenvalue problems of the form
Ax = λBx
(9.21)
where A and B are symmetric n× n matrices. We assume that B is also positive deﬁ-
nite. Such problems must be transformed into the standard form before they can be
solved by Jacobi diagonalization.

334
Symmetric Matrix Eigenvalue Problems
As B is symmetric and positive deﬁnite, we can apply Choleski decomposition
B = LLT, where L is a lower-triangular matrix (see Section 2.3). Then we introduce the
transformation
x = (L−1)Tz
(9.22)
Substituting into Eq. (9.21), we get
A(L−1)Tz =λLLT(L−1)Tz
Premultiplying both sides by L−1 results in
L−1A(L−1)Tz = λL−1LLT(L−1)Tz
Because L−1L = LT(L−1)T = I, the last equation reduces to the standard form
Hz = λz
(9.23)
where
H = L−1A(L−1)T
(9.24)
An important property of this transformation is that it does not destroy the symmetry
of the matrix; i.e., a symmetric A results in a symmetric H.
Here is the general procedure for solving eigenvalue problems of the form Ax =
λBx:
1.
Use Choleski decomposition B = LLT to compute L.
2.
Compute L−1 (a triangular matrix can be inverted with relatively small computa-
tional effort).
3.
Compute H from Eq. (9.24).
4.
Solve the standard eigenvalue problem Hz = λz (e.g., using the Jacobi method).
5.
Recover the eigenvectors of the original problem from Eq. (9.22): x = (L−1)Tz.
Note that the eigenvalues were untouched by the transformation.
An important special case is where B is a diagonal matrix:
B =


β1
0
· · ·
0
0
β2
· · ·
0
...
...
...
...
0
0
· · ·
βn


(9.25)

335
9.2 Jacobi Method
Here
L =


β1/2
1
0
· · ·
0
0
β1/2
2
· · ·
0
...
...
...
...
0
0
· · ·
β1/2
n


L−1 =


β−1/2
1
0
· · ·
0
0
β−1/2
2
· · ·
0
...
...
...
...
0
0
· · ·
β−1/2
n


(9.26a)
and
Hij =
Aij
βiβ j
(9.26b)
■stdForm
Given the matrices A and B, the function stdForm returns H and the transformation
matrix T = (L−1)T. The inversion of L is carried out by invert (the triangular shape
of L allows this to be done by back substitution). Note that original A, B and L are
destroyed.
## module stdForm
’’’ h,t = stdForm(a,b).
Transforms the eigenvalue problem [a]{x}
= lambda[b]{x}
to the standard form [h]{z}
= lambda{z}. The eigenvectors
are related by {x}
= [t]{z}.
’’’
from numarray import dot,matrixmultiply,transpose
from choleski import *
def stdForm(a,b):
def invert(L): # Inverts lower triangular matrix L
n = len(L)
for j in range(n-1):
L[j,j] = 1.0/L[j,j]
for i in range(j+1,n):
L[i,j] = -dot(L[i,j:i],L[j:i,j])/L[i,i]
L[n-1,n-1] = 1.0/L[n-1,n-1]
n = len(a)
L = choleski(b)
invert(L)
h = matrixmultiply(b,matrixmultiply(a,transpose(L)))
return h,transpose(L)

336
Symmetric Matrix Eigenvalue Problems
EXAMPLE 9.1
40 MPa
80 MPa
30 MPa
60 MPa
30 MPa
The stress matrix (tensor) corresponding to the state of stress shown is
S =


80
30
0
30
40
0
0
0
60

MPa
(each row of the matrix consists of the three stress components acting on a coordinate
plane). It can be shown that the eigenvalues of S are the principal stresses and the
eigenvectors are normal to the principal planes. (1) Determine the principal stresses
by diagonalizing S with one Jacobi rotation and (2) compute the eigenvectors.
Solution of Part(1) To eliminate S12 we must apply a rotation in the 1–2 plane. With
k = 1 and ℓ= 2 Eq. (9.15) is
φ = −S11 −S22
2S12
= −80 −40
2(30)
= −2
3
Equation (9.16a) then yields
t =
sgn(φ)
|φ| +

φ2 + 1
=
−1
2/3 +

(2/3)2 + 1
= −0.535 18
According to Eqs. (9.18), the changes in S due to the rotation are
S∗
11 = S11 −tS12 = 80 −(−0.535 18) (30) = 96.055 MPa
S∗
22 = S22 + tS12 = 40 + (−0.535 18) (30) = 23.945 MPa
S∗
12 = S∗
21 = 0
Hence the diagonalized stress matrix is
S∗=


96.055
0
0
0
23.945
0
0
0
60


where the diagonal terms are the principal stresses.

337
9.2 Jacobi Method
Solution of Part (2) To compute the eigenvectors, we start with Eqs. (9.17) and (9.19),
which yield
c =
1
√
1 + t2 =
1

1 + (−0.535 18)2
= 0.88168
s = tc = (−0.535 18) (0.881 68) = −0.471 86
τ =
s
1 + c =
−0.47186
1 + 0.881 68 = −0.250 77
We obtain the changes in the transformation matrix P from Eqs. (9.20). Because
P is initialized to the identity matrix, the ﬁrst equation gives us
P∗
11 = P11 −s(P12 + τ P11)
= 1 −(−0.471 86) [0 + (−0.250 77) (1)] = 0.881 67
P∗
21 = P21 −s(P22 + τ P21)
= 0 −(−0.471 86) [1 + (−0.250 77) (0)] = 0.471 86
Similarly, the second equation of Eqs. (9.20) yields
P∗
12 = −0.471 86
P∗
22 = 0.881 67
The third row and column of P are not affected by the transformation. Thus
P∗=


0.88167
−0.47186
0
0.47186
0.88167
0
0
0
1


The columns of P∗are the eigenvectors of S.
EXAMPLE 9.2
L
L
2L
C
C
3C
i1
i2
i3
i1
i2
i3
(1) Show that the analysis of the electric circuit shown leads to a matrix eigenvalue
problem. (2) Determine the circular frequencies and the relative amplitudes of the
currents.
Solution of Part (1) Kirchoff’s equations for the three loops are
L di1
dt + q1 −q2
3C
= 0
L di2
dt + q2 −q1
3C
+ q2 −q3
C
= 0
2L di3
dt + q3 −q2
C
+ q3
C = 0

338
Symmetric Matrix Eigenvalue Problems
Differentiating and substituting dqk/dt = ik, we get
1
3i1 −1
3i2 = −LC d2i1
dt2
−1
3i1 + 4
3i2 −i3 = −LC d2i2
dt2
−i2 + 2i3 = −2LC d2i3
dt2
These equations admit the solution
ik(t) = uk sin ωt
where ω is the circular frequency of oscillation (measured in rad/s) and uk are the
relative amplitudes of the currents. Substitution into Kirchoff’s equations yields Au =
λBu (sin ωt cancels out), where
A =


1/3
−1/3
0
−1/3
4/3
−1
0
−1
2


B =


1
0
0
0
1
0
0
0
2


λ = LCω2
which represents an eigenvalue problem of the nonstandard form.
Solution of Part (2) SinceBisadiagonalmatrix,wecanreadilytransformtheproblem
into the standard form Hz = λz. From Eq. (9.26a) we get
L−1 =


1
0
0
0
1
0
0
0
1/
√
2


and Eq. (9.26b) yields
H =


1/3
−1/3
0
−1/3
4/3
−1/
√
2
0
−1/
√
2
1


The eigenvalues and eigenvectors of H can now be obtained with the Jacobi method.
Skipping the details, we obtain the following results:
λ1 = 0.147 79
λ2 = 0.582 35
λ3 = 1.936 53
z1 =


0.810 27
0.451 02
0.374 23


z2 =


0.562 74
−0.420 40
−0.711 76


z3 =


0.163 70
−0.787 30
0.594 44



339
9.2 Jacobi Method
The eigenvectors of the original problem are recovered from Eq. (9.22): yi= (L−1)Tzi,
which yields
u1 =


0.810 27
0.451 02
0.264 62


u2 =


0.562 74
−0.420 40
−0.503 29


u3 =


0.163 70
−0.787 30
0.420 33


These vectors should now be normalized (each zi was normalized, but the transfor-
mation to ui does not preserve the magnitudes of vectors). The circular frequencies
are ωi =

λi/ (LC ), so that
ω1 = 0.3844
√
LC
ω2 = 0.7631
√
LC
ω3 = 1.3916
√
LC
EXAMPLE 9.3
n + 2
1
2
P
0
-1
n +1
n
n - 1
L
x
The propped cantilever beam carries a compressive axial load P. The lateral displace-
ment u(x) of the beam can be shown to satisfy the differential equation
u(4) + P
E I u′′ = 0
(a)
where E I is the bending rigidity. The boundary conditions are
u(0) = u′′(0) = 0
u(L) = u′(L) = 0
(b)
(1)Showthatdisplacementanalysisofthebeamresultsinamatrixeigenvalueproblem
if the derivatives are approximated by ﬁnite differences. (2) Use the Jacobi method to
compute the lowest three buckling loads and the corresponding eigenvectors.
Solution of Part (1) We divide the beam into n+ 1 segments of length L/(n+ 1) each
as shown. Replacing the derivatives of uin Eq. (a) by central ﬁnite differences of O(h2)
at the interior nodes (nodes 1 to n), we obtain
ui−2 −4ui−1 + 6ui −4ui+1 + ui+2
h4
= P
E I
−ui−1 + 2ui −ui+1
h2
, i = 1, 2, . . . , n
After multiplication by h4, the equations become
u−1 −4u0 + 6u1 −4u2 + u3 = λ(−u0 + 2u1 −u2)
u0 −4u1 + 6u2 −4u3 + u4 = λ(−u1 + 2u2 −u3)
...
(c)

340
Symmetric Matrix Eigenvalue Problems
un−3 −4un−2 + 6un−1 −4un + un+1 = λ(−un−2 + 2un−1 −un)
un−2 −4un−1 + 6un −4un+1 + un+2 = λ(−un−1 + 2un −un+1)
where
λ = Ph2
E I =
PL2
(n+ 1)2E I
The displacements u−1, u0, un+1 and un+2 can be eliminated by using the prescribed
boundary conditions. Referring to Table 8.1, we obtain the ﬁnite difference approxi-
mations to the boundary conditions:
u0 = 0
u−1 = −u1
un+1 = 0
un+2 = un
Substitution into Eqs. (c) yields the matrix eigenvalue problem Ax = λBx, where
A =


5
−4
1
0
0
· · ·
0
−4
6
−4
1
0
· · ·
0
1
−4
6
−4
1
· · ·
0
...
...
...
...
...
...
...
0
· · ·
1
−4
6
−4
1
0
· · ·
0
1
−4
6
−4
0
· · ·
0
0
1
−4
7


B =


2
−1
0
0
0
· · ·
0
−1
2
−1
0
0
· · ·
0
0
−1
2
−1
0
· · ·
0
...
... ...
...
...
...
...
...
0
· · ·
0
−1
2
−1
0
0
· · ·
0
0
−1
2
−1
0
· · ·
0
0
0
−1
2


Solution of Part (2) TheproblemwiththeJacobimethodisthatitinsistsonﬁndingall
the eigenvalues and eigenvectors. It is also incapable of exploiting banded structures
of matrices. Thus the program listed below does much more work than necessary for
the problem at hand. More efﬁcient methods of solution will be introduced later in
this chapter.
#!/usr/bin/python
## example9_3
from numarray import array,zeros,Float64
from stdForm import *
from jacobi import *
from sortJacobi import *

341
9.2 Jacobi Method
n = 10
a = zeros((n,n),type=Float64)
b = zeros((n,n),type=Float64)
for i in range(n):
a[i,i] = 6.0
b[i,i] = 2.0
a[0,0] = 5.0
a[n-1,n-1] = 7.0
for i in range(n-1):
a[i,i+1] = -4.0
a[i+1,i] = -4.0
b[i,i+1] = -1.0
b[i+1,i] = -1.0
for i in range(n-2):
a[i,i+2] = 1.0
a[i+2,i] = 1.0
h,t = stdForm(a,b)
# Convert to std. form
lam,z = jacobi(h)
# Solve by Jacobi mthd.
x = matrixmultiply(t,z)
# Eigenvectors of orig. prob.
for i in range(n):
# Normalize eigenvectors
xMag = sqrt(dot(x[:,i],x[:,i]))
x[:,i] = x[:,i]/xMag
sortJacobi(lam,x)
# Arrange in ascending order
print ’’Eigenvalues:\n’’,lam[0:3]
print ’’\nEigenvectors:\n’’,x[:,0:3]
raw_input(’’\n Press return to exit’’)
Running the program with n = 10 resulted in the following output:
Eigenvalues:
[ 0.16410379
0.47195675
0.90220118]
Eigenvectors:
[[ 0.16410119 -0.18476623
0.30699491]
[ 0.30618978 -0.26819121
0.36404289]
[ 0.40786549 -0.19676237
0.14669942]
[ 0.45735999
0.00994855 -0.12192373]
[ 0.45146805
0.26852252 -0.1724502 ]
[ 0.39607358
0.4710634
0.06772929]
[ 0.30518404
0.53612023
0.40894875]

342
Symmetric Matrix Eigenvalue Problems
[ 0.19863178
0.44712859
0.57038382]
[ 0.09881943
0.26022826
0.43341183]
[ 0.0270436
0.07776771
0.1486333 ]]
The ﬁrst three mode shapes, which represent the relative displacements of the
buckled beam, are plotted below (we appended the zero end displacements to the
eigenvectors before plotting the points).
u
-0.4
-0.2
0.0
0.2
0.4
0.6
3
1
2
The buckling loads are given by Pi = (n+ 1)2 λi E I/L2. Thus
P1 = (11)2 (0.164 103 7) E I
L2
= 19.857 E I
L2
P2 = (11)2 (0.471 956 75) E I
L2
= 57.107 E I
L2
P3 = (11)2 (0.902 201 18) E I
L2
= 109.17 E I
L2
The analytical values are P1 = 20.19E I/L2, P2 = 59.68E I/L2 and P3 = 118.9E I/L2. It
can be seen that the error introduced by the ﬁnite difference approximation increases
with the mode number (the error in Pi+1 is larger than in Pi). Of course, the accuracy
of the ﬁnite difference model can be improved by using larger n, but beyond n = 20
the cost of computation with the Jacobi method becomes rather high.
9.3
Inverse Power and Power Methods
Inverse Power Method
The inverse power method is a simple and efﬁcient algorithm that ﬁnds the smallest
eigenvalue λ1 and the corresponding eigenvector x1 of
Ax = λx
(9.27)

343
9.3 Inverse Power and Power Methods
The method works like this:
1.
Let v be an approximation to x1 (a random vector of unit magnitude will do).
2.
Solve
Az = v
(9.28)
for the vector z.
3.
Compute |z|.
4.
Let v = z/|z| and repeat steps 2–4 until the change in v is negligible.
At the conclusion of the procedure, |z| = ±1/λ1 and v = x1. The sign of λ1 is de-
termined as follows: if z changes sign between successive iterations, λ1 is negative;
otherwise, λ1 is positive.
Let us now investigate why the method works. Since the eigenvectors xi of
Eq. (9.27) are orthonormal (linearly independent), they can be used as the basis for
any n-dimensional vector. Thus v and z admit the unique representations
v =
n

i=1
vixi
z =
n

i=1
zixi
(a)
where vi and zi are the components of v and z with respect to the eigenvectors xi.
Substitution into Eq. (9.28) yields
A
n

i=1
zixi −
n

i=1
vixi = 0
But Axi = λixi, so that
n

i=1
(ziλi −vi) xi = 0
Hence
zi = vi
λi
It follows from Eq. (a) that
z =
n

i=1
vi
λi
xi = 1
λ1
n

i=1
vi
λ1
λi
xi
= 1
λ1
&
v1x1 + v2
λ1
λ2
x2 + v3
λ1
λ3
x3 + · · ·
'
(9.29)
Since λ1/λi < 1 (i ̸= 1), we observe that the coefﬁcient of x1 has become more promi-
nent in z than it was in v; hence z is a better approximation to x1. This completes the
ﬁrst iterative cycle.

344
Symmetric Matrix Eigenvalue Problems
In subsequent cycles we set v = z/|z| and repeat the process. Each iteration will
increase the dominance of the ﬁrst term in Eq. (9.29) so that the process converges to
z = 1
λ1
v1x1 = 1
λ1
x1
(at this stage v1 = 1 since v = x1, so that v1 = 1, v2 = v3 = · · · = 0).
The inverse power method also works with the nonstandard eigenvalue problem
Ax = λBx
(9.30)
provided that Eq. (9.28) is replaced by
Az = Bv
(9.31)
The alternative is, of course, to transform the problem to standard form before apply-
ing the power method.
Eigenvalue Shifting
By inspection of Eq. (9.29) we see that the speed of convergence is determined by the
strength of the inequality |λ1/λ2| < 1 (the second term in the equation). If |λ2| is well
separated from |λ1|, the inequality is strong and the convergence is rapid. On the other
hand, close proximity of these two eigenvalues results in very slow convergence.
Therateofconvergencecanbeimprovedbyatechniquecalledeigenvalueshifting.
If we let
λ = λ∗+ s
(9.32)
where s is a predetermined “shift,” the eigenvalue problem in Eq. (9.27) is trans-
formed to
Ax = (λ∗+ s)x
or
A∗x = λ∗x
(9.33)
where
A∗= A −sI
(9.34)
Solving the transformed problem in Eq. (9.33) by the inverse power method yields λ∗
1
and x1, where λ∗
1 is the smallest eigenvalue of A∗. The corresponding eigenvalue of the
original problem, λ = λ∗
1 + s, is thus the eigenvalue closest to s.
Eigenvalue shifting has two applications. An obvious one is the determination of
the eigenvalue closest to a certain value s. For example, if the working speed of a shaft
is s rpm, it is imperative to assure that there are no natural frequencies (which are
related to the eigenvalues) close to that speed.

345
9.3 Inverse Power and Power Methods
Eigenvalue shifting is also be used to speed up convergence. Suppose that we are
computing the smallest eigenvalue λ1 of the matrix A. The idea is to introduce a shift
s that makes λ∗
1/λ∗
2 as small as possible. Since λ∗
1 = λ1 −s, we should choose s ≈λ1
(s = λ1 should be avoided to prevent division by zero). Of course, this method works
only if we have a prior estimate of λ1.
The inverse power method with eigenvalue shifting is a particularly powerful tool
for ﬁnding eigenvectors if the eigenvalues are known. By shifting very close to an
eigenvalue, the corresponding eigenvector can be computed in one or two iterations.
Power Method
The power method converges to the eigenvalue farthest from zero and the associated
eigenvector. It is very similar to the inverse power method; the only difference be-
tween the two methods is the interchange of v and z in Eq. (9.28). The outline of the
procedure is:
1.
Let v be an approximation to x1 (a random vector of unit magnitude will do).
2.
Compute the vector
z = Av
(9.35)
3.
Compute |z|.
4.
Let v = z/|z| and repeat steps 2–4 until the change in v is negligible.
At the conclusion of the procedure, |z|′ = ±λn and v = xn (the sign of λn is deter-
mined in the same way as in the inverse power method).
■inversePower
Given the matrix A and the shift s, the function inversePower returns the eigen-
value of A closest to s and the corresponding eigenvector. The matrix A∗= A −sI is
decomposed as soon as it is formed, so that only the solution phase (forward and
back substitution) is needed in the iterative loop. If A is banded, the efﬁciency of the
program could be improved by replacing LUdecomp and LUsolve by functions that
specializeinbandedmatrices(e.g., LUdecomp5and LUsolve5)—seeExample9.6.The
program line that forms A∗must also be modiﬁed to be compatible with the storage
scheme used for A.
## module inversePower
’’’ lam,x = inversePower(a,s,tol=1.0e-6).
Inverse power method for solving the eigenvalue problem
[a]{x}
= lam{x}. Returns ’lam’ closest to ’s’ and the
corresponding eigenvector {x}.
’’’

346
Symmetric Matrix Eigenvalue Problems
from numarray import zeros,Float64,dot,identity
from LUdecomp import *
from math import sqrt
from random import random
def inversePower(a,s,tol=1.0e-6):
n = len(a)
aStar = a - identity(n)*s
# Form [a*] = [a] - s[I]
aStar = LUdecomp(aStar)
# Decompose [a*]
x = zeros((n),type=Float64)
for i in range(n):
# Seed [x] with random numbers
x[i] = random()
xMag = sqrt(dot(x,x))
# Normalize [x]
x =x/xMag
for i in range(50):
# Begin iterations
xOld = x.copy()
# Save current [x]
x = LUsolve(aStar,x)
# Solve [a*][x] = [xOld]
xMag = sqrt(dot(x,x))
# Normalize [x]
x = x/xMag
if dot(xOld,x) < 0.0:
# Detect change in sign of [x]
sign = -1.0
x = -x
else: sign = 1.0
if sqrt(dot(xOld - x,xOld - x)) < tol:
return s + sign/xMag,x
print ’Inverse power method did not converge’
EXAMPLE 9.4
The stress matrix describing the state of stress at a point is
S =


−30
10
20
10
40
−50
20
−50
−10

MPa
Determine the largest principal stress (the eigenvalue of S farthest from zero) by the
power method.
Solution First iteration:
Let v =

1
0
0
T
be the initial guess for the eigenvector. Then
z = Sv =


−30
10
20
10
40
−50
20
−50
−10




1
0
0

=


−30.0
10.0
20.0



347
9.3 Inverse Power and Power Methods
|z| =

302 + 102 + 202 = 37.417
v = z
|z| =


−30.0
10.0
20.0


1
37.417 =


−0.801 77
0.267 26
0.534 52


Second iteration:
z = Sv =


−30
10
20
10
40
−50
20
−50
−10




−0.801 77
0.267 26
0.534 52

=


37.416
−24.053
−34.744


|z| =

37.4162 + 24.0532 + 34.7442 = 56. 442
v = z
|z| =


37.416
−24.053
−34.744


1
56. 442 =


0.66291
−0.42615
−0.61557


Third iteration:
z = Sv =


−30
10
20
10
40
−50
20
−50
−10




0.66291
−0.42615
−0.61557

=


−36.460
20.362
40.721


|z| =

36.4602 + 20.3622 + 40.7212 = 58.328
v = z
|z| =


−36.460
20.362
40.721


1
58.328 =


−0.62509
0.34909
0.69814


At this point the approximation of the eigenvalue we seek is λ = −58.328 MPa (the
negativesignisdeterminedbythesignreversalofzbetweeniterations).Thisisactually
close to the second-largest eigenvalue λ2 = −58.39 MPa! By continuing the iterative
process we would eventually end up with the largest eigenvalue λ3 = 70.94 MPa. But
since |λ2| and |λ3| are rather close, the convergence is too slow from this point on for
manual labor. Here is a program that does the calculations for us:
#!/usr/bin/python
## example9_4
from numarray import array,matrixmultiply,dot
from math import sqrt
s = array([[-30.0,
10.0,
20.0], \
[ 10.0,
40.0, -50.0], \
[ 20.0, -50.0, -10.0]])

348
Symmetric Matrix Eigenvalue Problems
v = array([1.0, 0.0, 0.0])
for i in range(100):
vOld = v.copy()
z = matrixmultiply(s,v)
zMag = sqrt(dot(z,z))
v = z/zMag
if dot(vOld,v) < 0.0:
sign = -1.0
v = -v
else: sign = 1.0
if sqrt(dot(vOld - v,vOld - v)) < 1.0e-6: break
lam = sign*zMag
print ’’Number of iterations =’’,i
print ’’Eigenvalue =’’,lam
raw_input(’’\nPrint press return to exit’’)
The results are:
Number of iterations = 92
Eigenvalue = 70.9434833068
Note that it took 92 iterations to reach convergence!
EXAMPLE 9.5
Determine the smallest eigenvalue λ1 and the corresponding eigenvector of
A =


11
2
3
1
4
2
9
3
5
2
3
3
15
4
3
1
5
4
12
4
4
2
3
4
17


Use the inverse power method with eigenvalue shifting knowing that λ1 ≈5.
Solution
#!/usr/bin/python##
example9_5
from numarray import array
from inversePower import *
s = 5.0

349
9.3 Inverse Power and Power Methods
a = array([[ 11.0, 2.0,
3.0,
1.0,
4.0],
\
[
2.0, 9.0,
3.0,
5.0,
2.0],
\
[
3.0, 3.0, 15.0,
4.0,
3.0],
\
[
1.0, 5.0,
4.0, 12.0,
4.0],
\
[
4.0, 2.0,
3.0,
4.0, 17.0]])
lam,x = inversePower(a,s)
print ’’Eigenvalue =’’,lam
print ’’\nEigenvector:\n’’,x
raw_input(’’\nPrint press return to exit’’)
Here is the output:
Eigenvalue = 4.87394637865
Eigenvector:
[-0.26726603
0.74142854
0.05017271 -0.59491453
0.14970633]
Convergence was achieved with 4 iterations. Without the eigenvalue shift 26 iter-
ations would be required.
EXAMPLE 9.6
Unlike Jacobi diagonalization, the inverse power method lends itself to eigenvalue
problems of banded matrices. Write a program that computes the smallest buckling
load of the beam described in Example 9.3, making full use of the banded forms. Run
the program with 100 interior nodes (n = 100).
Solution The function inversePower5 listed below returns the smallest eigenvalue
and the corresponding eigenvector of Ax = λBx, where A is a pentadiagonal matrix
and B is a sparse matrix (in this problem it is tridiagonal). The matrix A is input
by its diagonals d, e and f as was done in Section 2.4 in conjunction with the LU
decomposition. The algorithm for inversePower5 does not use B directly, but calls
the function Bv(v) that supplies the product Bv. Eigenvalue shifting is not used.
## module inversePower5
’’’ lam,x = inversePower5(Bv,d,e,f,tol=1.0e-6).
Inverse power method for solving the eigenvalue problem
[A]{x}
= lam[B]{x}, where [A] = [f\e\d\e\f] is
pentadiagonal and [B] is sparse.. User must supply the
function Bv(v) that returns the vector [B]{v}.
’’’

350
Symmetric Matrix Eigenvalue Problems
from numarray import zeros,Float64,dot
from LUdecomp5 import *
from math import sqrt
from random import random
def inversePower5(Bv,d,e,f,tol=1.0e-6):
n = len(d)
d,e,f = LUdecomp5(d,e,f)
x = zeros((n),type=Float64)
for i in range(n):
# Seed {v}
with random numbers
x[i] = random()
xMag = sqrt(dot(x,x))
# Normalize {v}
x = x/xMag
for i in range(30):
# Begin iterations
xOld = x.copy()
# Save current {v}
x = Bv(xOld)
# Compute [B]{v}
x = LUsolve5(d,e,f,x)
# Solve [A]{z}
= [B]{v}
xMag = sqrt(dot(x,x))
# Normalize {z}
x = x/xMag
if dot(xOld,x) < 0.0:
# Detect change in sign of {x}
sign = -1.0
x = -x
else: sign = 1.0
if sqrt(dot(xOld - x,xOld - x)) < tol:
return sign/xMag,x
print ’Inverse power method did not converge’
The program that utilizes inversePower5 is
#!/usr/bin/python
## example9_6
from numarray import ones
from inversePower5 import *
def Bv(v):
# Computes {z}
= [B]{v}
n = len(v)
z = zeros((n),type=Float64)
z[0] = 2.0*v[0] - v[1]
for i in range(1,n-1):
z[i] = -v[i-1] + 2.0*v[i] - v[i+1]

351
9.3 Inverse Power and Power Methods
z[n-1] = -v[n-2] + 2.0*v[n-1]
return z
n = 100
# Number of interior nodes
d = ones((n))*6.0
# Specify diagonals of [A] = [f\e\d\e\f]
d[0] = 5.0
d[n-1] = 7.0
e = ones((n-1))*(-4.0)
f = ones((n-2))*1.0
lam,x = inversePower5(Bv,d,e,f)
print ’’PLˆ2/EI =’’,lam*(n+1)**2
raw_input(’’\nPress return to exit’’)
The output, shown below, is in excellent agreement with the analytical value.
PLˆ2/EI = 20.1867355603
PROBLEM SET 9.1
1. Given
A =


7
3
1
3
9
6
1
6
8


B =


4
0
0
0
9
0
0
0
4


convert the eigenvalue problem Ax = λBx to the standard form Hz = λz. What is
the relationship between x and z?
2. Convert the eigenvalue problem Ax = λBx, where
A =


4
−1
0
−1
4
−1
0
−1
4


B =


2
−1
0
−1
2
−1
0
−1
1


to the standard form.
3. An eigenvalue of the problem in Prob. 2 is roughly 2.5. Use the inverse power
method with eigenvalue shifting to compute this eigenvalue to four decimal
places. Start with x =

1
0
0
T
. Hint: two iterations should be sufﬁcient.
4. The stress matrix at a point is
S =


150
−60
0
−60
120
0
0
0
80

MPa
Compute the principal stresses (eigenvalues of S).

352
Symmetric Matrix Eigenvalue Problems
5.
m
L
L
k
θ2
θ1
2m
The two pendulums are connected by a spring which is undeformed when the
pendulums are vertical. The equations of motion of the system can be shown
to be
kL(θ2 −θ1) −mgθ1 = mL¨θ1
−kL(θ2 −θ1) −2mgθ2 = 2mL¨θ2
where θ1 and θ2 are the angular displacements and k is the spring stiffness.
Determine the circular frequencies of vibration and the relative amplitudes
of the angular displacements. Use m= 0.25 kg, k = 20 N/m, L = 0.75 m and
g = 9.80665 m/s2.
6.
L
L
L
C
C
C
i1
i2
i3
i1
i2
i3
Kirchoff’s laws for the electric circuit are
3i1 −i2 −i3 = −LC d2i1
dt2
−i1 + i2 = −LC d2i2
dt2
−i1 + i3 = −LC d2i3
dt2
Compute the circular frequencies of the circuit and the relative amplitudes of the
loop currents.

353
9.3 Inverse Power and Power Methods
7. Compute the matrix A∗that results from annihilation of A14 and A41 in the matrix
A =


4
−1
0
1
−1
6
−2
0
0
−2
3
2
1
0
2
4


by a Jacobi rotation.
8. ■Use the Jacobi method to determine the eigenvalues and eigenvectors of
A =


4
−1
−2
−1
3
3
−2
3
1


9. ■Find the eigenvalues and eigenvectors of
A =


4
−2
1
−1
−2
4
−2
1
1
−2
4
−2
−1
1
−2
4


with the Jacobi method.
10. ■Usethepowermethodtocomputethelargesteigenvalueandthecorresponding
eigenvector of the matrix A given in Prob. 9.
11. ■Find the smallest eigenvalue and the corresponding eigenvector of the matrix
A in Prob. 9. Use the inverse power method.
12. ■Let
A =


1.4
0.8
0.4
0.8
6.6
0.8
0.4
0.8
5.0


B =


0.4
−0.1
0.0
−0.1
0.4
−0.1
0.0
−0.1
0.4


Find the eigenvalues and eigenvectors of Ax = λBx by the Jacobi method.
13. ■Use the inverse power method to compute the smallest eigenvalue in Prob. 12.
14. ■Use the Jacobi method to compute the eigenvalues and eigenvectors of the
matrix
A =


11
2
3
1
4
2
2
9
3
5
2
1
3
3
15
4
3
2
1
5
4
12
4
3
4
2
3
4
17
5
2
1
2
3
5
8



354
Symmetric Matrix Eigenvalue Problems
15. ■Find the eigenvalues of Ax = λBx by the Jacobi method, where
A =


6
−4
1
0
−4
6
−4
1
1
−4
6
−4
0
1
−4
7


B =


1
−2
3
−1
−2
6
−2
3
3
−2
6
−2
−1
3
−2
9


Warning: B is not positive deﬁnite.
16. ■
1
n
2
L
x
u
The ﬁgure shows a cantilever beam with a superimposed ﬁnite difference mesh. If
u(x, t) is the lateral displacement of the beam, the differential equation of motion
governing bending vibrations is
u(4) = −γ
E I ¨u
where γ is the mass per unit length and E I is the bending rigidity. The boundary
conditions are u(0, t) = u′(0, t) = u′′(L, t) = u′′′(L, t) = 0. With u(x, t) = y(x) sin ωt
the problem becomes
y(4) = ω2γ
E I y
y(0) = y′(0) = y′′(L) = y′′′(L) = 0
The corresponding ﬁnite difference equations are


7
−4
1
0
0
· · ·
0
−4
6
−4
1
0
· · ·
0
1
−4
6
−4
1
· · ·
0
...
...
...
...
...
...
...
0
· · ·
1
−4
6
−4
1
0
· · ·
0
1
−4
5
−2
0
· · ·
0
0
1
−2
1




y1
y2
y3
...
yn−2
yn−1
yn


= λ


y1
y2
y3
...
yn−2
yn−1
yn/2


where
λ = ω2γ
E I
& L
n
'4
(a) Write down the matrix H of the standard form Hz = λz and the transformation
matrix P as in y = Pz. (b) Write a program that computes the lowest two circular
frequenciesofthebeamandthecorrespondingmodeshapes(eigenvectors)using
the Jacobi method. Run the program with n = 10. Note: the analytical solution for
the lowest circular frequency is ω1 =

3.515/L2 
E I/γ .

355
9.3 Inverse Power and Power Methods
17. ■
1 2
0
3 4 5 6 7 8 9 10
L /4
L /4
(b)
P
P
L/2
L /4
L /4
EI0
2EI0
EI0
(a)
The simply supported column in Fig. (a) consists of three segments with the
bendingrigiditiesshown.Ifonlytheﬁrstbucklingmodeisofinterest,itissufﬁcient
to model half of the beam as shown in Fig. (b). The differential equation for the
lateral displacement u(x) is
u′′ = −P
E I u
with the boundary conditions u(0) = u′(L/2) = 0. The corresponding ﬁnite dif-
ference equations are


2
−1
0
0
0
0
0
· · ·
0
−1
2
−1
0
0
0
0
· · ·
0
0
−1
2
−1
0
0
0
· · ·
0
0
0
−1
2
−1
0
0
· · ·
0
0
0
0
−1
2
−1
0
· · ·
0
0
0
0
0
−1
2
−1
· · ·
0
...
...
...
...
...
...
...
...
...
0
· · ·
0
0
0
0
−1
2
−1
0
· · ·
0
0
0
0
0
−1
1




u1
u2
u3
u4
u5
u6
...
u9
u10


= λ


u1
u2
u3
u4
u5/1.5
u6/2
...
u9/2
u10/4


where
λ =
P
E I0
& L
20
'2
Write a program that computes the lowest buckling load P of the column with
the inverse power method. Utilize the banded forms of the matrices.
18. ■
θ3
θ2
θ1
L
L
L
k
k
k
P
The springs supporting the three-bar linkage are undeformed when the linkage
is horizontal. The equilibrium equations of the linkage in the presence of the

356
Symmetric Matrix Eigenvalue Problems
horizontal force P can be shown to be


6
5
3
3
3
2
1
1
1




θ1
θ2
θ3

= P
kL


1
1
1
0
1
1
0
0
1




θ1
θ2
θ3


wherekisthespringstiffness.Determinethesmallestbucklingload P andthecor-
responding mode shape. Hint: the equations can easily rewritten in the standard
form Aθ = λθ, where A is symmetric.
19. ■
m
2m
3m
k
k
k
k
u1
u2
u3
The differential equations of motion for the mass–spring system are
k(−2u1 + u2) = m ¨u1
k(u1 −2u2 + u3) = 3m ¨u2
k(u2 −2u3) = 2m ¨u3
where ui(t) is the displacement of mass i from its equilibrium position and k
is the spring stiffness. Determine the circular frequencies of vibration and the
corresponding mode shapes.
20. ■
L
L
L
L
C
C/5
C/2
C/3
C/4
i1
i2
i3
i4
i1
i2
i3
i4
Kirchoff’s equations for the circuit are
L d2i1
dt2 + 1
C i1 + 2
C (i1 −i2) = 0
L d2i2
dt2 + 2
C (i2 −i1) + 3
C (i2 −i3) = 0
L d2i3
dt2 + 3
C (i3 −i2) + 4
C (i3 −i4) = 0
L d2i4
dt2 + 4
C (i4 −i3) + 5
C i4 = 0
Find the circular frequencies of the currents.

357
9.4 Householder Reduction to Tridiagonal Form
21. ■
L
L
L
L
C
C/2
C/3
C/4
i1
i2
i3
i4
i1
i2
i3
i4
L
Determine the circular frequencies of oscillation for the circuit shown, given the
Kirchoff equations
L d 2i1
dt2 + L
&d 2i1
dt2 −d 2i2
dt2
'
+ 1
C i1 = 0
L
&d 2i2
dt2 −d 2i1
dt2
'
+ L
&d 2i2
dt2 −d 2i3
dt2
'
+ 2
C i2 = 0
L
&d 2i3
dt2 −d 2i2
dt2
'
+ L
&d 2i3
dt2 −d 2i4
dt2
'
+ 3
C i3 = 0
L
&d 2i4
dt2 −d 2i3
dt2
'
+ L d 2i4
dt2 + 4
C i4 = 0
22. ■Several iterative methods exist for ﬁnding the eigenvalues of a matrix A. One of
these is the LR method, which requires the matrix to be symmetric and positive
deﬁnite. Its algorithm very simple:
Let A0 = A
do with i = 0, 1, 2, . . .
Use Choleski’s decomposition Ai = LiLT
i to compute Li
Form Ai+1 = LT
i Li
end do
It can be shown that the diagonal elements of Ai+1 converge to the eigenvalues of
A. Write a program that implements the LR method and test it with
A =


4
3
1
3
4
2
1
2
3


9.4
Householder Reduction to Tridiagonal Form
It was mentioned before that similarity transformations can be used to transform an
eigenvalue problem to a form that is easier to solve. The most desirable of the “easy”
forms is, of course, the diagonal form that results from the Jacobi method. However,
the Jacobi method requires about 10n3 to 20n3 multiplications, so that the amount of

358
Symmetric Matrix Eigenvalue Problems
computation increases very rapidly with n. We are generally better off by reducing the
matrix to the tridiagonal form, which can be done in precisely n−2 transformations
by the Householder method. Once the tridiagonal form is achieved, we still have to
extract the eigenvalues and the eigenvectors, but there are effective means of dealing
with that, as we see the next article.
Householder Matrix
Each Householder transformation utilizes the Householder matrix
Q = I −uuT
H
(9.36)
where u is a vector and
H = 1
2uTu = 1
2 |u|2
(9.37)
Note that uuT in Eq. (9.36) is the outer product; that is, a matrix with the elements

uuT 
ij = uiuj. Since Q is obviously symmetric (QT= Q), we can write
QTQ = QQ =
&
I −uuT
H
' &
I −uuT
H
'
= I −2uuT
H
+ u

uTu
 
uT
H2
= I −2uuT
H
+ u (2H) uT
H2
= I
which shows that Q is also orthogonal.
Now let x be an arbitrary vector and consider the transformation Qx. Choosing
u = x + ke1
(9.38)
where
k = ± |x|
e1 =

1
0
0
· · ·
0
T
we get
Qx =
&
I −uuT
H
'
x =
$
I −u (x + ke1)T
H
%
x
= x −u

xTx+keT
1 x
 
H
= x −u

k2 + kx1
 
H
But
2H = (x + ke1)T (x + ke1) = |x|2 + k

xTe1+eT
1 x
 
+ k2eT
1 e1
= k2 + 2kx1 + k2 = 2

k2 + kx1
 

359
9.4 Householder Reduction to Tridiagonal Form
so that
Qx = x −u = −ke1 =

−k
0
0
· · ·
0
T
(9.39)
Hence the transformation eliminates all elements of x except the ﬁrst one.
Householder Reduction of a Symmetric Matrix
Let us now apply the following transformation to a symmetric n× n matrix A:
P1A =
)
1
0T
0
Q
* )
A11
xT
x
A′
*
=
)
A11
xT
Qx
QA′
*
(9.40)
Here x represents the ﬁrst column of A with the ﬁrst element omitted, and A′
is simply A with its ﬁrst row and column removed. The matrix Q of dimensions
(n−1) × (n−1) is constructed using Eqs. (9.36)–(9.38). Referring to Eq. (9.39), we
see that the transformation reduces the ﬁrst column of A to
)
A11
Qx
*
=


A11
−k
0
...
0


The transformation
A ←P1AP1 =
)
A11
(Qx)T
Qx
QA′Q
*
(9.41)
thus tridiagonalizes the ﬁrst row as well as the ﬁrst column of A. Here is a diagram of
the transformation for a 4 × 4 matrix:
1
0
0
0
0
0
Q
0
·
A11
A12
A13
A14
A21
A31
A′
A41
·
1
0
0
0
0
0
Q
0
=
A11
−k
0
0
−k
0
QA′Q
0
The second row and column of A are reduced next by applying the transformation to
the 3 × 3 lower right portion of the matrix. This transformation can be expressed as
A ←P2AP2, where now

360
Symmetric Matrix Eigenvalue Problems
P2 =
)
I2
0T
0
Q
*
(9.42)
In Eq. (9.42) I2 is a 2 × 2 identity matrix and Q is a (n−2) × (n−2) matrix constructed
by choosing for x the bottom n−2 elements of the second column of A. It takes a total
of n−2 transformation with
Pi =
)
Ii
0T
0
Q
*
,
i = 1, 2, . . . , n−2
to attain the tridiagonal form.
It is wasteful to form Pi and then carry out the matrix multiplication PiAPi. We
note that
A′Q = A′
&
I −uuT
H
'
= A′ −A′u
H uT = A′−vuT
where
v = A′u
H
(9.43)
Therefore,
QA′Q =
&
I −uuT
H
' 
A′−vuT 
= A′−vuT −uuT
H

A′−vuT 
= A′−vuT −u

uTA′ 
H
+ u

uTv
 
uT
H
= A′−vuT−uvT + 2guuT
where
g = uTv
2H
(9.44)
Letting
w = v −gu
(9.45)
it can be easily veriﬁed that the transformation can be written as
QA′Q = A′−wuT−uwT
(9.46)
which gives us the following computational procedure which is to be carried out with
i = 1, 2, . . . , n−2:
1. Let A′ be the (n−i) × (n−i) lower right-hand portion of A.
2. Letx =

Ai+1,i
Ai+2,i
· · ·
An,i
T
(thecolumnoflengthn−i justtotheleftofA′).
3. Compute |x|. Let k = |x| if x1 > 0 and k = −|x| if x1 < 0 (this choice of sign mini-
mizes the roundoff error).

361
9.4 Householder Reduction to Tridiagonal Form
4. Let u =

k+x1
x2
x3
· · ·
xn−i
T
.
5. Compute H = |u|2.
6. Compute v = A′u/H.
7. Compute g = uTv/(2H).
8. Compute w = v −gu.
9. Compute the transformation A′←A′−wTu −uTw.
10. Set Ai,i+1 = Ai+1,i = −k.
Accumulated Transformation Matrix
Since we used similarity transformations, the eigenvalues of the tridiagonal matrix
are the same as those of the original matrix. However, to determine the eigenvectors
X of original A we must use the transformation
X = PXtridiag
where P is the accumulation of the individual transformations:
P = P1P2· · · Pn−2
We build up the accumulated transformation matrix by initializing P to a n× n iden-
tity matrix and then applying the transformation
P ←PPi =
)
P11
P12
P21
P22
* )
Ii
0T
0
Q
*
=
)
P11
P21Q
P12
P22Q
*
(b)
with i = 1, 2, . . . , n−2. It can be seen that each multiplication affects only the right-
most n−i columns of P (since the ﬁrst row of P12 contains only zeroes, it can also be
omitted in the multiplication). Using the notation
P′=
)
P12
P22
*
we have
)
P12Q
P22Q
*
= P′Q = P′
&
I −uuT
H
'
= P′ −P′u
H uT = P′−yuT
(9.47)
where
y = P′u
H
(9.48)
The procedure for carrying out the matrix multiplication in Eq. (b) is:
r Retrieve u (in our triangularization procedure the u’s are stored in the columns
of the lower triangular portion of A).

362
Symmetric Matrix Eigenvalue Problems
r Compute H = |u|2
r Compute y = P′u/H.
r Compute the transformation P′←P′−yuT.
■householder
The function householder in this module does the triangulization. It returns (d, c),
where d and c are vectors that contain the elements of the principal diagonal and
the subdiagonal, respectively. Only the upper triangular portion is reduced to the
triangular form. The part below the principal diagonal is used to store the vectors u.
This is done automatically by the statement u = a[k+1:n,k] which does not create
a new object u, but simply sets up a reference to a[k+1:n,k] (makes a deep copy).
Thus any changes made to u are reﬂected in a[k+1:n,k].
The function computeP returns the accumulated transformation matrix P. There
is no need to call it if only the eigenvalues are to be computed.
## module householder
’’’ d,c = householder(a).
Householder similarity transformation of matrix [a] to
the tridiagonal form [c\d\c].
p = computeP(a).
Computes the accumulated transformation matrix [p]
after calling householder(a).
’’’
from numarray import dot,matrixmultiply,diagonal, \
outerproduct,identity
from math import sqrt
def householder(a):
n = len(a)
for k in range(n-2):
u = a[k+1:n,k]
uMag = sqrt(dot(u,u))
if u[0] < 0.0: uMag = -uMag
u[0] = u[0] + uMag
h = dot(u,u)/2.0
v = matrixmultiply(a[k+1:n,k+1:n],u)/h
g = dot(u,v)/(2.0*h)
v = v - g*u
a[k+1:n,k+1:n] = a[k+1:n,k+1:n] - outerproduct(v,u) \
- outerproduct(u,v)

363
9.4 Householder Reduction to Tridiagonal Form
a[k,k+1] = -uMag
return diagonal(a),diagonal(a,1)
def computeP(a):
n = len(a)
p = identity(n)*1.0
for k in range(n-2):
u = a[k+1:n,k]
h = dot(u,u)/2.0
v = matrixmultiply(p[1:n,k+1:n],u)/h
p[1:n,k+1:n] = p[1:n,k+1:n] - outerproduct(v,u)
return p
EXAMPLE 9.7
Transform the matrix
A =


7
2
3
−1
2
8
5
1
3
5
12
9
−1
1
9
7


into tridiagonal form using Householder reduction.
Solution Reduce the ﬁrst row and column:
A′ =


8
5
1
5
12
9
1
9
7


x =


2
3
−1


k = |x| = 3. 7417
u =


k + x1
x2
x3

=


5.7417
3
−1


H = 1
2 |u|2 = 21. 484
uuT =


32.967
17 225
−5.7417
17.225
9
−3
−5.7417
−3
1


Q = I−uuT
H
=


−0.53450
−0.80176
0.26725
−0.80176
0.58108
0.13964
0.26725
0.13964
0.95345


QA′Q =


10.642
−0.1388
−9.1294
−0.1388
5.9087
4.8429
−9.1294
4.8429
10.4480



364
Symmetric Matrix Eigenvalue Problems
A ←
)
A11
(Qx)T
Qx
QA′Q
*
=


7
−3.7417
0
0
−3.7417
10.642
−0. 1388
−9.1294
0
−0.1388
5.9087
4.8429
0
−9.1294
4.8429
10.4480


In the last step we used the formula Qx =

−k
0
· · ·
0
T
.
Reduce the second row and column:
A′ =
)
5.9087
4.8429
4.8429
10.4480
*
x =
)
−0.1388
−9.1294
*
k = −|x| = −9.1305
where the negative sign on k was determined by the sign of x1.
u =
)
k + x1
x2
*
=
)
−9. 2693
−9.1294
*
H = 1
2 |u|2 = 84.633
uuT =
)
85.920
84.623
84.623
83.346
*
Q = I−uuT
H
=
)
0.01521
−0.99988
−0.99988
0.01521
*
QA′Q =
)
10.594
4.772
4.772
5.762
*
A ←


A11
A12
0T
A21
A22
(Qx)T
0
Qx
QA′Q

=


7
−3.742
0
0
−3.742
10.642
9.131
0
0
9.131
10.594
4.772
0
−0
4.772
5.762


EXAMPLE 9.8
Use the function householder to tridiagonalize the matrix in Example 9.7; also de-
termine the transformation matrix P.
Solution
#!/usr/bin/python
## example9_8
from numarray import array,matrixmultiply
from householder3 import *
a = array([[ 7.0, 2.0,
3.0, -1.0],
\
[ 2.0, 8.0,
5.0,
1.0],
\

365
9.5 Eigenvalues of Symmetric Tridiagonal Matrices
[ 3.0, 5.0, 12.0,
9.0],
\
[-1.0, 1.0,
9.0,
7.0]])
d,c = householder(a)
print ’’Principal diagonal {d}:\n’’,d
print ’’\nSubdiagonal {c}:\n’’,c
print ’’\nTransformation matrix [P]:’’
print computeP(a)
raw_input(’’\nPress return to exit’’)
The results of running the above program are:
Principal diagonal {d}:
[
7.
10.64285714
10.59421525
5.76292761]
Subdiagonal {c}:
[-3.74165739
9.13085149
4.77158058]
Transformation matrix [P]:
[[ 1.
0.
0.
0.
]
[ 0.
-0.53452248 -0.25506831
0.80574554]
[ 0.
-0.80178373 -0.14844139 -0.57888514]
[ 0.
0.26726124 -0.95546079 -0.12516436]]
9.5
Eigenvalues of Symmetric Tridiagonal Matrices
Sturm Sequence
In principle, the eigenvalues of a matrix A can be determined by ﬁnding the roots of
the characteristic equation |A −λI| = 0. This method is impractical for large matrices,
since the evaluation of the determinant involves n3/3 multiplications. However, if the
matrix is tridiagonal (we also assume it to be symmetric), its characteristic polynomial
Pn(λ) = |A−λI| =

d1 −λ
c1
0
0
· · ·
0
c1
d2 −λ
c2
0
· · ·
0
0
c2
d3 −λ
c3
· · ·
0
0
0
c3
d4 −λ
· · ·
0
...
...
...
...
...
...
0
0
. . .
0
cn−1
dn −λ


366
Symmetric Matrix Eigenvalue Problems
can be computed with only 3(n−1) multiplications using the following sequence of
operations:
P0(λ) = 1
P1(λ) = d1 −λ
(9.49)
Pi(λ) = (di −λ)Pi−1(λ) −c2
i−1Pi−2(λ),
i = 2, 3, . . . , n
The polynomials P0(λ), P1(λ), . . . , Pn(λ) form a Sturm sequence that has the fol-
lowing property:
r The number of sign changes in the sequence P0(a), P1(a), . . . , Pn(a) is equal to the
number of roots of Pn(λ) that are smaller than a. If a member Pi(a) of the sequence
is zero, its sign is to be taken opposite to that of Pi−1(a).
As we see later, Sturm sequence property makes it possible to bracket the eigen-
values of a tridiagonal matrix.
■sturmSeq
Given d, c and λ, the function sturmSeq returns the Sturm sequence
P0(λ), P1(λ), . . . , Pn(λ)
The function numLambdas returns the number of sign changes in the sequence (as
noted before, this equals the number of eigenvalues that are smaller than λ).
## module sturmSeq
’’’ p = sturmSeq(c,d,lam).
Returns the Sturm sequence {p[0],p[1],...,p[n]}
associated with the characteristic polynomial
|[A] - lam[I]|
= 0, where [A] = [c\d\c] is a n x n
tridiagonal matrix.
numLam = numLambdas(p).
Returns the number of eigenvalues of a tridiagonal
matrix [A] = [c\d\c] that are smaller than ’lam’.
Uses the Sturm sequence {p}
obtained from ’sturmSeq’.
’’’
from numarray import ones, Float64
def sturmSeq(d,c,lam):
n = len(d) + 1

367
9.5 Eigenvalues of Symmetric Tridiagonal Matrices
p = ones((n),type=Float64)
p[1] = d[0] - lam
for i in range(2,n):
p[i] = (d[i-1] - lam)*p[i-1] - (c[i-2]**2)*p[i-2]
return p
def numLambdas(p):
n = len(p)
signOld = 1
numLam = 0
for i in range(1,n):
if p[i] > 0.0: sign = 1
elif p[i] < 0.0: sign = -1
else: sign = -signOld
if sign*signOld < 0: numLam = numLam + 1
signOld = sign
return numLam
EXAMPLE 9.9
Use the Sturm sequence property to show that the smallest eigenvalue of A is in the
interval (0.25, 0.5), where
A =


2
−1
0
0
−1
2
−1
0
0
−1
2
−1
0
0
−1
2


Solution Taking λ = 0.5, we have di −λ = 1.5 and c2
i−1 = 1 and the Sturm sequence
in Eqs. (9.49) becomes
P0(0.5) = 1
P1(0.5) = 1.5
P2(0.5) = 1.5(1.5) −1 = 1.25
P3(0.5) = 1.5(1.25) −1.5 = 0.375
P4(0.5) = 1.5(0.375) −1.25 = −0.6875
Since the sequence contains one sign change, there exists one eigenvalue smaller
than 0.5.

368
Symmetric Matrix Eigenvalue Problems
Repeating the process with λ = 0.25, we get di −λ = 1.75 and c2
i−1 = 1, which
results in the Sturm sequence
P0(0.25) = 1
P1(0.25) = 1.75
P2(0.25) = 1.75(1.75) −1 = 2.0625
P3(0.25) = 1.75(2.0625) −1.75 = 1.8594
P4(0.25) = 1.75(1.8594) −2.0625 = 1.1915
There are no sign changes in the sequence, so that all the eigenvalues are greater than
0.25. We thus conclude that 0.25 < λ1 < 0.5.
Gerschgorin’s Theorem
Gerschgorin’s theorem is useful in determining the global bounds on the eigenval-
ues of an n× n matrix A. The term “global” means the bounds that enclose all the
eigenvalues. We give here a simpliﬁed version for a symmetric matrix.
r If λ is an eigenvalue of A, then
ai −ri ≤λ ≤ai + ri,
i = 1, 2, . . . , n
where
ai = Aii
ri =
n

j=1
j̸=i
Aij

(9.50)
It follows that the limits on the smallest and the largest eigenvalues are given by
λmin ≥min
i
(ai −ri)
λmax ≤max
i
(ai + ri)
(9.51)
■gerschgorin
The function gerschgorin returns the lower and upper global bounds on the eigen-
values of a symmetric tridiagonal matrix A = [c\d\c].
## module gerschgorin
’’’ lamMin,lamMax = gerschgorin(d,c).
Applies Gerschgorin’s theorem to find the global bounds on
the eigenvalues of a tridiagomal matrix [A] = [c\d\c].
’’’
def gerschgorin(d,c):

370
Symmetric Matrix Eigenvalue Problems
the eigenvalues by Gerschgorin’s theorem. Then the method of bisection in conjunc-
tion with the Sturm sequence property is used to determine rN,rN−1, . . . ,r0 in that
order.
## module lamRange
’’’ r = lamRange(d,c,N).
Returns the sequence {r[0],r[1],...,r[N]}
that
separates the N lowest eigenvalues of the tridiagonal
matrix [A] = [c\d\c]; that is, r[i] < lam[i] < r[i+1].
’’’
from numarray import ones,Float64
from sturmSeq import *
from gerschgorin import *
def lamRange(d,c,N):
lamMin,lamMax = gerschgorin(d,c)
r = ones((N+1),type=Float64)
r[0] = lamMin
# Search for eigenvalues in descending order
for k in range(N,0,-1):
# First bisection of interval(lamMin,lamMax)
lam = (lamMax + lamMin)/2.0
h = (lamMax - lamMin)/2.0
for i in range(1000):
# Find number of eigenvalues less than lam
p = sturmSeq(d,c,lam)
numLam = numLambdas(p)
# Bisect again & find the half containing lam
h = h/2.0
if numLam < k: lam = lam + h
elif numLam > k: lam = lam - h
else: break
# If eigenvalue located, change the upper limit
# of search and record it in [r]
lamMax = lam
r[k] = lam
return r
EXAMPLE 9.11
Bracket each eigenvalue of the matrix A in Example 9.10.

369
9.5 Eigenvalues of Symmetric Tridiagonal Matrices
n = len(d)
lamMin = d[0] - abs(c[0])
lamMax = d[0] + abs(c[0])
for i in range(1,n-1):
lam = d[i] - abs(c[i]) - abs(c[i-1])
if lam < lamMin: lamMin = lam
lam = d[i] + abs(c[i]) + abs(c[i-1])
if lam > lamMax: lamMax = lam
lam = d[n-1] - abs(c[n-2])
if lam < lamMin: lamMin = lam
lam = d[n-1] + abs(c[n-2])
if lam > lamMax: lamMax = lam
return lamMin,lamMax
EXAMPLE 9.10
Use Gerschgorin’s theorem to determine the bounds on the eigenvalues of the matrix
A =


4
−2
0
−2
4
−2
0
−2
5


Solution Referring to Eqs. (9.50), we get
a1 = 4
a2 = 4
a3 = 5
r1 = 2
r2 = 4
r3 = 2
Hence
λmin ≥min(ai −ri) = 4 −4 = 0
λmax ≤max(ai + ri) = 4 + 4 = 8
Bracketing Eigenvalues
The Sturm sequence property together with Gerschgorin’s theorem provides us con-
venient tools for bracketing each eigenvalue of a symmetric tridiagonal matrix.
■lamRange
The function lamRange brackets the N smallest eigenvalues of a symmetric tridi-
agonal matrix A = [c\d\c]. It returns the sequence r0,r1, . . . ,rN, where each interval
(ri−1,ri) contains exactly one eigenvalue. The algorithm ﬁrst ﬁnds the bounds on all

371
9.5 Eigenvalues of Symmetric Tridiagonal Matrices
Solution In Example 9.10 we found that all the eigenvalues lie in (0, 8). We now bisect
this interval and use the Sturm sequence to determine the number of eigenvalues in
(0, 4). With λ = 4, the sequence is—see Eqs. (9.49)
P0(4) = 1
P1(4) = 4 −4 = 0
P2(4) = (4 −4)(0) −22(1) = −4
P3(4) = (5 −4)(−4) −22(0) = −4
Since a zero value is assigned the sign opposite to that of the preceding member, the
signs in this sequence are (+, −, −, −). The one sign change shows the presence of
one eigenvalue in (0, 4).
Next we bisect the interval (4, 8) and compute the Sturm sequence with λ = 6:
P0(6) = 1
P1(6) = 4 −6 = −2
P2(6) = (4 −6)(−2) −22(1) = 0
P3(6) = (5 −6)(0) −22(−2) = 8
In this sequence the signs are (+, −, +, +), indicating two eigenvalues in (0, 6).
Therefore
0 ≤λ1 ≤4
4 ≤λ2 ≤6
6 ≤λ3 ≤8
Computation of Eigenvalues
Once the desired eigenvalues are bracketed, they can be found by determining the
roots of Pn(λ) = 0 with bisection or Brent’s method.
■eigenvals3
The function eigenvals3 computes the N smallest eigenvalues of a symmetric tridi-
agonal matrix with the method of Brent.
## module eigenvals3
’’’ lam = eigenvals3(d,c,N).
Returns the N smallest eigenvalues of a
tridiagonal matrix [A] = [c\d\c].
’’’
from lamRange import *

372
Symmetric Matrix Eigenvalue Problems
from brent import *
from sturmSeq import sturmSeq
from numarray import zeros,Float64
def eigenvals3(d,c,N):
def f(x):
# f(x) = |[A] - x[I]|
p = sturmSeq(d,c,x)
return p[len(p)-1]
lam = zeros((N),type=Float64)
r = lamRange(d,c,N)
# Bracket eigenvalues
for i in range(N):
# Solve by Brent’s method
lam[i] = brent(f,r[i],r[i+1])
return lam
EXAMPLE 9.12
Use eigenvals3 to determine the three smallest eigenvalues of the 100 × 100 matrix
A =


2
−1
0
· · ·
0
−1
2
−1
· · ·
0
0
−1
2
· · ·
0
...
...
...
...
...
0
0
· · ·
−1
2


Solution
#!/usr/bin/python
## example9_12
from numarray import ones,Float64
from eigenvals3 import *
N = 3
n = 100
d = ones((n))*2.0
c = ones((n-1))*(-1.0)
lambdas = eigenvals3(d,c,N)
print lambdas
raw_input(’’\nPress return to exit’’)
Here are the eigenvalues:
[ 0.00096744
0.00386881
0.0087013 ]

373
9.5 Eigenvalues of Symmetric Tridiagonal Matrices
Computation of Eigenvectors
If the eigenvalues are known (approximate values will be good enough), the best
means of computing the corresponding eigenvectors is the inverse power method
with eigenvalue shifting. This method was discussed before, but the algorithm listed
did not take advantage of banding. Here we present a version of the method written
for symmetric tridiagonal matrices.
■inversePower3
This function is very similar to inversePower listed in Art. 9.3, but it executes much
faster since it exploits the tridiagonal structure of the matrix.
## module inversePower3
’’’ lam,x = inversePower3(d,c,s,tol=1.0e-6).
Inverse power method applied to a tridiagonal matrix
[A] = [c\d\c]. Returns the eigenvalue closest to ’s’
and the corresponding eigenvector.
’’’
from numarray import dot,zeros,Float64
from LUdecomp3 import *
from math import sqrt
from random import random
def inversePower3(d,c,s,tol=1.0e-6):
n = len(d)
e = c.copy()
cc = c.copy()
# Save original [c]
dStar = d - s
# Form [A*] = [A] - s[I]
LUdecomp3(cc,dStar,e)
# Decompose [A*]
x = zeros((n),type=Float64)
for i in range(n):
# Seed [x] with random numbers
x[i] = random()
xMag = sqrt(dot(x,x))
# Normalize [x]
x =x/xMag
flag = 0
for i in range(30):
# Begin iterations
xOld = x.copy()
# Save current [x]
LUsolve3(cc,dStar,e,x)
# Solve [A*][x] = [xOld]
xMag = sqrt(dot(x,x))
# Normalize [x]
x = x/xMag

374
Symmetric Matrix Eigenvalue Problems
if dot(xOld,x) < 0.0:
# Detect change in sign of [x]
sign = -1.0
x = -x
else: sign = 1.0
if sqrt(dot(xOld - x,xOld - x)) < tol:
return s + sign/xMag,x
print ’Inverse power method did not converge’
EXAMPLE 9.13
Compute the 10th smallest eigenvalue of the matrix A given in Example 9.12.
Solution The following program extracts the Nth eigenvalue of A by the inverse power
method with eigenvalue shifting:
#!/usr/bin/python
## example9_13
from numarray import ones
from lamRange import *
from inversePower3 import *
N = 10
n = 100
d = ones((n))*2.0
c = ones((n-1))*(-1.0)
r = lamRange(d,c,N)
# Bracket N smallest eigenvalues
s = (r[N-1] + r[N])/2.0
# Shift to midpoint of Nth bracket
lam,x = inversePower3(d,c,s)
# Inverse power method
print ’’Eigenvalue No.’’,N,’’ =’’,lam
raw_input(’’\nPress return to exit’’)
The result is
Eigenvalue No. 10
= 0.0959737849345
EXAMPLE 9.14
Compute the three smallest eigenvalues and the corresponding eigenvectors of the
matrix A in Example 9.5.
Solution
#!/usr/bin/python
## example9_14

375
9.5 Eigenvalues of Symmetric Tridiagonal Matrices
from householder3 import *
from eigenvals3 import *
from inversePower3 import *
from numarray import array,zeros,Float64,matrixmultiply
N = 3
# Number of eigenvalues requested
a = array([[ 11.0, 2.0,
3.0,
1.0,
4.0],
\
[
2.0, 9.0,
3.0,
5.0,
2.0],
\
[
3.0, 3.0, 15.0,
4.0,
3.0],
\
[
1.0, 5.0,
4.0, 12.0,
4.0],
\
[
4.0, 2.0,
3.0,
4.0, 17.0]])
xx = zeros((len(a),N),type=Float64)
d,c = householder(a)
# Tridiagonalize [A]
p = computeP(a)
# Compute transformation matrix
lambdas = eigenvals3(d,c,N)
# Compute eigenvalues
for i in range(N):
s = lambdas[i]*1.0000001
# Shift very close to eigenvalue
lam,x = inversePower3(d,c,s) # Compute eigenvector [x]
xx[:,i] = x
# Place [x] in array [xx]
xx = matrixmultiply(p,xx)
# Recover eigenvectors of [A]
print ’’Eigenvalues:\n’’,lambdas
print ’’\nEigenvectors:\n’’,xx
raw_input(’’Press return to exit’’)
Eigenvalues:
[
4.87394638
8.66356791
10.93677451]
Eigenvectors:
[[ 0.26726603
0.72910002
0.50579164]
[-0.74142854
0.41391448 -0.31882387]
[-0.05017271 -0.4298639
0.52077788]
[ 0.59491453
0.06955611 -0.60290543]
[-0.14970633 -0.32782151 -0.08843985]]
PROBLEM SET 9.2
1. Use Gerschgorin’s theorem to determine bounds on the eigenvalues of
(a)
A =


10
4
−1
4
2
3
−1
3
6


(b)
B =


4
2
−2
2
5
3
−2
3
4



376
Symmetric Matrix Eigenvalue Problems
2. Use the Sturm sequence to show that
A =


5
−2
0
0
−2
4
−1
0
0
−1
4
−2
0
0
−2
5


has one eigenvalue in the interval (2, 4).
3. Bracket each eigenvalue of
A =


4
−1
0
−1
4
−1
0
−1
4


4. Bracket each eigenvalue of
A =


6
1
0
1
8
2
0
2
9


5. Bracket every eigenvalue of
A =


2
−1
0
0
−1
2
−1
0
0
−1
2
−1
0
0
−1
1


6. Tridiagonalize the matrix
A =


12
4
3
4
9
3
3
3
15


with Householder’s reduction.
7. Use Householder’s reduction to transform the matrix
A =


4
−2
1
−1
−2
4
−2
1
1
−2
4
−2
−1
1
−2
4


to tridiagonal form.

377
9.5 Eigenvalues of Symmetric Tridiagonal Matrices
8. ■Compute all the eigenvalues of
A =


6
2
0
0
0
2
5
2
0
0
0
2
7
4
0
0
0
4
6
1
0
0
0
1
3


9. ■Find the smallest two eigenvalues of
A =


4
−1
0
1
−1
6
−2
0
0
−2
3
2
1
0
2
4


10. ■Compute the three smallest eigenvalues of
A =


7
−4
3
−2
1
0
−4
8
−4
3
−2
1
3
−4
9
−4
3
−2
−2
3
−4
10
−4
3
1
−2
3
−4
11
−4
0
1
−2
3
−4
12


and the corresponding eigenvectors.
11. ■Find the two smallest eigenvalues of the 6 × 6 Hilbert matrix
A =


1
1/2
1/3
· · ·
1/6
1/2
1/3
1/4
· · ·
1/7
1/3
1/4
1/5
· · ·
1/8
...
...
...
...
...
1/6
1/7
1/8
· · ·
1/11


Recall that this matrix is ill-conditioned.
12. ■Rewrite the function lamRange(d,c,N) so that it will bracket the N largest
eigenvalues of a tridiagonal matrix. Use this function to bracket the two largest
eigenvalues of the Hilbert matrix in Example 9.11.
13. ■
m
2m
3m
k
k
k
k
u1
u2
u3

378
Symmetric Matrix Eigenvalue Problems
The differential equations of motion of the mass–spring system are
k(−2u1 + u2) = m ¨u1
k(u1 −2u2 + u3) = 3m ¨u2
k(u2 −2u3) = 2m ¨u3
where ui(t) is the displacement of mass i from its equilibrium position and k is
the spring stiffness. Substituting ui(t) = yi sin ωt, we obtain the matrix eigenvalue
problem


2
−1
0
−1
2
−1
0
−1
2




y1
y2
y3

= mω2
k


1
0
0
0
3
0
0
0
2




y1
y2
y3


Determine the circular frequencies ω and the corresponding relative amplitudes
yi of vibration.
14. ■
u1
u2
un
m
k1
k2
kn
m
m
k3
The ﬁgure shows nidentical masses connected by springs of different stiffnesses.
The equation governing free vibration of the system is Au = mω2u, where ω is the
circular frequency and
A =


k1 + k2
−k2
0
0
· · ·
0
−k2
k2 + k3
−k3
0
· · ·
0
0
−k3
k3 + k4
−k4
· · ·
0
...
...
...
...
...
...
0
· · ·
0
−kn−1
kn−1 + kn
−kn
0
· · ·
0
0
−kn
kn


Given the spring stiffnesses k =

k1
k2
· · ·
kn
T
, write a program that com-
putes the N lowest eigenvalues λ = mω2 and the corresponding eigenvectors.
Run the program with N = 4 and
k =

400
400
400
0.2
400
400
200
T
kN/m
Note that the system is weakly coupled, k4 being small. Do the results make sense?
15. ■
1
n
2
L
x

379
9.5 Eigenvalues of Symmetric Tridiagonal Matrices
The differential equation of motion of the axially vibrating bar is
u′′ = ρ
E ¨u
where u(x, t) is the axial displacement, ρ represents the mass density and E is the
modulus of elasticity. The boundary conditions are u(0, t) = u′(L, t) = 0. Letting
u(x, t) = y(x) sin ωt, we obtain
y′′ = −ω2 ρ
E y
y(0) = y′(L) = 0
The corresponding ﬁnite difference equations are


2
−1
0
0
· · ·
0
−1
2
−1
0
· · ·
0
0
−1
2
−1
· · ·
0
...
...
...
...
...
...
0
0
· · ·
−1
2
−1
0
0
· · ·
0
−1
1




y1
y2
y3
...
yn−1
yn


=
&ωL
n
'2 ρ
E


y1
y2
y3
...
yn−1
yn/2


(a) If the standard form of these equations is Hz = λz, write down H and the
transformation matrix P in y = Pz. (b) Compute the lowest circular frequency of
the bar with n = 10, 100 and 1000 utilizing the module inversePower3. Note: the
analytical solution is ω1 = π

E/ρ/ (2L).
16. ■
1
2
P
n
n - 1
L
x
P
u
k
The simply supported column is resting on an elastic foundation of stiffness k
(N/m per meter length). An axial force P acts on the column. The differential
equation and the boundary conditions for the lateral displacement u are
u(4) + P
E I u′′ + k
E I u = 0
u(0) = u′′(0) = u(L) = u′′(L) = 0
Using the mesh shown, the ﬁnite difference approximation of these equations is
(5 + α)u1 −4u2 + u3 = λ(2u1 −u2)
−4u1 + (6 + α)u2 −4u3 + u4 = λ(−u1 + 2u2 + u3)

380
Symmetric Matrix Eigenvalue Problems
u1 −4u2 + (6 + α)u3 −4u4 + u5 = λ(−u2 + 2u3 −u4)
...
un−3 −4un−2 + (6 + α)un−1 −4un = λ(−un−2 + 2un−1 −un)
un−2 −4un−1 + (5 + α)un = λ(−un−1 + 2un)
where
α = kh4
E I =
1
(n+ 1)4
kL4
E I
λ = Ph2
E I =
1
(n+ 1)2
PL2
E I
Write a program that computes the lowest three buckling loads P and the corre-
sponding mode shapes. Run the program with kL4/(E I) = 1000 and n = 25.
17. ■Find smallest ﬁve eigenvalues of the 20 × 20 matrix
A =


2
1
0
0
· · ·
0
1
1
2
1
0
· · ·
0
0
0
1
2
1
· · ·
0
0
...
...
...
...
...
...
...
0
0
· · ·
1
2
1
0
0
0
· · ·
0
1
2
1
1
0
· · ·
0
0
1
2


Note: this is a difﬁcult matrix that has many pairs of double eigenvalues.
9.6
Other Methods
On occasions when all the eigenvalues and eigenvectors of a matrix are required, the
QR algorithm is a worthy contender. It is based on the decomposition A = QR where Q
and R are orthogonal and upper triangular matrices, respectively. The decomposition
is carried out in conjuction with Householder transformation. There is also a QL
algorithm : A = QL that works in the same manner, but here L is a lower triangular
matrix.
Schur’s factorization is another solid technique for determining the eigenvalues
of A. Here the decomposition is A = QTUQ, where Q is orthogonal and U is an upper
triangular matrix. The diagonal terms of U are the eigenvalues of A.
The LR algorithm is probably the fastest means of computing the eigenvalues; it
is also very simple to implement—see Prob. 22 of Problem Set 9.1. But its stability is
inferior to the other methods.

10
Introduction to Optimization
Find x that minimizes F(x) subject to g(x) = 0, h(x) ≥0
10.1
Introduction
Optimization is the term often used for minimizing or maximizing a function. It is suf-
ﬁcienttoconsidertheproblemofminimizationonly;maximizationof F(x)isachieved
by simply minimizing −F(x). In engineering, optimization is closely related to design.
The function F(x), called the merit function or objective function, is the quantity that
we wish to keep as small as possible, such as cost or weight. The components of x,
known as the design variables, are the quantities that we are free to adjust. Physical
dimensions (lengths, areas, angles, etc.) are common examples of design variables.
Optimizationisalargetopicwithmanybooksdedicatedtoit.Thebestwecandoin
limited space is to introduce a few basic methods that are good enough for problems
that are reasonably well behaved and don’t involve too many design variables. By
omitting the more sophisticated methods, we may actually not miss all that much.
All optimization algorithms are unreliable to a degree—any one of them may work on
one problem and fail on another. As a rule of thumb, by going up in sophistication we
gain computational efﬁciency, but not necessarily reliability.
The algorithms for minimization are iterative procedures that require starting
values of the design variables x. If F(x) has several local minima, the initial choice of
x determines which of these will be computed. There is no guaranteed way of ﬁnding
the global optimal point. One suggested procedure is to make several computer runs
using different starting points and pick the best result.
More often than not, the design variables are also subjected to restrictions, or
constraints, which may have the form of equalities or inequalities. As an example,
take the minimum weight design of a roof truss that has to carry a certain loading.
381

382
Introduction to Optimization
Assume that the layout of the members is given, so that the design variables are the
cross-sectional areas of the members. Here the design is dominated by inequality
constraints that consist of prescribed upper limits on the stresses and possibly the
displacements.
The majority of available methods are designed for unconstrained optimization,
where no restrictions are placed on the design variables. In these problems the min-
ima, if they exist, are stationary points (points where gradient vector of F(x) vanishes).
In the more difﬁcult problem of constrained optimization the minima are usually lo-
cated where the F(x) surface meets the constraints. There are special algorithms for
constrained optimization, but they are not easily accessible due to their complexity
and specialization. One way to tackle a problem with constraints is to use an uncon-
strained optimization algorithm, but modify the merit function so that any violation
of constraints is heavily penalized.
Consider the problem of minimizing F(x) where the design variables are subject
to the constraints
gi(x) = 0,
i = 1, 2, . . . , M
(10.1a)
hj(x) ≤0,
j = 1, 2, . . . , N
(10.1b)
We choose the new merit function be
F ∗(x) = F(x) + λP(x)
(10.2a)
where
P(x) =
M

i=1
[gi(x)]2 +
N

j=1
1
max

0, hj(x)
22
(10.2b)
isthepenaltyfunctionandλisamultiplier.Thefunctionmax(a, b)returnsthelargerof
aandb.Itisevidentthat P(x) = 0ifnoconstraintsareviolated.Violationofaconstraint
imposesapenalty proportional to the square of the violation. Hence the minimization
algorithm tends to avoid the violations, the degree of avoidance being dependent on
the magnitude of λ. If λ is small, optimization will proceed faster because there is more
“space” in which the procedure can operate, but there may be signiﬁcant violation of
constraints. On the other hand, a large λ can result in a poorly conditioned procedure,
but the constraints will be tightly enforced. It is advisable to run the optimization
program with λ that is on the small side. If the results show unacceptable constraint
violation, increase λ and run the program again, starting with the results of the pre-
vious run.
An optimization procedure may also become ill-conditioned when the con-
straints have widely different magnitudes. This problem can be alleviated by scaling

383
10.2 Minimization Along a Line
the offending constraints; that is, multiplying the constraint equations by suitable
constants.
10.2
Minimization Along a Line
f(x)
x
Local minimum
Global minimum
Constraint boundaries
c
d
Figure 10.1. Example of local and global minima.
Consider the problem of minimizing a function f (x) of a single variable x with the
constraints c ≤x ≤d. A hypothetical plot of the function is shown in Fig. 10.1. There
are two minimum points: a stationary point characterized by f ′(x) = 0 that represents
a local minimum, and a global minimum at the constraint boundary. It appears that
ﬁnding the global minimum is simple. All the stationary points could be located by
ﬁnding the roots of df/dx = 0, and each constraint boundary may be checked for a
global minimum by evaluating f (c) and f (d). Then why do we need an optimization
algorithm? We need it if f (x) is difﬁcult or impossible to differentiate; for example, if
f represents a complex computer algorithm.
Bracketing
Before a minimization algorithm can be entered, the minimum point must be brack-
eted. The procedure of bracketing is simple: start with an initial value of x0 and move
downhill computing the function at x1, x2, x3, . . . until we reach the point xn where
f (x) increases for the ﬁrst time. The minimum point is now bracketed in the inter-
val (xn−2, xn). What should the step size hi = xi+1 −xi be? It is not a good idea have
a constant hi since it often results in too many steps. A more efﬁcient scheme is to
increase the size with every step, the goal being to reach the minimum quickly, even
if the resulting bracket is wide. We chose to increase the step size by a constant factor;
that is, we use hi+1 = chi, c > 1.
Golden Section Search
The golden section search is the counterpart of bisection used in ﬁnding roots of
equations. Suppose that the minimum of f (x) has been bracketed in the interval
(a, b) of length h. To telescope the interval, we evaluate the function at x1 = b −Rh

384
Introduction to Optimization
and x2 = a + Rh, as shown in Fig. 10.2(a). The constant R will be determined shortly.
If f1 > f2 as indicated in the ﬁgure, the minimum lies in (x1, b); otherwise it is located
in (a, x2).
Rh
Rh
a
b
x1
x2
f1
f2
2Rh - h 
Rh'
Rh'
a
b
x1
x2
h
h'
x
x
f(x)
f(x)
(a)
(b)
Figure 10.2. Golden section telescoping.
Assuming that f1 > f2, we set a ←x1 and x1 ←x2, which yields a new interval (a, b) of
lengthh′ = Rh,asillustratedinFig.10.2(b).Tocarryoutthenexttelescopingoperation
we evaluate the function at x2 = a + Rh′ and repeat the process.
The procedure works only if Figs. 10.1(a) and (b) are similar; i.e., if the same
constant R locates x1 and x2 in both ﬁgures. Referring to Fig. 10.2(a), we note that
x2 −x1 = 2Rh −h. The same distance in Fig. 10.2(b) is x1 −a = h′ −Rh′. Equating
the two, we get
2Rh −h = h′ −Rh′
Substituting h′ = Rh and cancelling h yields
2R −1 = R(1 −R)
the solution of which is the golden ratio24:
R = −1 +
√
5
2
= 0.618 033 989 . . .
(10.3)
Note that each telescoping decreases the interval containing the minimum by the
factor R, which is not as good as the factor is 0.5 in bisection. However, the golden
search method achieves this reduction with one function evaluation, whereas two
evaluations would be needed in bisection.
24 R is the ratio of the sides of a “golden rectangle,” considered by ancient Greeks to have the perfect
proportions.

385
10.2 Minimization Along a Line
The number of telescoping required to reduce h from |b −a| to an error tole-
rance ε is given by
|b −a| Rn = ε
which yields
n = ln(ε/ |b −a|)
ln R
= −2.078 087 ln
ε
|b −a|
(10.4)
■goldSearch
This module contains the bracketing and the golden section search algorithms. For
the factor that multiplies successive search intervals in bracket we chose c = 1 + R.
## module goldSearch
’’’ a,b = bracket(f,xStart,h)
Finds the brackets (a,b) of a minimum point of the
user-supplied scalar function f(x).
The search starts downhill from xStart with a step
length h.
x,fMin = search(f,a,b,tol=1.0e-6)
Golden section method for determining x that minimizes
the user-supplied scalar function f(x).
The minimum must be bracketed in (a,b).
’’’
from math import log
def bracket(f,x1,h):
c = 1.618033989
f1 = f(x1)
x2 = x1 + h; f2 = f(x2)
# Determine downhill direction and change sign of h if needed
if f2 > f1:
h = -h
x2 = x1 + h; f2 = f(x2)
# Check if minimum between x1 - h and x1 + h
if f2 > f1: return x2,x1 - h
# Search loop
for i in range (100):
h = c*h

386
Introduction to Optimization
x3 = x2 + h; f3 = f(x3)
if f3 > f2: return x1,x3
x1 = x2; x2 = x3
f1 = f2; f2 = f3
print ’’Bracket did not find a mimimum’’
def search(f,a,b,tol=1.0e-9):
nIter = -2.078087*log(tol/abs(b-a)) # Eq. (10.4)
R = 0.618033989
C = 1.0 - R
# First telescoping
x1 = R*a + C*b; x2 = C*a + R*b
f1 = f(x1); f2 = f(x2)
# Main loop
for i in range(nIter):
if f1 > f2:
a = x1
x1 = x2; f1 = f2
x2 = C*a + R*b; f2 = f(x2)
else:
b = x2
x2 = x1; f2 = f1
x1 = R*a + C*b; f1 = f(x1)
if f1 < f2: return x1,f1
else: return x2,f2
EXAMPLE 10.1
Use goldSearch to ﬁnd x that minimizes
f (x) = 1.6x3 + 3x2 −2x
subject to the constraint x ≥0. Compare the result with the analytical solution.
Solution This is a constrained minimization problem. The minimum of f (x) is either
a stationary point in x ≥0, or located at the constraint boundary x = 0. We handle
the constraint with the penalty function method by minimizing f (x) + λ [min(0, x)]2.
Starting at x = 1 and choosing h = 0.01 for the ﬁrst step size in bracket (both
choices being rather arbitrary), we arrive at the following program:
#!/usr/bin/python
## example10_1

387
10.2 Minimization Along a Line
from goldSearch import *
def f(x):
lam = 1.0
# Constraint multiplier
c = min(0.0, x)
# Constraint function
return 1.6*x**3 + 3.0*x**2 - 2.0*x + lam*c**2
xStart = 1.0
h = 0.01
x1,x2 = bracket(f,xStart,h)
x,fMin = search(f,x1,x2)
print ’’x =’’,x
print ’’f(x) =’’,fMin
raw_input (’’\nPress return to exit’’)
The result is
x = 0.27349402621
f(x) = -0.28985978555
Since the minimum was found to be a stationary point, the constraint was not
active. Therefore, the penalty function was superﬂuous, but we did not know that at
the beginning.
The locations of stationary points are obtained analytically by solving
f ′(x) = 4.8x2 + 6x −2 = 0
The positive root of this equation is x = 0.273 494. As this is the only positive root,
there are no other stationary points in x ≥0 that we must check out. The only other
possible location of a minimum is the constraint boundary x = 0. But here f (0) = 0
is larger than the function at the stationary point, leading to the conclusion that the
global minimum occurs at x = 0.273 494.
EXAMPLE 10.2
c
d
y
b
b
a
H
B
x
x_
C

388
Introduction to Optimization
The trapezoid shown is the cross section of a beam. It is formed by removing the top
from a triangle of base B = 48 mm and height H = 60 mm. The problem is the ﬁnd
the height y of the trapezoid that maximizes the section modulus
S = I ¯x/c
where I ¯x is the second moment of the cross-sectional area about the axis that passes
through the centroid C of the cross section. By optimizing the section modulus, we
minimizethemaximumbendingstressσ max = M/S inthebeam, Mbeingthebending
moment.
Solution Considering the area of the trapezoid as a composite of a rectangle and
two triangles, we ﬁnd the section modulus through the following sequence of
computations:
Base of rectangle
a = B (H −y) /H
Base of triangle
b = (B −a) /2
Area
A = (B + a) y/2
First moment of area about x-axis
Qx = (ay) y/2 + 2 (by/2) y/3
Location of centroid
d = Qx/A
Distance involved in S
c = y −d
Second moment of area about x-axis
Ix = ay3/3 + 2

by3/12
 
Parallel axis theorem
I ¯x = Ix −Ad2
Section modulus
S = I ¯x/c
We could use the formulas in the table to derive S as an explicit function of y, but
that would involve a lot of error-prone algebra and result in an overly complicated
expression. It makes more sense to let the computer do the work.
The program we used and its output are listed below. As we wish to maximize S
with a minimization algorithm, the merit function is −S. There are no constraints in
this problem.
#!/usr/bin/python
## example10_2
from goldSearch import *
def f(y):
B = 48.0
H = 60.0
a = B*(H - y)/H
b = (B - a)/2.0

389
10.3 Conjugate Gradient Methods
A = (B + a)*y/2.0
Q = (a*y**2)/2.0 + (b*y**2)/3.0
d = Q/A
c = y - d
I = (a*y**3)/3.0 + (b*y**3)/6.0
Ibar = I - A*d**2
return -Ibar/c
yStart = 60.0
# Starting value of y
h = 1.0
# Size of first step used in bracketing
a,b = bracket(f,yStart,h)
yOpt,fOpt = search(f,a,b)
print ’’Optimal y =’’,yOpt
print ’’Optimal S =’’,-fOpt
print ’’S of triangle =’’,-f(60.0)
raw_input(’’Press return to exit’’)
Optimal y = 52.1762738732
Optimal S = 7864.43094136
S of triangle = 7200.0
The printout includes the section modulus of the original triangle. The optimal
section shows a 9.2% improvement over the triangle.
10.3
Conjugate Gradient Methods
Introduction
We now look at optimization in n-dimensional design space. The objective is to min-
imize F(x), where the components of x are the n independent design variables. One
way to tackle the problem is to use a succession of one-dimensional minimizations
to close in on the optimal point. The basic strategy is
r Choose a point x0 in the design space.
r loop with i = 1, 2, 3, . . .
Choose a vector vi.
Minimize F(x) along the line through xi−1 in the direction of vi. Let the mini-
mum point be xi.
if |xi −xi−1| < ε exit loop
r end loop

390
Introduction to Optimization
The minimization along a line can be accomplished with any one-dimensional
optimization algorithm (such as the golden section search). The only question left
open is how to choose the vectors vi.
Conjugate Directions
Consider the quadratic function
F(x) = c −

i
bixi + 1
2

i

j
Aijxixj
= c −bTx + 1
2xTAx
(10.5)
Differentiation with respect to xi yields
∂F
∂xi
= −bi +

j
Aijxj
which can be written in vector notation as
∇F = −b + Ax
(10.6)
where ∇F is the gradient of F.
Now consider the change in the gradient as we move from point x0 in the direction
of a vector u. The motion takes place along the line
x = x0 + su
where s is the distance moved. Substitution into Eq. (10.6) yields the expression for
the gradient at x:
∇F|x0+su = −b + A (x0 + su) = ∇F|x0 + s Au
Note that the change in the gradient is s Au. If this change is perpendicular to a vector
v; that is, if
vTAu = 0
(10.7)
the directions of u and v are said to be mutually conjugate (noninterfering). The
implication is that once we have minimized F(x) in the direction of v, we can move
along u without ruining the previous minimization.
For a quadratic function of n independent variables it is possible to construct n
mutually conjugate directions. Therefore, it would take preciselyn line minimizations
along these directions to reach the minimum point. If F(x) is not a quadratic function,
Eq. (10.5) can be treated as a local approximation of the merit function, obtained by

391
10.3 Conjugate Gradient Methods
truncating the Taylor series expansion of F(x) about x0 (see Appendix A1):
F(x) ≈F(x0) + ∇F(x0)(x −x0) + 1
2(x −x0)TH(x0)(x −x0)
Now the conjugate directions based on the quadratic form are only approximations,
valid in the close vicinity of x0. Consequently, it would take several cycles of n line
minimizations to reach the optimal point.
Thevariousconjugategradientmethodsusedifferenttechniquesforconstructing
conjugate directions. The so-called zero-order methods work with F(x) only, whereas
the ﬁrst-order methods utilize both F(x) and ∇F. The ﬁrst-order methods are com-
putationally more efﬁcient, of course, but the input of ∇F, if it is available at all, can
be very tedious.
Powell’s Method
Powell’s method is a zero-order method, requiring the evaluation of F(x) only. If the
problem involves n design variables, the basic algorithm is
r Choose a point x0 in the design space.
r Choose the starting vectors vi, i = 1, 2, . . . , n(the usual choice is vi = ei, where ei
is the unit vector in the xi-coordinate direction).
r cycle
do with i = 1, 2, . . . , n
Minimize F(x) along the line through xi−1 in the direction of vi. Let the
minimum point be xi.
end do
vn+1 ←x0 −xn
Minimize F(x) along the line through x0 in the direction of vn+1. Let the
minimum point be xn+1.
if |xn+1 −x0| < ε exit loop
do with i = 1, 2, . . . , n
vi ←vi+1 (v1 is discarded, the other vectors are reused)
end do
r end cycle
Powell demonstrated that the vectors vn+1 produced in successive cycles are mu-
tually conjugate, so that the minimum point of a quadratic surface is reached in
precisely n cycles. In practice, the merit function is seldom quadratic, but as long as
it can be approximated locally by Eq. (10.5), Powell’s method will work. Of course, it

392
Introduction to Optimization
usually takes more than ncycles to arrive at the minimum of a nonquadratic function.
Note that it takes n line minimizations to construct each conjugate direction.
Figure 10.3(a) illustrates one typical cycle of the method in a two dimensional
design space (n = 2). We start with point x0 and vectors v1 and v2. Then we ﬁnd the
distance s1 that minimizes F(x0 + sv1), ﬁnishing up at point x1 = x0 + s1v1. Next, we
determine s2 that minimizes F(x1 + sv2) which takes us to x2 = x1 + s2v2. The last
search direction is v3 = x2 −x0. After ﬁnding s3 by minimizing F(x0 + sv3) we get to
x3 = x0 + s3v3, completing the cycle.
P0
P1
P2
P3
P4
P5
P6
P0(x0)
P1(x1)
P2(x2)
P3(x3)
v1
v3
s2v2
s3v3
s1v1
v2
(a)
(b)
Figure 10.3. The method of Powell.
Figure 10.3(b) shows the moves carried out in two cycles superimposed on the
contour map of a quadratic surface. As explained before, the ﬁrst cycle starts at point
P0 and ends up at P3. The second cycle takes us to P6, which is the optimal point. The
directions P0P3 and P3P6 are mutually conjugate.
Powell’s method does have a major ﬂaw that has to be remedied—if F(x) is not
a quadratic, the algorithm tends to produce search directions that gradually be-
come linearly dependent, thereby ruining the progress towards the minimum. The
source of the problem is the automatic discarding of v1 at the end of each cycle. It
has been suggested that it is better to throw out the direction that resulted in the
largest decrease of F(x), a policy that we adopt. It seems counterintuitive to discard
the best direction, but it is likely to be close to the direction added in the next cycle,
thereby contributing to linear dependence. As a result of the change, the search di-
rections cease to be mutually conjugate, so that a quadratic form is not minimized
in n cycles any more. This is not a signiﬁcant loss since in practice F(x) is seldom a
quadratic.
Powell suggested a few other reﬁnements to speed up convergence. Since they
complicate the bookkeeping considerably, we did not implement them.

393
10.3 Conjugate Gradient Methods
■powell
The algorithm for Powell’s method is listed below. It utilizes two arrays: df contains
the decreases of the merit function in the ﬁrst n moves of a cycle, and the matrix u
stores the corresponding direction vectors vi (one vector per row).
## module powell
’’’ xMin,nCyc = powell(F,x,h=0.1,tol=1.0e-6)
Powell’s method of minimizing user-supplied function F(x).
x
= starting point
h
= initial search increment used in ’bracket’
xMin = mimimum point
nCyc = number of cycles
’’’
from numarray import identity,array,dot,zeros,Float64,argmax
from goldSearch import *
from math import sqrt
def powell(F,x,h=0.1,tol=1.0e-6):
def f(s): return F(x + s*v)
# F in direction of v
n = len(x)
# Number of design variables
df = zeros((n),type=Float64)
# Decreases of F stored here
u = identity(n)*1.0
# Vectors v stored here by rows
for j in range(30):
# Allow for 30 cycles:
xOld = x.copy()
# Save starting point
fOld = F(xOld)
# First n line searches record decreases of F
for i in range(n):
v = u[i]
a,b = bracket(f,0.0,h)
s,fMin = search(f,a,b)
df[i] = fOld - fMin
fOld = fMin
x = x + s*v
# Last line search in the cycle
v = x - xOld
a,b = bracket(f,0.0,h)
s,fLast = search(f,a,b)
x = x + s*v

394
Introduction to Optimization
# Check for convergence
if sqrt(dot(x-xOld,x-xOld)/n) < tol: return x,j+1
# Identify biggest decrease & update search directions
iMax = int(argmax(df))
for i in range(iMax,n-1):
u[i] = u[i+1]
u[n-1] = v
print ’’Powell did not converge’’
EXAMPLE 10.3
Find the minimum of the function25
F = 100(y −x2)2 + (1 −x)2
with Powell’s method starting at the point (−1, 1). This function has an interesting
topology. The minimum value of F occurs at the point (1, 1). As seen in the ﬁgure,
there is a hump between the starting and minimum points which the algorithm must
negotiate.
1000
800
600
400
200
0
y
1.5
1
0.5
0
-0.5
-1
x
1.5
1
0.5
0
-0.5
-1
-1.5
Solution The program that solves this unconstrained optimization problem is
#!/usr/bin/python
## example10_3
from powell import *
from numarray import array
def F(x): return 100.0*(x[1] - x[0]**2)**2 + (1 - x[0])**2
xStart = array([-1.0, 1.0])
xMin,nIter = powell(F,xStart)
print ’’x =’’,xMin
25 From Shoup, T. E., and Mistree, F., Optimization Methods with Applications for Personal Computers,
Prentice-Hall, 1987.

395
10.3 Conjugate Gradient Methods
print ’’F(x) =’’,F(xMin)
print ’’Number of cycles =’’,nIter
raw_input (’’Press return to exit’’)
As seen in the printout, the minimum point was obtained in 14 cycles.
x = [ 1.
1.]
F(x) = 4.93038065763e-030
Number of cycles = 14
EXAMPLE 10.4
Use powell to determine the smallest distance from the point (5, 8) to the curve
xy = 5.
Solution This is a constrained optimization problem: minimize F(x, y) = (x −5)2 +
(y −8)2 (the square of the distance) subject to the equality constraint xy −5 = 0. The
following program uses Powell’s method with penalty function:
#!/usr/bin/python
## example10_4
from powell import *
from numarray import array
from math import sqrt
def F(x):
lam = 1.0
# Penalty multiplier
c = x[0]*x[1] - 5.0
# Constraint equation
return
distSq(x) + lam*c**2
# Penalized merit function
def distSq(x): return (x[0] - 5)**2 + (x[1] - 8)**2
xStart = array([1.0, 5.0])
x,numIter = powell(F,xStart,0.01)
print ’’Intersection point =’’,x
print ’’Minimum distance =’’, sqrt(distSq(x))
print ’’xy =’’, x[0]*x[1]
print ’’Number of cycles =’’,numIter
raw_input (’’Press return to exit’’)
As mentioned before, the value of the penalty function multiplier λ (called lam
in the program) can have profound effects on the result. We chose λ = 1 (as in the

396
Introduction to Optimization
program listing) with the following result:
Intersection point = [ 0.73306759
7.58776399]
Minimum distance = 4.28679959441
xy = 5.56234382324
Number of cycles = 6
The small value of λ favored speed of convergence over accuracy. Since the viola-
tion of the constraint xy = 5 is clearly unacceptable, we ran the program again with
λ = 10 000 and changed the starting point to (0.733 07, 7.587 76), the end point of the
ﬁrst run. The results shown below are now acceptable:
Intersection point = [ 0.65561312
7.6265359 ]
Minimum distance = 4.36040970941
xy = 5.00005696388
Number of cycles = 5
Could we have used λ = 10 000 in the ﬁrst run? In this case we would be lucky
and obtain the minimum in 19 cycles. Hence we save eight cycles by using two runs.
However, a large λ often causes the algorithm to hang up, so that it generally wise to
start with a small λ.
Fletcher–Reeves Method
Let us assume again that the merit function has the quadratic form in Eq. (10.5). Given
a direction v, it took Powell’s method n line minimizations to construct a conjugate
direction. We can reduce this to a single line minimization with a ﬁrst-order method.
Here is the procedure, known as the Fletcher–Reeves method:
r Choose a starting point x0.
r g0 ←−∇F(x0)
r v0 ←g0 (lacking a previous search direction, we choose the steepest descent).
r loop with i = 0, 1, 2, . . .
Minimize F(x) along vi; let the minimum point be xi+1.
gi+1 ←−∇F(xi+1).
if
gi+1
 < ε or |F(xi+1) −F(xi)| < ε exit loop (convergence criterion).
γ ←(gi+1 · gi+1)/(gi · gi).
vi+1 ←gi+1 + γ vi.
r end loop
It can be shown that vi and vi+1 are mutually conjugate; that is, they satisfy the
relationship vT
i Avi+1 = 0 . Also gi · gi+1 = 0.

397
10.3 Conjugate Gradient Methods
The Fletcher–Reeves method will ﬁnd the minimum of a quadratic function in
n iterations. If F(x) is not quadratic, it is necessary to restart the process after every
n iterations. A variant of the Fletcher–Reeves method replaces the expression for γ by
γ = (gi+1 −gi) · gi+1
gi · gi
(10.6)
For a quadratic F(x) this change makes no difference since gi and gi+1 are orthogonal.
However, for merit functions that are not quadratic, Eq. (10.6) is claimed to eliminate
the need for a restart after n iterations.
■fletcherReeves
## module fletcherReeves
’’’ xMin,nIter = optimize(F,gradF,x,h=0.01,tol=1.0e-6
Fletcher-Reeves method of minimizing a function.
F(x)
= user-supplied function to be minimized.
gradF(x) = user-supplied function for grad(F).
x
= starting point.
h
= initial search increment used in ’bracket’.
xMin
= mimimum point.
nIter
= number of iterations.
’’’
from numarray import array,zeros,Float64,dot
from goldSearch import *
from math import sqrt
def optimize(F,gradF,x,h=0.1,tol=1.0e-6):
def f(s): return F(x + s*v)
# Line function along v
n = len(x)
g0 = -gradF(x)
v = g0.copy()
F0 = F(x)
for i in range(200):
a,b = bracket(f,0.0,h)
# Minimization along
s,fMin = search(f,a,b)
# a line
x = x + s*v
F1 = F(x)
g1 = -gradF(x)
if (sqrt(dot(g1,g1)) <= tol) or (abs(F0 - F1) < tol):
return x,i+1

398
Introduction to Optimization
gamma = dot((g1 - g0),g1)/dot(g0,g0)
v = g1 + gamma*v
g0 = g1.copy()
F0 = F1
print ’’fletcherReeves did not converge’’
EXAMPLE 10.5
Use the Fletcher–Reeves method to locate the minimum of
F(x) = 10x2
1 + 3x2
2 −10x1x2 + 2x1
Start with x0 =

0
0
T
.
Solution Since F(x) is quadratic, we need only two iterations. The gradient of F is
∇F(x) =
)
∂F/∂x1
∂F/∂x2
*
=
)
20x1 −10x2 + 2
−10x1 + 6x2
*
First iteration:
g0 = −∇F(x0) =
)
−2
0
*
v0 = g0 =
)
−2
0
*
x0 + sv0 =
)
−2s
0
*
f (s) = F(x0 + sv0) = 10(2s)2 + 3(0)2 −10(−2s)(0) + 2(−2s)
= 40s2 −4s
f ′(s) = 80s −4 = 0
s = 0.05
x1 = x0 + sv0 =
)
0
0
*
+ 0.05
)
−2
0
*
=
)
−0.1
0
*
Second iteration:
g1 = −∇F(x1) =
)
−20(−0.1) + 10(0) −2
10(−0.1) −6(0)
*
=
)
0
−1.0
*
γ = g1 · g1
g0 · g0
= 1.0
4
= 0.25
v1 = g1 + γ v0 =
)
0
−1.0
*
+ 0.25
)
−2
0
*
=
)
−0.5
−1.0
*
x1 + sv1 =
)
−0.1
0
*
+ s
)
−0.5
−1.0
*
=
)
−0.1 −0.5s
−s
*

399
10.3 Conjugate Gradient Methods
f (s) = F(x1 + sv1)
= 10(−0.1 −0.5s)2 + 3(−s)2 −10(−0.1 −0.5s)(−s) + 2(−0.1 −0.5s)
= 0.5s2 −s −0.1
f ′(s) = s −1 = 0
s = 1.0
x2 = x1 + sv1 =
)
−0.1
0
*
+ 1.0
)
−0.5
−1.0
*
=
)
−0.6
−1.0
*
We have now reached the minimum point.
EXAMPLE 10.6
b
h
The ﬁgure shows the cross section of a channel carrying water. Determine h, b
and θ that minimize the length of the wetted perimeter while maintaining a cross-
sectional area of 8 m2. (Minimizing the wetted perimeter results in least resistance to
the ﬂow.) Use the Fletcher–Reeves method.
Solution The cross-sectional area of the channel is
A = 1
2 [b + (b + 2htan θ)] h = (b + htan θ)h
and the length of the wetted perimeter is
S = b + 2(hsec θ)
The optimization problem can be cast as
minimize b + 2hsec θ
subject to (b + htan θ)h = 8
Equality constraints can often be used to eliminate some of the design variables.
In this case we can solve the area constraint for b, obtaining
b = 8
h −htan θ
Substituting the result into the expression for S, we get
S = 8
h −htan θ + 2hsec θ

400
Introduction to Optimization
We have now arrived at an unconstrained optimization problem of ﬁnding h and
θ that minimize S. The gradient of the merit function is
∇S =
)
∂S/∂h
∂S/∂θ
*
=
)
−8/h2 −tan θ + 2 sec θ
−hsec2 θ + 2hsec θ tan θ
*
Letting x =

h θ
T
and starting with x0 =

2 0
T
, we arrive at the following program:
#!/usr/bin/python
## example10_6
from fletcherReeves import *
from numarray import array,zeros,Float64
from math import cos,tan,pi
def F(x):
return
8.0/x[0] - x[0]*(tan(x[1]) - 2.0/cos(x[1]))
def gradF(x):
g = zeros((2),type=Float64)
g[0] = -8.0/(x[0]**2) - tan(x[1]) + 2.0/cos(x[1])
g[1] = x[0]*(-1.0/cos(x[1]) + 2.0*tan(x[1]))/cos(x[1])
return g
x = array([2.0, 0.0])
x,nIter = optimize(F,gradF,x)
b = 8.0/x[0] - x[0]*tan(x[1])
print ’’h =’’,x[0],’’m’’
print ’’b =’’,b,’’m’’
print ’’theta =’’,x[1]*180.0/pi,’’deg’’
print ’’perimeter =’’, F(x),’’m’’
print ’’Number of iterations =’’,nIter
raw_input(’’Press return to exit’’)
The results are:
h = 2.14914172295 m
b = 2.48162366149 m
theta = 29.9997001208 deg
perimeter = 7.44483887289 m
Number of iterations = 4

401
10.3 Conjugate Gradient Methods
PROBLEM SET 10.1
1. ■The Lennard–Jones potential between two molecules is
V = 4ε
$,σ
r
-12
−
,σ
r
-6%
where ε and σ are constants, and r is the distance between the molecules. Use
the module goldSearch to ﬁnd σ/r that minimizes the potential and verify the
result analytically.
2. ■One wave function of the hydrogen atom is
ψ = C

27 −18σ + 2σ 2 
e−σ/3
where
σ = zr/a0
C =
1
81
√
3π
& z
a0
'2/3
z = nuclear charge
a0 = Bohr radius
r = radial distance
Find σ where ψ is at a minimum. Verify the result analytically.
3. ■Determine the parameter p that minimizes the integral
/ π
0
sin x cos px dx
Hint: use numerical quadrature to evaluate the integral.
4. ■
R3= 1.5 
R4= 1.8 
E = 120 V
i1
i2
i1
i2
R
R5= 1.2 
R2= 3.6 
R1= 2 
Kirchoff’s equations for the two loops of the electrical circuit are
R1i1 + R3i1 + R(i1 −i2) = E
R2i2 + R4i2 + R5i2 + R(i2 −i1) = 0
Find the resistance R that maximizes the power dissipated by R. Hint: solve
Kirchoff’s equations numerically with one of the functions in Chapter 2.

402
Introduction to Optimization
5. ■
T
a
r
T
A wire carrying an electric current is surrounded by rubber insulation of outer
radius r. The resistance of the wire generates heat, which is conducted through
the insulation and convected into the surrounding air. The temperature of the
wire can be shown to be
T = q
2π
&ln(r/a)
k
+ 1
hr
'
+ T∞
where
q = rate of heat generation in wire = 50 W/m
a = radius of wire = 5 mm
k = thermal conductivity of rubber = 0.16 W/m · K
h = convective heat-transfer coefﬁcient = 20 W/m2 · K
T∞= ambient temperature = 280 K
Find r that minimizes T.
6. ■Minimize the function
F(x, y) = (x −1)2 + (y −1)2
subject to the constraints x + y ≤1 and x ≥0.6.
7. ■Find the minimum of the function
F(x, y) = 6x2 + y3 + xy
in y ≥0. Verify the result analytically.
8. ■Solve Prob. 7 if the constraint is changed to y ≥−2.
9. ■Determine the smallest distance from the point (1, 2) to the parabola y = x2.

403
10.3 Conjugate Gradient Methods
10. ■
C
x
d
0.4 m
0.4 m
0.2 m
Determine x that minimizes the distance d between the base of the area shown
and its centroid C.
11. ■
0.43H
r
H
x
C
The cylindrical vessel of mass M has its center of gravity at C. The water in the
vessel has a depth x. Determine x so that the center of gravity of the vessel–water
combination is as low as possible. Use M = 115 kg, H = 0.8 m and r = 0.25 m.
12. ■
b
b
a
a
The sheet of cardboard is folded along the dashed lines to form a box with an
open top. If the volume of the box is to be 1.0 m3, determine the dimensions a
and b that would use the least amount of cardboard. Verify the result analytically.

404
Introduction to Optimization
13. ■
a
b
P
u
v
A
B
C
B'
The elastic cord ABC has an extensional stiffness k. When the vertical force P is
applied at B, the cord deforms to the shape AB′C. The potential energy of the
system in the deformed position is
V = −Pv + k(a + b)
2a
δ2
AB + k(a + b)
2b
δ2
BC
where
δ AB =

(a + u)2 + v2 −a
δBC =

(b −u)2 + v2 −b
are the elongations of AB and BC. Determine the displacements uand v by min-
imizing V (this is an application of the principle of minimum potential energy:
a system is in stable equilibrium if its potential energy is at a minimum). Use
a = 150 mm, b = 50 mm, k = 0.6 N/mm and P = 5 N.
14. ■
b = 4 m
P = 50 kN
Each member of the truss has a cross-sectional area A. Find A and the angle θ
that minimize the volume
V =
bA
cos θ
of the material in the truss without violating the constraints
σ ≤150 MPa
δ ≤5 mm

405
10.3 Conjugate Gradient Methods
where
σ =
P
2A sin θ = stress in each member
δ =
Pb
2E A sin 2θ sin θ = displacement at the load P
and E = 200 × 109 Pa.
15. ■Solve Prob. 14 if the allowable displacement is changed to 2.5 mm.
16. ■
r1
r2
L = 1.0 m
L = 1.0 m
P = 10 kN
The cantilever beam of circular cross section is to have the smallest volume pos-
sible subject to constraints
σ 1 ≤180 MPa
σ 2 ≤180 MPa
δ ≤25 mm
where
σ 1 = 8PL
πr3
1
= maximum stress in left half
σ 2 = 4PL
πr3
2
= maximum stress in right half
δ = 4PL3
3π E
& 7
r4
1
+ 1
r4
2
'
= displacement at free end
and E = 200 GPa. Determine r1 and r2.
17. ■Find the minimum of the function
F(x, y, z) = 2x2 + 3y2 + z2 + xy + xz −2y
and conﬁrm the result analytically.
18. ■
r
h
b
The cylindrical container has a conical bottom and an open top. If the volume V
of the container is to be 1.0 m3, ﬁnd the dimensions r, h and b that minimize the

406
Introduction to Optimization
surface area S. Note that
V = πr2
&b
3 + h
'
S = πr
,
2h +

b2 + r2
-
19. ■
3 m
4 m
P = 200 kN
P = 200 kN
1
2
3
The equilibrium equations of the truss shown are
σ 1 A1 + 4
5σ 2 A2 = P
3
5σ 2 A2 + σ 3 A3 = P
where σ i is the axial stress in member i and Ai are the cross-sectional areas.
The third equation is supplied by compatibility (geometrical constraints on the
elongations of the members):
16
5 σ 1 −5σ 2 + 9
5σ 3 = 0
Find the cross-sectional areas of the members that minimize the weight of the
truss without the stresses exceeding 150 MPa.
20. ■
B
H
y1
y2
L1
L2
L3
W1
W2
1
3
2
A cable supported at the ends carries the weights W1 and W2. The potential energy
of the system is
V = −W1y1 −W2y2
= −W1L1 sin θ1 −W2(L1 sin θ1 + L2 sin θ2)

407
10.4 Other Methods
and the geometric constraints are
L1 cos θ1 + L2 cos θ2 + L3 cos θ3 = B
L1 sin θ1 + L2 sin θ2 + L3 sin θ3 = H
The principle of minimum potential energy states that the equilibrium conﬁgu-
ration of the system is the one that satisﬁes geometric constraints and minimizes
the potential energy. Determine the equilibrium values of θ1, θ2 and θ3 given
that L1 = 1.2 m, L2 = 1.5 m, L3 = 1.0 m, B = 3.5 m, H = 0, W1 = 20 kN and
W2 = 30 kN.
10.4 Other Methods
The Nelder–Mead method, also know as the downhill simplex algorithm, is a popular
androbustmethodofoptimization.Itsmainattractionisacommonsensegeometrical
approach that requires no mathematical sophistication. In speed of execution of the
downhill simplex is not competitive with Powell’s method.
Simulated annealing methods have been successfully employed for complex
problems involving many design variables. These methods are based on an anal-
ogy with the annealing as a slowly cooled liquid metal solidiﬁes into a crystalline,
minimum energy structure. One distinguishing feature of simulated annealing is its
ability to pass over local minima in its search for the global minimum.
A topic that we reluctantly omitted is the simplex method of linear programming.
Linear programming deals with optimization problems where the merit function and
the constraints are linear expressions of the independent variables. The general linear
programming problem is to minimize the objective function
F =
n

i=1
aixi
subject to the constraints
n

j=1
Bijxj ≤bi,
i = 1, 2, . . . , m1
n

j=1
Cijxj ≥ci,
i = 1, 2, . . . , m2
n

j=1
Dijxj = di,
i = 1, 2, . . . , m3
xi ≥0,
i = 1, 2, . . . n

408
Introduction to Optimization
where the constants bi, ci and di are nonnegative. The roots of linear programming
lie in cost analysis, operations research and related ﬁelds. We skip this topic because
there are very few engineering applications that can be formulated as linear program-
ming problems. In addition, a fail-safe implementation of the simplex method results
in a rather complicated algorithm. This not to say that the simplex method has no
place nonlinear optimization. There are several effective methods that rely in part on
the simplex method. For example, problems with nonlinear constraints can often be
solved by a piecewise application of linear programming. The simplex method is also
used to compute search directions in the so-called method of feasible directions.

Appendices
A1
Taylor Series
Function of a Single Variable
The Taylor series expansion of a function f (x) about the point x = a is the inﬁnite
series
f (x) = f (a) + f ′(a)(x −a) + f ′′(a)(x −a)2
2!
+ f ′′′(a)(x −a)3
3!
+ · · ·
(A1)
In the special case a = 0 the series is also known as the MacLaurin series. It can be
shown that the Taylor series expansion is unique in the sense that no two functions
have identical Taylor series.
A Taylor series is meaningful only if all the derivatives of f (x) exist at x = a and
the series converges. In general, convergence occurs only if x is sufﬁciently close to a;
i.e., if |x −a| ≤ε, where ε is called the radius of convergence. In many cases ε is inﬁnite.
Another useful form of the Taylor series is the expansion about an arbitrary value
of x:
f (x + h) = f (x) + f ′(x)h + f ′′(x)h2
2! + f ′′′(x)h3
3! + · · ·
(A2)
Since it is not possible to evaluate all the terms of an inﬁnite series, the effect of
truncating the series in Eq. (A2) is of great practical importance. Keeping the ﬁrst
n+ 1 terms, we have
f (x + h) = f (x) + f ′(x)h + f ′′(x)h2
2! + · · · + f (n)(x)hn
n! + En
(A3)
where En is the truncation error (sum of the truncated terms). The bounds on the
truncation error are given by Taylor’s theorem:
En = f (n+1)(ξ) hn+1
(n+ 1)!
(A4)
409

410
Appendices
where ξ is some point in the interval (x, x + h). Note that the expression for En is
identical to the ﬁrst discarded term of the series, but with x replaced by ξ. Since the
value of ξ is undetermined (only its limits are known), the most we can get out of
Eq. (A4) are the upper and lower bounds on the truncation error.
If the expression for f (n+1)(ξ) is not available, the information conveyed by
Eq. (A4) is reduced to
En = O(hn+1)
(A5)
which is a concise way of saying that the truncation error is of the order of hn+1, or
behaves as hn+1. If h is within the radius of convergence, then
O(hn) > O(hn+1)
i.e., the error is always reduced if a term is added to the truncated series (this may not
be true for the ﬁrst few terms).
In the special case n = 1, Taylor’s theorem is known as the mean value theorem:
f (x + h) = f (x) + f ′(ξ)h,
x ≤ξ ≤x + h
(A6)
Function of Several Variables
If f is a function of the m variables x1, x2, . . . , xm, then its Taylor series expansion
about the point x = [x1, x2, . . . , xm]T is
f (x + h) = f (x) +
m

i=1
∂f
∂xi

x
hi + 1
2!
m

i=1
m

j=1
∂2 f
∂xi∂xj

x
hihj + · · ·
(A7)
This is sometimes written as
f (x + h) = f (x) + ∇f (x) · h + 1
2hTH(x)h + · · ·
(A8)
The vector ∇f is known as the gradient of f and the matrix H is called the Hessian
matrix of f .
EXAMPLE A1
Derive the Taylor series expansion of f (x) = ln(x) about x = 1.
Solution The derivatives of f are
f ′(x) = 1
x
f ′′(x) = −1
x2
f ′′′(x) = 2!
x3
f (4) = −3!
x4 etc.
Evaluating the derivatives at x = 1, we get
f ′(1) = 1
f ′′(1) = −1
f ′′′(1) = 2!
f (4)(1) = −3! etc.

411
A1 Taylor Series
which upon substitution into Eq. (A1) together with a = 1 yields
ln(x) = 0 + (x −1) −(x −1)2
2!
+ 2!(x −1)3
3!
−3!(x −1)4
4!
+ · · ·
= (x −1) −1
2(x −1)2 + 1
3(x −1)3 −1
4(x −1)4 + · · ·
EXAMPLE A2
Use the ﬁrst ﬁve terms of the Taylor series expansion of ex about x = 0:
ex = 1 + x + x2
2! + x3
3! + x4
4! + · · ·
together with the error estimate to ﬁnd the bounds of e.
Solution
e = 1 + 1 + 1
2 + 1
6 + 1
24 + E4 = 65
24 + E4
E4 = f (4)(ξ)h5
5! = eξ
5! ,
0 ≤ξ ≤1
The bounds on the truncation error are
(E4)min = e0
5! =
1
120
(E4)max = e1
5! =
e
120
Thus the lower bound on e is
emin = 65
24 +
1
120 = 163
60
and the upper bound is given by
emax = 65
24 + emax
120
which yields
119
120emax = 65
24
emax = 325
119
Therefore,
163
60 ≤e ≤325
119
EXAMPLE A3
Compute the gradient and the Hessian matrix of
f (x, y) = ln

x2 + y2
at the point x = −2, y = 1.

412
Appendices
Solution
∂f
∂x =
1

x2 + y 2

1
2
2x

x2 + y 2

=
x
x2 + y 2
∂f
∂y =
y
x2 + y 2
∇f (x, y) =

x/(x2 + y 2)
y/(x2 + y 2)
T
∇f (−2, 1) =

−0.4
0.2
T
∂2 f
∂x2 = (x2 + y 2) −x(2x)
(x2 + y 2)2
= −x2 + y 2
(x2 + y 2)2
∂2 f
∂y 2 =
x2 −y 2
(x2 + y 2)2
∂2 f
∂x∂y = ∂2 f
∂y∂x =
−2xy
(x2 + y 2)2
H(x, y) =
)
−x2 + y 2
−2xy
−2xy
x2 −y 2
*
1
(x2 + y 2)2
H(−2, 1) =
)
−0.12
0.16
0.16
0.12
*
A2
Matrix Algebra
A matrix is a rectangular array of numbers. The size of a matrix is determined by the
number of rows and columns, also called the dimensions of the matrix. Thus a matrix
of mrows and n columns is said to have the size m× n (the number of rows is always
listed ﬁrst). A particularly important matrix is the square matrix, which has the same
number of rows and columns.
An array of numbers arranged in a single column is called a column vector, or
simply a vector. If the numbers are set out in a row, the term row vector is used. Thus
a column vector is a matrix of dimensions n× 1 and a row vector can be viewed as a
matrix of dimensions 1 × n.
We denote matrices by boldface, upper case letters. For vectors we use boldface,
lower case letters. Here are examples of the notation:
A =


A11
A12
A13
A21
A22
A23
A31
A32
A33


b =


b1
b2
b3


(A9)

413
A2 Matrix Algebra
Indices of the elements of a matrix are displayed in the same order as its dimensions:
therownumbercomesﬁrst,followedbythecolumnnumber.Onlyoneindexisneeded
for the elements of a vector.
Transpose
The transpose of a matrix A is denoted by AT and deﬁned as
AT
ij = A ji
The transpose operation thus interchanges the rows and columns of the matrix. If
applied to vectors, it turns a column vector into a row vector and vice versa. For
example, transposing A and b in Eq. (A9), we get
AT =


A11
A21
A31
A12
A22
A32
A13
A23
A33


bT =

b1
b2
b3

An n× n matrix is said to be symmetric if AT = A. This means that the elements
in the upper triangular portion (above the diagonal connecting A11 and Ann) of a
symmetric matrix are mirrored in the lower triangular portion.
Addition
The sum C = A + B of two m× n matrices A and B is deﬁned as
Cij = Aij + Bij,
i = 1, 2, . . . , m;
j = 1, 2, . . . , n
(A10)
Thus the elements of C are obtained by adding elements of A to the elements of B.
Note that addition is deﬁned only for matrices that have the same dimensions.
Multiplication
The scalar or dot product c = a · b of the vectors a and b, each of size m, is deﬁned as
c =
m

k=1
akbk
(A11)
It can also be written in the form c = aTb.
The matrix product C = AB of an l × m matrix A and an m× n matrix B is
deﬁned by
Cij =
m

k=1
AikBkj,
i = 1, 2, . . . ,l;
j = 1, 2, . . . , n
(A12)

414
Appendices
The deﬁnition requires the number of columns in A (the dimension m) to be equal to
the number of rows in B. The matrix product can also be deﬁned in terms of the dot
product. Representing the ith row of A as the vector ai and the jth column of B as the
vector b j, we have
Cij = ai · b j
(A13)
A square matrix of special importance is the identity or unit matrix
I =


1
0
0
· · ·
0
0
1
0
· · ·
0
0
0
1
· · ·
0
...
...
...
...
...
0
0
0
0
1


(A14)
It has the property AI = IA = A.
Inverse
The inverse of an n× n matrix A, denoted by A−1, is deﬁned to be an n× n matrix
that has the property
A−1A = AA−1 = I
(A15)
Determinant
The determinant of a square matrix A is a scalar denoted by |A| or det(A). There is no
concise deﬁnition of the determinant for a matrix of arbitrary size. We start with the
determinant of a 2 × 2 matrix, which is deﬁned as

A11
A12
A21
A22
 = A11 A22 −A12 A21
(A16)
The determinant of a 3 × 3 matrix is then deﬁned as

A11
A12
A13
A21
A22
A23
A31
A32
A33

= A11

A22
A23
A32
A33
 −A12

A21
A23
A31
A33
 + A13

A21
A22
A31
A32

Having established the pattern, we can now deﬁne the determinant of an n× n
matrix in terms of the determinant of an (n−1) × (n−1) matrix:
|A| =
n

k=1
(−1)k+1 A1kM1k
(A17)

415
A2 Matrix Algebra
where Mik is the determinant of the (n−1) × (n−1) matrix obtained by deleting the
ith row and kth column of A. The term (−1)k+i Mik is called a cofactor of Aik.
Equation (A17) is known as Laplace’s development of the determinant on the
ﬁrst row of A. Actually Laplace’s development can take place on any convenient row.
Choosing the ith row, we have
|A| =
n

k=1
(−1)k+i AikMik
(A18)
The matrix A is said to be singular if |A| = 0.
Positive Deﬁniteness
An n× n matrix A is said to be positive deﬁnite if
xTAx > 0
(A19)
for all nonvanishing vectors x. It can be shown that a matrix is positive deﬁnite if the
determinants of all its leading minors are positive. The leading minors of A are the
n square matrices


A11
A12
· · ·
A1k
A12
A22
· · ·
A2k
...
...
...
...
Ak1
Ak2
· · ·
Akk


,
k = 1, 2, . . . , n
Therefore, positive deﬁniteness requires that
A11 > 0,

A11
A12
A21
A22
 > 0,

A11
A12
A13
A21
A22
A23
A31
A32
A33

> 0, . . . , |A| > 0
(A20)
Useful Theorems
We list without proof a few theorems that are utilized in the main body of the text.
Most proofs are easy and could be attempted as exercises in matrix algebra.
(AB)T = BTAT
(A21a)
(AB)−1 = B−1A−1
(A21b)
AT = |A|
(A21c)
|AB| = |A| |B|
(A21d)
if C = ATBA where B = BT, then C = CT
(A21e)

416
Appendices
EXAMPLE A4
Letting
A =


1
2
3
1
2
1
0
1
2


u =


1
6
−2


v =


8
0
−3


compute u + v, u · v, Av and uTAv.
Solution
u + v =


1 + 8
6 + 0
−2 −3

=


9
6
−5


u · v = 1(8) + 6(0) + (−2)(−3) = 14
Av =


a1· v
a2· v
a3· v

=


1(8) + 2(0) + 3(−3)
1(8) + 2(0) + 1(−3)
0(8) + 1(0) + 2(−3)

=


−1
5
−6


uTAv = u · (Av) = 1(−1) + 6(5) + (−2)(−6) = 41
EXAMPLE A5
Compute |A|, where A is given in Example A4. Is A positive deﬁnite?
Solution Laplace’s development of the determinant on the ﬁrst row yields
|A| = 1

2
1
1
2
 −2

1
1
0
2
 + 3

1
2
0
1

= 1(3) −2(2) + 3(1) = 2
Development on the third row is somewhat easier due to the presence of the zero
element:
|A| = 0

2
3
2
1
 −1

1
3
1
1
 + 2

1
2
1
2

= 0(−4) −1(−2) + 2(0) = 2
To verify positive deﬁniteness, we evaluate the determinants of the leading
minors:
A11 = 1 > 0
O.K.

A11
A12
A21
A22
 =

1
2
1
2
 = 0
Not O.K.
A is not positive deﬁnite.

417
A2 Matrix Algebra
EXAMPLE A6
Evaluate the matrix product AB, where A is given in Example A4 and
B =


−4
1
1
−4
2
−2


Solution
AB =


a1· b1
a1· b2
a2· b1
a2· b2
a3· b1
a3· b2


=


1(−4) + 2(1) + 3(2)
1(1) + 2(−4) + 3(−2)
1(−4) + 2(1) + 1(2)
1(1) + 2(−4) + 1(−2)
0(−4) + 1(1) + 2(2)
0(1) + 1(−4) + 2(−2)

=


4
−13
0
−9
5
−8




Index
adaptive Runge–Kutta method, 275–283
algebra. See linear algebraic equations systems;
matrix algebra
appendices, 409–412
arithmetic operators, in Python, 7
arrays
accessing/changing, 21
copying, 23
creating, 19–21
functions, 22–23
operations on, 21–22
augmented assignment operators, 7
augmented coefﬁcient matrix, 28
backward ﬁnite difference approximations,
183
banded matrix, 56–66
bisect, 145–146
bisection method, for equation root, 145–148
brent, 150–151
Brent’s method, 148–153
Bulirsch–Stoer algorithm, 286–290
Bulirsch–Stoer method, 278–279, 283
algorithm, 286–290
midpoint method, 283–284
Richardson extrapolation, 284–286
bulStoer, 287
byte code, 1
choleski(a), 47–48
Choleski’s decomposition, 45–52
cmath module, 18–19
coefﬁcient matrices, symmetric/banded, 56–66
symmetric, 59–60
symmetric/pentadiagonal, 61–66
tridiagonal, 57–59
comparison operators, in Python, 8
composite Simpson’s 1/3 rule, 204
composite trapezoidal rule, 200–201
conditionals, in Python, 9
conjGrad, 86, 90
conjugate gradient methods, 86, 88–96, 389–400
conjugate directions, 390–391
Fletcher–Reeves method, 396–400
Powell’s method, 391–396
continuation character, 6
cubicSpline, 117–119
cubic splines, 115–121, 195
curve ﬁtting. See interpolation/curve ﬁtting
cyclic tridiagonal equation, 94
deﬂation of polynomials, 172–173
diagonal dominance, 68
Doolittle’s decomposition, 42–45
dot, 3
eigenvals3, 371–372
eigenvalue problems. See symmetric matrix
eigenvalue problems
elementary operations, linear algebra, 31
embedded integration formula, 275
equivalent linear equation, 31
error
control in Python, 15
in ﬁnite difference approximations, 186–187
Euhler’s method, stability of, 272
Euler–Maclaurin summation formula, 201
evalPoly, 172
evaluation of polynomials, 170–172
exponential functions, ﬁtting, 130–131
false position method, roots of equations, 179
ﬁnite difference approximations, 181–187
errors in, 186–187
419

420
Index
ﬁnite difference approximations (cont.)
ﬁrst central difference approximations,
182–183
ﬁrst noncentral, 183–184
second noncentral, 185
ﬁnite elements, 233
ﬁrst central difference approximations,
182–183
ﬁrst noncentral ﬁnite difference
approximations, 183–184
fletcherReeves, 397–398
Fletcher–Reeves method, 396–400
forward ﬁnite difference approximations, 183
fourth-order differential equation, 316–320
fourth-order Runge–Kutta method, 257–265
functions, in Python, 15–16
gaussElimin, 37–38
Gauss elimination method, 33–41
algorithm for, 35–38
back substitution phase, 37
elimination phase, 35–36
back substitution phase, 35
elimination phase, 34–35
multiple sets of equations, 38–41
Gauss elimination with scaled row pivoting,
68–76
Gaussian integration, 215–230
abscissas/weights for Guaussian quadratures,
221–230
Gauss–Chebyshev quadrature, 222
Gauss–Hermite quadrature, 223
Gauss–Laguerre quadrature, 222–223
Gauss–Legendre quadrature, 221–222
Gauss quadrature with logarithmic
singularity, 224
determination of nodal abscissas/weights,
219–221
formulas for, 215
orthogonal polynomials, 217–219
Gauss–Jordan elimination, 32
Gauss–Legendre quadrature over quadrilateral
element, 233–240
gaussNodes, 224–225
gaussPivot, 71–72
gaussQuad, 225–226
gaussQuad2, 235–237
gaussSeidel, 87–88
Gauss–Seidel method, 85–88
gerschgorin, 368–369
Gerschgorin’s theorem, 368–369
golden section search, 383–389
goldSearch, 385–386
Higher-order equations, shooting method,
301–307
householder, 362–363
householder reduction to tridiagonal form,
357–365
accumulated transformation matrix,
361–365
householder matrix, 358–359
householder reduction of symmetric
matrix, 359–361
Idle (code editor), 3
ill-conditioning, 29–30
incremental search method, roots of equations,
143–145
indirect methods. See iterative methods
initial value problems
adaptive Runge–Kutta method, 275–283
Bulirsch–Stoer method, 278–279, 283
algorithm, 286–290
midpoint method, 283–284
Richardson extrapolation, 284–286
introduction, 248–249
multistep methods, 294
problem set, 266–271, 290–294
Runge–Kutta methods, 255–265
fourth-order, 257–265
second-order, 255–257
stability/stiffness, 271–275
stability of Euhler’s method, 272
stiffness, 272–275
Taylor series method, 249–255
Input/output
printing, 14–15
reading, 13
integration order, 234
interpolation, derivatives by, 190–195
cubic spline interpolant, 195
polynomial interpolant, 190–191
interpolation/curve ﬁtting
interpolation with cubic spline, 115–121
introduction, 103
least–squares ﬁt, 124–137
ﬁtting a straight line, 126
ﬁtting linear forms, 126–127
polynomial ﬁt, 127–129
weighting of data, 129–137
ﬁtting exponential functions,
130–131
weighted linear regression, 130
polynomial interpolation, 104–115
Lagrange’s method, 104–105
limits of, 110–115

421
Index
Neville’s method, 108–110
Newton’s method, 105–108
problem set, 121–124, 137–140
rational function interpolation, 140–141
interval halving method. See bisection method
inversePower, 345–346
inversePower3, 373–374
iterative methods, 85–96
conjugate gradient method, 86, 88–96
Gauss–Seidel method, 85–88
jacobi, 331
Jacobian matrix, 235
Jacobi method, 326–342
Jacobi diagonalization, 328–333
Jacobi rotation, 327–328
similarity transformation/diagonalization,
326–327
transformation to standard form,
333–342
Jenkins–Traub algorithm, 179–180
knots of spline, 115
Kronecker delta, 104
Lagrange’s method, 104–105
Laguerre’s method, 173–178
lamRange, 369–370
LAPACK (Linear Algebra PACKage), 27
least-squares ﬁt, 124–137
ﬁtting linear forms, 126–127
ﬁtting straight line, 126
polynomial ﬁt, 127–129
weighting data, 129–137
ﬁtting exponential functions,
130–131
weighted linear regression, 130
linear algebraic equations systems. See also
matrix algebra
back substitution, 32
direct methods overview, 31–33
elementary operations, 31
equivalent equations, 31
forward substitution, 32
Gauss elimination method, 33–41
algorithm for, 35–38
back substitution phase, 37
elimination phase, 35–36
back substitution phase, 35
elimination phase, 34–35
multiple sets of equations, 38–41
ill-conditioning, 29–30
introduction, 27–33
iterative methods, 85–96
conjugate gradient method, 86, 88–96
Gauss–Seidel method, 85–88
linear systems, 30
LU decomposition methods, 41–52
Choleski’s decomposition, 45–52
Doolittle’s decomposition, 42–45
matrix inversion, 82–84
methods of solution, 30–31
notation in, 27–28
pivoting, 66–76
diagonal dominance, 68
Gauss elimination with scaled row pivoting,
68–76
when to pivot, 74–76
problem set, 53–56, 77, 86, 96–101
QR decomposition, 101
singular value decomposition, 101
symmetric/banded coefﬁcient matrices,
56–66
symmetric coefﬁcient, 59–60
symmetric/pentadiagonal coefﬁcient,
61–66
tridiagonal coefﬁcient, 57–59
uniqueness of solution, 28–29
linear forms, ﬁtting, 126–127
linear systems, 30
linInterp, 297
lists, 5–7
loops, 10–11
LR algorithm, 380
LUdecomp, 44
LUdecomp3, 59
LUdecomp5, 66
LU decomposition methods, 41–52
Choleski’s decomposition, 45–52
Doolittle’s decomposition, 42–45
LUpivot, 72–73
mathematical functions, 12–13
math module, 17–18
MATLAB, 2–3
matrix algebra, 412–417
addition, 413
determinant, 414–415
example, 416–417
inverse, 414
multiplication, 413–414
positive deﬁniteness, 415
transpose, 413
useful theorems, 415
matrix inversion, 82–84
methods of feasible directions, 408

422
Index
methods of solution, 30–31
midpoint, 285–286
minimization along line, 383–389
bracketing, 383
golden section search, 383–389
modules, in Python, 17
multiple integrals, 233
Gauss–Legendre quadrature over
quadrilateral element, 233–240
quadrature over triangular element,
240–245
multistep methods, for initial value problems,
294
NameError, 23
Namespace, 23
natural cubic spline, 115
Nelder–Mead method, 407
neville, 109–110
Neville’s method, 108–110
Newton–Cotes formulas, 199–207
composite trapezoidal rule, 200–201
recursive trapezoidal rule, 202–203
Simpson’s rules, 203–207
trapezoidal rule, 200
newtonPoly, 107–108
newtonRaphson, 155–156
newtonRaphson2, 160–161
Newton–Raphson method, 153–158
norm of matrix, 29
notation, 27–28
Numarray module, 3
numarry module, 19–23, 7
accessing/changing array, 21
array functions, 22–23
copying arrays, 23
creating an array, 19–21
operations on arrays, 21–22
numerical differentiation
derivatives by interpolation, 190–195
cubic spline interpolant, 195
polynomial interpolant, 190–191
ﬁnite difference approximations,
181–187
errors in, 186–187
ﬁrst central difference approximations,
182–183
ﬁrst noncentral, 183–184
second noncentral, 185
introduction, 181
problem set, 195–197
Richardson extrapolation, 187–190
numerical instability, 243, 262
numerical integration
Gaussian integration, 215–230
abscissas/weights for Guaussian
quadratures, 221–230
Gauss–Chebyshev quadrature, 222
Gauss–Hermite quadrature, 223
Gauss–Laguerre quadrature, 222–223
Gauss–Legendre quadrature, 221–222
Gauss quadrature with logarithmic
singularity, 224
determination of nodal abscissas/weights,
219–221
formulas for, 215
orthogonal polynomials, 217–219
introduction, 198–199, 217
multiple integrals, 233
Gauss–Legendre quadrature over
quadrilateral element, 233–240
quadrature over triangular element,
240–245
Newton–Cotes formulas, 199–207
composite trapezoidal rule, 200–201
recursive trapezoidal rule, 202–203
Simpson’s rules, 203–207
trapezoidal rule, 200
problem set, 212–215, 230–233, 245–247
Romberg integration, 207–212
operators
arithmetic, 7
comparison, 8
optimization
conjugate gradient methods, 389–400
conjugate directions, 390, 391
Fletcher–Reeves method, 396–400
Powell’s method, 391–396
introduction, 381–383
minimization along line, 383–389
bracketing, 383
golden section search, 383–389
Nelder–Mead method, 407
problem set, 401–407
simplex method, 407–408
simulated annealing method, 407
orthogonal polynomials, 217–219
overrelaxation factor, 86, 96–101
piecewise cubic curve, 116
pivoting, 66–76
diagonal dominance, 68
Gauss elimination with scaled row pivoting,
68–76
when to pivot, 74–76

423
Index
polyFit, 128–129
polynomial ﬁt, 127–129
polynomial interpolant, 190–191
polynomial interpolation, 104–115
Lagrange’s method, 104–105
limits of, 110–115
Neville’s method, 108–110
Newton’s method, 105–108
polynomials, zeroes of, 170–178
deﬂation of polynomials, 172–173
evaluation of polynomials, 170–172
Laguerre’s method, 173–178
polyRoots, 174–176
powell, 393–394
Powell’s method, 391–396
Prandtl stress function, 235
printing input, 14–15
printSoln, 251–252
Python
arithmetic operators, 7
cmath module, 18–19
comparison operators, 8
conditionals, 9
error control, 15
functions, 15–16
general information, 1–4
obtaining Python, 3–4
overview, 1–3
lists, 5–7
loops, 10–11
mathematical functions, 12–13
math module, 17–18
modules, 17
numarry module, 19–23
accessing/changing array, 21
array functions, 22–23
copying arrays, 23
creating an array, 19–21
operations on arrays, 21–22
printing input, 14–15
reading input, 13
scoping of variables, 23–24
strings, 5
tuples, 5
type conversion, 11–12
variables, 4
writing/running programs, 24–26
Python interpreter, 1, 1
QR algorithm, 380
quadrature. See numerical integration
quadrature over triangular element,
240–245
rational function interpolation, 140–141
reading input, 13
recursive trapezoidal rule, 202–203
relaxation, 86
relaxation factor, 86, 88–96
Richardson extrapolation, 187–190, 284–286
romberg, 209–210
Romberg integration, 207–212
rootsearch, 144
roots of equations
Brent’s method, 148–153
false position method, 179
incremental search method, 143–145
introduction, 142–143
Jenkins–Traub algorithm, 179–180
method of bisection, 145–148
Newton–Raphson method, 153–158
problem set, 164–169, 178–179
secant method, 179
systems of equations, 158–163
Newton–Raphson method, 159–163
zeroes of polynomials, 170–178
deﬂation of polynomials, 172–173
evaluation of polynomials, 170–172
Laguerre’s method, 173–178
row pivoting, 56, 67
Runge–Kutta–Fehlberg formulas, 275–276
Runge–Kutta methods, 255–265
fourth-order, 257–265
second-order, 255–257
run kut4, 258–259
run kut5, 278–279, 283
scaled row pivoting, 68–76
secent formula, 179
second forward ﬁnite difference
approximations, 185
second noncentral ﬁnite difference
approximations, 185
second-order differential equation, 296–301,
311–316
second-order Runge–Kutta method, 255–257
shape functions, 234
shooting method, 296–307
higher-order equations, 301–307
second-order differential equation, 296–301
Shur’s factorization, 380
similarity transformation, 104
Simpson’s 3/8 rule, 204
Simpson’s rules, 203–207
slicing operator, 3
sortJacobi, 333
sparsely populated matrix, 56

424
Index
stability/stiffness, 271–275
stability of Euhler’s method, 272
stiffness, 272–275
stdForm, 335–336
stiffness, 272–275
straight line, ﬁtting, 126
strings, 5
Strum sequence, 365–375
sturmSeq, 366–367, 375
swapCols, 70
swapRows, 70
symmetric/banded coefﬁcient matrices, 56–66
symmetric coefﬁcient, 59–60
symmetric/pentadiagonal coefﬁcient, 61–66
tridiagonal coefﬁcient, 57–59
symmetric coefﬁcient matrix, 59–60
symmetric matrix eigenvalue problems
eigenvalues of symmetric tridiagonal
matrices, 365–375
bracketing eigenvalues, 369–371
computation of eigenvalues, 371–372
computation of eigenvectors, 373–375
Gerschgorin’s theorem, 368–369
Strum sequence, 365–375
householder reduction to tridiagonal form,
357–365
accumulated transformation matrix,
361–365
householder matrix, 358–359
householder reduction of symmetric
matrix, 359–361
introduction, 324–326
inverse power/power methods, 342–351
eigenvalue shifting, 344
inverse power method, 342–344
power method, 345–351
Jacobi method, 326–342
Jacobi diagonalization, 328–333
Jacobi rotation, 327–328
similarity transformation/diagonalization,
326–327
transformation to standard form, 333–342
LR algorithm, 380
problem set, 351–357, 375–380
QR algorithm, 380
Shur’s factorization, 380
symmetric/pentadiagonal coefﬁcient matrix,
61–66
synthetic division, 172–173
systems of equations
Newton–Raphson method, 159–163
roots of equations, 158–163
taylor, 250–251
Taylor series, 249–255, 409–412
function of several variables, 410–412
function of single variable, 409–410
transpose operator, 413
trapezoid, 202–203
trapezoidal rule, 200
triangleQuad, 242
tridiagonal coefﬁcient matrix, 57–59
tuples, 5
two-point boundary value problems
ﬁnite difference method, 310–320
fourth-order differential equation, 316–320
second-order differential equation,
311–316
introduction, 295–296
problem set, 307–310, 320–323
shooting method, 296–307
higher-order equations, 301–307
second-order differential equation, 296–301
type(a), 13
type conversion, 11–12
underrelaxation factor, 86, 90
variables
Python, 4
scoping, 23–24
Taylor series, 409–410, 410–412
weighted linear regression, 130
writing/running programs, in Python, 24–26
ZeroDivisionError, 15
zeroes of polynomials, 170–178
deﬂation of polynomials, 172–173
evaluation of polynomials, 170–172
Laguerre’s method, 173–178
zero offset, 3

