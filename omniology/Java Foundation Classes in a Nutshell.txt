

FOUNDATION 
CLASSES
IN A NUTSHELL
A Desktop Quick Reference

THE
JAVA
SERIES
TM
Exploring Java™
Java™Threads
Java™Network Programming
Java™Virtual Machine
Java™AWT Reference
Java™Language Reference
Java™Fundamental Classes Reference
Database Programming with 
JDBC™and Java™
Java™ Distributed Computing 
Developing Java Beans™
Java™ Security
Java™ Cryptography
Java™ Swing
Java™ Servlet Programming
Java™ I/O
Java™ 2D Graphics
Enterprise JavaBeans™ 
Also from O’Reilly
Java™in a Nutshell
Java™in a Nutshell, Deluxe Edition
Java™Examples in a Nutshell
Java™Enterprise in a Nutshell
Java™Foundation Classes in 
a Nutshell
Java™Power Reference: A Complete 
Searchable Resource on CD-ROM

Beijing • Cambridge • Farnham • Köln • Sebastopol • Taipei • Tokyo
David Flanagan
FOUNDATION 
CLASSES
IN A NUTSHELL
A Desktop Quick Reference

Java™ Foundation Classes in a Nutshell
by David Flanagan
Copyright © 1999 O’Reilly Media, Inc. All rights reserved.
Published by O’Reilly Media, Inc., 1005 Gravenstein Highway North, Sebastopol, CA 95472.
Editor: Paula Ferguson
Production Editor: Nicole Arigo
Production Services: Nancy Crumpton
Printing History:
September 1999:
First Edition.
Nutshell Handbook, the Nutshell Handbook logo, and the O’Reilly logo are registered
trademarks and the Java™series is a trademark of O’Reilly Media, Inc. The In a Nutshell series
designations, Java™ Foundation Classes in a Nutshell, the image of a Florida panther, and
related trade dress are trademarks of O’Reilly Media, Inc. Java™and all Java-based trademarks
and logos are trademarks or registered trademarks of Sun Microsystems, Inc., in the United
States and other countries. O’Reilly Media, Inc. is independent of Sun Microsystems.
Many of the designations used by manufacturers and sellers to distinguish their products are
claimed as trademarks.  Where those designations appear in this book, and O’Reilly Media,
Inc. was aware of a trademark claim, the designations have been printed in caps or initial caps.
While every precaution has been taken in the preparation of this book, the publisher assumes
no responsibility for errors or omissions, or for damages resulting from the use of the
information contained herein.
This book uses RepKover ,  a durable and flexible lay-flat binding.
™
ISBN:  978-1-565-92488-8
[M]
[4/05]

Ta ble of Contents
Pr eface .................................................................................................. ix
Part I: Introducing the Java Foundation Classes
Chapter 1 —The Java Foundation Classes ................................... 3
Chapter 2 —Swing and AWT Architectur e ................................... 5
A Simple Graphical User Interface ........................................................ 6
Components ............................................................................................ 7
Pr operties .............................................................................................. 11
Containers and Containment ................................................................ 12
Layout Management .............................................................................. 15
Event Handling ..................................................................................... 17
Swing Component Architectur e ........................................................... 23
Chapter 3 —Swing Programming Topics ................................... 25
Versions of Swing ................................................................................. 25
Labels and HTML .................................................................................. 26
Actions ................................................................................................... 26
Tooltips .................................................................................................. 27
Timers .................................................................................................... 27
The Event Dispatch Thread .................................................................. 28
Client Properties ................................................................................... 28
Keyboard Shortcuts ............................................................................... 29
Serialization ........................................................................................... 33
v

Borders .................................................................................................. 34
Icons ...................................................................................................... 34
Cursors ................................................................................................... 35
Double-Buf fering .................................................................................. 37
The Box Container ................................................................................ 37
Simple Dialogs ...................................................................................... 40
JFileChooser .......................................................................................... 42
JColorChooser ....................................................................................... 44
Menus .................................................................................................... 45
JTree and TreeModel ............................................................................ 47
JTable and TableModel ......................................................................... 50
JTextComponent and HTML Text Display ........................................... 52
Pluggable Look-and-Feel ...................................................................... 55
Accessibility ........................................................................................... 58
Custom Components ............................................................................ 59
Chapter 4 —Graphics with AWT and Java 2D .......................... 64
Graphics Before Java 2D ...................................................................... 64
Java 2D Graphics Attributes and Operations ...................................... 68
The Coordinate System ......................................................................... 71
Shapes ................................................................................................... 73
Str oking Lines ........................................................................................ 76
Paint ....................................................................................................... 79
Blending Colors with AlphaComposite ............................................... 80
Rendering Hints .................................................................................... 86
Fonts and Text ...................................................................................... 86
Buf fered Images .................................................................................... 92
Transfor mations with AfﬁneTransfor m ................................................ 97
Color Spaces ........................................................................................ 100
Chapter 5 —Printing ..................................................................... 102
Printing in Java 1.1 .............................................................................. 102
Printing in Java 1.2 .............................................................................. 103
Chapter 6 —Data Transfer .......................................................... 111
The Data Transfer Framework ........................................................... 111
Cut-and-Paste ...................................................................................... 114
Drag-and-Dr op .................................................................................... 115
A Data Source ..................................................................................... 117
A Data Sink ......................................................................................... 119
vi

Chapter 7 —Applets ....................................................................... 123
Writing Applets ................................................................................... 123
Including Applets in HTML Files ....................................................... 129
Applet Security .................................................................................... 133
Part II: API Quick Reference
How To Use This Quick Reference .............................................. 139
Chapter 8 —The java.applet Package ....................................... 150
Chapter 9 —The java.awt Package ........................................... 154
Chapter 10 —The java.awt.color Package .............................. 232
Chapter 11 —The java.awt.datatransfer Package ................ 239
Chapter 12 —The java.awt.dnd Package ................................ 246
Chapter 13 —The java.awt.dnd.peer Package ....................... 262
Chapter 14 —The java.awt.event Package .............................. 264
Chapter 15 —The java.awt.font Package ................................ 288
Chapter 16 —The java.awt.geom Package .............................. 302
Chapter 17 —The java.awt.im Package ................................... 329
Chapter 18 —The java.awt.image Package ............................ 332
Chapter 19 —The java.awt.image.renderable Package ....... 368
Chapter 20 —The java.awt.peer Package ................................ 373
vii

Chapter 21 —The java.awt.print Package .............................. 381
Chapter 22 —The javax.accessibility Package ....................... 388
Chapter 23 —The javax.swing Package ................................... 399
Chapter 24 —The javax.swing.border Package ..................... 519
Chapter 25 —The javax.swing.colorchooser Package .......... 527
Chapter 26 —The javax.swing.event Package ........................ 530
Chapter 27 —The javax.swing.ﬁlechooser Package .............. 551
Chapter 28 —The javax.swing.plaf Package .......................... 554
Chapter 29 —The javax.swing.table Package ........................ 568
Chapter 30 —The javax.swing.text Package ........................... 579
Chapter 31 —The javax.swing.text.html Package ................. 633
Chapter 32 —The javax.swing.text.html.parser Package .... 656
Chapter 33 —The javax.swing.text.rtf Package ..................... 664
Chapter 34 —The javax.swing.tree Package .......................... 666
Chapter 35 —The javax.swing.undo Package ....................... 683
Chapter 36 —Class Index ............................................................ 690
Index ................................................................................................. 703
viii

Preface
This book is a desktop quick refer ence for Java™ programmers who are writing
applications or applets that involve graphics or graphical user interfaces. The ﬁrst
part of the book is a fast-paced, “no ﬂuff” introduction to the Java APIs that com-
prise the Java Foundation Classes, or JFC. These chapters are followed by a quick-
refer ence section that succinctly details every class of those APIs.
This book complements the best-selling Java in a Nutshell. That volume introduces
the Java programming language itself and provides an API quick refer ence for the
cor e packages and classes of the Java platform. A third volume in the series, Java
Enterprise in a Nutshell, covers the Java Enterprise APIs. Programmers working on
server-side or enterprise applications will be interested in that book.
Contents of This Book
The ﬁrst seven chapters of this book document the graphics and graphical user
inter face (GUI) APIs used in client-side Java programming. The chapters are:
Chapter 1: The Java Foundation Classes
Pr ovides a quick introduction to the JFC and the APIs that comprise it.
Chapter 2: Swing and AWT Architectur e
Explains the architectur e used for graphical user interfaces built with the older
Abstract Windowing Toolkit (AWT) and the new Swing API. The remaining
chapters of the book assume an understanding of the fundamentals presented
her e.
Chapter 3: Swing Programming Topics
Intr oduces a number of the most important GUI components and application
services provided by the Swing API.
ix

Chapter 4: Graphics with AWT and Java 2D
Explains how to draw text and graphics. It introduces the AWT graphics API,
used in Java 1.0 and Java 1.1, and the powerful new Java 2D API of Java 2.
Chapter 5: Printing
Covers how to draw text and graphics to a printer, using both the Java 1.1
and Java 2 printing APIs.
Chapter 6: Data Transfer
Explains how to enable data transfer between and within applications, using
both cut-and-paste and drag-and-drop.
Chapter 7: Applets
Documents the Java applet API, which allows Java applets, or mini-applica-
tions, to run within web browsers.
These chapters provide enough information to get you started with each of the JFC
APIs. The bulk of the book, however, is the API quick refer ence, Chapters 8
thr ough 36, which is a succinct but detailed API refer ence for matted for optimum
ease of use. Please be sure to read the How To Use This Quick Reference section,
which appears at the beginning of the refer ence section. It explains how to get the
most out of this book.
Related Books
O’Reilly & Associates publishes an entire series of books on Java programming.
These books include Java in a Nutshell and Java Enterprise in a Nutshell, which, as
mentioned earlier, are companions to this book.
A related refer ence work is the Java Power Reference. It is an electr onic Java quick
refer ence on CD-ROM that uses the Java in a Nutshell style. But since it is
designed for viewing in a web browser, it is fully hyperlinked and includes a pow-
er ful search engine. It is wider in scope but narrower in depth than the Java in a
Nutshell books. The Java Power Reference covers all the APIs of the Java 2 plat-
for m, plus the APIs of many standard extensions. But it does not include tutorial
chapters on the various APIs, nor does it include descriptions of the individual
classes.
You can ﬁnd a complete list of Java books from O’Reilly & Associates at
http://java.or eilly.com/. Books of particular interest to JFC programmers include
the following:
Java Swing, by Robert Eckstein, Marc Loy, and Dave Wood
A complete guide to the Swing graphical user interface toolkit.
Java 2D Graphics, by Jonathan Knudsen
A compr ehensive tutorial on the Java 2D API, from basic drawing techniques
to advanced image processing and font handling.
Java AWT Reference, by John Zukowski
A complete refer ence manual (not a quick refer ence like this book) to the
graphics and GUI features of the AWT. This book covers Java 1.0 and Java
1.1, and although some AWT features have been superseded by the Swing
x
Preface

and Java 2D APIs, the AWT is still the foundation for all graphics and graphi-
cal user interfaces in Java.
Exploring Java, by Pat Niemeyer and Joshua Peck
A compr ehensive tutorial introduction to Java, with an emphasis on client-side
Java programming.
Ja va Programming Resources Online
This book is a quick refer ence designed for speedy access to frequently needed
infor mation. It does not, and cannot, tell you everything you need to know about
the Java Foundation Classes. In addition to the books listed earlier, ther e ar e sev-
eral valuable (and free) electronic sources of information about Java programming.
Sun’s main web site for all things related to Java is http://java.sun.com/. The web
site speciﬁcally for Java developers is http://developer.java.sun.com/. Much of the
content on this developer site is password protected, and access to it requir es
(fr ee) registration.
Sun distributes electronic documentation for all Java classes and methods in its
javadoc HTML format. Although this documentation is rough or outdated in
places, it is still an excellent starting point when you need to know more about a
particular Java package, class, method, or ﬁeld. If you do not already have the
javadoc ﬁles with your Java distribution, see http://java.sun.com/docs/ for a link to
the latest available version.
Sun also distributes its excellent Java Tutorial online. You can browse and down-
load it from http://java.sun.com/docs/books/tutorial/. Developers who are using the
Swing GUI toolkit should read “The Swing Connection,” a periodically updated
online newsletter devoted to Swing programming. It contains news and useful
tutorial articles. You’ll ﬁnd it at http://java.sun.com/pr oducts/jfc/tsc/.
For Usenet discussion (in English) about Java, try the comp.lang.java.pr ogrammer
and related comp.lang.java.* newsgr oups. You can ﬁnd the very comprehensive
comp.lang.java.pr ogrammer FAQ by Peter van der Linden at http://www.afu.com/
javafaq.htm.
Finally, don’t forget O’Reilly’s Java web site. http://java.or eilly.com/ contains Java
news and commentary and a monthly tips-and-tricks column by O’Reilly Java
author Jonathan Knudsen.
Examples Online
The examples in this book are available online and can be downloaded from the
home page for the book at http://www.or eilly.com/catalog/jfcnut. You also may
want to visit this site to see if any important notes or errata about the book have
been published there.
Pr eface
xi

Conventions Used in This Book
We use the following formatting conventions in this book:
Italic
Used for emphasis and to signify the ﬁrst use of a term. Italic is also used for
commands, email addresses, web sites, FTP sites, ﬁle and directory names,
and newsgroups.
Bold
Occasionally used to refer to particular keys on a computer keyboard or to
portions of a user interface, such as the Back button or the Options menu.
Letter Gothic
Used in all Java code and generally for anything that you would type literally
when programming, including keywords, data types, constants, method
names, variables, class names, and interface names.
Letter Gothic Oblique
Used for the names of function arguments and generally as a placeholder to
indicate an item that should be replaced with an actual value in your pro-
gram.
Franklin Gothic Book Condensed
Used for the Java class synopses in the quick-refer ence section. This very nar-
row font allows us to ﬁt a lot of information on the page without a lot of dis-
tracting line breaks. This font is also used for code entities in the descriptions
in the quick-refer ence section.
Franklin Gothic Demi Condensed
Used for highlighting class, method, ﬁeld, property, and constructor names in
the quick-refer ence section, which makes it easier to scan the class synopses.
Franklin Gothic Book Compressed Italic
Used for method parameter names and comments in the quick-refer ence sec-
tion.
Request for Comments
Please help us to improve future editions of this book by reporting any errors,
inaccuracies, bugs, misleading or confusing statements, and even plain old typos
that you ﬁnd. Email your bug reports and comments to us at bookques-
tions@or eilly.com. Please also let us know what we can do to make this book
mor e useful to you. We take your comments seriously and will try to incorporate
reasonable suggestions into future editions.
Acknowledgments
This book is an outgrowth of the best-selling Java in a Nutshell. I’d like to thank
all the readers who made that book a success and who wrote in with comments,
suggestions, and praise.
xii Preface

The editor of this book, and of Java in a Nutshell befor e it, was Paula Ferguson.
As usual, she’s done a great job of keeping me on topic and made her best effort
to keep me on schedule! Her careful and thoughtful editing has made this book a
better one. Thanks, Paula.
This book had a number of high-powered technical reviewers. Jeanette Hung, of
Sun Microsystems; Doug Felt and John Raley, both of IBM; and Jonathan Knudsen,
author of O’Reilly’s Java 2D Graphics, reviewed the Java 2D class descriptions.
Jonathan also reviewed the Java 2D-related chapters. Marc Loy, coauthor of
O’Reilly’s Java Swing and course developer and technical trainer at Galileo Sys-
tems, LLC, reviewed all of the Swing-related material. This book is made much
str onger by the valuable contributions of these reviewers. I alone must take
responsibility for any errors that remain, of course.
The O’Reilly & Associates production team has done its usual ﬁne work of creating
a book out of the electronic ﬁles I submit. My thanks to them all. And a special
thanks to Lenny Muellner and Chris Maden, who worked overtime to implement
the new and improved format of the quick-refer ence section.
Finally, as always, my thanks and love to my partner Christie.
David Flanagan
http://www.davidﬂanagan.com
June 1999
Pr eface
xiii


PART I
Introducing the
Ja va Foundation Classes
Part I is an introduction to the key APIs that comprise the Java Foundation
Classes. These chapters provide enough information for you to get started
using these APIs right away.
Chapter 1, The Java Foundation Classes
Chapter 2, Swing and AWT Architectur e
Chapter 3, Swing Programming Topics
Chapter 4, Graphics with AWT and Java 2D
Chapter 5, Printing
Chapter 6, Data Transfer
Chapter 7, Applets


CHAPTER 1
The Java Foundation Classes
The Java Foundation Classes, or JFC, is a loose collection of standard Java APIs for
client-side graphics, graphical user interfaces (GUIs), and related programming
tasks. They are foundation classes in the sense that most client-side Java applica-
tions are built upon these APIs. This book covers the following APIs:
AWT
Although the most powerful and exciting features of the JFC were intr oduced
in Version 1.2 of the Java 2 platform, the JFC also includes the graphics and
GUI features of Java 1.0 and Java 1.1. These features are provided by the
Abstract Windowing Toolkit (AWT). The graphics and GUI capabilities of the
AWT are rudimentary, and many of them have been superseded by more
advanced features in Java 1.2. Nevertheless, the AWT is the bedrock upon
which more advanced JFC functionality is built.
In addition, there are certain situations in which you cannot take advantage of
the new JFC functionality and must instead rely solely on the AWT. For exam-
ple, common web browsers do not yet support Swing, so if you are writing
applets, you have to use the AWT. Because of this, the graphics and GUI APIs
of the AWT are discussed right along with the more power ful APIs introduced
in Java 1.2.
Swing
Swing is an advanced GUI toolkit written in pure Java. It is built upon the
AWT but provides many new GUI components and useful GUI-related appli-
cation services.
Swing offers a pluggable look-and-feel architectur e that
allows an application to be trivially conﬁgured either to display a platform-
independent Java look-and-feel or to mimic the look-and-feel of the native
operating system. Swing also includes an accessibility API that enables the
use of assistive technologies, such as screen readers or screen magniﬁers for
the vision impaired. Many features of Swing are based on the pioneering
design of the Netscape Internet Foundation Classes.
JFC
3

Swing is a core part of the Java 2 platform. It is also available, however, as an
extension to Java 1.1.
Java 2D
Java 2D is the name for the state-of-the-art two-dimensional graphics API
intr oduced in Java 1.2. Java 2D is built upon the AWT, but greatly expands on
the graphics capabilities that were available in Java 1.0 and Java 1.1. Java 2D
includes support for resolution independence, rotation, scaling and shearing
of arbitrary graphics, antialiasing of text and graphics, alpha transparency,
color compositing, and the use of the full range of fonts installed on the
native system.
Printing
The ability to print text and graphics on a page is almost as important as the
ability to draw text and graphics on the screen. Java 1.1 introduced simple
printing capabilities as part of the AWT, and Java 1.2 includes a more power-
ful printing API as part of the JFC. This book describes both printing APIs.
Data transfer
An important feature of many client-side applications is the ability to allow
user-dir ected data transfer within the application and between unrelated
applications. There are two commonly used data transfer metaphors: cut-and-
paste and drag-and-drop. Java 1.1 deﬁned a basic data transfer framework and
pr ovided an API for cut-and-paste. Java 1.2 adds support for data transfer
using the drag-and-drop metaphor.
Applets
The applet API allows a client-side program to run as an applet, or mini-appli-
cation, within a web browser or some other form of applet viewer. Techni-
cally, the applet API is not part of the JFC, but it is a crucial piece of the
client-side Java programming picture and is included in this book.
The rest of the chapters in Part I describe these APIs in far more detail. Read
Chapter 2, Swing and AWT Architectur e, ﬁrst. After reading that chapter, you can
read the remaining chapters in whatever order you prefer. The goal of each chap-
ter is to introduce an API in enough detail so that you can begin to use it in your
pr ograms. While reading a chapter, you may ﬁnd it helpful to refer to the quick-
refer ence material in Part II of this book to ﬁnd detailed API information on the
individual classes you are reading about.
4
Chapter 1 – The Java Foundation Classes

CHAPTER 2
Swing and AWT
Ar chitecture
The Abstract Windowing Toolkit (AWT) provides basic facilities for creating graphi-
cal user interfaces (GUIs), and also for drawing graphics, as we’ll discuss in a later
chapter. AWT has been a core part of Java since Java 1.0. The GUI features of AWT
ar e layer ed on top of the native GUI system of the underlying platform. In other
words, when you create a graphical push button with AWT, AWT creates a Win-
dows push button, or a Macintosh push button, or a Motif push button, or what-
ever, depending on the platform on which the application is running. In Java 1.1,
AWT was extended to allow the creation of “lightweight” GUI components that do
not have corresponding native GUI components behind them.
Swing is a new GUI toolkit that is available as a core part of the Java 2 platform
and also as an extension to Java 1.1. Swing is an extension of the AWT toolkit, not
an entirely new toolkit. All of the GUI components provided by Swing are
lightweight components, so they do not rely on the underlying native GUIs. The
result is that Swing is more portable, making it much easier to write graphical
applications that behave the same on all platforms. Swing is also larger and more
compr ehensive than AWT. In addition to a complete and powerful set of GUI com-
ponents, Swing provides a number of utilities that make it easier to write graphical
applications.
Swing offers a great step forward when compared to AWT. You should use Swing
in all your Java 2 applications. You should also seriously consider using it as an
extension for Java 1.1 applications. Unfortunately, at the time of this writing, com-
mon web browsers do not yet support Swing, so if you are writing applets, you
should either run those applets under the Java Plug-in, or you should avoid the
use of Swing and rely exclusively on the features of AWT. See Chapter 7, Applets,
for more infor mation on applets.
This chapter introduces the basic architectur e used by both AWT and Swing. For
mor e infor mation on Swing and AWT, see Java Swing, by Robert Eckstein, Marc
Loy, and Dave Wood (O’Reilly), and Java AWT Reference, by John Zukowski
(O’Reilly), respectively.
Swing/AWT
Architecture
5

A Simple Graphical User Interface
Example 2-1 is a simple program that uses Swing to create and display a graphical
user interface. Figure 2-1 shows the GUI created by this program.
Figur e 2−1: The GUI of the DisplayMessage program
The DisplayMessage pr ogram is designed for use in a shell script or batch ﬁle.* If
you invoke the program on the command line with the text of a question, it dis-
plays the question to the user and waits for the user to click the Yes button or the
No button. The program sets its exit code based on the user’s response, so a shell
script can examine this exit code to determine how the user responded. The pro-
gram expects from one to three command-line arguments that specify the text of
the question and the text for the “Yes” and “No” buttons, respectively. For exam-
ple, you might invoke the program like this:
% java DisplayMessage "Do you really want to quit?" "Yes, Please", "No, Thanks"
The example illustrates step-by-step how to create a Swing GUI. Don’t worry if
you don’t understand the details of this program yet. If you read it through once
now to get the big picture, you can refer back to it as you read the sections that
follow.
Example 2−1: Cr eating a Simple GUI with Swing
import java.awt.*;
// AWT classes
import javax.swing.*;
// Swing components and classes
import javax.swing.border.*;
// Borders for Swing components
import java.awt.event.*;
// Basic event handling
public class DisplayMessage {
public static void main(String[] args) {
/*
* Step 1: Create the components
*/
JLabel msgLabel = new JLabel();
// Component to display the question
JButton yesButton = new JButton();
// Button for an affirmative response
JButton noButton = new JButton();
// Button for a negative response
/*
* Step 2: Set properties of the components
*/
msgLabel.setText(args[0]); 
// The msg to display
* Because the Java Virtual Machine takes a long time to start up, it is not actually practical to use this pro-
gram in a shell script. It is a useful example nevertheless.
6
Chapter 2 – Swing and AWT Architectur e

Example 2−1: Cr eating a Simple GUI with Swing (continued)
msgLabel.setBorder(new EmptyBorder(10,10,10,10));
// A 10-pixel margin
yesButton.setText((args.length >= 2)?args[1]:"Yes"); // Text for yes button
noButton.setText((args.length >= 3)?args[2]:"No");
// Text for no button
/*
* Step 3: Create containers to hold the components
*/
JFrame win = new JFrame("Message");
// The main application window
JPanel buttonbox = new JPanel();
// A container for the two buttons
/*
* Step 4: Specify LayoutManagers to arrange components in the containers
*/
win.getContentPane().setLayout(new BorderLayout()); // Layout on borders
buttonbox.setLayout(new FlowLayout());
// Layout left-to-right
/*
* Step 5: Add components to containers, with optional layout constraints
*/
buttonbox.add(yesButton); 
// Add yes button to the panel
buttonbox.add(noButton); 
// Add no button to the panel
// add JLabel to window, telling the BorderLayout to put it in the middle
win.getContentPane().add(msgLabel, "Center");
// add panel to window, telling the BorderLayout to put it at the bottom
win.getContentPane().add(buttonbox, "South");
/*
* Step 6: Arrange to handle events in the user interface
*/
yesButton.addActionListener(new ActionListener() {
// Note: inner class
// This method is called when the Yes button is clicked
public void actionPerformed(ActionEvent e) { System.exit(0); }
});
noButton.addActionListener(new ActionListener() {
// Note: inner class
// This method is called when the No button is clicked
public void actionPerformed(ActionEvent e) { System.exit(1); }
});
/*
* Step 7: Display the GUI to the user
*/
win.pack(); 
// Set the size of the window based on its children's sizes
win.show(); 
// Make the window visible
}
}
Components
A graphical user interface is composed of individual building blocks such as push
buttons, scrollbars, and pull-down menus. Some programmers know these individ-
ual building blocks as controls, while others call them widgets. In Java, they are
typically called components because they all inherit from the base class
java.awt.Component.
Swing/AWT
Architecture
Components 7

When you are describing a GUI toolkit, one of the most important characteristics is
the list of components it supports. Table 2-1 lists the heavyweight components
pr ovided by AWT, wher e heavyweight refers to components that are layer ed on
top of native GUI components. The components listed are all classes in the
java.awt package. One of the curious features of the AWT is that pull-down and
pop-up menus, and the items contained within those menus, are not technically
components. Instead of inheriting from Component, they inherit from java.awt.-
MenuComponent. Nevertheless, the various menu component classes are used in
very much the same way that true components are, so I have included them in
Table 2-1.
Table 2−1: Heavyweight AWT Components
Component Name
Description
Button
A graphical push button.
Canvas
A heavyweight component that displays a blank canvas,
allowing a program to display custom graphics.
Checkbox
A toggle button that can be selected or unselected. Use the
Checkbox gr oup to enforce mutually exclusive or radio
button behavior among a group of Checkbox components.
CheckboxMenuItem
A toggle button that can appear within a Menu.
Choice
An option menu or drop-down list. Displays a menu of
options when clicked on and allows the user to select
among this ﬁxed set of options.
Component
The base class for all AWT and Swing components.
Deﬁnes many basic methods inherited by all components.
FileDialog
Allows the user to browse the ﬁlesystem and select or
enter a ﬁlename.
Label
Displays a single line of read-only text. Does not respond
to user input in any way.
List
Displays a list of choices (optionally scrollable) to the user
and allows the user to select one or more of them.
Menu
A single pane of a pull-down menu
MenuBar
A horizontal bar that contains pull-down menus.
MenuComponent
The base class from which all menu-related classes inherit.
MenuItem
A single item within a pull-down or pop-up menu pane.
PopUpMenu
A menu pane for a pop-up menu.
Scrollbar
A graphical scrollbar.
TextArea
Displays multiple lines of plain text and allows the user to
edit the text.
TextComponent
The base class for both TextArea and TextField.
TextField
Displays a single line of plain text and allows the user to
edit the text.
8
Chapter 2 – Swing and AWT Architectur e

Table 2-2 lists the components provided by Swing. By convention, the names of
these components all begin with the letter J. You’ll notice that except for this J pre-
ﬁx, many Swing components have the same names as AWT components. These
ar e designed to be replacements for the corresponding AWT components. For
example, the lightweight Swing components JButton and JTextField replace the
heavyweight AWT components Button and TextField. In addition, Swing deﬁnes
a number of components, some quite powerful, that are simply not available
in AWT.
Swing components are all part of the javax.swing package. Despite the javax
package preﬁx, Swing is a core part of the Java 2 platform, not a standard exten-
sion. Swing can be used as an extension to Java 1.1, however. All Swing compo-
nents inherit from the javax.swing.JComponent class. JComponent itself inherits
fr om the java.awt.Component class, which means that all Swing components are
also AWT components. Unlike most AWT components, however, Swing compo-
nents do not have a native “peer” object and are ther efor e “lightweight” compo-
nents, at least when compared to the AWT components they replace. Finally, note
that menus and menu components are no dif ferent than any other type of compo-
nent in Swing; they do not form a distinct class hierarchy as they do in AWT.
Table 2−2: GUI Components of Swing
Component Name
Description
JButton
A push button that can display text, images, or both.
JCheckBox
A toggle button for displaying choices that are not
mutually exclusive.
JCheckBoxMenuItem
A checkbox designed for use in menus.
JColorChooser
A complex, customizable component that allows the
user to select a color from one or more color spaces.
Used in conjunction with the
javax.swing.colorchooser package.
JComboBox
A combination of a text entry ﬁeld and a drop-down
list of choices. The user can type a selection or choose
one from the list.
JComponent
The root of the Swing component hierarchy. Adds
Swing-speciﬁc features such as tooltips and support for
double-buf fering.
JEditorPane
A power ful text editor, customizable via an EditorKit
object. Predeﬁned editor kits exist for displaying and
editing HTML- and RTF-for mat text.
JFileChooser
A complex component that allows the user to select a
ﬁle or directory. Supports ﬁltering and optional ﬁle
pr eviews. Used in conjunction with the
javax.swing.filechooser package.
JLabel
A simple component that displays text, an image, or
both. Does not respond to input.
Swing/AWT
Architecture
Components 9

Table 2−2: GUI Components of Swing (continued)
Component Name
Description
JList
A component that displays a selectable list of choices.
The choices are usually strings or images, but arbitrary
objects may also be displayed.
JMenu
A pull-down menu in a JMenuBar or a submenu within
another menu.
JMenuBar
A component that displays a set of pull-down menus.
JMenuItem
A selectable item within a menu.
JOptionPane
A complex component suitable for displaying simple
dialog boxes. Deﬁnes useful static methods for
displaying common dialog types.
JPasswordField
A text input ﬁeld for sensitive data, such as passwords.
For security, does not display the text as it is typed.
JPopupMenu
A window that pops up to display a menu. Used by
JMenu and for standalone pop-up menus.
JProgressBar
A component that displays the progr ess of a time-
consuming operation.
JRadioButton
A toggle button for displaying mutually exclusive
choices.
JRadioButtonMenuItem
A radio button for use in menus.
JScrollBar
A horizontal or vertical scrollbar.
JSeparator
A simple component that draws a horizontal or vertical
line. Used to visually divide complex interfaces into
sections.
JSlider
A component that simulates a slider control like those
found on stereo equalizers. Allows the user to select a
numeric value by dragging a knob. Can display tick
marks and labels.
JTable
A complex and powerful component for displaying
tables and editing their contents. Typically used to
display strings but may be customized to display any
type of data. Used in conjunction with the
javax.swing.table package.
JTextArea
A component for displaying and editing multiple lines
of plain text. Based on JTextComponent.
JTextComponent
The root component of a powerful and highly
customizable text display and editing system. Part of
the javax.swing.text package.
JTextField
A component for the display, input, and editing of a
single line of plain text. Based on JTextComponent.
10 Chapter 2 – Swing and AWT Architectur e

Table 2−2: GUI Components of Swing (continued)
Component Name
Description
JTextPane
A subclass of JEditorPane for displaying and editing
for matted text that is not in HTML or RTF format.
Suitable for adding simple word processing
functionality to an application.
JToggleButton
The parent component of both JCheckBox and
JRadioButton.
JToolBar
A component that displays a set of user-selectable
tools or actions.
JToolTip
A lightweight pop-up window that displays simple
documentation or tips when the mouse pointer lingers
over a component.
JTree
A power ful component for the display of tree-
structur ed data. Data values are typically strings, but
the component can be customized to display any kind
of data. Used in conjunction with the
javax.swing.tree package.
Proper ties
Every AWT and Swing component can have its appearance and behavior cus-
tomized by specifying values for its pr operties. In Example 2-1, we set the text
pr operty of the JButton components by calling the setText() method and the
border pr operty of the JLabel by calling setBorder().
The properties of a component are not a formal part of a Java class, in the way
that the ﬁelds and methods of a class are. Instead, the notion of properties is
mer ely a naming convention adopted from the JavaBeans component framework.
When a component deﬁnes a pair of public accessor methods whose names begin
with “set” and “get”, this pair of methods deﬁnes a property. For example, the
methods setFont() and getFont() deﬁne the font pr operty of a component.
When a property is of type boolean, the “get” accessor method is often replaced
with one that begins with “is”. For example, the setVisible() and isVisible()
methods deﬁne the visible pr operty.
Although any given component may deﬁne only a few properties of its own, every
component inherits the properties of its superclasses. If you refer to the refer ence
pages for JComponent, Component, and MenuComponent, you’ll see that there are
quite a few of these inherited properties.
Thinking about GUI components in terms of the properties they deﬁne and the
pr operties they inherit is useful because it conveniently sums up the customizable
state of the component. Looking at a list of component properties tells you a lot
Swing/AWT
Architecture
Pr operties
11

about what you can do with the component. This is so useful, in fact, that the ref-
er ence section of this book groups property accessor methods separately from
other methods.
Container s and Containment
Table 2-1 and Table 2-2 listed the GUI components available in the AWT and
Swing toolkits. In order to create a graphical user interface, however, these indi-
vidual components must be arranged within some kind of container. A container
is a component that can contain other components. All containers inherit from the
java.awt.Container base class, which itself inherits from java.awt.Component.
Main application windows and dialog boxes are commonly used containers. Each
pr ovides a window within which GUI components can be arranged to create a
user interface. A graphical application does not usually arrange all its components
dir ectly within a window or dialog box, however. Instead, an application typically
uses containers nested within other containers. For example, a dialog box that
contains two columns of text input ﬁelds above a row of push buttons might use
thr ee separate containers, one for each column of text ﬁelds and one for the row
of push buttons. Then the dialog box container contains only these three contain-
ers, instead of the full set of text ﬁelds and push buttons.
Some kinds of containers display their children in very speciﬁc ways, while others
have restrictions on the number or type of components they can display. Some
other containers are generic, so they can contain any number of children, arranged
in any way. A generic container uses a layout manager to specify how its children
should be arranged (as we’ll discuss in the next section).
Table 2-3 lists the containers provided by AWT (in the java.awt package), and
Table 2-4 lists the additional containers provided by Swing (in javax.swing).
Menus and menu bars, such as javax.swing.JMenuBar and javax.swing.JPopup-
Menu, are containers. Because of their highly specialized use, however, I have
listed them in the earlier tables of components. Also, the JComponent class extends
java.awt.Container, which means that all Swing components are actually contain-
ers. In practice, however, they are not used this way; only the Swing classes listed
in Table 2-4 are typically used as containers.
Table 2−3: AWT Containers
Container 
Description
Applet
This subclass of Panel is actually part of the java.applet
package. It is the base class for all applets. (See Chapter 7.)
Container
The base class from which all containers inherit.
Dialog
A window suitable for dialog boxes.
Frame
A window suitable for use as the main window of an application.
In AWT, Frame is the only container that can contain a MenuBar
and related menu components.
Panel
A generic container used to create nested layouts.
12 Chapter 2 – Swing and AWT Architectur e

Table 2−3: AWT Containers (continued)
Container 
Description
ScrollPane
A container that contains a single child and allows that child to be
scr olled vertically and horizontally.
Window
A heavyweight window with no titlebar or other decoration,
suitable for pop-up menus and similar uses.
Table 2−4: Swing Containers
Container 
Description
Box
A general-purpose container that arranges children using the
BoxLayout layout manager.
JApplet
A java.applet.Applet subclass that contains a JRootPane to
add Swing features, such as support for menu bars to applets.
Applets are discussed in Chapter 7.
JDesktopPane
A container for JInternalFrame components; simulates the
operation of a desktop within a single window. Supports MDI
(multiple document interface) application styles.
JDialog
The container used to display dialog boxes in Swing.
JFrame
The container used for top-level windows in Swing.
JInternalFrame
A lightweight nested window container. Behaves like a
JFrame and displays a titlebar and resize handles but is not an
independent window and is constrained to appear within the
bounds of its parent container. Often used with JDesktopPane.
JLayeredPane
A container that allows its children to overlap and manages
the stacking order of those children.
JPanel
A generic container for grouping Swing components. Typically
used with an appropriate LayoutManager.
JRootPane
A complex container used internally by JApplet, JDialog,
JFrame, JInternalFrame, and JWindow. Provides a number of
important Swing capabilities to these top-level containers.
JScrollPane
A container that allows a single child component to be
scr olled horizontally or vertically. Supports scrolling and non-
scr olling header regions at the top and left of the scrolling
region.
JSplitPane
A container that displays two children by splitting itself
horizontally or vertically. Allows the user to adjust the amount
of space allocated to each child.
JTabbedPane
A container that displays one child at a time, allowing the user
to select the currently displayed child by clicking on tabs like
those found on manila ﬁle folders.
Swing/AWT
Architecture
Containers and Containment
13

Table 2−4: Swing Containers (continued)
Container 
Description
JViewport
A ﬁxed-size container that displays a portion of a single larger
child. Typically used as part of a JScrollPane.
JWindow
A top-level Swing window that does not display a titlebar,
resize handles, or any other decorations.
When building a graphical user interface, you must create your components, cre-
ate the containers that will hold those components, and then add the components
to the containers. You do this with one of the add() methods deﬁned by
java.awt.Container. In its simplest form, this process looks like this:
JButton b = new JButton("Push Me");
JPanel p = new JPanel();
p.add(b);
Ther e ar e other versions of the add() method as well. In addition to specifying the
component to add, you may also specify a string or an object as a constraint. The
container may use this constraint object as a hint that tells it how the component
should be arranged in the container. In practice, containers do not use the con-
straint directly, but pass it on to a layout manager, as we’ll discuss shortly.
In Swing, the top-level containers JFrame, JDialog, JInternalFrame, JWindow, and
JApplet ar e used slightly differ ently than containers such as JPanel, JSplitPane,
and JTabbedPane.
I’ve said that all Swing components extend JComponent. JFrame, JInternalFrame,
JDialog, JWindow, and JApplet ar e actually exceptions to this rule. These top-level
Swing containers extend their corresponding AWT containers: Frame, Dialog, Win-
dow, and java.applet.Applet. Because these container classes do not extend
JComponent, they do not inherit the Swing-speciﬁc features of JComponent.
Instead, when you create a JFrame, JInternalFrame, JDialog, JWindow, or JApplet
container, the container automatically creates a single child for itself. The child is a
JRootPane container. JRootPane does extend JComponent, and it is this automati-
cally created JRootPane that will hold all of the components that are placed in the
container. You cannot add children directly to the top-level container. Instead, you
add them to the content pane of the JRootPane. All Swing containers that use a
JRootPane implement the RootPaneContainer inter face. This interface deﬁnes the
getContentPane() method, which retur ns the container that you should use. This
is not as confusing as it sounds. In practice, your code looks like this:
JButton b = new JButton("Press Me");
// Create a button
JFrame f = new JFrame("Test Application");
// Create a window to display it
f.getContentPane().add(b); 
// Add the button to the window
By default, getContentPane() retur ns a JPanel container, but you can override this
default by creating a container of your own and passing it to setContentPane().
The JRootPane container is a complex one; it contains a number of children in
addition to the content pane container. These children support features such as
pop-up menus and are primarily for internal use by Swing. One notable and
14 Chapter 2 – Swing and AWT Architectur e

commonly used feature of JRootPane, however, is that it displays a JMenuBar
passed to its setJMenuBar() method. (In AWT, you specify a MenuBar for a Frame
by calling the setMenuBar() method of Frame.)
Layout Management
Some containers, such as
JTabbedPane and
JSplitPane, deﬁne a particular
arrangement for their children. Other containers such as JPanel (and JFrame, JDi-
alog, and other top-level containers that use JPanel as their default content pane)
do not deﬁne any particular arrangement. When working with containers of this
type, you must specify a LayoutManager object to arrange the children within the
container.
AWT and Swing include various implementations of the java.awt.LayoutManager
inter face. Each arranges components in a differ ent way. Table 2-5 lists the layout
managers deﬁned by AWT. Swing applications often rely on these AWT layout
managers, but Swing also deﬁnes some of its own, which are listed in Table 2-6.
Figur e 2-2 shows how some of these layout managers arrange their children.
Table 2−5: AWT Layout Managers
Layout Manager
Description
BorderLayout
Lays out a maximum of ﬁve components: one along each of
the four borders of the container and one in the center. When
using this layout manager, you must add components to the
container using a two-argument version of the add() method.
The constraint argument should be one of the strings “North”,
“East”, “South”, “West”, or “Center”. Despite the simplicity of
this layout system, this layout manager is used quite often.
CardLayout
Makes each component as large as the container and displays
only one at a time. Various methods change the currently
displayed component.
FlowLayout
Arranges components like words on a page: from left to right
in rows and then top to bottom as each row ﬁlls up. Rows
may be left, center, or right justiﬁed.
GridBagLayout
A ﬂexible layout manager that arranges components in a grid
with variable-sized cells. Allows explicit control over the way
each component is resized when the container changes size.
Requir es a complex constraints set speciﬁed with the
GridBagConstraints object.
GridLayout
Makes all components the same size and arranges them in a
grid of speciﬁed dimensions.
Swing/AWT
Architecture
Layout Management
15

BorderLayout
GridLayout
GridBagLayout
FlowLayout
Figur e 2−2: Layout managers
Table 2−6: Swing Layout Managers
Layout Manager
Description
BoxLayout
The layout manager used by the Box container. It arranges
its children into either a row or a column. It uses the glue
and strut components retur ned by static Box methods to
display stretchy and rigid spaces between the children.
OverlayLayout
An obscure and infrequently used layout manager that
overlaps its children based on the children’s alignment
values speciﬁed with the setAlignmentX() and
setAlignmentY() methods inherited from JComponent.
Used by AbstractButton.
ScrollPaneLayout
A specialized layout manager used by JScrollPane. Not
typically useful for general-purpose layouts.
ViewportLayout
A specialized layout manager used by JViewport. Not
useful for general-purpose layouts.
16 Chapter 2 – Swing and AWT Architectur e

Some layout managers requir e additional information about the components they
ar e to arrange. This information takes the form of a constraint string or constraint
object passed to the add() method when the component is added to its container.
java.awt.BorderLayout is the most commonly used of these layout managers: its
constraint object is a string that speciﬁes where the child should be positioned
within the container. Example 2-1 showed a typical use of BorderLayout.
Every AWT and Swing container has a default layout manager. If you explicitly set
the layout manager to null, however, you can arrange your components using
hardcoded sizes and positions. Set the size and position with methods such as
setSize() and setLocation(). However, hardcoding the layout of your compo-
nents makes your GUI less portable, harder to customize, and harder to translate
into other languages.
Event Handling
Using a layout manager to arrange components within a container may result in a
GUI that looks good, but in order to make it do anything, you have to handle
events. An event typically signiﬁes an action by the user, such as striking a key or
clicking the mouse over a JButton component. But it can also refer to any other
action perfor med by the user or the program. An event can be generated when
the value of component’s property changes or when a speciﬁed amount of time
elapses, for example.
The event model used in Java changed between Java 1.0 and Java 1.1. The Java
1.1 event model is used by AWT and Swing in Java 1.1 and Java 1.2. The Java 1.0
event model is largely obsolete; we’ll discuss it in Chapter 7, Applets, however,
since some web browsers still only support Java 1.0.
Event Objects
Dif ferent types of events are repr esented by differ ent Java classes. The base class,
fr om which all events inherit, is java.util.EventObject. AWT deﬁnes its own
base class for GUI events, java.awt.AWTEvent, which is subclassed from EventOb-
ject. AWT then deﬁnes a number of subclasses of AWTEvent in the package
java.awt.event. Swing uses many of these event types and also deﬁnes more of
its own in the javax.swing.event package. Some Swing events subclass AWT
events, but many subclass java.util.EventObject dir ectly. Ther e is one other
kind of event used by Swing components: the java.beans.PropertyChangeEvent,
which is part of the JavaBeans component model.
The base EventObject class deﬁnes a getSource() method that retur ns the object
that generated or triggered the event. AWTEvent deﬁnes the getID() method; the
value retur ned by this method is used to distinguish the various types of events
that are repr esented by the same event class. For example, FocusEvent has two
possible types: FocusEvent.FOCUS_GAINED and FocusEvent.FOCUS_LOST.
In addition to these getSource() and getID() methods, the various event sub-
classes deﬁne methods to retur n whatever data values are pertinent to the particu-
lar event type. For example, MouseEvent has getX(), getY(), and getClickCount()
Swing/AWT
Architecture
Event Handling
17

methods; it also inherits the getModifiers() and getWhen() methods, among oth-
ers, from its superclass InputEvent. Thus, when the user clicks the mouse, you
receive a MouseEvent that speciﬁes where, when, and how many times the user
clicked, along with other information, such as the set of keyboard modiﬁer keys
that were held down at the time.
Event Listeners
An object that would like to be notiﬁed of and respond to an event is an event lis-
tener. An object that generates a particular kind of event, called an event source,
maintains a list of listeners that are inter ested in being notiﬁed when that kind of
event occurs. The event source provides methods that allow listeners to add and
remove themselves from this list of interested objects. When the event source gen-
erates an event (or when a user input event such as a mouse click or a key press
occurs on the event source object), the event source notiﬁes all the listener objects
that the event has occurred.
All AWT and Swing components are event sources, and all of them deﬁne (or
inherit) methods for adding and removing event listeners. By convention, these
methods have names that begin with “add” or “remove” and end with “Listener”.
So, for example, the JButton class inherits the addActionListener() and remove-
ActionListener() methods. In the refer ence section of this book, you’ll notice
that the event registration methods of a component are grouped separately, just as
the property accessor methods are. This is because one of the most important
things you need to know about a component is the list of event types that it can
generate.
Each type of event object typically has a corresponding event listener type. The
ActionEvent event type has an ActionListener listener type, for example. Event
listeners, such as ActionListener, are inter faces that extend java.util.EventLis-
tener. EventListener doesn’t deﬁne any methods; it is merely a marker interface
that gives all event listeners a common type. An event listener interface deﬁnes
one or more methods that an event source may invoke when a particular type of
event occurs. Such a method always takes an event object as its single argument.
For example, the ActionListener inter face deﬁnes a single method, actionPer-
formed(). When the user clicks on a JButton component, an ActionEvent repr e-
senting that click is created and passed to the actionPerformed() method of each
ActionListener object that was register ed on the JButton with the addAction-
Listener() method.
An event listener interface may deﬁne more than one method. For example,
MouseListener deﬁnes several methods that correspond to differ ent types of
mouse events, including button press events and button release events. This is
because MouseEvent repr esents several differ ent types of mouse events. By con-
vention, each method of an event listener is passed a single argument that is an
event object of the type that corresponds to the listener. Thus, a MouseEvent object
is always created when a mouse event occurs, but the object is passed to a differ-
ent listener method depending on the type of mouse event that occurred.
18 Chapter 2 – Swing and AWT Architectur e

Event Adapters
When an event listener interface deﬁnes more than one method, it is often accom-
panied by an event adapter class that provides empty implementations for each of
the methods. For example, the MouseListener inter face deﬁnes ﬁve differ ent
methods. If your program is interested only in the mouseClicked() method, it may
be easier for you to subclass the MouseAdapter class and override mouseClicked()
than to implement all ﬁve methods of the MouseListener inter face dir ectly.
Event Handling with Inner Classes
An important point to notice about the Java event handling model is that, in order
to receive an event notiﬁcation, you must implement an appropriate event listener
inter face. Sometimes you do this directly in your main application class. For exam-
ple, an object interested in action and focus events might simply implement
ActionListener and FocusListener dir ectly.
However, it is also quite common to create special classes for the sole purpose of
handling events. This is usually done with inner classes, as we saw in Example
2-1. With this event-handling paradigm, you create a simple inner class to handle
each event type that you are inter ested in for a particular event source. Your code
might look like this:
JFrame window = new JFrame("test application");
window.addFocusListener(new FocusListener() {
public void focusGained(FocusEvent e) { /* gain focus code here */ }
public void focusLost(FocusEvent e) {
/* lose focus code here */ }
});
You can also use this approach with an event adapter class, instead of an event lis-
tener interface. For example:
Panel panel = new Panel();
panel.addMouseListener(new MouseAdapter() {
public void mouseClicked(MouseEvent e) { /* mouse click code here */ }
});
Handling Input Events Directly
Certain types of events occur as a direct result of user input. When the user types
a key or moves the mouse, for example, a KeyEvent or MouseEvent is generated.
Similarly, when the user resizes a window or transfers keyboard focus to a new
component, a FocusEvent or ComponentEvent is generated. These types of events
repr esent event notiﬁcations generated by the underlying native windowing sys-
tem or operating system. Other types of events, such as ActionEvent and Popup-
MenuEvent, do not originate in the native windowing system. Instead, these events
ar e generated directly by AWT and Swing components.
The distinction between these types of events becomes more clear when you
implement a component yourself. Consider the JButton component, for example.
It receives MouseEvent events and generates ActionEvent events in response to
them. For a component like this, it is not particularly appropriate or efﬁcient to
use a MouseListener object to receive mouse events.
Swing/AWT
Architecture
Event Handling
19

The Java event model provides a low-level way to handle input events that origi-
nate in the underlying windowing system. When such an event occurs, it is passed
to the processEvent() method of the Component on which it occurs. This method
examines the type of event and invokes an appropriate method to handle the
event. These methods are: processMouseEvent(), processMouseMotionEvent(),
processKeyEvent(), processFocusEvent(), processComponentEvent(), and pro-
cessInputMethodEvent(). By default, each method simply invokes the appropriate
methods on the appropriate event listeners. When you subclass a component,
however, you can override any of these protected methods to perfor m any other
type of event handling you desire. When you override one of these methods, you
should usually remember to invoke the superclass method as well, so that the
appr opriate event listeners are notiﬁed.
Ther e is one additional requir ement to make this low-level Java 1.1 event model
work. In order to receive events of a particular type for a particular component,
you must tell the component that it is interested in receiving that type of event. If
you do not, events of that type are simply not delivered to the component, at least
on some operating systems. With event listeners, the act of registering a listener is
suf ﬁcient to tell the component what kinds of events it should request. However,
when you are using the processXXXEvent() methods directly, you must ﬁrst call
another protected method, enableEvents(), and pass in a bit mask that speciﬁes
the types of events you are inter ested in. The bit mask is formed by ORing
together various EVENT_MASK constants that are deﬁned by java.awt.AWTEvent. For
example:
this.enableEvents(AWTEvent.MOUSE_EVENT_MASK | AWTEvent.KEY_EVENT_MASK);
Event Reference
AWT and Swing deﬁne quite a few event objects, event listeners, and event
adapters in the java.awt.event and javax.swing.event packages. Fortunately, all
these classes and interfaces follow the same basic naming conventions. For an
event X, the event object is named XEvent, the listener interface is XListener, and
the adapter, if one is deﬁned is XAdapter. The event listener interface deﬁnes
methods that vary by event type, but every event listener method retur ns void and
accepts the corresponding event object as its single argument. The only signiﬁcant
variation from these rules is that the java.awt.MouseListener and java.awt.-
MouseMotionListener listeners both work with MouseEvent events — there is no
separate MouseMotionEvent.
You can ﬁnd a list of the events generated by any given component by turning to
its refer ence page and looking at the event listener registration methods for that
component. Remember, too, that the component may also inherit events. Table 2-7
and Table 2-8 work in the opposite direction. For a given event listener type, these
tables list the components that can generate events of that type. (Note, however,
that they do not list classes that inherit events of that type.) These tables also list
the names of the methods deﬁned by each event listener interface. You can learn a
lot about the intended usage of an event simply by looking at the list of listener
methods to which it can be passed.
20 Chapter 2 – Swing and AWT Architectur e

Table 2-7 shows the event listeners deﬁned by AWT. These event types are not
restricted to AWT components; Swing components use them too, as do some other
Swing classes that are not components. Table 2-8 displays the event listeners
deﬁned by Swing. Note that I have also added two event listeners deﬁned in the
java.beans package, but used by Swing components, to this table.
Table 2−7: AWT Event Listeners and the Components That Use Them
Event Listener
Listener Methods
Register ed on
ActionListener
actionPerformed()
AbstractButton, Button,
ButtonModel,
ComboBoxEditor,
JComboBox,
JFileChooser,
JTextField, List,
MenuItem, TextField,
Timer
AdjustmentListener
adjustmentValue-
Adjustable,
Changed()
JScrollBar, Scrollbar
ComponentListener
componentHidden(),
componentMoved(),
componentResized(),
componentShown()
Component
ContainerListener
componentAdded(),
componentRemoved()
Container
FocusListener
focusGained(),
focusLost()
Component
ItemListener
itemStateChanged()
AbstractButton,
ButtonModel, Checkbox,
CheckboxMenuItem,
Choice, ItemSelectable,
JComboBox, List
KeyListener
keyPressed(),
keyReleased(),
keyTyped()
Component
MouseListener
mouseClicked(),
mouseEntered(),
mouseExited(),
mousePressed(),
mouseReleased()
Component
MouseMotionListener
mouseDragged(),
mouseMoved()
Component
TextListener
textValueChanged()
TextComponent
Swing/AWT
Architecture
Event Handling
21

Table 2−7: AWT Event Listeners and the Components That Use Them (continued)
Event Listener
Listener Methods
Register ed on
WindowListener
windowActivated(),
windowClosed(),
windowClosing(),
windowDeactivated(),
windowDeiconified(),
windowIconified(),
windowOpened()
Window
Table 2−8: Swing Event Listeners and the Components That Use Them
Event Listener
Listener Methods
Register ed on
AncestorListener
ancestorAdded(),
ancestorMoved(),
ancestorRemoved()
Action, JComponent
CaretListener
caretUpdate()
JTextComponent
CellEditorListener
editingCanceled(),
editingStopped()
CellEditor,
ChangeListener
stateChanged()
AbstractButton,
BoundedRangeModel,
ButtonModel,
JProgressBar, JSlider,
JTabbedPane, JViewport,
MenuSelectionManager,
SingleSelectionModel
HyperlinkListener
hyperlinkUpdate()
JEditorPane
InternalFrameListener
internalFrame-
Activated (),
internalFrameClosed(),
internalFrameClosing()
internalFrame-
Deactivated(),
internalFrame-
Deiconified(),
internalFrame-
Iconified()
internalFrameOpened()
ListDataListener
contentsChanged(),
intervalAdded(),
intervalRemoved()
AbstractListModel,
ListModel
22 Chapter 2 – Swing and AWT Architectur e

Table 2−8: Swing Event Listeners and the Components That Use Them (continued)
Event Listener
Listener Methods
Register ed on
ListSelectionListener
valueChanged()
JList,
ListSelectionModel
MenuDragMouseListener
menuDragMouseDragged(),
menuDragMouseEntered(),
menuDragMouseExited(),
menuDragMouseReleased()
JMenuItem
MenuKeyListener
menuKeyPressed(),
menuKeyReleased(),
menuKeyTyped()
JMenuItem
MenuListener
menuCanceled(),
menuDeselected(),
menuSelected()
JMenu
PopupMenuListener
popupMenuCanceled(),
JPopupMenu
popupMenuWillBecome-
Invisible(),
popupMenuWillBecome-
Visible()
TreeExpansionListener
treeCollapsed(),
treeExpanded()
JTree
TreeSelectionListener
valueChanged()
JTree
TreeWillExpandListener
treeWillCollapse(),
treeWillExpand()
JTree
java.beans.-
propertyChange()
Action, JComponent,
PropertyChangeListener 
UIDefaults, UIManager
java.beans.-
vetoableChange()
JComponent
VetoableChangeListener
Swing Component Architecture
So far, we have treated components as single, self-contained GUI building blocks.
And indeed, components can be written to be entirely self-contained. However,
neither AWT nor Swing components are actually self-contained. As I mentioned
earlier, each AWT component is simply a frontend for an underlying native user-
inter face object. AWT delegates all the display and event processing — that is, the
look-and-feel — to these native GUI elements.
Swing components are not self-contained either. Most Swing components rely on
two other objects: a user-inter face (UI) delegate object and a model object. Swing
supports a pluggable look-and-feel architectur e, which means that a Swing appli-
cation can control the appearance and behavior of its user-inter face. Thus, a Swing
Swing/AWT
Architecture
Swing Component Architectur e
23

application can be displayed in a platform-independent way or in a way that mim-
ics the native look-and-feel of the underlying platform, for example. In order to
implement the pluggable look-and-feel architectur e, every Swing component must
delegate its display and event-handling functions to a separate object: the UI dele-
gate. Fortunately, you can use Swing without ever thinking about the pluggable
look-and-feel. That’s because, when you create a Swing component, an appropri-
ate UI delegate object is automatically created for it.
The model object for a Swing component is responsible for storing the state of the
component. For example, the JToggleButton uses an implementation of the But-
tonModel inter face as its model. This ButtonModel object remembers whether the
button is currently selected. As another example, the JScrollBar, JSlider, and
JProgressBar components use a BoundedRangeModel object to keep track of their
state. This state includes minimum, maximum, and current values.
Most Swing components automatically create the model objects they rely on, so
you can use these components without ever worrying about model objects. When
working with more complicated components, however, models become more
important. For example, the JTree component uses a javax.swing.tree.Tree-
Model object to repr esent the data it is to display. The JTree component can be
used to display many kinds of hierarchically structured data. JTree does not
requir e you to convert your data into some predeﬁned data format, however.
Instead, you implement the TreeModel inter face in a way that allows JTree to
understand the data. For example, to use a JTree component to display ﬁles in the
ﬁlesystem, you might deﬁne a FileTreeModel class that implements the TreeModel
inter face on top of the capabilities of the java.io.File class. Or, if you want to
use JTree to display the structure of an XML document, you might create an
implementation of TreeModel that works with the parse tree retur ned by an XML
parsing class.
The JTable component is another for which the use of a separate model object is
particularly important. JTable can be used to display a tabular view of data, even
when that data is not tabular by nature. To do so, you implement the javax.-
swing.table.TableModel inter face to provide a neat, tabular view of the data.
One advantage of this model object approach, where the actual data is separated
fr om the component’s view of that data, is that you can deﬁne multiple views of
the same data. For example, if you have a large set of tabular data that implements
the TableModel inter face, you can have two or more JTable components that dis-
play differ ent portions of that data at the same time. When you are writing an
application that manipulates complex data structures, you should consider design-
ing these structures so that they implement appropriate Swing model interfaces. If
you do this, you’ll be able to trivially display your data using Swing components.
See Chapter 3, Swing Programming Topics, for more infor mation about implement-
ing TreeModel and TableModel.
24 Chapter 2 – Swing and AWT Architectur e

CHAPTER 3
Swing
Prog ramming Topics
The last chapter provided an architectural overview of AWT and Swing; it
explained how to create a graphical user interface by placing components inside
containers, arranging them with layout managers, and handling the events that
they generate. This chapter builds on that architectural foundation and introduces
many other important features of Swing. Most of the topics discussed herein are
independent of one another, so you can think of each section as a short essay on
a particular topic, where the sections can be read in any order.
This chapter introduces many of the new components and features of Swing, but it
cannot cover them in full detail. For more infor mation on the topics covered
her ein, see Java Swing, by Robert Eckstein, Marc Loy, and Dave Wood (O’Reilly).
Versions of Swing
Swing is a core part of the Java 2 platform, so many developers will simply obtain
the Swing libraries when they download the Java 2 SDK. Swing is also available as
a separate download for use as an extension to Java 1.1. When you download
Swing independently of the SDK, you must pay attention to the Swing version
number. Swing 1.0.3 is an early version of Swing that was released before Version
1.2 of Java 2. It is now outdated and is not documented in this book. Swing 1.1 is
the version of Swing that is being bundled with Java 1.2. You can download a ver-
sion of it for use with Java 1.1 from http://java.sun.com/pr oducts/jfc/.
As this book goes to press, the most recent version of Swing is Swing 1.1.1. This
version of Swing is bundled with Java 1.2.2 and is also available for use with Java
1.1 from the web site mentioned in the previous paragraph. Swing 1.1.1 ﬁxes
many bugs in the initial release of Swing 1.1 but does not change the Swing 1.1
API in any way. Its use is strongly recommended. Swing 1.1.1 is the last release of
Swing that will be available for use with Java 1.1.
Swing Prog.
Topics
25

Development of Swing continues, and Java 1.3 will ship with a new version that
includes a number of minor changes and improvements to the Swing API. This
futur e release will focus on improving the existing APIs and should not add many
new APIs.
Labels and HTML
In the initial releases of Swing 1.1 and Java 1.2, the JLabel, JButton, and related
classes that display textual labels can display only a single line of text using a sin-
gle font. In Swing 1.1.1 and Java 1.2.2, however, components like these can dis-
play multiline, multifont text using simple HTML formatting. To display formatted
text, simply specify a string of HTML text that begins with an <HTML> tag. You can
use this feature to present text using multiple fonts, font styles, and colors. Just as
important, however, the introduction of HTML allows you to specify multiline
labels.
This new formatted text display feature is available in Java 1.2.2 for the JLabel,
JButton, MenuItem, JMenu, JCheckBoxMenuItem, JRadioButtonMenuItem, JTabbed-
Pane, and JToolTip classes. It is not supported (at least in Java 1.2.2) by JCheckBox
or JRadioButton, however. For matted text display is particularly useful with JOp-
tionPane dialog boxes (described later in this chapter), as they display text using
inter nal JLabel objects.
Actions
A GUI application often allows a user to invoke an operation in a number of dif-
fer ent ways. For example, the user may be able to save a ﬁle by either selecting an
item from a menu or clicking on a button in a toolbar. The resulting operation is
exactly the same; it is simply presented to the user through two differ ent inter-
faces.
Swing deﬁnes a simple but powerful javax.swing.Action inter face that encapsu-
lates information about such an operation. The Action inter face extends the
ActionListener inter face, so it contains the actionPerformed() method. It is this
method that you implement to actually perfor m the desired action. Each Action
object also has an arbitrary set of name/value pairs that provide additional infor-
mation about the action. The values typically include: a short string of text that
names the operation, an image that can be used to repr esent the action graphi-
cally, and a longer string of text suitable for use in a tooltip for the action. In addi-
tion, each Action object has an enabled pr operty and a setEnabled() method that
allows it to be enabled and disabled. (If there is no text selected in a text editor,
for example, the “Cut” action is usually disabled.)
You can add an Action object directly to a JMenu or JToolBar component. When
you do this, the component automatically creates a JMenuItem or JButton to repr e-
sent the action, making the action’s operation available to the user and displaying
the action’s textual description and graphical image as appropriate. When an
action is disabled, the JMenuItem or JButton component that repr esents the action
displays it in a grayed-out style and does not allow it to be selected or invoked.
26 Chapter 3 – Swing Programming Topics

One shortcoming of working with actions is that there is no way to tell a JMenuBar
or JToolBar to display just text or just icons for actions. Although you might like
an action’s name to be displayed in a menu and its icon to be displayed in a tool-
bar, both JMenuBar and JToolBar display an action’s textual name and its icon.
The Action inter face helps you implement a clean separation between GUI code
and application logic. Remember, however, that you cannot just instantiate Action
objects directly. Since Action is a kind of ActionListener, you must deﬁne an
individual subclass of Action that implements the actionPerformed() method for
each of your desired actions. The AbstractAction class is helpful here; it imple-
ments everything except the actionPerformed() method.
Tooltips
A Swing component can display context-sensitive help to the user in the form of a
tooltip: a small window that pops up when the user lets the mouse rest over the
component. You can display text in this window that explains the purpose or
function of the component. Specify this text with the setToolTipText() method.
This toolTipText pr operty is inherited from JComponent, so it is shar ed by all
Swing components.
While it is a good idea to provide tooltips for the beneﬁt of your novice users,
your experienced users may ﬁnd them annoying, so it is nice to provide a way to
tur n them off. You can do this programatically by setting the enabled pr operty of
the ToolTipManager object. The code looks like this:
ToolTipManager.sharedInstance().setEnabled(false);
Timer s
The javax.swing.Timer object generates single or multiple ActionEvent events at
time intervals that you specify. Thus, a Timer is useful for perfor ming a repeated
operation like an animation. They are also useful for triggering operations that
must occur at some point in the future. For example, an application might display
a message in a status line and then set up a Timer object that erases the message
after 5,000 milliseconds. These operations can also be perfor med with threads, of
course, but since Swing is not designed for thread safety, it is usually more conve-
nient to use a Timer.
You use Timer objects just like regular components. A Timer has property accessor
methods and an addActionListener() method that you can use to add event lis-
teners. The initialDelay pr operty speciﬁes how many milliseconds the Timer
waits before ﬁring its ﬁrst ActionEvent. If the repeats pr operty is true, the Timer
generates a new ActionEvent each time delay milliseconds passes. When an
application (or the system in general) is very busy or when the delay pr operty is
very small, the timer may ﬁre events faster than the application can process them.
If the coalesce pr operty is true, the Timer combines multiple pending events into
a single ActionEvent, rather than letting a queue of unprocessed events build up.
Swing Prog.
Topics
Timers 27

The Event Dispatch Thread
For efﬁciency reasons, Swing components are not designed to be thread safe. This
means that Swing components should be manipulated by a single thread at a time.
The easiest way to ensure this is to do all your GUI manipulations from the event
dispatch thread. Every GUI application has an event dispatch thread: it is the
thr ead that waits for events to occur and then dispatches those events to the
appr opriate event handlers. All of your event listener methods are invoked by the
event dispatch thread, so any GUI manipulations you perfor m fr om an event lis-
tener are safe.
Ther e ar e times, however, when you need to update your UI in response to some
kind of external event, such as a response from a server that arrives in a separate
thr ead. To accommodate these situations, Swing provides two utility methods that
allow you ask the event dispatch thread to run arbitrary code. The methods are
SwingUtilities.invokeLater() and SwingUtilities.invokeAndWait(). You pass
a Runnable object to each method, and the run() method of this object is invoked
fr om the event thread. invokeLater() retur ns right away, regardless of when the
run() method is invoked, while invokeAndWait() does not retur n until the run()
method has completed.
The invokeLater() and invokeAndWait() methods do not run your Runnable
object right away. Instead, each method encapsulates the Runnable object within a
special event object and places the event on the event queue. Then, when all
pending events have been handled, the Runnable object is extracted from the
event queue and the event dispatch thread calls its run() method. This means that
invokeLater() pr ovides a useful way to defer the execution of some chunk of
code until after all pending events have been processed. There are times when
you may even want to do this with code that is already running within the event
dispatch thread.
Client Proper ties
In addition to its normal set of properties, JComponent includes a hashtable in
which it can store arbitrary name/value pairs. These name/value pairs are called
client properties, and they can be set and queried with the putClientProperty()
and getClientProperty() methods. Since these are JComponent methods, they are
inherited by all Swing components. Although both the name and value of a client
pr operty can be arbitrary objects, the name is usually a String object.
Client properties allow arbitrary data to be associated with any Swing component.
This can be useful in a number of situations. For example, suppose you’ve created
a JMenu that contains 10 JMenuItem components. Each component notiﬁes the
same ActionListener object when it is invoked. This action listener has to decide
which of the 10 menu items invoked it and then perfor m whatever action is
appr opriate for that menu item. One way the action listener can distinguish among
the menu items is by looking at the text that each displays. But this approach
doesn’t work well if you plan to translate your menu system into other languages.
A better approach is to use the setActionCommand() method (inherited from
AbstractButton) to associate a string with each of the JMenuItem components.
28 Chapter 3 – Swing Programming Topics

Then the action listener can use this string to distinguish among the various menu
items. But what if the action listener needs to check some kind of object other
than a String in order to decide how to process the action event? Client properties
ar e the solution: they allow you to associate an arbitrary object (or multiple
objects) with each JMenuItem.
Client properties are used within Swing to set properties that are speciﬁc to a sin-
gle look-and-feel implementation. For example, the default Java look-and-feel
examines the client properties of a few components to obtain additional informa-
tion about how it should display the components. Here are some details on these
particular client properties:
"JInternalFrame.isPalette"
When a JInternalFrame is being used as a ﬂoating palette, set this client
pr operty to Boolean.TRUE to change the look of the border.
"JScrollBar.isFreeStanding"
JScrollPane sets this client property to Boolean.FALSE on the JScrollBar
components it creates.
"JSlider.isFilled"
Setting this client property of a JSlider to Boolean.TRUE causes the slider to
display a differ ent backgr ound color on either side of the slider thumb.
"JToolBar.isRollover"
Setting this client property to Boolean.TRUE on a JToolBar causes the compo-
nent to highlight the border of whatever child component the mouse is cur-
rently over.
"JTree.lineStyle"
This client property speciﬁes how the JTree component draws the branches
of its tree. The default value is the string “Horizontal”; other possible values
ar e “Angled” and “None”.
Ke yboard Shor tcuts
A full-featur ed user interface does not requir e the user to use the mouse all the
time. Instead, it provides keyboard shortcuts that allow the user to operate the
application primarily or entirely with the keyboard. Swing has a number of fea-
tur es that support keyboard shortcuts. Every Swing component is designed to
respond to keyboard events and support keyboard operation automatically. For
example, a JButton is activated when it receives a KeyEvent that tells it that the
user pressed the Spacebar or the Enter key. Similarly, JMenu and JList respond to
the arrow keys.
Focus Management
In order for a Swing component to receive keyboard events, it must ﬁrst have the
keyboard focus. In the old days, before graphical interfaces, when you typed on
the keyboard, the characters always appeared on the screen. There was only one
“window,” so there was only one place to send key events. This changes with the
Swing Prog.
Topics
Keyboar d Shortcuts 29

intr oduction of windowing systems and GUIs, however, as ther e ar e now lots of
places that keyboard events can be directed to. When there is mor e than one win-
dow open on the screen, one window is singled out as the current window (or the
focused window). Most windowing systems highlight this window somehow.
When you type at the keyboard, it is understood that your keystrokes are dir ected
at the current window.
Just as a screen may contain many application windows, a single application win-
dow usually contains many GUI components. An application window must redi-
rect the keyboard events it receives to only one of these components, called the
focused component. Like most GUI toolkits, Swing highlights the component that
has the keyboard focus, to let the user know where keyboard events are being
dir ected. The details of the highlight depend on the look-and-feel that is currently
in effect, but focus is often indicated by drawing a bold border around a com-
ponent.
A Swing component can be operated from the keyboard when it has the focus.
The user can usually direct keyboard focus to a given component by clicking on
that component with the mouse, but this defeats the whole point of not using the
mouse. The missing piece of the picture is focus traversal, otherwise known as
keyboard navigation, which allows the user to use the keyboard to change focus
fr om one component to the next.
Swing uses the Ta b key to implement focus traversal. When the user presses Ta b,
Swing moves the keyboard focus from the current component to the next compo-
nent that can accept the focus. (Some components, such as JLabel objects, do not
respond to keyboard events and are ther efor e never given the focus.) When the
user types Shift-Tab, Swing moves keyboard focus backward to the previous focus-
able component. By default, keyboard focus moves from left to right and top to
bottom within a container. You can override this, however, by setting the nextFo-
cusableComponent pr operty of your components, chaining them together in what-
ever order you desire.
When a container is given focus through this mechanism, it passes that focus on to
its ﬁrst focusable child. When the focus reaches the last focusable child, some con-
tainers relinquish the focus and allow it to move on, while other containers retain
the focus and give it back to the ﬁrst focusable child. You can determine the
behavior of a container by calling isFocusCycleRoot(). If this method retur ns
true, the container deﬁnes a focus cycle and retains the focus. The user must type
Ctrl-Tab to traverse to the next focus cycle or Ctrl-Shift-Tab to traverse to the previ-
ous focus cycle. There is no setFocusCycleRoot() method: the only way you can
change this behavior is by subclassing a container and overriding the isFocusCy-
cleRoot() method. Also note that multiline text components such as JTextArea
and JEditorPane use the Ta b key for their own purposes. These components
behave like focus cycles, so the user must type Ctrl-Tab to move the focus away
fr om such a component.
An application sometimes needs to set the keyboard focus to a particular compo-
nent explicitly. You can do this by calling the requestFocus() method of that
component. Components typically call requestFocus() themselves under certain
circumstances, such as when they are clicked on. If you do not want a component
to respond to requestFocus() calls, set its requestFocusEnabled pr operty to
30 Chapter 3 – Swing Programming Topics

false. For example, you might set this property on a JButton so that the user can
click on it without taking keyboard focus away from whatever component cur-
rently has it.
Swing focus management is handled by the currently installed
javax.-
swing.FocusManager object. You can obtain this object with FocusManager.get-
CurrentFocusManager(). If you implement your own manager, you can install it
with FocusManager.setCurrentFocusManager().
Menu Mnemonics and Accelerator s
Although Swing components can all be operated automatically from the keyboard,
doing so is often cumbersome. The solution is to provide additional explicit key-
board shortcuts for common actions, as is commonly done with items on pull-
down menus. Swing pull-down menus support two traditional types of keyboard
shortcuts: mnemonics and accelerators. Figure 3-1 shows both types of menu
shortcuts.
Menu Item with Mnemonic
Menu Items with Keyboard Accelerators
Figur e 3−1: Swing menu mnemonics and accelerators
A menu mnemonic is a single-letter abbreviation for a menu command. When the
menu has already been pulled down, the user can type this single key to invoke
that menu item. The mnemonic for a menu item is typically indicated by underlin-
ing the letter of the shortcut in the menu item name, which means that you must
select a shortcut letter that appears in the menu item label. Mnemonics must be
unique within a menu, of course, but multiple menu panes can reuse mnemonics.
Items in a menu bar may also have mnemonics. You specify a mnemonic for a
menu or a menu item with the setMnemonic() method (inherited from Abstract-
Button):
JMenu file = new JMenu("File");
file.setMnemonic('F');
JMenuItem save = new JMenuItem("Save");
save.setMnemonic('S'); 
// Always use a capital letter
file.add(save);
A menu accelerator is a unique keyboard command that can be used to invoke a
menu item even when the menu is not displayed. An accelerator is repr esented by
a javax.swing.KeyStroke object and usually includes a keyboard modiﬁer such as
Swing Prog.
Topics
Keyboar d Shortcuts 31

Ctrl or Alt. Unlike mnemonics, accelerators can be applied only to menu items,
not to menus in a menu bar. You can create an accelerator for a menu item by
calling setAccelerator(). To obtain an appropriate KeyStroke object, call the
static KeyStroke.getKeyStroke() method with the keycode and modiﬁer mask for
the keyboard command you want to use:
JMenuItem save = new JMenuItem("Save");
save.setAccelerator(KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S,
java.awt.Event.CTRL_MASK));
Ke yboard Actions
Sometimes even the keyboard shortcuts supported by menus are not enough. An
application may need to deﬁne keyboard shortcuts for actions that are not avail-
able through the menu system. For example, an application that uses a JScroll-
Pane to display a large drawing might want to allow the user to scroll the drawing
with the arrow keys and the Pa geUp and Pa geDown keys.
Fortunately, every Swing component maintains a table of KeyStroke-to-ActionLis-
tener bindings. When a particular keystroke is bound to an ActionListener, the
component will perfor m the action (i.e., invoke the actionPerformed() method)
when the user types the keystroke. You can register a keyboard shortcut for a
component with registerKeyboardAction(). For instance:
Action scroll;
// This action object is initialized elsewhere
JPanel panel;
// The application's main container; initialized elsewhere
KeyStroke up = KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_UP);
KeyStroke down = KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_DOWN);
KeyStroke pgup = KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_PAGE_UP);
KeyStroke pgdown=KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_PAGE_DOWN);
panel.registerKeyboardAction(scroll, "lineup", up,
JComponent.WHEN_ANCESTOR_OF_FOCUSED_WINDOW);
panel.registerKeyboardAction(scroll, "linedown", down,
JComponent.WHEN_ANCESTOR_OF_FOCUSED_WINDOW);
panel.registerKeyboardAction(scroll, "pageup", pgup,
JComponent.WHEN_ANCESTOR_OF_FOCUSED_WINDOW);
panel.registerKeyboardAction(scroll, "pagedown", pgdown,
JComponent.WHEN_ANCESTOR_OF_FOCUSED_WINDOW);
This code registers four keystrokes that all invoke the scroll action. When the
user types one of these keystrokes, the actionPerformed() method is passed an
ActionEvent object. The getActionCommand() method of this ActionEvent retur ns
one of the strings “lineup”, “linedown”, “pageup”, or “pagedown”. The hypotheti-
cal scroll action we are using here would examine this string to determine what
kind of scrolling to perfor m.
The fourth argument to registerKeyboardAction() is a constant that deﬁnes
under what circumstances the keyboard action should be available to the user. The
value used here, WHEN_ANCESTOR_OF_FOCUSED_WINDOW, speciﬁes that the keyboard
binding should be in effect whenever the panel or any of its descendants has the
focus. You can also specify a value of WHEN_IN_FOCUSED_WINDOW, which means that
the keyboard action is available whenever the window containing the component
has the focus. This is useful for shortcuts register ed on default buttons within
32 Chapter 3 – Swing Programming Topics

dialog boxes. The ﬁnal allowable value for this argument is WHEN_FOCUSED, which
speciﬁes that the key binding is in effect only when the component itself has the
focus. This is useful when you are adding key bindings to an individual compo-
nent like a JTree.
Ke ymaps
Swing supports a general, yet powerful text-editing subsystem. The javax.-
swing.text.JTextComponent is the base component in this system; it is the super-
class of JTextField, JTextEditor, and JEditorPane, among others.
Because text editing typically involves many keyboard shortcuts, Swing deﬁnes the
javax.swing.text.Keymap inter face, which repr esents a set of KeyStroke-to-Action
bindings. As you might expect, when a text component has the keyboard focus
and the user types a keystroke that is bound to an action, the text component
invokes that action. A Keymap can have a parent Keymap fr om which it inherits
bindings, making it easy to override a few bindings of an existing keymap without
redeﬁning all the bindings from scratch. When you are working with a large num-
ber of keyboard shortcuts, it is easier to use a Keymap than to register each one
individually with registerKeyboardAction().
JTextComponent deﬁnes getKeymap() and setKeymap() methods you can use to
query and set the current keymap of a text component. There are no public imple-
mentations of the Keymap inter face, so you cannot instantiate one directly. Instead,
cr eate a new Keymap by calling the static JTextComponent.addKeymap() method.
This method allows you to specify a name and parent for the new Keymap. Both
arguments are optional, however, so you may pass in null.
Ser ialization
The AWT Component class implements the java.io.Serializable marker interface,
and JComponent reimplements this interface. This means that all AWT and Swing
components are serializable, or, in other words, the state of an AWT or Swing
component can be stored as a stream of bytes that can be written to a ﬁle. Com-
ponents serialized to a ﬁle can be restor ed to their original state at a later date.
When a component is serialized, all the components it contains are also automati-
cally serialized as part of the same stream.
You serialize a component (or any serializable object) with the
java.io.-
ObjectOutputStream class and reconstruct a serialized component with the
java.io.ObjectInputStream. See Java in a Nutshell for more infor mation about
these classes. Because the byte stream format used in serialization changed
between Java 1.1 and Java 1.2, Swing components serialized by a Java 1.2 applica-
tion cannot be deserialized by a Java 1.1 application.
The serializability of Swing and AWT components is a powerful feature that is
exploited by some GUI design tools. Thus, an application may create its graphical
inter face simply by reading and deserializing an already-built interface from a ﬁle.
This is usually much simpler than creating the components of the GUI indi-
vidually.
Swing Prog.
Topics
Serialization 33

Border s
Every Swing component inherits a border pr operty fr om JComponent, so you can
call setBorder() to specify a Border object for a Swing component. This Border
object displays some kind of decoration around the outside of the component. The
javax.swing.border package contains this Border inter face and a number of use-
ful implementations of it. Table 3-1 lists the available border styles, and Figure 3-2
illustrates them.
Table 3−1: Swing Border Styles
Bor der
Description
BevelBorder
Gives the component a beveled edge that makes it appear
raised or lowered.
CompoundBorder
Combines two other Border types to create a compound
border.
EmptyBorder
A border with no appearance. This is a useful way to place
an empty margin around a component.
EtchedBorder
Draws a line around the component, using a 3D effect that
makes the line appear etched into or raised out of the
surr ounding container.
LineBorder
Draws a line, with a color and thickness you specify, around
the component.
MatteBorder
Draws the border using a solid color or a tiled image. You
specify the border dimensions for all four sides.
SoftBevelBorder
Like BevelBorder, but with somewhat more complex
graphics that give the bevel a softer edge.
TitledBorder
A border that combines text with an EtchedBorder or any
other border you specify.
The Border implementations deﬁned in javax.swing.border cover just about
every possible border you are likely to want to display. But if you ever ﬁnd your-
self needing a specialized border, simply implement the Border inter face yourself.
Most of the
Border implementations in
javax.swing.border ar e immutable
objects, designed to be shared. If two components have the same style of border,
they can use the same Border immutable object. The javax.swing.BorderFactory
class contains static methods that retur n various commonly used Border objects
suitable for sharing.
Icons
All buttons, labels, and menu items in Swing can display both text and graphic ele-
ments. If you are familiar with the AWT, you might expect Swing to use the
java.awt.Image class to repr esent these graphic elements. Instead, however, it
uses javax.swing.Icon. This interface repr esents a graphic element more gener-
34 Chapter 3 – Swing Programming Topics

Figur e 3−2: Swing bor der styles
ally. Its paintIcon() method is called to display the graphic, and this method can
do anything necessary to display it.
Swing includes an Icon implementation called ImageIcon. This commonly used
class is an Image-based implementation of Icon. ImageIcon also simpliﬁes the pro-
cess of reading images from external ﬁles. One of the constructors for ImageIcon
simply takes the name of the desired image ﬁle.
A related utility function is the static method GrayFilter.createDisabledImage().
This version produces a grayed-out version of a given Image, which can be used
to create an ImageIcon that repr esents a disabled action or capability.
Cur sor s
The cursor, or mouse pointer, is the graphic that appears on the screen and tracks
the position of the mouse. Java support for cursors has evolved in each Java
release. Java 1.0 and 1.1 included 14 predeﬁned cursors but did not support cus-
tom cursors. In Java 1.0, the predeﬁned cursors were repr esented by constants
deﬁned by java.awt.Frame and they could be speciﬁed only for these top-level
Frame components. These Frame constants and the corresponding setCursor()
method of Frame ar e now deprecated.
Swing Prog.
Topics
Cursors 35

Java 1.1 included a new java.awt.Cursor class and deﬁned a new setCursor()
method for all Component objects. Even though cursors had a class of their own in
Java 1.1, the Cursor() constructor and the Cursor.getPredefinedCursor() method
could still retur n only the same 14 predeﬁned cursors. Despite their limited num-
ber, these predeﬁned cursors are often useful. Figure 3-3 shows what they look
like on a Unix machine running the X Window System.
Cursor.DEFAULT_CURSOR
Cursor.CROSSHAIR_CURSOR
Cursor.TEXT_CURSOR
Cursor.WAIT_CURSOR
Cursor.HAND_CURSOR
Cursor.MOVE_CURSOR
Cursor.N_RESIZE_CURSOR
Cursor.S_RESIZE_CURSOR
Cursor.E_RESIZE_CURSOR
Cursor.W_RESIZE_CURSOR
Cursor.NE_RESIZE_CURSOR
Cursor.NW_RESIZE_CURSOR
Cursor.SE_RESIZE_CURSOR
Cursor.SW_RESIZE_CURSOR
Figur e 3−3: The standar d Java cursors, on a Unix platform
Java 1.2 includes an API to support custom cursors, at least when running on top
of a native windowing system that supports them. In Java 1.2, the Cursor class has
a new getSystemCustomCursor() method that retur ns a named cursor deﬁned by a
system administrator in a systemwide cursors.pr operties ﬁle. Since there is no way
to query the list of system-speciﬁc custom cursors, however, this method is rarely
used. Instead, an application may create its own custom cursors by calling the
createCustomCursor() method of the Toolkit object. First, however, the appli-
cation should check whether custom cursors are supported, by calling the
getBestCursorSize() method of the Toolkit. If this method indicates a width or
height of 0, custom cursors are not supported (by either the Java implementation
or the underlying windowing system).
To create a custom cursor, you might use code like this:
Cursor c;
Toolkit tk = Toolkit.getDefaultToolkit();
Dimension bestsize = tk.getBestCursorSize(24,24);
if (bestsize.width != 0)
c = tk.createCustomCursor(cursorImage, cursorHotSpot, cursorName);
else
c = Cursor.getDefaultCursor();
36 Chapter 3 – Swing Programming Topics

Double-Buffering
Double-buf fering is the process of drawing graphics into an off-scr een image
buf fer and then copying the contents of the buffer to the screen all at once. For
complex graphics, using double-buffering can reduce ﬂickering. Swing automati-
cally supports double-buffering for all of its components. To enable it, simply call
the setDoubleBuffered() method (inherited from JComponent) to set the double-
Buffered pr operty to true for any components that should use double-buffer ed
drawing.
Remember that double-buffering is memory intensive. Its use is typically only justi-
ﬁed for components that are repainted very frequently or have particularly com-
plex graphics to display. Note, however, that if a container uses double-buffering,
any double-buffer ed childr en it has share the off-scr een buf fer of the container, so
the requir ed of f-screen buffer is never larger than the on-screen size of the appli-
cation.
The Box Container
Chapter 2, Swing and AWT Architectur e, discussed the general task of arranging
components within containers and listed the layout managers provided by AWT
and Swing. This section describes a commonly used Swing layout management
technique in detail. The easiest way to create complex arrangements of Swing
components is often with the javax.swing.Box container.* Box arranges its compo-
nents into a single row or a single column. You can then use nested Box contain-
ers to create a two-dimensional arrangement of components.
The Box container uses the BoxLayout layout manager, but this layout manager is
automatically assigned, so you never need to work with it explicitly. The easiest
way to create a Box is with the static Box.createHorizontalBox() or Box.create-
VerticalBox() method. Once you have created a Box, simply add children to it.
They will be arranged from left to right or from top to bottom.
The unique power of the
Box actually comes from an inner class called
Box.Filler. This class is a simple component that has no appearance; it exists
simply to insert blank space in a layout and to affect the resize behavior of the lay-
out. You do not create Box.Filler objects directly. Instead, you create them using
the following static methods of Box:
Box.createHorizontalStrut(int width)
Box.createVerticalStrut(int height)
Box.createHorizontalGlue()
Box.createVerticalGlue()
If you are arranging a row of components, you can call createHorizontalStrut()
to insert a ﬁxed number of pixels of blank horizontal space. For a column of com-
ponents, use createVerticalStrut() to insert a blank vertical space.
* For some reason, Box does not begin with the letter J as other Swing components and containers do.
Nevertheless, it is a very useful and commonly used container.
Swing Prog.
Topics
The Box Container
37

The glue methods are dif ferent. They insert stretchy horizontal or vertical space
into a row or column. By default, the space is zero pixels wide or zero pixels
high. But, if the row or column is stretched so that it becomes wider or higher
than its default size, these glue components stretch to take up that extra space. For
example, say you ﬁll a row with some horizontal glue, a JButton component, and
some more horizontal glue. Now, no matter how wide the row becomes, the
JButton is always centered in it. This is because the two glue components (and
possibly the JButton) grow equally to take up the extra space. On the other hand,
if the row consists of only one glue component followed by a JButton, the JBut-
ton always appears right justiﬁed in the row, since the glue component grows to
take up all the space to the left of the button.
As another example, consider a Box used in a dialog to hold a row of OK, Cancel,
and Help buttons. Without any glue, the buttons are resized to ﬁll up the entire
row, with no extra space between them. If we intersperse the three buttons with
four glue components, however, the buttons are always nicely spaced out and the
buttons and the spaces between them grow proportionally as the dialog box
becomes wider.
Minimum, Prefer red, and Maximum Sizes
In order to fully understand the behavior of the Box container and its glue, it is
important to understand that Swing components can have a minimum size, a pre-
ferr ed size, and a maximum size. Many components have a natural size. For exam-
ple, with a JButton, the natural size is the space requir ed to accommodate the
button text and/or Icon, plus the space requir ed for the button border. By default,
a JButton reports its natural size as its minimum size and as its preferr ed size.
When asked for its maximum size, a JButton retur ns very large integers, indicating
that it can grow to become arbitrarily wide and arbitrarily tall.
Swing components (but not AWT components) allow you to specify their mini-
mum, preferr ed, and maximum sizes. For example, if you do not want to allow a
JButton to become arbitrarily large as its container grows larger, you can set a
maximum size for it by calling setMaximumSize(). Setting a preferr ed size for a
JButton is an uncommon thing to do, as JButton has a perfectly good natural size.
But some components, such as JScrollPane objects, do not have a natural size.
For components like these, it is usually important that you establish a default size
with setPreferredSize(). If you want to prevent a JScrollPane or similar compo-
nent from becoming arbitrarily small or arbitrarily large, you should also call set-
MinimumSize() and setMaximumSize().
Now that you understand the concepts of minimum, preferr ed, and maximum
sizes, we can retur n to the Box container and its struts and glue. Both struts and
glue are instances of the Box.Filler component. When you create a Box.Filler,
you are actually specifying minimum, preferr ed, and maximum sizes for the com-
ponent. A horizontal strut is simply a Box.Filler with its minimum, preferr ed, and
maximum width set to the number of pixels you specify. A vertical strut has a
ﬁxed minimum, preferr ed, and maximum height.
Horizontal glue has a minimum and preferr ed width of zero, but a very large max-
imum width. This means that the glue takes up no space by default but grows as
38 Chapter 3 – Swing Programming Topics

necessary to ﬁll up extra space. Vertical glue does the same thing in the other
dimension. In order to understand glue, it is also important to understand how the
Box container distributes excess space to its children. If a horizontal Box becomes
wider, the extra width is allocated among the children based on their maximum
widths. Children with larger maximums are given a proportionally larger amount
of the extra space. When you intersperse JButton objects with glue, all the com-
ponents have effectively inﬁnite maximum widths, so all grow by equal amounts.
Suppose, instead, that you restricted the sizes of your buttons like this:
okayButton.setMaximumSize(okayButton.getPreferredSize());
cancelButton.setMaximumSize(cancelButton.getPreferredSize());
helpButton.setMaximumSize(helpButton.getPreferredSize());
In this case, the buttons are alr eady at their maximum sizes, so no extra space is
allocated to them. Now the glue between the buttons gets all the extra space.
I just said that glue components have a preferr ed size of zero. With regard to the
example of three buttons interspersed with four glue components, this means that
when the row of buttons is displayed at its default size, the buttons bump into one
another and appear awkwardly crowded. To remedy this, you might place hori-
zontal struts and horizontal glue between the buttons. In this case, the struts pro-
vide the default and minimum spacing, while the glue components make the
spacing grow. There is a mor e ef ﬁcient way to do this, however. You can explicitly
cr eate Box.Filler components that combine the nonzero default size of a strut
with the inﬁnite maximum size of a glue object. You can create such a ﬁller object
as follows:
Dimension fixedwidth = new Dimension(15, 0);
Dimension infinitewidth = new Dimension(Short.MAX_VALUE, 0);
Box.Filler filler = new Box.Filler(fixedwidth, fixedwidth, infinitewidth);
The Other Dimension
So far, our discussion of the Box container has covered only how components are
arranged horizontally in a horizontal box or vertically in a vertical box. What does
Box do in the other dimension? When laying out components in a row, the Box
makes the row as tall as the tallest component and then attempts to make all the
components as tall as the row. Similarly, when it lays out components in a col-
umn, Box tries to make all components as wide as the widest component.
As we’ve discussed, however, components can have a maximum size. If a row
becomes taller than a component’s maximum height or a column becomes wider
than a component’s maximum width, the Box must decide how to position the
component with respect to the others in the row or column. For a column, the
component can be left, center, or right justiﬁed or positioned anywhere in
between. A component in a row can be aligned along the top or bottom of the
row or placed somewhere in between.
A Box positions such a component based on its alignmentX or alignmentY pr op-
erty. Each is a float pr operty that should have a value between 0.0 and 1.0. The
default for both is 0.5. When a component needs to be positioned horizontally in a
column, the Box uses the alignmentX pr operty. A value of 0.0 means the compo-
nent is left justiﬁed, 1.0 means the component is right justiﬁed, and 0.5 means the
Swing Prog.
Topics
The Box Container
39

component is centered. Other values position the component appropriately
between these positions. When a Box needs to position a component vertically in
a row, it uses the component’s alignmentY pr operty to place the component in the
vertical plane in an analogous way.
Simple Dialogs
GUIs often use dialog boxes to handle simple interactions with the user.
javax.swing.JOptionPane is a Swing component that is designed to serve as a
highly conﬁgurable body of a dialog box. Instead of using the JOptionPane
dir ectly, however, most Swing programs use one or more of the many static meth-
ods deﬁned by JOptionPane. These methods make it quite easy to implement sim-
ple dialog-based interactions.
If you take a look at the API for JOptionPane, you’ll see that the class deﬁnes a
gr oup of static methods whose names begin with show and another whose names
begin with showInternal. The show methods display simple dialog boxes within
JDialog windows, while the showInternal methods display the same dialog boxes
inside JInternalFrame windows. These static methods are further broken down by
the type of dialog they display. There are several versions of showMessageDia-
log(), showConfirmDialog(), and showInputDialog(), as well as showInternal
versions of the same methods. We’ll consider these three types of dialogs—mes-
sage, conﬁrm, and input—in the sections that follow.
Message Dialogs
Message dialogs are used to display important information to users in a way that is
dif ﬁcult or impossible for them to miss. For example, you might use a message
dialog to tell the user that a requested ﬁle was not found. To display this message
with a JOptionPane, you can use code like this:
JOptionPane.showMessageDialog(mainpanel, "The file you requested, " +
filename + ", was not found. Please try again");
This code produces the dialog shown in Figure 3-4. The dialog remains visible
until the user dismisses it by clicking OK.
Figur e 3−4: A JOptionPane message dialog
The ﬁrst argument to showMessageDialog() is the component over which the dia-
log is to appear. You typically specify the main window or panel of your
40 Chapter 3 – Swing Programming Topics

application. If you specify null, then the dialog will simply be centered on the
scr een. The second argument is obviously the message to be displayed. If you
look at the API again, however, you’ll notice that the message argument to this and
other JOptionPane methods is deﬁned as an Object, not a String. This means that
you are not limited to textual messages. If you pass a Component or an Icon, the
JOptionPane displays it as the message. If you pass some other kind of object,
JOptionPane attempts to convert it to a string by calling its toString() method.
You can even pass an array of objects as the message argument. When you pass
mor e than one object, the objects are displayed top to bottom in the resulting dia-
log. So, to display a multiline message, for example, you can just pass in an array
of String objects, instead of a single long String.
The showMessageDialog() function has variants that take more arguments. The
title argument speciﬁes the text to appear in the titlebar of the dialog. The mes-
sageType argument speciﬁes the general type of the message. Legal values are the
JOptionPane constants that end with _MESSAGE. The values you are most likely to
use are INFORMATION_MESSAGE, WARNING_MESSAGE, and ERROR_MESSAGE. Specifying a
message type implicitly speciﬁes the icon that appears in the dialog box. If you
don’t like the default icons, however, ther e is a version of showMessageDialog()
that lets you specify your own icon to display.
Confir m Dialogs
You can use JOptionPane.showConfirmDialog() or JOptionPane.showInternal-
ConfirmDialog() when you want to ask the user a simple question that requir es a
Yes or No (or perhaps Cancel) answer. For example, you can use one of these
methods to present the dialog shown in Figure 3-5.
Figur e 3−5: A JOptionPane conﬁrm dialog
The arguments to showConfirmDialog() ar e much like the arguments to showMes-
sageDialog(), with the addition of the optionType argument. This argument speci-
ﬁes the set of buttons that appears at the bottom of the dialog. Legal values are
OK_CANCEL_OPTION, YES_NO_OPTION, and YES_NO_CANCEL_OPTION.
A conﬁr m dialog asks the user a question. The retur n value of showOptionDia-
log() or showInternalOptionDialog() is an integer that repr esents the user’s
answer in terms of the button the user clicked to dismiss the dialog. The possible
values are OK_OPTION, YES_OPTION, NO_OPTION, CANCEL_OPTION, and CLOSED_OPTION.
This last value is retur ned if the user did not click any of the dialog buttons but
instead dismissed the dialog by closing the window. Here is some simple code
Swing Prog.
Topics
Simple Dialogs
41

that asks a question with a conﬁrm dialog (note the use of a string array for the
message argument):
int response = JOptionPane.showConfirmDialog(mainpanel, new String[] {
/* first line of the message */
"There are unsaved files.",
/* second line of message
*/ 
"Save them before quitting?"},
/* dialog title
*/ 
"Save Before Quitting?",
/* what buttons to display
*/ 
JOptionPane.YES_NO_CANCEL_OPTION,
/* icon type to display
*/ 
JOptionPane.WARNING_MESSAGE);
switch(response) {
case JOptionPane.YES_OPTION:
saveAndQuit();
case JOptionPane.NO_OPTION:
quitWithoutSaving();
case JOptionPane.CANCEL_OPTION:
case JOptionPane.CLOSED_OPTION:
break; // Don't quit!
}
Input Dialogs
The showInputDialog() and showInternalInputDialog() methods are designed to
ask for input that is more complex than a yes-or-no answer. The simple versions
of showInputDialog() support asking a question like “What is your name?” and
letting the user type a response in a text input area:
String name = JOptionPane.showInputDialog(frame, "What is your name?");
The more complex version of this method allows the user to select an object from
a list or pull-down menu of predeﬁned options.
The arguments to showInputDialog() ar e quite similar to those passed to showMes-
sageDialog() and showConfirmDialog(). To display a list of options to the user,
use the seven-argument version of the method and pass in an array of choices and
the default choice to display. For example:
String response = (String) JOptionPane.showInputDialog(
contentpane, 
// parent
"Who is your favorite chipmunk?",
// message
"Pick a Chipmunk",
// dialog title
JOptionPane.QUESTION_MESSAGE, 
// icon type
null, 
// no explicit icon
new String[] {
// choices
"Alvin", "Simon", "Theodore"
},
"Alvin"); 
// default choice
JFileChooser
javax.swing.JFileChooser is a specialized component that allows the user to
br owse the ﬁlesystem and select a ﬁle. The easiest way to use it is with the
showOpenDialog() and showSaveDialog() methods. These methods differ only in
the text that appears in the “Okay” button. You can also call the showDialog()
method and specify your own text for that button. Each of these methods retur ns
an integer status code that speciﬁes how the user dismissed the dialog. If the
retur n value is APPROVE_OPTION, the user actually selected a ﬁle, which you can
obtain with the getSelectedFile() method. For example:
42 Chapter 3 – Swing Programming Topics

public void saveAs() {
JFileChooser chooser = new JFileChooser();
int result = chooser.showSaveDialog(mainpane);
if (result == JFileChooser.APPROVE_OPTION)
save(chooser.getSelectedFile());
}
Note that showSaveDialog() and showOpenDialog() ar e instance methods, not
static methods like those used with JOptionPane. This means that you can cus-
tomize the dialog by setting properties on your JFileChooser object. You may be
inter ested in setting the currentDirectory and fileSelectionMode pr operties
befor e you display a JFileChooser. fileSelectionMode can be set to FILES_ONLY,
DIRECTORIES_ONLY, or FILES_AND_DIRECTORIES. Once you create a JFileChooser
for an application, you may want to reuse it, rather than creating a new one each
time you need one. If you do so, the JFileChooser automatically remembers the
currentDirectory most recently selected by the user.
Using File Filter s
The javax.swing.filechooser package deﬁnes auxiliary classes that are used by
JFileChooser. One of the most important of these is FileFilter. The abstract
javax.swing.filechooser.FileFilter class is much like the java.io.FileFilter
inter face. Each deﬁnes an accept() method that is passed File objects and retur ns
true for each ﬁle that should be displayed. The FileFilter class used by JFile-
Chooser has an additional getDescription() method that retur ns a string that
names the types of ﬁles accepted by the ﬁlter. For example, you might deﬁne a
FileFilter subclass that accepts ﬁles with names ending in .htm or .html and
retur ns a description of “HTML Files.”
When you create a JFileChooser, you can specify the FileFilter it is to use with
setFileFilter(). Alter nately, you can specify an array of FileFilter objects with
setChoosableFileFilters(). In this case, JFileChooser displays the descriptions
of the ﬁlters and allows the user to choose one.
Customizing JFileChooser
The behavior of a JFileChooser can be customized by providing your own imple-
mentation of FileView and FileSystemView. Both of these abstract classes are
deﬁned in the javax.swing.filechooser class. FileView deﬁnes methods that
af fect the way individual ﬁles are displayed by the JFileChooser, while FileSys-
temView deﬁnes methods that enable the JFileChooser to handle operating-system
dependencies in the ﬁlesystem. FileSystemView understands the notion of hidden
ﬁles, and it can retur n a complete list of ﬁlesystem roots, a capability that was
lacking from the basic java.io.File class prior to Java 1.2. The default FileView
and FileSystemView classes provided by JFileChooser ar e per fectly adequate for
most purposes, so you typically don’t have to implement these classes yourself.
It is also possible to customize a JFileChooser by providing an accessory compo-
nent. If you pass a JComponent to the setAccessory() method of JFileChooser,
the Swing component you specify is displayed in the ﬁle chooser dialog box. A
Swing Prog.
Topics
JFileChooser 43

common use of a ﬁle chooser accessory is as a ﬁle preview component. In order
to provide a preview of the currently selected ﬁle, the accessory must know what
the currently selected ﬁle is. It can get this information by implementing the Prop-
ertyChangeListener inter face and listening for changes to the selectedFile pr op-
erty. In order for this to work, you have to pass the accessory object to the
addPropertyChangeListener() method of the JFileChooser, of course.
JColorChooser
Just as JFileChooser allows the user to choose a ﬁle, javax.swing.JColorChooser
allows the user to choose a color. Figur e 3-6 shows a JColorChooser dialog. You
can embed a JColorChooser component directly in your application or in a cus-
tom dialog box, but the most common way to use it is to simply call the static
showDialog() method:
Color c = JColorChooser.showDialog(contentpane,
// Dialog appears over this
"Pick a Color", // Dialog title
Color.white); 
// Default color selection
Figur e 3−6: A JColorChooser dialog
As you can see from Figure 3-6, JColorChooser displays a color selection pane
and a color preview pane. The selection pane is actually a JTabbedPane that allows
colors to be selected in three differ ent ways. The Swatches pane lets the user
select a color from a palette of color swatches. With the RGB pane, the user picks
a color by specifying the red, green, and blue components of the color, while with
the HSV pane, the user speciﬁes the hue, saturation, and value components of the
color.
44 Chapter 3 – Swing Programming Topics

Instead of displaying a generic JColorChooser with the static showDialog()
method, you can create your own instance of the JColorChooser class. You can
then set properties on the color chooser object and display it in any way you
want. The static JColorChooser.createDialog() method is useful here. It creates a
dialog box to hold your JColorChooser pane and allows you to specify two
ActionListener objects that are invoked in response to the OK and Cancel but-
tons in the dialog box.
You can customize a JColorChooser by adding a new color selection panel or a
new color preview panel. To add a new color selection panel (for example, a
panel that allows the user to select a grayscale color or a CMYK color), implement
a subclass of AbstractColorChooserPanel (fr om the javax.swing.colorchooser
package) and pass it to the addChooserPanel() method of your JColorChooser.
Your custom panel contains a ColorSelectionModel that serves as the interface
between your pane and the JColorChooser. All your pane needs to do is update
the selected color of its ColorSelectionModel (ColorSelectionModel is also part
of the javax.swing.colorchooser package).
You can use any JComponent as a custom preview panel for your JColorChooser.
Simply pass the component to setPreviewPanel(). The preview component has to
track the currently selected color by listening for ChangeEvent events generated by
the ColorSelectionModel of the JColorChooser.
Menus
In Swing, menu bars, menu panes, and menu items are components, just like all
other Swing components. JMenuBar is a container designed to hold JMenu objects.
JMenu is a container designed to hold JMenuItem objects and other JMenu objects
(as submenus). Working with menus is not exactly the same as working with other
types of components, however, and Example 3-1 shows a simple example of creat-
ing pull-down and pop-up menus.
Example 3−1: Cr eating Pull-Down and Pop-Up Menus in Swing
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
public class MenuDemo {
public static void main(String[] args) {
// Create a window for this demo
JFrame frame = new JFrame("Menu Demo");
JPanel panel = new JPanel();
frame.getContentPane().add(panel, "Center");
// Create an action listener for the menu items we will create
// The MenuItemActionListener class is defined below
ActionListener listener = new MenuItemActionListener(panel);
// Create some menu panes, and fill them with menu items
// The menuItem() method is important.
It is defined below.
JMenu file = new JMenu("File");
file.setMnemonic('F');
file.add(menuItem("New", listener, "new", 'N', KeyEvent.VK_N));
Swing Prog.
Topics
Menus 45

Example 3−1: Cr eating Pull-Down and Pop-Up Menus in Swing (continued)
file.add(menuItem("Open...", listener, "open", 'O', KeyEvent.VK_O));
file.add(menuItem("Save", listener, "save", 'S', KeyEvent.VK_S));
file.add(menuItem("Save As...", listener, "saveas", 'A', KeyEvent.VK_A));
JMenu edit = new JMenu("Edit");
edit.setMnemonic('E');
edit.add(menuItem("Cut", listener, "cut", 0, KeyEvent.VK_X));
edit.add(menuItem("Copy", listener, "copy", 'C', KeyEvent.VK_C));
edit.add(menuItem("Paste", listener, "paste", 0, KeyEvent.VK_V));
// Create a menu bar and add these panes to it.
JMenuBar menubar = new JMenuBar();
menubar.add(file);
menubar.add(edit);
// Add menu bar to the main window.
Note special method to add menu bars.
frame.setJMenuBar(menubar);
// Now create a popup menu and add the some stuff to it
final JPopupMenu popup = new JPopupMenu();
popup.add(menuItem("Open...", listener, "open", 0, 0));
popup.addSeparator(); 
// Add a separator between items
JMenu colors = new JMenu("Colors");
// Create a submenu
popup.add(colors); 
// and add it to the popup menu
// Now fill the submenu with mutually exclusive radio buttons
ButtonGroup colorgroup = new ButtonGroup();
colors.add(radioItem("Red", listener, "color(red)", colorgroup));
colors.add(radioItem("Green", listener, "color(green)", colorgroup));
colors.add(radioItem("Blue", listener, "color(blue)", colorgroup));
// Arrange to display the popup menu when the user clicks in the window
panel.addMouseListener(new MouseAdapter() {
public void mousePressed(MouseEvent e) {
// Check whether this is the right type of event to pop up a popup
// menu on this platform.
Usually checks for right button down.
if (e.isPopupTrigger())
popup.show((Component)e.getSource(), e.getX(), e.getY());
}
});
// Finally, make our main window appear
frame.setSize(450, 300);
frame.setVisible(true);
}
// A convenience method for creating menu items
public static JMenuItem menuItem(String label,
ActionListener listener, String command,
int mnemonic, int acceleratorKey) {
JMenuItem item = new JMenuItem(label);
item.addActionListener(listener);
item.setActionCommand(command);
if (mnemonic != 0) item.setMnemonic((char) mnemonic);
if (acceleratorKey != 0)
item.setAccelerator(KeyStroke.getKeyStroke(acceleratorKey,
java.awt.Event.CTRL_MASK));
return item;
}
46 Chapter 3 – Swing Programming Topics

Example 3−1: Cr eating Pull-Down and Pop-Up Menus in Swing (continued)
// A convenience method for creating radio button menu items
public static JMenuItem radioItem(String label, ActionListener listener,
String command, ButtonGroup mutExGroup) {
JMenuItem item = new JRadioButtonMenuItem(label);
item.addActionListener(listener);
item.setActionCommand(command);
mutExGroup.add(item);
return item;
}
// An event listener class used with the menu items created above
// For this demo, it just displays a dialog box when an item is selected
public static class MenuItemActionListener implements ActionListener {
Component parent;
public MenuItemActionListener(Component parent) { this.parent = parent; }
public void actionPerformed(ActionEvent e) {
JMenuItem item = (JMenuItem) e.getSource();
String cmd = item.getActionCommand();
JOptionPane.showMessageDialog(parent, cmd + " was selected.");
}
}
}
JTree and TreeModel
The javax.swing.JTree class is a powerful Swing component for displaying tree-
structur ed data. Like all Swing components, JTree relies on a separate model
object to hold and repr esent the data that it displays. Most Swing components cre-
ate this model object automatically, and you never need to work with it explicitly.
The JTree component, however, displays data that is much more complex than a
typical Swing component. When you are working with a JTree, you must create a
model object that implements the javax.swing.tree.TreeModel inter face.
One approach is to use the DefaultTreeModel class, which implements the
TreeModel inter face using the TreeNode and MutableTreeNode inter faces (all
deﬁned in javax.swing.tree). To use DefaultTreeModel, you must implement
your hierarchical data structures so that each element of the tree implements the
TreeNode or MutableTreeNode inter face. Now you can create a DefaultTreeModel
object simply by passing the root TreeNode of your tree to a DefaultTreeModel
constructor. Then you create a JTree component to display your tree simply by
passing the DefaultTreeModel to the setModel() method of the JTree.
Sometimes, however, you do not have the luxury of designing the data structures
used to repr esent your tree, so implementing the TreeNode inter face is simply not
an option. In this case, you can implement the TreeModel inter face dir ectly. The
resulting TreeModel object serves as the interface between your data and the JTree
component that displays the data. Your TreeModel implementation provides the
methods that allow the JTree component to traverse the nodes of your tree,
regardless of the actual repr esentation of the tree data.
Example 3-2 shows a program that implements the TreeModel inter face to repr e-
sent the hierarchical structure of the ﬁlesystem, thereby allowing the ﬁle and direc-
tory tree to be displayed in a JTree component. Notice how a relatively simple
Swing Prog.
Topics
JT ree and TreeModel 47

implementation of TreeModel enables the powerful tree- browsing capabilities
shown in Figure 3-7.
Figur e 3−7: The JT ree component
Example 3−2: Using JTree and TreeModel
import javax.swing.*;
import javax.swing.event.*;
import javax.swing.tree.*;
import java.io.File;
public class FileTreeDemo {
public static void main(String[] args) {
// Figure out where in the filesystem to start displaying
File root;
if (args.length > 0) root = new File(args[0]);
else root = new File(System.getProperty("user.home"));
// Create a TreeModel object to represent our tree of files
FileTreeModel model = new FileTreeModel(root);
// Create a JTree and tell it to display our model
JTree tree = new JTree();
tree.setModel(model);
// The JTree can get big, so allow it to scroll
JScrollPane scrollpane = new JScrollPane(tree);
// Display it all in a window and make the window appear
JFrame frame = new JFrame("FileTreeDemo");
frame.getContentPane().add(scrollpane, "Center");
frame.setSize(400,600);
frame.setVisible(true);
}
}
48 Chapter 3 – Swing Programming Topics

Example 3−2: Using JTree and TreeModel (continued)
/**
* The methods in this class allow the JTree component to traverse
* the file system tree and display the files and directories.
**/
class FileTreeModel implements TreeModel {
// We specify the root directory when we create the model.
protected File root;
public FileTreeModel(File root) { this.root = root; }
// The model knows how to return the root object of the tree
public Object getRoot() { return root; }
// Tell JTree whether an object in the tree is a leaf
public boolean isLeaf(Object node) {
return ((File)node).isFile(); }
// Tell JTree how many children a node has
public int getChildCount(Object parent) {
String[] children = ((File)parent).list();
if (children == null) return 0;
return children.length;
}
// Fetch any numbered child of a node for the JTree.
// Our model returns File objects for all nodes in the tree.
The
// JTree displays these by calling the File.toString() method.
public Object getChild(Object parent, int index) {
String[] children = ((File)parent).list();
if ((children == null) || (index >= children.length)) return null;
return new File((File) parent, children[index]);
}
// Figure out a child's position in its parent node.
public int getIndexOfChild(Object parent, Object child) {
String[] children = ((File)parent).list();
if (children == null) return -1;
String childname = ((File)child).getName();
for(int i = 0; i < children.length; i++) {
if (childname.equals(children[i])) return i;
}
return -1;
}
// This method is invoked by the JTree only for editable trees.
// This TreeModel does not allow editing, so we do not implement
// this method.
The JTree editable property is false by default.
public void valueForPathChanged(TreePath path, Object newvalue) {}
// Since this is not an editable tree model, we never fire any events,
// so we don't actually have to keep track of interested listeners
public void addTreeModelListener(TreeModelListener l) {}
public void removeTreeModelListener(TreeModelListener l) {}
}
Swing Prog.
Topics
JT ree and TreeModel 49

JTable and TableModel
javax.swing.JTable is another powerful Swing component for displaying com-
plex data structures. Like JTree, JTable relies on a separate model object to hold
and repr esent the data it displays and has its own package of helper classes,
javax.swing.table. This package contains the TableModel inter face and its default
implementations, AbstractTableModel and DefaultTableModel.
If your table data is tidily organized, it is easy to use JTable without worrying
about the TableModel. If your data is an array of rows, where each row is an array
of objects, you can just pass this Object[][] dir ectly to the JTable constructor. If
you want, you can also specify an optional array of column names. This is all you
need to do: the JTable does the rest. This technique also works if your data is
stor ed in a Vector of rows, where each row is itself a Vector.
Often, however, your data is not as regular as that. When you want to display a
tabular view of data that is not, by nature, tabular, you must implement the Table-
Model inter face (or, mor e likely, subclass the AbstractTableModel class). The job
of this TableModel implementation is to serve as the interface between your data,
which is not neatly organized into a table, and the JTable object, which wants to
display a table. In other words, your TableModel pr esents a neat tabular view of
your data, regardless of how the data is organized underneath.
Example 3-3 shows how this can be done. Given a File object that repr esents a
dir ectory in the ﬁlesystem, this example displays the contents of that directory in
tabular form, as shown in Figure 3-8. Once again, notice how a relatively simple
TableModel implementation enables the use of the powerful table-display capabili-
ties of the JTable component.
Figur e 3−8: The JTable component
Example 3−3: Using JTable and TableModel
import javax.swing.*;
import javax.swing.table.*;
import java.io.File;
import java.util.Date;
50 Chapter 3 – Swing Programming Topics

Example 3−3: Using JTable and TableModel (continued)
public class FileTableDemo {
public static void main(String[] args) {
// Figure out what directory to display
File dir;
if (args.length > 0) dir = new File(args[0]);
else dir = new File(System.getProperty("user.home"));
// Create a TableModel object to represent the contents of the directory
FileTableModel model = new FileTableModel(dir);
// Create a JTable and tell it to display our model
JTable table = new JTable(model);
// Display it all in a scrolling window and make the window appear
JFrame frame = new JFrame("FileTableDemo");
frame.getContentPane().add(new JScrollPane(table), "Center");
frame.setSize(600, 400);
frame.setVisible(true);
}
}
/**
* The methods in this class allow the JTable component to get
* and display data about the files in a specified directory.
* It represents a table with six columns: filename, size, modification date,
* plus three columns for flags: directory, readable, writable.
**/
class FileTableModel extends AbstractTableModel {
protected File dir;
protected String[] filenames;
protected String[] columnNames = new String[] {
"name", "size", "last modified", "directory?", "readable?", "writable?"
};
protected Class[] columnClasses = new Class[] {
String.class, Long.class, Date.class,
Boolean.class, Boolean.class, Boolean.class
};
// This table model works for any one given directory
public FileTableModel(File dir) {
this.dir = dir;
this.filenames = dir.list();
// Store a list of files in the directory
}
// These are easy methods
public int getColumnCount() { return 6; }
// A constant for this model
public int getRowCount() { return filenames.length; }
// # of files in dir
// Information about each column
public String getColumnName(int col) { return columnNames[col]; }
public Class getColumnClass(int col) { return columnClasses[col]; }
// The method that must actually return the value of each cell
public Object getValueAt(int row, int col) {
File f = new File(dir, filenames[row]);
switch(col) {
Swing Prog.
Topics
JTable and TableModel 51

Example 3−3: Using JTable and TableModel (continued)
case 0: return filenames[row];
case 1: return new Long(f.length());
case 2: return new Date(f.lastModified());
case 3: return f.isDirectory() ? Boolean.TRUE : Boolean.FALSE;
case 4: return f.canRead() ? Boolean.TRUE : Boolean.FALSE;
case 5: return f.canWrite() ? Boolean.TRUE : Boolean.FALSE;
default: return null;
}
}
}
JTextComponent and HTML Text Display
The most complex component in all of Swing is the JTextComponent, which is a
power ful editor. It is part of the javax.swing.text package and generally is not
used directly. Instead, you typically use one of its subclasses, such as JTextField,
JPasswordField, JTextArea, or JEditorPane. The ﬁrst three of these components
ar e straightforward. They are for the entry of a single line of text, secret text such
as a password, and simple, unformatted, multiline text, respectively.
It is the JEditorPane component that really makes use of the full power of
JTextComponent. JEditorPane supports the display and editing of complex format-
ted text. In conjunction with the classes in the javax.swing.text.html and
javax.swing.text.rtf packages, JEditorPane can display and edit HTML and
RTF documents. The ability to display formatted text so easily is a very powerful
featur e. For example, the ability to display HTML documents makes it simple for a
Swing application to add online help based on an HTML version of the applica-
tion’s user manual. Furthermor e, for matted text is a professional-looking way for
an application to display its output to the user.
Because HTML has become so ubiquitous, we’ll focus on the display of HTML
documents with JEditorPane, Ther e ar e several differ ent ways to get a JEditor-
Pane to display an HTML document. If the desired document is available on the
network, the easiest way to display it is simply to pass an appropriate
java.net.URL object to the setPage() method of JEditorPane. setPage() deter-
mines the data type of the document and, assuming it is an HTML document,
loads it and displays it as such. For example:
editor.setPage(new java.net.URL("http://www.my.com/product/help.htm"));
If the document you want to display is in a local ﬁle or is available from some
kind of InputStream, you can display it by passing the appropriate stream to the
read() method of JEditorPane. The second argument to this method should be
null. For example:
InputStream in = new FileInputStream("help.htm");
editor.read(in, null);
52 Chapter 3 – Swing Programming Topics

Yet another way to display text in a JEditorPane is to pass the text to the set-
Text() method. Before you do this, however, you must tell the editor what type of
text to expect:
editor.setContentType("text/html");
editor.setText("<H1>Hello World!</H1>");
Calling setText() can be particularly useful when your application generates
HTML text on the ﬂy and wants to use a JEditorPane to display nicely formatted
output to the user.
Example 3-4 shows one such use of the JEditorPane. This example is an alterna-
tive to Example 3-3: it displays the contents of a directory in tabular form but uses
an HTML table instead of the JTable component. As a bonus, this example uses
HTML hyperlinks to allow the user to browse from one directory to the next. (If
you download and run the two examples, however, you’ll probably notice that the
JTable example is signiﬁcantly faster, since it does not have to encode the direc-
tory contents into HTML and then parse that HTML into a table.) Figure 3-9 shows
sample output from this example.
Figur e 3−9: The JEditorPane component displaying an HTML table
Example 3−4: Dynamically Generated HTML in JEditorPane
import javax.swing.*;
import javax.swing.event.*;
import java.io.*;
import java.util.Date;
/**
* This class implements a simple directory browser using the HTML
* display capabilities of the JEditorPane component
Swing Prog.
Topics
JT extComponent and HTML Text Display
53

Example 3−4: Dynamically Generated HTML in JEditorPane (continued)
**/
public class FileTableHTML {
public static void main(String[] args) throws IOException {
// Get the name of the directory to display
String dirname = (args.length>0)?args[0]:System.getProperty("user.home");
// Create something to display it in
final JEditorPane editor = new JEditorPane();
editor.setEditable(false); 
// we're browsing not editing
editor.setContentType("text/html"); 
// must specify HTML text
editor.setText(makeHTMLTable(dirname)); // specify the text to display
// Set up the JEditorPane to handle clicks on hyperlinks
editor.addHyperlinkListener(new HyperlinkListener() {
public void hyperlinkUpdate(HyperlinkEvent e) {
// Handle clicks; ignore mouseovers and other link-related events
if (e.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {
// Get the HREF of the link and display it.
editor.setText(makeHTMLTable(e.getDescription()));
}
}
});
// Put the JEditorPane in a scrolling window and display it
JFrame frame = new JFrame("FileTableHTML");
frame.getContentPane().add(new JScrollPane(editor));
frame.setSize(650, 500);
frame.setVisible(true);
}
// This method returns an HTML table representing the specified directory
public static String makeHTMLTable(String dirname) {
// Look up the contents of the directory
File dir = new File(dirname);
String[] entries = dir.list();
// Set up an output stream we can print the table to.
// This is easier than concatenating strings all the time.
StringWriter sout = new StringWriter();
PrintWriter out = new PrintWriter(sout);
// Print the directory name as the page title
out.println("<H1>" + dirname + "</H1>");
// Print an "up" link, unless we're already at the root
String parent = dir.getParent();
if ((parent != null) && (parent.length() > 0))
out.println("<A HREF=\"" + parent + "\">Up to parent directory</A><P>");
// Print out the table
out.print("<TABLE BORDER=2 WIDTH=600><TR>");
out.print("<TH>Name</TH><TH>Size</TH><TH>Modified</TH>");
out.println("<TH>Readable?</TH><TH>Writable?</TH></TR>");
for(int i=0; i < entries.length; i++) {
File f = new File(dir, entries[i]);
out.println("<TR><TD>" +
(f.isDirectory() ?
"<a href=\""+f+"\">" + entries[i] + "</a>" :
54 Chapter 3 – Swing Programming Topics

Example 3−4: Dynamically Generated HTML in JEditorPane (continued)
entries[i]) +
"</TD><TD>" + f.length() +
"</TD><TD>" + new Date(f.lastModified()) +
"</TD><TD align=center>" + (f.canRead()?"x":" ") +
"</TD><TD align=center>" + (f.canWrite()?"x":" ") +
"</TD></TR>");
}
out.println("</TABLE>");
out.close();
// Get the string of HTML from the StringWriter and return it.
return sout.toString();
}
}
Pluggable Look-and-Feel
One of the unique features of Swing is its pluggable look-and-feel (PLAF) architec-
tur e, which allows a Swing application to change its entire appearance with one or
two lines of code. The most common use of this feature is to give applications a
choice between the native platform look-and-feel and a new platform-independent
Java look-and-feel (also known as the Metal look-and-feel). Swing is distributed
with three look-and-feels: Metal and two look-and-feels that mimic the appearance
and behavior of the Windows and Motif (Unix/X) component toolkits. A look-and-
feel that mimics the Macintosh platform is available as a separate download. While
the Metal and Motif look-and-feels can be freely used, the Windows look-and-feel
is restricted for use only on Windows platform—for copyright reasons, it does not
run on any other operating system.
When a Swing application starts up, it reads the system property swing.default-
laf to determine the classname of the default look-and-feel. In most Java installa-
tions, this property is set to the default Java look-and-feel, implemented by the
class javax.swing.plaf.metal.MetalLookAndFeel. The end user can override this
default by using the -D switch on the command line when invoking the Java inter-
pr eter. For example, to run a Swing application using the Motif look-and-feel, a
user can type:
% java -Dswing.defaultlaf=com.sun.java.swing.plaf.motif.MotifLookAndFeel app
If the user is using a Windows operating system, he can start the application using
the Windows look-and-feel like this:
% java -Dswing.defaultlaf=com.sun.java.swing.plaf.windows.WindowsLookAndFeel app
When you write a Swing application, you can explicitly set the look-and-feel that
the application uses. To do this, simply call the static setLookAndFeel() method of
the UIManager class and specify the classname of the desired look-and-feel imple-
mentation. To make this even easier, UIManager deﬁnes a static method that
retur ns the classname of the default cross-platfor m look-and-feel (i.e., Metal) and
another that retur ns the classname of the look-and-feel that mimics the native
look-and-feel of the current platform. So, if you want your application to always
look like a native application, you can simply include this line of code in your
Swing Prog.
Topics
Pluggable Look-and-Feel
55

application, before it begins to create any GUI components:
UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
Or, if you want to force the application to use the cross-platfor m look-and-feel,
regardless of installation defaults and user prefer ences, you can use this line of
code:
UIManager.setLookAndFeel(UIManager.getCrossPlatformLookAndFeelClassName());
Note that calling
setLookAndFeel()
like this overrides the value of the
swing.defaultlaf pr operty, if the end user has set one. Of course, the command-
line syntax for setting that property is quite awkward and may be beyond the
capabilities of many end users. An alternative is to implement command-line
options in your own application that give the user a choice of look-and-feels. You
might set a native look-and-feel if the user speciﬁes a -nativelook ﬂag on the
command line, for example.
The easiest time to call the setLookAndFeel() method is at application start-up,
befor e any Swing components have been created. It is also possible to change the
look-and-feel of a running application, however. This means that you can allow
the user to change the current look-and-feel through a prefer ences dialog box, if
you are so inclined. When the user selects a new look-and-feel, you ﬁrst call set-
LookAndFeel() to install the new look-and-feel, and then you have to notify all of
the Swing components that a new look-and-feel is in effect and ask them to use it.
Fortunately, there is a convenience method to do this. Your code might look like
this:
// Set the new look-and-feel
UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName);
// Tell all components from main JFrame on down that LAF has changed
SwingUtilities.updateComponentTreeUI(myframe);
A dialog that allows the user to change the currently installed look-and-feel of a
running application should probably let the user choose among all the look-and-
feels that are installed on the system. An application can ﬁnd out the classnames
and human-readable names of all the installed look-and-feels on a given system by
calling the static getInstalledLookAndFeels() method of UIManager. In the imple-
mentation from Sun, this method retur ns either a default list of installed look-and-
feels or a list obtained from the swing.properties ﬁle of the installation.
Using Themes with the Metal Look-and-Feel
You can customize the colors and fonts of the default Java look-and-feel by sub-
classing the DefaultMetalTheme class that appears in the javax.swing.plaf.metal
package. When you create a custom subclass, you can specify the six differ ent
fonts and six differ ent colors used by the Metal look-and-feel. For example, you
might implement a large font theme for users who have difﬁculty reading the
default fonts used by Metal.
If you are feeling brave and want to second-guess the skilled designers who put
the Metal look-and-feel together, you can subclass the abstract MetalTheme class
dir ectly. This class deﬁnes many methods that retur n colors and fonts. All of these
56 Chapter 3 – Swing Programming Topics

methods, however, are implemented in terms of the six basic font methods and six
basic color methods of the DefaultMetalTheme class.
If you look at the DefaultMetalTheme API, you’ll notice that the font and color
methods do not retur n java.awt.Font and java.awt.Color objects as you would
expect. Instead, they retur n FontUIResource and ColorUIResource objects. Both of
these classes are part of the javax.swing.plaf package and are trivial subclasses
of the more familiar Font and Color classes. The only thing these subclasses do is
implement the UIResource inter face. But UIResource is a marker interface, with no
methods of its own. Thus, a FontUIResource is a Font object that also happens to
implement UIResource. Similarly, a ColorUIResource is both a Color object and a
UIResource object.
The currently installed look-and-feel assigns default values for many properties of
Swing components. A look-and-feel implementation needs to be able to distin-
guish between default values it has speciﬁed and programmer-supplied property
values. For this reason, all look-and-feel defaults, such as colors and fonts, must
implement the UIResource marker interface. For our purposes here, you can sub-
class
DefaultMetalTheme and use the
FontUIResource and
ColorUIResource
classes exactly as you would use normal Font and Color resources.
Once you have created your own theme by subclassing MetalTheme or Default-
MetalTheme, you can install it with code like this:
MetalLookAndFeel.setCurrentTheme(new MyCustomTheme());
If you are changing the current theme after having already created Swing compo-
nents, you also have to reinstall the MetalLookAndFeel and notify all the compo-
nents of the change:
UIManager.setLookAndFeel(new MetalLookAndFeel());
SwingUtilities.updateComponentTreeUI(myRootFrame);
Auxiliar y Look-and-Feels
If you’ve browsed the list of Swing packages, you’ve probably noticed
javax.swing.plaf.multi. This is the multiplexing look-and-feel. It allows one or
mor e auxiliary look-and-feels to be used in conjunction with a single primary
look-and-feel. The multiplexing look-and-feel is automatically used by a Swing
application if an auxiliary look-and-feel has been requested. An application can
request an auxiliary look-and-feel by calling the static UIManager method addAux-
iliaryLookAndFeel(), while an end user can do this by setting the swing.auxil-
iarylaf pr operty on a Java command line.
The primary purpose of auxiliary look-and-feels is for accessibility. For example, a
person with impaired vision might start up a Java application using the
-Dswing.auxiliarylaf= option to specify that the application should load a
scr een-r eader look-and-feel. Auxiliary look-and-feels can be used for other pur-
poses as well, of course. You might use an auxiliary look-and-feel to add audio
feedback to a user interface. Such a look-and-feel might produce an audible click
when the user clicks on a JButton, for example.
Swing Prog.
Topics
Pluggable Look-and-Feel
57

Swing is not shipped with any predeﬁned auxiliary look-and-feels. You can imple-
ment your own, of course, although explaining how to do so is beyond the scope
of this book.
Accessibility
The term accessibility refers to the architectural features of Swing that allow Swing
applications to interact with assistive technologies, such as a visual macro recorder
that allows users to automate repetitive point-and-click tasks or a screen reader.
To enable accessibility, every Swing component implements the Accessible inter-
face, which, like all accessibility-related classes, is part of the javax.accessibil-
ity package. This interface deﬁnes a single getAccessibleContext() method that
retur ns an AccessibleContext object for the component. The methods of Acces-
sibleContext export salient information about the component, such as a list of its
accessible children and its name, purpose, and description. An assistive technology
can use the tree of AccessibleContext objects to gather information about a GUI
and assist the user in interacting with that GUI.
A number of the AccessibleContext methods retur n objects that implement spe-
cialized interfaces to retur n speciﬁc types of accessibility information. For example,
if an accessible component repr esents a numeric value of some sort (say a
JSlider), the getAccessibleValue() method of its AccessibleContext object
retur ns an AccessibleValue object that provides more infor mation about that
value and allows the assistive technology to query and set the value.
The interfaces and classes of the javax.accessibility package provide methods
that allow an assistive technology to “read” a GUI. Many of the methods deﬁned
by these interfaces duplicate functionality already provided by Swing components.
The point, however, is that java.accessibility deﬁnes a standard API for interac-
tion between any assistive technology and any accessible application. In other
words, the accessibility API is not Swing speciﬁc. You can write JavaBeans and
other custom components so that they support accessibility. If you do, these com-
ponents automatically work with assistive technologies.
The details of the javax.accessibility package are of inter est to programmers
who are creating assistive technologies and developing accessible components or
JavaBeans. Unfortunately, the details of these tasks are beyond the scope of this
book.
Most of us are not developing assistive technologies and only rarely do we have to
cr eate accessible components. What we all want to do, however, is create accessi-
ble applications. Since all Swing components support accessibility, it is quite sim-
ple to create an accessible application with Swing. The key to supporting
accessibility is providing the necessary information that allows an assistive technol-
ogy to interpret your GUI for a user. The most commonly used example of an
assistive technology is a screen reader for the vision impaired. A screen reader
needs to be able to verbally describe a GUI to a user who cannot see it. In order
to do this, it needs to have names and descriptions for all the critical components
in your GUI.
58 Chapter 3 – Swing Programming Topics

The easiest way to assign a description to a component is to give it a tooltip. This
way, your accessibility information also serves as context-sensitive help for novice
users:
continue.setToolTipText("Click here to continue");
If, for some reason, you want to assign an accessible description to a component
without giving it a tooltip, you can use code like this:
continue.getAccessibleContext().setAccessibleDescription("Continue button");
It is also helpful to assistive technologies if you provide names for your various
components. A name should be a short human-readable string that uniquely iden-
tiﬁes the component, at least within the current window or dialog box. Buttons,
labels, menu items, and other components that display labels simply use those
labels as their accessible names. Other components need to have names assigned.
Her e is one way to do that:
JTextField zipcode = new JTextField();
zipcode.getAccessibleContext().setAccessibleName("zipcode");
In a GUI, important components that do not display their own labels are often
associated with JLabel components that serve to identify them. When this is the
case, you can use the setLabelFor() method of JLabel to set the accessible name
of the other component. The code might look like this:
JLabel zipcodeLabel = new JLabel("Zipcode");
JTextField zipcode = new JTextField();
zipcodeLabel.setLabelFor(zipcode);
By taking the simple step of assigning names and descriptions to your GUI com-
ponents, you ensure that your application can be interpreted by assistive technolo-
gies and successfully used by all users.
Custom Components
We’ll conclude this survey of Swing features with a quick look at what it takes to
write a custom Swing component. Creating a custom component is a matter of
subclassing an existing component and adding the new functionality you desire.
Sometimes this is a simple job of adding a minor new feature to an existing com-
ponent. At other times, you may want to create an entirely new component from
scratch. In this case, you’ll probably be subclassing JComponent, which is a bit
mor e complicated. The following sections brieﬂy explain the various things you’ll
need to consider when creating such a custom component. The best way to learn
to write your own Swing-style components is to study the source code of Swing
components, and since Sun makes this source code freely available, I encourage
you to examine it.
Proper ties
You need to decide what properties you want your component to export and
deﬁne accessor methods that allow them to be set and queried. If your component
repr esents or displays some kind of nontrivial data structure, consider repr esenting
Swing Prog.
Topics
Custom Components
59

the data in a separate model object. Deﬁne an interface for the model and a
default implementation of the interface.
If you think that other objects may be interested in property changes on your
component, have the set methods for those properties generate the events Prop-
ertyChangeEvent or ChangeEvent and include appropriate event listener registra-
tion methods in your component. This kind of notiﬁcation is often important if
you follow the Swing architectur e and divide the functionality of your component
among a component object, a model object, and a UI delegate object.
When a property is set on your component, the component may need to be
redrawn or resized as a result. You must keep this in mind when you write the
pr operty accessor methods for your component. For example, if you deﬁne a set-
Color() method, this method should call repaint() to request that the component
be repainted. (Painting the component is a separate topic that is discussed later.) If
you deﬁne a setFont() method and a change in font size causes the component
to requir e mor e (or less) space on the screen, you should call revalidate() to
request a relayout of the GUI. Note that the repaint() and revalidate() methods
add a repaint or relayout request to a queue and retur n right away. Therefor e, you
may call these methods freely without fear of inefﬁciency.
Events
You need to decide what kind of events your component generates. You can reuse
existing event and listener classes, if they suit your purposes, or you can deﬁne
your own. Add event listener registration and deregistration methods in your com-
ponent. You need to keep track of the register ed listeners, and you may ﬁnd the
javax.swing.event.EventListenerList helpful for this task. For each event lis-
tener registration method, it is common practice to deﬁne a protected method to
generate and ﬁre an appr opriate event to all register ed listeners. For example, if
your component has a public addActionListener() method, you may ﬁnd it use-
ful to deﬁne a protected fireActionEvent() method as well. This method calls the
actionPerformed() method of every register ed ActionListener object.
Constr uctors
It is customary to provide a no-argument constructor for a component. This is
helpful if you want your component to work with GUI builder tools, for example.
In addition, think about how you expect programmers to use your component. If
ther e ar e a few properties that are likely to be set in most cases, you should deﬁne
a constructor that takes values for these properties as arguments, to make the com-
ponent easier to use.
Drawing the Component
Almost every component has some visual appearance. When you deﬁne a custom
component, you have to write the code that draws the component on the screen.
Ther e ar e several ways you can do this. If you are creating an AWT component,
override the paint() method and use the Graphics object that is passed to it to do
whatever drawing you need to do.
60 Chapter 3 – Swing Programming Topics

For Swing components, the paint() method is also responsible for drawing the
border and the children of your component, so you should not override it directly.
Instead, override the paintComponent() method. This method is passed a Graphics
object, just as the paint() method is, and you use this Graphics object to do any
drawing you want. As we’ll see in Chapter 4, Graphics with AWT and Java 2D, you
can cast this Graphics object to a Graphics2D object if you want to use Java 2D
featur es when drawing your component. Keep in mind, however, that a Swing
component can be assigned an arbitrary border. Your paintComponent() method
should check the size of the border and take this value into account when
drawing.
When you deﬁne a custom component, you typically have only one look-and-feel
in mind, so you can hardcode this look-and-feel as part of the component class
itself. If you want your component to support the Swing pluggable look-and-feel
architectur e, however, you need to separate the drawing and event-handling tasks
out into a separate javax.swing.plaf.ComponentUI object. If you do this, you
should not override your component’s paintComponent() method. Instead, put the
painting functionality in the paint() method of the ComponentUI implementation.
In order to make this work, you have to override the getUIClassID(), getUI(),
setUI(), and updateUI() methods of JComponent.
Handling Events
Most components have some kind of interactive behavior and respond to user-
input events such as mouse clicks and drags and key presses. When you are creat-
ing a custom component, you must write the code that handles these events. The
Swing event-handling model was discussed in Chapter 2. Recall that the high-level
way to handle input events is to register appropriate event listeners, such as
MouseListener, MouseMotionListener, KeyListener, and FocusListener on your
component. If you are using a separate UI delegate object, this object should
implement the appropriate listener interfaces, and it should register itself with the
appr opriate event registration methods on the component when its installUI()
method is called.
If you are not using a UI delegate, your component class can handle events at the
lower level discussed in Chapter 2. To do this, you override methods such as pro-
cessMouseEvent(),
processMouseMotionEvent(),
processKeyEvent(), and
pro-
cessFocusEvent(). In this case, be sure to register your interest in receiving events
of the appropriate type by calling enableEvents() in your component’s initializa-
tion code.
Component Size
Most components have a natural or preferr ed size that often depends on the set-
tings of various component properties. Many components also have a minimum
size below which they cannot adequately display themselves. And some compo-
nents have a maximum size they wish to enforce. You must write the methods that
compute and retur n these sizes.
Swing Prog.
Topics
Custom Components
61

If you are using a UI delegate object, you should implement the getMinimum-
Size(), getPreferredSize(), and getMaximumSize() methods in the delegate. The
default JComponent methods call the delegate methods to determine these sizes if
the programmer using the component has not overridden the minimum, preferr ed,
or maximum sizes with her own speciﬁcations.
If you are not using a UI delegate object, you should override these three methods
in the component itself. Ideally, your methods should respect any sizes passed to
setMinimumSize(), setPreferredSize() and setMaximumSize(). Unfortunately, the
values set by these methods are stor ed in private ﬁelds of JComponent, so you
typically have to override both the get and the set methods.
Accessibility
It is a good idea to make your component accessible. In order to do this, your
component must implement the javax.accessibility.Accessible inter face and
its getAccessibleContext() method. This method must retur n an AccessibleCon-
text object that is customized for your component. You typically implement
AccessibleContext as an inner class of the component by extending JCompo-
nent.AccessibleJComponent or some subclass of that class. Depending on your
component, you may need to implement various other accessibility interfaces on
this inner class as well. Studying the accessibility code in existing Swing com-
ponents can be very helpful in learning how to write your own accessible
components. You might start, for example, with the source code for AbstractBut-
ton.AccessibleAbstractButton.
Miscellaneous Methods
JComponent deﬁnes a number of other methods that you can optionally override to
change aspects of a component’s behavior. If you take a look at the list of proper-
ties deﬁned by the JComponent API, you’ll notice that a number of these are read-
only properties (i.e., they do not deﬁne set methods). The only way to set the
value retur ned by one of these methods is to subclass the method. In general,
when you see a read-only property, you should consider it a candidate for sub-
classing. Here are a few methods of particular interest:
isOpaque()
If the component always ﬁlls its entire backgr ound, this method should retur n
true. If a component can guarantee that it completely paints itself, Swing can
per form some drawing optimizations. JComponent actually does deﬁne a set-
Opaque() method for this property, but your custom component may choose
to ignore setOpaque() and override isOpaque().
isOptimizedDrawingEnabled()
If your component has children and allows those children to overlap, it
should override this method to retur n false. Otherwise, leave it as is.
isFocusTraversable()
If your component wants to be included in focus traversal, it should override
this method to retur n true. If your component does not want to be included
in the keyboard navigation system, this method should retur n false.
62 Chapter 3 – Swing Programming Topics

isFocusCycleRoot()
If your component has children and wants to cycle focus among them, over-
ride this method to retur n true.
isManagingFocus()
If your component needs to receive the Ta b and Shift-Tab key events that are
nor mally handled by the focus manager, override this method to retur n true.
If you do, the focus manager uses Ctrl-Tab instead.
Swing Prog.
Topics
Custom Components
63

CHAPTER 4
Graphics with AWT
and Java 2D
Java 1.0 and Java 1.1 included basic graphics capabilities as part of the AWT
(Abstract Windowing Toolkit). In the Java 2 platform, these capabilities have been
gr eatly enhanced with the introduction of Java 2D. While Java 2D is part of the JFC
(the Java Foundation Classes), the Java 2D API is implemented in the same
java.awt package as the original Java graphics classes.
This chapter begins by documenting the original Java graphics model, which is still
requir ed for Java 1.1 applications, applets, and Personal Java applications. The
chapter then moves on to detail the enhanced features provided by Java 2D. This
chapter can provide only an introduction to the various features of Java 2D; for
mor e
complete information, see
Java 2D Graphics,
by
Jonathan Knudsen
(O’Reilly).
Graphics Before Java 2D
All graphics operations in Java are per formed using a java.awt.Graphics object.
The Graphics object serves three purposes:
•
It repr esents the drawing surface. A Graphics object is used to draw into a
java.awt.Component on the screen, to draw into an off-scr een java.awt.-
Image, or to send graphics to a printer.
•
It maintains the current state of graphics attributes, such as the current draw-
ing color, font, and clipping region.
•
It deﬁnes methods that perfor m various graphics operations, such as drawing
lines, rendering strings of text, and copying the content of Image objects onto
the drawing surface.
The graphics capabilities of Java before Java 2D can be neatly summarized by list-
ing the graphics attributes and operations supported by the Graphics object. Table
4-1 lists the attributes, and Table 4-2 lists the operations.
64

Table 4−1: Attributes of the Graphics Class
Attribute 
Type 
Description
Color
Color
Set with setColor().
Font
Font
Set with setFont(). Only a small number of
standard fonts are available.
Clipping region
Rectangle
In Java 1.1, set with setClip(). Use
clipRect() to set to the intersection of the
curr ent clipping region and a rectangle.
setClip() takes a Shape object, but prior to
Java 1.2, the clipping region is, in practice,
restricted to rectangles.
Origin
Point
Use translate() to move the origin. The
default origin is in the upper-left corner of
the drawing region, with X coordinates
incr easing to the right and Y coordinates
incr easing down.
Paint mode
boolean
setXORMode() puts the Graphics object into
the infrequently used XOR mode, while
setPaintMode() restor es the default drawing
mode.
Backgr ound color
Color
This attribute is used only by the clearRect()
method, and its value cannot be set. When
drawing into a Component, the background
color is the value of the background attribute
of the component. The value is undeﬁned
when drawing into off-scr een images.
Table 4−2: Operations of the Graphics Class
Operation 
Methods
Attributes Used
Line drawing
drawLine(),
drawPolyline()
color, origin, clip, paint mode
Shape drawing
drawArc(),
drawOval(),
drawPolygon(),
drawRect(),
drawRoundRect(),
draw3DRect()
color, origin, clip, paint mode
Graphics/
Java 2D
Graphics Before Java 2D
65

Table 4−2: Operations of the Graphics Class (continued)
Operation 
Methods
Attributes Used
Shape ﬁlling
fillArc(),
fillOval(),
fillPolygon(),
fillRect(),
fillRoundRect(),
fill3DRect()
color, origin, clip, paint mode
Text drawing
drawBytes(),
drawChars(),
drawString()
color, font, origin, clip, paint
mode
Image drawing (blitting)
drawImage()
(various versions)
origin, clip, paint mode
Clearing
clearRect()
origin, clip, background color
Line Drawing
An important point to notice in Table 4-1 is that there is no attribute for line width.
Prior to Java 2D, Java can only draw lines that are a single pixel wide. This is per-
haps the single largest limitation of the Java 1.0 and Java 1.1 graphics envi-
ronments.
Color s
Colors are repr esented by the java.awt.Color class. In Java 1.0 and Java 1.1, this
class repr esents colors in the RGB color space. It has constructors that allow you
to specify red, green, and blue color coordinates as integers or as ﬂoating-point
values. The class deﬁnes a static method that allows you to create a Color using
coordinates from the HSB (hue, saturation, brightness) color space. It also deﬁnes
a number of constants that repr esent colors by their common names, such as
Color.black and Color.white.
java.awt.SystemColor is a subclass of Color intr oduced in Java 1.1. The class has
no public constructor but deﬁnes a number of SystemColor constants that repr e-
sent colors used on the system desktop (for systems that support a system desktop
color palette). For example, SystemColor.textHighlight repr esents the color used
for highlighted text
Fonts
Fonts are repr esented with the java.awt.Font class. A Font object is created by
specifying the name, style, and point size of the desired font. In an attempt to pro-
mote platform independence, Java 1.0 supports only a handful of standard font
names. Java 1.1 supports the same fonts but provides new preferr ed symbolic
names for them. The fonts supported prior to Java 2D are listed in Table 4-3.
66 Chapter 4 – Graphics with AWT and Java 2D

Table 4−3: Font Names in Java 1.0 and Java 1.1
Java 1.0 Name
Pr eferr ed Name in Java 1.1
TimesRoman 
Serif
Helvetica 
SansSerif
Courier 
Monospaced
Symbol 
Symbol
Dialog 
Dialog
DialogInput 
DialogInput
Fonts can be displayed in any of four possible font styles, which are repr esented
by the symbolic constants listed in Table 4-4.
Table 4−4: Java Font Styles
Style 
Java Constant
plain
Font.PLAIN
italic
Font.ITALIC
bold
Font.BOLD
bolditalic
Font.BOLD + Font.ITALIC
Font sizes are speciﬁed in points. The Font() constructor accepts an integer argu-
ment, so fractional point sizes are not supported in Java 1.0 and 1.1. If the native
platfor m does not support scalable fonts, the retur ned font may have a differ ent
size than what you requested.
Font Metrics
If you need to ﬁgure out how big a piece of text will be, you can call the get-
FontMetrics() methods of a Graphics object and pass in the desired font. This
retur ns a FontMetrics object. The getHeight() method retur ns the line height for
the font, which can be further broken down into the font ascent and descent,
retur ned by getAscent() and getDescent(), respectively. To measur e the horizon-
tal dimension of text, use charWidth() and stringWidth().
Images
Images are repr esented by the java.awt.Image class. Working with images in Java
1.0 and Java 1.1 is a little tricky because the image processing model of those
releases is based on streaming image data being loaded across a network. This
tr eatment of images allows images to be partially displayed before they are fully
loaded, but makes working with images somewhat more dif ﬁcult.
Graphics/
Java 2D
Graphics Before Java 2D
67

All of the drawImage() methods of the Graphics objects requir e an java.awt.-
image.ImageObserver object. This is the object that handles things if you try to
draw an image that is not fully loaded. Fortunately, java.awt.Component imple-
ments ImageObserver, so you can use any Component or Applet object for this
method argument.
If are writing an applet and want to load a predeﬁned image from a URL, you can
use the getImage() method deﬁned by the java.applet.Applet class. This
method begins downloading the speciﬁed image and retur ns an Image object to
you immediately.
If you are writing a standalone application and want to load a predeﬁned image
fr om a ﬁle or URL, use one of the getImage() or createImage() methods of the
java.awt.Toolkit class:
Toolkit.getDefaultToolkit().getImage("myimage.gif");
Like the getImage() method of Applet, these Toolkit methods start loading the
image and immediately retur n an Image object. The image formats supported by
these Applet and Toolkit methods are implementation dependent. Most imple-
mentations support common formats, such as GIF (including transparent GIF),
JPEG, and XBM.
To ensur e that an Image object is fully loaded before you use it, you can create a
java.awt.MediaTracker object, pass your Image to its addImage() method, then
call the waitForAll() method.
To create an empty off-scr een image that you can draw into and copy pixels out
of, call the createImage() method of the Component with which you plan to use
the image and pass in the desired width and height of the image. To draw into the
image, you have to obtain a Graphics object by calling the getGraphics() method
of the image. Images created in this way are often used for double-buffering, to
pr oduce smoother animations or graphical updates.
The java.awt.image package contains classes that support rudimentary image pro-
cessing and ﬁltering. Java 2D implements more power ful image-pr ocessing tech-
niques, so the Java 1.0 model is not described here.
Ja va 2D Graphics Attributes and Operations
Java 2D dramatically expands the graphics capabilities of Java. It does this through
the java.awt.Graphics2D subclass of java.awt.Graphics. In Java 2, you can sim-
ply cast any Graphics object you are given to a Graphics2D object, and then you
can use the new features of Java 2D.
Table 4-5 and Table 4-6 summarize the new features of Java 2D by listing the
graphics attributes and graphics operations supported by the Graphics2D class.
68 Chapter 4 – Graphics with AWT and Java 2D

Table 4−5: Graphics Attributes of Java 2D
Attribute 
Type 
Description
For eground color
Color
Inherited from Graphics but
superseded by the ﬁll style attribute
and the Paint inter face.
Backgr ound color
Color
Inherited from Graphics but can now
be set and queried with setBack-
ground() and getBackground(). This
attribute is still used only by
clearRect().
Font
Font
Inherited from Graphics. All of the
system fonts are now available to
Java.
Clipping region
Shape
Inherited from Graphics. In Java 2D,
however, arbitrary Shape objects may
be used; the clipping region is no
longer restricted to only rectangular
shapes. A new method, which is
called clip(), sets the clipping region
to the intersection of the current
region and a speciﬁed Shape.
Line style
Stroke
A Stroke object speciﬁes how lines
ar e drawn. The BasicStroke
implementation supports line width,
dash pattern, and other attributes,
described in more detail later in the
chapter. Set the current line style with
setStroke().
Fill style
Paint
A Paint object speciﬁes how an area
is ﬁlled. Color implements this
inter face and ﬁlls with a solid color,
java.awt.TexturePaint ﬁlls with a
tiled image, and java.awt.Gra-
dientPaint ﬁlls with a color gradient.
Set the current ﬁll style with
setPaint().
Graphics/
Java 2D
Java 2D Graphics Attributes and Operations
69

Table 4−5: Graphics Attributes of Java 2D (continued)
Attribute 
Type 
Description
Compositing
Composite
A Composite object controls how the
color of a pixel is combined, or
composited, with the color of the
pixel on top of which it is drawn. The
default compositing operation
combines translucent pixels with the
pixels they overlay, letting the
overlaid colors “show through.” The
AlphaComposite class is an
implementation of Composite; it
per forms various types of
compositing, based on the alpha-
transpar ency of the pixels involved.
Transfor m
java.awt.geom.-
AffineTransform
Contr ols the translation, scaling,
rotation, and shearing of the
coordinate system. Set this attribute
with setTransform(), or modify the
curr ent transfor m with translate(),
scale(), rotate(), shear(), or
transform().
Hints
RenderingHints
A RenderingHints object allows a
pr ogram to express prefer ences about
various speed versus quality trade-offs
made by Java 2D. Most notably,
RenderingHints contr ols whether Java
2D perfor ms antialiasing. Set with
setRenderingHints(), setRendering-
Hint(), or addRenderingHints().
Table 4−6: Graphics Operations of Java 2D
Operation 
Methods
Description
Drawing
draw(), inherited
methods
draw() outlines an arbitrary
Shape. Uses the clip, transform,
str oke, paint, and composite
attributes.
Filling
fill(), inherited
methods
fill() ﬁlls an arbitrary Shape.
Uses the clip, transform, paint,
and composite attributes.
70 Chapter 4 – Graphics with AWT and Java 2D

Table 4−6: Graphics Operations of Java 2D (continued)
Operation 
Methods
Description
Hit detection
hit()
Tests whether a given rectangle
(in device coordinates) intersects
the interior or outline of an
arbitrary Shape. Uses the clip,
transfor m, and stroke attributes
when testing the outline of a
Shape.
Text drawing
drawString(),
drawGlyphVector(),
inherited methods
Java 2D deﬁnes text-drawing
methods that take String,
java.text.AttributedCharacter-
Iterator, and java.awt.font.-
GlyphVector arguments. Text
drawing uses the clip, transform,
font, paint, and composite
attributes. Note, however, that
AttributedCharacterIterator
objects supply their own fonts.
Image drawing
drawImage(),
drawRenderableImage(),
drawRenderedImage(),
inherited methods
Java 2D deﬁnes new image-
drawing methods that draw
special types of images.
java.awt.image.BufferedImage is
the most important new type.
These methods use the clip,
transfor m, and composite
attributes.
The Coordinate System
By default, Java 2D uses the same coordinate system as AWT. The origin is in the
upper-left corner of the drawing surface. X coordinate values increase to the right,
and Y coordinate values increase as they go down. When drawing to a screen or
an off-scr een image, X and Y coordinates are measur ed in pixels. When drawing
to a printer or other high-resolution device, however, X and Y coordinates are
measur ed in points instead of pixels (and there are 72 points in one inch).
It is instructive to consider in more detail how Java 2D draws to a high-resolution
device like a printer. The Java 2D drawing commands you issue express coordi-
nates on the printer paper in units of points. This coordinate system is referr ed to
as “user space.” However, dif ferent printers print at differ ent resolutions and sup-
port differ ent coordinate systems, so when drawing to a device like this, Java 2D
must convert your user-space coordinates into printer-speciﬁc, device-space coor-
dinates.
Graphics/
Java 2D
The Coordinate System
71

On a high-resolution printer, one point in user space may translate into 10 or more
pixels in the printer’s device space. In order to take full advantage of all this reso-
lution, you need to be able to use coordinates like 75.3 in user space. This brings
us to one of the big differ ences between the Java 2D coordinate system and the
AWT system: Java 2D allows coordinates to be expressed as ﬂoating-point num-
bers, instead of restricting them to integers. Throughout the Java 2D API, you’ll see
methods that accept float values instead of int values.
The distinction between user space and device space is valid even when we are
just drawing to the relatively low resolution screen. By default, when drawing to a
scr een or image, user space is the same as device space. However, the Graphics2D
class deﬁnes methods that allow you to trivially modify the default coordinate sys-
tem. For example, you can move the origin of the coordinate system with the
translate() method. The following code draws two identical lines at identical
positions. The ﬁrst line is drawn in the default coordinate system, while the sec-
ond is drawn after calling translate():
Graphics2D g;
// Assume this is already initialized
g.drawLine(100, 100, 200, 200);
// Draw in the default coordinate system
g.translate(100.0, 100.0);
// Move the origin down and to the right
g.drawLine(0, 0, 100, 100);
// Draw the same line relative to new origin
The translate() method is not all that interesting, and, in fact, a version of it
existed even before Java 2D. The Graphics2D class also deﬁnes scale(), rotate(),
and shear() methods that perfor m mor e power ful transfor mations of the coordi-
nate system.
By default, when drawing to the screen, one unit in user space corresponds to one
pixel in device space. The scale() method changes this. If you scale the coordi-
nate system by a factor of 10, one unit of user space corresponds to 10 pixels in
device space. Note that you can scale by differ ent amounts in the X and Y dimen-
sions. The following code draws the same simple line from 100, 100 to 200, 200
(using the default origin):
g.scale(2.0, 2.0);
g.drawLine(50, 50, 100, 100);
You can combine transformations. For example, suppose you are drawing into a
500-pixel-by-500-pixel window and you want to have the origin at the bottom left
of the window, with Y coordinates increasing as they go up, rather than as they go
down. You can achieve this with two simple method calls:
g.translate(0.0, 500.0);
// Move the origin to the lower left
g.scale(1.0, -1.0);
// Flip the sign of the coordinate system
rotate() is another powerful coordinate system transformation method. You spec-
ify an angle in radians, and the method rotates the coordinate system by that
amount. The direction of rotation is such that points on the positive X axis are
rotated in the direction of the positive Y axis. Although you typically do not want
to leave your coordinate system in a permanently rotated state, the rotate()
method is useful for drawing rotated text or other rotated graphics. For example:
g.rotate(Math.PI/4); 
// Rotate 45 degrees
g.drawString("Hello world", 300, 300)
// Draw text in this rotated position
g.rotate(-Math.PI/4); 
// Rotate back to normal
72 Chapter 4 – Graphics with AWT and Java 2D

Note that these calls to rotate() rotate the coordinate system about the origin.
Ther e is also a three-argument version of the method that rotates about a speciﬁed
point, which can often be more useful.
The ﬁnal transformation method deﬁned by Graphics2D is shear(). The effects of
this method are not as intuitive as the methods we’ve already discussed. After a
call to shear(), any rectangles you draw appear skewed, as parallelograms.
Any calls you make to translate(), scale(), rotate(), and shear() have a
cumulative effect on the mapping from user space to device space. This mapping
is encapsulated in a java.awt.geom.AffineTransform object and is one of the
graphics attributes maintained by a Graphics2D object. You can obtain a copy of
the current transform with getTransform(), and you can set a transform dir ectly
with setTransform(). setTransform() is not cumulative. It simply replaces the
curr ent user-to-device-space mapping with a new mapping:
AffineTransform t = g.getTransform(); // Save the current transform
g.rotate(theta); 
// Change the transform
g.drawRect(100, 100, 200, 200);
// Draw something
g.setTransform(t); 
// Restore the transform to its old state
AffineTransform is used in a number of places in the Java 2D API; we’ll discuss it
in more detail later in this chapter. Once you understand the details and some of
the math behind this class, you can deﬁne AffineTransform objects of your own
and pass them to setTransform().
Another use of AffineTransform objects is with the transform() method of
Graphics2D. This method modiﬁes the current coordinate system, just as trans-
late(), scale(), rotate(), and shear() do. transform() is much more general,
however. The AffineTransform object you pass to it can repr esent any arbitrary
combination of translation, scaling, rotation, and shearing.
Shapes
One of the most fundamental abstractions in Java 2D is the java.awt.Shape. This
inter face describes a shape, obviously. But note that the Java 2D deﬁnition of a
shape does not requir e the shape to enclose an area — a Shape object may repr e-
sent an open curve such as a line or parabola just as easily as it repr esents a
closed curve such as a rectangle or circle. If an open curve is passed to a graphics
operation (such as fill()) that requir es a closed curve, the curve is implicitly
closed by adding a straight-line segment between its end points. A Java 2D shape
is sometimes referr ed to as a “path,” because it describes the path a pen would
follow to draw the shape.
The Java 2D Graphics2D class deﬁnes some very fundamental operations on Shape
objects: draw() draws a Shape; fill() ﬁlls a Shape; clip() restricts the current
drawing region to the speciﬁed Shape; hit() tests whether a given rectangle falls
in or on a given shape. In addition, the AffineTransform class has methods that
allow Shape objects to be arbitrarily scaled, rotated, translated, and sheared.
Because the Shape inter face is used throughout Java 2D, these fundamental opera-
tions on shapes are quite powerful. For example, the individual glyphs of a font
Graphics/
Java 2D
Shapes 73

can be repr esented as Shape objects, meaning they can be individually scaled,
rotated, drawn, ﬁlled, and so on.
Java 2D contains a number of predeﬁned Shape implementations, many of which
ar e part of the java.awt.geom package. Note that some basic geometric shapes
have multiple Shape implementations, where each implementation uses a differ ent
data type to store coordinates. Table 4-7 lists these predeﬁned Shape implemen-
tations.
Table 4−7: Java 2D Shape Implementations
Shape 
Implementations
Rectangle
java.awt.Rectangle,
java.awt.geom.Rectangle2D.Float,
java.awt.geom.Rectangle2D.Double
Rounded rectangle
java.awt.geom.RoundRectangle2D.Float,
java.awt.geom.RoundRectangle2D.Double
Ellipse (and circle)
java.awt.geom.Ellipse2D.Float,
java.awt.geom.Ellipse2D.Double
Polygon
java.awt.Polygon
Line segment
java.awt.geom.Line2D.Float,
java.awt.geom.Line2D.Double
Arc (ellipse segment)
java.awt.geom.Arc2D.Float,
java.awt.geom.Arc2D.Double
Bezier curve (quadratic)
java.awt.geom.QuadCurve2D.Float,
java.awt.geom.QuadCurve2D.Double
Bezier curve (cubic)
java.awt.geom.CubicCurve2D.Float,
java.awt.geom.CubicCurve2D.Double
To draw a circle inside a square, for example, you can use code like this:
Graphics2D g;
// Initialized elsewhere
Shape square = new Rectangle2D.Float(100.0f, 100.0f, 100.0f, 100.0f);
Shape circle = new Ellipse2D.Float(100.0f, 100.0f, 100.0f, 100.0f);
g.draw(square);
g.draw(circle);
In addition to these basic predeﬁned shapes, the java.awt.geom package also con-
tains two powerful classes for deﬁning complex shapes. The Area class allows you
to deﬁne a shape that is the union or intersection of other shapes. It also allows
you to subtract one shape from another or deﬁne a shape that is the exclusive OR
of two shapes. For example, the following code allows you to ﬁll the shape that
results from subtracting a circle from a square:
Graphics2D g;
// Initialized elsewhere
Shape square = new Rectangle2D.Float(100.0f, 100.0f, 100.0f, 100.0f);
Shape circle = new Ellipse2D.Float(100.0f, 100.0f, 100.0f, 100.0f);
Area difference = new Area(square);
difference.subtract(circle);
g.fill(difference);
74 Chapter 4 – Graphics with AWT and Java 2D

The GeneralPath class allows you to describe a Shape as a sequence of line seg-
ments and Bezier curve segments. You create such a general shape by calling the
moveTo(), lineTo(), quadTo(), and curveTo() methods of GeneralPath. General-
Path also allows you to append entire Shape objects to the path you are deﬁning.
Bezier Curves
A Bezier curve is a smooth curve between two end points, with a shape described
by one or more contr ol points. Java 2D makes extensive low-level use of quadratic
and cubic Bezier curves. A quadratic Bezier curve uses one control point, while a
cubic Bezier curve uses two control points. There is some moderately complex
mathematics behind Bezier curves, but for most Java 2D programmers, an intuitive
understanding of these curves is sufﬁcient. Figure 4-1 shows three quadratic and
thr ee cubic Bezier curves and illustrates how the position of the control points
af fects the shape of the curve.
Tangent line
Bezier Curve
Control point
Endpoint
KEY
Figur e 4−1: Bezier curves
How Shapes Are Implemented
Java 2D can perfor m some very general operations on arbitrary Shape objects. In
order to make this possible, the Shape inter face exposes a quite general descrip-
tion of the desired shape. For example, the getBounds() and getBounds2D() meth-
ods retur n a bounding box for the shape. The various contains() methods test
whether a given point or rectangle is enclosed by the shape. The intersects()
methods test whether a given rectangle touches or overlaps the shape. These
methods enable clipping, hit detection, and similar operations.
The getBounds(), contains(), and intersects() methods are important, but they
do not say anything about how to draw the shape. This is the job of getPathIter-
ator(), which retur ns a java.awt.geom.PathIterator object that breaks a Shape
down into a sequence of individual line and curve segments that Java 2D can han-
dle at a primitive level. The PathIterator inter face is basically the opposite of
GeneralPath. While GeneralPath allows a Shape to be built of line and curve seg-
ments, PathIterator br eaks a Shape down into its component line and curve
segments.
Shape deﬁnes two getPathIterator() methods. The two-argument version of this
method retur ns a PathIterator that describes the shape in terms of line segments
only (i.e., it cannot use curves). This method is usually implemented with a
Graphics/
Java 2D
Shapes 75

java.awt.geom.FlatteningPathIterator, an implementation of PathIterator that
appr oximates the curved segments in a given path with multiple line segments.
The flatness argument to getPathIterator() is a measure of how closely these
line segments must approximate the original curve segments, where smaller values
of flatness imply a better approximation.
Stroking Lines
One of the new graphic attributes deﬁned by Java 2D is the java.awt.Stroke; it is
set with the setStroke() method of a Graphics2D object. The Stroke attribute is
used by Java 2D whenever it draws a line. Conceptually, the Stroke describes the
pen or brush that is used to draw the line: it controls all line-drawing attributes,
such as line width and dash pattern. Java 2D deﬁnes a single implementation of
the Stroke inter face, java.awt.BasicStroke, that is suitable for almost all line
drawing needs.
BasicStroke
A BasicStroke object encapsulates several differ ent line drawing attributes: the
line width, the dash pattern, the end cap style for the line, and the join style for
the line. You specify values for these attributes when you call the BasicStroke()
constructor. BasicStroke objects are immutable, so that they can be safely cached
and shared. This means, however, that they don’t have set() methods that allow
you to change the attribute values.
The line-width attribute speciﬁes (obviously) the width of the line. This line width
is measured in units of user space. If you are using the default coordinate system,
then user space equals device space, and line widths are measur ed in pixels. For
backward compatibility, the default line width is 1.0. Suppose you want to draw
the outline of a circle of radius 100, using a line that is 10 units wide. You can
code it like this:
Graphics2D g;
// Initialized elsewhere
Shape circle = new Ellipse2D.Float(100.0f, 100.0f,
// Upper-left corner
300.0f, 300.0f); // Width and height
g.setStroke(new BasicStroke(10.0f));
// Set line width
g.draw(circle); 
// Now draw it
The end-cap attribute speciﬁes how the ends of lines are drawn, or, mor e speciﬁ-
cally, what type of end caps are placed at the end of lines. There is no analogous
line attribute in AWT prior to Java 2D, as end caps are necessary only for lines that
ar e mor e than one-pixel wide. If you are not familiar with end caps, look at Figure
4-2, as they are best explained visually. This ﬁgure shows what lines look like
when drawn with each of the three possible end cap styles.
The BasicStroke.CAP_BUTT constant speciﬁes that the line should have no end
cap. The CAP_SQUARE constant speciﬁes a rectangular end cap that projects beyond
the end point of the line by a distance equal to half of the line width; this is the
default value for the end-cap attribute. CAP_ROUND speciﬁes a semicircular end cap,
with a radius equal to half of the line width.
76 Chapter 4 – Graphics with AWT and Java 2D

CAP_BUTT
CAP_SQUARE
CAP_ROUND
Figur e 4−2: BasicStroke end-cap styles
The join-style attribute is similar to the end-cap attribute, except that it applies to
the vertex where two lines join, rather than to the end of a line. Like the end-cap
attribute, the join-style attribute is necessary only with wide lines and is best
understood visually. Figure 4-3 illustrates this BasicStroke attribute. Note that the
join style attribute is used only when drawing a shape that includes multiple line
segments, not when two intersecting lines are drawn as separate shapes.
JOIN_BEVEL
JOIN_MITER
JOIN_ROUND
Figur e 4−3: BasicStroke join styles
The default join style is a mitered join, repr esented
by the
Basic-
Stroke.JOIN_MITER constant. This value speciﬁes that lines are joined by extend-
ing their outer edges until they meet. The JOIN_BEVEL constant speciﬁes that lines
ar e joined by drawing a straight line between the outside corners of the two lines,
while JOIN_ROUND speciﬁes that the vertex formed by the two lines should be
rounded, with a radius of half the line width. To use cap style and join style, you
can use code like this:
g.setStroke(new BasicStroke(5.0f,
// Line width
BasicStroke.CAP_ROUND, 
// End-cap style
BasicStroke.JOIN_ROUND)); // Vertex join style
When you use the JOIN_MITER style to join two lines that have a small angle
between them, the miter can become quite long. To avoid this situation, Basic-
Stroke includes another attribute known as the miter limit. If the miter would be
longer than this value times half of the line width, it is truncated. The default miter
limit is 10.0.
The dash pattern of a line is actually controlled by two attributes: the dash array
and the dash phase. The dash array is a float[] that speciﬁes the number of units
to be drawn followed by the number of units to be skipped. For example, to draw
Graphics/
Java 2D
Str oking Lines 77

a dashed line in which both the dashes and spaces are 25 units long, you use an
array like:
new float[] { 25.0f, 25.0f }
To draw a dot-dash pattern consisting of 21 on, 9 off, 3 on, and 9 off, you use this
array:
new float[] { 21.0f, 9.0f, 3.0f, 9.0f }
Figur e 4-4 illustrates these dashed-line examples. The end-cap style you specify is
applied to each dash that is drawn.
Figur e 4−4: BasicStroke dash patterns
If, for some reason, you want to draw a dashed line but do not want your line to
begin at the beginning of the dash pattern, you can specify the dash-phase
attribute. The value of this attribute speciﬁes how far into the dash pattern the line
should begin. Note, however, that this value is not an integer index into the dash
patter n array. Instead, it is a ﬂoating-point value that speciﬁes a linear distance.
To draw a dashed line, you must use the most complicated BasicStroke() con-
structor and specify values for all attributes. For example:
Stroke s = new BasicStroke(4.0f,
// Width
BasicStroke.CAP_SQUARE, 
// End cap
BasicStroke.JOIN_MITER, 
// Join style
10.0f, 
// Miter limit
new float[] {16.0f,20.0f}, // Dash pattern
0.0f); 
// Dash phase
How a Stroke Works
The BasicStroke class is sufﬁcient for most drawing needs, so it is unlikely that
you will ever need to implement the Stroke inter face yourself. Nevertheless, the
Stroke inter face deﬁnes only a single createStrokedShape() method, and it is
instructive to understand what this method does.
In Java 2D, ﬁlling an area is a more fundamental operation than drawing (or
str oking) the outline of a shape. The Stroke object is the link between the two
operations; it makes it possible to implement the draw() method using the fill()
method.
78 Chapter 4 – Graphics with AWT and Java 2D

Recall the code that we just used to draw the outline of a circle. The draw()
method has to draw the outline of the circle using only the fill() method. If it
simply calls fill() on the circle, it ends up creating a solid disk, not the outline of
a circle. So instead, draw() ﬁrst passes the circle to the createStrokedShape()
method of the BasicStroke object we’ve speciﬁed. createStrokedShape() retur ns
a new shape: a circle of radius 105, minus a concentric circle of radius 95. The
interior of this shape is the area between the two circles, a region that always has
a width of 10 units. Now draw() can call fill() on this stroked shape to draw the
10-unit-wide outline of the original circle. (We’ll discuss the fill() operation and
the graphics attributes that it uses in the next section.)
Paint
As we’ve just seen, the Java 2D Stroke attribute turns the task of drawing a line
into the task of ﬁlling an area. Prior to Java 2D, an area could be ﬁlled only with a
solid color, speciﬁed by passing a Color object to the setColor() method of a
Graphics object. In Java 2D, this color attribute has been generalized to a paint
attribute: you pass a Paint object to the setPaint() method of a Graphics2D
object. The speciﬁed Paint object is used to generate the pixel values used to ﬁll
ar eas.
The most common way to ﬁll an area, however, is still to use a solid color. So
another change in Java 2D is that the java.awt.Color class now implements the
java.awt.Paint inter face. All Color objects are per fectly legal Paint objects and
can be used to draw lines and ﬁll areas with a solid color.
Java 2D also deﬁnes two more complex Paint implementations. The java.awt.-
TexturePaint class uses a tiled image for its ﬁlling operations. The image is speci-
ﬁed as a java.awt.image.BufferedImage. This is a Java 2D simpliﬁcation of the
java.awt.Image class; we’ll discuss it in more detail later in the chapter. When you
cr eate a TexturePaint object, you must also specify a java.awt.geom.Rectangle2D
object (java.awt.Rectangle is a kind of Rectangle2D). The purpose of this rectan-
gle is to specify an initial position and horizontal and vertical repetition intervals
for the tiled image. Typically, you can just specify a rectangle based at 0,0 with the
same width and height as the image. If you are not using the default coordinate
system, things are a little trickier, since image dimensions are always measured in
pixels, but you must specify your rectangle dimensions in user-space coordinates.
The java.awt.GradientPaint class ﬁlls an area with a color gradient. The ﬁll color
varies linearly between a color C1 and a color C2, along the line between point P1
and point P2. You may also specify whether the gradient is cyclic or acyclic. If the
gradient is cyclic, the line between P1 and P2 is extended inﬁnitely in both direc-
tions, and the color cycles smoothly along this line from C1 to C2 and back to C1
again. If the gradient is deﬁned to be acyclic, however, the color remains ﬁxed at
C1 beyond P1 and at C2 beyond P2.
Graphics/
Java 2D
Paint 79

Her e’s an example of creating and using a GradientPaint:
Graphics2D g;
// Initialized elsewhere
Paint p = new GradientPaint(0, 0, Color.red, 100, 100, Color.pink, true);
g.setPaint(p);
g.fillRect(0, 0, 300, 300);
Both TexturePaint and GradientPaint objects are immutable: they have no set()
methods that allow their attributes to be changed. This is important because it
means that a Graphics2D object can use a Paint object without worrying about its
attributes being changed concurrently (i.e., the Graphics2D object does not have to
make a private copy of its Paint attribute).
Blending Colors with AlphaComposite
Although a Paint object is used to generate the colors used when drawing and ﬁll-
ing with Java 2D, these colors are not always the ﬁnal colors that end up displayed
on the screen. Another Java 2D attribute, the Composite object, controls the way in
which the colors being drawn combine with the colors that are alr eady visible on
the drawing surface.
A compositing operation combines the pixels of your drawing (the source pixels)
with the pixels of the drawing surface (the destination pixels) to produce a new,
composite set of pixels. Prior to Java 2D, you could use the setXORMode() method
of a Graphics object to produce a simple and very specialized kind of compositing
operation. Java 2D supports generalized compositing through the java.awt.Com-
posite inter face and its implementation, java.awt.AlphaComposite.
AlphaComposite per forms compositing based on alpha-transparency, letting you
paint with partially transparent colors that allow some of the background color to
show through. It also supports various Porter-Duf f compositing rules, as we’ll dis-
cuss shortly.
Tr ansparent Colors and the Alpha Channel
Befor e we can discuss the AlphaComposite class, you need to understand a bit
about the notion of transparent colors. With most low-end graphics systems, such
as the AWT before Java 2D, colors and images are opaque. When a line is drawn,
a shape is ﬁlled, or an image is render ed, that item totally obscures whatever pix-
els it is drawn on top of. An image is always repr esented as a rectangular array of
pixels. Sometimes, however, we want to use an image to display a nonrectangular
graphic. To allow this, some image formats support the notion of a transparent
color. When the image is drawn, the background shows through whatever pixels
ar e marked as transparent. Transpar ency is indicated with a bit mask: for each
pixel in the image, the graphics system uses one extra bit of information to specify
whether the pixel is transparent or opaque.
Bit mask transparency is an on-or-of f thing: a pixel is either fully transparent or
fully opaque. The notion of transparency can be generalized, however, to include
translucent pixels. Instead of simply associating 1 extra bit of data with each pixel,
the graphics system can associate 4, 8, 16, or some other number of bits with each
80 Chapter 4 – Graphics with AWT and Java 2D

pixel. This leads to 16, 256, or 65,536 possible levels of translucency, ranging from
fully transparent (0) to fully opaque (16, 256, or 65536). When you think about it,
these transparency bits are really no differ ent than the bits we use to repr esent the
red, green, and blue components of each pixel. The transparency bits are called
the alpha channel, while the color bits are called the red, green, and blue chan-
nels. When you are working with pixels repr esented by red, green, and blue com-
ponents, you are said to be using the RGB color space.
Transpar ent and translucent pixels do not actually exist. Inside a monitor, ther e ar e
red, green, and blue electron guns (or red, green, and blue LCD elements), but
ther e is no electron gun for the alpha channel. At the hardware level, a pixel is on
or it is off; it cannot be partially on. In order to give the appearance of trans-
par ency, the graphics system (Java 2D, in this case) has to blend (or composite)
transpar ent pixels with the pixels that are beneath them. When a source color Cs
that has a transparency of α is painted over a destination color Cd, the two colors
ar e combined to produce a new destination color Cd' with an equation like the
following:
Cd' = Cs*α + Cd*(1 - α)
For the purposes of this computation, the alpha value and the values of the red,
gr een, and blue channels are treated as ﬂoating-point numbers between 0.0 and
1.0, rather than 8- or 16-bit integers. The equation is shorthand: the computation is
actually perfor med independently on each of the red, green, and blue channels. If
Cs is fully opaque, α is 1 and Cd' is simply Cs. On the other hand, if Cs is fully
transpar ent, α is 0 and Cd' is simply Cd. If α is somewhere between fully opaque
and fully transparent, the resulting color Cd' is a combination of the source and
destination colors. The remarkable fact about combining colors with this simple
mathematical formula is that the resulting blended color is actually a visually con-
vincing simulation of translucent colors.
Drawing with Translucent Colors
You create an AlphaComposite object by calling its static getInstance() factory
method. (A factory method is provided instead of a constructor so that the Alpha-
Composite
class can cache and share
immutable
AlphaComposite
objects.)
getInstance() takes two arguments: a compositing mode and a float value
between 0.0 and 1.0 that speciﬁes an alpha-transparency value. The default Com-
posite object used by a Graphics2D object is an AlphaComposite cr eated like this:
AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 1.0f);
The AlphaComposite.SrcOver constant also refers to this default AlphaComposite
object.
The SRC_OVER compositing rule places the source color over the destination color
and blends them based on the transparency of the source, using the formula
shown in the previous section. I’ll explain this rule and the others supported by
AlphaComposite in more detail shortly. For now, you just need to know that
SRC_OVER is the most commonly used compositing rule and has the most intuitive
behavior.
Graphics/
Java 2D
Blending Colors with AlphaComposite
81

If you use the default AlphaComposite attribute of a Graphics2D object, you can
achieve color-blending effects by drawing with a translucent color. In Java 2D, the
Color class includes new constructors that allow you to create translucent colors
by including an alpha channel. For example, you can create and use a 50% trans-
par ent red color with code like the following:
Graphics2D g;
// Initialized elsewhere
Color c = new Color(1.0f, 0.0f, 0.0f, 0.5f);
// Red with alpha = 0.5
g.setPaint(c); 
// Use this translucent color
g.fillRect(100, 100, 100, 100);
// Draw something with it
This code draws a translucent red rectangle over whatever background previously
existed on the drawing surface repr esented by the Graphics2D object. As an aside,
it is worth noting that you can achieve interesting effects by using the Gradient-
Paint class to deﬁne color gradients between colors with differ ent levels of trans-
par ency.
Now suppose that you want to draw a complex, multicolor ﬁgure, and you want
to make it translucent. While you could allocate a bunch of translucent colors and
draw with them, there is an easier way. As we already discussed, when you create
an AlphaComposite object, you specify an alpha value for it. The alpha value of
any source pixel is multiplied by the alpha value associated with the AlphaCompos-
ite curr ently in effect. Since the default AlphaComposite object has an alpha value
of 1.0, this object does not affect the transparency of colors. However, by setting
the alpha value of an AlphaComposite object, we can draw using opaque colors
and opaque images and still achieve the effect of translucency. For example,
her e’s another way to draw a translucent red rectangle:
Graphics2D g;
// Initialized elsewhere
Color c = new Color(1.0f, 0.0f, 0.0f);
// Opaque red; alpha = 1.0
g.setPaint(c); 
// Use this opaque color
// Get and install an AlphaComposite to do transparent drawing
g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.5f);
g.fillRect(100, 100, 100, 100);
// Start drawing with it
The AlphaComposite Compositing Rules
The SRC_OVER compositing rule draws a possibly translucent source color over the
destination color. This is what we typically want to happen when we perfor m a
graphics operation. But the AlphaComposite object actually allows colors to be
combined according to seven other rules as well.
Befor e we consider the compositing rules in detail, there is an important point you
need to understand. Colors displayed on the screen never have an alpha channel.
If you can see a color, it is an opaque color. The precise color value may have
been chosen based on a transparency calculation, but, once that color is chosen,
the color resides in the memory of a video card somewhere and does not have an
alpha value associated with it. In other words, with on-screen drawing, destination
pixels always have alpha values of 1.0.
The situation is differ ent when you are drawing into an off-scr een image, however.
As you’ll see when we consider the Java 2D BufferedImage class later in this
82 Chapter 4 – Graphics with AWT and Java 2D

chapter, you can specify the desired color repr esentation when you create an off-
scr een image. By default, a BufferedImage object repr esents an image as an array
of RGB colors, but you can also create an image that is an array of ARGB colors.
Such an image has alpha values associated with it, and when you draw into the
images, the alpha values remain associated with the pixels you draw.
This distinction between on-screen and off-scr een drawing is important because
some of the compositing rules perfor m compositing based on the alpha values of
the destination pixels, rather than the alpha values of the source pixels. With on-
scr een drawing, the destination pixels are always opaque (with alpha values of
1.0), but with off-scr een drawing, this need not be the case. Thus, some of the
compositing rules only are useful when you are drawing into off-scr een images
that have an alpha channel.
To overgeneralize a bit, we can say that when you are drawing on-screen, you
typically stick with the default SRC_OVER compositing rule, use opaque colors, and
vary the alpha value used by the AlphaComposite object. When working with off-
scr een images that have alpha channels, however, you can make use of other
compositing rules. In this case, you typically use translucent colors and translucent
images and an AlphaComposite object with an alpha value of 1.0.
The compositing rules supported by AlphaComposite ar e a subset of the classic
Porter-Duf f compositing rules.* Each of the rules describes a way of creating a
new destination color Cd' by combining a source color Cs with the existing desti-
nation color Cd. The colors are combined according to a general formula, which is
applied independently to each of the red, green, and blue values of the color:
Cd' = Cs*Fs + Cd*Fd
In this formula, Fs and Fd ar e the fractions of the source and destination colors
used in the compositing operation, respectively. Each of the eight compositing
rules uses a differ ent pair of values for Fs and Fd, which is what makes each rule
unique.
As I already noted, with certain off-scr een images, destination pixels can have
alpha values. The new alpha value of a destination pixel is computed in the same
way as the new color value of that pixel (i.e., using the same fractions). If Ad is the
destination alpha value and As is the source alpha value, the resulting alpha value
is computed like this:
Ad' = As*Fs + Ad*Fd
Table 4-8 lists the compositing rules supported by AlphaComposite, using the
names deﬁned by that class. Don’t take the names of these constants at face value;
they can be misleading. The rule names that include the words IN and OUT make
the most sense if you consider the case of a 1-bit alpha channel. In this case, the
alpha channel is simply a bit mask, and an image has an inside where it is fully
opaque and an outside where it is fully transparent. In the more general case, with
a multibit alpha channel, these compositing operations behave more generally
* These rules were described originally in the paper “Compositing Digital Images,” by Porter and Duff,
published in SIGGRAPH, vol. 84.
Graphics/
Java 2D
Blending Colors with AlphaComposite
83

than their names imply. These rules also make the most sense when copying one
image into another; they typically are not useful for drawing lines, text, and so on.
Table 4-8 includes the Fs and Fd values, used in the preceding formulas that
deﬁne each of the compositing rules. These values are speciﬁed in terms of As, the
alpha value of the source pixel, and Ad, the alpha value of the destination pixel.
Note that the values of Fs and Fd listed here are for illustrative purposes, to help
you understand the compositing operations. The actual formulas for computing
composited colors depends on whether the source and destination color values
have been premultiplied by their alpha values.
Table 4−8: AlphaComposite Compositing Rules
Rule 
Fs
Fd 
Description
SRC_OVER 
As
1-As
By far the most commonly used compositing rule.
It draws the source on top of the destination. The
source and destination are combined based on the
transpar ency of the source. Where the source is
opaque, it replaces the destination. Where the
source is transparent, the destination is unchanged.
Wher e the source is translucent, the source and
destination colors are combined so that some of
the destination color shows through the translucent
source.
DST_OVER 
1-Ad 
Ad
This rule draws the source based on the
transpar ency of the destination, so that the source
appears to be underneath the destination. Where
the destination is opaque, it is left unchanged.
Wher e the destination is fully transparent, the
source is drawn. Wher e the destination is
translucent, the source and destination colors are
combined so that some of the source color shows
thr ough the translucent destination.
SRC 
1.0
0.0
The source replaces the destination color and its
alpha channel with the source color and its alpha
channel. In other words, the rule does a simple
replacement, ignoring the destination and doing no
color blending at all.
CLEAR 
0.0
0.0
This rule ignores both the source and the
destination. It clears the destination by setting it to
a fully transparent black.
84 Chapter 4 – Graphics with AWT and Java 2D

Table 4−8: AlphaComposite Compositing Rules (continued)
Rule 
Fs
Fd 
Description
SRC_IN 
Ad 
0
This rule draws the source color using the
transpar ency of the destination. Where the
destination is fully opaque, it is replaced with an
opaque version of the source. Where the
destination is fully transparent, it remains fully
transpar ent. Wher e the destination is translucent, it
is replaced with an equally translucent version of
the source. The color of the destination is never
blended with the color of the source.
SRC_OUT 
1-Ad
0
This is the inverse of the SRC_IN rule. It draws the
source color using the inverse of the destination
transpar ency. Wher e the destination is opaque, it
becomes transparent. Where the destination is
transpar ent, it is replaced with an opaque version
of the source. Where the destination is translucent,
it is replaced with an inversely translucent version
of the source.
DST_IN 
0
As
This rule ignores the color of the source, but
modiﬁes the destination based on the transparency
of the source. Where the source is transparent, the
destination becomes transparent. Where the source
is opaque, the destination is unmodiﬁed. Where
the source is translucent, the destination becomes
corr espondingly translucent.
DST_OUT 
0
1-As
This rule is the inverse of the DST_IN rule. It
ignor es the source color but modiﬁes the
destination based on the inverse of the source
transpar ency. Wher e the source is opaque, the
destination becomes transparent. Where the
source is transparent, the destination is left
unmodiﬁed. Where the source is translucent, the
destination is given the inverse translucency.
Finally, note that AlphaComposite also predeﬁnes constant AlphaComposite objects
that use each of these rules along with a built-in alpha value of 1.0. For example,
the
AlphaComposite.DstOver object uses the
AlphaComposite.DST_OVER com-
positing rule with an alpha value of 1.0. This object is the same as the object cre-
ated by:
AlphaComposite.getInstance(AlphaComposite.DST_OVER, 1.0f)
Remember that if you use an AlphaComposite object with an alpha value other
than the default 1.0, that alpha value is used to make the source colors more trans-
par ent befor e the rest of the compositing operation occurs.
Graphics/
Java 2D
Blending Colors with AlphaComposite
85

Render ing Hints
Another graphics attribute used by the Graphics2D class is java.awt.Rendering-
Hints. This class is a mapping (a java.util.Map) from a set of rendering hint
names to a set of rendering hint values. Unlike with other attributes, Graphics2D
deﬁnes more than one method to set the rendering hints attribute. setRendering-
Hints() speciﬁes a new set of hints that replaces the old set of hints, while
addRenderingHints() adds a set of hints to the existing set and setRendering-
Hint() sets the value for a single hint in the current set of hints.
Rendering hints are suggestions to Java 2D about how it should perfor m its ren-
dering. The RenderingHints class deﬁnes a number of constants whose names
begin with KEY_. These constants repr esent the kind of hints you can give. The
class also deﬁnes a number of constants whose names begin with VALUE_. These
ar e the legal values for the various hints. The names of the VALUE constants make
it clear with which hint KEY constant each value is associated.
The purpose of the hints is to allow you to request that Java 2D turn a particular
featur e, such as antialiasing, on or off. In addition, the hints allow you to suggest
what kind of speed versus quality trade-offs Java 2D should make. Remember that
these are hints and suggestions to Java 2D, not commands. Not all Java 2D imple-
mentations support all the hints, and differ ent implementations have differ ent
default values for the hints. Furthermor e, the meanings of the hints are not pre-
cisely deﬁned, so differ ent implementations may interpret the hints differ ently.
Suppose that you are writing an application that draws complex graphics. For slow
systems, you might want to support a draft mode that draws graphics quickly at
the expense of high-quality output. Your code might look like this:
public void paint(Graphics graphics) {
Graphics2D g = (Graphics2D)graphics;
if (draftmode) {
g.setRenderingHint(RenderingHints.KEY_RENDERING,
RenderingHints.VALUE_RENDER_SPEED);
g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
RenderingHints.VALUE_ANTIALIAS_OFF);
g.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,
RenderingHints.VALUE_TEXT_ANTIALIAS_OFF);
g.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS,
RenderingHints.VALUE_FRACTIONALMETRICS_OFF);
g.setRenderingHint(RenderingHints.KEY_COLOR_RENDERING,
RenderingHints.VALUE_COLOR_RENDER_SPEED);
g.setRenderingHint(RenderingHints.KEY_DITHERING,
RenderingHints.VALUE_DITHER_DISABLE);
}
}
Fonts and Text
As we’ve seen, fonts are repr esented in AWT by the java.awt.Font class. While
you can continue to use fonts in Java 1.2 exactly as you did in Java 1.1, Java 2D
has added a number of powerful new features related to fonts and text rendering
that you may want to take advantage of.
86 Chapter 4 – Graphics with AWT and Java 2D

Available Fonts
Java 1.0 and Java 1.1 support only a small set of fonts, speciﬁed by logical font
names. Although these logical fonts are guaranteed to be available on every plat-
for m, they are not guaranteed to look the same on every platform. In addition, the
lack of variety severely limits the design choices available to developers. The fonts
and their logical names were listed earlier in Table 4-3.
Java 1.2 allows an application to use any font installed on the native system and
refer to that font by its physical font name, instead of a logical font name. A physi-
cal font name is the actual name of a font, such as “Century Gothic” or “Lucida
Sans Bold.” To request a speciﬁc font, simply pass its physical name to the Font()
constructor. The Font() constructor always retur ns a valid Font object, even if the
font you have requested does not exist. If you need to check whether you got the
font you requested, call the getFontName() method of the retur ned font.
If you want to be sure that a font exists on the host system before attempting to
use it, you should ﬁrst query the system to ﬁnd out what fonts are installed. You
can do this with methods of the java.awt.GraphicsEnvironment object. The code
looks like this:
GraphicsEnvironment env = GraphicsEnvironment.getLocalGraphicsEnvironment();
Font[] allfonts = env.getAllFonts();
The getAllFonts() method retur ns an array of Font objects that repr esents all of
the fonts installed on the system. Each Font object in this array repr esents a font
that is one point high, so you have to scale the font (using deriveFont() as
explained shortly) before using it. Also, in the initial release of Java 1.2 at least, the
getAllFonts() method can take prohibitively long to retur n (65 seconds on my
Windows 95 system).
Another GraphicsEnvironment method, getAvailableFontFamilyNames(), retur ns
an array of font family names instead of an array of Font objects:
GraphicsEnvironment env = GraphicsEnvironment.getLocalGraphicsEnvironment();
String[] familynames = env.getAvailableFontFamilyNames();
This method retur ns relatively quickly and is therefor e safer to call than getAll-
Fonts(). Note that this method retur ns font family names (e.g., “Lucida Sans”), not
actual font face names (e.g., “Lucida Sans Oblique”). The good news is that you
can get away with specifying a font family name instead of a font face name when
you call the Font() constructor.*
Font Attributes
In Java 1.2, the Font class has a new constructor that is passed a java.util.Map
object that contains a set of font attributes. These attributes specify the desired
characteristics of the font; the Font() constructor tries to retur n a Font that
matches 
the 
attributes. 
Typically, 
you 
use 
a
java.util.Hashtable
or
java.util.Hashmap to hold your attribute values. The attribute names or keys are
* A bug in Java 1.2, 1.2d, and 1.2.2 prevents the Font() constructor from working with any nonlogical
font name unless you have previously queried the list of available fonts or font family names.
Graphics/
Java 2D
Fonts and Text 87

constants deﬁned in java.awt.font.TextAttribute. The important constants are
FAMILY, SIZE, WEIGHT, and POSTURE. The TextAttribute class also deﬁnes com-
monly used values for the WEIGHT and POSTURE attributes.
Tr ansfor ming Fonts
The Font class deﬁnes several deriveFont() methods that allow you to use a Font
object to create related Font objects. deriveFont() is typically used to retur n a
new Font object that repr esents an existing font at a differ ent size or in a differ ent
style. For example:
GraphicsEnvironment env = GraphicsEnvironment.getLocalGraphicsEnvironment();
String[] familynames = env.getAvailableFontFamilyNames();
Font regularFont = new Font("Century Schoolbook", Font.PLAIN, 12);
Font bigFont = regularFont.deriveFont(18.0f);
Font boldFont = regularFont.deriveFont(Font.BOLD);
Font bigBoldFont = regularFont.deriveFont(Font.BOLD, 24.0f);
When you are passing a point size to deriveFont(), be sur e to explicitly specify a
float value, such as the 18.0f constant in the preceding code, so that you do not
inadvertently call the version of deriveFont() that takes an integer-style constant.
You can also derive a transformed version of a Font object by passing in an arbi-
trary java.awt.geom.AffineTransform object. This technique allows you to arbi-
trarily rotate or skew any font, as we’ll discuss later in the chapter.
Te xt-Render ing Hints
The java.awt.RenderingHints class deﬁnes two hints that apply particularly to
text drawing. The ﬁrst controls antialiasing. Antialiasing is a technique used to
make the jagged edges of shapes, such as the glyphs of a font, look smoother. It is
implemented using translucent colors and compositing: when the edge of a shape
only partially covers a pixel, the color used to draw that pixel is given an alpha-
transpar ency value that corresponds to the amount of coverage. If a fully covered
pixel is drawn with an opaque color, a pixel that is only one-quarter covered is
drawn with an alpha value of .25. As you can imagine, antialiasing can be compu-
tationally intensive. However, the smoothing effect it achieves is signiﬁcant and is
particularly useful when drawing small amounts of text at large point sizes.
The ﬁrst text-related rendering hint simply requests antialiasing for text. If you
want text to be antialiased, set the KEY_TEXT_ANTIALIASING hint to VALUE_
TEXT_ANTIALIAS_ON. Ther e is also a more general hint, KEY_ANTIALIASING. Java 2D
deﬁnes a separate hint for text so that you can choose independently whether to
request antialiasing for text and other graphics.
The second text-related rendering hint controls the low-level positioning of charac-
ters of text. When Java 2D renders the shape of an individual font glyph, it caches
the render ed pixels for reuse. This technique dramatically speeds up text display.
However, the cached rendering is useful only if the glyph is always drawn at an
integral pixel position. By default, therefor e, most implementations of Java 2D
adjust character spacing so that the origin of each character falls evenly on an
integer-pixel coordinate. If you want to be able to position text at arbitrary
88 Chapter 4 – Graphics with AWT and Java 2D

ﬂoating-point positions, without forcing each character to the nearest device pixel,
set the KEY_FRACTIONALMETRICS hint to VALUE_FRACTIONALMETRICS_ON. Note, how-
ever, that the visual effect of setting this hint is rarely worth the computational
overhead it requir es.
Measur ing Te xt and Fonts
Sometimes you need to obtain measurement information about a font or measure
text before you can draw text. For example, to horizontally center a string of text,
you must be able to ﬁgure out how wide it is. To corr ectly draw multiple lines of
text, you need to be able to query the baseline position and the interline spacing
for the font. In Java 1.0 and Java 1.1, you obtained this information with the Font-
Metrics class (as described near the beginning of the chapter).
Java 2D provides another way to measure the width of a string of text. The Font
class deﬁnes several getStringBounds() methods that retur n the width and height
of a speciﬁed string as a Rectangle2D object. These methods allow widths to be
retur ned as ﬂoating-point numbers instead of integers and are ther efor e mor e
accurate than the stringWidth() method of FontMetrics. Each variant of get-
StringBounds() allows you to specify a string of text in a differ ent way. What
these methods have in common, however, is that they must all be passed a
FontRenderContext object. This object contains information needed to accurately
measur e text. It includes information about whether antialiasing and
fractional
metrics are being used, for example. You can obtain an appropriate FontRender-
Context by calling the getFontRenderContext() method of a Graphics2D object.
The Java 1.2 Font class also deﬁnes a set of getLineMetrics() methods that are
similar to the getStringBounds() methods. Each method takes a FontRenderCon-
text object and retur ns a java.awt.font.LineMetrics object that contains various
vertical metrics for the font. LineMetrics is similar to the older FontMetrics,
except that it retur ns pr ecise float values instead of approximate int values. get-
Height() retur ns the line height of the font. This value is the sum of the values
retur ned by getAscent(), getDescent(), and getLeading(). Ascent is the amount
of space above the baseline, descent is the space below the baseline, and leading
space is the empty interline spacing for the font. Other LineMetrics methods
retur n values that allow you to correctly underline and strike through text.
The following code shows how you can obtain important metrics for a string of
text, so that you can center it in a box:
Graphics2D g;
// Initialized elsewhere
Font f;
// Initialized elsewhere
String message = "Hello World!";
// The text to measure and display
Rectangle2D box;
// The display box: initialized elsewhere
// Measure the font and the message
FontRenderContext frc = g.getFontRenderContext();
Rectangle2D bounds = f.getStringBounds(message, frc);
LineMetrics metrics = f.getLineMetrics(message, frc);
float width = (float) bounds.getWidth();
// The width of our text
float lineheight = metrics.getHeight();
// Total line height
float ascent = metrics.getAscent();
// Top of text to baseline
Graphics/
Java 2D
Fonts and Text 89

// Now display the message centered horizontally and vertically in box
float x0 = (float) (box.getX() + (box.getWidth() - width)/2);
float y0 = (float) (box.getY() + (box.getHeight() - lineheight)/2 + ascent);
g.setFont(f);
g.drawString(message, x0, y0);
The getLineMetrics() methods all requir e a string to be speciﬁed, just as the get-
StringBounds() methods do. This is because a single font may have differ ent font
metrics for glyphs in differ ent writing systems. If you pass a string of Latin text,
you may get a differ ent LineMetrics object than you would if you supplied a
string of Chinese text, for example. If you pass in a string that mixes text from sev-
eral distinct writing systems, you get line metrics for only a preﬁx of that string.
The LineMetrics.getNumChars() method retur ns the length of this preﬁx.
Advanced Text Dra wing
The easiest way to display text in an application is to use a Swing component such
as a JLabel, JTextField, JTextArea, or JEditorPane. Sometimes, however, you
have to draw text explicitly, such as when you are implementing a custom Swing
component.
The easiest way to draw text is with the drawString() method of Graphics or
Graphics2D. drawString() is actually a more complex method than you might
think. It works by ﬁrst taking the characters of a string and converting them to a
list of glyphs in a font. There is not always a one-to-one correspondence between
characters and glyphs, however, and font encodings usually do not match the Uni-
code encoding used for characters. Next, the method must obtain the measure-
ments of each glyph in the list of glyphs and position it individually. Only after
these steps can the method actually perfor m the requested string drawing
operation.
If you are drawing a string repeatedly, you can optimize this process by ﬁrst con-
verting the string of characters into a java.awt.font.GlyphVector.* This converts
characters to glyphs and calculates the appropriate position for each glyph. Then,
to draw the string, you simply pass the resulting glyph vector to the drawGlyph-
Vector() method of a Graphics2D object. Your code might look like this:
Graphics2D g;
Font f;
GlyphVector msg = f.createGlyphVector(g.getFontRenderContext(), "Hello");
g.drawGlyphVector(msg, 100.0f, 100.0f);
This technique is useful only if you expect to be drawing the same string repeat-
edly. The optimization occurs because the string is converted to glyphs only once,
instead of being converted each time you call drawString().
The GlyphVector class has a number of methods that are useful for other pur-
poses. Once you have created a GlyphVector, you can call getOutline() to obtain
a Shape that repr esents the original string or getGlyphOutline() to get the Shape
* The drawString() method is typically already highly optimized for drawing basic ASCII or Latin-1 text
without antialiasing. Using a GlyphVector may actually slow down the drawing process.
90 Chapter 4 – Graphics with AWT and Java 2D

of a single glyph. You can also call getGlyphMetrics() to obtain a GlyphMetrics
object that contains detailed metrics for an individual glyph.
Two other methods, setGlyphPosition() and setGlyphTransform(), are designed
to let you set the position and transform for individual glyphs. For example, you
might use setGlyphPosition() to increase the interletter spacing of a glyph in a
GlyphVector in order to implement ﬁll-justiﬁcation. In the initial release of Java
1.2, however, these methods are not implemented. If you want to handle the low-
level layout of glyphs, one approach is to implement your own subclass of the
abstract GlyphVector class.
A GlyphVector object can repr esent only glyphs from a single font; the default
implementation repr esents only glyphs that appear on a single line of text. If you
want to repr esent a single line of multifont text, you can use a java.awt.-
font.TextLayout object. And if you want to work with multiline text, you can use
java.awt.font.LineBreakMeasurer to break a paragraph of multifont text into
multiple TextLayout objects, each repr esenting a single line of text.
TextLayout is a powerful class for displaying multifont text. It supports bidirec-
tional text layout, such as when left-to-right English text is mixed with right-to-left
Hebr ew or Arabic text or when right-to-left Hebrew letters are mixed with left-to-
right Hebrew numbers. Once you’ve created a TextLayout object, you can draw
the text it repr esents by calling its draw() method, specifying a Graphics2D object
and a position.
The TextLayout object does more than simply draw text. Once the text is drawn, it
also provides methods that applications can use to allow a user to interact with the
text. If the user clicks on the text, the TextLayout has a method that allows you to
deter mine which character was clicked on. If you want to highlight portions of the
text, you can tell the TextLayout the ﬁrst and last characters to be highlighted, and
it retur ns a Shape that repr esents the region to be highlighted. Similarly, if you
want to display an insertion cursor within the text, you can specify the character
position, and the TextLayout retur ns a Shape that you can draw to display the cur-
sor. Although these methods may seem trivial, they in fact handle all the nontrivial
complexities of multifont and bidirectional text, making TextLayout a power ful
class for certain applications.
You can create a TextLayout object by specifying a String, a Font, and a
FontRenderContext. However, a TextLayout cr eated in this way can repr esent only
single-font text. To display multifont text, you must use a java.text.Attributed-
CharacterIterator to repr esent the text. The attributes associated with the text
should be java.awt.font.TextAttribute constants, such as TextAttribute.FONT.
The easiest way to create an
AttributedCharacterIterator is to create a
java.text.AttributedString, specify attributes with its addAttribute() method,
and then get an iterator for it with its getIterator() method. The java.text API
is covered in Java in a Nutshell, not in this book.
Te xt Art with Font Glyphs
As I mentioned earlier, the GlyphVector class allows you to obtain a Shape object
that repr esents the outline of a single glyph or a string of glyphs. This is a power-
ful feature of Java 2D that allows you to produce sophisticated text art. The Shape
Graphics/
Java 2D
Fonts and Text 91

object retur ned by the getOutline() or getGlyphOutline() method of Glyph-
Vector can be used in the same way that you use any other Shape object. Use the
draw() method of Graphics2D to draw the outline of the glyph or glyphs. Use
fill() to ﬁll the glyphs with an arbitrary Paint. You can transform the glyph
shapes by scaling, rotating, and skewing them and you can even use them to per-
for m clipping and hit detection.
Buffered Images
Java 2D introduces a new java.awt.Image subclass, java.awt.image.BufferedIm-
age. BufferedImage repr esents image data that is present in memory, unlike Image,
which typically repr esents str eaming image data being transferred over a network.
Java 2D also provides powerful image-processing classes that operate on
BufferedImage objects and are much simpler to use than the ImageFilter class of
Java 1.0.
As we discussed at the beginning of the chapter, Java knows how to read images
in commonly used formats from ﬁles and URLs. You can use the getImage()
method of either Applet() or Toolkit to retrieve an Image, but the image data
may not have been fully read when the method retur ns. If you want to ensure that
the image is fully loaded, you have to use a java.awt.MediaTracker. Note also
that both of these methods retur n read-only Image objects, rather than read/write
BufferedImage objects.
If you are writing a Swing application, an easy way to load an image is with the
javax.swing.ImageIcon class. This class automatically waits until the image is fully
loaded. For example:
Image myimage = new javax.swing.ImageIcon("myimage.gif").getImage();
As useful as ImageIcon is, its getImage() method still retur ns an Image object, not
a BufferedImage object.
Obtaining a BufferedImage
To create an empty BufferedImage object, call the createImage() method of a
Component. This method was ﬁrst introduced in Java 1.0; it retur ns an Image object.
In Java 1.2, however, the retur ned Image object is always an instance of Buffered-
Image, so you can safely cast it. After you have created an empty BufferedImage,
you can call its createGraphics() method to obtain a Graphics2D object. Then use
this Graphics2D object to draw image data from an Image object into your
BufferedImage object. For example:
javax.swing.JFrame f;
// Initialized elsewhere
// Create an image, and wait for it to load
Image i = javax.swing.ImageIcon("myimage.gif").getImage();
// Create a BufferedImage of the same size as the Image
BufferedImage bi = (BufferedImage)f.createImage(i.getWidth(f),i.getHeight(f));
92 Chapter 4 – Graphics with AWT and Java 2D

Graphics2D g = bi.createGraphics();
// Get a Graphics2D object
g.drawImage(i, 0, 0, f);
// Draw the Image data into the BufferedImage
Note that we must pass an ImageObserver object to the getWidth(), getHeight()
and drawImage() methods in this code. All AWT components implement ImageOb-
server, so we use our JFrame for this purpose. Although we could have gotten
away with passing null, this is exactly the sort of complexity that the BufferedIm-
age API allows us to avoid.
Sun’s 
implementation 
of 
Java 
1.2 
ships 
with 
a 
package 
named
com.sun.image.codec.jpeg that contains classes for reading JPEG image data
dir ectly into BufferedImage objects and for encoding BufferedImage image data
using the JPEG image format. Although this package is not part of the core Java 2
platfor m, most Java implementations will probably contain these classes. You can
use this package to read JPEG ﬁles with code like this:
import java.io.*;
import com.sun.image.codec.jpeg.*;
FileInputStream in = new FileInputStream("myimage.jpeg");
JPEGImageDecoder decoder = JPEGCodec.createJPEGDecoder(in);
BufferedImage image = decoder.decodeAsBufferedImage();
in.close();
Drawing a BufferedImage
A BufferedImage is a kind of Image, so you can do anything with a BufferedImage
that you can do with an Image. For instance, the Graphics class deﬁnes a number
of methods for drawing Image objects. Some of these methods take only an X and
a Y coordinate at which to draw the image and simply draw the image at its origi-
nal size. Other drawImage() methods also take a width and a height and scale the
image as appropriate.
Java 1.1 introduced more sophisticated drawImage() methods that take coordinates
that specify a destination rectangle on the drawing surface and a source rectangle
within the image. These methods map an arbitrary subimage onto an arbitrary
rectangle of the drawing surface, scaling and ﬂipping as necessary. Each of these
drawImage() methods comes in two versions, one that takes a background color
argument and one that does not. The background Color is used if the Image con-
tains transparent pixels.
Since all the drawImage() methods of the Graphics object operate on Image
objects instead of BufferedImage objects, they all requir e a Component or other
ImageObserver object to be speciﬁed.
In Java 2D, the Graphics2D object deﬁnes two more drawImage() methods. One of
these methods draws an Image object as modiﬁed by an arbitrary AffineTransform
object. As we’ll see a bit later, an AffineTransform object can specify a position,
scaling factor, rotation, and shear.
The other drawImage() method of Graphics2D actually operates on a Buffered-
Image object. This method processes the speciﬁed BufferedImage as speciﬁed by a
BufferedImageOp object and then draws the processed image at the speciﬁed posi-
tion. We’ll talk about image processing with BufferedImageOp objects in more
Graphics/
Java 2D
Buf fered Images
93

detail shortly. Since this drawImage() method operates on a BufferedImage object
instead of an Image object, it does not requir e an ImageObserver argument.
Finally, the Graphics2D class deﬁnes a drawRenderedImage() method. Buffered-
Image implements the RenderedImage inter face, so you can pass a BufferedImage
to this method, along with an arbitrary AffineTransform that speciﬁes where and
how to draw it.
Drawing into a BufferedImage
As I mentioned earlier, the createGraphics() method of a BufferedImage retur ns
a Graphics2D object that you can use to draw into a BufferedImage. Anything you
can draw on the screen, you can draw into a BufferedImage. One common reason
to draw into a BufferedImage object is to implement double-buffering. When per-
for ming animations or other repetitive drawing tasks, the erase/redraw cycle can
cause ﬂickering. To avoid this, do your drawing into an off-scr een BufferedImage
and then copy the contents of the image to the screen all at once. Although this
requir es extra memory, it can dramatically improve the appearance of your
pr ograms.*
Manipulating Pixels of a BufferedImage
The Image class deﬁnes very few methods, so about all you can do with an Image
object is query its width and height. The BufferedImage class, by contrast, deﬁnes
quite a few methods. Most of these are requir ed by interfaces that BufferedImage
implements. A few important ones, however, allow pixel-level manipulation of
images.
For example, getRGB() retur ns the image pixel at the speciﬁed X and Y coordi-
nates, while setRGB() sets the pixel at the speciﬁed coordinates. Both of these
methods repr esent the pixel value as an int that contains 8-bit red, green, and
blue color values. Other versions of getRGB() and setRGB() read and write rectan-
gular arrays of pixels into int arrays. getSubimage() is a related method that
retur ns a rectangular region of the image as a BufferedImage.
Inside a BufferedImage
Most applications can use the BufferedImage class without ever caring what is
inside a BufferedImage. However, if you are writing a program that perfor ms low-
level image-data manipulation, such as reading or writing image data from a ﬁle,
you need to know more. The complete details of the image architectur e ar e
beyond the scope of this book; this section explains the basics in case you want to
explor e on your own.
* Recall that Swing components, and custom components subclassed from Swing components, automati-
cally support double-buffering.
94 Chapter 4 – Graphics with AWT and Java 2D

The image data of a BufferedImage is stored in a java.awt.image.Raster object,
which can be obtained with the getData() method of BufferedImage. The Raster
itself contains two parts: a java.awt.image.DataBuffer that holds the raw image
data and a java.awt.image.SampleModel object that knows how to extract individ-
ual pixel values out of the DataBuffer. DataBuffer supports a wide variety of for-
mats for image data, which is why a Raster object also needs a SampleModel.
The Raster object of a BufferedImage stor es the pixel values of an image. These
pixel values may or may not correspond directly to the red, green, and blue color
values to be displayed on the screen. Therefor e, a BufferedImage object also con-
tains a java.awt.image.ColorModel object that knows how to convert pixel values
fr om the Raster into Color objects. A ColorModel object typically contains a
java.awt.color.ColorSpace object that speciﬁes the repr esentation of color com-
ponents.
Processing a BufferedImage
The
java.awt.image package deﬁnes ﬁve powerful implementations of the
BufferedImageOp inter face that perfor m various types of image-processing opera-
tions on BufferedImage objects. The ﬁve implementations are described brieﬂy in
Table 4-9.
Table 4−9: Java 1.2 Image-Processing Classes
Class 
Description
AffineTransformOp
Per forms an arbitrary geometric transformation — speciﬁed
by an AffineTransform—on an image. The transform can
include scaling, rotation, translation, and shearing in any
combination. This operator interpolates pixel values when
needed, using either a fast, nearest-neighbor algorithm or
a slower, higher-quality bilinear interpolation algorithm.
This class cannot process images in place.
ColorConvertOp
Converts an image to a new java.awt.color.ColorSpace.
It can process an image in place.
ConvolveOp
Per forms a powerful and ﬂexible type of image processing
called convolution, which is used for blurring or
sharpening images and perfor ming edge detection, among
other things. ConvolveOp uses a java.awt.image.Kernel
object to hold the matrix of numbers that specify exactly
what convolution operation is perfor med. Convolution
operations cannot be perfor med in place.
Graphics/
Java 2D
Buf fered Images
95

Table 4−9: Java 1.2 Image-Processing Classes (continued)
Class 
Description
LookupOp
Pr ocesses the color channels of an image using a lookup
table, which is an array that maps color values in the
source image to color values in the new image. The use of
lookup tables makes LookupOp a very ﬂexible image-
pr ocessing class. For example, you can use it to brighten
or darken an image, to invert the colors of an image, or to
reduce the number of distinct color levels in an image.
LookupOp can use either a single lookup table to operate
on all color channels in an image or a separate lookup
table for each channel. LookupOp can be used to process
images in place. You typically use LookupOp in conjunction
with java.awt.image.ByteLookupTable.
RescaleOp
Like LookupOp, RescaleOp is used to modify the values of
the individual color components of an image. Instead of
using a lookup table, however, RescaleOp uses a simple
linear equation. The color values of the destination are
obtained by multiplying the source values by a constant
and then adding another constant. You can specify either a
single pair of constants for use on all color channels or
individual pairs of constants for each of the channels in
the image. RescaleOp can process images in place.
To use a BufferedImageOp, simply call its filter() method. This method pro-
cesses or ﬁlters a source image and stores the results in a destination image. If no
destination image is supplied, filter() cr eates one. In either case, the method
retur ns a BufferedImage that contains the processed image. As noted in Table 4-9,
some implementations of BufferedImageOp can process an image “in place.” These
implementations allow you to specify the same BufferedImage object as both the
source and destination arguments to the filter() method.
To convert a color image to grayscale, you can use ColorConvertOp as follows:
import java.awt.image.*;
import java.awt.color.*;
ColorConvertOp op = new ColorConvertOp(ColorSpace.getInstance(CS_GRAY), null);
BufferedImage grayImage = op.filter(sourceImage, null);
To invert the colors in an image (producing a photographic negative effect), you
might use a RescaleOp as follows:
RescaleOp op = new RescaleOp(-1.0f, 255f, null);
BufferedImage negative = op.filter(sourceImage, null);
To brighten an image, you can use a RescaleOp to linearly increase the intensity of
each color value. More realistic brightening effects requir e a nonlinear transform,
however. For example, you can use a LookupOp to handle brightening based on
96 Chapter 4 – Graphics with AWT and Java 2D

the square-r oot function, which boosts midrange colors more than colors that are
dark or bright:
byte[] data = new byte[256];
for(int i = 0; i < 256; i++)
data[i] = (byte)(Math.sqrt((float)i/255.0) * 255);
ByteLookupTable table = new ByteLookupTable(0, data);
LookupOp op = new LookupOp(table, null);
BufferedImage brighterImage = op.filter(sourceImage, null);
You can blur an image using a ConvolveOp. When processing an image by convo-
lution, a pixel value in the destination image is computed from the corresponding
pixel value in the source image and the pixels that surround that pixel. A matrix of
numbers known as the ker nel is used to specify the contribution of each source
pixel to the destination pixel. To per form a simple blurring operation, you might
use a kernel like this to specify that the destination pixel is the average of the
source pixel and the eight pixels that surround that source pixel:
0.1111 0.1111 0.1111
0.1111 0.1111 0.1111
0.1111 0.1111 0.1111
Note that the sum of the values in this kernel is 1.0, which means that the destina-
tion image has the same brightness as the source image. To per form a simple blur,
use code like this:
Kernel k = new Kernel(3, 3, new float[] { .1111f, .1111f, .1111f,
.1111f, .1111f, .1111f,
.1111f, .1111f, .1111f });
ConvolveOp op = new ConvolveOp(k);
BufferedImage blurry = op.filter(sourceImage, null);
Tr ansfor mations with AffineTransfor m
As we discussed earlier when we considered the Java 2D coordinate system, the
java.awt.geom.AffineTransform class repr esents a general mapping from one
coordinate system to another. AffineTransform deﬁnes a general coordinate-
system transformation that can include translation, scaling, rotation, and shearing.
Setting Up an AffineTransfor m
One of the easiest ways to obtain an AffineTransform object is to use one of the
static methods deﬁned by AffineTransform. For example, getScaleInstance()
retur ns an instance of AffineTransform that repr esents a simple scaling transfor-
mation.
Another way to get an AffineTransform is with the AffineTransform() construc-
tor, of course. The no-argument version of the constructor retur ns an Affine-
Transform that repr esents the identity transform—that is, no transform at all. You
can modify this empty transform with a number of methods. Note that Affine-
Transform deﬁnes several other constructors, but we have to wait to discuss them
until after we’ve discussed the mathematics that underlie AffineTransform.
Graphics/
Java 2D
Transfor mations with AfﬁneT ransform
97

Once you have obtained an AffineTransform object, you can modify it with meth-
ods just like the methods deﬁned by Graphics2D. Each of the translate(),
scale(), rotate(), and shear() methods modiﬁes an AffineTransform by adding
the speciﬁed transformation to it. Note that there are two versions of rotate().
One rotates around the origin and the other rotates around a speciﬁed point; both
use angles speciﬁed in radians. Remember that calls to these four methods are
cumulative: you can build up a complex transformation as a combination of trans-
lation, scaling, rotation, and shearing.
AffineTransform also deﬁnes noncumulative methods. setToTranslation(), set-
ToScale(), setToRotation(), and setToShear() set an AffineTransform to a sin-
gle transform, replacing whatever transform was previously contained by the
AffineTransform.
Perfor ming Tr ansfor mations
Once you have created and initialized an AffineTransform object, you can use
it to transform points and shapes.
AffineTransform deﬁnes a number of
transform() methods that transform points repr esented by either java.awt.-
geom.Point2D objects or arrays of numbers. deltaTransform() is a variant of
transform() that perfor ms a transfor mation disr egarding any translation compo-
nent. It is designed for transforming distances or position-independent vectors,
instead of actual points. inverseTransform() is the inverse of transform()—it
converts points expressed in the new coordinate system back to the corresponding
points in the original coordinate system.
The transform(), deltaTransform(), and inverseTransform() methods are fairly
low-level and typically are not used directly by Java 2D programs. Instead, a pro-
gram typically uses the createTransformedShape() method, which provides a
power ful, high-level transformation capability. Given an arbitrary Shape object, this
method retur ns a new Shape that has been transformed as speciﬁed by the Af-
fineTransform object.
The Mathematics of AffineTransfor m
The coordinate system transformations described by AffineTransform have two
very important properties:
•
Straight lines remain straight
•
Parallel lines remain parallel
An AffineTransform is a linear transform, so the transformation can be expressed
in the matrix notation of linear algebra. An arbitrary AffineTransform can be
mathematically expressed by six numbers arranged in a matrix like this:



sx
shy
shx
sy
tx
ty



In this matrix, tx and ty ar e the translation amounts, sx and sy ar e the scaling fac-
tors, and shx and shy ar e the shearing factors, all in the X and Y dimensions,
98 Chapter 4 – Graphics with AWT and Java 2D

respectively. As we’ll see in a moment, rotation is a combination of scaling and
shearing, so there are not separate rx and ry numbers.
To transfor m a point from one coordinate system to another using an Affine-
Transform, we multiply the point by this matrix. Using matrix notation (and
adding a few dummy matrix elements), the equation looks like this:




x′
y′
1




=




sx
shy
0
shx
sy
0
0
0
1








x
y
1




This matrix equation is simply shorthand for the following system of equations:
x' = sx*x + shx*y + tx
y' = shy*x + sy*y + ty
The identity transform does not perfor m any transformation at all. It looks like
this:




x′
y′
1




=




1
0
0
0
1
1
0
0
1








x
y
1




=




x
y
1
∗
∗
1
1




Mathematically, rotation is a combination of scaling and shearing. The rotation of
an angle theta ar ound the origin is expressed with a matrix like this:



cos(θ)
sin(θ)
−sin(θ)
cos(θ)
0
0



You don’t need to understand how this rotation matrix works. If you remember
basic trigonometry, however, you can use it and the preceding equations to verify
that this matrix works for the base cases of 90-degree and 180-degree rotations.
As we’ve seen, it is possible to make cumulative changes to an AffineTransform.
This is done by multiplying the current transformation matrix by the new transfor-
mation matrix. For example, suppose we perfor m a translation by 100 units in
both the X and Y dimensions and follow this by scaling both the X and Y dimen-
sions by a factor of 2. The resulting AffineTransform matrix is the product of the
two individual matrices:




1
0
0
0
1
0
100
100
1




∗




2
0
0
0
2
0
0
0
1




=




2
0
0
0
2
0
100
100
1




Note that matrix multiplication is not commutative. If we perfor m the scaling op-
eration ﬁrst and then do the translation, we obtain a differ ent result:




2
0
0
0
2
0
0
0
1




∗




1
0
0
0
1
0
100
100
1




=




2
0
0
0
2
0
200
200
1




Most applications do not have to work with matrices explicitly in order to perfor m
coordinate-system transformations. As we’ve seen, it typically is easier to use the
translate(), scale(), rotate(), and shear() methods of either AffineTransform
or Graphics2D. It is useful to understand the mathematics underlying Affine-
Transform, however.
Graphics/
Java 2D
Transfor mations with AfﬁneT ransform
99

You may, on occasion, have the need to create a custom AffineTransform object
fr om a set of six numbers. A number of AffineTransform constructors and meth-
ods take matrix elements as arguments. These matrix elements are either passed in
explicitly or speciﬁed in an array. Note that the matrix-element naming system
used by the AffineTransform class is differ ent than the system I’ve used here. The
parameter names for AffineTransform methods are based on the following matrix:



m00
m10
m01
m11
m02
m12



This is nothing more that a differ ent naming scheme for the elements we are
alr eady familiar with:



sx
shy
shx
sy
tx
ty



When matrix elements are passed to or retur ned by an AffineTransform in an
array of float or double values, they are stor ed in this order:

m00, m10, m01, m11, m01, m12

This corresponds to the following order using our mnemonic names:

sx, shy, sy, tx, ty

Color Spaces
The java.awt.Color class repr esents a color in Java. As we discussed earlier, Java
2D has added several new constructors to the Color class, to support the creation
of translucent colors. Another important change to the Color class is support for
arbitrary color spaces. A color space is a system for repr esenting a color using
some characteristic set of axes.
Java 2D introduces the java.awt.color package for working with color spaces.
The most important piece of this package is the abstract ColorSpace class, which
repr esents a color space and deﬁnes a number of constants for commonly used
spaces. By default, Java colors are repr esented in the standard, device-independent
sRGB color space, in which colors are repr esented by idealized red, green, and
blue components. There are other ways of repr esenting colors, however. One
commonly used standard is the CIEXYZ space, which repr esents colors in terms of
thr ee abstract components named X, Y, and Z. Applications that repr esent colors
to be displayed on a printed page often use the CMYK color space, which repr e-
sents the cyan, magenta, yellow, and black inks used in the four-color printing
pr ocess. Another familiar color space is the grayscale color space, which repr e-
sents shades of gray as individual values between 0.0 (black) and 1.0 (white).
An application that cares about accurate color repr oduction often uses a device-
independent color space to ensure that the colors it displays look the same on dif-
fer ent monitors, printers, and other devices. To make device-independent color
repr esentation work, each monitor, printer, scanner, or other device needs to be
calibrated, so that device-independent colors can be correctly and accurately
100 Chapter 4 – Graphics with AWT and Java 2D

converted to appropriate device-dependent colors for that device. The result of a
device calibration is called a “proﬁle.” The International Color Consortium (ICC)
has deﬁned a standard ﬁle format for proﬁles, and the java.awt.color package
deﬁnes classes that implement color spaces in terms of these proﬁles. Sun’s imple-
mentation of the Java 1.2 runtime environment includes ﬁve sample proﬁles for
ﬁve differ ent color spaces, stored in the jr e/lib/cmm dir ectory of the Java installa-
tion. A more sophisticated implementation would obtain proﬁles from the color
management system of the native OS.
Graphics/
Java 2D
Color Spaces
101

CHAPTER 5
Pr inting
The previous chapters of this book have described how to draw graphics and dis-
play graphical user interfaces on a computer screen. This chapter explains how to
transfer those graphics to hardcopy. Printing was not supported in Java 1.0. Java
1.1 added a simple printing API that was easy to use but was not tightly integrated
with the printing capabilities of the underlying operating system. The Java 2 plat-
for m intr oduces an entirely new printing API that addresses the shortcomings of
the Java 1.1 API. This chapter explains both the Java 1.1 and the Java 1.2 APIs.
Pr inting in Java 1.1
In Java 1.1, you use a Graphics object to draw to the screen or into an off-scr een
Image. To produce hardcopy, you do exactly the same thing: obtain a Graphics
object that repr esents your printer and use the methods of that object to draw to
the printer. The only tricky thing you need to know is how to obtain an appropri-
ate Graphics object. You do this with a java.awt.PrintJob object, which you can
obtain from the Toolkit object.
The basic Java 1.1 printing algorithm has the following steps:
1. 
First, you must begin the print job. You do this by calling the getPrintJob()
method of the Toolkit object. This method displays a dialog box to the user
to request information about the print job, such as the name of the printer it
should be sent to. getPrintJob() retur ns a PrintJob object.
2. 
To begin printing a page, you call the getGraphics() method of the PrintJob
object. This retur ns a Graphics object that implements the PrintGraphics
inter face, to distinguish it from an on-screen Graphics object.
3. 
Now you can use the various methods of the Graphics object to draw your
desir ed output on the page. If you are printing an applet or a custom AWT
component, you can simply pass your Graphics object to the paint() method
102

of the applet or component. Note, however, that built-in AWT components are
drawn by the native GUI system, rather than a paint() method, and may not
print correctly.
4. 
When you are done drawing the page, you call the dispose() method of the
Graphics object to send that page description to the printer. If you need to
print another page, you can call the getGraphics() method of the PrintJob
again to obtain a new Graphics object for the next page and repeat the pro-
cess of drawing and calling dispose().
5. 
When you have printed all of your pages, you end the print job itself by call-
ing the end() method of the PrintJob object.
With the Java 1.1 printing API, the coordinate system of the printer is very much
like the coordinate system used when drawing on-screen. The origin is at the top
left, X coordinates run from left to right, and Y coordinates run from the top to the
bottom of the page. The coordinate system uses a resolution of 72 points per inch,
which is a typical resolution for monitors as well. Most printers support much
higher resolutions than this, however, and they use that extra resolution when
printing text, for example. However, because the Java 1.1 Graphics object does
not allow ﬂoating-point coordinates, all graphics must be positioned exactly at
integer positions.
Pr inting in Java 1.2
Java 1.2 introduces a more complete printing API. As in Java 1.1, printing is done
by calling methods of a special Graphics object that repr esents the printer device.
The printer coordinate system and base resolution of 72 points per inch are the
same in both Java 1.1 and Java 1.2. Beyond these similarities, however, the Java
1.2 API ﬂips the Java 1.1 API upside down. Instead of asking a PrintJob object for
the Graphics object to draw to, Java 1.2 uses a callback model. You tell the Java
1.2 printing API the object you’d like to print, and it calls the print() method of
that object, passing in the appropriate Graphics object to draw to. In Java 1.1,
your printing code is in charge of the print job, while in Java 1.2, the print job is in
charge of your printing code.
The Java 1.2 printing API is contained in the java.awt.print package. Key classes
and interfaces in this package are Printable, which repr esents a printable object,
Pageable, which repr esents a multipage printable document, and PrinterJob,
which coordinates the print job and serves as an intermediary between the Java
API and the native printing system. Do not confuse java.awt.print.PrinterJob
with the java.awt.PrintJob class used by the Java 1.1 printing API! Another
important class is PageFormat, which repr esents the size of the paper being
printed on, its margins, and the printing orientation (i.e., portrait mode or land-
scape mode).
The basic Java 1.2 printing algorithm includes the following steps:
1. 
First, obtain a PrinterJob object to coordinate the printing. Do this by calling
the static method PrinterJob.getPrinterJob().
Printing
Printing in Java 1.2
103

2. 
Obtain a PageFormat object that describes the size, margins, and orientation of
the page or pages to be printed. The PrinterJob object has methods that
allow you to obtain a default PageFormat object and display a dialog asking
the user to specify paper, margin, and orientation information. (You might dis-
play this dialog box in response to a Pr int Setup . . . menu item, for example.)
3. 
Next, tell the PrinterJob object what it is that you want to print. The item to
print is an object that implements either the Printable inter face or the Page-
able inter face (we’ll discuss each of these in more detail shortly). You pass
this object to either the setPrintable() or the setPageable() method of the
PrinterJob.
4. 
Unless you want the printing to occur silently, without any user interaction,
your next call is to the printDialog() method of the PrinterJob object. This
method displays a dialog box, giving the user the opportunity to specify the
printer to use and the number of copies to print. If you are printing a multi-
page Pageable object, this dialog box allows the user to select a subset of
pages to print, rather than printing the entire Pageable document. The dialog
box also gives the user the opportunity to cancel the print job. If the printDi-
alog() method retur ns false, the user has asked to cancel printing and you
should not proceed.
5. 
Finally, you call the print() method of the PrinterJob. This tells the Print-
erJob to begin the printing process.
6. 
The PrinterJob is now in control of printing. As we’ll discuss later, Print-
erJob invokes methods of the Printable or Pageable object you speciﬁed,
pr oviding the opportunity for your object to print itself to an appropriate
Graphics object.
Pr inting Single-Page Objects
When the object, ﬁgure, or document you want to print ﬁts on a single printed
page, you typically repr esent it using the Printable inter face. This interface
deﬁnes a single method, print(), that the PrinterJob calls to print the page. The
print() method has three arguments. The ﬁrst is the Graphics object that repr e-
sents the printer. print() should do all of its drawing using this object. This
Graphics object may be cast to a Graphics2D object, enabling all the features of
Java 2D, including the use of ﬂoating-point coordinates to position graphics ele-
ments with more precision than is possible with integer coordinates.
The second argument to print() is a PageFormat object. Your print() method
should call the getImageableX(), getImageableY(), getImageableWidth(), and
getImageableHeight() methods of PageFormat to determine the size and position
of the area that it should draw in. Note that these methods are poorly named. The
values they retur n repr esent the page and margin sizes requested by the user,not
the size of the paper actually available in the printer or the imageable area of the
printer (i.e., the region of the page that a speciﬁc type of printer can actually
print to).
The third argument is a page number. Although the Printable inter face is most
useful for single-page documents, it can be used for multipage documents. The
104 Chapter 5 – Printing

PrinterJob has no way to determine how many pages a Printable object
requir es. Indeed, a Printable object may be implemented in such a way that it
does not know how many pages it requir es either (e.g., a PrintableStream object
that prints a stream of text as it arrives). Because the page count is not known in
advance, the PrinterJob calls the print() method repeatedly, incrementing the
page number after printing each page.
One important responsibility of the print() method is to notify the PrinterJob
when all pages are printed. Your method does this by retur ning the constant
Printable.NO_SUCH_PAGE when the PrinterJob asks it to print a page that is past
the end of the document.
It is also important to implement the print() method so that it can be called more
than once for each page. As of this writing, Sun’s Java 1.2 printing implementation
calls the print() method at least twice for each page (we’ll see why at the end of
this chapter).
Example 5-1 shows a PrintableComponent class that can be used to print the con-
tents of a Swing component, applet, or custom AWT component. This class is a
wrapper around a Component and implements the Printable inter face. Note that it
deﬁnes two print() methods. One is the three-argument Printable method I
alr eady described. The other print() method takes no arguments and implements
the general Java 1.2 printing algorithm. It creates a PrinterJob, displays some
dialogs to the user, and initiates the printing process. To print a component, create
a PrintableComponent for that component, then call its print() method with no
arguments.
Example 5−1: PrintableComponent.java
import java.awt.*;
import java.awt.print.*;
/**
* This wrapper class encapsulates a Component and allows it to be printed
* using the Java 1.2 printing API
*/
public class PrintableComponent implements Printable {
// The component to be printed
Component c;
/** Create a PrintableComponent wrapper around a Component */
public PrintableComponent(Component c) { this.c = c; }
/**
* This method is not part of the Printable interface.
It is a method
* that sets up the PrinterJob and initiates the printing.
*/
public void print() throws PrinterException {
// Get the PrinterJob object
PrinterJob job = PrinterJob.getPrinterJob();
// Get the default page format, then allow the user to modify it
PageFormat format = job.pageDialog(job.defaultPage());
// Tell the PrinterJob what to print
job.setPrintable(this, format);
// Ask the user to confirm, and then begin the printing process
if (job.printDialog())
job.print();
Printing
Printing in Java 1.2
105

Example 5−1: PrintableComponent.java (continued)
}
/**
* This is the "callback" method that the PrinterJob will invoke.
* This method is defined by the Printable interface.
*/
public int print(Graphics g, PageFormat format, int pagenum) {
// The PrinterJob will keep trying to print pages until we return
// this value to tell it that it has reached the end
if (pagenum > 0)
return Printable.NO_SUCH_PAGE;
// We're passed a Graphics object, but it can always be cast to Graphics2D
Graphics2D g2 = (Graphics2D) g;
// Use the top and left margins specified in the PageFormat Note
// that the PageFormat methods are poorly named.
They specify
// margins, not the actual imageable area of the printer.
g2.translate(format.getImageableX(), format.getImageableY());
// Tell the Component to draw itself to the printer by passing in
// the Graphics2D object.
This will not work well if the Component
// has double-buffering enabled.
c.paint(g2);
// Return this constant to tell the PrinterJob that we printed the page
return Printable.PAGE_EXISTS;
}
}
Ther e ar e a few important points to note about this PrintableComponent example.
First, it is not designed to work with native AWT components, since those compo-
nents do not do their own drawing. Second, it does not work well for components
that use double-buffering because double-buffering locks the component drawing
into the relatively low resolution of an off-scr een image, rather than taking advan-
tage of the high resolution available on the printer. Finally, PrintableComponent
prints only the visible portion of a component, not the complete contents of the
component. For example, the Swing JEditorPane class can display long HTML
documents. If you use PrintableComponent to print a JEditorPane, however, it
prints only the currently visible text, not the complete HTML document. The ability
to print complete documents is a feature that is sorely missing in the current
implementation of Swing.
Pr inting Multipage Documents
As we just discussed, the Printable inter face can be used to print multipage docu-
ments. However, the PrinterJob has no way of determining in advance how
many pages are requir ed. This means that the user cannot request that only a sub-
set of pages be printed, for example. When you know the complete contents of
the document to be printed and can break it into pages before printing begins, it
is better to use the Pageable inter face than the Printable inter face.
Pageable deﬁnes a getNumberOfPages() method that retur ns the number of pages
to be printed. It also deﬁnes two methods that take a page number and retur n
106 Chapter 5 – Printing

PageFormat and Printable objects for that page. To print a Pageable object, the
PrinterJob asks for a PageFormat and a Printable object for each page to be
printed and then uses the print() method of each Printable object to print that
page.
Example 5-2 shows a class that implements the Pageable and Printable inter faces
in order to print a string, ﬁle, or stream of text. This is a rudimentary example of
text printing. It prints only text ﬁles, using a single font, and does not even expand
tabs or wrap long lines. The Java 1.2 printing API allows the use of Java 2D graph-
ics through the Graphics2D class. This example does not use the Java 2D version
of the drawString() method, however. Although that method allows text to be
positioned more precisely using ﬂoating-point coordinates, there is a  bug in the
curr ent implementation that prevents this method from printing correctly.
Example 5−2: PageableT ext.java
import java.awt.*;
import java.awt.print.*;
import java.io.*;
import java.util.Vector;
public class PageableText implements Pageable, Printable {
// Constants for font name, size, style and line spacing
public static String FONTFAMILY = "Monospaced";
public static int FONTSIZE = 10;
public static int FONTSTYLE = Font.PLAIN;
public static float LINESPACEFACTOR = 1.1f;
PageFormat format;
// The page size, margins, and orientation
Vector lines;
// The text to be printed, broken into lines
Font font;
// The font to print with
int linespacing;
// How much space between lines
int linesPerPage;
// How many lines fit on a page
int numPages;
// How many pages required to print all lines
int baseline = -1;
// The baseline position of the font
/** Create a PageableText object for a string of text */
public PageableText(String text, PageFormat format) throws IOException {
this(new StringReader(text), format);
}
/** Create a PageableText object for a file of text */
public PageableText(File file, PageFormat format) throws IOException {
this(new FileReader(file), format);
}
/** Create a PageableText object for a stream of text */
public PageableText(Reader stream, PageFormat format) throws IOException {
this.format = format;
// First, read all the text, breaking it into lines.
// This code ignores tabs and does not wrap long lines.
BufferedReader in = new BufferedReader(stream);
lines = new Vector();
String line;
while((line = in.readLine()) != null)
lines.addElement(line);
Printing
Printing in Java 1.2
107

Example 5−2: PageableT ext.java (continued)
// Create the font we will use, and compute spacing between lines
font = new Font(FONTFAMILY, FONTSTYLE, FONTSIZE);
linespacing = (int) (FONTSIZE * LINESPACEFACTOR);
// Figure out how many lines per page and how many pages
linesPerPage = (int)Math.floor(format.getImageableHeight()/linespacing);
numPages = (lines.size()-1)/linesPerPage + 1;
}
// These are the methods of the Pageable interface.
// Note that the getPrintable() method returns this object, which means
// that this class must also implement the Printable interface.
public int getNumberOfPages() { return numPages; }
public PageFormat getPageFormat(int pagenum) { return format; }
public Printable getPrintable(int pagenum) { return this; }
/**
* This is the print() method of the Printable interface.
* It does most of the printing work.
*/
public int print(Graphics g, PageFormat format, int pagenum) {
// Tell the PrinterJob if the page number is not a legal one
if ((pagenum < 0) | (pagenum >= numPages))
return NO_SUCH_PAGE;
// First time we're called, figure out the baseline for our font.
// We couldn't do this earlier because we needed a Graphics object.
if (baseline == -1) {
FontMetrics fm = g.getFontMetrics(font);
baseline = fm.getAscent();
}
// Clear the background to white.
This shouldn't be necessary but is
// required on some systems to work around an implementation bug.
g.setColor(Color.white);
g.fillRect((int)format.getImageableX(), (int)format.getImageableY(),
(int)format.getImageableWidth(),
(int)format.getImageableHeight());
// Set the font and the color we will be drawing with.
// Note that you cannot assume that black is the default color!
g.setFont(font);
g.setColor(Color.black);
// Figure out which lines of text we will print on this page
int startLine = pagenum * linesPerPage;
int endLine = startLine + linesPerPage - 1;
if (endLine >= lines.size())
endLine = lines.size()-1;
// Compute the position on the page of the first line
int x0 = (int) format.getImageableX();
int y0 = (int) format.getImageableY() + baseline;
// Loop through the lines, drawing them all to the page
for(int i=startLine; i <= endLine; i++) {
// Get the line
String line = (String)lines.elementAt(i);
108 Chapter 5 – Printing

Example 5−2: PageableT ext.java (continued)
// Draw the line.
// We use the integer version of drawString(), not the Java 2D
// version that uses floating-point coordinates. A bug in early
// Java 1.2 implementations prevents the Java 2D version from working.
if (line.length() > 0)
g.drawString(line, x0, y0);
// Move down the page for the next line
y0 += linespacing;
}
// Tell the PrinterJob that we successfully printed the page
return PAGE_EXISTS;
}
/**
* This is a test program that demonstrates the use of PageableText
*/
public static void main(String[] args) throws IOException, PrinterException {
// Get the PrinterJob object that coordinates everything
PrinterJob job = PrinterJob.getPrinterJob();
// Get the default page format, then ask the user to customize it
PageFormat format = job.pageDialog(job.defaultPage());
// Create our PageableText object, and tell the PrinterJob about it
job.setPageable(new PageableText(new File(args[0]), format));
// Ask the user to select a printer, etc., and if not canceled, print!
if (job.printDialog())
job.print();
}
}
Efficienc y Issues in the Java 1.2 Printing API
Although the Java 1.2 printing API offers important design improvements over the
Java 1.1 API, there are serious efﬁciency problems with Sun’s implementation of
the 1.2 API in versions of Java up to at least Java 1.2.2. All printers are good at
printing text, but not all are equally good at drawing arbitrary graphics. Thus,
when a page contains anything but text or very simple graphics, Java 1.2 converts
the entire page to a very large image and prints it in graphics mode.
As I mentioned earlier, the current implementation of PrinterJob calls the print()
method of a Printable object at least twice. The ﬁrst call uses a dummy Graphics
object whose sole purpose is to determine what kind of graphics the page con-
tains. If the page contains only text, as is the case in Example 5-2, the PrinterJob
can print the page efﬁciently in text mode.
However, if the page contains any other type of graphics, the PrinterJob uses a
large, high-resolution image to capture the graphics on the page and then trans-
mits this image to the printer for printing in graphics mode. Because such a high-
resolution image is memory intensive, the PrinterJob typically breaks the page up
into several smaller bands and calls the print() method several times (using a
Printing
Printing in Java 1.2
109

dif ferent clipping region each time). In this way, the PrinterJob is able to spool a
large image to the printer without using a large amount of memory (a classic time
versus space trade-off).
Unfortunately, the implementation is not well optimized, and printing perfor mance
is unacceptable on some systems. Printing even a simple graphic, such as one pro-
duced with the PrintableComponent class shown in Example 5-1, can take several
minutes and can produce a printer spool ﬁle of more than 50 megabytes.
Printing with the Java 1.1 API works better in Java 1.1 than it does in current
implementations of Java 1.2. The Java 1.1 API works in Java 1.2, but it suffers the
same efﬁciency problems as the Java 1.2 API. Furthermor e, the Java 1.1 API does
not perfor m the ﬁrst pass to determine what type of graphics a page contains,
so even a Java 1.1 program that prints only text is inefﬁcient when run under
Java 1.2.
110 Chapter 5 – Printing

CHAPTER 6
Data Transfer
Data transfer refers to the ability of an application to transfer selected data in a
variety of ways. For example, an application can use data transfer to support mov-
ing data between its own subparts. An application can also use data transfer to
exchange data with other Java applications that are running in the same Java VM
or in another Java VM or with native applications that are not running in a VM at
all. There are two commonly used metaphors for data transfer: cut-and-paste and
drag-and-dr op. Java 1.1 included a basic data transfer architectur e and supported
cut-and-paste. The Java 2 platform extends the architectur e in minor ways and
adds support for drag-and-drop.
The Data Transfer Framework
Both the cut-and-paste and drag-and-drop metaphors rely on the same underlying
data transfer architectur e. This architectur e was deﬁned in Java 1.1 in the
java.awt.datatransfer package. It consists of the
DataFlavor class, which
describes data types and data formats, and the Transferable inter face, which
deﬁnes methods that must be implemented if data is to be transferred.
The DataFlavor Class
A data transfer mechanism requir es a precise and portable way to specify the type
of data to be transferred. This is necessary so that both parties to the transfer—the
data source and the data sink—can agree on exactly what is being transferred.
Since the data source and the data sink may be entirely differ ent applications, the
mechanism for describing a data type must be general and ﬂexible.
In Java, the type of data being transferred is described by a java.awt.datatrans-
fer.DataFlavor object. The DataFlavor class describes data types using MIME
types. MIME deﬁnes standard types like “text/html” and “image/jpeg”. Because
Java programs often transfer data within the same Java VM or between VMs, the
Data
Transfer
111

DataFlavor class also supports describing data types with Java class names. For
example, to transfer a java.awt.Point object from one Java VM to another, the
data transfer mechanism can simply serialize the Point object and send the result-
ing stream of bytes to the other Java VM, where the Point object can be deserial-
ized. When doing data transfer between Java VMs in this way, the transfer of
objects becomes totally transparent.
The DataFlavor class deﬁnes constants for several commonly used data ﬂavors,
including DataFlavor.stringFlavor, DataFlavor.plainTextFlavor, and (in Java
1.2) DataFlavor.javaFileListFlavor. To transfer another types of data, you must
cr eate a custom DataFlavor by specifying the MIME type or Java class of the data
and a human-readable name for the data type. For example:
DataFlavor jpegFlavor = new DataFlavor("image/jpeg", "JPEG Image Data");
DataFlavor pointFlavor = new DataFlavor(java.awt.Point.class,
"Java Point Object");
The Transferable Interface
DataFlavor objects describe data types, but they contain no data themselves. Data
to be transferred using cut-and-paste or drag-and-drop must be encapsulated in an
object that implements the Transferable inter face.
Data transfer occurs in a heterogeneous environment. When you design the data
transfer capabilities of your application, you cannot know the other applications
with which the user may eventually want to exchange data. Thus, for maximum
ﬂexibility, an application that exports data—a data source — typically of fers its data
in multiple formats. An application that exports text might offer to transfer that
data in the form of a Java String object or as a stream of Unicode characters, for
example. If the receiving application is a Java program, it may choose to request
the data as a Java String, while a non-Java application would choose the stream
of characters instead.
The Transferable inter face deﬁnes three methods. getTransferDataFlavors(),
retur ns an array of DataFlavor objects that repr esent the data formats in which the
data may be transferred, while isDataFlavorSupported() asks whether a particular
data ﬂavor is supported. The third method, getTransferData(), per forms the
actual transfer. This method takes an argument that speciﬁes the desired data ﬂa-
vor and retur ns an Object that repr esents the data in the speciﬁed format. If the
speciﬁed data ﬂavor is not supported, getTransferData() thr ows an Unsupported-
FlavorException.
The retur n value for getTransferData() needs a little more explanation. The type
of this object depends on the DataFlavor that was requested. For any DataFlavor,
the getRepresentationClass() method retur ns a Java Class object that repr esents
the type of object that will be retur ned by getTransferData(). When a DataFla-
vor repr esents data that is transferred as a serialized Java object, the retur n value
of getTransferData() is simply a Java object of whatever type was transferred
(e.g., a String or java.awt.Point object). When a DataFlavor repr esents a MIME
type, the data is actually transferred between applications as a stream of bytes. In
this case, getTransferData() retur ns a java.io.InputStream object from which
you can read and parse these bytes.
112 Chapter 6 – Data Transfer

Because text is the most frequently transferred data type, the java.awt.datatrans-
fer package deﬁnes a StringSelection class that implements the Transferable
inter face for strings. This Transferable class supports two data ﬂavors, the pre-
deﬁned DataFlavor.stringFlavor and DataFlavor.plainTextFlavor constants.
Unfortunately, however, ther e is a problem with StringSelection. When the
string is requested in plain text format, the getTransferData() method retur ns a
java.io.Reader object instead of a java.io.InputStream. Because StringSelec-
tion is widely used, applications receiving DataFlavor.plainTextFlavor data may
want to use instanceof to determine whether the retur n value is an InputStream
(a byte stream) or a Reader (a Unicode character stream). Despite the problems
with StringSelection, ther e is a long-standing bug in Sun’s Java 1.1 and Java 1.2
implementations for Windows platforms that makes it indispensable. On those
platfor ms, StringSelection is the only Transferable class that can successfully
transfer text between a Java application and a native application.
Applications that display strings in JTextField, JTextArea, and related compo-
nents already support textual data transfer, as these components have cut-and-
paste support built in. In other words, you typically don’t have to implement tex-
tual data transfer yourself. When you do need to implement data transfer, it is
pr obably because you are transferring some specialized type of data. Example 6-1
shows how we can implement the
Transferable
inter face
to transfer
java.awt.Color objects between Java applications.
Example 6−1: TransferableColor.java
import java.awt.Color;
import java.awt.datatransfer.*;
import java.io.*;
/**
* This class is used to transfer a Color object via cut-and-paste or
* drag-and-drop. It allows a color to be transferred as a Color object
* or as a string. Due to a long-standing bug in Java 1.1 and Java 1.2,
* transferring a color as a string to native Windows applications will
* not work.
*/
public class TransferableColor implements Transferable {
// This DataFlavor object is used when we transfer Color objects directly
protected static DataFlavor colorFlavor =
new DataFlavor(Color.class, "Java Color Object");
// These are the data flavors we support
protected static DataFlavor[] supportedFlavors = {
colorFlavor, 
// Transfer as a Color object
DataFlavor.stringFlavor, 
// Transfer as a String object
DataFlavor.plainTextFlavor, 
// Transfer as a stream of Unicode text
};
Color color;
// The color we encapsulate and transfer
/** Create a new TransferableColor that encapsulates the specified color */
public TransferableColor(Color color) { this.color = color; }
/** Return a list of DataFlavors we can support */
public DataFlavor[] getTransferDataFlavors() { return supportedFlavors; }
Data
Transfer
The Data Transfer Framework
113

Example 6−1: TransferableColor.java (continued)
/** Check whether a specified DataFlavor is available */
public boolean isDataFlavorSupported(DataFlavor flavor) {
if (flavor.equals(colorFlavor) ||
flavor.equals(DataFlavor.stringFlavor) ||
flavor.equals(DataFlavor.plainTextFlavor)) return true;
return false;
}
/**
* Transfer the data.
Given a specified DataFlavor, return an Object
* appropriate for that flavor.
Throw UnsupportedFlavorException if we
* don't support the requested flavor.
*/
public Object getTransferData(DataFlavor flavor)
throws UnsupportedFlavorException, IOException
{
if (flavor.equals(colorFlavor)) return color;
else if (flavor.equals(DataFlavor.stringFlavor)) return color.toString();
else if (flavor.equals(DataFlavor.plainTextFlavor))
return new ByteArrayInputStream(color.toString().getBytes("Unicode"));
else throw new UnsupportedFlavorException(flavor);
}
}
Cut-and-Paste
In addition to the data transfer framework classes, the java.awt.datatransfer
package also deﬁnes the Clipboard class and the ClipboardOwner inter face, which
implement data transfer with the cut-and-paste metaphor.
A typical cut-and-paste transfer works as follows:
•
In the initiating application, the user types Ctrl-C or Ctrl-X or in some other
way tells the application that he wants to copy or cut some data.
•
The application takes the selected data and encapsulates it in an appropriate
Transferable object. The next step is to call the getSystemClipboard()
method of the Toolkit object, to get a Clipboard object. The application then
calls the setContents() method of the Clipboard, passing the Transferable
object as the new clipboard contents.
•
If the user issued a cut command, the initiating application typically deletes
the data after transferring it to the clipboard. If the user issued a copy com-
mand, however, the application typically just highlights the data to make it
clear to the user what data is available for pasting. Often this data should
remain highlighted for as long as the initiating application owns the clipboard.
When an application calls setContents(), it becomes the clipboard owner
and remains such until some other application transfers data to the clipboard.
The application must, in fact, pass a object that implements ClipboardOwner
to the setContents() method. This object is used to notify the application
when it ceases to be the clipboard owner. Until that happens, however, the
application must maintain the Transferable object and be willing to provide
the data when it is requested.
114 Chapter 6 – Data Transfer

•
At some point, the user moves his attention to some other application and
issues a paste command in that application. This receiving ﬁrst application
calls Toolkit.getSystemClipboard() to obtain a Clipboard object. Then it
calls getContents() to obtain a Transferable object that repr esents the data
available on the clipboard. The application uses getTransferDataFlavors()
or isDataFlavorSupported() to see if the clipboard data is available in a for-
mat it is willing to accept. If there is such a format, the application calls get-
TransferData() to transfer the data.
•
At some point after this cut-and-paste operation, the user cuts or copies a new
piece of data in an application. At this point, the original application ceases to
be the clipboard owner and no longer has to make its data available for past-
ing. The lostOwnership() method of the originating application’s Clipboard-
Owner object is called to notify the application of this occurrence.
Drag-and-Drop
Java 1.2 adds drag-and-drop support to Java. Drag-and-drop requir es quite a bit
mor e infrastructur e than cut-and-paste, and this infrastructure is added in a pack-
age of its own, java.awt.dnd. Despite the complexity of the infrastructure, drag-
and-dr op is built upon the same data transfer architectur e as cut-and-paste. The
key classes are still DataFlavor and Transferable.
Her e’s the general outline of a drag-and-drop transaction from the standpoint of
the initiating or dragging application or component:
•
If a component within an application wants to allow data to be dragged from
it, it ﬁrst obtains a DragSource object and then uses this DragSource to create
a DragGestureRecognizer. This DragGestureRecognizer pays attention to
mouse events that occur over the component, looking for the platform-depen-
dent gesture that indicates that the user wants to drag something.
•
When the
DragGestureRecognizer sees a drag gesture, it invokes the
dragGestureRecognized() of a speciﬁed DragGestureListener object.
•
The dragGestureRecognized() method determines if there is data available
for dragging, and, if so, it encapsulates the data in a Transferable object.
dragGestureRecognized is passed a DragGestureEvent object. Unlike most
other event objects, many of the event objects in the java.awt.dnd package
deﬁne important methods that are used during a drag-and-drop transaction.
In this case, the dragGestureRecognized() method activates the native drag-
and-dr op system by calling the startDrag() method of its DragGestureEvent
object and passing it the Transferable object. In the call to startDrag(),
you also specify a cursor that is displayed during the drag and a Drag-
SourceListener object that keeps the data source notiﬁed about how the drag
is progr essing. You can also specify an optional Image that is dragged along
with the cursor,
on
systems that support it. (Call the static
Drag-
Source.isDragImageSupported() to see if image dragging is supported on the
system.)
Data
Transfer
Drag-and-Dr op
115

•
As the user drags the data, various methods of the DragSourceListener ar e
invoked to notify the initiating application of the status of the drag. These
methods can be used to update the cursor being displayed or the image being
dragged along with the cursor.
The methods provide a way to implement
specialized drag-over animation effects, for example. The native drag-and-
dr op system typically supplies basic drag-over effects, by changing the cursor
when it is over a receptive drop target.
•
The most commonly used DragSourceListener method is dragDropEnd().
This method is invoked when the user drops the data. The initiating applica-
tion can use this method to determine whether the drop was successful. If the
user were moving data instead of copying data, the initiating application
should delete its copy of the data once it has been successfully transferred to
the recipient.
dragDropEnd() is passed a DragSourceDropEvent object. The
getDropSuccess() and getDropAction() methods of this event help the initi-
ating application decide on the appropriate action to take.
A drag-and-dr op transaction looks somewhat differ ent fr om the standpoint of a
receiving application or component:
•
A component that wants to allow data to be dropped on it must create a
DropTarget object to act as an intermediary between itself and the native
drag-and-dr op system. When creating a DropTarget, you must specify the
component on which data can be dropped and also a DropTargetListener
object that can be notiﬁed when data is dragged over the component.
•
When the user drags data over the component, the dragEnter() method of
the DropTargetListener is invoked. This method is passed a DropTarget-
DragEvent that it can query to determine the supported data ﬂavors of the
data being dragged. If the component is willing to accept a drop of that type
of data, it should call the acceptDrop() method of the event object to signal
its willingness. This in turn causes the dragEnter() method of the Drag-
SourceListener in the initiating application to be invoked. The dragEnter()
method of the DropTargetListener may also want to display some visual cue
to the user of its willingness to accept a drop. For example, it might change
colors or change its border. This kind of visual change is known as a “drag-
under effect.”
•
The dragOver() method is called repeatedly as the user continues to drag the
data over the component. If the user drags the data out of the component, the
dragExit() method is called. If dragEnter() displayed a visual cue, drag-
Exit() should undo it.
•
If the user drops the data while over the component, the drop() method of
the DropTargetListener is invoked. It is this method that perfor ms the actual
data transfer.
drop() is passed a DropTargetDropEvent. The getTransfer-
able() method of this event retur ns the Transferable object that was
dr opped. If the Transferable object supports a DataFlavor that the compo-
nent can accept, the component calls the acceptDrop() method of the event
to tell the native drag-and-drop system that the drop is valid. If it cannot work
with any of the available data ﬂavors, it should call rejectDrop(). After
accepting the drop, the receiving component uses the getTransferData()
116 Chapter 6 – Data Transfer

method of the Transferable object to actually transfer the data. This phase of
the data transfer is done exactly as it is in cut-and-paste. Finally, the compo-
nent calls the dropComplete() method of the DropTargetDropEvent, passing
true if the transfer was successful or false if something went wrong and the
transfer did not succeed.
A Data Source
Example 6-2 shows the ColorSource class. This is a simple JComponent subclass
that displays a small block of a solid color and makes that color available for trans-
fer via both cut-and-paste and drag-and-drop. The copy() method copies the color
to the clipboard, making it available for pasting, while the dragGestureRecog-
nized() method initiates a drag operation. This example relies upon the Trans-
ferableColor class of Example 6-1, of course. For simplicity, the copy() method is
invoked when the user clicks on the component—ther e is no Ctrl-C keyboard
binding or Edit menu command.
Example 6−2: ColorSour ce.java
import java.awt.*;
import java.awt.event.*;
import java.awt.datatransfer.*;
import java.awt.dnd.*;
import javax.swing.*;
import javax.swing.border.*;
import java.io.*;
/**
* This simple component displays a solid color and allows that color
* to be dragged. Also, it copies the color to the clipboard when the
* user clicks on it.
*/
public class ColorSource extends JComponent
implements ClipboardOwner, DragGestureListener, DragSourceListener
{
Color color;
// The color to display
TransferableColor tcolor;
// The color, encapsulated for data transfer
DragSource dragSource;
// We need this object for drag-and-drop
/** A ColorSource normally displays itself with this border */
protected static Border defaultBorder = new BevelBorder(BevelBorder.LOWERED);
/** When we are the clipboard owner, uses this border */
protected static Border highlightBorder =
new CompoundBorder(defaultBorder, new LineBorder(Color.black, 2));
/** Create a new ColorSource object that displays the specified color */
public ColorSource(Color color) {
// Save the color.
Encapsulate it in a Transferable object so that
// it can be used with cut-and-paste and drag-and-drop.
this.color = color;
this.tcolor = new TransferableColor(color);
// Set our default border
this.setBorder(defaultBorder);
// Listen for mouse clicks, and copy the color to the clipboard
Data
Transfer
A Data Source 117

Example 6−2: ColorSour ce.java (continued)
this.addMouseListener(new MouseAdapter() {
public void mouseClicked(MouseEvent e) { copy(); }
});
// Set up a DragGestureRecognizer that will detect when the user
// begins a drag.
When it detects one, it will notify us by calling
// the dragGestureRecognized() method of the DragGestureListener
// interface we implement below
this.dragSource = DragSource.getDefaultDragSource();
dragSource.createDefaultDragGestureRecognizer(this, // Look for drags on us
DnDConstants.ACTION_COPY_OR_MOVE, // Recognize these types
this); 
// Tell us when recognized
}
// These are component methods that make this class work as a component.
// They specify how big the component is, and what it it looks like.
protected static Dimension mysize = new Dimension(25, 25);
public Dimension getMinimumSize() { return mysize; }
public Dimension getPreferredSize() { return mysize; }
public void paintComponent(Graphics g) {
g.setColor(color);
Dimension s = this.getSize();
Insets i = this.getInsets();
g.fillRect(i.left, i.top,
s.width-i.left-i.right, s.height-i.top-i.bottom);
}
// The methods below support cut-and-paste
/** This method copies the color to the clipboard */
public void copy() {
// Get system clipboard
Clipboard c = this.getToolkit().getSystemClipboard();
// Put our TransferableColor object on the clipboard.
// Also, we'll get notification when we no longer own the clipboard.
c.setContents(tcolor, this);
// Set a special border on ourselves that indicates that we're the
// current color available for pasting
this.setBorder(highlightBorder);
}
// This ClipboardOwner method is called when something else is
// placed on the clipboard.
It means that our color is no longer
// available for pasting, and we should not display the highlight border.
public void lostOwnership(Clipboard clipboard, Transferable contents) {
this.setBorder(defaultBorder);
}
// The methods below support drag-and-drop
// This DragGestureListener method is called when the DragGestureRecognizer
// detects that the user has dragged the mouse.
It is responsible
// for beginning the drag-and-drop process.
public void dragGestureRecognized(DragGestureEvent e) {
// Create an image we can drag along with us.
// Not all systems support this, but it doesn't hurt to try.
118 Chapter 6 – Data Transfer

Example 6−2: ColorSour ce.java (continued)
Image colorblock = this.createImage(25,25);
Graphics g = colorblock.getGraphics();
g.setColor(color);
g.fillRect(0,0,25,25);
// Start dragging our transferable color object
e.startDrag(DragSource.DefaultMoveDrop, 
// The initial drag cursor
colorblock, new Point(0,0),
// The image to drag
tcolor, 
// The data being dragged
this); 
// Who to notify during drag
}
// These methods implement DragSourceListener.
// Since we passed this object to startDrag, these methods will be
// called at interesting points during the drag.
We could use them,
// for example, to implement custom cursors or other "drag-over" effects.
public void dragEnter(DragSourceDragEvent e) {}
public void dragExit(DragSourceEvent e) {}
public void dragDropEnd(DragSourceDropEvent e) {}
public void dragOver(DragSourceDragEvent e) {}
public void dropActionChanged(DragSourceDragEvent e) {}
}
A Data Sink
Example 6-3 shows the ColorSink class, which is a simple subclass of the Swing
JTextArea class. ColorSink allows color objects to be pasted or dropped on it.
When either event occurs, ColorSink sets its background color to the transferred
color object. In addition, the class allows the pasting of textual data, which it
inserts at the current cursor position. Finally, ColorSink accepts drops of the
DataFlavor.javaFileListFlavor type. This data ﬂavor is used when the user
drags and drops a ﬁle icon. When a ColorSink receives a drop of this type, it
opens the speciﬁed ﬁle (which it assumes to be a text ﬁle) and reads and displays
its contents.
The pastecolor() method does the work of transferring a color through cut-and-
paste. Again, for simplicity, the pastecolor() method is invoked when the user
double-clicks on the ColorSink. The drag-and-drop transfer is implemented pri-
marily in the drop() method. Note, however, that dragEnter() and dragExit()
per form a simple drag-under effect by highlighting the ColorSink border.
The ColorSink class also includes a simple main() method that shows how it can
be combined with the ColorSource class to create a simple demonstration of cut-
and-paste and drag-and-drop.
Example 6−3: ColorSink.java
import java.awt.*;
import java.awt.event.*;
import java.awt.datatransfer.*;
import java.awt.dnd.*;
import javax.swing.*;
import javax.swing.border.*;
import java.io.*;
Data
Transfer
A Data Sink
119

Example 6−3: ColorSink.java (continued)
import java.util.List;
/**
* This simple JTextArea subclass allows TransferableColor objects to
* be pasted or dropped into it.
It also supports the pasting of
* text and the dropping of File objects.
*/
public class ColorSink extends JTextArea implements DropTargetListener {
/** Create a new ColorSink object */
public ColorSink() {
// Listen for double-clicks.
Use them to trigger a paste action.
addMouseListener(new MouseAdapter() {
public void mouseClicked(MouseEvent e) {
if (e.getClickCount() == 2) { pastecolor(); e.consume(); }
}
});
// We have to create a DropTarget object to support drag-and-drop.
// It will listen for drops on top of us and notify our DropTargetListener
// methods when drag-and-drop-related events occur.
setDropTarget(new DropTarget(this, this));
}
// This method is invoked when the user double-clicks on us.
It attempts
// to paste a color or text.
Note that the JTextArea we extend
// already supports cut-and-paste of text through the Ctrl-V keystroke.
// This adds a different kind of cut-and-paste for demonstration purposes.
public void pastecolor() {
// Get the clipboard, and read its contents
Clipboard c = this.getToolkit().getSystemClipboard();
Transferable t = c.getContents(this);
if (t == null) {
// If nothing to paste
this.getToolkit().beep(); // then beep and do nothing
return;
}
try {
// If the clipboard contained a color, use it as the background color
if (t.isDataFlavorSupported(TransferableColor.colorFlavor)) {
Color color = (Color) t.getTransferData(TransferableColor.colorFlavor);
this.setBackground(color);
}
// If the clipboard contained text, insert it.
else if (t.isDataFlavorSupported(DataFlavor.stringFlavor)) {
String s = (String) t.getTransferData(DataFlavor.stringFlavor);
this.replaceSelection(s);
}
// Otherwise, we don't know how to paste the data, so just beep
else this.getToolkit().beep();
}
catch (UnsupportedFlavorException ex) { this.getToolkit().beep(); }
catch (IOException ex) { this.getToolkit().beep(); }
}
// The methods below are the methods of DropTargetListener.
// They are invoked at various times when something is being
// dragged over us, and allow us an opportunity to respond to the drag.
// This is the border we display when the user is dragging over us.
120 Chapter 6 – Data Transfer

Example 6−3: ColorSink.java (continued)
protected static Border dropBorder = new BevelBorder(BevelBorder.LOWERED);
// Something is being dragged over us.
If we can support this data type.
// tell the drag-and-drop system that we are interested, and display
// a special border to tell the user that we're interested.
public void dragEnter(DropTargetDragEvent e) {
if (e.isDataFlavorSupported(TransferableColor.colorFlavor) ||
e.isDataFlavorSupported(DataFlavor.javaFileListFlavor)) {
e.acceptDrag(DnDConstants.ACTION_COPY_OR_MOVE);
this.setBorder(dropBorder);
}
}
/** The user is no longer dragging over us, so restore the default border */
public void dragExit(DropTargetEvent e) { this.setBorder(null); }
/** This method is invoked when the user drops something on us */
public void drop(DropTargetDropEvent e){
this.setBorder(null); 
// Restore the default border
Transferable t = e.getTransferable();
// Get the data that was dropped
// Check for types of data that we support
if (t.isDataFlavorSupported(TransferableColor.colorFlavor)) {
// If it was a color, accept it, and use it as the background color
e.acceptDrop(DnDConstants.ACTION_COPY_OR_MOVE);
try {
Color c = (Color) t.getTransferData(TransferableColor.colorFlavor);
this.setBackground(c);
e.dropComplete(true);
}
catch (Exception ex) { e.dropComplete(false); }
}
else if (t.isDataFlavorSupported(DataFlavor.javaFileListFlavor)) {
// If it was a file list, accept it, read the first file in the list
// and display the file contents
e.acceptDrop(DnDConstants.ACTION_COPY_OR_MOVE);
try {
List files = (List) t.getTransferData(DataFlavor.javaFileListFlavor);
File f = (File) files.get(0);
BufferedReader in = new BufferedReader(new FileReader(f));
String s;
this.setText("");
while((s = in.readLine()) != null) this.append(s);
e.dropComplete(true);
}
catch (Exception ex) { e.dropComplete(false); }
}
else {
// If it wasn't a color or a file list, reject it
e.rejectDrop();
return;
}
}
// These are unused DropTargetListener methods
public void dragOver(DropTargetDragEvent e) {}
public void dropActionChanged(DropTargetDragEvent e) {}
Data
Transfer
A Data Sink
121

Example 6−3: ColorSink.java (continued)
/** This is a simple test program for ColorSource and ColorSink */
public static void main(String[] args) {
// Create a window
JFrame f = new JFrame("ColorSourceTest");
f.getContentPane().setLayout(new BorderLayout());
// Add some ColorSources
JPanel panel = new JPanel();
f.getContentPane().add(panel, BorderLayout.NORTH);
panel.add(new ColorSource(Color.yellow));
panel.add(new ColorSource(Color.pink));
panel.add(new ColorSource(Color.white));
panel.add(new ColorSource(Color.gray));
// Add a ColorSink
ColorSink sink = new ColorSink();
f.getContentPane().add(sink, BorderLayout.CENTER);
// Pop it all up
f.setSize(400, 300);
f.show();
}
}
122 Chapter 6 – Data Transfer

CHAPTER 7
Applets
An applet, as the name implies, is a kind of mini-application, designed to be
downloaded over a network from a possibly untrusted source and run in a web
br owser or in the context of some other applet viewer application. Because of the
ubiquity of web browsers, applets are a useful and powerful way of delivering
Java programs to end users. In fact, it was the power of applets that popularized
Java in the ﬁrst place. Applets differ from regular applications in several important
ways:
•
An applet doesn’t have a main() method like a standalone Java application
does. Writing an applet is a lot more like subclassing an AWT or Swing com-
ponent than writing a standalone application.
•
An applet is not invoked using the command line, as a Java application is.
Instead, an applet is embedded within an HTML ﬁle with an <APPLET> tag.
And, instead of reading command-line arguments as an application does, an
applet gets its arguments from <PARAM> tags in the HTML ﬁle.
•
An applet is usually subject to a number of strict security restrictions that pre-
vent untrusted, and possibly malicious, applet code from damaging the host
system.
This chapter brieﬂy explains how applets are written and how they are embedded
in HTML pages. It also explains the security restrictions to which applets are
subject.
Wr iting Applets
Fr om a programmer’s standpoint, one of the biggest differ ences between an applet
and an application is that an applet does not have a main() method or any other
single entry point from which the program starts running. Instead, to write an
applet, you subclass the java.applet.Applet class (which is itself a subclass of
Applets
123

java.awt.Panel and thus a descendant of java.awt.Component) and override a
number of standard methods. At appropriate times, under well-deﬁned circum-
stances, the web browser or applet viewer invokes the methods you have deﬁned.
The applet is not in control of the thread of execution; it simply responds when
the browser or viewer tells it to. For this reason, the methods you write must take
the necessary action and retur n pr omptly—they are not allowed to enter time-con-
suming (or inﬁnite) loops. In order to perfor m a time-consuming or repetitive task,
such as animation, an applet may create its own Thread, over which it does have
complete control.
The task of writing an applet, then, comes down to deﬁning the appropriate meth-
ods. A number of these methods are deﬁned by the Applet class:
init()
Called when the applet is ﬁrst loaded into the browser or viewer. It is typi-
cally used to perfor m applet initialization, in prefer ence to a constructor
method. (If you deﬁne a constructor for your Applet, it must be a no-argu-
ment constructor, as that is what the web browser expects.) If your applet
displays GUI components, they are typically created here. (Remember that the
applet itself is a java.awt.Panel, so you can create components and add()
them directly to the applet.)
destroy()
Called when the applet is about to be unloaded from the browser or viewer.
The method should free any resources, other than memory, that the applet
has allocated. The destroy() method is much less commonly used than
init().
start()
Called when the applet becomes visible and should start doing whatever it is
that it does. An applet that perfor ms animation or does some other action
only when it is visible needs to implement this method.
stop()
Called when the applet becomes temporarily invisible (e.g., when the user
has scrolled it off the screen). Tells the applet to stop perfor ming an anima-
tion or other task.
getAppletInfo()
Called to get information about the applet (e.g., its name and author). This
method should retur n a string suitable for display in a dialog box.
getParameterInfo()
Called to obtain information about the parameters to which the applet
responds. Returns a String[ ][ ] that describes the parameters.
In addition to these Applet methods, there are a variety of Component methods that
an applet may want to override. The most obvious of these methods is paint(),
which the browser or viewer invokes to ask the applet to draw itself on the
scr een.
Applets handle events in the same way that AWT and Swing applications and com-
ponents do. However, for maximum portability to old web browsers such as
124 Chapter 7 – Applets

Netscape Navigator 3 and early versions of Navigator 4, many applets use the dep-
recated Java 1.0 event model and override methods such as mouseDown(), mouse-
Drag(), keyDown(), and action().
In addition to all these methods that you override when writing an applet, the
Applet class also deﬁnes some methods that you may ﬁnd useful to invoke from
your applet:
getImage()
Loads an image ﬁle from the network and retur ns an Image object.
getAudioClip()
Loads a sound clip from the network and retur ns an AudioClip object.
getParameter()
Looks up and retur ns the value of a named parameter, speciﬁed with a
<PARAM> tag in the HTML ﬁle that contains the applet.
getCodeBase()
Retur ns the base URL from which the applet class ﬁle was loaded.
getDocumentBase()
Retur ns the base URL of the HTML ﬁle that refers to the applet.
showStatus()
Displays a message in the status line of the browser or applet viewer.
getAppletContext()
Retur ns the AppletContext object for the applet.
AppletContext deﬁnes the
useful showDocument() method that asks the browser to load and display a
new web page.
A Simple Applet
Example 7-1 is a simple applet. The applet has a simple init() method but con-
sists primarily of the paint() method that produces the applet display shown in
Figur e 7-1. The example also demonstrates the use of the getParameter() method
to obtain the string of text that it displays.
This applet can be placed within an HTML ﬁle using the following HTML tags:
<APPLET code="MessageApplet.class" width=350 height=125>
<PARAM name="message" value="Hello World">
</APPLET>
To run and display the applet, simply load the HTML ﬁle into a Java-enabled web
br owser. Alter natively, you can use the appletviewer pr ogram included with Sun’s
Java implementation to view the applet:
% appletviewer MessageApplet.html
When invoking appletviewer, you must specify the name of the HTML ﬁle that
includes the applet, not the Java class ﬁle that implements the applet. We’ll discuss
how applets are embedded in HTML ﬁles in full detail later in this chapter.
Applets
Writing Applets
125

Figur e 7−1: A simple applet
Example 7−1: MessageApplet.java
import java.applet.*;
import java.awt.*;
public class MessageApplet extends Applet {
protected String message;
// The text to display
protected Font font;
// The font to display it in
// One-time initialization for the applet
public void init() {
message = this.getParameter("message");
font = new Font("Helvetica", Font.BOLD, 48);
}
// Draw the applet whenever necessary
public void paint(Graphics g) {
// The pink oval
g.setColor(Color.pink);
g.fillOval(10, 10, 330, 100);
// The red outline. The browser may not support Java 2D, so we
// try to simulate a four-pixel-wide line by drawing four ovals.
g.setColor(Color.red);
g.drawOval(10,10, 330, 100);
g.drawOval(9, 9, 332, 102);
g.drawOval(8, 8, 334, 104);
g.drawOval(7, 7, 336, 106);
// The text
g.setColor(Color.black);
g.setFont(font);
g.drawString(message, 40, 75);
}
}
126 Chapter 7 – Applets

Applets and the Java 1.0 Event Model
The AWT event model changed dramatically between Java 1.0 and Java 1.1. Chap-
ter 2, Swing and AWT Architectur e, described the Java 1.1 event-handling model
exclusively, since the Java 1.0 event model is now deprecated. However, because
ther e is still a large installed base of web browsers that support only the Java 1.0
event model, applets are sometimes still written using this model.
In Java 1.0, all events are repr esented by the Event class. This class has a number
of instance variables that describe the event. One of these variables, id, speciﬁes
the type of the event. Event deﬁnes a number of constants that are the possible
values for the id ﬁeld. The target ﬁeld speciﬁes the object (typically a Component)
that generated the event or on which the event occurred (i.e., the source of the
event). The other ﬁelds may or may not be used, depending on the type of the
event. For example, the x and y ﬁelds are deﬁned when id speciﬁes a BUT-
TON_EVENT but not when it speciﬁes an ACTION_EVENT. The arg ﬁeld can provide
additional type-dependent data.
A Java 1.0 event is dispatched ﬁrst to the handleEvent() method of the Component
on which it occurred. The default implementation of this method checks the id
ﬁeld of the Event object and dispatches the most commonly used types of events
to various type-speciﬁc methods, listed in Table 7-1.
Table 7−1: Java 1.0 Event Processing Methods of Component
action() 
keyUp()
mouseDrag() 
mouseMove()
gotFocus() 
lostFocus() 
mouseEnter() 
mouseUp()
keyDown() 
mouseDown()
mouseExit()
The methods listed in Table 7-1 are deﬁned by the Component class. One of the
primary characteristics of the Java 1.0 event model is that you must override these
methods in order to process events. This means that you must create a subclass to
deﬁne custom event-handling behavior, which is exactly what we do when we
write an applet, for example. However, not all of the event types are dispatched
by handleEvent() to more speciﬁc methods. If you are inter ested in LIST_SELECT
or WINDOW_ICONIFY events, for example, you have to override handleEvent() itself,
rather than one of the more speciﬁc methods. If you do this, you usually want to
invoke super.handleEvent() to continue dispatching events of other types in the
default way.
handleEvent() and all of the type-speciﬁc methods retur n boolean values. If an
event-handling method retur ns false, as they all do by default, it means that the
event was not handled, so it should be passed to the container of the current com-
ponent to see if that container is interested in processing it. If a method retur ns
true, on the other hand, it is a signal that the event has been handled and no fur-
ther processing is needed.
The fact that unhandled events are passed up the containment hierarchy is impor-
tant. It means that we can override the action() method in an applet in order to
handle ACTION_EVENT events that are generated by the buttons within the applet. If
Applets
Writing Applets
127

they were not propagated up as they are, we would have to create a custom sub-
class of Button for every button we wanted to add to an interface!
In the Java 1.0 model, there is no de facto way to know what types of events are
generated by what GUI components nor to know what ﬁelds of the Event object
ar e ﬁlled in for what types of events. You simply have to look this information up
in the documentation of individual AWT components.
Many event types use the modifiers ﬁeld of the Event object to report which key-
board modiﬁer keys were pressed when the event occurred. This ﬁeld contains a
bitmask of the SHIFT_MASK, CTRL_MASK, META_MASK, and ALT_MASK constants deﬁned
by the Event class. The shiftDown(), controlDown(), and metaDown() methods
can be used to test for the various modiﬁers.
The Event class does not have a special ﬁeld to indicate which mouse button was
pr essed when a mouse event occurs. Instead, Event uses the keyboard modiﬁer
constants for this purpose, which allows systems that use a one-button mouse to
simulate other mouse buttons by using keyboard modiﬁers. If the left mouse but-
ton is in use, no keyboard modiﬁers are reported. If the right button is used, the
META_MASK bit is set in the modifiers ﬁeld. And if the middle button is down, the
ALT_MASK bit is set.
When a keyboard event occurs, you should check the id ﬁeld of the Event object
to determine what kind of key was pressed. If the event type is KEY_PRESS or
KEY_RELEASE, the keyboard key has an ASCII or Unicode repr esentation, and the
key ﬁelds of the event object contain the encoding of the key. On the other hand,
if id is KEY_ACTION or KEY_ACTION_RELEASE, the key is a function key of some sort,
and the key ﬁeld contains one of the keyboard constants deﬁned by the Event
class, such as Event.F1 or Event.LEFT.
Example 7-2 shows a simple applet that allows the user to produce drawings by
scribbling with the mouse. It also allows the user to erase those drawings by click-
ing on a button or pressing the E key. The applet overrides methods to handle
mouse events, keyboard events, and action events generated by the Button com-
ponent. Unlike the applet in Example 7-1, this applet does not deﬁne a paint()
method. For simplicity, it does its drawing directly in response to the events it
receives and does not store the coordinates. This means that it cannot regenerate
the user’s drawing if it is scrolled off the screen and then scrolled back on.
Example 7−2: An Applet That Uses the Java 1.0 Event Model
import java.applet.*;
import java.awt.*;
/** A simple applet using the Java 1.0 event-handling model */
public class Scribble extends Applet {
private int lastx, lasty;
// Remember last mouse coordinates
Button erase_button;
// The Erase button
Graphics g;
// A Graphics object for drawing
/** Initialize the button and the Graphics object */
public void init() {
erase_button = new Button("Erase");
this.add(erase_button);
g = this.getGraphics();
128 Chapter 7 – Applets

Example 7−2: An Applet That Uses the Java 1.0 Event Model (continued)
this.requestFocus(); // Ask for keyboard focus so we get key events
}
/** Respond to mouse clicks */
public boolean mouseDown(Event e, int x, int y) {
lastx = x; lasty = y;
// Remember where the click was
return true;
}
/** Respond to mouse drags */
public boolean mouseDrag(Event e, int x, int y) {
g.setColor(Color.black);
g.drawLine(lastx, lasty, x, y);
// Draw from last position to here
lastx = x; lasty = y;
// And remember new last position
return true;
}
/** Respond to key presses: erase drawing when user types 'e' */
public boolean keyDown(Event e, int key) {
if ((e.id == Event.KEY_PRESS) && (key == 'e')) {
g.setColor(this.getBackground());
g.fillRect(0, 0, bounds().width, bounds().height);
return true;
}
else return false;
}
/** Respond to button clicks: erase drawing when user clicks button */
public boolean action(Event e, Object arg) {
if (e.target == erase_button) {
g.setColor(this.getBackground());
g.fillRect(0, 0, bounds().width, bounds().height);
return true;
}
else return false;
}
}
Inc luding Applets in HTML Files
Applets are typically embedded in HTML ﬁles using the <APPLET> tag. Another
alter native relies on a Java Plug-in and uses the <EMBED> and <OBJECT> tags. Multi-
ple applet ﬁles can be combined into a single JAR (Java Archive) ﬁle that a web
br owser can read as a single, compressed ﬁle, substantially reducing download
time for some applets.
The <APPLET> Tag
A Java applet is included in a web page with the <APPLET> tag, which has the fol-
lowing syntax (items in brackets ([]) are optional):
<APPLET
CODE = applet-filename
WIDTH = pixel-width
HEIGHT = pixel-height
[OBJECT = serialized-applet-filename]
[ARCHIVE = jar-file-list]
[CODEBASE = applet-url]
Applets
Including Applets in HTML Files
129

[ALT = alternate-text]
[NAME = applet-name]
[ALIGN = alignment]
[VSPACE = vertical-pixel-space]
[HSPACE = horizontal-pixel-space]
>
[<PARAM NAME = parameter VALUE = value>]
[<PARAM NAME = parameter VALUE = value>]
...
[alternate-text]
</APPLET>
<APPLET>
The <APPLET> tag speciﬁes an applet to be run within a web document. A
web browser that does not support Java and does not understand the
<APPLET> tag ignores this tag and any related <PARAM> tags and simply dis-
plays any alternate-text that appears between <APPLET> and </APPLET>. A
br owser that does support Java runs the speciﬁed applet and does not display
the alternate-text.
CODE
This requir ed attribute speciﬁes the ﬁle that contains the compiled Java code
for the applet. It must be relative to the CODEBASE, if that attribute is speciﬁed
or relative to the current document’s URL, by default. It must not be an abso-
lute URL. As of Java 1.1, this attribute can be replaced with an OBJECT
attribute.
WIDTH
This attribute speciﬁes the initial width, in pixels, that the applet needs in the
br owser’s window. It is requir ed.
HEIGHT
This attribute speciﬁes the initial height, in pixels, that the applet needs in the
br owser’s window. It is requir ed.
OBJECT
As of Java 1.1, this attribute speciﬁes the name of a ﬁle that contains a serial-
ized applet that is to be created by deserialization. An applet speciﬁed in this
way does not have its init() method invoked but does have its start()
method invoked.
Thus, before an applet is saved through serialization, it
should be initialized but should not be started, or, if started, it should be
stopped. An applet must have either the CODE or OBJECT attribute speciﬁed,
but not both.
ARCHIVE
As of Java 1.1, this attribute speciﬁes a comma-separated list of JAR ﬁles that
ar e pr eloaded by the web browser or applet viewer. These archive ﬁles may
contain Java class ﬁles, images, sounds, properties, or any other resources
requir ed by the applet. The web browser or applet viewer searches for
requir ed ﬁles in the archives before attempting to load them over the net-
work.
130 Chapter 7 – Applets

CODEBASE
This optional attribute speciﬁes the base URL (absolute or relative) of the
applet to be displayed. This should be a directory, not the applet ﬁle itself. If
this attribute is unspeciﬁed, the URL of the current document is used.
ALT This optional attribute speciﬁes text that should be displayed by browsers that
understand the <APPLET> tag but do not support Java.
NAME
This optional attribute gives a name to the applet instance. Applets that are
running at the same time can look one another up by name and communicate
with one another.
ALIGN
This optional attribute speciﬁes the applet’s alignment on the page. It behaves
just like the ALIGN attribute of the <IMG> tag. Its allowed values are: left,
right, top, texttop, middle, absmiddle, baseline, bottom, and absbottom.
VSPACE
This optional attribute speciﬁes the margin, in pixels, that the browser should
put above and below the applet. It behaves just like the VSPACE attribute of
the <IMG> tag.
HSPACE
This optional attribute speciﬁes the margin, in pixels, that the browser should
put on either side of the applet. It behaves just like the HSPACE attribute of
the <IMG> tag.
<PARAM>
The <PARAM> tag, with its NAME and VALUE attributes, speciﬁes a named param-
eter and its corresponding string value that are passed to the applet. These
applet parameters function like system properties or command-line arguments
do for a regular application. Any number of <PARAM> tags may appear
between <APPLET> and </APPLET>. An applet can look up the value of a
parameter speciﬁed in a <PARAM> tag with the getParameter() method of
Applet.
Using Applet JAR Files
The <APPLET> tag supports an ARCHIVE attribute that identiﬁes a JAR ﬁle containing
the ﬁles requir ed by an applet. The JAR, or Java Archive, format is simply a ZIP
ﬁle with the addition of an optional manifest ﬁle. When an applet implementation
involves more than one class ﬁle or when an applet relies on external image or
sound ﬁles, it can be quite useful to combine all these ﬁles into a single, com-
pr essed JAR ﬁle and allow the web browser to download them all at once.
Starting with Java 1.1, Sun’s Java SDK contains a jar command that allows you to
cr eate a JAR ﬁle. You might invoke it like this to create a JAR ﬁle named myap-
plet.jar that contains all class ﬁles, GIF images, and AU format sound ﬁles in the
curr ent dir ectory:
% jar cf myapplet.jar *.class *.gif *.au
Applets
Including Applets in HTML Files
131

Having created a JAR ﬁle like this, you can tell a web browser about it with the
following HTML tags:
<APPLET ARCHIVE="myapplet.jar" CODE="myapplet.class" WIDTH=400 HEIGHT=200>
</APPLET>
The ARCHIVE attribute does not replace the CODE attribute. ARCHIVE speciﬁes where
to look for ﬁles, but CODE is still requir ed to tell the browser which of the ﬁles in
the archive is the applet class ﬁle to be executed. The ARCHIVE attribute may actu-
ally specify a comma-separated list of JAR ﬁles. The web browser or applet viewer
searches these archives for any ﬁles the applet requir es. If a ﬁle is not found in an
archive, however, the browser falls back upon its old behavior and attempts to
load the ﬁle from the web server using a new HTTP request.
Web browsers introduced support for the ARCHIVE attribute at about the same time
that Java 1.1 was introduced. Some Java 1.0 browsers do not recognize ARCHIVE
and therefor e ignor e it. If you want to maintain compatibility with these browsers,
be sure to make your applet ﬁles available in an unarchived form, in addition to
the more efﬁcient archived form.
Using Applets with the Java Plug-in
When a Java-enabled web browser encounters an <APPLET> tag, it starts up its
embedded Java VM, downloads the class ﬁles that implement the applet, and starts
running them. This approach has run into difﬁculties because web browser
releases are not synchronized with releases of new versions of Java. It was quite a
while after the release of Java 1.1 before commonly used browsers supported this
version of the language, and there are still quite a few browsers in use that sup-
port only Java 1.0. It is not at all clear when, or even if, browsers will include sup-
port for the Java 2 platform. Furthermor e, because of the lawsuit between Sun and
Micr osoft, the future of integrated Java support in the popular Internet Explorer
web browser is questionable.
For these reasons, Sun has produced a product called the Java Plug-in. This prod-
uct is a Java VM that acts as a Netscape Navigator plug-in and as an Internet
Explor er ActiveX control. It adds Java 1.2 support to these browsers for the Win-
dows and Solaris platforms. In many ways, Java support makes the most sense as
a plug-in; using the Java Plug-in may be the preferr ed method for distributing Java
applets in the future.
Ther e is a catch, however. To run an applet under the Java Plug-in, you cannot
use the <APPLET> tag. <APPLET> invokes the built-in Java VM, not the Java Plug-in.
Instead, you must invoke the Java Plug-in just as you would invoke any other Nav-
igator plug-in or Internet Explorer ActiveX control. Unfortunately, Netscape and
Micr osoft have deﬁned differ ent HTML tags for these purposes. Netscape uses the
<EMBED> tag, and Microsoft uses the <OBJECT> tag. The details of using these tags
and combining them in a portable way are messy and confusing. To help applet
developers, Sun distributes a special HTML converter program that you can run
over your HTML ﬁles. It scans for <APPLET> tags and converts them to equivalent
<EMBED> and <OBJECT> tags.
132 Chapter 7 – Applets

Consider the simple HTML ﬁle we used for the ﬁrst applet example in this chapter:
<APPLET code="MessageApplet.class" width=350 height=125>
<PARAM name="message" value="Hello World">
</APPLET>
When run through the HTML converter, this tag becomes something like this:
<OBJECT classid="clsid:8AD9C840-044E-11D1-B3E9-00805F499D93"
codebase=
"http://java.sun.com/products/plugin/1.2/jinstall-12-win32.cab#Version=1,2,0,0"
WIDTH=350 HEIGHT=125>
<PARAM NAME=CODE VALUE="MessageApplet.class" >
<PARAM NAME="type" VALUE="application/x-java-applet;version=1.2">
<PARAM NAME="message" VALUE="Hello World">
<COMMENT>
<EMBED type="application/x-java-applet;version=1.2"
pluginspage=
"http://java.sun.com/products/plugin/1.2/plugin-install.html"
java_CODE="MessageApplet.class"
WIDTH=350 HEIGHT=125 message="Hello World">
</EMBED>
</COMMENT>
</OBJECT>
When Navigator reads this HTML ﬁle, it ignores the <OBJECT> and <COMMENT> tags
that it does not support and reads only the <EMBED> tag. When Internet Explorer
reads the ﬁle, however, it handles the <OBJECT> tag and ignores the <EMBED> tag
that is hidden within the <COMMENT> tag. Note that both the <OBJECT> and <EMBED>
tags specify all the attributes and parameters speciﬁed in the original ﬁle. In addi-
tion, however, they identify the plug-in or ActiveX control to be used and tell the
br owser fr om wher e it can download the Java Plug-in, if it has not already down-
loaded it.
You can learn mor e about the Java Plug-in and download the HTML converter util-
ity from http://java.sun.com/pr oducts/plugin.
Applet Security
One of the most important features of Java is its security model. It allows untrusted
code, such as applets downloaded from arbitrary web sites, to be run in a
restricted environment that prevents that code from doing anything malicious, like
deleting ﬁles or sending fake email. The Java security model has evolved consider-
ably between Java 1.0 and Java 1.2 and is covered in detail in Java in a Nutshell.
To write applets, you don’t need to understand the entire Java security model.
What you do need to know is that when your applet is run as untrusted code, it is
subject to quite a few security restrictions that limit the kinds of things it can do.
This section describes those security restrictions and also describes how you can
attach a digital signature to applets, so that users can treat them as trusted code
and run them in a less restrictive environment.
The following list details the security restrictions that are typically imposed on
untrusted applet code. Differ ent web browsers and applet viewers may impose
Applets
Applet Security
133

slightly differ ent security restrictions and may allow the end user to customize or
selectively relax the restrictions. In general, however, you should assume that your
untrusted applet are restricted in the following ways:
•
Untrusted code cannot read from or write to the local ﬁlesystem. This means
that untrusted code cannot:
–
Read ﬁles
–
List directories
–
Check for the existence of ﬁles
–
Obtain the size or modiﬁcation date of ﬁles
–
Obtain the read and write permissions of a ﬁle
–
Test whether a ﬁlename is a ﬁle or directory
–
Write ﬁles
–
Delete ﬁles
–
Create directories
–
Rename ﬁles
–
Read or write from FileDescriptor objects
•
Untrusted code cannot perfor m networking operations, except in certain
restricted ways. Untrusted code cannot:
–
Create a network connection to any computer other than the one from
which the code was itself loaded
–
Listen for network connections on any of the privileged ports with num-
bers less than or equal to 1,024
–
Accept network connections on ports less than or equal to 1,024 or from
any host other than the one from which the code itself was loaded
–
Use multicast sockets
–
Create or register a SocketImplFactory, URLStreamHandlerFactory, or
ContentHandlerFactory
•
Untrusted code cannot make use of certain system facilities. It cannot:
–
Exit the Java interpreter by calling System.exit() or Runtime.exit()
–
Spawn new processes by calling any of the Runtime.exec() methods
–
Dynamically load native code libraries with the load() or loadLibrary()
methods of Runtime or System
•
Untrusted code cannot make use of certain AWT facilities. One major restric-
tion is that all windows created by untrusted code display a prominent visual
indication that they have been created by untrusted code and are “insecur e.”
134 Chapter 7 – Applets

This is to prevent untrusted code from spooﬁng the on-screen appearance of
trusted code. Additionally, untrusted code cannot:
–
Initiate a print job
–
Access the system clipboard
–
Access the system event queue
•
Untrusted code has restricted access to system properties. It cannot call Sys-
tem.getProperties(), so it cannot modify or insert properties into the system
pr operties list. It can call System.getProperty() to read individual properties
but can read only system properties to which it has been explicitly granted
access. By default, appletviewer grants access to only the following 10 proper-
ties. Note that user.home and user.dir ar e excluded:
–
java.version
–
java.class.version
–
java.vendor
–
java.vendor.url
–
os.name
–
os.version
–
os.arch
–
file.separator
–
path.separator
–
line.separator
•
Untrusted code cannot create or access threads or thread groups outside of
the thread group in which the untrusted code is running.
•
Untrusted code has restrictions on the classes it can load and deﬁne. It can-
not:
–
Explicitly load classes from the sun.* packages
–
Deﬁne classes in any of the java.* or sun.* packages
–
Create a ClassLoader object or call any ClassLoader methods
•
Untrusted code cannot use the java.lang.Class reﬂection methods to obtain
infor mation about nonpublic members of a class, unless the class was loaded
fr om the same host as the untrusted code.
Applets
Applet Security
135

•
Untrusted code has restrictions on its use of the java.security package. It
cannot:
–
Manipulate security identities in any way
–
Set or read security properties
–
List, look up, insert, or remove security providers
–
Finally, to prevent untrusted code from circumventing all of these restric-
tions, it is not allowed to create or register a SecurityManager object.
Local Applets
When an applet is loaded from the local ﬁlesystem, instead of through a network
pr otocol, web browsers and applet viewers may relax some, or even many, of the
pr eceding restrictions. The reason for this is that local applets are assumed to be
mor e trustworthy than anonymous applets from the network.
Inter mediate applet security policies are also possible. For example, an applet
viewer can be written so that it places fewer restrictions on applets loaded from an
inter nal corporate network than on those loaded from the Internet.
Signed Applets
Java 1.1 added the ability to attach a digital signature to a JAR ﬁle that contains an
applet. This signature secur ely identiﬁes the author or origin of an applet. If you
trust the author or originating organization, you can conﬁgure your web browser
or applet viewer to run applets bearing that signature as trusted code, rather than
as untrusted code. Such an applet runs without the onerous security restrictions
placed on untrusted applets. Java 1.2 platform actually allows the security policy to
be customized based on the origin of an applet. This means that an end user or
system administrator may deﬁne multiple levels of trust, allowing fully trusted
applets to run with all the privileges of a standalone application, while partially
trusted applets run with a reduced list of security restrictions.
The process of attaching a digital signature to an applet’s JAR ﬁle is platform
dependent. In Java 1.1, you use the javakey pr ogram. In Java 1.2, this program has
been superseded by jarsigner. Netscape and Microsoft also provide their own digi-
tal signature programs that are customized for use with their browsers.
The process of telling your web browser or applet viewer which digital signatures
to trust is also vendor dependent, of course. In Java 1.1, you use javakey to spec-
ify which signatures are trusted. In Java 1.2, you use a differ ent tool, policytool, to
specify trusted signatures and the security policies associated with them. See Java
in a Nutshell for further details.
136 Chapter 7 – Applets

PART II
API Quick Reference
Part II is the real heart of this book: quick-refer ence material for the APIs
that comprise the Java Foundation Classes. Please read the following sec-
tion, How To Use This Quick Reference, to lear n how to get the most out of
this material.
Chapter 8, The java.applet Package
Chapter 9, The java.awt Package
Chapter 10, The java.awt.color Package
Chapter 11, The java.awt.datatransfer Package
Chapter 12, The java.awt.dnd Package
Chapter 13, The java.awt.dnd.peer Package
Chapter 14, The java.awt.event Package
Chapter 15, The java.awt.font Package
Chapter 16, The java.awt.geom Package
Chapter 17, The java.awt.im Package
Chapter 18, The java.awt.image Package
Chapter 19, The java.awt.image.renderable Package
Chapter 20, The java.awt.peer Package
Chapter 21, The java.awt.print Package
Chapter 22, The javax.accessibility Package
Chapter 23, The javax.swing Package
Chapter 24, The javax.swing.border Package
Chapter 25, The javax.swing.colorchooser Package
Chapter 26, The javax.swing.event Package
Chapter 27, The javax.swing.ﬁlechooser Package
Chapter 28, The javax.swing.plaf Package
Chapter 29, The javax.swing.table Package
Chapter 30, The javax.swing.text Package

Chapter 31, The javax.swing.text.html Package
Chapter 32, The javax.swing.text.html.parser Package
Chapter 33, The javax.swing.text.rtf Package
Chapter 34, The javax.swing.tree Package
Chapter 35, The javax.swing.undo Package
Chapter 36, Class Index

How To Use This
Quick Reference
The quick-refer ence section that follows packs a lot of information into a small
space. This introduction explains how to get the most out of that information. It
describes how the quick refer ence is organized and how to read the individual
quick-r ef entries.
Finding a Quick Reference Entry
The quick refer ence is organized into chapters, one per package. Each chapter
begins with an overview of the package and includes a hierarchy diagram for the
classes and interfaces in the package. Following this overview are quick refer ence
entries for all of the classes and interfaces in the package.
Entries are organized alphabetically by class and package name, so that related
classes are grouped near each other. Thus, in order to look up a quick refer ence
entry for a particular class, you must also know the name of the package that con-
tains that class. Usually, the package name is obvious from the context, and you
should have no trouble looking up the quick-refer ence entry you want. Use the
tabs on the outside edge of the book and the “dictionary-style” headers on the
upper outside corner of each page to help you ﬁnd the package and class you are
looking for.
Occasionally, you may need to look up a class for which you do not already know
the package. In this case, refer to Chapter 36, Class Index. This index allows you
to look up a class by class name and ﬁnd out what package it is part of.
Reading a Quick Reference Entry
Each quick-refer ence entry contains quite a bit of information. The sections that
follow describe the structure of a quick-r efer ence entry, explaining what informa-
tion is available, where it is found, and what it means. While reading the
How To
139

descriptions that follow, you will ﬁnd it helpful to ﬂip through the refer ence sec-
tion itself to ﬁnd examples of the features being described.
Class Name, Package Name, Availability, and Flags
Each quick-refer ence entry begins with a four-part title that speciﬁes the name,
package, and availability of the class, and may also specify various additional ﬂags
that describe the class. The class name appears in bold at the upper-left of the
title. The package name appears, in smaller print, in the lower-left, below the class
name.
The upper-right portion the title indicates the availability of the class; it speciﬁes
the earliest release that contained the class. If a class was introduced in Java 1.1,
for example, this portion of the title reads “Java 1.1”. If a class was introduced in
Version 1.2 of the Java 2 platform, the availability reads “Java 1.2”, for simplicity’s
sake. The availability section of the title is also used to indicate whether a class
has been deprecated, and, if so, in what release. For example, it might read “Java
1.1; Deprecated in Java 1.2”.
In the lower-right corner of the title you may ﬁnd a list of ﬂags that describe the
class. The possible ﬂags and their meanings are as follows:
accessible
The class, or a superclass, implements javax.accessibility.Accessible. This ﬂag may be
followed by a parenthesized list that speciﬁes the speciﬁc types of accessibil-
ity supported by this class. The possible accessibility types are action, selec-
tion, value, text, and hypertext. When present, a type indicates that the
javax.accessibility.AccessibleContext for this class can retur n an accessiblity object of
that type. For example, a class that is accessible(action,selection) has an Acces-
sibleContext whose getAccessibleAction() and getAccessibleSelection()
methods retur n
non-null javax.accessibility.AccessibleAction and javax.accessibility.AccessibleSelection objects,
respectively. The AccessibleContext for an accessible component has a getAccessible-
Component() method that retur ns an AccessibleComponent object. Because this is true
for all components, however, it is not specially ﬂagged here.
AccessibleContext classes are typically implemented as protected inner classes of
the accessible class itself. This book does not contain refer ence entries for
these classes because all the necessary information about them is contained in
the accessible class ﬂag of the accessible class, in the single-line inner class
synopsis that appears in the containing accessible class, and in Chapter 22,
The javax.accessibility Package.
AWT component
The class extends java.awt.Component, but does not extend javax.swing .JComponent.
bean container
The class may contain JavaBeans components.
checked
The class is a checked exception, which means that it extends java.lang .Exception,
but not java.lang .RuntimeException. In other words, it must be declared in the throws
clause of any method that may throw it.
140 How To Use This Quick Reference

cloneable
The class, or a superclass, implements java.lang .Cloneable.
collection
The class, or a superclass, implements java.util.Collection or java.util.Map.
comparable
The class, or a superclass, implements java.lang .Comparable.
err or
The class extends java.lang .Error.
event
The class extends java.util.EventObject.
event adapter
The class, or a superclass, implements java.util.EventListener, and the class name
ends with “Adapter”.
event listener
The class, or a superclass, implements java.util.EventListener.
layout manager
The class, or a superclass, implements java.awt.LayoutManager.
model
The class is Swing class whose name ends with “Model”.
PJ1.1
The class or interface is part of the Personal Java 1.1 platform.
PJ1.1(mod)
The class or interface is supported, in modiﬁed form, by the Personal Java 1.1
platfor m.
PJ1.1(opt)
The class or interface is an optional part of the Personal Java 1.1 platform.
Support for the class is implementation-dependent.
remote
The class, or a superclass, implements java.r mi.Remote.
runnable
The class, or a superclass, implements java.lang .Runnable.
serializable
The class, or a superclass, implements java.io.Serializable and may be serialized.
shape
The class, or a superclass, implements java.awt.Shape.
swing component
The class extends javax.swing .JComponent.
How To
How To Use This Quick Reference 141

unchecked
The class is an unchecked exception, which means it extends java.lang .RuntimeEx-
ception and therefor e does not need to be declared in the throws clause of a
method that may throw it.
Descr iption
The title of each quick-refer ence entry is followed by a short description of the
most important features of the class or interface. This description may be any-
wher e fr om a couple of sentences to several paragraphs long.
Synopsis
The most important part of every quick-refer ence entry is the class synopsis,
which follows the title and description. The synopsis for a class looks a lot like the
source code for the class, except that the method bodies are omitted and some
additional annotations are added. If you know Java syntax, you know how to read
the class synopsis.
The ﬁrst line of the synopsis contains information about the class itself. It begins
with a list of class modiﬁers, such as public, abstract, and ﬁnal. These modiﬁers are
followed by the class or interface keyword and then by the name of the class. The
class name may be followed by an extends clause that speciﬁes the superclass and
an implements clause that speciﬁes any interfaces the class implements.
The class deﬁnition line is followed by a list of the ﬁelds and methods that the
class deﬁnes. Once again, if you understand basic Java syntax, you should have no
tr ouble making sense of these lines. The listing for each member includes the
modiﬁers, type, and name of the member. For methods, the synopsis also includes
the type and name of each method parameter and an optional throws clause that
lists the exceptions the method can throw. The member names are in boldface, so
that it is easy to scan the list of members looking for the one you want. The names
of method parameters are in italics to indicate that they are not to be used literally.
The member listings are printed on alternating gray and white backgrounds to
keep them visually separate.
Member availability and flags
Each member listing is a single line that deﬁnes the API for that member. These
listings use Java syntax, so their meaning is immediately clear to any Java pro-
grammer. Ther e is some auxiliary information associated with each member syn-
opsis, however, that requir es explanation.
Recall that each quick-refer ence entry begins with a title section that includes the
release in which the class was ﬁrst deﬁned. When a member is introduced into a
class after the initial release of the class, the version in which the member was
intr oduced appears, in small print, to the left of the member synopsis. For exam-
ple, if a class was ﬁrst introduced in Java 1.1, but had a new method added in Ver-
sion 1.2 of Java 2, the title contains the string “Java 1.1”, and the listing for the new
member is preceded by the number “1.2”. Furthermor e, if a member has been
142 How To Use This Quick Reference

depr ecated, that fact is indicated with a hash mark (#) to the left of the member
synopsis.
The area to the right of the member synopsis is used to display a variety of ﬂags
that provide additional information about the member. Some of these ﬂags indicate
additional speciﬁcation details that do not appear in the member API itself. Other
ﬂags contain implementation-speciﬁc information. This information can be quite
useful in understanding the class and in debugging your code, but be aware that it
may differ between implementations. The implementation-speciﬁc ﬂags displayed
in this book are based on Sun’s implementation of Java for Microsoft Windows.
The following ﬂags may be displayed to the right of a member synopsis:
native
An implementation-speciﬁc ﬂag that indicates that a method is implemented
in native code. Although native is a Java keyword and can appear in method
signatur es, it is part of the method implementation, not part of its speciﬁca-
tion. Therefor e, this information is included with the member ﬂags, rather
than as part of the member listing. This ﬂag is useful as a hint about the
expected perfor mance of a method.
synchr onized
An implementation-speciﬁc ﬂag that indicates that a method implementation is
declar ed synchronized, meaning that it obtains a lock on the object or class
befor e executing. Like the native keyword, the synchronized keyword is part of
the method implementation, not part of the speciﬁcation, so it appears as a
ﬂag, not in the method synopsis itself. This ﬂag is a useful hint that the
method is probably implemented in a thread-safe manner.
Whether or not a method is thread-safe is part of the method speciﬁcation,
and this information should appear (although it often does not) in the method
documentation. There are a number of differ ent ways to make a method
thr ead-safe, however, and declaring the method with the synchronized keyword
is only one possible implementation. In other words, a method that does not
bear the synchronized ﬂag can still be thread-safe.
Overrides:
Indicates that a method overrides a method in one of its superclasses. The
ﬂag is followed by the name of the superclass that the method overrides. This
is a speciﬁcation detail, not an implementation detail. As we’ll see in the next
section, overriding methods are usually grouped together in their own section
of the class synopsis. The Over rides: ﬂag is only used when an overriding
method is not grouped in that way.
Implements:
Indicates that a method implements a method in an interface. The ﬂag is fol-
lowed by the name of the interface that is implemented. This is a speciﬁcation
detail, not an implementation detail. As we’ll see in the next section, methods
that implement an interface are usually grouped into a special section of the
class synopsis. The Implements: ﬂag is only used for methods that are not
gr ouped in this way.
How To
How To Use This Quick Reference 143

empty
Indicates that the implementation of the method has an empty body. This can
be a hint to the programmer that the method may need to be overridden in a
subclass.
constant
An implementation ﬂag that indicates that a method has a trivial implementa-
tion. Only methods with a void retur n type can be truly empty. Any method
declar ed to retur n a value must have at least a retur n statement. The “constant”
ﬂag indicates that the method implementation is empty except for a retur n
statement that retur ns a constant value. Such a method might have a body like
retur n null; or retur n false;. Like the “empty” ﬂag, this ﬂag indicates that a method
may need to be overridden.
default:
This ﬂag is used with property accessor methods that read the value of a
pr operty (i.e., methods whose names begins with “get” and take no argu-
ments). The ﬂag is followed by the default value of the property. Strictly
speaking, default property values are a speciﬁcation detail. In practice, how-
ever, these defaults are not always documented, and care should be taken,
because the default values may change between implementations.
Not all property accessors have a “default:” ﬂag. A default value is determined
by dynamically loading the class in question, instantiating it using a no-argu-
ment constructor, and then calling the method to ﬁnd out what it retur ns.
This technique can be used only on classes that can be dynamically loaded
and instantiated and that have no-argument constructors, so default values are
shown for those classes only. Furthermor e, note that when a class is instanti-
ated using a differ ent constructor, the default values for its properties may be
dif ferent.
bound
This ﬂag is used with property accessor methods for bound properties of Jav-
aBeans components. The presence of this ﬂag means that calling the method
generates a java.beans.Proper tyChangeEvent. This is a speciﬁcation detail, but it is
sometimes not documented. Information about bound properties is obtained
fr om the BeanInfo object for the class.
constrained
Indicates that a JavaBeans component property is constrained. In other words,
the method may throw a java.beans.Proper tyVetoException. This is a speciﬁcation
detail, not an implementation detail.
expert
Indicates that the BeanInfo object for this class speciﬁes that this method is
intended for use by experts only. This hint is intended for visual programming
tools, but users of this book may ﬁnd the hint useful as well.
hidden
Indicates that the BeanInfo object for this class speciﬁes that this method is for
inter nal use only. This is a hint that visual programming tools should hide the
pr operty or event from the programmer. This book does not hide these meth-
144 How To Use This Quick Reference

ods, of course, but this ﬂag does indicate that you should probably avoid
using the method.
pr eferr ed
Indicates that the BeanInfo object for this class speciﬁes that this method is an
accessor for a default or preferr ed pr operty or event. This is a hint to visual
pr ogramming tools to display the property or event in a prominent way, and
it may also be a useful hint to readers of this book.
=
For static ﬁnal ﬁelds, this ﬂag is followed by the constant value of the ﬁeld.
Only constants of primitive and String types and constants with the value null
ar e displayed. Some constant values are speciﬁcation details, while others are
implementation details. The reason that symbolic constants are deﬁned, how-
ever, is so you can write code that does not rely directly upon the constant
value. Use this ﬂag to help you understand the class, but do not rely upon the
constant values in your own programs.
Functional grouping of members
Within a class synopsis, the members are not listed in strict alphabetical order.
Instead, they are broken down into functional groups and listed alphabetically
within each group. Constructors, methods, ﬁelds, and inner classes are all listed
separately. Instance methods are kept separate from static (class) methods. Con-
stants are separated from non-constant ﬁelds. Public members are listed separately
fr om pr otected members. Grouping members by category breaks a class down into
smaller, mor e compr ehensible segments, making the class easier to understand.
This grouping also makes it easier for you to ﬁnd a desired member.
Functional groups are separated from each other in a class synopsis with Java
comments, such as “// Public Constructors”, “// Inner Classes”, and “// Methods
Implementing Servlet”. The various functional categories are as follows (in the
order in which they appear in a class synopsis):
Constructors
Displays the constructors for the class. Public constructors and protected con-
structors are displayed separately in subgroupings. If a class deﬁnes no con-
structor at all, the Java compiler adds a default no-argument constructor that is
displayed here. If a class deﬁnes only private constructors, it cannot be instan-
tiated, so a special, empty grouping entitled “No Constructor” indicates this
fact. Constructors are listed ﬁrst because the ﬁrst thing you do with most
classes is instantiate them by calling a constructor.
Constants
Displays all of the constants (i.e., ﬁelds that are declar ed static and ﬁnal)
deﬁned by the class. Public and protected constants are displayed in separate
subgr oups. Constants are listed here, near the top of the class synopsis,
because constant values are often used throughout the class as legal values
for method parameters and retur n values.
How To
How To Use This Quick Reference 145

Inner Classes
Gr oups all of the inner classes and interfaces deﬁned by the class or interface.
For each inner class, there is a single-line synopsis. Each inner class also has
its own quick-refer ence entry that includes a full class synopsis for the inner
class. Like constants, inner classes are listed near the top of the class synopsis
because they are often used by a number of other members of the class.
Static Methods
Lists the static methods (class methods) of the class, broken down into sub-
gr oups for public static methods and protected static methods.
Event Listener Registration Methods
Lists the public instance methods that register and deregister event listener
objects with the class. The names of these methods begin with the words
“add” and “remove” and end in “Listener”. These methods are always passed
a java.util.EventListener object. The methods are typically deﬁned in pairs, so the
pairs are listed together. The methods are listed alphabetically by event name,
rather than by method name.
Pr operty Accessor Methods
Lists the public instance methods that set or query the value of a property or
attribute of the class.
The names of these methods begin with the words
“set”, “get”, and “is”, and their signatures follow the patterns set out in the Jav-
aBeans speciﬁcation.
Although the naming conventions and method signa-
tur e patter ns ar e deﬁned for JavaBeans, classes and interfaces throughout the
Java platform deﬁne property accessor methods that follow these conventions
and patterns. Looking at a class in terms of the properties it deﬁnes can be a
power ful tool for understanding the class, so property methods are grouped
together in this section.
Pr operty accessor methods are listed alphabetically by property name, not by
method name. This means that the “set”, “get”, and “is” methods for a prop-
erty all appear together. This book deﬁnes a property accessor method in a
somewhat more general way than the JavaBeans speciﬁcation does. A method
is considered to be a property accessor if it follows the JavaBeans conventions
itself or if it has the same name as a method that follows those conventions.
Consider the setSize() method of the Component class. There are two versions of
this method, and, since they have the same name, they obviously share a pur-
pose and deserve to be grouped together. However, only one version of the
method strictly follows the JavaBeans signature patter ns. The relaxed deﬁni-
tion of what constitutes a property accessor method allows these two meth-
ods to be listed together, as they should be.
Public Instance Methods
Contains all of the public instance methods that are not grouped elsewhere.
Implementing Methods
Gr oups the methods that implement the same interface. There is one sub-
gr oup for each interface implemented by the class. Methods that are deﬁned
by the same interface are almost always related to each other, so this is a use-
ful functional grouping of methods.
146 How To Use This Quick Reference

Note that if an interface method is also an event registration method or a
pr operty accessor method, it is listed both in this group and in the event or
pr operty gr oup. This situation does not arise often, but when it does, all of
the functional groupings are important and useful enough to warrant the
duplicate listing. When an interface method is listed in the event or property
gr oup, it displays an “Implements:” ﬂag that speciﬁes the name of the inter-
face of which it is part.
Overriding Methods
Gr oups the methods that override methods of a superclass broken down into
subgr oups by superclass. This is typically a useful grouping, because it helps
to make it clear how a class modiﬁes the default behavior of its superclasses.
In practice, it is also often true that methods that override the same superclass
ar e functionally related to each other.
Sometimes a method that overrides a superclass is also a property accessor
method or (more rar ely) an event registration method. When this happens,
the method is grouped with the property or event methods and displays a ﬂag
that indicates which superclass it overrides. The method is not listed with
other overriding methods, however. Note that this is differ ent fr om inter face
methods, which, because they are mor e str ongly functionally related, may
have duplicate listings in both groups.
Pr otected Instance Methods
Contains all of the protected instance methods that are not grouped else-
wher e.
Fields
Lists all the non-constant ﬁelds of the class, breaking them down into sub-
gr oups for public and protected static ﬁelds and public and protected instance
ﬁelds. Many classes do not deﬁne any publicly accessible ﬁelds. For those that
do, many object-oriented programmers prefer not to use those ﬁelds directly,
but instead to use accessor methods when such methods are available.
Depr ecated Members
Depr ecated methods and deprecated ﬁelds are grouped at the very bottom of
the class synopsis. Use of these members is strongly discouraged.
Class Hierar chy
For any class or interface that has a non-trivial class hierarchy, the class synopsis is
followed by a Hierarchy section. This section lists all of the superclasses of the
class, as well as any interfaces implemented by those superclasses. It may also list
any interfaces extended by an interface. In the hierarchy listing, arrows indicate
superclass to subclass relationships, while the interfaces implemented by a class
follow the class name in parentheses. For example, the following hierarchy indi-
cates that java.awt.AWTException extends Exception which extends Throwable (which imple-
ments Serializable) which extends Object:
Object→Throwable(Serializable)→Exception→AWTException
How To
How To Use This Quick Reference 147

If a class has subclasses, the “Hierarchy” section is followed by a “Subclasses” sec-
tion that lists those subclasses. If an interface has implementations, the “Hierarchy”
section is followed by an “Implementations” section that lists those implementa-
tions. While the “Hierarchy” section shows ancestors of the class, the “Subclasses”
or “Implementations” section shows descendants.
Cross References
The class hierarchy section of a quick-refer ence entry is followed by a number of
optional “cross refer ence” sections that indicate other, related classes and methods
that may be of interest. These sections are the following:
Passed To
This section lists all of the methods and constructors that are passed an object
of this type as an argument. This is useful when you have an object of a
given type and want to ﬁgure out what you can do with it.
Retur ned By
This section lists all of the methods (but not constructors) that retur n an object
of this type. This is useful when you know that you want to work with an
object of this type, but don’t know how to obtain one.
Thr own By
For checked exception classes, this section lists all of the methods and con-
structors that throw exceptions of this type. This material helps you ﬁgure out
when a given exception or error may be thrown. Note, however, that this sec-
tion is based on the exception types listed in the throws clauses of methods and
constructors. Subclasses of RuntimeException and Er ror do not have to be listed in
throws clauses, so it is not possible to generate a complete cross refer ence of
methods that throw these types of unchecked exceptions.
Type Of
This section lists all of the ﬁelds and constants that are of this type, which can
help you ﬁgure out how to obtain an object of this type.
A Note About Class Names
Thr oughout the quick refer ence, you’ll notice that classes are sometimes referr ed
to by class name alone and at other times referr ed to by class name and package
name. If package names were always used, the class synopses would become long
and hard to read. On the other hand, if package names were never used, it would
sometimes be difﬁcult to know what class was being referr ed to. The rules for
including or omitting the package name are complex. They can be summarized
appr oximately as follows, however:
•
If the class name alone is ambiguous, the package name is always used.
•
If the class is part of the java.lang package or is a very commonly used class
like java.io.Serializable or java.awt.Component, the package name is omitted.
148 How To Use This Quick Reference

•
If the class being referr ed to is part of the current package (and has a quick-
ref entry in the current chapter), the package name is omitted. The package
name is also omitted if the class being referr ed to is part of a package that
contains the current package.
How To
How To Use This Quick Reference 149

CHAPTER 8
The java.applet Package
The java.applet package is a small but important package that deﬁnes the Applet
class — the superclass of all applets. It also deﬁnes the AppletContext and AppletStub
inter faces, which are implemented by web browsers and other applet viewers.
Finally, for lack of a better place, this package contains the AudioClip inter face,
which repr esents a sound to be played. Figure 8-1 shows the class hierarchy of
this package. See Chapter 7, Applets, for more details about applets.
Component
Container
Panel
Applet
AudioClip
AppletStub
AppletContext
java.applet
java.awt
java.lang
Object
Serializable
java.awt.image
java.io
ImageObserver
MenuContainer
extends
implements
KEY
CLASS
FINAL CLASS
INTERFACE
Figur e 8−1: The java.applet package
Applet
Ja va 1.0
java.applet
serializable AWT component PJ1.1
This class implements an applet. To create your own applet, you should create a sub-
class of this class and override some or all of the following methods. Note that you
never need to call these methods—they are called when appropriate by a web browser
or other applet viewer.
150

init() should perfor m any initialization for the applet; it is called when the applet ﬁrst
starts. destroy() should free up any resources that the applet is holding; it is called when
the applet is about to be permanently stopped. star t() is called to make applet start
doing whatever it is that it does. Often, it starts a thread to perfor m an animation or
similar task. stop() should temporarily stop the applet from executing. It is called when
the applet temporarily becomes hidden or nonvisible.
getAppletInfo() should retur n text suitable for display in an About dialog posted by the
web browser or applet viewer. getParameterInfo() should retur n an arbitrary-length array
of three-element arrays of strings, where each element describes one of the parameters
that this applet understands. The three elements of each parameter description are
strings that specify the parameter’s name, type, and description, respectively.
In addition to these methods, an applet typically overrides several of the methods of
java.awt.Component, notably the paint() method to draw the applet on the screen.
Ther e ar e also several Applet methods that you do not override but may call from applet
code: showStatus() displays text in the web browser or applet viewer’s status line. getIm-
age() and getAudioClip() read image (GIF and JPEG formats) and audio ﬁles (AU format)
over the network and retur n corr esponding Java objects. getParameter() looks up the
value of a parameter speciﬁed with a <PARAM> tag within an <APPLET>/</APPLET> pair.
getCodeBase() retur ns the base URL from which the applet’s code was loaded, while get-
DocumentBase() retur ns the base URL from which the HTML document containing the
applet was loaded. Finally, getAppletContext() retur ns an AppletContext object.
public class Applet extends java.awt.Panel {
// Public Constructors
public Applet();
// Public Class Methods
1.2 public static ﬁnal AudioClip newAudioClip(java.net.URL url);
// Property Accessor Methods (by property name)
default:false
public boolean isActive();
public AppletContext getAppletContext();
constant default:null
public String getAppletInfo();
public java.net.URL getCodeBase();
public java.net.URL getDocumentBase();
Overrides:Component
1.1 public java.util.Locale getLocale();
constant default:null
public String[ ][ ] getParameterInfo();
// Public Instance Methods
empty
public void destroy();
public AudioClip getAudioClip(java.net.URL url);
public AudioClip getAudioClip(java.net.URL url, String name);
public java.awt.Image getImage(java.net.URL url);
public java.awt.Image getImage(java.net.URL url, String name);
public String getParameter(String name);
empty
public void init();
public void play(java.net.URL url);
public void play(java.net.URL url, String name);
public ﬁnal void setStub(AppletStub stub);
public void showStatus(String msg);
empty
public void star t();
empty
public void stop();
// Public Methods Overriding Component
public void resize(java.awt.Dimension d);
public void resize(int width, int height);
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→java.awt.Panel→Applet
java.applet
java.applet.Applet
Chapter 8 – The java.applet Package
151

Subc lasses: javax.swing .JApplet
Passed To: java.beans.AppletInitializer.{activate(), initialize()}, org.omg .CORBA.ORB.{init(),
set_parameters()}
Retur ned By: AppletContext.getApplet()
AppletContext
Ja va 1.0
java.applet
PJ1.1
This interface deﬁnes the methods that allow an applet to interact with the context in
which it runs (usually a web browser or an applet viewer). The getAppletContext()
method of Applet retur ns an object that implements the AppletContext inter face. You can
use an AppletContext to take advantage of a web browser’s cache or display a message to
the user in the web browser or applet viewer’s message area. The getAudioClip() and
getImage() methods may make use of a web browser’s caching mechanism. showDocu-
ment() and showStatus() give an applet a small measure of contr ol over the appearance of
the browser or applet viewer. The getApplet() and getApplets() methods allow an applet to
ﬁnd out what other applets are running at the same time.
public abstract interface AppletContext {
// Public Instance Methods
public abstract Applet getApplet(String name);
public abstract java.util.Enumeration getApplets();
public abstract AudioClip getAudioClip(java.net.URL url);
public abstract java.awt.Image getImage(java.net.URL url);
public abstract void showDocument(java.net.URL url);
public abstract void showDocument(java.net.URL url, String target);
public abstract void showStatus(String status);
}
Retur ned By: Applet.getAppletContext(), AppletStub.getAppletContext()
AppletStub
Ja va 1.0
java.applet
PJ1.1
This is an internal interface used when implementing an applet viewer.
public abstract interface AppletStub {
// Property Accessor Methods (by property name)
public abstract boolean isActive();
public abstract AppletContext getAppletContext();
public abstract java.net.URL getCodeBase();
public abstract java.net.URL getDocumentBase();
// Public Instance Methods
public abstract void appletResize(int width, int height);
public abstract String getParameter(String name);
}
Passed To: Applet.setStub()
AudioClip
Ja va 1.0
java.applet
PJ1.1
This interface describes the essential methods that an audio clip must have. The getAu-
dioClip() methods of Applet and AppletContext both retur n an object that implements this
inter face. The current Java SDK implementation of this interface works only with
sounds encoded in AU format. The AudioClip inter face is in the java.applet package only
because there is no better place for it.
java.applet.Applet
152 Chapter 8 – The java.applet Package

public abstract interface AudioClip {
// Public Instance Methods
public abstract void loop();
public abstract void play();
public abstract void stop();
}
Retur ned By: Applet.{getAudioClip(), newAudioClip()}, AppletContext.getAudioClip()
java.applet
java.applet.AudioClip
Chapter 8 – The java.applet Package
153

CHAPTER 9
The java.awt Package
The java.awt package is the main package of the AWT, or Abstract Windowing
Toolkit. It contains classes for graphics, including the Java 2D graphics capabilities
intr oduced in the Java 2 platform, and also deﬁnes the basic graphical user inter-
face (GUI) framework for Java. java.awt also includes a number of heavyweight
GUI objects, many of which have been superseded by the javax.swing package.
java.awt also has a number of important subpackages.
The most important graphics classes in java.awt ar e Graphics and its Java 2D exten-
sion, Graphics2D. These classes repr esent a drawing surface, maintain a set of draw-
ing attributes, and deﬁne methods for drawing and ﬁlling lines, shapes, and text.
Classes that repr esent graphics attributes include Color, Font, Paint, Stroke, and Com-
posite. The Image class and Shape inter face repr esent things that you can draw using
a Graphics object and the various graphics attributes. Figure 9-1 shows the graphics
classes of this package.
The most important class for GUIs is Component, which repr esents a single graphi-
cal element in a GUI. Container is a kind of component that can contain other com-
ponents. The LayoutManager inter face and its various implementations are used to
position components within their containers. Figure 9-2 shows the GUI classes of
this package, and Figure 9-3 shows the event, exception, and security classes.
See Chapter 4, Graphics with AWT and Java 2D, for an introduction to Java graph-
ics with AWT and Java 2D and Chapter 2, Swing and AWT Architectur e, for an
intr oduction to the GUI framework deﬁned by the java.awt package.
ActiveEvent
Ja va 1.2
java.awt
This interface is implemented by events that know how to dispatch themselves. When
the event dispatch system encounters an ActiveEvent on the event queue, it simply
invokes the dispatch() method of the event, instead of attempting to dispatch the event
on its own. This interface is implemented by java.awt.event.InvocationEvent, which is used
by the invokeLater() and invokeAndWait() methods of EventQueue.
154

extends
implements
KEY
CLASS
ABSTRACT CLASS
FINAL CLASS
INTERFACE
java.lang
java.awt.geom
java.awt
AlphaComposite
BasicStroke
SystemColor
Composite
Stroke
GradientPaint
RenderingHints
Color
TexturePaint
Insets
Cursor
Font
FontMetrics
Graphics
GraphicsConfigTemplate
GraphicsConfiguration
Image
PrintJob
MediaTracker
Toolkit
Polygon
Dimension
Point
Rectangle
java.util
Map
ComponentOrientation
Graphics2D
Dimension2D
Point2D
Rectangle2D
java.io
Transparency
Paint
Shape
CompositeContext
PrintGraphics
PaintContext
Cloneable
Serializable
Object
Figur e 9−1: Graphics classes of the java.awt package
java.awt
java.awt.ActiveEvent
Chapter 9 – The java.awt Package
155

extends
implements
KEY
CLASS
FINAL CLASS
INTERFACE
java.lang
Button
Canvas
Checkbox
Choice
Container
Label
List
Scrollbar
TextComponent
Window
MenuBar
MenuItem
Menu
CheckboxMenuItem
Dialog
Frame
MenuContainer
FileDialog
TextArea
TextField
LayoutManager
Component
GridBagConstraints
MenuComponent
Adjustable
MenuShortcut
CheckboxGroup
java.awt.image
ImageObserver
LayoutManager2
ScrollPane
PopupMenu
java.io
Serializable
Object
Cloneable
ItemSelectable
java.awt
Panel
BorderLayout
CardLayout
GridBagLayout
FlowLayout
GridLayout
Figur e 9−2: GUI classes of the java.awt package
public abstract interface ActiveEvent {
// Public Instance Methods
public abstract void dispatch();
}
Implementations: java.awt.event.InvocationEvent
java.awt.ActiveEvent
156 Chapter 9 – The java.awt Package

extends
implements
KEY
CLASS
ABSTRACT CLASS
INTERFACE
FINAL CLASS
java.lang
java.util
AWTEvent
AWTEventMulticaster
java.io
Serializable
AWTError
java.awt.event
java.awt
java.security
Event
EventQueue
ActionListener
AdjustmentListener
ComponentListener
ContainerListener
FocusListener
ItemListener
KeyListener
MouseListener
MouseMotionListener
TextListener
WindowListener
AWTPermission
AWTException
IllegalComponentStateException
Error
Object
EventObject
Exception
IllegalStateException
BasicPermission
ActiveEvent
Figur e 9−3: Event, exception, and security classes of the java.awt package
Adjustable
Ja va 1.1
java.awt
PJ1.1
This interface deﬁnes the methods that should be implemented by an object that main-
tains a user-adjustable numeric value. The adjustable value has speciﬁed minimum and
maximum values, and it may be incremented or decremented either a unit at a time or
a block at a time. An Adjustable object generates an AdjustmentEvent when it is adjusted
and maintains a list of AdjustmentListener objects interested in being notiﬁed when such
an event occurs.
This interface abstracts the essential functionality of the Scrollbar and javax.swing .JScrollBar
components.
public abstract interface Adjustable {
// Public Constants
=0
public static ﬁnal int HORIZONTAL;
=1
public static ﬁnal int VERTICAL;
// Event Registration Methods (by event name)
public abstract void addAdjustmentListener(java.awt.e vent.AdjustmentListener l);
java.awt
java.awt.Adjustable
Chapter 9 – The java.awt Package
157

public abstract void removeAdjustmentListener(java.awt.e vent.AdjustmentListener l);
// Property Accessor Methods (by property name)
public abstract int getBlockIncrement();
public abstract void setBlockIncrement(int b);
public abstract int getMaximum();
public abstract void setMaximum(int max);
public abstract int getMinimum();
public abstract void setMinimum(int min);
public abstract int getOrientation();
public abstract int getUnitIncrement();
public abstract void setUnitIncrement(int u);
public abstract int getValue();
public abstract void setValue(int v);
public abstract int getV isibleAmount();
public abstract void setV isibleAmount(int v);
}
Implementations: Scrollbar, javax.swing .JScrollBar
Passed To: java.awt.event.AdjustmentEvent.AdjustmentEvent(),
java.awt.peer.ScrollPanePeer.{setUnitIncrement(), setValue()}
Retur ned By: ScrollPane.{getHAdjustable(), getVAdjustable()},
java.awt.event.AdjustmentEvent.getAdjustable()
AlphaComposite
Ja va 1.2
java.awt
This implementation of the Composite inter face blends colors according to their levels of
alpha transparency. AlphaComposite does not have a public constructor, but you can
obtain a shared immutable instance by calling the static getInstance() method, specifying
the desired compositing rule (one of the eight integer constants deﬁned by the class),
and specifying an alpha value. Alternatively, if you use an alpha value of 1.0, you can
simply use one of the eight predeﬁned AlphaComposite constants. Once you have
obtained an AlphaComposite object, you use it by passing it to the setComposite() method
of a Graphics2D object.
The most common way to use an AlphaComposite object is to specify the SRC_OVER com-
positing rule and an alpha value greater than 0 but less than 1. This causes the source
colors you draw to be given the speciﬁed level of alpha transparency, so that they are
blended with whatever colors already exist on the screen, making the destination colors
appear to show through the translucent source colors. This technique allows you to
achieve transparency effects using opaque colors when you are drawing onto a draw-
ing surface, like a screen, that does not have an alpha channel.
The other compositing rules of AlphaComposite ar e best understood when both the
source (your drawing) and the destination (the drawing surface) have alpha channels.
For example, you can create translucent Color objects with the four-argument version of
the Color() constructor, and you can create an off-scr een image with an alpha channel
by passing the constant TYPE_INT_ARGB to the java.awt.image.BufferedImage() constructor.
(Once your compositing operation has been perfor med in an off-scr een image with an
alpha channel, you can view the results by copying the contents of the image to the
scr een, of course.) When your source and destination have alpha channels built in, you
do not usually specify an alpha value for the AlphaComposite itself. If you do, however,
the transparency values of the source colors are multiplied by this alpha value.
java.awt.Adjustable
158 Chapter 9 – The java.awt Package

AlphaComposite supports the following compositing rules:
SRC Replace the colors of the destination with the colors of the source, ignoring the
destination colors and the transparency of the source.
SRC_OVER
Combine the source and destination colors combined based on the transparency
of the source, so that the source appears to be drawn over the destination.
DST_OVER
Combine the source and destination colors based on the transparency of the desti-
nation, so that the source appears to be drawn underneath the destination.
SRC_IN
Draw the colors of the source using the transparency values of the destination,
completely ignoring the colors of the destination.
SRC_OUT
Draw the colors of the source using the inverse transparency values of the destina-
tion.
DST_IN
Modify the colors of the destination using the alpha values of the source and
ignoring the colors of the source.
DST_OUT
Modify the colors of the destination using the inverted alpha values of the source
and ignoring the colors of the source.
CLEAR
Ignor e the color and transparency of both the destination and the source. This
clears the destination by making it a fully transparent black.
public ﬁnal class AlphaComposite implements Composite {
// No Constructor
// Public Constants
public static ﬁnal AlphaComposite Clear;
=1
public static ﬁnal int CLEAR;
=6
public static ﬁnal int DST_IN;
=8
public static ﬁnal int DST_OUT;
=4
public static ﬁnal int DST_OVER;
public static ﬁnal AlphaComposite DstIn;
public static ﬁnal AlphaComposite DstOut;
public static ﬁnal AlphaComposite DstOver;
public static ﬁnal AlphaComposite Src;
=2
public static ﬁnal int SRC;
=5
public static ﬁnal int SRC_IN;
=7
public static ﬁnal int SRC_OUT;
=3
public static ﬁnal int SRC_OVER;
public static ﬁnal AlphaComposite SrcIn;
public static ﬁnal AlphaComposite SrcOut;
public static ﬁnal AlphaComposite SrcOver;
// Public Class Methods
public static AlphaComposite getInstance(int rule);
public static AlphaComposite getInstance(int rule, ﬂoat alpha);
// Public Instance Methods
public ﬂoat getAlpha();
public int getRule();
java.awt
java.awt.AlphaComposite
Chapter 9 – The java.awt Package
159

// Methods Implementing Composite
public CompositeContext createContext(java.awt.image.ColorModel srcColorModel,
java.awt.image.ColorModel dstColorModel, RenderingHints hints);
// Public Methods Overriding Object
public boolean equals(Object obj);
public int hashCode();
}
Hierar chy: Object→AlphaComposite(Composite)
Retur ned By: AlphaComposite.getInstance()
Type Of: AlphaComposite.{Clear, DstIn, DstOut, DstOver, Src, SrcIn, SrcOut, SrcOver}
AWTEr ror
Ja va 1.0
java.awt
serializable error PJ1.1
Signals that an error has occurred in the java.awt package.
public class AWTEr ror extends Error {
// Public Constructors
public AWTEr ror(String msg);
}
Hierar chy: Object→Throwable(Serializable)→Er ror→AWTEr ror
AWTEvent
Ja va 1.1
java.awt
serializable event PJ1.1
This abstract class serves as the root event type for all AWT events in Java 1.1 and
supersedes the Event class that was used in Java 1.0.
Each AWTEvent has a source object, as all EventObject objects do. You can query the
source of an event with the inherited getSource() method. The AWTEvent class adds an
event type, or ID, for every AWT event. Use getID() to query the type of an event. Sub-
classes of AWTEvent deﬁne various constants for this type ﬁeld.
The various _MASK constants are used by applets and custom components that call the
enableEvents() method of Component to receive various event types without having to reg-
ister EventListener objects.
public abstract class AWTEvent extends java.util.EventObject {
// Public Constructors
public AWTEvent(Event event);
public AWTEvent(Object source, int id);
// Public Constants
=128
public static ﬁnal long ACTION_EVENT_MASK;
=256
public static ﬁnal long ADJUSTMENT_EVENT_MASK;
=1
public static ﬁnal long COMPONENT_EVENT_MASK;
=2
public static ﬁnal long CONTAINER_EVENT_MASK;
=4
public static ﬁnal long FOCUS_EVENT_MASK;
=2048
1.2 public static ﬁnal long INPUT_METHOD_EVENT_MASK;
=512
public static ﬁnal long ITEM_EVENT_MASK;
=8
public static ﬁnal long KEY_EVENT_MASK;
=16
public static ﬁnal long MOUSE_EVENT_MASK;
=32
public static ﬁnal long MOUSE_MOTION_EVENT_MASK;
=1999
public static ﬁnal int RESERVED_ID_MAX;
=1024
public static ﬁnal long TEXT_EVENT_MASK;
=64
public static ﬁnal long WINDOW_EVENT_MASK;
java.awt.AlphaComposite
160 Chapter 9 – The java.awt Package

// Public Instance Methods
public int getID();
public String paramString();
// Public Methods Overriding EventObject
public String toString();
// Protected Methods Overriding Object
1.2 protected void ﬁnalize() throws Throwable;
// Protected Instance Methods
protected void consume();
protected boolean isConsumed();
// Protected Instance Fields
protected boolean consumed;
protected int id;
}
Hierar chy: Object→java.util.EventObject(Serializable)→AWTEvent
Subc lasses: java.awt.event.ActionEvent, java.awt.event.AdjustmentEvent, java.awt.event.ComponentEvent,
java.awt.event.InputMethodEvent, java.awt.event.InvocationEvent, java.awt.event.ItemEvent,
java.awt.event.TextEvent, javax.swing .event.AncestorEvent, javax.swing .event.Inter nalFrameEvent
Passed To: Too many methods to list.
Retur ned By: Component.coalesceEvents(), EventQueue.{getNextEvent(), peekEvent()}
AWTEventMulticaster
Ja va 1.1
java.awt
PJ1.1
AWTEventMulticaster is a convenience class used when writing a custom AWT component.
It provides an easy way to maintain a list of AWT EventListener objects and notify the lis-
teners on that list when an event occurs.
AWTEventMulticaster implements each of the event listener interfaces deﬁned in the
java.awt.event package, which means that an AWTEventMulticaster object can serve as any
desir ed type of event listener. (It also means that the class deﬁnes quite a few meth-
ods.) AWTEventMulticaster implements what amounts to a linked list of EventListener objects.
When you invoke one of the EventListener methods of an AWTEventMulticaster, it invokes
the same method on all of the EventListener objects in the linked list.
Rather than instantiate an AWTEventMulticaster object directly, you use the static add() and
remove() methods of the class to add and remove EventListener objects from the linked
list. Calling add() or remove() retur ns an AWTEventMulticaster with the appropriate EventLis-
tener object register ed or deregister ed. Using an AWTEventMulticaster is somewhat non-
intuitive, so here is some example code that shows its use:
public class MyList extends Component { // a class that sends ItemEvents
// The head of a linked list of AWTEventMulticaster objects
protected ItemListener listener = null;
public void addItemListener(ItemListener l) {
// add a listener
listener = AWTEventMulticaster.add(listener, l);
}
public void removeItemListener(ItemListener l) { // remove a listener
listener = AWTEventMulticaster.remove(listener, l);
}
protected void fireItemEvent(ItemEvent e) {
// notify all listeners
if (listener != null) listener.itemStateChanged(e);
}
// The rest of the class goes here
}
java.awt
java.awt.AWTEventMulticaster
Chapter 9 – The java.awt Package
161

public class AWTEventMulticaster implements java.awt.event.ActionListener, java.awt.e vent.AdjustmentListener,
java.awt.e vent.ComponentListener, java.awt.e vent.ContainerListener, java.awt.e vent.FocusListener,
java.awt.e vent.InputMethodListener, java.awt.e vent.ItemListener, java.awt.e vent.Ke yListener,
java.awt.e vent.MouseListener, java.awt.e vent.MouseMotionListener, java.awt.e vent.TextListener,
java.awt.e vent.WindowListener {
// Protected Constructors
protected AWTEventMulticaster(java.util.EventListener a, java.util.EventListener b);
// Public Class Methods
public static java.awt.event.ActionListener add(java.awt.e vent.ActionListener a, java.awt.e vent.ActionListener b);
public static java.awt.event.AdjustmentListener add(java.awt.e vent.AdjustmentListener a,
java.awt.e vent.AdjustmentListener b);
public static java.awt.event.ComponentListener add(java.awt.e vent.ComponentListener a,
java.awt.e vent.ComponentListener b);
public static java.awt.event.ContainerListener add(java.awt.e vent.ContainerListener a,
java.awt.e vent.ContainerListener b);
public static java.awt.event.FocusListener add(java.awt.e vent.FocusListener a, java.awt.e vent.FocusListener b);
1.2 public static java.awt.event.InputMethodListener add(java.awt.e vent.InputMethodListener a,
java.awt.e vent.InputMethodListener b);
public static java.awt.event.ItemListener add(java.awt.e vent.ItemListener a, java.awt.e vent.ItemListener b);
public static java.awt.event.Ke yListener add(java.awt.e vent.Ke yListener a, java.awt.e vent.Ke yListener b);
public static java.awt.event.MouseListener add(java.awt.e vent.MouseListener a, java.awt.e vent.MouseListener b);
public static java.awt.event.MouseMotionListener add(java.awt.e vent.MouseMotionListener a,
java.awt.e vent.MouseMotionListener b);
public static java.awt.event.TextListener add(java.awt.e vent.TextListener a, java.awt.e vent.TextListener b);
public static java.awt.event.W indowListener add(java.awt.e vent.WindowListener a, java.awt.e vent.WindowListener b);
public static java.awt.event.ActionListener remove(java.awt.e vent.ActionListener l,
java.awt.e vent.ActionListener oldl);
public static java.awt.event.AdjustmentListener remove(java.awt.e vent.AdjustmentListener l,
java.awt.e vent.AdjustmentListener oldl);
public static java.awt.event.ComponentListener remove(java.awt.e vent.ComponentListener l,
java.awt.e vent.ComponentListener oldl);
public static java.awt.event.ContainerListener remove(java.awt.e vent.ContainerListener l,
java.awt.e vent.ContainerListener oldl);
public static java.awt.event.FocusListener remove(java.awt.e vent.FocusListener l, java.awt.e vent.FocusListener oldl);
1.2 public static java.awt.event.InputMethodListener remove(java.awt.e vent.InputMethodListener l,
java.awt.e vent.InputMethodListener oldl);
public static java.awt.event.ItemListener remove(java.awt.e vent.ItemListener l, java.awt.e vent.ItemListener oldl);
public static java.awt.event.Ke yListener remove(java.awt.e vent.Ke yListener l, java.awt.e vent.Ke yListener oldl);
public static java.awt.event.MouseListener remove(java.awt.e vent.MouseListener l,
java.awt.e vent.MouseListener oldl);
public static java.awt.event.MouseMotionListener remove(java.awt.e vent.MouseMotionListener l,
java.awt.e vent.MouseMotionListener oldl);
public static java.awt.event.TextListener remove(java.awt.e vent.TextListener l, java.awt.e vent.TextListener oldl);
public static java.awt.event.W indowListener remove(java.awt.e vent.WindowListener l,
java.awt.e vent.WindowListener oldl);
// Protected Class Methods
protected static java.util.EventListener addInter nal(java.util.EventListener a, java.util.EventListener b);
protected static java.util.EventListener removeInter nal(java.util.EventListener l, java.util.EventListener oldl);
protected static void save(java.io.ObjectOutputStream s, String k, java.util.EventListener l)
throws java.io.IOException;
// Methods Implementing ActionListener
public void actionPerfor med(java.awt.e vent.ActionEvent e);
// Methods Implementing AdjustmentListener
public void adjustmentValueChanged(java.awt.e vent.AdjustmentEvent e);
// Methods Implementing ComponentListener
public void componentHidden(java.awt.e vent.ComponentEvent e);
public void componentMoved(java.awt.e vent.ComponentEvent e);
java.awt.AWTEventMulticaster
162 Chapter 9 – The java.awt Package

public void componentResized(java.awt.e vent.ComponentEvent e);
public void componentShown(java.awt.e vent.ComponentEvent e);
// Methods Implementing ContainerListener
public void componentAdded(java.awt.e vent.ContainerEvent e);
public void componentRemoved(java.awt.e vent.ContainerEvent e);
// Methods Implementing FocusListener
public void focusGained(java.awt.e vent.FocusEvent e);
public void focusLost(java.awt.e vent.FocusEvent e);
// Methods Implementing InputMethodListener
1.2 public void caretPositionChanged(java.awt.e vent.InputMethodEvent e);
1.2 public void inputMethodTextChanged(java.awt.e vent.InputMethodEvent e);
// Methods Implementing ItemListener
public void itemStateChanged(java.awt.e vent.ItemEvent e);
// Methods Implementing KeyListener
public void keyPressed(java.awt.e vent.Ke yEvent e);
public void keyReleased(java.awt.e vent.Ke yEvent e);
public void keyTyped(java.awt.e vent.Ke yEvent e);
// Methods Implementing MouseListener
public void mouseClicked(java.awt.e vent.MouseEvent e);
public void mouseEntered(java.awt.e vent.MouseEvent e);
public void mouseExited(java.awt.e vent.MouseEvent e);
public void mousePressed(java.awt.e vent.MouseEvent e);
public void mouseReleased(java.awt.e vent.MouseEvent e);
// Methods Implementing MouseMotionListener
public void mouseDragged(java.awt.e vent.MouseEvent e);
public void mouseMoved(java.awt.e vent.MouseEvent e);
// Methods Implementing TextListener
public void textValueChanged(java.awt.e vent.TextEvent e);
// Methods Implementing WindowListener
public void windowActivated(java.awt.e vent.WindowEvent e);
public void windowClosed(java.awt.e vent.WindowEvent e);
public void windowClosing(java.awt.e vent.WindowEvent e);
public void windowDeactivated(java.awt.e vent.WindowEvent e);
public void windowDeiconiﬁed(java.awt.e vent.WindowEvent e);
public void windowIconiﬁed(java.awt.e vent.WindowEvent e);
public void windowOpened(java.awt.e vent.WindowEvent e);
// Protected Instance Methods
protected java.util.EventListener remove(java.util.EventListener oldl);
protected void saveInter nal(java.io.ObjectOutputStream s, String k) throws java.io.IOException;
// Protected Instance Fields
protected ﬁnal java.util.EventListener a;
protected ﬁnal java.util.EventListener b;
}
Hierar chy: Object→AWTEventMulticaster(java.awt.event.ActionListener(java.util.EventListener),
java.awt.event.AdjustmentListener(java.util.EventListener),
java.awt.event.ComponentListener(java.util.EventListener),
java.awt.event.ContainerListener(java.util.EventListener), java.awt.event.FocusListener(java.util.EventListener),
java.awt.event.InputMethodListener(java.util.EventListener), java.awt.event.ItemListener(java.util.EventListener),
java.awt.event.KeyListener(java.util.EventListener), java.awt.event.MouseListener(java.util.EventListener),
java.awt.event.MouseMotionListener(java.util.EventListener), java.awt.event.TextListener(java.util.EventListener),
java.awt.event.W indowListener(java.util.EventListener))
AWTException
Ja va 1.0
java.awt
serializable checked PJ1.1
Signals that an exception has occurred in the java.awt package.
java.awt
java.awt.AWTException
Chapter 9 – The java.awt Package
163

public class AWTException extends Exception {
// Public Constructors
public AWTException(String msg);
}
Hierar chy: Object→Throwable(Serializable)→Exception→AWTException
Thrown By: Cursor.getSystemCustomCursor()
AWTPer mission
Ja va 1.2
java.awt
serializable permission
This class encapsulates permissions for perfor ming various AWT-r elated operations;
applications do not typically use it. The name, or target, of a permission should be one
of the following values: accessClipboard, accessEventQueue, listenToAllAWTEvents, or
showWindowWithoutWar ningBanner. Alter natively, a name of * implies all of these val-
ues. AWTPer mission does not use actions, so the actions argument to the constructor should
be null.
public ﬁnal class AWTPer mission extends java.security.BasicPermission {
// Public Constructors
public AWTPer mission(String name);
public AWTPer mission(String name, String actions);
}
Hierar chy: Object→java.security.Per mission(java.security.Guard, Serializable)→
java.security.BasicPer mission(Serializable)→AWTPer mission
BasicStroke
Ja va 1.2
java.awt
This class deﬁnes properties that control how lines are drawn. By default, lines are one-
pixel wide and solid. To change these attributes, pass a BasicStroke (or another imple-
mentation of Stroke) to the setStroke() method of a Graphics2D object. BasicStroke supports
the following line attribute properties:
lineW idth
The thickness of the line.
endCap
The end cap style of the line. CAP_BUTT speciﬁes that a line ends exactly at its end
points, without caps.
CAP_SQUARE causes a line to end with square caps that
extend beyond the end points by a distance equal to one-half of the line width.
CAP_ROUND speciﬁes that a line ends with round caps with a radius of one-half of
the line width.
lineJoin
The join style when two line segments meet at the vertex of a shape. JOIN_MITER
speciﬁes that the outside edges of the two line segments are extended as far as
necessary until they intersect. JOIN_BEVEL causes the outside corners of the vertex
to be joined with a straight line. JOIN_ROUND speciﬁes that the vertex is rounded
with a curve that has a radius of half the line width.
miterLimit
The maximum length of the miter used to connect two intersecting line segments.
When two lines intersect at an acute angle and the line join style is JOIN_MITER, the
length of the miter gets progr essively longer as the angle between the lines gets
java.awt.AWTException
164 Chapter 9 – The java.awt Package

smaller. This property imposes a maximum length on the miter; beyond this
length, the miter is squared off.
dashAr ray
The pattern of dashes and spaces that make up a dashed line. This attribute is an
array, where the ﬁrst element and all the additional odd elements specify the
lengths of dashes. The second element and all the additional even elements spec-
ify the lengths of the spaces. When the dash pattern is complete, it starts over at
the beginning of the array, of course.
dashPhase
The distance into the dash pattern that line drawing begins. Note that this value is
not an index into the dash array, but a distance. For example, if you’ve speciﬁed a
dash of length 5 followed by a space of length 3 and want to begin your line with
the space rather than the dash, you set this property to 5.
See Stroke for a discussion of how line drawing is perfor med in Java 2D.
public class BasicStroke implements Stroke {
// Public Constructors
public BasicStroke();
public BasicStroke(ﬂoat width);
public BasicStroke(ﬂoat width, int cap, int join);
public BasicStroke(ﬂoat width, int cap, int join, ﬂoat miterlimit);
public BasicStroke(ﬂoat width, int cap, int join, ﬂoat miterlimit, ﬂoat[ ] dash, ﬂoat dash_phase);
// Public Constants
=0
public static ﬁnal int CAP_BUTT;
=1
public static ﬁnal int CAP_ROUND;
=2
public static ﬁnal int CAP_SQUARE;
=2
public static ﬁnal int JOIN_BEVEL;
=0
public static ﬁnal int JOIN_MITER;
=1
public static ﬁnal int JOIN_ROUND;
// Property Accessor Methods (by property name)
default:null
public ﬂoat[ ] getDashAr ray();
default:0.0
public ﬂoat getDashPhase();
default:2
public int getEndCap();
default:0
public int getLineJoin();
default:1.0
public ﬂoat getLineW idth();
default:10.0
public ﬂoat getMiterLimit();
// Methods Implementing Stroke
public Shape createStrokedShape(Shape s);
// Public Methods Overriding Object
public boolean equals(Object obj);
public int hashCode();
}
Hierar chy: Object→BasicStroke(Stroke)
BorderLayout
Ja va 1.0
java.awt
serializable layout manager PJ1.1
A LayoutManager that arranges components that have been added to their Container (using
the Container.add() method) with the names “North”, “South”, “East”, “West”, and “Cen-
ter”. These named components are arranged along the edges and in the center of the
java.awt
java.awt.BorderLayout
Chapter 9 – The java.awt Package
165

container. The hgap and vgap arguments to the BorderLayout constructor specify the desired
horizontal and vertical spacing between adjacent components.
In Java 1.1, ﬁve constants were deﬁned to repr esent these strings. In Java 1.2, an addi-
tional four constants have been added to repr esent the four sides of the container in a
way that is independent of writing direction. For example, BEFORE_LINE_BEGINS is the
same as WEST in locales where text is drawn from left to right, but is the same as EAST in
locales where text is drawn from right to left.
Note that an application should never call the LayoutManager methods of this class
dir ectly; the Container for which the BorderLayout is register ed does this.
In Java 1.1, ﬁve constants were deﬁned to repr esent these strings. In Java 1.2, an addi-
tional four constants have been added to repr esent the four sides of the container in a
way that is independent of writing direction. For example, BEFORE_LINE_BEGINS is the
same as WEST in locales where text is drawn from left to right but is the same as EAST in
locales where text is drawn right to left.
public class BorderLayout implements LayoutManager2, Serializable {
// Public Constructors
public BorderLayout();
public BorderLayout(int hgap, int vgap);
// Public Constants
="Last"
1.2 public static ﬁnal String AFTER_LAST_LINE;
="After"
1.2 public static ﬁnal String AFTER_LINE_ENDS;
="F irst"
1.2 public static ﬁnal String BEFORE_FIRST_LINE;
="Before"
1.2 public static ﬁnal String BEFORE_LINE_BEGINS;
="Center"
1.1 public static ﬁnal String CENTER;
="East"
1.1 public static ﬁnal String EAST;
="Nor th"
1.1 public static ﬁnal String NORTH;
="South"
1.1 public static ﬁnal String SOUTH;
="West"
1.1 public static ﬁnal String WEST;
// Property Accessor Methods (by property name)
default:0
1.1 public int getHgap();
1.1 public void setHgap(int hgap);
default:0
1.1 public int getVgap();
1.1 public void setVgap(int vgap);
// Methods Implementing LayoutManager
public void layoutContainer(Container target);
public Dimension minimumLayoutSize(Container target);
public Dimension prefer redLayoutSize(Container target);
public void removeLayoutComponent(Component comp);
// Methods Implementing LayoutManager2
1.1 public void addLayoutComponent(Component comp, Object constraints);
1.1 public ﬂoat getLayoutAlignmentX(Container parent);
1.1 public ﬂoat getLayoutAlignmentY(Container parent);
empty
1.1 public void invalidateLayout(Container target);
1.1 public Dimension maximumLayoutSize(Container target);
// Public Methods Overriding Object
public String toString();
// Deprecated Public Methods
Implements:LayoutManager
# public void addLayoutComponent(String name, Component comp);
}
Hierar chy: Object→BorderLayout(LayoutManager2(LayoutManager), Serializable)
java.awt.BorderLayout
166 Chapter 9 – The java.awt Package

Button
Ja va 1.0
java.awt
serializable AWT component PJ1.1
This class repr esents a GUI push button that displays a speciﬁed textual label. Use
setActionCommand() to specify an identifying string that is included in the ActionEvent
events generated by the button.
public class Button extends Component {
// Public Constructors
public Button();
public Button(String label);
// Event Registration Methods (by event name)
synchronized
1.1 public void addActionListener(java.awt.e vent.ActionListener l);
synchronized
1.1 public void removeActionListener(java.awt.e vent.ActionListener l);
// Property Accessor Methods (by property name)
default:""
1.1 public String getActionCommand();
1.1 public void setActionCommand(String command);
default:""
public String getLabel();
public void setLabel(String label);
// Public Methods Overriding Component
public void addNotify();
// Protected Methods Overriding Component
protected String paramString();
1.1 protected void processEvent(AWTEvent e);
// Protected Instance Methods
1.1 protected void processActionEvent(java.awt.e vent.ActionEvent e);
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, MenuContainer, Serializable)→Button
Passed To: Toolkit.createButton()
Canvas
Ja va 1.0
java.awt
serializable AWT component PJ1.1
A Component that does no default drawing or event handling on its own. You can sub-
class it to display any kind of drawing or image and handle any kind of user input
event. Canvas inherits the event-handling methods of its superclass. In Java 1.1, you can
also subclass Component dir ectly to create a lightweight component, instead of having to
subclass Canvas.
public class Canvas extends Component {
// Public Constructors
public Canvas();
1.2 public Canvas(GraphicsConﬁguration conﬁg);
// Public Methods Overriding Component
public void addNotify();
public void paint(Graphics g);
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, MenuContainer, Serializable)→Canvas
Passed To: Toolkit.createCanvas()
CardLayout
Ja va 1.0
java.awt
serializable layout manager PJ1.1
A LayoutManager that makes each of the components it manages as large as the container
and ensures that only one is visible at a time. The standard LayoutManager methods are
called by the Container object and should not be called directly by applet or application
java.awt
java.awt.CardLayout
Chapter 9 – The java.awt Package
167

code. ﬁrst(), last(), next(), previous(), and show() make a particular Component in the Container
visible. The names with which the components are added to the container are used
only by the show() method.
public class CardLayout implements LayoutManager2, Serializable {
// Public Constructors
public CardLayout();
public CardLayout(int hgap, int vgap);
// Property Accessor Methods (by property name)
default:0
1.1 public int getHgap();
1.1 public void setHgap(int hgap);
default:0
1.1 public int getVgap();
1.1 public void setVgap(int vgap);
// Public Instance Methods
public void ﬁrst(Container parent);
public void last(Container parent);
public void next(Container parent);
public void previous(Container parent);
public void show(Container parent, String name);
// Methods Implementing LayoutManager
public void layoutContainer(Container parent);
public Dimension minimumLayoutSize(Container parent);
public Dimension prefer redLayoutSize(Container parent);
public void removeLayoutComponent(Component comp);
// Methods Implementing LayoutManager2
1.1 public void addLayoutComponent(Component comp, Object constraints);
1.1 public ﬂoat getLayoutAlignmentX(Container parent);
1.1 public ﬂoat getLayoutAlignmentY(Container parent);
empty
1.1 public void invalidateLayout(Container target);
1.1 public Dimension maximumLayoutSize(Container target);
// Public Methods Overriding Object
public String toString();
// Deprecated Public Methods
Implements:LayoutManager
# public void addLayoutComponent(String name, Component comp);
}
Hierar chy: Object→CardLayout(LayoutManager2(LayoutManager), Serializable)
Checkbox
Ja va 1.0
java.awt
serializable AWT component PJ1.1
This class repr esents a GUI checkbox with a textual label. The Checkbox maintains a
boolean state — whether it is checked or not. The checkbox may optionally be part of a
CheckboxGroup that enforces radio button behavior.
public class Checkbox extends Component implements ItemSelectable {
// Public Constructors
public Checkbox();
public Checkbox(String label);
1.1 public Checkbox(String label, boolean state);
public Checkbox(String label, CheckboxGroup group, boolean state);
1.1 public Checkbox(String label, boolean state, CheckboxGroup group);
// Event Registration Methods (by event name)
Implements:ItemSelectable synchronized
1.1 public void addItemListener(java.awt.e vent.ItemListener l);
Implements:ItemSelectable synchronized
1.1 public void removeItemListener(java.awt.e vent.ItemListener l);
// Property Accessor Methods (by property name)
default:null
public CheckboxGroup getCheckboxGroup();
public void setCheckboxGroup(CheckboxGroup g);
default:""
public String getLabel();
java.awt.CardLayout
168 Chapter 9 – The java.awt Package

public void setLabel(String label);
Implements:ItemSelectable default:null
1.1 public Object[ ] getSelectedObjects();
default:false
public boolean getState();
public void setState(boolean state);
// Methods Implementing ItemSelectable
synchronized
1.1 public void addItemListener(java.awt.e vent.ItemListener l);
default:null
1.1 public Object[ ] getSelectedObjects();
synchronized
1.1 public void removeItemListener(java.awt.e vent.ItemListener l);
// Public Methods Overriding Component
public void addNotify();
// Protected Methods Overriding Component
protected String paramString();
1.1 protected void processEvent(AWTEvent e);
// Protected Instance Methods
1.1 protected void processItemEvent(java.awt.e vent.ItemEvent e);
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, MenuContainer, Serializable)→
Checkbox(ItemSelectable)
Passed To: CheckboxGroup.{setCur rent(), setSelectedCheckbox()}, Toolkit.createCheckbox()
Retur ned By: CheckboxGroup.{getCur rent(), getSelectedCheckbox()}
CheckboxGroup
Ja va 1.0
java.awt
serializable PJ1.1
A CheckboxGroup object enforces mutual exclusion (also known as radio button behav-
ior) among any number of Checkbox buttons. A Checkbox component can specify a Check-
boxGroup object when created or with its setCheckboxGroup() method. If a Checkbox within
a CheckboxGroup object is selected, the CheckboxGroup ensur es that the previously selected
Checkbox becomes unselected.
public class CheckboxGroup implements Serializable {
// Public Constructors
public CheckboxGroup();
// Property Accessor Methods (by property name)
default:null
1.1 public Checkbox getSelectedCheckbox();
1.1 public void setSelectedCheckbox(Checkbox box);
// Public Methods Overriding Object
public String toString();
// Deprecated Public Methods
default:null
# public Checkbox getCur rent();
synchronized
# public void setCur rent(Checkbox box);
}
Hierar chy: Object→CheckboxGroup(Serializable)
Passed To: Checkbox.{Checkbox(), setCheckboxGroup()}, java.awt.peer.CheckboxPeer.setCheckboxGroup()
Retur ned By: Checkbox.getCheckboxGroup()
CheckboxMenuItem
Ja va 1.0
java.awt
serializable AWT component PJ1.1(opt)
This class repr esents a checkbox with a textual label in a GUI menu. It maintains a
boolean state — whether it is checked or not. See also MenuItem.
java.awt
java.awt.CheckboxMenuItem
Chapter 9 – The java.awt Package
169

public class CheckboxMenuItem extends MenuItem implements ItemSelectable {
// Public Constructors
1.1 public CheckboxMenuItem();
public CheckboxMenuItem(String label);
1.1 public CheckboxMenuItem(String label, boolean state);
// Event Registration Methods (by event name)
Implements:ItemSelectable synchronized
1.1 public void addItemListener(java.awt.e vent.ItemListener l);
Implements:ItemSelectable synchronized
1.1 public void removeItemListener(java.awt.e vent.ItemListener l);
// Property Accessor Methods (by property name)
Implements:ItemSelectable synchronized default:null
1.1 public Object[ ] getSelectedObjects();
default:false
public boolean getState();
synchronized
public void setState(boolean b);
// Methods Implementing ItemSelectable
synchronized
1.1 public void addItemListener(java.awt.e vent.ItemListener l);
synchronized default:null
1.1 public Object[ ] getSelectedObjects();
synchronized
1.1 public void removeItemListener(java.awt.e vent.ItemListener l);
// Public Methods Overriding MenuItem
public void addNotify();
public String paramString();
// Protected Methods Overriding MenuItem
1.1 protected void processEvent(AWTEvent e);
// Protected Instance Methods
1.1 protected void processItemEvent(java.awt.e vent.ItemEvent e);
}
Hierar chy: Object→MenuComponent(Serializable)→MenuItem→CheckboxMenuItem(ItemSelectable)
Passed To: Toolkit.createCheckboxMenuItem()
Choice
Ja va 1.0
java.awt
serializable AWT component PJ1.1
This class repr esents an option menu or dropdown list. The addItem() method adds an
item with the speciﬁed label to a Choice menu. getSelectedIndex() retur ns the numerical
position of the selected item in the menu, while getSelectedItem() retur ns the label of the
selected item.
public class Choice extends Component implements ItemSelectable {
// Public Constructors
public Choice();
// Event Registration Methods (by event name)
Implements:ItemSelectable synchronized
1.1 public void addItemListener(java.awt.e vent.ItemListener l);
Implements:ItemSelectable synchronized
1.1 public void removeItemListener(java.awt.e vent.ItemListener l);
// Property Accessor Methods (by property name)
default:0
1.1 public int getItemCount();
default:-1
public int getSelectedIndex();
synchronized default:null
public String getSelectedItem();
Implements:ItemSelectable synchronized default:null
1.1 public Object[ ] getSelectedObjects();
// Public Instance Methods
1.1 public void add(String item);
public void addItem(String item);
public String getItem(int index);
1.1 public void inser t(String item, int index);
1.1 public void remove(String item);
1.1 public void remove(int position);
1.1 public void removeAll();
synchronized
public void select(String str);
synchronized
public void select(int pos);
java.awt.CheckboxMenuItem
170 Chapter 9 – The java.awt Package

// Methods Implementing ItemSelectable
synchronized
1.1 public void addItemListener(java.awt.e vent.ItemListener l);
synchronized default:null
1.1 public Object[ ] getSelectedObjects();
synchronized
1.1 public void removeItemListener(java.awt.e vent.ItemListener l);
// Public Methods Overriding Component
public void addNotify();
// Protected Methods Overriding Component
protected String paramString();
1.1 protected void processEvent(AWTEvent e);
// Protected Instance Methods
1.1 protected void processItemEvent(java.awt.e vent.ItemEvent e);
// Deprecated Public Methods
# public int countItems();
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, MenuContainer, Serializable)→
Choice(ItemSelectable)
Passed To: Toolkit.createChoice()
Color
Ja va 1.0
java.awt
serializable PJ1.1
This class describes a color in terms of the individual components of that color. These
components are either ﬂoat values that range between 0 and 1 or 8-bit integers that
range from 0 to 255. Prior to Java 1.2, only the RGB (red, green, blue) color space was
supported. With the advent of Java 2D, the Color class has been extended to support
alpha transparency and arbitrary java.awt.color.ColorSpace objects. In addition, the Java 1.2
Color class implements the Paint inter face and is used to perfor m Java 2D drawing and
ﬁlling operations that use solid colors.
Color objects can be obtained in a number of ways. The Color() constructors allow color
components to be directly speciﬁed. The class also deﬁnes several color constants. The
SystemColor subclass deﬁnes other useful Color constants that are related to standard col-
ors used on the system desktop. The static methods HSBtoRGB() and RGBtoHSB() convert
between the RGB color space and the HSB (hue, saturation, brightness) color space
and can be used to create colors speciﬁed using the more intuitive HSB color compo-
nents. brighter() and darker() retur n variants on the current color and are useful for creat-
ing shading effects.
An RGB color can be expressed as a 24-bit number, wher e the top 8 bits speciﬁes the
red component, the middle 8 bits speciﬁes the green component, and the low 8 bits
speciﬁes the blue component. Colors are often repr esented using a string repr esenta-
tion of this 24-bit number. It is particularly common to use a hexadecimal repr esenta-
tion for a color, since it keeps the red, green, and blue components distinct. For
example, the string “0xFF0000” repr esents a bright red color: the red component has a
value of 255, and both the green and blue components are 0. The static decode()
method converts color strings encoded in this way to Color objects. Each getColor()
method looks up the speciﬁed key in the system properties list and then decodes the
value and retur ns the resulting Color or the speciﬁed default color, if no color is found
in the properties list.
getRGB() retur ns the red, green, and blue components of a color as a 24-bit number.
getRed(), getBlue(), getGreen(), and getAlpha() retur n the individual components of a color
as integers. getComponents() is a generalized method that retur ns the color and trans-
par ency components of a color in a ﬂoat array, using an optionally speciﬁed ColorSpace.
getColorComponents() is similar but retur ns only the color components, not the trans-
par ency component. getRGBComponents() retur ns the color and alpha components as ﬂoat
java.awt
java.awt.Color
Chapter 9 – The java.awt Package
171

values using the RGB color space. getRGBColorComponents() does the same but does not
retur n the alpha component. Each of these methods either ﬁlls in the elements of a
ﬂoat[] array you provide or allocates one of its own, if you pass null.
public class Color implements Paint, Serializable {
// Public Constructors
public Color(int rgb);
1.2 public Color(int rgba, boolean hasalpha);
1.2 public Color(java.awt.color.ColorSpace cspace, ﬂoat[ ] components, ﬂoat alpha);
public Color(ﬂoat r, ﬂoat g, ﬂoat b);
public Color(int r, int g, int b);
1.2 public Color(int r, int g, int b, int a);
1.2 public Color(ﬂoat r, ﬂoat g, ﬂoat b, ﬂoat a);
// Public Constants
public static ﬁnal Color black;
public static ﬁnal Color blue;
public static ﬁnal Color cyan;
public static ﬁnal Color darkGray;
public static ﬁnal Color gray;
public static ﬁnal Color green;
public static ﬁnal Color lightGray;
public static ﬁnal Color magenta;
public static ﬁnal Color orange;
public static ﬁnal Color pink;
public static ﬁnal Color red;
public static ﬁnal Color white;
public static ﬁnal Color yellow;
// Public Class Methods
1.1 public static Color decode(String nm) throws NumberFormatException;
public static Color getColor(String nm);
public static Color getColor(String nm, Color v);
public static Color getColor(String nm, int v);
public static Color getHSBColor(ﬂoat h, ﬂoat s, ﬂoat b);
public static int HSBtoRGB(ﬂoat hue, ﬂoat saturation, ﬂoat brightness);
public static ﬂoat[ ] RGBtoHSB(int r, int g, int b, ﬂoat[ ] hsbvals);
// Property Accessor Methods (by property name)
1.2 public int getAlpha();
public int getBlue();
1.2 public java.awt.color.ColorSpace getColorSpace();
public int getGreen();
public int getRed();
public int getRGB();
Implements:Transparency
1.2 public int getTransparency();
// Public Instance Methods
public Color brighter();
public Color darker();
1.2 public ﬂoat[ ] getColorComponents(ﬂoat[ ] compArray);
1.2 public ﬂoat[ ] getColorComponents(java.awt.color.ColorSpace cspace, ﬂoat[ ] compArray);
1.2 public ﬂoat[ ] getComponents(ﬂoat[ ] compArray);
1.2 public ﬂoat[ ] getComponents(java.awt.color.ColorSpace cspace, ﬂoat[ ] compArray);
1.2 public ﬂoat[ ] getRGBColorComponents(ﬂoat[ ] compArray);
1.2 public ﬂoat[ ] getRGBComponents(ﬂoat[ ] compArray);
// Methods Implementing Paint
synchronized
1.2 public PaintContext createContext(java.awt.image.ColorModel cm, Rectangle r,
java.awt.geom.Rectangle2D r2d,
java.awt.geom.AfﬁneTransform xform, RenderingHints hints);
// Methods Implementing Transparency
1.2 public int getTransparency();
java.awt.Color
172 Chapter 9 – The java.awt Package

// Public Methods Overriding Object
public boolean equals(Object obj);
public int hashCode();
public String toString();
}
Hierar chy: Object→Color(Paint(Transparency), Serializable)
Subc lasses: SystemColor, javax.swing .plaf.ColorUIResource
Passed To: Too many methods to list.
Retur ned By: Too many methods to list.
Type Of: Too many fields to list.
Component
Ja va 1.0
java.awt
serializable AWT component PJ1.1(mod)
Component is the superclass of all GUI components (except menu components) in the
java.awt package. You cannot instantiate a Component dir ectly; you must use a subclass.
Component deﬁnes many methods. Some of these are intended to be implemented by
subclasses, including some that are for handling events. Other methods are used inter-
nally by the AWT. And many are useful utility methods for working with GUI compo-
nents.
getParent()
retur ns
the
Container
that contains a
Component.
setBackground(),
setForeground(), and setFont() set the speciﬁed display attributes of a component. hide(),
show(), enable(), and disable() per form the speciﬁed actions for a component. createImage()
cr eates either an Image object from a speciﬁed ImageProducer or an off-scr een image that
can be drawn into and used for double-buffering during animation. Component also has
quite a few deprecated methods, as a result of the Java 1.1 event model and the intro-
duction of the JavaBeans method-naming conventions. The class deﬁnes numerous
methods for handling many types of events, using the 1.0 and 1.1 event models, in
both their high-level and low-level forms.
In Personal Java environments, the setCursor() method can be ignored. Also, the Per-
sonal Java API supports the isDoubleBuffered() method, even though it is not part of the
Java 1.1 API from which Personal Java is derived.
public abstract class Component implements java.awt.image.ImageObserver, MenuContainer, Serializable {
// Protected Constructors
protected Component();
// Public Constants
=1.0
1.1 public static ﬁnal ﬂoat BOTTOM_ALIGNMENT;
=0.5
1.1 public static ﬁnal ﬂoat CENTER_ALIGNMENT;
=0.0
1.1 public static ﬁnal ﬂoat LEFT_ALIGNMENT;
=1.0
1.1 public static ﬁnal ﬂoat RIGHT_ALIGNMENT;
=0.0
1.1 public static ﬁnal ﬂoat TOP_ALIGNMENT;
// Event Registration Methods (by event name)
synchronized
1.1 public void addComponentListener(java.awt.e vent.ComponentListener l);
synchronized
1.1 public void removeComponentListener(java.awt.e vent.ComponentListener l);
synchronized
1.1 public void addFocusListener(java.awt.e vent.FocusListener l);
synchronized
1.1 public void removeFocusListener(java.awt.e vent.FocusListener l);
synchronized
1.2 public void addInputMethodListener(java.awt.e vent.InputMethodListener l);
synchronized
1.2 public void removeInputMethodListener(java.awt.e vent.InputMethodListener l);
synchronized
1.1 public void addKeyListener(java.awt.e vent.Ke yListener l);
synchronized
1.1 public void removeKeyListener(java.awt.e vent.Ke yListener l);
synchronized
1.1 public void addMouseListener(java.awt.e vent.MouseListener l);
synchronized
1.1 public void removeMouseListener(java.awt.e vent.MouseListener l);
synchronized
1.1 public void addMouseMotionListener(java.awt.e vent.MouseMotionListener l);
java.awt
java.awt.Component
Chapter 9 – The java.awt Package
173

synchronized
1.1 public void removeMouseMotionListener(java.awt.e vent.MouseMotionListener l);
synchronized
1.2 public void addProper tyChangeListener(java.beans.Proper tyChangeListener listener);
synchronized
1.2 public void removeProper tyChangeListener(java.beans.Proper tyChangeListener listener);
// Property Accessor Methods (by property name)
1.1 public ﬂoat getAlignmentX();
1.1 public ﬂoat getAlignmentY();
public Color getBackground();
public void setBackground(Color c);
1.1 public Rectangle getBounds();
1.2 public Rectangle getBounds(Rectangle rv);
1.1 public void setBounds(Rectangle r);
1.1 public void setBounds(int x, int y, int width, int height);
public java.awt.image.ColorModel getColorModel();
1.2 public ComponentOrientation getComponentOrientation();
1.2 public void setComponentOrientation(ComponentOrientation o);
1.1 public Cursor getCursor();
synchronized
1.1 public void setCursor(Cursor cursor);
1.2 public boolean isDisplayable();
constant
1.2 public boolean isDoubleBuffered();
synchronized
1.2 public java.awt.dnd.DropTarget getDropTarget();
synchronized
1.2 public void setDropTarget(java.awt.dnd.DropTarget dt);
public boolean isEnabled();
1.1 public void setEnabled(boolean b);
1.1 public boolean isFocusTraversable();
Implements:MenuContainer
public Font getFont();
public void setFont(Font f);
public Color getForeground();
public void setForeground(Color c);
public Graphics getGraphics();
1.2 public int getHeight();
1.2 public java.awt.im.InputContext getInputContext();
constant
1.2 public java.awt.im.InputMethodRequests getInputMethodRequests();
1.2 public boolean isLightweight();
1.1 public java.util.Locale getLocale();
1.1 public void setLocale(java.util.Locale l);
1.1 public Point getLocation();
1.2 public Point getLocation(Point rv);
1.1 public void setLocation(Point p);
1.1 public void setLocation(int x, int y);
1.1 public Point getLocationOnScreen();
1.1 public Dimension getMaximumSize();
1.1 public Dimension getMinimumSize();
1.1 public String getName();
1.1 public void setName(String name);
1.2 public boolean isOpaque();
public Container getParent();
1.1 public Dimension getPrefer redSize();
public boolean isShowing();
1.1 public Dimension getSize();
1.2 public Dimension getSize(Dimension rv);
1.1 public void setSize(Dimension d);
1.1 public void setSize(int width, int height);
public Toolkit getToolkit();
1.1 public ﬁnal Object getTreeLock();
public boolean isValid();
public boolean isV isible();
1.1 public void setV isible(boolean b);
1.2 public int getW idth();
java.awt.Component
174 Chapter 9 – The java.awt Package

1.2 public int getX();
1.2 public int getY();
// Public Instance Methods
synchronized
1.1 public void add(PopupMenu popup);
public void addNotify();
synchronized
1.2 public void addProper tyChangeListener(String proper tyName,
java.beans.Proper tyChangeListener listener);
public int checkImage(Image image, java.awt.image.ImageObserver obser ver);
public int checkImage(Image image, int width, int height, java.awt.image.ImageObserver obser ver);
1.1 public boolean contains(Point p);
1.1 public boolean contains(int x, int y);
public Image createImage(java.awt.image.ImageProducer producer);
public Image createImage(int width, int height);
1.1 public ﬁnal void dispatchEvent(AWTEvent e);
1.1 public void doLayout();
1.2 public void enableInputMethods(boolean enable);
1.1 public Component getComponentAt(Point p);
1.1 public Component getComponentAt(int x, int y);
public FontMetrics getFontMetrics(Font font);
1.2 public boolean hasFocus();
public void invalidate();
public void list();
1.1 public void list(java.io.PrintWriter out);
public void list(java.io.PrintStream out);
1.1 public void list(java.io.PrintWriter out, int indent);
public void list(java.io.PrintStream out, int indent);
empty
public void paint(Graphics g);
public void paintAll(Graphics g);
public boolean prepareImage(Image image, java.awt.image.ImageObserver obser ver);
public boolean prepareImage(Image image, int width, int height, java.awt.image.ImageObserver obser ver);
public void print(Graphics g);
public void printAll(Graphics g);
public void removeNotify();
synchronized
1.2 public void removeProper tyChangeListener(String proper tyName,
java.beans.Proper tyChangeListener listener);
public void repaint();
public void repaint(long tm);
public void repaint(int x, int y, int width, int height);
public void repaint(long tm, int x, int y, int width, int height);
public void requestFocus();
1.1 public void transferFocus();
public void update(Graphics g);
public void validate();
// Methods Implementing ImageObser ver
public boolean imageUpdate(Image img, int ﬂags, int x, int y, int w, int h);
// Methods Implementing MenuContainer
public Font getFont();
synchronized
1.1 public void remove(MenuComponent popup);
// Public Methods Overriding Object
public String toString();
// Protected Instance Methods
1.2 protected AWTEvent coalesceEvents(AWTEvent existingEvent, AWTEvent newEvent);
1.1 protected ﬁnal void disableEvents(long eventsToDisable);
1.1 protected ﬁnal void enableEvents(long eventsToEnable);
1.2 protected void ﬁreProper tyChange(String proper tyName, Object oldValue, Object newValue);
protected String paramString();
1.1 protected void processComponentEvent(java.awt.e vent.ComponentEvent e);
1.1 protected void processEvent(AWTEvent e);
java.awt
java.awt.Component
Chapter 9 – The java.awt Package
175

1.1 protected void processFocusEvent(java.awt.e vent.FocusEvent e);
1.2 protected void processInputMethodEvent(java.awt.e vent.InputMethodEvent e);
1.1 protected void processKeyEvent(java.awt.e vent.Ke yEvent e);
1.1 protected void processMouseEvent(java.awt.e vent.MouseEvent e);
1.1 protected void processMouseMotionEvent(java.awt.e vent.MouseEvent e);
// Deprecated Public Methods
constant
# public boolean action(Event evt, Object what);
# public Rectangle bounds();
# public void deliverEvent(Event e);
# public void disable();
# public void enable();
# public void enable(boolean b);
# public java.awt.peer.ComponentPeer getPeer();
constant
# public boolean gotFocus(Event evt, Object what);
# public boolean handleEvent(Event evt);
# public void hide();
# public boolean inside(int x, int y);
constant
# public boolean keyDown(Event evt, int key);
constant
# public boolean keyUp(Event evt, int key);
empty
# public void layout();
# public Component locate(int x, int y);
# public Point location();
constant
# public boolean lostFocus(Event evt, Object what);
# public Dimension minimumSize();
constant
# public boolean mouseDown(Event evt, int x, int y);
constant
# public boolean mouseDrag(Event evt, int x, int y);
constant
# public boolean mouseEnter(Event evt, int x, int y);
constant
# public boolean mouseExit(Event evt, int x, int y);
constant
# public boolean mouseMove(Event evt, int x, int y);
constant
# public boolean mouseUp(Event evt, int x, int y);
# public void move(int x, int y);
# public void nextFocus();
Implements:MenuContainer
# public boolean postEvent(Event e);
# public Dimension prefer redSize();
# public void reshape(int x, int y, int width, int height);
# public void resize(Dimension d);
# public void resize(int width, int height);
# public void show();
# public void show(boolean b);
# public Dimension size();
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, MenuContainer, Serializable)
Subc lasses: Button, Canvas, Checkbox, Choice, Container, Label, java.awt.List, Scrollbar, TextComponent,
javax.swing .Box.Filler
Passed To: Too many methods to list.
Retur ned By: Too many methods to list.
Type Of: Too many fields to list.
ComponentOrientation
Ja va 1.2
java.awt
serializable
This class encapsulates differ ences in the way characters in GUI components are
arranged into lines and the way lines are grouped into blocks. In western languages
like English, characters are arranged left to right and lines are arranged top to bottom,
but this is not true throughout the world. In Hebrew, for example, characters are
java.awt.Component
176 Chapter 9 – The java.awt Package

arranged from right to left, and in traditional Chinese, characters are arranged from top
to bottom.
The isHorizontal() and isLeftToRight() methods specify the necessary orientation informa-
tion. The class deﬁnes two constants for commonly used orientation types. Authors of
AWT, Swing, and JavaBeans components may want to take orientation into account
when developing their components (see the getComponentOrientation() method of Compo-
nent). Applications that use these components should typically not have to worry about
this class.
You can query the default orientation for a given java.util.Locale by calling the static get-
Orientation() method. Set the componentOrientation pr operty of all components in a window
by passing a ResourceBundle object to the applyResourceBundle() method of a Window. This
looks up the “Orientation” resource in the bundle and, if it is not found, uses the
default orientation for the locale of the bundle.
public ﬁnal class ComponentOrientation implements Serializable {
// No Constructor
// Public Constants
public static ﬁnal ComponentOrientation LEFT_TO_RIGHT;
public static ﬁnal ComponentOrientation RIGHT_TO_LEFT;
public static ﬁnal ComponentOrientation UNKNOWN;
// Public Class Methods
public static ComponentOrientation getOrientation(java.util.ResourceBundle bdl);
public static ComponentOrientation getOrientation(java.util.Locale locale);
// Public Instance Methods
public boolean isHorizontal();
public boolean isLeftToRight();
}
Hierar chy: Object→ComponentOrientation(Serializable)
Passed To: Component.setComponentOrientation()
Retur ned By: Component.getComponentOrientation(), ComponentOrientation.getOrientation()
Type Of: ComponentOrientation.{LEFT_TO_RIGHT, RIGHT_TO_LEFT, UNKNOWN}
Composite
Ja va 1.2
java.awt
This interface deﬁnes how two colors are combined to yield a composite color. When
Java 2D perfor ms a drawing operation, it uses a Composite object to combine the colors
it wants to draw with the colors that already exist on the screen or in the off-scr een
image.
The default compositing operation is to draw the new color on top of the color already
on the screen. If the new color is fully opaque, the existing color is ignored. If the new
color is partially transparent, however, it is combined with the color already on the
scr een to produce a composite color. To specify a differ ent compositing operation, pass
a Composite object to the setComposite() method of a Graphics2D object.
AlphaComposite is a commonly used implementation of Composite; it combines colors in a
number of possible ways based on their alpha-transparency levels. AlphaComposite is
suitable for most uses; very few applications should have to deﬁne a custom implemen-
tation of Composite.
Note that the only method of Composite, createContext(), does not perfor m compositing
itself. Instead, it retur ns a CompositeContext object suitable for compositing colors
encoded using the speciﬁed color models and rendering hints. It is the CompositeContext
object that perfor ms the actual work of combining colors.
java.awt
java.awt.Composite
Chapter 9 – The java.awt Package
177

public abstract interface Composite {
// Public Instance Methods
public abstract CompositeContext createContext(java.awt.image.ColorModel srcColorModel,
java.awt.image.ColorModel dstColorModel,
RenderingHints hints);
}
Implementations: AlphaComposite
Passed To: Graphics2D.setComposite()
Retur ned By: Graphics2D.getComposite()
CompositeContext
Ja va 1.2
java.awt
This interface deﬁnes the methods that do the actual work of compositing colors. The
CompositeContext inter face is used internally by Java 2D; applications never need to call
CompositeContext methods. And only applications that implement a custom Composite
class need to implement this interface.
A CompositeContext object holds the state for a particular compositing operation (in multi-
thr eaded pr ograms, ther e may be several compositing operations in progr ess at once).
A Graphics2D object creates CompositeContext objects as needed by calling the createCon-
text() method of its Composite object.
Once a CompositeContext object has been created, its compose() method is responsible for
combining the colors of the ﬁrst two Raster objects passed to it and storing the resulting
colors in the speciﬁed WriteableRaster. (This WriteableRaster is usually the same object as
one of the ﬁrst two arguments.) The dispose() method should free any resources held by
the CompositeContext. It is called when the Graphics2D no longer requir es the Composite-
Context.
public abstract interface CompositeContext {
// Public Instance Methods
public abstract void compose(java.awt.image.Raster src, java.awt.image.Raster dstIn,
java.awt.image.WritableRaster dstOut);
public abstract void dispose();
}
Retur ned By: AlphaComposite.createContext(), Composite.createContext()
Container
Ja va 1.0
java.awt
serializable AWT component PJ1.1
This class implements a component that can contain other components. You cannot
instantiate Container dir ectly but must use one of its subclasses, such as Panel, Frame, or
Dialog. Once a Container is created, you can set its LayoutManager with setLayout(), add com-
ponents to it with add(), and remove them with remove(). getComponents() retur ns an array
of the components contained in a Container. locate() deter mines within which contained
component a speciﬁed point falls. list() pr oduces helpful debugging output.
public class Container extends Component {
// Public Constructors
public Container();
// Event Registration Methods (by event name)
synchronized
1.1 public void addContainerListener(java.awt.e vent.ContainerListener l);
synchronized
1.1 public void removeContainerListener(java.awt.e vent.ContainerListener l);
java.awt.Composite
178 Chapter 9 – The java.awt Package

// Property Accessor Methods (by property name)
Overrides:Component default:0.5
1.1 public ﬂoat getAlignmentX();
Overrides:Component default:0.5
1.1 public ﬂoat getAlignmentY();
default:0
1.1 public int getComponentCount();
public Component[ ] getComponents();
Overrides:Component synchronized
1.2 public void setCursor(Cursor cursor);
Overrides:Component
1.2 public void setFont(Font f);
1.1 public Insets getInsets();
default:null
public LayoutManager getLayout();
public void setLayout(LayoutManager mgr);
Overrides:Component
1.1 public Dimension getMaximumSize();
Overrides:Component
1.1 public Dimension getMinimumSize();
Overrides:Component
1.1 public Dimension getPrefer redSize();
// Public Instance Methods
public Component add(Component comp);
1.1 public void add(Component comp, Object constraints);
public Component add(String name, Component comp);
public Component add(Component comp, int index);
1.1 public void add(Component comp, Object constraints, int index);
1.2 public Component ﬁndComponentAt(Point p);
1.2 public Component ﬁndComponentAt(int x, int y);
public Component getComponent(int n);
1.1 public boolean isAncestorOf(Component c);
public void paintComponents(Graphics g);
public void printComponents(Graphics g);
public void remove(Component comp);
1.1 public void remove(int index);
public void removeAll();
// Public Methods Overriding Component
public void addNotify();
1.1 public void doLayout();
1.1 public Component getComponentAt(Point p);
1.1 public Component getComponentAt(int x, int y);
1.1 public void invalidate();
1.1 public void list(java.io.PrintWriter out, int indent);
public void list(java.io.PrintStream out, int indent);
1.1 public void paint(Graphics g);
1.1 public void print(Graphics g);
public void removeNotify();
1.1 public void update(Graphics g);
public void validate();
// Protected Methods Overriding Component
protected String paramString();
1.1 protected void processEvent(AWTEvent e);
// Protected Instance Methods
1.1 protected void addImpl(Component comp, Object constraints, int index);
1.1 protected void processContainerEvent(java.awt.e vent.ContainerEvent e);
1.1 protected void validateTree();
// Deprecated Public Methods
# public int countComponents();
Overrides:Component
# public void deliverEvent(Event e);
# public Insets insets();
Overrides:Component
# public void layout();
Overrides:Component
# public Component locate(int x, int y);
Overrides:Component
# public Dimension minimumSize();
Overrides:Component
# public Dimension prefer redSize();
}
java.awt
java.awt.Container
Chapter 9 – The java.awt Package
179

Hierar chy: Object→Component(java.awt.image.ImageObser ver, MenuContainer, Serializable)→Container
Subc lasses: Panel, ScrollPane, Window, javax.swing .Box, javax.swing .CellRendererPane,
javax.swing .JComponent, javax.swing .tree.DefaultTreeCellEditor.EditorContainer
Passed To: Too many methods to list.
Retur ned By: Too many methods to list.
Type Of: javax.swing .JRootPane.contentPane, javax.swing .tree.DefaultTreeCellEditor.editingContainer
Cursor
Ja va 1.1
java.awt
serializable PJ1.1
This class repr esents a mouse cursor. It deﬁnes a number of constants, which repr esent
the 14 predeﬁned cursors provided by Java 1.0 and Java 1.1. You can pass one of these
constants to the constructor to create a cursor of the speciﬁed type. Call getType() to
deter mine the type of an existing Cursor object. Since there are only a ﬁxed number of
available cursors, the static method getPredeﬁnedCursor() is more efﬁcient than the Cursor()
constructor — it maintains a cache of Cursor objects that can be reused. The static getDe-
faultCursor() method retur ns the default cursor for the underlying system.
In Java 1.2, the Cursor class has a new getSystemCustomCursor() method that retur ns a
named cursor deﬁned by a system administrator in a systemwide cursors.pr operties ﬁle.
Since there is no way to query the list of system-speciﬁc custom cursors, however, this
method is rarely used. Instead, you can create your own custom cursor by calling the
createCustomCursor() method of the Toolkit object. You should ﬁrst check whether custom
cursors are supported by calling the getBestCursorSize() method of Toolkit. If this method
indicates a width or height of 0, custom cursors are not supported (by either the Java
implementation or the underlying windowing system).
public class Cursor implements Serializable {
// Public Constructors
public Cursor(int type);
// Protected Constructors
1.2 protected Cursor(String name);
// Public Constants
=1
public static ﬁnal int CROSSHAIR_CURSOR;
=-1
1.2 public static ﬁnal int CUSTOM_CURSOR;
=0
public static ﬁnal int DEFAULT_CURSOR;
=11
public static ﬁnal int E_RESIZE_CURSOR;
=12
public static ﬁnal int HAND_CURSOR;
=13
public static ﬁnal int MOVE_CURSOR;
=8
public static ﬁnal int N_RESIZE_CURSOR;
=7
public static ﬁnal int NE_RESIZE_CURSOR;
=6
public static ﬁnal int NW_RESIZE_CURSOR;
=9
public static ﬁnal int S_RESIZE_CURSOR;
=5
public static ﬁnal int SE_RESIZE_CURSOR;
=4
public static ﬁnal int SW_RESIZE_CURSOR;
=2
public static ﬁnal int TEXT_CURSOR;
=10
public static ﬁnal int W_RESIZE_CURSOR;
=3
public static ﬁnal int WAIT_CURSOR;
// Public Class Methods
public static Cursor getDefaultCursor();
public static Cursor getPredeﬁnedCursor(int type);
1.2 public static Cursor getSystemCustomCursor(String name) throws AWTException;
// Public Instance Methods
1.2 public String getName();
public int getType();
java.awt.Container
180 Chapter 9 – The java.awt Package

// Public Methods Overriding Object
1.2 public String toString();
// Protected Class Fields
protected static Cursor[ ] predeﬁned;
// Protected Instance Fields
1.2 protected String name;
}
Hierar chy: Object→Cursor(Serializable)
Passed To: Too many methods to list.
Retur ned By: Too many methods to list.
Type Of: Cursor.predefined, java.awt.dnd.DragSource.{DefaultCopyDrop, DefaultCopyNoDrop,
DefaultLinkDrop, DefaultLinkNoDrop, DefaultMoveDrop, DefaultMoveNoDrop}
Dialog
Ja va 1.0
java.awt
serializable AWT component PJ1.1(mod)
This class repr esents a dialog box window. A Dialog can be modal, so that it blocks user
input to all other windows until dismissed. It is optional whether a dialog has a title
and whether it is resizable. A Dialog object is a Container, so you can add Component
objects to it in the normal way with the add() method. The default LayoutManager for Dia-
log is BorderLayout. You can specify a differ ent LayoutManager object with setLayout(). Call
the pack() method of Window to initiate layout management of the dialog and set its ini-
tial size appropriately. Call show() to pop a dialog up and setV isible(false) to pop it down.
For modal dialogs, show() blocks until the dialog is dismissed. Event handling continues
while show() is blocked, using a new event dispatcher thread. In Java 1.0, show() is
inherited from Window. Call the Window.dispose() method when the Dialog is no longer
needed so that its window system resources may be reused.
In Personal Java environments, support for modeless dialogs is optional, and the Dia-
log() constructors can throw an exception if you attempt to create a modeless dialog.
Also, the setResizable() method is optional, and calls to it can be ignored.
public class Dialog extends Window {
// Public Constructors
1.1 public Dialog(Frame owner);
1.2 public Dialog(Dialog owner);
1.2 public Dialog(Dialog owner, String title);
1.1 public Dialog(Frame owner, String title);
public Dialog(Frame owner, boolean modal);
public Dialog(Frame owner, String title, boolean modal);
1.2 public Dialog(Dialog owner, String title, boolean modal);
// Property Accessor Methods (by property name)
public boolean isModal();
1.1 public void setModal(boolean b);
public boolean isResizable();
public void setResizable(boolean resizable);
public String getT itle();
synchronized
public void setT itle(String title);
// Public Methods Overriding Window
public void addNotify();
1.2 public void dispose();
1.2 public void hide();
1.1 public void show();
java.awt
java.awt.Dialog
Chapter 9 – The java.awt Package
181

// Protected Methods Overriding Container
protected String paramString();
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, MenuContainer, Serializable)→
Container→Window→Dialog
Subc lasses: FileDialog, javax.swing .JDialog
Passed To: Dialog.Dialog(), Toolkit.createDialog(), javax.swing .JDialog.JDialog()
Dimension
Ja va 1.0
java.awt
cloneable serializable PJ1.1
This class contains two integer ﬁelds that describe a width and a height of something.
The ﬁelds are public and can be manipulated directly.
In Java 1.0 and Java 1.1, Dimension is a subclass of Object. In Java 1.2, with the introduc-
tion of Java 2D, it has become a concrete subclass of java.awt.geom.Dimension2D. Contrast
Dimension with Dimension2D,which repr esents the width and height with double values.
public class Dimension extends java.awt.geom.Dimension2D implements Serializable {
// Public Constructors
public Dimension();
public Dimension(Dimension d);
public Dimension(int width, int height);
// Public Instance Methods
1.1 public Dimension getSize();
1.1 public void setSize(Dimension d);
1.1 public void setSize(int width, int height);
// Public Methods Overriding Dimension2D
default:0.0
1.2 public double getHeight();
default:0.0
1.2 public double getW idth();
1.2 public void setSize(double width, double height);
// Public Methods Overriding Object
1.1 public boolean equals(Object obj);
public String toString();
// Public Instance Fields
public int height;
public int width;
}
Hierar chy: Object→java.awt.geom.Dimension2D(Cloneable)→Dimension(Serializable)
Subc lasses: javax.swing .plaf.DimensionUIResource
Passed To: Too many methods to list.
Retur ned By: Too many methods to list.
Type Of: javax.swing .JTable.prefer redViewpor tSize
Event
Ja va 1.0
java.awt
serializable PJ1.1
This class contains public instance variables that describe some kind of GUI event. In
Java 1.1, this class has been superseded by AWTEvent and the java.awt.event package.
The class contains a large number of constants. Some of the constants specify the event
type and are values for the id variable. Other constants are values for keys, such as the
function keys, that do not have ASCII (Latin-1) values and are set on the key ﬁeld. Other
constants are mask values that are ORed into the modiﬁers ﬁeld to describe the state of
java.awt.Dialog
182 Chapter 9 – The java.awt Package

the modiﬁer keys on the keyboard. The target ﬁeld is very important—it is the object
for which the event occurred. The when ﬁeld speciﬁes when the event occurred. The x
and y ﬁelds specify the mouse coordinates at which it occurred. Finally, the arg ﬁeld is a
value speciﬁc to the type of the event. Not all ﬁelds have valid values for all types of
events.
public class Event implements Serializable {
// Public Constructors
public Event(Object target, int id, Object arg);
public Event(Object target, long when, int id, int x, int y, int key, int modiﬁers);
public Event(Object target, long when, int id, int x, int y, int key, int modiﬁers, Object arg);
// Public Constants
=1001
public static ﬁnal int ACTION_EVENT;
=8
public static ﬁnal int ALT_MASK;
=8
1.1 public static ﬁnal int BACK_SPACE;
=1022
1.1 public static ﬁnal int CAPS_LOCK;
=2
public static ﬁnal int CTRL_MASK;
=127
1.1 public static ﬁnal int DELETE;
=1005
public static ﬁnal int DOWN;
=1001
public static ﬁnal int END;
=10
1.1 public static ﬁnal int ENTER;
=27
1.1 public static ﬁnal int ESCAPE;
=1008
public static ﬁnal int F1;
=1017
public static ﬁnal int F10;
=1018
public static ﬁnal int F11;
=1019
public static ﬁnal int F12;
=1009
public static ﬁnal int F2;
=1010
public static ﬁnal int F3;
=1011
public static ﬁnal int F4;
=1012
public static ﬁnal int F5;
=1013
public static ﬁnal int F6;
=1014
public static ﬁnal int F7;
=1015
public static ﬁnal int F8;
=1016
public static ﬁnal int F9;
=1004
public static ﬁnal int GOT_FOCUS;
=1000
public static ﬁnal int HOME;
=1025
1.1 public static ﬁnal int INSERT;
=403
public static ﬁnal int KEY_ACTION;
=404
public static ﬁnal int KEY_ACTION_RELEASE;
=401
public static ﬁnal int KEY_PRESS;
=402
public static ﬁnal int KEY_RELEASE;
=1006
public static ﬁnal int LEFT;
=702
public static ﬁnal int LIST_DESELECT;
=701
public static ﬁnal int LIST_SELECT;
=1002
public static ﬁnal int LOAD_FILE;
=1005
public static ﬁnal int LOST_FOCUS;
=4
public static ﬁnal int META_MASK;
=501
public static ﬁnal int MOUSE_DOWN;
=506
public static ﬁnal int MOUSE_DRAG;
=504
public static ﬁnal int MOUSE_ENTER;
=505
public static ﬁnal int MOUSE_EXIT;
=503
public static ﬁnal int MOUSE_MOVE;
=502
public static ﬁnal int MOUSE_UP;
=1023
1.1 public static ﬁnal int NUM_LOCK;
=1024
1.1 public static ﬁnal int PA USE;
=1003
public static ﬁnal int PGDN;
=1002
public static ﬁnal int PGUP;
=1020
1.1 public static ﬁnal int PRINT_SCREEN;
=1007
public static ﬁnal int RIGHT;
java.awt
java.awt.Event
Chapter 9 – The java.awt Package
183

=1003
public static ﬁnal int SAVE_FILE;
=605
public static ﬁnal int SCROLL_ABSOLUTE;
=606
1.1 public static ﬁnal int SCROLL_BEGIN;
=607
1.1 public static ﬁnal int SCROLL_END;
=602
public static ﬁnal int SCROLL_LINE_DOWN;
=601
public static ﬁnal int SCROLL_LINE_UP;
=1021
1.1 public static ﬁnal int SCROLL_LOCK;
=604
public static ﬁnal int SCROLL_PAGE_DOWN;
=603
public static ﬁnal int SCROLL_PAGE_UP;
=1
public static ﬁnal int SHIFT_MASK;
=9
1.1 public static ﬁnal int TAB;
=1004
public static ﬁnal int UP;
=204
public static ﬁnal int WINDOW_DEICONIFY;
=201
public static ﬁnal int WINDOW_DESTROY;
=202
public static ﬁnal int WINDOW_EXPOSE;
=203
public static ﬁnal int WINDOW_ICONIFY;
=205
public static ﬁnal int WINDOW_MOVED;
// Public Instance Methods
public boolean controlDown();
public boolean metaDown();
public boolean shiftDown();
public void translate(int x, int y);
// Public Methods Overriding Object
public String toString();
// Protected Instance Methods
protected String paramString();
// Public Instance Fields
public Object arg;
public int clickCount;
public Event evt;
public int id;
public int key;
public int modiﬁers;
public Object target;
public long when;
public int x;
public int y;
}
Hierar chy: Object→Event(Serializable)
Passed To: Too many methods to list.
Type Of: Event.evt
EventQueue
Ja va 1.1
java.awt
PJ1.1
This class implements an event queue for AWT events in Java 1.1. When an EventQueue
is created, a new thread is automatically created and started to remove events from the
fr ont of the queue and dispatch them to the appropriate component. It is this thread,
cr eated by the EventQueue, that notiﬁes event listeners and executes most of the code in
a typical GUI-driven application.
An application can create and use its own private EventQueue, but all AWT events are
placed on and dispatched from a single system EventQueue. Use the getSystemEventQueue()
method of the Toolkit class to get the system EventQueue object.
getNextEvent() removes and retur ns the event at the front of the queue. It blocks if there
ar e no events in the queue. peekEvent() retur ns the event at the front of the queue
java.awt.Event
184 Chapter 9 – The java.awt Package

without removing it from the queue. Passed an optional AWTEvent id ﬁeld, it retur ns the
ﬁrst event of the speciﬁed type. Finally, postEvent() places a new event on the end of the
event queue.
In Java 1.2, EventQueue deﬁnes three useful static methods. isDispatchThread() retur ns tr ue
if the calling thread is the AWT event dispatch thread. To avoid thread-safety issues, all
modiﬁcations to AWT and Swing components should be done from this dispatch
thr ead. If another thread needs to operate on a component, it should wrap the desired
operation in a Runnable object and pass that object to invokeLater() or invokeAndWait().
These methods bundle the Runnable object into an ActiveEvent that is placed on the
queue. When the ActiveEvent reaches the head of the queue, the Runnable code is
invoked by the event dispatch thread and can safely modify any AWT and Swing com-
ponents. invokeLater() retur ns immediately, while invokeAndWait() blocks until the Runnable
code has been run. It is an error to call invokeAndWait() fr om the event dispatch thread
itself. See also ActiveEvent and javax.swing .SwingUtilities. Except for these useful static meth-
ods, most applications do not need to use the EventQueue class at all; they can simply
rely on the system to dispatch events automatically.
public class EventQueue {
// Public Constructors
public EventQueue();
// Public Class Methods
1.2 public static void invokeAndWait(Runnable runnable) throws InterruptedException,
java.lang .reﬂect.InvocationTargetException;
1.2 public static void invokeLater(Runnable runnable);
1.2 public static boolean isDispatchThread();
// Public Instance Methods
synchronized
public AWTEvent getNextEvent() throws InterruptedException;
synchronized
public AWTEvent peekEvent();
synchronized
public AWTEvent peekEvent(int id);
public void postEvent(AWTEvent theEvent);
synchronized
1.2 public void push(EventQueue newEventQueue);
// Protected Instance Methods
1.2 protected void dispatchEvent(AWTEvent event);
1.2 protected void pop() throws java.util.EmptyStackException;
}
Passed To: EventQueue.push()
Retur ned By: Toolkit.{getSystemEventQueue(), getSystemEventQueueImpl()}
FileDialog
Ja va 1.0
java.awt
serializable AWT component PJ1.1(opt)
This class repr esents a ﬁle selection dialog box. The constants LOAD and SAVE ar e values
of an optional constructor argument that speciﬁes whether the dialog should be an
Open File dialog or a Save As dialog. You may specify a FilenameF ilter object to control
the ﬁles that are displayed in the dialog.
The inherited show() method pops the dialog up. For dialogs of this type, show() blocks,
not retur ning until the user has selected a ﬁle and dismissed the dialog (which pops
down automatically—you don’t have to call hide()). Once show() has retur ned, use get-
File() to get the name of the ﬁle the user selected.
public class FileDialog extends Dialog {
// Public Constructors
1.1 public FileDialog(Frame parent);
public FileDialog(Frame parent, String title);
public FileDialog(Frame parent, String title, int mode);
java.awt
java.awt.FileDialog
Chapter 9 – The java.awt Package
185

// Public Constants
=0
public static ﬁnal int LOAD;
=1
public static ﬁnal int SAVE;
// Property Accessor Methods (by property name)
public String getDirector y();
public void setDirector y(String dir);
public String getF ile();
public void setF ile(String ﬁle);
public java.io.FilenameF ilter getF ilenameF ilter();
synchronized
public void setF ilenameF ilter(java.io.F ilenameF ilter ﬁlter);
public int getMode();
1.1 public void setMode(int mode);
// Public Methods Overriding Dialog
public void addNotify();
// Protected Methods Overriding Dialog
protected String paramString();
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, MenuContainer, Serializable)→
Container→Window→Dialog→FileDialog
Passed To: Toolkit.createF ileDialog()
FlowLayout
Ja va 1.0
java.awt
serializable layout manager PJ1.1
A LayoutManager that arranges components in a container likes words on a page: from
left to right and top to bottom. It ﬁts as many components as it can in a row before
moving on to the next row. The constructor allows you to specify one of ﬁve constants
as an alignment value for the rows. LEFT, CENTER, and RIGHT specify left, center, and right
alignment, obviously. LEADING and TRAILING alignment are the same as LEFT and RIGHT
alignment in locales where writing is done left to right, but they have the opposite
meaning in locales where writing is done primarily right to left. You can also specify
the horizontal spacing between components and the vertical spacing between rows.
Applications should never call the LayoutManager methods of this class directly; the Con-
tainer for which the FlowLayout is register ed does this.
public class FlowLayout implements LayoutManager, Serializable {
// Public Constructors
public FlowLayout();
public FlowLayout(int align);
public FlowLayout(int align, int hgap, int vgap);
// Public Constants
=1
public static ﬁnal int CENTER;
=3
1.2 public static ﬁnal int LEADING;
=0
public static ﬁnal int LEFT;
=2
public static ﬁnal int RIGHT;
=4
1.2 public static ﬁnal int TRAILING;
// Property Accessor Methods (by property name)
default:1
1.1 public int getAlignment();
1.1 public void setAlignment(int align);
default:5
1.1 public int getHgap();
1.1 public void setHgap(int hgap);
default:5
1.1 public int getVgap();
1.1 public void setVgap(int vgap);
// Methods Implementing LayoutManager
empty
public void addLayoutComponent(String name, Component comp);
java.awt.FileDialog
186 Chapter 9 – The java.awt Package

public void layoutContainer(Container target);
public Dimension minimumLayoutSize(Container target);
public Dimension prefer redLayoutSize(Container target);
empty
public void removeLayoutComponent(Component comp);
// Public Methods Overriding Object
public String toString();
}
Hierar chy: Object→FlowLayout(LayoutManager, Serializable)
Font
Ja va 1.0
java.awt
serializable PJ1.1
This class repr esents a font. The Font() constructor is passed a name, a style, and a point
size. The style should be one of the constants PLAIN, BOLD, or ITALIC or the sum
BOLD+ITALIC.
The allowed font names have changed with each release of Java. In Java 1.0, the sup-
ported font names are “TimesRoman”, “Helvetica”, “Courier”, “Dialog”, “DialogInput”,
and “Symbol”. In Java 1.1, “serif”, “sansserif”, and “monospaced” should be used in
pr efer ence to the ﬁrst three names.
With the introduction of Java 2D, you may continue to use these logical names, but you
ar e not limited to them. In Java 1.2, you may specify the name of any font family avail-
able on the system. These are names such as “Times New Roman,” “Arial,” “New Cen-
tury Schoolbook,” “Bookman,” and so on. You can obtain a list of available font
families by calling the getAvailableFontFamilyNames() method of GraphicsEnvironment. You
may also pass the name of a speciﬁc font face to the Font() constructor. These are
names such as “Copperplate DemiBold Oblique.” When you specify the name of a spe-
ciﬁc font face, you typically specify a font style of PLAIN, since the style you want is
implicit in the name.
With Java 1.2, you can also create a font by passing a Map object that contains attribute
names and values to either the Font() constructor or the static getFont() method. The
attribute names and values are deﬁned by java.awt.font.TextAttribute. The TextAttribute con-
stants FAMILY, WEIGHT, POSTURE, and SIZE identify the attributes of interest.
In Java 1.2, new fonts can be derived from old fonts in a variety of ways, using the
deriveFont() methods. Most generally, the glyphs of a font may all be transformed with
the speciﬁed AfﬁneTransfor m.
If you need to know the height or width (or other metrics) of characters or strings
drawn using a Font, call the getFontMetrics() method of a Graphics object to obtain a Font-
Metrics object. The methods of this object retur n font measurement information as inte-
ger values. In Java 1.2, you can obtain higher-pr ecision
ﬂoating-point font
measur ements with the getLineMetrics(), getMaxCharBounds(), and getStringBounds() methods
of a Font. These methods requir e a FontRenderContext, which is obtained by calling the
getFontRenderContext() method of Graphics2D.
The canDisplay() method tests whether a Font can display a given character (i.e., whether
the font contains a glyph for that character). canDisplayUpTo() tests whether the Font can
display all the characters in a string and retur ns the index of the ﬁrst character it cannot
display.
public class Font implements Serializable {
// Public Constructors
1.2 public Font(java.util.Map attributes);
public Font(String name, int style, int size);
java.awt
java.awt.Font
Chapter 9 – The java.awt Package
187

// Public Constants
=1
public static ﬁnal int BOLD;
=1
1.2 public static ﬁnal int CENTER_BASELINE;
=2
1.2 public static ﬁnal int HANGING_BASELINE;
=2
public static ﬁnal int ITALIC;
=0
public static ﬁnal int PLAIN;
=0
1.2 public static ﬁnal int ROMAN_BASELINE;
// Public Class Methods
1.1 public static Font decode(String str);
1.2 public static Font getFont(java.util.Map attributes);
public static Font getFont(String nm);
public static Font getFont(String nm, Font font);
// Property Accessor Methods (by property name)
1.2 public java.util.Map getAttributes();
1.2 public java.text.AttributedCharacterIterator.Attribute[ ] getAvailableAttributes();
public boolean isBold();
public String getFamily();
1.2 public String getFamily(java.util.Locale l);
1.2 public String getFontName();
1.2 public String getFontName(java.util.Locale l);
public boolean isItalic();
1.2 public ﬂoat getItalicAngle();
1.2 public int getMissingGlyphCode();
public String getName();
1.2 public int getNumGlyphs();
public boolean isPlain();
1.2 public String getPSName();
public int getSize();
1.2 public ﬂoat getSize2D();
public int getStyle();
1.2 public java.awt.geom.AfﬁneTransform getTransfor m();
// Public Instance Methods
1.2 public boolean canDisplay(char c);
1.2 public int canDisplayUpTo(String str);
1.2 public int canDisplayUpTo(char[ ] text, int star t, int limit);
1.2 public int canDisplayUpTo(java.text.CharacterIterator iter, int star t, int limit);
1.2 public java.awt.font.GlyphVector createGlyphVector(java.awt.font.FontRenderContext frc,
java.text.CharacterIterator ci);
1.2 public java.awt.font.GlyphVector createGlyphVector(java.awt.font.FontRenderContext frc, char[ ] chars);
1.2 public java.awt.font.GlyphVector createGlyphVector(java.awt.font.FontRenderContext frc, int[ ] glyphCodes);
1.2 public java.awt.font.GlyphVector createGlyphVector(java.awt.font.FontRenderContext frc, String str);
1.2 public Font deriveFont(ﬂoat size);
1.2 public Font deriveFont(int style);
1.2 public Font deriveFont(java.awt.geom.AfﬁneTransform trans);
1.2 public Font deriveFont(java.util.Map attributes);
1.2 public Font deriveFont(int style, java.awt.geom.AfﬁneTransform trans);
1.2 public Font deriveFont(int style, ﬂoat size);
1.2 public byte getBaselineFor(char c);
1.2 public java.awt.font.LineMetrics getLineMetrics(String str, java.awt.font.FontRenderContext frc);
1.2 public java.awt.font.LineMetrics getLineMetrics(char[ ] chars, int beginIndex, int limit,
java.awt.font.FontRenderContext frc);
1.2 public java.awt.font.LineMetrics getLineMetrics(java.text.CharacterIterator ci, int beginIndex, int limit,
java.awt.font.FontRenderContext frc);
1.2 public java.awt.font.LineMetrics getLineMetrics(String str, int beginIndex, int limit,
java.awt.font.FontRenderContext frc);
1.2 public java.awt.geom.Rectangle2D getMaxCharBounds(java.awt.font.FontRenderContext frc);
1.2 public java.awt.geom.Rectangle2D getStringBounds(String str, java.awt.font.FontRenderContext frc);
1.2 public java.awt.geom.Rectangle2D getStringBounds(char[ ] chars, int beginIndex, int limit,
java.awt.font.FontRenderContext frc);
java.awt.Font
188 Chapter 9 – The java.awt Package

1.2 public java.awt.geom.Rectangle2D getStringBounds(java.text.CharacterIterator ci, int beginIndex, int limit,
java.awt.font.FontRenderContext frc);
1.2 public java.awt.geom.Rectangle2D getStringBounds(String str, int beginIndex, int limit,
java.awt.font.FontRenderContext frc);
constant
1.2 public boolean hasUnifor mLineMetrics();
// Public Methods Overriding Object
public boolean equals(Object obj);
public int hashCode();
public String toString();
// Protected Methods Overriding Object
1.2 protected void ﬁnalize() throws Throwable;
// Protected Instance Fields
protected String name;
1.2 protected ﬂoat pointSize;
protected int size;
protected int style;
// Deprecated Public Methods
1.1# public java.awt.peer.FontPeer getPeer();
}
Hierar chy: Object→Font(Serializable)
Subc lasses: javax.swing .plaf.FontUIResource
Passed To: Too many methods to list.
Retur ned By: Too many methods to list.
Type Of: FontMetrics.font, javax.swing .border.T itledBorder.titleFont, javax.swing .tree.DefaultTreeCellEditor.font
FontMetrics
Ja va 1.0
java.awt
serializable PJ1.1
This class repr esents font metrics for a speciﬁed Font. The methods allow you to deter-
mine the overall metrics for the font (ascent, descent, and so on) and compute the
width of strings that are to be displayed in a particular font. The FontMetrics() constructor
is protected; you can obtain a FontMetrics object for a font with the getFontMetrics()
method of Component, Graphics, or Toolkit.
In Java 1.2, with the introduction of Java 2D, you can obtain more precise (ﬂoating-
point) metrics using the getLineMetrics(), getMaxCharBounds(), and getStringBounds() methods
of FontMetrics or a Font object itself. See also java.awt.font.LineMetrics.
public abstract class FontMetrics implements Serializable {
// Protected Constructors
protected FontMetrics(Font font);
// Property Accessor Methods (by property name)
public int getAscent();
constant
public int getDescent();
public Font getFont();
public int getHeight();
constant
public int getLeading();
constant
public int getMaxAdvance();
public int getMaxAscent();
public int getMaxDescent();
public int[ ] getW idths();
// Public Instance Methods
public int bytesW idth(byte[ ] data, int off, int len);
public int charsW idth(char[ ] data, int off, int len);
public int charW idth(int ch);
java.awt
java.awt.FontMetr ics
Chapter 9 – The java.awt Package
189

public int charW idth(char ch);
1.2 public java.awt.font.LineMetrics getLineMetrics(String str, Graphics context);
1.2 public java.awt.font.LineMetrics getLineMetrics(char[ ] chars, int beginIndex, int limit, Graphics context);
1.2 public java.awt.font.LineMetrics getLineMetrics(java.text.CharacterIterator ci, int beginIndex, int limit,
Graphics context);
1.2 public java.awt.font.LineMetrics getLineMetrics(String str, int beginIndex, int limit, Graphics context);
1.2 public java.awt.geom.Rectangle2D getMaxCharBounds(Graphics context);
1.2 public java.awt.geom.Rectangle2D getStringBounds(String str, Graphics context);
1.2 public java.awt.geom.Rectangle2D getStringBounds(char[ ] chars, int beginIndex, int limit, Graphics context);
1.2 public java.awt.geom.Rectangle2D getStringBounds(java.text.CharacterIterator ci, int beginIndex, int limit,
Graphics context);
1.2 public java.awt.geom.Rectangle2D getStringBounds(String str, int beginIndex, int limit, Graphics context);
1.2 public boolean hasUnifor mLineMetrics();
public int stringW idth(String str);
// Public Methods Overriding Object
public String toString();
// Protected Instance Fields
protected Font font;
// Deprecated Public Methods
# public int getMaxDecent();
}
Hierar chy: Object→FontMetrics(Serializable)
Passed To: javax.swing .SwingUtilities.{computeStringWidth(), layoutCompoundLabel()},
javax.swing .text.Utilities.{getBreakLocation(), getTabbedTextOffset(), getTabbedTextW idth()}
Retur ned By: Too many methods to list.
Type Of: javax.swing .text.PlainView.metrics
Frame
Ja va 1.0
java.awt
serializable AWT component PJ1.1(mod)
This class repr esents an optionally resizable top-level application window with a title-
bar and other platform-dependent window decorations. setT itle() speciﬁes a title, set-
MenuBar() speciﬁes a menu bar, setCursor() speciﬁes a cursor, and setIconImage() speciﬁes
an icon for the window. Call the pack() method of Window to initiate layout management
of the window and set its initial size appropriately. Call the show() method of Window to
make the window appear and be brought to the top of the window stack. Call setV isi-
ble(false) to make the window disappear. Call setState(Frame.ICONIFIED) to iconify the win-
dow, and call setState(Frame.NORMAL) to deiconify it. Use getState() to determine whether
the window is iconiﬁed or not. Call the static getFrames() method to obtain an array of
all Frame objects that have been created by the application or applet. Call the dispose()
method when the Frame is no longer needed, so that it can release its window system
resources for reuse.
The constants deﬁned by this class specify various cursor types. As of Java 1.1, these
constants and the cursor methods of Frame ar e depr ecated in favor of the Cursor class
and cursor methods of Component.
Personal Java environments can support only a single Frame object, and any calls to the
Frame() constructor after the ﬁrst can throw an exception.
public class Frame extends Window implements MenuContainer {
// Public Constructors
public Frame();
public Frame(String title);
java.awt.FontMetr ics
190 Chapter 9 – The java.awt Package

// Public Constants
=1
1.2 public static ﬁnal int ICONIFIED;
=0
1.2 public static ﬁnal int NORMAL;
// Public Class Methods
1.2 public static Frame[ ] getFrames();
// Property Accessor Methods (by property name)
default:null
public Image getIconImage();
synchronized
public void setIconImage(Image image);
default:null
public MenuBar getMenuBar();
public void setMenuBar(MenuBar mb);
default:true
public boolean isResizable();
public void setResizable(boolean resizable);
synchronized default:0
1.2 public int getState();
synchronized
1.2 public void setState(int state);
default:""
public String getT itle();
synchronized
public void setT itle(String title);
// Methods Implementing MenuContainer
public void remove(MenuComponent m);
// Public Methods Overriding Window
public void addNotify();
// Protected Methods Overriding Window
1.2 protected void ﬁnalize() throws Throwable;
// Public Methods Overriding Container
1.2 public void removeNotify();
// Protected Methods Overriding Container
protected String paramString();
// Deprecated Public Methods
default:0
# public int getCursorType();
synchronized
# public void setCursor(int cursorType);
// Deprecated Public Fields
=1
# public static ﬁnal int CROSSHAIR_CURSOR;
=0
# public static ﬁnal int DEFAULT_CURSOR;
=11
# public static ﬁnal int E_RESIZE_CURSOR;
=12
# public static ﬁnal int HAND_CURSOR;
=13
# public static ﬁnal int MOVE_CURSOR;
=8
# public static ﬁnal int N_RESIZE_CURSOR;
=7
# public static ﬁnal int NE_RESIZE_CURSOR;
=6
# public static ﬁnal int NW_RESIZE_CURSOR;
=9
# public static ﬁnal int S_RESIZE_CURSOR;
=5
# public static ﬁnal int SE_RESIZE_CURSOR;
=4
# public static ﬁnal int SW_RESIZE_CURSOR;
=2
# public static ﬁnal int TEXT_CURSOR;
=10
# public static ﬁnal int W_RESIZE_CURSOR;
=3
# public static ﬁnal int WAIT_CURSOR;
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, MenuContainer, Serializable)→
Container→Window→Frame(MenuContainer)
Subc lasses: javax.swing .JFrame
Passed To: Too many methods to list.
Retur ned By: Frame.getFrames(), javax.swing .JOptionPane.{getFrameForComponent(), getRootFrame()}
java.awt
java.awt.Frame
Chapter 9 – The java.awt Package
191

GradientPaint
Ja va 1.2
java.awt
This implementation of Paint ﬁlls shapes with a color gradient. To use a GradientPaint
object for ﬁlling shapes, pass it to the setPaint() method of a Graphics2D object.
The color of the ﬁll varies linearly between a color C1 and another color C2. The orien-
tation of the color gradient is deﬁned by a line between points P1 and P2. For example,
if these points deﬁne a horizontal line, the color of the ﬁll varies from left to right. If P1
is at the upper left of a rectangle and P2 is at the lower right, the ﬁll color varies from
upper left to lower right.
Color C1 is always used at point P1 and color C2 is used at P2. If the area to be ﬁlled
includes points outside of the ﬁll region deﬁned by P1 and P2, these points can be
ﬁlled in one of two ways. If the GradientPaint object is created with the cyclic constructor
argument set to tr ue, colors repeatedly cycle from C1 to C2 and back to C1 again. If cyclic
is speciﬁed as false or if this argument is omitted, the gradient does not repeat. When
an acyclic GradientPaint object is used, all points beyond P1 ar e given the color C1, and
all points beyond C2 ar e given the color P2.
public class GradientPaint implements Paint {
// Public Constructors
public GradientPaint(java.awt.geom.Point2D pt1, Color color1, java.awt.geom.Point2D pt2, Color color2);
public GradientPaint(java.awt.geom.Point2D pt1, Color color1, java.awt.geom.Point2D pt2, Color color2,
boolean cyclic);
public GradientPaint(ﬂoat x1, ﬂoat y1, Color color1, ﬂoat x2, ﬂoat y2, Color color2);
public GradientPaint(ﬂoat x1, ﬂoat y1, Color color1, ﬂoat x2, ﬂoat y2, Color color2, boolean cyclic);
// Property Accessor Methods (by property name)
public Color getColor1();
public Color getColor2();
public boolean isCyclic();
public java.awt.geom.Point2D getPoint1();
public java.awt.geom.Point2D getPoint2();
Implements:Transparency
public int getTransparency();
// Methods Implementing Paint
public PaintContext createContext(java.awt.image.ColorModel cm, Rectangle deviceBounds,
java.awt.geom.Rectangle2D userBounds, java.awt.geom.AfﬁneTransform xform,
RenderingHints hints);
// Methods Implementing Transparency
public int getTransparency();
}
Hierar chy: Object→GradientPaint(Paint(Transparency))
Graphics
Ja va 1.0
java.awt
PJ1.1(mod)
This abstract class deﬁnes a device-independent interface to graphics. It speciﬁes meth-
ods for drawing lines, ﬁlling areas, painting images, copying areas, and clipping graph-
ics output. Speciﬁc subclasses of Graphics ar e implemented for differ ent platfor ms and
dif ferent graphics output devices. A Graphics object cannot be created directly through a
constructor — it must either be obtained with the getGraphics() method of a Component or
an Image or copied from an existing Graphics object with create(). When a Graphics object
is no longer needed, you should call dispose() to free up the window system resources
it uses.
In Personal Java environments, the setXORMode() method may be unsupported.
java.awt.GradientPaint
192 Chapter 9 – The java.awt Package

public abstract class Graphics {
// Protected Constructors
protected Graphics();
// Property Accessor Methods (by property name)
1.1 public abstract Shape getClip();
1.1 public abstract void setClip(Shape clip);
1.1 public abstract void setClip(int x, int y, int width, int height);
1.1 public abstract Rectangle getClipBounds();
1.2 public Rectangle getClipBounds(Rectangle r);
public abstract Color getColor();
public abstract void setColor(Color c);
public abstract Font getFont();
public abstract void setFont(Font font);
public FontMetrics getFontMetrics();
public abstract FontMetrics getFontMetrics(Font f);
// Public Instance Methods
public abstract void clearRect(int x, int y, int width, int height);
public abstract void clipRect(int x, int y, int width, int height);
public abstract void copyArea(int x, int y, int width, int height, int dx, int dy);
public abstract Graphics create();
public Graphics create(int x, int y, int width, int height);
public abstract void dispose();
public void draw3DRect(int x, int y, int width, int height, boolean raised);
public abstract void drawArc(int x, int y, int width, int height, int star tAngle, int arcAngle);
public void drawBytes(byte[ ] data, int offset, int length, int x, int y);
public void drawChars(char[ ] data, int offset, int length, int x, int y);
public abstract boolean drawImage(Image img, int x, int y, java.awt.image.ImageObserver obser ver);
public abstract boolean drawImage(Image img, int x, int y, Color bgcolor, java.awt.image.ImageObserver obser ver);
public abstract boolean drawImage(Image img, int x, int y, int width, int height,
java.awt.image.ImageObserver obser ver);
public abstract boolean drawImage(Image img, int x, int y, int width, int height, Color bgcolor,
java.awt.image.ImageObserver obser ver);
1.1 public abstract boolean drawImage(Image img, int dx1, int dy1, int dx2, int dy2, int sx1, int sy1, int sx2, int sy2,
java.awt.image.ImageObserver obser ver);
1.1 public abstract boolean drawImage(Image img, int dx1, int dy1, int dx2, int dy2, int sx1, int sy1, int sx2, int sy2,
Color bgcolor, java.awt.image.ImageObserver obser ver);
public abstract void drawLine(int x1, int y1, int x2, int y2);
public abstract void drawOval(int x, int y, int width, int height);
public void drawPolygon(Polygon p);
public abstract void drawPolygon(int[ ] xPoints, int[ ] yPoints, int nPoints);
1.1 public abstract void drawPolyline(int[ ] xPoints, int[ ] yPoints, int nPoints);
public void drawRect(int x, int y, int width, int height);
public abstract void drawRoundRect(int x, int y, int width, int height, int arcWidth, int arcHeight);
1.2 public abstract void drawString(java.text.AttributedCharacterIterator iterator, int x, int y);
public abstract void drawString(String str, int x, int y);
public void ﬁll3DRect(int x, int y, int width, int height, boolean raised);
public abstract void ﬁllArc(int x, int y, int width, int height, int star tAngle, int arcAngle);
public abstract void ﬁllOval(int x, int y, int width, int height);
public void ﬁllPolygon(Polygon p);
public abstract void ﬁllPolygon(int[ ] xPoints, int[ ] yPoints, int nPoints);
public abstract void ﬁllRect(int x, int y, int width, int height);
public abstract void ﬁllRoundRect(int x, int y, int width, int height, int arcWidth, int arcHeight);
1.2 public boolean hitClip(int x, int y, int width, int height);
public abstract void setPaintMode();
public abstract void setXORMode(Color c1);
public abstract void translate(int x, int y);
// Public Methods Overriding Object
public void ﬁnalize();
java.awt
java.awt.Graphics
Chapter 9 – The java.awt Package
193

public String toString();
// Deprecated Public Methods
# public Rectangle getClipRect();
}
Subc lasses: Graphics2D, javax.swing .DebugGraphics
Passed To: Too many methods to list.
Retur ned By: Component.getGraphics(), Graphics.create(), Image.getGraphics(), PrintJob.getGraphics(),
java.awt.image.BufferedImage.getGraphics(), java.awt.peer.ComponentPeer.getGraphics(),
javax.swing .DebugGraphics.create(), javax.swing .JComponent.{getComponentGraphics(), getGraphics()}
Graphics2D
Ja va 1.2
java.awt
This class is the Java 2D graphics context that encapsulates all drawing and ﬁlling oper-
ations. It generalizes and extends the Graphics class. A number of attributes control how
the Graphics2D object perfor ms drawing and ﬁlling operations. You can set these
attributes with the following methods:
setBackground()
Speciﬁes the background color used by the clearRect() method of the Graphics
object. Prior to Java 2D, the background color could not be set.
setClip()
Sets the clipping region, outside of which no drawing is done. This method is
inherited from the Graphics object. Use setClip() to establish an initial clipping region
and then use clip() to narrow that region by intersecting it with other regions.
setComposite()
Speciﬁes a Composite object (typically an instance of AlphaComposite) that should be
used to combine drawing colors with the colors that are alr eady pr esent on the
drawing surface.
setFont()
Sets the default Font object used to draw text. This is a Graphics method, inherited
by Graphics2D.
setPaint()
Speciﬁes the Paint object that controls the color or pattern used for drawing. See
Color, GradientPaint, and TexturePaint.
setRenderingHints()
Sets hints about how drawing should be done. This method allows you to turn
antialiasing and color dithering on and off, for example. You can also set hints
with addRenderingHints() and setRenderingHint().
setStroke()
Speciﬁes the Stroke object (typically an instance of BasicStroke) used to trace the
outline of shapes that are drawn. The Stroke object effectively deﬁnes the pen that
is used for drawing operations.
setTransfor m()
Sets the AfﬁneTransfor m object used to convert from user coordinates to device coor-
dinates. Note that you do not usually call setTransfor m() dir ectly, but instead modify
the current transform with transfor m() or the more speciﬁc rotate(), scale(), shear(),
and translate() methods.
java.awt.Graphics
194 Chapter 9 – The java.awt Package

Once you have used these methods to conﬁgure a Graphics2D object as desired, you can
pr oceed to draw with it. The following methods are commonly used:
draw()
Draw the outline of a Shape, using the line style speciﬁed by the current Stroke
object and the color or pattern speciﬁed by the current Paint object. The
java.awt.geom package contains a number of commonly used implementations of
the Shape inter face.
ﬁll() Fill the interior of a Shape, using the color or pattern speciﬁed by the current Paint
object.
drawString()
Draw the speciﬁed text using the speciﬁed Font object and Paint object. drawGlyph-
Vector() is similar. See also the drawString() methods inherited from Graphics.
drawImage()
Draw an Image with an optional ﬁltering operation and/or an optional transforma-
tion. Also drawRenderableImage() and drawRenderedImage(). See also the drawImage()
methods inherited from Graphics.
public abstract class Graphics2D extends Graphics {
// Protected Constructors
protected Graphics2D();
// Property Accessor Methods (by property name)
public abstract Color getBackground();
public abstract void setBackground(Color color);
public abstract Composite getComposite();
public abstract void setComposite(Composite comp);
public abstract GraphicsConﬁguration getDeviceConﬁguration();
public abstract java.awt.font.FontRenderContext getFontRenderContext();
public abstract Paint getPaint();
public abstract void setPaint(Paint paint);
public abstract RenderingHints getRenderingHints();
public abstract void setRenderingHints(java.util.Map hints);
public abstract Stroke getStroke();
public abstract void setStroke(Stroke s);
public abstract java.awt.geom.AfﬁneTransform getTransfor m();
public abstract void setTransfor m(java.awt.geom.AfﬁneTransform Tx);
// Public Instance Methods
public abstract void addRenderingHints(java.util.Map hints);
public abstract void clip(Shape s);
public abstract void draw(Shape s);
public abstract void drawGlyphVector(java.awt.font.GlyphVector g, ﬂoat x, ﬂoat y);
public abstract boolean drawImage(Image img, java.awt.geom.AfﬁneTransform xform,
java.awt.image.ImageObserver obs);
public abstract void drawImage(java.awt.image.BufferedImage img, java.awt.image.BufferedImageOp op, int x,
int y);
public abstract void drawRenderableImage(java.awt.image.renderable.RenderableImage img,
java.awt.geom.AfﬁneTransform xform);
public abstract void drawRenderedImage(java.awt.image.RenderedImage img,
java.awt.geom.AfﬁneTransform xform);
public abstract void drawString(java.text.AttributedCharacterIterator iterator, ﬂoat x, ﬂoat y);
public abstract void drawString(String s, ﬂoat x, ﬂoat y);
public abstract void ﬁll(Shape s);
public abstract Object getRenderingHint(RenderingHints.Ke y hintKey);
public abstract boolean hit(Rectangle rect, Shape s, boolean onStroke);
public abstract void rotate(double theta);
java.awt
java.awt.Graphics2D
Chapter 9 – The java.awt Package
195

public abstract void rotate(double theta, double x, double y);
public abstract void scale(double sx, double sy);
public abstract void setRenderingHint(RenderingHints.Ke y hintKey, Object hintValue);
public abstract void shear(double shx, double shy);
public abstract void transfor m(java.awt.geom.AfﬁneTransform Tx);
public abstract void translate(double tx, double ty);
// Public Methods Overriding Graphics
public void draw3DRect(int x, int y, int width, int height, boolean raised);
public abstract void drawString(java.text.AttributedCharacterIterator iterator, int x, int y);
public abstract void drawString(String str, int x, int y);
public void ﬁll3DRect(int x, int y, int width, int height, boolean raised);
public abstract void translate(int x, int y);
}
Hierar chy: Object→Graphics→Graphics2D
Passed To: java.awt.font.GraphicAttribute.draw(), java.awt.font.ImageGraphicAttribute.draw(),
java.awt.font.ShapeGraphicAttribute.draw(), java.awt.font.TextLayout.draw()
Retur ned By: GraphicsEnvironment.createGraphics(), java.awt.image.BufferedImage.createGraphics()
GraphicsConfigTemplate
Ja va 1.2
java.awt
serializable
This abstract class is designed to support a matching operation that selects the best
conﬁguration from an array of GraphicsConﬁguration objects. The best conﬁguration is
deﬁned as the one that most closely matches the desired criteria. GraphicsConﬁgTemplate
does not deﬁne what those criteria might be, however: the criteria and the matching
algorithm are left entirely to the concrete subclass that provides deﬁnitions of the
abstract methods.
This class in not commonly used. There are not any implementations of GraphicsCon-
ﬁgTemplate built into Java 1.2. On many platforms, such as Windows, a screen has only
one available GraphicsConﬁguration, so ther e is never a need to try to ﬁnd the best one.
public abstract class GraphicsConﬁgTemplate implements Serializable {
// Public Constructors
public GraphicsConﬁgTemplate();
// Public Constants
=2
public static ﬁnal int PREFERRED;
=1
public static ﬁnal int REQUIRED;
=3
public static ﬁnal int UNNECESSARY;
// Public Instance Methods
public abstract GraphicsConﬁguration getBestConﬁguration(GraphicsConﬁguration[ ] gc);
public abstract boolean isGraphicsConﬁgSuppor ted(GraphicsConﬁguration gc);
}
Hierar chy: Object→GraphicsConfigTemplate(Serializable)
Passed To: GraphicsDevice.getBestConfiguration()
GraphicsConfiguration
Ja va 1.2
java.awt
This class describes a conﬁguration of a graphics device. It stores information about the
available resolution and colors of the device.
Resolution information is stored in the form of AfﬁneTransfor m objects. getDefaultTransfor m()
retur ns the default transform used to map user coordinates to device coordinates. For
scr een devices, this is usually an identity transform: by default, user coordinates are
java.awt.Graphics2D
196 Chapter 9 – The java.awt Package

measur ed in screen pixels. For printers, the default transform is such that 72 units in
user space maps to one inch on the printed page. getNor malizingTransfor m() retur ns an
AfﬁneTransfor m that, when concatenated to the default transform, yields a coordinate sys-
tem in which 72 units of user space equal one inch on the screen or on a printed piece
of paper. (For printers, this normalizing transform is obviously the identity transform,
since the default transform is alr eady 72 units to the inch.)
Color information about the device is retur ned by getColorModel(), in the form of a
java.awt.image.ColorModel object. A ColorModel maps pixel values to their individual color
components. The zero-argument form of getColorModel() retur ns the default color model
for the conﬁguration. If you pass one of the constants deﬁned by the Transparency inter-
face, the method retur ns a ColorModel object suitable for the conﬁguration and the speci-
ﬁed level of transparency.
createCompatibleImage() cr eates an off-scr een BufferedImage object with the speciﬁed size
and transparency that is compatible with the device color model. However, that most
applications create off-scr een images using a higher-level method, such as the createIm-
age() method of Component.
See also GraphicsDevice and GraphicsEnvironment.
public abstract class GraphicsConﬁguration {
// Protected Constructors
protected GraphicsConﬁguration();
// Property Accessor Methods (by property name)
public abstract java.awt.image.ColorModel getColorModel();
public abstract java.awt.image.ColorModel getColorModel(int transparency);
public abstract java.awt.geom.AfﬁneTransform getDefaultTransfor m();
public abstract GraphicsDevice getDevice();
public abstract java.awt.geom.AfﬁneTransform getNor malizingTransfor m();
// Public Instance Methods
public abstract java.awt.image.BufferedImage createCompatibleImage(int width, int height);
public abstract java.awt.image.BufferedImage createCompatibleImage(int width, int height, int transparency);
}
Passed To: Canvas.Canvas(), GraphicsConfigTemplate.{getBestConfiguration(), isGraphicsConfigSupported()}
Retur ned By: Graphics2D.getDeviceConfiguration(), GraphicsConfigTemplate.getBestConfiguration(),
GraphicsDevice.{getBestConfiguration(), getConfigurations(), getDefaultConfiguration()}
GraphicsDevice
Ja va 1.2
java.awt
The GraphicsDevice class repr esents a device capable of displaying graphics, such as a
computer monitor, a printer, or an off-scr een image.
A GraphicsDevice object stores the type of the device (getType()) and an identifying string
(getIDString()). More importantly, it contains a list of possible conﬁgurations of the
device. For example, a screen may be conﬁgured at differ ent resolutions and color
depths. This conﬁguration information is stored by the GraphicsDevice as GraphicsConﬁgura-
tion objects.
GraphicsDevice does not have a public constructor. Instances that repr esent scr een
devices can be obtained by calling the getDefaultScreenDevice() method of GraphicsEnviron-
ment. Mor e generally, the GraphicsDevice used by any Graphics2D object can be obtained
by calling getDeviceConﬁguration() on that object to obtain a GraphicsConﬁguration, and then
calling getDevice() on that object to get its GraphicsDevice.
java.awt
java.awt.GraphicsDevice
Chapter 9 – The java.awt Package
197

public abstract class GraphicsDevice {
// Protected Constructors
protected GraphicsDevice();
// Public Constants
=2
public static ﬁnal int TYPE_IMAGE_BUFFER;
=1
public static ﬁnal int TYPE_PRINTER;
=0
public static ﬁnal int TYPE_RASTER_SCREEN;
// Property Accessor Methods (by property name)
public abstract GraphicsConﬁguration[ ] getConﬁgurations();
public abstract GraphicsConﬁguration getDefaultConﬁguration();
public abstract String getIDstring();
public abstract int getType();
// Public Instance Methods
public GraphicsConﬁguration getBestConﬁguration(GraphicsConﬁgTemplate gct);
}
Retur ned By: GraphicsConfiguration.getDevice(), GraphicsEnvironment.{getDefaultScreenDevice(),
getScreenDevices()}
GraphicsEnvironment
Ja va 1.2
java.awt
This class describes a Java 2D graphics environment. This class does not have a public
constructor; use getLocalGraphicsEnvironment() to obtain the GraphicsEnvironment object that
repr esents the environment available to the Java VM.
A graphics environment consists of a list of available screens and a list of available
fonts. The screens are repr esented by GraphicsDevice objects. Use getDefaultScreenDevice()
to obtain information about the default screen. Although the GraphicsDevice class can
also describe printers and off-scr een images, the methods of GraphicsEnvironment retur n
only screen devices. Therefor e, it is not possible to use the GraphicsEnvironment class to
query the available printers.
getAllFonts() retur ns a list of all fonts available on the system. Use caution when calling
this method, however, because on some systems it can take a long time to enumerate
all installed fonts. Note that the fonts retur ned by this method all have a size of 1 unit;
a font must be scaled to the desired size by calling deriveFont() on the Font. When possi-
ble, it is usually better to call getAvailableFontFamilyNames() to list available font families,
then create only the individual Font objects desired.
See also GraphicsDevice and GraphicsConﬁguration.
public abstract class GraphicsEnvironment {
// Protected Constructors
protected GraphicsEnvironment();
// Public Class Methods
public static GraphicsEnvironment getLocalGraphicsEnvironment();
// Property Accessor Methods (by property name)
public abstract Font[ ] getAllFonts();
public abstract String[ ] getAvailableFontFamilyNames();
public abstract String[ ] getAvailableFontFamilyNames(java.util.Locale l);
public abstract GraphicsDevice getDefaultScreenDevice();
public abstract GraphicsDevice[ ] getScreenDevices();
// Public Instance Methods
public abstract Graphics2D createGraphics(java.awt.image.BufferedImage img);
}
Retur ned By: GraphicsEnvironment.getLocalGraphicsEnvironment()
java.awt.GraphicsDevice
198 Chapter 9 – The java.awt Package

GridBagConstraints
Ja va 1.0
java.awt
cloneable serializable PJ1.1
This class encapsulates the instance variables that tell a GridBagLayout how to position a
given Component within its Container:
gridx, gridy
The grid position of the component. The RELATIVE constant speciﬁes a position to
the right of or below the previous component.
gridwidth, gridheight
The height and width of the component in grid cells. The constant REMAINDER
speciﬁes that the component is the last one and should get all remaining cells.
ﬁll
The dimensions of a component that should grow when the space available for it
is larger than its default size. Legal values are the constants NONE, BO TH, HORIZONTAL,
and VERTICAL.
ipadx, ipady
Inter nal padding to add on each side of the component in each dimension. This
padding increases the size of the component beyond its default minimum size.
insets
An Insets object that speciﬁes margins to appear on all sides of the component.
anchor
How the component should be displayed within its grid cells when it is smaller
than those cells. The CENTER constant and the compass-point constants are legal
values.
weightx, weighty
How extra space in the container should be distributed among its components in
the X and Y dimensions. Larger weights specify that a component should receive a
pr oportionally larger amount of extra space. A 0 weight indicates that the compo-
nent should not receive any extra space. These weights specify the resizing behav-
ior of the component and its container.
See also GridBagLayout.
public class GridBagConstraints implements Cloneable, Serializable {
// Public Constructors
public GridBagConstraints();
1.2 public GridBagConstraints(int gridx, int gridy, int gridwidth, int gridheight, double weightx, double weighty,
int anchor, int ﬁll, Insets insets, int ipadx, int ipady);
// Public Constants
=1
public static ﬁnal int BOTH;
=10
public static ﬁnal int CENTER;
=13
public static ﬁnal int EAST;
=2
public static ﬁnal int HORIZONTAL;
=0
public static ﬁnal int NONE;
=11
public static ﬁnal int NORTH;
=12
public static ﬁnal int NORTHEAST;
=18
public static ﬁnal int NORTHWEST;
=-1
public static ﬁnal int RELATIVE;
=0
public static ﬁnal int REMAINDER;
=15
public static ﬁnal int SOUTH;
=14
public static ﬁnal int SOUTHEAST;
=16
public static ﬁnal int SOUTHWEST;
=3
public static ﬁnal int VERTICAL;
java.awt
java.awt.Gr idBagConstraints
Chapter 9 – The java.awt Package
199

=17
public static ﬁnal int WEST;
// Public Methods Overriding Object
public Object clone();
// Public Instance Fields
public int anchor;
public int ﬁll;
public int gridheight;
public int gridwidth;
public int gridx;
public int gridy;
public Insets insets;
public int ipadx;
public int ipady;
public double weightx;
public double weighty;
}
Hierar chy: Object→GridBagConstraints(Cloneable, Serializable)
Passed To: GridBagLayout.{AdjustForGravity(), setConstraints()}
Retur ned By: GridBagLayout.{getConstraints(), lookupConstraints()}
Type Of: GridBagLayout.defaultConstraints
GridBagLayout
Ja va 1.0
java.awt
serializable layout manager PJ1.1
The most complicated and most powerful LayoutManager in the java.awt package. Grid-
BagLayout divides a container into a grid of rows and columns (that need not have the
same width and height) and places the components into this grid, adjusting the size of
the grid cells as necessary to ensure that components do not overlap. Each component
contr ols how it is positioned within this grid by specifying a number of variables (or
constraints) in a GridBagConstraints object. Do not confuse this class with the much sim-
pler GridLayout, which arranges components in a grid of equally sized cells.
Use setConstraints() to specify a GridBagConstraints object for each of the components in
the container. Or, as of Java 1.1, specify the GridBagConstraints object when adding the
component to the container with add(). The variables in this object specify the position
of the component in the grid and the number of horizontal and vertical grid cells that
the component occupies and also control other important aspects of component layout.
See GridBagConstraints for more infor mation on these constraint variables. setConstraints()
makes a copy of the constraints object, so you may reuse a single object in your code.
Applications should never call the LayoutManager methods of this class directly; the Con-
tainer for which the GridBagLayout is register ed does this.
public class GridBagLayout implements LayoutManager2, Serializable {
// Public Constructors
public GridBagLayout();
// Protected Constants
=512
protected static ﬁnal int MAXGRIDSIZE;
=1
protected static ﬁnal int MINSIZE;
=2
protected static ﬁnal int PREFERREDSIZE;
// Property Accessor Methods (by property name)
public int[ ][ ] getLayoutDimensions();
public Point getLayoutOrigin();
public double[ ][ ] getLayoutWeights();
java.awt.Gr idBagConstraints
200 Chapter 9 – The java.awt Package

// Public Instance Methods
public GridBagConstraints getConstraints(Component comp);
public Point location(int x, int y);
public void setConstraints(Component comp, GridBagConstraints constraints);
// Methods Implementing LayoutManager
empty
public void addLayoutComponent(String name, Component comp);
public void layoutContainer(Container parent);
public Dimension minimumLayoutSize(Container parent);
public Dimension prefer redLayoutSize(Container parent);
public void removeLayoutComponent(Component comp);
// Methods Implementing LayoutManager2
1.1 public void addLayoutComponent(Component comp, Object constraints);
1.1 public ﬂoat getLayoutAlignmentX(Container parent);
1.1 public ﬂoat getLayoutAlignmentY(Container parent);
empty
1.1 public void invalidateLayout(Container target);
1.1 public Dimension maximumLayoutSize(Container target);
// Public Methods Overriding Object
public String toString();
// Protected Instance Methods
protected void AdjustForGravity(GridBagConstraints constraints, Rectangle r);
protected void Ar rangeGrid(Container parent);
protected GridBagLayoutInfo GetLayoutInfo(Container parent, int sizeﬂag);
protected Dimension GetMinSize(Container parent, GridBagLayoutInfo info);
protected GridBagConstraints lookupConstraints(Component comp);
// Public Instance Fields
public double[ ] columnWeights;
public int[ ] columnW idths;
public int[ ] rowHeights;
public double[ ] rowWeights;
// Protected Instance Fields
protected java.util.Hashtable comptable;
protected GridBagConstraints defaultConstraints;
protected GridBagLayoutInfo layoutInfo;
}
Hierar chy: Object→GridBagLayout(LayoutManager2(LayoutManager), Serializable)
GridLayout
Ja va 1.0
java.awt
serializable layout manager PJ1.1
A LayoutManager that divides a Container into a speciﬁed number of equally sized rows
and columns and arranges the components in those rows and columns, left to right and
top to bottom. If either the number of rows or the number of columns is set to 0, its
value is computed from the other dimension and the total number of components. Do
not confuse this class with the more ﬂexible and complicated GridBagLayout.
Applications should never call the LayoutManager methods of this class directly; the Con-
tainer for which the GridLayout is register ed does this.
public class GridLayout implements LayoutManager, Serializable {
// Public Constructors
1.1 public GridLayout();
public GridLayout(int rows, int cols);
public GridLayout(int rows, int cols, int hgap, int vgap);
// Property Accessor Methods (by property name)
default:0
1.1 public int getColumns();
1.1 public void setColumns(int cols);
default:0
1.1 public int getHgap();
java.awt
java.awt.Gr idLayout
Chapter 9 – The java.awt Package
201

1.1 public void setHgap(int hgap);
default:1
1.1 public int getRows();
1.1 public void setRows(int rows);
default:0
1.1 public int getVgap();
1.1 public void setVgap(int vgap);
// Methods Implementing LayoutManager
empty
public void addLayoutComponent(String name, Component comp);
public void layoutContainer(Container parent);
public Dimension minimumLayoutSize(Container parent);
public Dimension prefer redLayoutSize(Container parent);
empty
public void removeLayoutComponent(Component comp);
// Public Methods Overriding Object
public String toString();
}
Hierar chy: Object→GridLayout(LayoutManager, Serializable)
IllegalComponentStateException
Ja va 1.1
java.awt
serializable unchecked PJ1.1
Signals that an AWT component is not in the appropriate state for some requested oper-
ation (e.g., it hasn’t been added to a container yet or is currently hidden).
public class IllegalComponentStateException extends java.lang.IllegalStateException {
// Public Constructors
public IllegalComponentStateException();
public IllegalComponentStateException(String s);
}
Hierar chy: Object→Throwable(Serializable)→Exception→RuntimeException→
java.lang .IllegalStateException→IllegalComponentStateException
Thrown By: AccessibleContext.getLocale()
Image
Ja va 1.0
java.awt
PJ1.1
This abstract class repr esents a displayable image in a platform-independent way. An
Image object cannot be instantiated directly through a constructor; it must be obtained
thr ough a method like the getImage() method of Applet or the createImage() method of
Component. getSource() method retur ns the ImageProducer object that produces the image
data. getGraphics() retur ns a Graphics object that can be used for drawing into off-scr een
images (but not images that are downloaded or generated by an ImageProducer).
public abstract class Image {
// Public Constructors
public Image();
// Public Constants
=16
1.1 public static ﬁnal int SCALE_AREA_AVERAGING;
=1
1.1 public static ﬁnal int SCALE_DEFAULT;
=2
1.1 public static ﬁnal int SCALE_FAST;
=8
1.1 public static ﬁnal int SCALE_REPLICATE;
=4
1.1 public static ﬁnal int SCALE_SMOOTH;
public static ﬁnal Object UndeﬁnedProper ty;
// Property Accessor Methods (by property name)
public abstract Graphics getGraphics();
public abstract java.awt.image.ImageProducer getSource();
java.awt.Gr idLayout
202 Chapter 9 – The java.awt Package

// Public Instance Methods
public abstract void ﬂush();
public abstract int getHeight(java.awt.image.ImageObserver obser ver);
public abstract Object getProper ty(String name, java.awt.image.ImageObserver obser ver);
1.1 public Image getScaledInstance(int width, int height, int hints);
public abstract int getW idth(java.awt.image.ImageObserver obser ver);
}
Subc lasses: java.awt.image.BufferedImage
Passed To: Too many methods to list.
Retur ned By: Too many methods to list.
Type Of: javax.swing .JViewpor t.backingStoreImage
Insets
Ja va 1.0
java.awt
cloneable serializable PJ1.1
This class holds four values that repr esent the top, left, bottom, and right margins, in
pixels, of a Container or other Component. An object of this type can be speciﬁed in a
GridBagConstraints layout object and is retur ned by Container.insets(), which queries the
margins of a container.
public class Insets implements Cloneable, Serializable {
// Public Constructors
public Insets(int top, int left, int bottom, int right);
// Public Methods Overriding Object
public Object clone();
1.1 public boolean equals(Object obj);
public String toString();
// Public Instance Fields
public int bottom;
public int left;
public int right;
public int top;
}
Hierar chy: Object→Insets(Cloneable, Serializable)
Subc lasses: javax.swing .plaf.InsetsUIResource
Passed To: Too many methods to list.
Retur ned By: Too many methods to list.
Type Of: GridBagConstraints.insets
ItemSelectable
Ja va 1.1
java.awt
PJ1.1
This interface abstracts the functionality of an AWT component that presents one or
mor e items to the user and allows the user to select none, one, or several of them. It is
implemented by several components in the AWT and Swing.
getSelectedObjects() retur ns an array of selected objects or null, if none are selected.
addItemListener() and removeItemListener() ar e standard methods for adding and removing
ItemListener objects to be notiﬁed when an item is selected.
public .ne 10 abstract interface ItemSelectable {
// Event Registration Methods (by event name)
public abstract void addItemListener(java.awt.e vent.ItemListener l);
java.awt
java.awt.ItemSelectable
Chapter 9 – The java.awt Package
203

public abstract void removeItemListener(java.awt.e vent.ItemListener l);
// Public Instance Methods
public abstract Object[ ] getSelectedObjects();
}
Implementations: Checkbox, CheckboxMenuItem, Choice, java.awt.List, javax.swing .AbstractButton,
javax.swing .ButtonModel, javax.swing .JComboBox
Passed To: java.awt.event.ItemEvent.ItemEvent()
Retur ned By: java.awt.event.ItemEvent.getItemSelectable()
Label
Ja va 1.0
java.awt
serializable AWT component PJ1.1
This class is a Component that displays a single speciﬁed line of read-only text. The con-
stant values specify the text alignment within the component and can be speciﬁed in a
call to the constructor or used with setAlignment().
public class Label extends Component {
// Public Constructors
public Label();
public Label(String text);
public Label(String text, int alignment);
// Public Constants
=1
public static ﬁnal int CENTER;
=0
public static ﬁnal int LEFT;
=2
public static ﬁnal int RIGHT;
// Property Accessor Methods (by property name)
default:0
public int getAlignment();
synchronized
public void setAlignment(int alignment);
default:""
public String getText();
public void setText(String text);
// Public Methods Overriding Component
public void addNotify();
// Protected Methods Overriding Component
protected String paramString();
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, MenuContainer, Serializable)→Label
Passed To: Toolkit.createLabel()
LayoutManager
Ja va 1.0
java.awt
layout manager PJ1.1
This interface deﬁnes the methods necessary for a class to be able to arrange Component
objects within a Container object. Most programs use one of the existing classes that
implement this interface: BorderLayout, CardLayout, FlowLayout, GridBagConstraints, GridBagLay-
out, or GridLayout.
To deﬁne a new class that lays out components, you must implement each of the meth-
ods deﬁned by this interface. addLayoutComponent() is called when a component is added
to the container. removeLayoutComponent() is called when a component is removed. layout-
Container() should perfor m the actual positioning of components by setting the size and
position of each component in the speciﬁed container. minimumLayoutSize() should retur n
the minimum container width and height that the LayoutManager needs in order to lay
out its components. prefer redLayoutSize() should retur n the optimal container width and
height for the LayoutManager to lay out its components.
java.awt.ItemSelectable
204 Chapter 9 – The java.awt Package

As of Java 1.1, layout managers should implement the LayoutManager2 inter face, which is
an extension of this one. A Java applet or application never directly calls any of these
LayoutManager methods — the Container object for which the LayoutManager is register ed
does that.
public abstract interface LayoutManager {
// Public Instance Methods
public abstract void addLayoutComponent(String name, Component comp);
public abstract void layoutContainer(Container parent);
public abstract Dimension minimumLayoutSize(Container parent);
public abstract Dimension prefer redLayoutSize(Container parent);
public abstract void removeLayoutComponent(Component comp);
}
Implementations: FlowLayout, GridLayout, LayoutManager2, javax.swing .ScrollPaneLayout,
javax.swing .Viewpor tLayout
Passed To: Container.setLayout(), Panel.Panel(), ScrollPane.setLayout(), javax.swing .Box.setLayout(),
javax.swing .JApplet.setLayout(), javax.swing .JDialog.setLayout(), javax.swing .JFrame.setLayout(),
javax.swing .JInternalFrame.setLayout(), javax.swing .JPanel.JPanel(), javax.swing .JScrollPane.setLayout(),
javax.swing .JWindow.setLayout()
Retur ned By: Container.getLayout(), javax.swing .JRootPane.createRootLayout(),
javax.swing .JViewpor t.createLayoutManager()
LayoutManager2
Ja va 1.1
java.awt
layout manager PJ1.1
This interface is an extension of the LayoutManager inter face. It deﬁnes additional layout
management methods for layout managers that perfor m constraint-based layout. Grid-
BagLayout is an example of a constraint-based layout manager—each component added
to the layout is associated with a GridBagConstraints object that speciﬁes the constraints
on how the component is to be laid out.
Java programs do not directly invoke the methods of this interface — they ar e used by
the Container object for which the layout manager is register ed.
public abstract interface LayoutManager2 extends LayoutManager {
// Public Instance Methods
public abstract void addLayoutComponent(Component comp, Object constraints);
public abstract ﬂoat getLayoutAlignmentX(Container target);
public abstract ﬂoat getLayoutAlignmentY(Container target);
public abstract void invalidateLayout(Container target);
public abstract Dimension maximumLayoutSize(Container target);
}
Hierar chy: (LayoutManager2(LayoutManager))
Implementations: BorderLayout, CardLayout, GridBagLayout, javax.swing .BoxLayout,
javax.swing .JRootPane.RootLayout, javax.swing .Over layLayout
List
Ja va 1.0
java.awt
serializable AWT component PJ1.1
This class is a Component that graphically displays a list of strings. The list is scrollable if
necessary. The constructor takes optional arguments that specify the number of visible
rows in the list and whether selection of more than one item is allowed. The various
java.awt
java.awt.List
Chapter 9 – The java.awt Package
205

instance methods allow strings to be added and removed from the List and allow the
selected item or items to be queried.
public class List extends Component implements ItemSelectable {
// Public Constructors
public List();
1.1 public List(int rows);
public List(int rows, boolean multipleMode);
// Event Registration Methods (by event name)
synchronized
1.1 public void addActionListener(java.awt.e vent.ActionListener l);
synchronized
1.1 public void removeActionListener(java.awt.e vent.ActionListener l);
Implements:ItemSelectable synchronized
1.1 public void addItemListener(java.awt.e vent.ItemListener l);
Implements:ItemSelectable synchronized
1.1 public void removeItemListener(java.awt.e vent.ItemListener l);
// Property Accessor Methods (by property name)
default:0
1.1 public int getItemCount();
synchronized
1.1 public String[ ] getItems();
Overrides:Component
1.1 public Dimension getMinimumSize();
1.1 public Dimension getMinimumSize(int rows);
default:false
1.1 public boolean isMultipleMode();
1.1 public void setMultipleMode(boolean b);
Overrides:Component
1.1 public Dimension getPrefer redSize();
1.1 public Dimension getPrefer redSize(int rows);
default:4
public int getRows();
synchronized default:-1
public int getSelectedIndex();
synchronized
public int[ ] getSelectedIndexes();
synchronized default:null
public String getSelectedItem();
synchronized
public String[ ] getSelectedItems();
Implements:ItemSelectable
1.1 public Object[ ] getSelectedObjects();
default:-1
public int getV isibleIndex();
// Public Instance Methods
1.1 public void add(String item);
1.1 public void add(String item, int index);
synchronized
public void deselect(int index);
public String getItem(int index);
1.1 public boolean isIndexSelected(int index);
synchronized
public void makeV isible(int index);
synchronized
1.1 public void remove(String item);
1.1 public void remove(int position);
1.1 public void removeAll();
synchronized
public void replaceItem(String newValue, int index);
public void select(int index);
// Methods Implementing ItemSelectable
synchronized
1.1 public void addItemListener(java.awt.e vent.ItemListener l);
1.1 public Object[ ] getSelectedObjects();
synchronized
1.1 public void removeItemListener(java.awt.e vent.ItemListener l);
// Public Methods Overriding Component
public void addNotify();
public void removeNotify();
// Protected Methods Overriding Component
protected String paramString();
1.1 protected void processEvent(AWTEvent e);
// Protected Instance Methods
1.1 protected void processActionEvent(java.awt.e vent.ActionEvent e);
1.1 protected void processItemEvent(java.awt.e vent.ItemEvent e);
// Deprecated Public Methods
# public void addItem(String item);
synchronized
# public void addItem(String item, int index);
# public boolean allowsMultipleSelections();
synchronized
# public void clear();
java.awt.List
206 Chapter 9 – The java.awt Package

# public int countItems();
# public void delItem(int position);
synchronized
# public void delItems(int star t, int end);
# public boolean isSelected(int index);
Overrides:Component
# public Dimension minimumSize();
# public Dimension minimumSize(int rows);
Overrides:Component
# public Dimension prefer redSize();
# public Dimension prefer redSize(int rows);
synchronized
# public void setMultipleSelections(boolean b);
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, MenuContainer, Serializable)→
java.awt.List(ItemSelectable)
Passed To: Toolkit.createList()
MediaTracker
Ja va 1.0
java.awt
serializable PJ1.1
This class provides a convenient way to asynchronously load and keep track of the sta-
tus of any number of Image objects. You can use it to load one or more images and
then wait until those images have been completely loaded and are ready to be used.
The addImage() method registers an image to be loaded and tracked, assigning it a spec-
iﬁed identiﬁer value. waitForID() loads all the images that have been assigned the speci-
ﬁed identiﬁer and retur ns when they have all ﬁnished loading or it receives an error.
isEr rorAny() and isEr rorID() check whether any errors have occurred while loading images.
statusAll() and statusID() retur n the status of all images and of all images with the speci-
ﬁed identiﬁer, respectively. The retur n value of each of these methods is one of the
deﬁned constants.
public class MediaTracker implements Serializable {
// Public Constructors
public MediaTracker(Component comp);
// Public Constants
=2
public static ﬁnal int ABORTED;
=8
public static ﬁnal int COMPLETE;
=4
public static ﬁnal int ERRORED;
=1
public static ﬁnal int LOADING;
// Public Instance Methods
public void addImage(Image image, int id);
synchronized
public void addImage(Image image, int id, int w, int h);
public boolean checkAll();
public boolean checkAll(boolean load);
public boolean checkID(int id);
public boolean checkID(int id, boolean load);
synchronized
public Object[ ] getEr rorsAny();
synchronized
public Object[ ] getEr rorsID(int id);
synchronized
public boolean isEr rorAny();
synchronized
public boolean isEr rorID(int id);
synchronized
1.1 public void removeImage(Image image);
synchronized
1.1 public void removeImage(Image image, int id);
synchronized
1.1 public void removeImage(Image image, int id, int width, int height);
public int statusAll(boolean load);
public int statusID(int id, boolean load);
public void waitForAll() throws InterruptedException;
synchronized
public boolean waitForAll(long ms) throws InterruptedException;
public void waitForID(int id) throws InterruptedException;
java.awt
java.awt.MediaTracker
Chapter 9 – The java.awt Package
207

synchronized
public boolean waitForID(int id, long ms) throws InterruptedException;
}
Hierar chy: Object→MediaTracker(Serializable)
Type Of: javax.swing .ImageIcon.tracker
Menu
Ja va 1.0
java.awt
serializable AWT component PJ1.1(opt)
This class repr esents a pulldown menu pane that appears within a MenuBar. Each Menu
has a label that appears in the MenuBar and can optionally be a tear-of f menu. The add()
and addSeparator() methods add individual items to a Menu.
public class Menu extends MenuItem implements MenuContainer {
// Public Constructors
1.1 public Menu();
public Menu(String label);
public Menu(String label, boolean tearOff);
// Property Accessor Methods (by property name)
default:0
1.1 public int getItemCount();
default:false
public boolean isTearOff();
// Public Instance Methods
public void add(String label);
public MenuItem add(MenuItem mi);
public void addSeparator();
public MenuItem getItem(int index);
1.1 public void inser t(String label, int index);
1.1 public void inser t(MenuItem menuitem, int index);
1.1 public void inser tSeparator(int index);
public void remove(int index);
1.1 public void removeAll();
// Methods Implementing MenuContainer
public void remove(MenuComponent item);
// Public Methods Overriding MenuItem
public void addNotify();
1.1 public String paramString();
// Public Methods Overriding MenuComponent
public void removeNotify();
// Deprecated Public Methods
# public int countItems();
}
Hierar chy: Object→MenuComponent(Serializable)→MenuItem→Menu(MenuContainer)
Subc lasses: PopupMenu
Passed To: MenuBar.{add(), setHelpMenu()}, Toolkit.createMenu(),
java.awt.peer.MenuBarPeer.{addHelpMenu(), addMenu()}
Retur ned By: MenuBar.{add(), getHelpMenu(), getMenu()}
MenuBar
Ja va 1.0
java.awt
serializable AWT component PJ1.1(opt)
This class repr esents a menu bar. add() adds Menu objects to the menu bar, and setHelp-
Menu() adds a Help menu in a reserved location of the menu bar. A MenuBar object may
be displayed within a Frame by passing it to the setMenuBar() of the Frame.
java.awt.MediaTracker
208 Chapter 9 – The java.awt Package

public class MenuBar extends MenuComponent implements MenuContainer {
// Public Constructors
public MenuBar();
// Property Accessor Methods (by property name)
default:null
public Menu getHelpMenu();
public void setHelpMenu(Menu m);
default:0
1.1 public int getMenuCount();
// Public Instance Methods
public Menu add(Menu m);
public void addNotify();
1.1 public void deleteShor tcut(MenuShor tcut s);
public Menu getMenu(int i);
1.1 public MenuItem getShor tcutMenuItem(MenuShor tcut s);
public void remove(int index);
synchronized
1.1 public java.util.Enumeration shor tcuts();
// Methods Implementing MenuContainer
public void remove(MenuComponent m);
// Public Methods Overriding MenuComponent
public void removeNotify();
// Deprecated Public Methods
# public int countMenus();
}
Hierar chy: Object→MenuComponent(Serializable)→MenuBar(MenuContainer)
Passed To: Frame.setMenuBar(), Toolkit.createMenuBar(), java.awt.peer.FramePeer.setMenuBar()
Retur ned By: Frame.getMenuBar()
MenuComponent
Ja va 1.0
java.awt
serializable AWT component PJ1.1
This class is the superclass of all menu-related classes: You never need to instantiate a
MenuComponent dir ectly. setFont() speciﬁes the font to be used for all text within the
menu component.
public abstract class MenuComponent implements Serializable {
// Public Constructors
public MenuComponent();
// Property Accessor Methods (by property name)
public Font getFont();
public void setFont(Font f);
1.1 public String getName();
1.1 public void setName(String name);
public MenuContainer getParent();
// Public Instance Methods
1.1 public ﬁnal void dispatchEvent(AWTEvent e);
public void removeNotify();
// Public Methods Overriding Object
public String toString();
// Protected Instance Methods
1.1 protected ﬁnal Object getTreeLock();
protected String paramString();
empty
1.1 protected void processEvent(AWTEvent e);
// Deprecated Public Methods
# public java.awt.peer.MenuComponentPeer getPeer();
# public boolean postEvent(Event evt);
}
java.awt
java.awt.MenuComponent
Chapter 9 – The java.awt Package
209

Hierar chy: Object→MenuComponent(Serializable)
Subc lasses: MenuBar, MenuItem
Passed To: Component.remove(), Frame.remove(), Menu.remove(), MenuBar.remove(),
MenuContainer.remove()
MenuContainer
Ja va 1.0
java.awt
PJ1.1
This interface deﬁnes the methods necessary for MenuContainer types, such as Menu,
Frame, and MenuBar objects. Unless you implement new menulike components, you
never need to use it.
public abstract interface MenuContainer {
// Public Instance Methods
public abstract Font getFont();
public abstract void remove(MenuComponent comp);
// Deprecated Public Methods
# public abstract boolean postEvent(Event evt);
}
Implementations: Component, Frame, Menu, MenuBar
Retur ned By: MenuComponent.getParent()
MenuItem
Ja va 1.0
java.awt
serializable AWT component PJ1.1
This class encapsulates a menu item with a speciﬁed textual label. A MenuItem can be
added to a menu pane with the add() method of Menu. The disable() method makes an
item nonselectable; you might use it to gray out a menu item when the command it
repr esents is not valid in the current context. The enable() method makes an item
selectable again. In Java 1.1, use setActionCommand() to specify an identifying string that
is included in ActionEvent events generated by the menu item.
public class MenuItem extends MenuComponent {
// Public Constructors
1.1 public MenuItem();
public MenuItem(String label);
1.1 public MenuItem(String label, MenuShor tcut s);
// Event Registration Methods (by event name)
synchronized
1.1 public void addActionListener(java.awt.e vent.ActionListener l);
synchronized
1.1 public void removeActionListener(java.awt.e vent.ActionListener l);
// Property Accessor Methods (by property name)
default:""
1.1 public String getActionCommand();
1.1 public void setActionCommand(String command);
default:true
public boolean isEnabled();
synchronized
1.1 public void setEnabled(boolean b);
default:""
public String getLabel();
synchronized
public void setLabel(String label);
default:null
1.1 public MenuShortcut getShor tcut();
1.1 public void setShor tcut(MenuShor tcut s);
// Public Instance Methods
public void addNotify();
1.1 public void deleteShor tcut();
// Public Methods Overriding MenuComponent
public String paramString();
// Protected Methods Overriding MenuComponent
1.1 protected void processEvent(AWTEvent e);
java.awt.MenuComponent
210 Chapter 9 – The java.awt Package

// Protected Instance Methods
1.1 protected ﬁnal void disableEvents(long eventsToDisable);
1.1 protected ﬁnal void enableEvents(long eventsToEnable);
1.1 protected void processActionEvent(java.awt.e vent.ActionEvent e);
// Deprecated Public Methods
synchronized
# public void disable();
synchronized
# public void enable();
# public void enable(boolean b);
}
Hierar chy: Object→MenuComponent(Serializable)→MenuItem
Subc lasses: CheckboxMenuItem, Menu
Passed To: Menu.{add(), insert()}, Toolkit.createMenuItem(), java.awt.peer.MenuPeer.addItem()
Retur ned By: Menu.{add(), getItem()}, MenuBar.getShor tcutMenuItem()
MenuShor tcut
Ja va 1.1
java.awt
serializable PJ1.1(opt)
This class repr esents a keystr oke used to select a MenuItem without actually pulling
down the menu. A MenuShor tcut object can be speciﬁed for a MenuItem when the Menu-
Item is created or by calling the item’s setShor tcut() method. The keystroke sequence for
the menu shortcut automatically appears in the label for the menu item, so you do not
need to add this information yourself.
When you create a MenuShor tcut, you specify the keycode of the shortcut—this is one of
the VK_ constants deﬁned by java.awt.event.KeyEvent and is not always the same as a cor-
responding character code. You may optionally specify a boolean value that, if tr ue, indi-
cates that the MenuShor tcut requir es the Shift key to be held down.
Note that menu shortcuts are trigger ed in a platform-dependent way. When you create
a shortcut, you specify only the keycode and an optional Shift modiﬁer. The shortcut is
not triggered, however, unless an additional modiﬁer key is held down. On Windows
platfor ms, for example, the Ctrl key is used for menu shortcuts. You can query the plat-
for m-speciﬁc menu shortcut key with the getMenuShor tcutKeyMask() method of Toolkit.
public class MenuShor tcut implements Serializable {
// Public Constructors
public MenuShor tcut(int key);
public MenuShor tcut(int key, boolean useShiftModiﬁer);
// Public Instance Methods
public boolean equals(MenuShor tcut s);
public int getKey();
public boolean usesShiftModiﬁer();
// Public Methods Overriding Object
1.2 public boolean equals(Object obj);
1.2 public int hashCode();
public String toString();
// Protected Instance Methods
protected String paramString();
}
Hierar chy: Object→MenuShor tcut(Serializable)
Passed To: MenuBar.{deleteShor tcut(), getShor tcutMenuItem()}, MenuItem.{MenuItem(), setShortcut()},
MenuShor tcut.equals()
Retur ned By: MenuItem.getShor tcut()
java.awt
java.awt.MenuShor tcut
Chapter 9 – The java.awt Package
211

Paint
Ja va 1.2
java.awt
This interface deﬁnes a color or pattern used by Java 2D in drawing and ﬁlling opera-
tions. Color is the simplest implementation: it perfor ms drawing and ﬁlling using a solid
color. GradientPaint and TexturePaint ar e two other commonly used implementations. Most
applications can simply use these predeﬁned Paint implementations and do not need to
implement this interface themselves.
Because a single Paint object may be used by differ ent thr eads with differ ent Graphics2D
objects, the Paint object does not perfor m painting operations itself. Instead, it deﬁnes a
createContext() method that retur ns a PaintContext object that is capable of perfor ming
painting in a particular context. See PaintContext for details.
public abstract interface Paint extends Transparency {
// Public Instance Methods
public abstract PaintContext createContext(java.awt.image.ColorModel cm, Rectangle deviceBounds,
java.awt.geom.Rectangle2D userBounds,
java.awt.geom.AfﬁneTransform xform, RenderingHints hints);
}
Hierar chy: (Paint(Transparency))
Implementations: Color, GradientPaint, TexturePaint
Passed To: Graphics2D.setPaint()
Retur ned By: Graphics2D.getPaint()
PaintContext
Ja va 1.2
java.awt
This interface deﬁnes the methods that do the actual work of computing the colors to
be used in Java 2D drawing and ﬁlling operations. PaintContext is used internally by Java
2D; applications never need to call any of its methods. Only applications that imple-
ment custom Paint objects need to implement this interface.
A Graphics2D object creates a PaintContext object by calling the createContext() method of
its Paint object. The getRaster() method of the PaintContext is called to perfor m the actual
painting; this method must retur n a java.awt.image.Raster object that contains the appro-
priate colors for the speciﬁed rectangle. The Graphics2D object calls dispose() when the
PaintContext is no longer needed. The dispose() method should release any system
resources held by the PaintContext.
public abstract interface PaintContext {
// Public Instance Methods
public abstract void dispose();
public abstract java.awt.image.ColorModel getColorModel();
public abstract java.awt.image.Raster getRaster(int x, int y, int w, int h);
}
Retur ned By: Color.createContext(), GradientPaint.createContext(), Paint.createContext(),
SystemColor.createContext(), TexturePaint.createContext()
Panel
Ja va 1.0
java.awt
serializable AWT component PJ1.1
This class is a Container that is itself contained within a container. Unlike Frame and Dia-
log, Panel is a container that does not create a separate window of its own. Panel is suit-
able for holding portions of a larger interface within a parent Frame or Dialog or within
another Panel. (Because Applet is a subclass of Panel, applets are displayed in a Panel that
java.awt.Paint
212 Chapter 9 – The java.awt Package

is contained within a web browser or applet viewer.) The default LayoutManager for a
Panel is FlowLayout.
public class Panel extends Container {
// Public Constructors
public Panel();
1.1 public Panel(LayoutManager layout);
// Public Methods Overriding Container
public void addNotify();
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, MenuContainer, Serializable)→
Container→Panel
Subc lasses: java.applet.Applet
Passed To: Toolkit.createPanel()
Point
Ja va 1.0
java.awt
cloneable serializable PJ1.1
This class holds the integer X and Y coordinates of a two-dimensional point. The move()
and setLocation() methods set the coordinates, and the translate() method adds speciﬁed
values to the coordinates. Also, the x and y ﬁelds are public and may be manipulated
dir ectly.
In Java 1.0 and Java 1.1, Point is a subclass of Object. In Java 1.2, with the introduction of
Java 2D, Point has become a concrete subclass of java.awt.geom.Point2D. Contrast Point with
Point2D.Float and Point2D.Double, which use ﬂoat and double ﬁelds to repr esent the coordi-
nates of the point.
public class Point extends java.awt.geom.Point2D implements Serializable {
// Public Constructors
1.1 public Point();
1.1 public Point(Point p);
public Point(int x, int y);
// Public Instance Methods
1.1 public Point getLocation();
public void move(int x, int y);
1.1 public void setLocation(Point p);
1.1 public void setLocation(int x, int y);
public void translate(int x, int y);
// Public Methods Overriding Point2D
public boolean equals(Object obj);
default:0.0
1.2 public double getX();
default:0.0
1.2 public double getY();
1.2 public void setLocation(double x, double y);
// Public Methods Overriding Object
public String toString();
// Public Instance Fields
public int x;
public int y;
}
Hierar chy: Object→java.awt.geom.Point2D(Cloneable)→Point(Serializable)
Passed To: Too many methods to list.
Retur ned By: Too many methods to list.
Type Of: javax.swing .JViewpor t.lastPaintPosition
java.awt
java.awt.Point
Chapter 9 – The java.awt Package
213

Polygon
Ja va 1.0
java.awt
serializable shape PJ1.1
This class deﬁnes a polygon as an array of points. The points of the polygon can be
passed to the constructor or speciﬁed with addPoint(). getBoundingBox() retur ns the small-
est Rectangle that contains the polygon, and inside() tests whether a speciﬁed point is
within the Polygon. Note that the arrays of X and Y points and the number of points in
the polygon (not necessarily the same as the array size) are deﬁned as public variables.
Polygon objects are used when drawing polygons with the drawPolygon() and ﬁllPolygon()
methods of Graphics. In Java 2, Polygon has become part of the Java 2D API. It imple-
ments the Shape inter face and can be passed to the draw() and ﬁll() method of a Graph-
ics2D object.
public class Polygon implements Serializable, Shape {
// Public Constructors
public Polygon();
public Polygon(int[ ] xpoints, int[ ] ypoints, int npoints);
// Public Instance Methods
public void addPoint(int x, int y);
1.1 public boolean contains(Point p);
1.1 public boolean contains(int x, int y);
1.1 public void translate(int deltaX, int deltaY);
// Methods Implementing Shape
1.2 public boolean contains(java.awt.geom.Rectangle2D r);
1.2 public boolean contains(java.awt.geom.Point2D p);
1.2 public boolean contains(double x, double y);
1.2 public boolean contains(double x, double y, double w, double h);
1.1 public Rectangle getBounds();
default:Rectangle2D.Float
1.2 public java.awt.geom.Rectangle2D getBounds2D();
1.2 public java.awt.geom.PathIterator getPathIterator(java.awt.geom.AfﬁneTransform at);
1.2 public java.awt.geom.PathIterator getPathIterator(java.awt.geom.AfﬁneTransform at, double ﬂatness);
1.2 public boolean intersects(java.awt.geom.Rectangle2D r);
1.2 public boolean intersects(double x, double y, double w, double h);
// Public Instance Fields
public int npoints;
public int[ ] xpoints;
public int[ ] ypoints;
// Protected Instance Fields
protected Rectangle bounds;
// Deprecated Public Methods
# public Rectangle getBoundingBox();
# public boolean inside(int x, int y);
}
Hierar chy: Object→Polygon(Serializable, Shape)
Passed To: Graphics.{drawPolygon(), fillPolygon()}
PopupMenu
Ja va 1.1
java.awt
serializable AWT component PJ1.1(mod)
PopupMenu is a simple subclass of Menu that repr esents a popup menu rather than a
pulldown menu. You create a PopupMenu just as you would create a Menu object. The
main differ ence is that a popup menu must be popped up in response to a user event
by calling its show() method. Another differ ence is that, unlike a Menu, which can only
appear within a MenuBar or another Menu, a PopupMenu can be associated with any com-
java.awt.Polygon
214 Chapter 9 – The java.awt Package

ponent in a graphical user interface. A PopupMenu is associated with a component by
calling the add() method of the component.
Popup menus are popped up by the user in differ ent ways on differ ent platfor ms. In
order to hide this platform dependency, the MouseEvent class deﬁnes the isPopupTrigger()
method. If this method retur ns tr ue, the speciﬁed MouseEvent repr esents the platform-
speciﬁc popup menu trigger event, and you should use the show() method to display
your PopupMenu. Note that the X and Y coordinates passed to show() should be in the
coordinate system of the speciﬁed Component.
Support for nested popup menus is optional in Personal Java environments, and the
inherited add() method may throw an exception if you attempt to add a Menu child to a
PopupMenu.
public class PopupMenu extends Menu {
// Public Constructors
public PopupMenu();
public PopupMenu(String label);
// Public Instance Methods
public void show(Component origin, int x, int y);
// Public Methods Overriding Menu
public void addNotify();
}
Hierar chy: Object→MenuComponent(Serializable)→MenuItem→Menu(MenuContainer)→PopupMenu
Passed To: Component.add(), Toolkit.createPopupMenu()
PrintGraphics
Ja va 1.1
java.awt
PJ1.1
The Graphics object retur ned by the getGraphics() method of PrintJob always implements
this PrintGraphics inter face. You can use this fact to distinguish a Graphics object that
draws to the screen from one that generates hardcopy. This is a useful thing to do in a
paint() method, when you want to generate hardcopy that differs somewhat from what
is being displayed on-screen.
The getPrintJob() method deﬁned by this interface can be used to retur n the PrintJob with
which the PrintGraphics object is associated.
public abstract interface PrintGraphics {
// Public Instance Methods
public abstract PrintJob getPrintJob();
}
PrintJob
Ja va 1.1
java.awt
PJ1.1
A PrintJob object repr esents a single printing session, or job. The job may consist of one
or more individual pages.
PrintJob is abstract, so it cannot be instantiated directly. Instead, you must call the get-
PrintJob() method of the Toolkit object. Calling this method posts an appropriate print dia-
log box to request information from the user, such as which printer should be used. An
application has no control over this process, but may pass a Proper ties object in which
the dialog stores the user’s printing prefer ences. This Proper ties object can then be
reused when initiating subsequent print jobs.
Once a PrintJob object has been obtained from the Toolkit object, you call the getGraphics()
method of PrintJob to obtain a Graphics object. Any drawing done with this Graphics
object is printed, instead of displayed on-screen. The object retur ned by getGraphics()
java.awt
java.awt.Pr intJob
Chapter 9 – The java.awt Package
215

implements the PrintGraphics inter face. Do not make any assumptions about the initial
state of the Graphics object; in particular, note that you must specify a font before you
can draw any text.
When you are done drawing all the desired output on a page, call the dispose() method
of the Graphics object to force the current page to be printed. You can call getGraphics()
and dispose() repeatedly to print any number of pages requir ed by your application.
However, if the lastPageF irst() method retur ns tr ue, the user has requested that pages be
printed in reverse order. It is up to your application to implement this feature.
The getPageDimension() method retur ns the size of the page in pixels. getPageResolution()
retur ns the resolution of the page in pixels per inch. This resolution is closer to a
scr een resolution (70 to 100 pixels per inch) than a typical printer resolution (300 to
600 pixels per inch). This means that on-screen drawings can be drawn directly to the
printer without scaling. It also means, however, that you cannot take full advantage of
the extra resolution provided by printers.
When you are done with a PrintJob and have called dispose() on the Graphics object
retur ned by getGraphics(), you should call end() to terminate the job.
As of Java 1.2, the PrintJob class has been superseded by a more complete printing API
pr ovided in the java.awt.print package.
public abstract class PrintJob {
// Public Constructors
public PrintJob();
// Property Accessor Methods (by property name)
public abstract Graphics getGraphics();
public abstract Dimension getPageDimension();
public abstract int getPageResolution();
// Public Instance Methods
public abstract void end();
public abstract boolean lastPageF irst();
// Public Methods Overriding Object
public void ﬁnalize();
}
Retur ned By: PrintGraphics.getPrintJob(), Toolkit.getPrintJob()
Rectangle
Ja va 1.0
java.awt
cloneable serializable shape PJ1.1
This class deﬁnes a rectangle using four integer values: the X and Y coordinates of its
upper-left corner and its width and height. The instance methods perfor m various tests
and transformations on the rectangle. The x, y, width, and height methods are public and
may thus be manipulated directly. Rectangle is used for a variety of purposes throughout
java.awt and related packages.
In Java 1.0 and Java 1.1, Rectangle is a subclass of Object. In Java 2, with the introduction
of Java 2D, Rectangle has become a concrete subclass of java.awt.geom.Rectangle2D. Con-
trast Rectangle with Rectangle2D.Float and Rectangle2D.Double, which use ﬂoat and double
ﬁelds to repr esent the coordinates of the rectangle.
public class Rectangle extends java.awt.geom.Rectangle2D implements Serializable, Shape {
// Public Constructors
public Rectangle();
1.1 public Rectangle(Rectangle r);
public Rectangle(Dimension d);
public Rectangle(Point p);
public Rectangle(int width, int height);
java.awt.Pr intJob
216 Chapter 9 – The java.awt Package

public Rectangle(Point p, Dimension d);
public Rectangle(int x, int y, int width, int height);
// Property Accessor Methods (by property name)
Implements:Shape
1.1 public Rectangle getBounds();
1.1 public void setBounds(Rectangle r);
1.1 public void setBounds(int x, int y, int width, int height);
Implements:Shape default:Rectangle
1.2 public java.awt.geom.Rectangle2D getBounds2D();
Overrides:RectangularShape default:true
public boolean isEmpty();
Overrides:RectangularShape default:0.0
1.2 public double getHeight();
1.1 public Point getLocation();
1.1 public void setLocation(Point p);
1.1 public void setLocation(int x, int y);
1.1 public Dimension getSize();
1.1 public void setSize(Dimension d);
1.1 public void setSize(int width, int height);
Overrides:RectangularShape default:0.0
1.2 public double getW idth();
Overrides:RectangularShape default:0.0
1.2 public double getX();
Overrides:RectangularShape default:0.0
1.2 public double getY();
// Public Instance Methods
public void add(Rectangle r);
public void add(Point pt);
public void add(int newx, int newy);
1.2 public boolean contains(Rectangle r);
1.1 public boolean contains(Point p);
1.1 public boolean contains(int x, int y);
1.2 public boolean contains(int X, int Y, int W, int H);
public void grow(int h, int v);
public Rectangle intersection(Rectangle r);
public boolean intersects(Rectangle r);
public void translate(int x, int y);
public Rectangle union(Rectangle r);
// Methods Implementing Shape
1.1 public Rectangle getBounds();
default:Rectangle
1.2 public java.awt.geom.Rectangle2D getBounds2D();
// Public Methods Overriding Rectangle2D
1.2 public java.awt.geom.Rectangle2D createIntersection(java.awt.geom.Rectangle2D r);
1.2 public java.awt.geom.Rectangle2D createUnion(java.awt.geom.Rectangle2D r);
public boolean equals(Object obj);
1.2 public int outcode(double x, double y);
1.2 public void setRect(double x, double y, double width, double height);
// Public Methods Overriding Object
public String toString();
// Public Instance Fields
public int height;
public int width;
public int x;
public int y;
// Deprecated Public Methods
# public boolean inside(int x, int y);
# public void move(int x, int y);
# public void reshape(int x, int y, int width, int height);
# public void resize(int width, int height);
}
Hierar chy: Object→java.awt.geom.RectangularShape(Cloneable, Shape)→
java.awt.geom.Rectangle2D→Rectangle(Serializable, Shape)
Subc lasses: javax.swing .text.DefaultCaret
java.awt
java.awt.Rectangle
Chapter 9 – The java.awt Package
217

Passed To: Too many methods to list.
Retur ned By: Too many methods to list.
Type Of: Polygon.bounds
RenderingHints
Ja va 1.2
java.awt
cloneable collection
This class contains a set of key-to-value mappings that provide hints to Java 2D about
the speed-versus-quality trade-offs it should make. The constants that begin with KEY_
ar e the hints, while the constants that begin with VALUE_ ar e the values that may be
speciﬁed for those hints. Use put() to add a hint to the RenderingHints object. Once you
have speciﬁed all desired hints, pass the RenderingHints object to the setRenderingHints() or
addRenderingHints() method of a Graphics2D object. If you want to set only a single ren-
dering hint, you don’t need to create a RenderingHints object at all; you can simply pass a
key and value to the setRenderingHint() method of Graphics2D.
public class RenderingHints implements Cloneable, java.util.Map {
// Public Constructors
public RenderingHints(java.util.Map init);
public RenderingHints(RenderingHints.Ke y key, Object value);
// Public Constants
public static ﬁnal RenderingHints.Key KEY_ALPHA_INTERPOLATION;
public static ﬁnal RenderingHints.Key KEY_ANTIALIASING;
public static ﬁnal RenderingHints.Key KEY_COLOR_RENDERING;
public static ﬁnal RenderingHints.Key KEY_DITHERING;
public static ﬁnal RenderingHints.Key KEY_FRACTIONALMETRICS;
public static ﬁnal RenderingHints.Key KEY_INTERPOLATION;
public static ﬁnal RenderingHints.Key KEY_RENDERING;
public static ﬁnal RenderingHints.Key KEY_TEXT_ANTIALIASING;
public static ﬁnal Object VALUE_ALPHA_INTERPOLATION_DEFAULT;
public static ﬁnal Object VALUE_ALPHA_INTERPOLATION_QUALITY;
public static ﬁnal Object VALUE_ALPHA_INTERPOLATION_SPEED;
public static ﬁnal Object VALUE_ANTIALIAS_DEFAULT;
public static ﬁnal Object VALUE_ANTIALIAS_OFF;
public static ﬁnal Object VALUE_ANTIALIAS_ON;
public static ﬁnal Object VALUE_COLOR_RENDER_DEFAULT;
public static ﬁnal Object VALUE_COLOR_RENDER_QUALITY;
public static ﬁnal Object VALUE_COLOR_RENDER_SPEED;
public static ﬁnal Object VALUE_DITHER_DEFAULT;
public static ﬁnal Object VALUE_DITHER_DISABLE;
public static ﬁnal Object VALUE_DITHER_ENABLE;
public static ﬁnal Object VALUE_FRACTIONALMETRICS_DEFAULT;
public static ﬁnal Object VALUE_FRACTIONALMETRICS_OFF;
public static ﬁnal Object VALUE_FRACTIONALMETRICS_ON;
public static ﬁnal Object VALUE_INTERPOLATION_BICUBIC;
public static ﬁnal Object VALUE_INTERPOLATION_BILINEAR;
public static ﬁnal Object VALUE_INTERPOLATION_NEAREST_NEIGHBOR;
public static ﬁnal Object VALUE_RENDER_DEFAULT;
public static ﬁnal Object VALUE_RENDER_QUALITY;
public static ﬁnal Object VALUE_RENDER_SPEED;
public static ﬁnal Object VALUE_TEXT_ANTIALIAS_DEFAULT;
public static ﬁnal Object VALUE_TEXT_ANTIALIAS_OFF;
public static ﬁnal Object VALUE_TEXT_ANTIALIAS_ON;
// Inner Classes
public abstract static class Key;
// Public Instance Methods
public void add(RenderingHints hints);
java.awt.Rectangle
218 Chapter 9 – The java.awt Package

// Methods Implementing Map
public void clear();
public boolean containsKey(Object key);
public boolean containsValue(Object value);
public java.util.Set entr ySet();
public boolean equals(Object o);
public Object get(Object key);
public int hashCode();
public boolean isEmpty();
public java.util.Set keySet();
public Object put(Object key, Object value);
public void putAll(java.util.Map m);
public Object remove(Object key);
public int size();
public java.util.Collection values();
// Public Methods Overriding Object
public Object clone();
public String toString();
}
Hierar chy: Object→RenderingHints(Cloneable, java.util.Map)
Passed To: Too many methods to list.
Retur ned By: Graphics2D.getRenderingHints(), java.awt.image.AffineTransfor mOp.getRenderingHints(),
java.awt.image.BandCombineOp.getRenderingHints(), java.awt.image.BufferedImageOp.getRenderingHints(),
java.awt.image.ColorConvertOp.getRenderingHints(), java.awt.image.ConvolveOp.getRenderingHints(),
java.awt.image.LookupOp.getRenderingHints(), java.awt.image.RasterOp.getRenderingHints(),
java.awt.image.RescaleOp.getRenderingHints(), java.awt.image.renderable.RenderContext.getRenderingHints()
RenderingHints.Key
Ja va 1.2
java.awt
This class is the type of the KEY_ constants deﬁned by RenderingHints.
public abstract static class RenderingHints.Key {
// Protected Constructors
protected Key(int privatekey);
// Public Instance Methods
public abstract boolean isCompatibleValue(Object val);
// Public Methods Overriding Object
public ﬁnal boolean equals(Object o);
public ﬁnal int hashCode();
// Protected Instance Methods
protected ﬁnal int intKey();
}
Passed To: Graphics2D.{getRenderingHint(), setRenderingHint()}, RenderingHints.RenderingHints()
Type Of: RenderingHints.{KEY_ALPHA_INTERPOLATION, KEY_ANTIALIASING, KEY_COLOR_RENDERING,
KEY_DITHERING, KEY_FRACTIONALMETRICS, KEY_INTERPOLATION, KEY_RENDERING,
KEY_TEXT_ANTIALIASING}
Scrollbar
Ja va 1.0
java.awt
serializable AWT component PJ1.1(opt)
This Component repr esents a graphical scrollbar. setValue() sets the displayed value of the
scr ollbar. setValues() sets the displayed value, the page size, and the minimum and maxi-
java.awt
java.awt.Scrollbar
Chapter 9 – The java.awt Package
219

mum values. The constants HORIZONTAL and VERTICAL ar e legal values for the scrollbar
orientation.
public class Scrollbar extends Component implements Adjustable {
// Public Constructors
public Scrollbar();
public Scrollbar(int orientation);
public Scrollbar(int orientation, int value, int visible, int minimum, int maximum);
// Public Constants
=0
public static ﬁnal int HORIZONTAL;
=1
public static ﬁnal int VERTICAL;
// Event Registration Methods (by event name)
Implements:Adjustable synchronized
1.1 public void addAdjustmentListener(java.awt.e vent.AdjustmentListener l);
Implements:Adjustable synchronized
1.1 public void removeAdjustmentListener(
java.awt.e vent.AdjustmentListener l);
// Property Accessor Methods (by property name)
Implements:Adjustable default:10
1.1 public int getBlockIncrement();
Implements:Adjustable
1.1 public void setBlockIncrement(int v);
Implements:Adjustable default:100
public int getMaximum();
Implements:Adjustable
1.1 public void setMaximum(int newMaximum);
Implements:Adjustable default:0
public int getMinimum();
Implements:Adjustable
1.1 public void setMinimum(int newMinimum);
Implements:Adjustable default:1
public int getOrientation();
1.1 public void setOrientation(int orientation);
Implements:Adjustable default:1
1.1 public int getUnitIncrement();
Implements:Adjustable
1.1 public void setUnitIncrement(int v);
Implements:Adjustable default:0
public int getValue();
Implements:Adjustable
public void setValue(int newValue);
Implements:Adjustable default:10
1.1 public int getV isibleAmount();
Implements:Adjustable
1.1 public void setV isibleAmount(int newAmount);
// Public Instance Methods
synchronized
public void setValues(int value, int visible, int minimum, int maximum);
// Public Methods Overriding Component
public void addNotify();
// Protected Methods Overriding Component
protected String paramString();
1.1 protected void processEvent(AWTEvent e);
// Protected Instance Methods
1.1 protected void processAdjustmentEvent(java.awt.e vent.AdjustmentEvent e);
// Deprecated Public Methods
default:1
# public int getLineIncrement();
default:10
# public int getPageIncrement();
default:10
# public int getV isible();
synchronized
# public void setLineIncrement(int v);
synchronized
# public void setPageIncrement(int v);
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, MenuContainer, Serializable)→
Scrollbar(Adjustable)
Passed To: Toolkit.createScrollbar()
ScrollPane
Ja va 1.1
java.awt
serializable AWT component PJ1.1(mod)
This Container class creates horizontal and vertical scrollbars surrounding a viewport and
allows a single child component to be displayed and scrolled within this viewport. Typ-
ically, the child of the ScrollPane is larger than the ScrollPane itself, so scrollbars allow the
user to select the currently visible portion.
java.awt.Scrollbar
220 Chapter 9 – The java.awt Package

When you call the ScrollPane() constructor, you may optionally specify a scrollbar dis-
play policy, which should be one of the three constants deﬁned by this class. If you do
not specify a policy, ScrollPane uses the SCROLLBARS_AS_NEEDED policy. Personal Java
envir onments may provide a scrolling mechanism other than scrollbars. In this case, the
scr ollbar display policy may be ignored.
A program can programmatically scroll the child within the viewport by calling setScroll-
Position(). getHAdjustable() and getVAdjustable() retur n the horizontal and vertical Adjustable
objects that control scrolling (typically these are not actually instances of Scrollbar). You
can use these Adjustable objects to specify the unit and block increment values for the
scr ollbars. You can also directly set the Adjustable value as an alternative to calling
setScrollPosition(), but you should not set other values of an Adjustable object.
Use setSize() to set the size of the ScrollPane container. You may want to take the size of
the scrollbars into account when computing the overall container size—use getHScroll-
barHeight() and getVScrollbarW idth() to obtain these values.
ScrollPane overrides the printComponents() method of Container, so that when a ScrollPane is
printed, the entire child component, rather than only the currently visible portion, is
printed.
public class ScrollPane extends Container {
// Public Constructors
public ScrollPane();
public ScrollPane(int scrollbarDisplayPolicy);
// Public Constants
=1
public static ﬁnal int SCROLLBARS_ALWAYS;
=0
public static ﬁnal int SCROLLBARS_AS_NEEDED;
=2
public static ﬁnal int SCROLLBARS_NEVER;
// Property Accessor Methods (by property name)
public Adjustable getHAdjustable();
default:0
public int getHScrollbarHeight();
Overrides:Container
public ﬁnal void setLayout(LayoutManager mgr);
default:0
public int getScrollbarDisplayPolicy();
public Point getScrollPosition();
public void setScrollPosition(Point p);
public void setScrollPosition(int x, int y);
public Adjustable getVAdjustable();
public Dimension getV iewportSize();
default:0
public int getVScrollbarW idth();
// Public Methods Overriding Container
public void addNotify();
public void doLayout();
public String paramString();
public void printComponents(Graphics g);
// Protected Methods Overriding Container
protected ﬁnal void addImpl(Component comp, Object constraints, int index);
// Deprecated Public Methods
Overrides:Container
# public void layout();
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, MenuContainer, Serializable)→
Container→ScrollPane
Passed To: Toolkit.createScrollPane()
Shape
Ja va 1.1
java.awt
shape PJ1.1
This interface is one of the most important in all of Java 2D. It deﬁnes methods neces-
sary for generalized operations on shapes, such as drawing, ﬁlling, and insideness
java.awt
java.awt.Shape
Chapter 9 – The java.awt Package
221

testing. The package java.awt.geom contains a number of useful implementations of this
inter face, including GeneralPath, which can be used to describe arbitrary shapes com-
posed of line and curve segments. java.awt.Polygon and java.awt.Rectangle ar e also im-
portant implementations of Shape. Most applications can rely on these predeﬁned
implementations and do not need to implement this interface themselves.
getBounds() and getBounds2D() retur n rectangular bounding boxes that completely
enclose a Shape. contains() and intersects() test whether the shape contains or intersects a
speciﬁed point or rectangle. The most important method of the Shape inter face, how-
ever, is getPathIterator(). This method retur ns a java.awt.geom.PathIterator object that traces
the outline of the shape using line and curve segments. The two-argument version of
this method retur ns a PathIterator that is guaranteed to trace the outline using only
straight line segments and no curves. The ﬂatness argument is a measure of how closely
the line segments must approximate the actual outline. Smaller values of ﬂatness requir e
incr easingly accurate approximations.
The Shape inter face was ﬁrst deﬁned in Java 1.1. In that version of the language it con-
tained only the getBounds() method. The interface is so central to Java 2D and has
gr own so much since the Java 1.1 version, however, that it should generally be consid-
er ed to be new in Java 1.2.
public abstract interface Shape {
// Public Instance Methods
1.2 public abstract boolean contains(java.awt.geom.Point2D p);
1.2 public abstract boolean contains(java.awt.geom.Rectangle2D r);
1.2 public abstract boolean contains(double x, double y);
1.2 public abstract boolean contains(double x, double y, double w, double h);
public abstract Rectangle getBounds();
1.2 public abstract java.awt.geom.Rectangle2D getBounds2D();
1.2 public abstract java.awt.geom.PathIterator getPathIterator(java.awt.geom.AfﬁneTransform at);
1.2 public abstract java.awt.geom.PathIterator getPathIterator(java.awt.geom.AfﬁneTransform at, double ﬂatness);
1.2 public abstract boolean intersects(java.awt.geom.Rectangle2D r);
1.2 public abstract boolean intersects(double x, double y, double w, double h);
}
Implementations: Polygon, Rectangle, java.awt.geom.Area, java.awt.geom.CubicCur ve2D,
java.awt.geom.GeneralPath, java.awt.geom.Line2D, java.awt.geom.QuadCur ve2D,
java.awt.geom.RectangularShape
Passed To: Too many methods to list.
Retur ned By: Too many methods to list.
Stroke
Ja va 1.2
java.awt
This interface deﬁnes how Java 2D draws the outline of a shape. It is responsible for
graphical attributes such as line width and dash pattern. However, the Stroke is not
responsible for the color or texture of the outline—those are the responsibility of the
Paint inter face. By default, lines are solid and are one pixel wide. To specify a differ ent
line style, pass a Stroke object to the setStroke() method of a Graphics2D object.
Mathematically, the outline of a shape is an inﬁnitely thin line. Because it has no thick-
ness, it cannot be drawn. The Stroke inter face is responsible for deﬁning how such
inﬁnitely thin outlines are drawn. The createStrokedShape() method is passed the Shape
that is to be drawn. It retur ns a new Shape that places a ﬁnite width around the
inﬁnitely thin boundaries of the speciﬁed shape. The outline of the original shape can
then be drawn by ﬁlling the interior of the retur ned shape.
java.awt.Shape
222 Chapter 9 – The java.awt Package

BasicStroke implements Stroke and is the only implementation needed by most programs.
Some programs may deﬁne their own implementations to achieve special effects not
possible with BasicStroke, however.
public abstract interface Stroke {
// Public Instance Methods
public abstract Shape createStrokedShape(Shape p);
}
Implementations: BasicStroke
Passed To: Graphics2D.setStroke()
Retur ned By: Graphics2D.getStroke()
SystemColor
Ja va 1.1
java.awt
serializable PJ1.1
Instances of the SystemColor class repr esent colors used in the system desktop. You can
use these colors to produce applications and custom components that ﬁt well in the
desktop color scheme. On platforms that allow the desktop colors to be modiﬁed
dynamically, the actual colors repr esented by these symbolic system colors may be
dynamically updated.
The SystemColor class does not have a constructor, but it deﬁnes constant SystemColor
objects that repr esent each of the symbolic colors used by the system desktop. If you
need to compare a SystemColor object to a regular Color object, use the getRGB() method
of both objects and compare the resulting values.
public ﬁnal class SystemColor extends Color implements Serializable {
// No Constructor
// Public Constants
=1
public static ﬁnal int ACTIVE_CAPTION;
=3
public static ﬁnal int ACTIVE_CAPTION_BORDER;
=2
public static ﬁnal int ACTIVE_CAPTION_TEXT;
public static ﬁnal SystemColor activeCaption;
public static ﬁnal SystemColor activeCaptionBorder;
public static ﬁnal SystemColor activeCaptionText;
public static ﬁnal SystemColor control;
=17
public static ﬁnal int CONTROL;
=22
public static ﬁnal int CONTROL_DK_SHADOW;
=19
public static ﬁnal int CONTROL_HIGHLIGHT;
=20
public static ﬁnal int CONTROL_LT_HIGHLIGHT;
=21
public static ﬁnal int CONTROL_SHADOW;
=18
public static ﬁnal int CONTROL_TEXT;
public static ﬁnal SystemColor controlDkShadow;
public static ﬁnal SystemColor controlHighlight;
public static ﬁnal SystemColor controlLtHighlight;
public static ﬁnal SystemColor controlShadow;
public static ﬁnal SystemColor controlText;
public static ﬁnal SystemColor desktop;
=0
public static ﬁnal int DESKTOP;
=4
public static ﬁnal int INACTIVE_CAPTION;
=6
public static ﬁnal int INACTIVE_CAPTION_BORDER;
=5
public static ﬁnal int INACTIVE_CAPTION_TEXT;
public static ﬁnal SystemColor inactiveCaption;
public static ﬁnal SystemColor inactiveCaptionBorder;
public static ﬁnal SystemColor inactiveCaptionText;
public static ﬁnal SystemColor info;
=24
public static ﬁnal int INFO;
java.awt
java.awt.SystemColor
Chapter 9 – The java.awt Package
223

=25
public static ﬁnal int INFO_TEXT;
public static ﬁnal SystemColor infoText;
public static ﬁnal SystemColor menu;
=10
public static ﬁnal int MENU;
=11
public static ﬁnal int MENU_TEXT;
public static ﬁnal SystemColor menuText;
=26
public static ﬁnal int NUM_COLORS;
public static ﬁnal SystemColor scrollbar;
=23
public static ﬁnal int SCROLLBAR;
=12
public static ﬁnal int TEXT;
public static ﬁnal SystemColor text;
=14
public static ﬁnal int TEXT_HIGHLIGHT;
=15
public static ﬁnal int TEXT_HIGHLIGHT_TEXT;
=16
public static ﬁnal int TEXT_INACTIVE_TEXT;
=13
public static ﬁnal int TEXT_TEXT;
public static ﬁnal SystemColor textHighlight;
public static ﬁnal SystemColor textHighlightText;
public static ﬁnal SystemColor textInactiveText;
public static ﬁnal SystemColor textText;
=7
public static ﬁnal int WINDOW;
public static ﬁnal SystemColor window;
=8
public static ﬁnal int WINDOW_BORDER;
=9
public static ﬁnal int WINDOW_TEXT;
public static ﬁnal SystemColor windowBorder;
public static ﬁnal SystemColor windowText;
// Public Methods Overriding Color
1.2 public PaintContext createContext(java.awt.image.ColorModel cm, Rectangle r, java.awt.geom.Rectangle2D r2d,
java.awt.geom.AfﬁneTransform xform, RenderingHints hints);
public int getRGB();
public String toString();
}
Hierar chy: Object→Color(Paint(Transparency), Serializable)→SystemColor(Serializable)
Type Of: Too many fields to list.
TextArea
Ja va 1.0
java.awt
serializable AWT component PJ1.1(mod)
This class is a GUI component that displays and optionally edits multiline text. The
appendText(), inser tText(), and replaceText() methods provide various techniques for specify-
ing text to appear in the TextArea. Many important TextArea methods are deﬁned by its
TextComponent superclass. See also TextComponent and TextF ield.
The four-argument version of the TextArea() constructor allows you to specify a scrollbar
display policy for the TextArea object. Personal Java environments can deﬁne a scrolling
mechanism other than scrollbars. In this case, the scrollbar display policy can be
ignor ed.
public class TextArea extends TextComponent {
// Public Constructors
public TextArea();
public TextArea(String text);
public TextArea(int rows, int columns);
public TextArea(String text, int rows, int columns);
1.1 public TextArea(String text, int rows, int columns, int scrollbars);
// Public Constants
=0
1.1 public static ﬁnal int SCROLLBARS_BOTH;
=2
1.1 public static ﬁnal int SCROLLBARS_HORIZONTAL_ONLY;
java.awt.SystemColor
224 Chapter 9 – The java.awt Package

=3
1.1 public static ﬁnal int SCROLLBARS_NONE;
=1
1.1 public static ﬁnal int SCROLLBARS_VERTICAL_ONLY;
// Property Accessor Methods (by property name)
default:0
public int getColumns();
1.1 public void setColumns(int columns);
Overrides:Component
1.1 public Dimension getMinimumSize();
1.1 public Dimension getMinimumSize(int rows, int columns);
Overrides:Component
1.1 public Dimension getPrefer redSize();
1.1 public Dimension getPrefer redSize(int rows, int columns);
default:0
public int getRows();
1.1 public void setRows(int rows);
default:0
1.1 public int getScrollbarV isibility();
// Public Instance Methods
1.1 public void append(String str);
1.1 public void inser t(String str, int pos);
1.1 public void replaceRange(String str, int star t, int end);
// Protected Methods Overriding TextComponent
protected String paramString();
// Public Methods Overriding Component
public void addNotify();
// Deprecated Public Methods
synchronized
# public void appendText(String str);
synchronized
# public void inser tText(String str, int pos);
Overrides:Component
# public Dimension minimumSize();
# public Dimension minimumSize(int rows, int columns);
Overrides:Component
# public Dimension prefer redSize();
# public Dimension prefer redSize(int rows, int columns);
synchronized
# public void replaceText(String str, int star t, int end);
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, MenuContainer, Serializable)→
TextComponent→TextArea
Passed To: Toolkit.createTextArea()
TextComponent
Ja va 1.0
java.awt
serializable AWT component PJ1.1
This class is the superclass of the TextArea and TextF ield components. It cannot be instanti-
ated itself but provides methods that are common to these two component types. setEd-
itable() speciﬁes whether the text in the component is editable. getText() retur ns the text
in the component, and setText() speciﬁes text to be displayed. getSelectedText() retur ns the
curr ently selected text in the component, and getSelectionStar t() and getSelectionEnd()
retur n the extents of the selected region of text. select() and selectAll() select some and
all of the text displayed in the text component, respectively.
See also TextF ield and TextArea.
public class TextComponent extends Component {
// No Constructor
// Event Registration Methods (by event name)
synchronized
1.1 public void addTextListener(java.awt.e vent.TextListener l);
synchronized
1.1 public void removeTextListener(java.awt.e vent.TextListener l);
// Property Accessor Methods (by property name)
synchronized
1.1 public int getCaretPosition();
synchronized
1.1 public void setCaretPosition(int position);
public boolean isEditable();
synchronized
public void setEditable(boolean b);
java.awt
java.awt.TextComponent
Chapter 9 – The java.awt Package
225

synchronized
public String getSelectedText();
synchronized
public int getSelectionEnd();
synchronized
1.1 public void setSelectionEnd(int selectionEnd);
synchronized
public int getSelectionStar t();
synchronized
1.1 public void setSelectionStar t(int selectionStar t);
synchronized
public String getText();
synchronized
public void setText(String t);
// Public Instance Methods
synchronized
public void select(int selectionStar t, int selectionEnd);
synchronized
public void selectAll();
// Public Methods Overriding Component
public void removeNotify();
// Protected Methods Overriding Component
protected String paramString();
1.1 protected void processEvent(AWTEvent e);
// Protected Instance Methods
1.1 protected void processTextEvent(java.awt.e vent.TextEvent e);
// Protected Instance Fields
1.1 protected transient java.awt.event.TextListener textListener;
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, MenuContainer, Serializable)→
TextComponent
Subc lasses: TextArea, TextF ield
TextF ield
Ja va 1.0
java.awt
serializable AWT component PJ1.1
This Component displays a single line of optionally editable text. Most of its interesting
methods are deﬁned by its TextComponent superclass. Use setEchoChar() to specify a char-
acter to be echoed when requesting sensitive input, such as a password.
See also TextComponent and TextArea.
public class TextF ield extends TextComponent {
// Public Constructors
public TextF ield();
public TextF ield(int columns);
public TextF ield(String text);
public TextF ield(String text, int columns);
// Event Registration Methods (by event name)
synchronized
1.1 public void addActionListener(java.awt.e vent.ActionListener l);
synchronized
1.1 public void removeActionListener(java.awt.e vent.ActionListener l);
// Property Accessor Methods (by property name)
default:0
public int getColumns();
synchronized
1.1 public void setColumns(int columns);
default:\0
public char getEchoChar();
1.1 public void setEchoChar(char c);
Overrides:Component
1.1 public Dimension getMinimumSize();
1.1 public Dimension getMinimumSize(int columns);
Overrides:Component
1.1 public Dimension getPrefer redSize();
1.1 public Dimension getPrefer redSize(int columns);
Overrides:TextComponent
1.2 public void setText(String t);
// Public Instance Methods
public boolean echoCharIsSet();
// Protected Methods Overriding TextComponent
protected String paramString();
1.1 protected void processEvent(AWTEvent e);
java.awt.TextComponent
226 Chapter 9 – The java.awt Package

// Public Methods Overriding Component
public void addNotify();
// Protected Instance Methods
1.1 protected void processActionEvent(java.awt.e vent.ActionEvent e);
// Deprecated Public Methods
Overrides:Component
# public Dimension minimumSize();
# public Dimension minimumSize(int columns);
Overrides:Component
# public Dimension prefer redSize();
# public Dimension prefer redSize(int columns);
synchronized
# public void setEchoCharacter(char c);
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, MenuContainer, Serializable)→
TextComponent→TextF ield
Passed To: Toolkit.createTextF ield()
TexturePaint
Ja va 1.2
java.awt
This implementation of Paint is used to perfor m Java 2D drawing and ﬁlling operations
with a texture or patter n of colors deﬁned in a BufferedImage object.
When you create a TexturePaint object, you must specify the BufferedImage that deﬁnes the
textur e. You must also specify a rectangle that deﬁnes both the initial position of the
image and the tile size with which the image is replicated. Typically, you specify a rect-
angle with its upper-left corner at (0,0) and a width and height equal to the width and
height of the image
public class TexturePaint implements Paint {
// Public Constructors
public TexturePaint(java.awt.image.BufferedImage txtr, java.awt.geom.Rectangle2D anchor);
// Public Instance Methods
public java.awt.geom.Rectangle2D getAnchorRect();
public java.awt.image.BufferedImage getImage();
// Methods Implementing Paint
public PaintContext createContext(java.awt.image.ColorModel cm, Rectangle deviceBounds,
java.awt.geom.Rectangle2D userBounds, java.awt.geom.AfﬁneTransform xform,
RenderingHints hints);
// Methods Implementing Transparency
public int getTransparency();
}
Hierar chy: Object→TexturePaint(Paint(Transparency))
Toolkit
Ja va 1.0
java.awt
PJ1.1(mod)
This abstract class deﬁnes methods that, when implemented, create platform-dependent
peers for each of the Component types in java.awt. Java supports its platform-independent
GUI interface by implementing a subclass of Toolkit for each platform. Portable programs
should never use these methods to create peers directly — they should use the Compo-
nent classes themselves. A Toolkit object cannot be instantiated directly. The getToolkit()
method of Component retur ns the Toolkit being used for a particular component.
The Toolkit class also deﬁnes methods that you can use directly. The static method getDe-
faultToolkit() retur ns the default Toolkit that is in use. getScreenSize() retur ns the screen size
in pixels, and getScreenResolution() retur ns the resolution in dots per inch. sync() ﬂushes
all pending graphics output, which can be useful for animation. Other methods of
java.awt
java.awt.Toolkit
Chapter 9 – The java.awt Package
227

inter est include beep(), getSystemClipboard(), createCustomCursor(), and addAWTEventListener().
getPrintJob() is part of the Java 1.1 printing API. In Personal Java environments, printing
support is optional, and this method can throw an exception.
public abstract class Toolkit {
// Public Constructors
public Toolkit();
// Public Class Methods
synchronized
public static Toolkit getDefaultToolkit();
1.1 public static String getProper ty(String key, String defaultValue);
// Protected Class Methods
1.1 protected static Container getNativeContainer(Component c);
// Event Registration Methods (by event name)
1.2 public void removeAWTEventListener(java.awt.e vent.AWTEventListener listener);
// Property Accessor Methods (by property name)
public abstract java.awt.image.ColorModel getColorModel();
constant
1.2 public int getMaximumCursorColors();
constant
1.1 public int getMenuShor tcutKeyMask();
public abstract int getScreenResolution();
public abstract Dimension getScreenSize();
1.1 public abstract java.awt.datatransfer.Clipboard getSystemClipboard();
1.1 public ﬁnal EventQueue getSystemEventQueue();
// Public Instance Methods
1.2 public void addAWTEventListener(java.awt.e vent.AWTEventListener listener, long eventMask);
synchronized
1.2 public void addProper tyChangeListener(String name, java.beans.Proper tyChangeListener pcl);
1.1 public abstract void beep();
public abstract int checkImage(Image image, int width, int height, java.awt.image.ImageObserver obser ver);
1.2 public Cursor createCustomCursor(Image cursor, Point hotSpot, String name)
throws IndexOutOfBoundsException;
constant
1.2 public java.awt.dnd.DragGestureRecognizer createDragGestureRecognizer(
Class abstractRecognizerClass,
java.awt.dnd.DragSource ds,
Component c, int srcActions,
java.awt.dnd.DragGestureListener dgl);
1.2 public abstract java.awt.dnd.peer.DragSourceContextPeer createDragSourceContextPeer(
java.awt.dnd.DragGestureEvent dge)
throws java.awt.dnd.InvalidDnDOperationException;
1.2 public abstract Image createImage(java.net.URL url);
1.1 public Image createImage(byte[ ] imagedata);
1.2 public abstract Image createImage(String ﬁlename);
public abstract Image createImage(java.awt.image.ImageProducer producer);
1.1 public abstract Image createImage(byte[ ] imagedata, int imageoffset, int imagelength);
1.2 public Dimension getBestCursorSize(int preferredWidth, int preferredHeight);
synchronized
1.2 public ﬁnal Object getDesktopProper ty(String proper tyName);
public abstract Image getImage(java.net.URL url);
public abstract Image getImage(String ﬁlename);
1.1 public abstract PrintJob getPrintJob(Frame frame, String jobtitle, java.util.Proper ties props);
public abstract boolean prepareImage(Image image, int width, int height,
java.awt.image.ImageObserver obser ver);
synchronized
1.2 public void removeProper tyChangeListener(String name,
java.beans.Proper tyChangeListener pcl);
public abstract void sync();
// Protected Instance Methods
protected abstract java.awt.peer.ButtonPeer createButton(Button target);
protected abstract java.awt.peer.CanvasPeer createCanvas(Canvas target);
protected abstract java.awt.peer.CheckboxPeer createCheckbox(Checkbox target);
protected abstract java.awt.peer.CheckboxMenuItemPeer createCheckboxMenuItem(
CheckboxMenuItem target);
protected abstract java.awt.peer.ChoicePeer createChoice(Choice target);
java.awt.Toolkit
228 Chapter 9 – The java.awt Package

1.1 protected java.awt.peer.LightweightPeer createComponent(Component target);
protected abstract java.awt.peer.DialogPeer createDialog(Dialog target);
protected abstract java.awt.peer.F ileDialogPeer createF ileDialog(F ileDialog target);
protected abstract java.awt.peer.FramePeer createFrame(Frame target);
protected abstract java.awt.peer.LabelPeer createLabel(Label target);
protected abstract java.awt.peer.ListPeer createList(java.awt.List target);
protected abstract java.awt.peer.MenuPeer createMenu(Menu target);
protected abstract java.awt.peer.MenuBarPeer createMenuBar(MenuBar target);
protected abstract java.awt.peer.MenuItemPeer createMenuItem(MenuItem target);
protected abstract java.awt.peer.PanelPeer createPanel(Panel target);
1.1 protected abstract java.awt.peer.PopupMenuPeer createPopupMenu(PopupMenu target);
protected abstract java.awt.peer.ScrollbarPeer createScrollbar(Scrollbar target);
1.1 protected abstract java.awt.peer.ScrollPanePeer createScrollPane(ScrollPane target);
protected abstract java.awt.peer.TextAreaPeer createTextArea(TextArea target);
protected abstract java.awt.peer.TextF ieldPeer createTextF ield(TextF ield target);
protected abstract java.awt.peer.W indowPeer createW indow(W indow target);
1.1 protected abstract EventQueue getSystemEventQueueImpl();
empty
1.2 protected void initializeDesktopProper ties();
constant
1.2 protected Object lazilyLoadDesktopProper ty(String name);
empty
1.1 protected void loadSystemColors(int[ ] systemColors);
synchronized
1.2 protected ﬁnal void setDesktopProper ty(String name, Object newValue);
// Protected Instance Fields
1.2 protected ﬁnal java.util.Map desktopProper ties;
1.2 protected ﬁnal java.beans.PropertyChangeSuppor t desktopPropsSuppor t;
// Deprecated Public Methods
# public abstract String[ ] getFontList();
# public abstract FontMetrics getFontMetrics(Font font);
// Deprecated Protected Methods
1.1# protected abstract java.awt.peer.FontPeer getFontPeer(String name, int style);
}
Retur ned By: Component.getToolkit(), Toolkit.getDefaultToolkit(), Window.getToolkit(),
java.awt.peer.ComponentPeer.getToolkit()
Tr ansparency
Ja va 1.2
java.awt
The integer constants deﬁned by this interface identify the three types of transparency
supported by Java 2D. Although the Transparency inter face is implemented only by a
couple of Java 2D classes, the constants it deﬁnes are mor e widely used. These con-
stants are:
OPAQUE
All colors are fully opaque, with no transparency. The alpha value of every pixel is
1.0.
BITMASK
Colors are either fully opaque or fully transparent, as speciﬁed by the bits in a bit
mask. That is, each pixel has 1 bit associated with it that speciﬁes whether the
pixel is opaque (alpha is 1.0) or transparent (alpha is 0.0).
TRANSLUCENT
Colors may be totally opaque, totally transparent, or translucent. This model of
transpar ency uses an alpha channel that is wider than 1 bit and supports a number
of alpha transparency levels between 1.0 and 0.0.
java.awt
java.awt.Transparenc y
Chapter 9 – The java.awt Package
229

public abstract interface Tr ansparency {
// Public Constants
=2
public static ﬁnal int BITMASK;
=1
public static ﬁnal int OPAQUE;
=3
public static ﬁnal int TRANSLUCENT;
// Public Instance Methods
public abstract int getTransparency();
}
Implementations: Paint, java.awt.image.ColorModel
Window
Ja va 1.0
java.awt
serializable AWT component PJ1.1(mod)
This class repr esents a top-level window with no borders or menu bar. Window is a Con-
tainer with BorderLayout as its default layout manager. Window is rarely used directly; its
subclasses Frame and Dialog ar e mor e commonly useful.
show() (which overrides the show() method of Component) makes a Window visible and
brings it to the front of other windows. toFront() brings a window to the front, and
toBack() buries a window beneath others. pack() is an important method that initiates
layout management for the window, setting the window size to match the preferr ed
size of the components contained within the window. getToolkit() retur ns the Toolkit() in
use for this window. Call dispose() when a Window is no longer needed, to free its win-
dow system resources.
Although the Window class is part of the Personal Java API, Personal Java implementa-
tions can prohibit the creation of Window objects. In this case, the Window() constructor
thr ows an exception.
public class Window extends Container {
// Public Constructors
1.2 public Window(W indow owner);
public Window(Frame owner);
// Event Registration Methods (by event name)
synchronized
1.1 public void addW indowListener(java.awt.e vent.WindowListener l);
synchronized
1.1 public void removeW indowListener(java.awt.e vent.WindowListener l);
// Property Accessor Methods (by property name)
1.1 public Component getFocusOwner();
Overrides:Component
1.2 public java.awt.im.InputContext getInputContext();
Overrides:Component
1.1 public java.util.Locale getLocale();
1.2 public Window[ ] getOwnedW indows();
1.2 public Window getOwner();
Overrides:Component
1.1 public boolean isShowing();
Overrides:Component
public Toolkit getToolkit();
public ﬁnal String getWar ningString();
// Public Instance Methods
1.2 public void applyResourceBundle(java.util.ResourceBundle rb);
1.2 public void applyResourceBundle(String rbName);
public void dispose();
public void pack();
public void toBack();
public void toFront();
// Public Methods Overriding Container
public void addNotify();
synchronized
1.2 public void setCursor(Cursor cursor);
// Protected Methods Overriding Container
1.1 protected void processEvent(AWTEvent e);
java.awt.Transparenc y
230 Chapter 9 – The java.awt Package

// Public Methods Overriding Component
1.2 public void hide();
public void show();
// Protected Methods Overriding Object
1.2 protected void ﬁnalize() throws Throwable;
// Protected Instance Methods
1.1 protected void processW indowEvent(java.awt.e vent.WindowEvent e);
// Deprecated Public Methods
Overrides:Component
1.1# public boolean postEvent(Event e);
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, MenuContainer, Serializable)→
Container→Window
Subc lasses: Dialog, Frame, javax.swing .JWindow
Passed To: Toolkit.createW indow(), Window.W indow(), java.awt.event.W indowEvent.W indowEvent(),
javax.swing .JWindow.JW indow()
Retur ned By: Window.{getOwnedW indows(), getOwner()}, java.awt.event.W indowEvent.getW indow(),
javax.swing .SwingUtilities.windowForComponent()
java.awt
java.awt.Window
Chapter 9 – The java.awt Package
231

CHAPTER 10
The java.awt.color Package
The java.awt.color package includes the abstract ColorSpace class, which deﬁnes
methods necessary for converting colors between arbitrary color spaces. The pack-
age also contains implementations of the ColorSpace class based on data contained
in ICC proﬁle ﬁles. (The ICC is the international color standards body.) Most appli-
cations do not need to use this package; it is requir ed only for applications that
per form sophisticated image processing or requir e extr emely accurate device-inde-
pendent color display. Figure 10-1 shows the class hierarchy of this package,
which is new in Java 1.2.
This package does not contain classes for repr esenting colors. See the java.awt.Color
class instead.
ABSTRACT CLASS
KEY
CLASS
java.lang
Object
RuntimeException
ColorSpace
ICC_Profile
java.awt.color
ICC_ColorSpace
ICC_ProfileGray
ICC_ProfileRGB
CMMException
ProfileDataException
Figur e 10−1: The java.awt.color package
232

CMMException
Ja va 1.2
java.awt.color
serializable unchecked
Signals that an error has occurred in the internal color space management code.
public class CMMException extends RuntimeException {
// Public Constructors
public CMMException(String s);
}
Hierar chy: Object→Throwable(Serializable)→Exception→RuntimeException→CMMException
ColorSpace
Ja va 1.2
java.awt.color
This abstract class encapsulates a color space: a system of repr esenting colors using
some number of ﬂoating-point color components. For examples, sRGB is a proposed
standard color space that repr esents colors in terms of red, green, and blue compo-
nents, while CIEXYZ is an international standard color space that repr esents colors in
ter ms of three color components named X, Y, and Z. Typically, only applications that
ar e doing image processing or are concer ned with very precise color repr oduction
need to use this class.
ColorSpace does not have a public constructor. You can obtain an instance by calling the
static getInstance() method and passing in one of the CS_ constants to specify the type of
color space you want. Alternatively, implement and instantiate your own concrete sub-
class. Each ColorSpace object has methods to convert a color to and from the standard
sRGB and CIEXYZ color spaces. This ensures that any color, regardless of its color
space, can be converted to the red, green, and blue values used by computer display
devices. It also ensures that a color repr esented in an arbitrary color space can be trans-
for med to any other color space by ﬁrst converting to an intermediate CIEXYZ repr e-
sentation.
public abstract class ColorSpace {
// Protected Constructors
protected ColorSpace(int type, int numcomponents);
// Public Constants
=1001
public static ﬁnal int CS_CIEXYZ;
=1003
public static ﬁnal int CS_GRAY;
=1004
public static ﬁnal int CS_LINEAR_RGB;
=1002
public static ﬁnal int CS_PYCC;
=1000
public static ﬁnal int CS_sRGB;
=12
public static ﬁnal int TYPE_2CLR;
=13
public static ﬁnal int TYPE_3CLR;
=14
public static ﬁnal int TYPE_4CLR;
=15
public static ﬁnal int TYPE_5CLR;
=16
public static ﬁnal int TYPE_6CLR;
=17
public static ﬁnal int TYPE_7CLR;
=18
public static ﬁnal int TYPE_8CLR;
=19
public static ﬁnal int TYPE_9CLR;
=20
public static ﬁnal int TYPE_ACLR;
=21
public static ﬁnal int TYPE_BCLR;
=22
public static ﬁnal int TYPE_CCLR;
=11
public static ﬁnal int TYPE_CMY;
=9
public static ﬁnal int TYPE_CMYK;
=23
public static ﬁnal int TYPE_DCLR;
=24
public static ﬁnal int TYPE_ECLR;
=25
public static ﬁnal int TYPE_FCLR;
=6
public static ﬁnal int TYPE_GRAY;
java.awt.
color
java.awt.color.ColorSpace
Chapter 10 – The java.awt.color Package
233

=8
public static ﬁnal int TYPE_HLS;
=7
public static ﬁnal int TYPE_HSV;
=1
public static ﬁnal int TYPE_Lab;
=2
public static ﬁnal int TYPE_Luv;
=5
public static ﬁnal int TYPE_RGB;
=0
public static ﬁnal int TYPE_XYZ;
=3
public static ﬁnal int TYPE_YCbCr;
=4
public static ﬁnal int TYPE_Yxy;
// Public Class Methods
public static ColorSpace getInstance(int colorspace);
// Public Instance Methods
public abstract ﬂoat[ ] fromCIEXYZ(ﬂoat[ ] color value);
public abstract ﬂoat[ ] fromRGB(ﬂoat[ ] rgbvalue);
public String getName(int idx);
public int getNumComponents();
public int getType();
public boolean isCS_sRGB();
public abstract ﬂoat[ ] toCIEXYZ(ﬂoat[ ] color value);
public abstract ﬂoat[ ] toRGB(ﬂoat[ ] color value);
}
Subc lasses: ICC_ColorSpace
Passed To: Color.{Color(), getColorComponents(), getComponents()},
java.awt.image.ColorConvertOp.ColorConvertOp(), java.awt.image.ColorModel.ColorModel(),
java.awt.image.ComponentColorModel.ComponentColorModel(),
java.awt.image.DirectColorModel.DirectColorModel(), java.awt.image.PackedColorModel.PackedColorModel()
Retur ned By: Color.getColorSpace(), ColorSpace.getInstance(), java.awt.image.ColorModel.getColorSpace()
ICC_ColorSpace
Ja va 1.2
java.awt.color
This concrete subclass of ColorSpace deﬁnes a color space based on an ICC_Proﬁle object
that repr esents color space proﬁle data in a format deﬁned by the International Color
Consortium (ICC). See http://www.color.or g for information about ICC standards.
public class ICC_ColorSpace extends ColorSpace {
// Public Constructors
public ICC_ColorSpace(ICC_Proﬁle proﬁle);
// Public Instance Methods
public ICC_Proﬁle getProﬁle();
// Public Methods Overriding ColorSpace
public ﬂoat[ ] fromCIEXYZ(ﬂoat[ ] color value);
public ﬂoat[ ] fromRGB(ﬂoat[ ] rgbvalue);
public ﬂoat[ ] toCIEXYZ(ﬂoat[ ] color value);
public ﬂoat[ ] toRGB(ﬂoat[ ] color value);
}
Hierar chy: Object→ColorSpace→ICC_ColorSpace
java.awt.color.ColorSpace
234 Chapter 10 – The java.awt.color Package

ICC_Profile
Ja va 1.2
java.awt.color
This class repr esents an International Color Consortium (ICC) color space proﬁle. For
details about the proﬁle format, see the ICC Proﬁle Format Speciﬁcation, Version 3.4, at
http://www.color.or g. Only applications working with custom or specialized color
spaces ever need to use this class.
ICC_Proﬁle does not have a public constructor. Obtain an instance by calling the static
getInstance() method. There are versions of this method that read proﬁle data from a
java.io.InputStream, a string, and an array of bytes. The fourth version of this method
takes one of the CS_ constants deﬁned by the ColorSpace class and reads a built-in pro-
ﬁle for that color space. (In Sun’s Java 1.2 implementation, the proﬁle data for these
built-in standard color spaces is in the directory jr e/lib/cmm.)
public class ICC_Proﬁle {
// No Constructor
// Public Constants
=5
public static ﬁnal int CLASS_ABSTRACT;
=4
public static ﬁnal int CLASS_COLORSPACECONVERSION;
=3
public static ﬁnal int CLASS_DEVICELINK;
=1
public static ﬁnal int CLASS_DISPLAY;
=0
public static ﬁnal int CLASS_INPUT;
=6
public static ﬁnal int CLASS_NAMEDCOLOR;
=2
public static ﬁnal int CLASS_OUTPUT;
=3
public static ﬁnal int icAbsoluteColorimetric;
=8
public static ﬁnal int icCur veCount;
=12
public static ﬁnal int icCur veData;
=56
public static ﬁnal int icHdrAttributes;
=4
public static ﬁnal int icHdrCmmId;
=16
public static ﬁnal int icHdrColorSpace;
=80
public static ﬁnal int icHdrCreator;
=24
public static ﬁnal int icHdrDate;
=12
public static ﬁnal int icHdrDeviceClass;
=44
public static ﬁnal int icHdrFlags;
=68
public static ﬁnal int icHdrIlluminant;
=36
public static ﬁnal int icHdrMagic;
=48
public static ﬁnal int icHdrManufacturer;
=52
public static ﬁnal int icHdrModel;
=20
public static ﬁnal int icHdrPcs;
=40
public static ﬁnal int icHdrPlatfor m;
=64
public static ﬁnal int icHdrRenderingIntent;
=0
public static ﬁnal int icHdrSize;
=8
public static ﬁnal int icHdrVersion;
=0
public static ﬁnal int icPerceptual;
=1
public static ﬁnal int icRelativeColorimetric;
=2
public static ﬁnal int icSaturation;
=1633842036
public static ﬁnal int icSigAbstractClass;
=1093812784
public static ﬁnal int icSigAToB0Tag;
=1093812785
public static ﬁnal int icSigAToB1Tag;
=1093812786
public static ﬁnal int icSigAToB2Tag;
=1649957210
public static ﬁnal int icSigBlueColorantTag;
=1649693251
public static ﬁnal int icSigBlueTRCTag;
=1110589744
public static ﬁnal int icSigBToA0Tag;
=1110589745
public static ﬁnal int icSigBToA1Tag;
=1110589746
public static ﬁnal int icSigBToA2Tag;
=1667329140
public static ﬁnal int icSigCalibrationDateT imeTag;
=1952543335
public static ﬁnal int icSigCharTargetTag;
=1129142560
public static ﬁnal int icSigCmyData;
java.awt.
color
java.awt.color.ICC_Proﬁle
Chapter 10 – The java.awt.color Package
235

=1129142603
public static ﬁnal int icSigCmykData;
=1936744803
public static ﬁnal int icSigColorSpaceClass;
=1668313716
public static ﬁnal int icSigCopyrightTag;
=1684893284
public static ﬁnal int icSigDeviceMfgDescTag;
=1684890724
public static ﬁnal int icSigDeviceModelDescTag;
=1835955314
public static ﬁnal int icSigDisplayClass;
=1734438260
public static ﬁnal int icSigGamutTag;
=1196573017
public static ﬁnal int icSigGrayData;
=1800688195
public static ﬁnal int icSigGrayTRCTag;
=1733843290
public static ﬁnal int icSigGreenColorantTag;
=1733579331
public static ﬁnal int icSigGreenTRCTag;
=1751474532
public static ﬁnal int icSigHead;
=1212961568
public static ﬁnal int icSigHlsData;
=1213421088
public static ﬁnal int icSigHsvData;
=1935896178
public static ﬁnal int icSigInputClass;
=1281450528
public static ﬁnal int icSigLabData;
=1818848875
public static ﬁnal int icSigLinkClass;
=1819635049
public static ﬁnal int icSigLuminanceTag;
=1282766368
public static ﬁnal int icSigLuvData;
=1835360627
public static ﬁnal int icSigMeasurementTag;
=1651208308
public static ﬁnal int icSigMediaBlackPointTag;
=2004119668
public static ﬁnal int icSigMediaWhitePointTag;
=1852009522
public static ﬁnal int icSigNamedColor2Tag;
=1852662636
public static ﬁnal int icSigNamedColorClass;
=1886549106
public static ﬁnal int icSigOutputClass;
=1886545200
public static ﬁnal int icSigPreview0Tag;
=1886545201
public static ﬁnal int icSigPreview1Tag;
=1886545202
public static ﬁnal int icSigPreview2Tag;
=1684370275
public static ﬁnal int icSigProﬁleDescriptionTag;
=1886610801
public static ﬁnal int icSigProﬁleSequenceDescTag;
=1886610480
public static ﬁnal int icSigPs2CRD0Tag;
=1886610481
public static ﬁnal int icSigPs2CRD1Tag;
=1886610482
public static ﬁnal int icSigPs2CRD2Tag;
=1886610483
public static ﬁnal int icSigPs2CRD3Tag;
=1886597747
public static ﬁnal int icSigPs2CSATag;
=1886597737
public static ﬁnal int icSigPs2RenderingIntentTag;
=1918392666
public static ﬁnal int icSigRedColorantTag;
=1918128707
public static ﬁnal int icSigRedTRCTag;
=1380401696
public static ﬁnal int icSigRgbData;
=1935897188
public static ﬁnal int icSigScreeningDescTag;
=1935897198
public static ﬁnal int icSigScreeningTag;
=843271250
public static ﬁnal int icSigSpace2CLR;
=860048466
public static ﬁnal int icSigSpace3CLR;
=876825682
public static ﬁnal int icSigSpace4CLR;
=893602898
public static ﬁnal int icSigSpace5CLR;
=910380114
public static ﬁnal int icSigSpace6CLR;
=927157330
public static ﬁnal int icSigSpace7CLR;
=943934546
public static ﬁnal int icSigSpace8CLR;
=960711762
public static ﬁnal int icSigSpace9CLR;
=1094929490
public static ﬁnal int icSigSpaceACLR;
=1111706706
public static ﬁnal int icSigSpaceBCLR;
=1128483922
public static ﬁnal int icSigSpaceCCLR;
=1145261138
public static ﬁnal int icSigSpaceDCLR;
=1162038354
public static ﬁnal int icSigSpaceECLR;
=1178815570
public static ﬁnal int icSigSpaceFCLR;
=1952801640
public static ﬁnal int icSigTechnolog yTag;
=1650877472
public static ﬁnal int icSigUcrBgTag;
=1987405156
public static ﬁnal int icSigV iewingCondDescTag;
java.awt.color.ICC_Proﬁle
236 Chapter 10 – The java.awt.color Package

=1986618743
public static ﬁnal int icSigV iewingConditionsTag;
=1482250784
public static ﬁnal int icSigXYZData;
=1497588338
public static ﬁnal int icSigYCbCrData;
=1501067552
public static ﬁnal int icSigYxyData;
=4
public static ﬁnal int icTagReser ved;
=0
public static ﬁnal int icTagType;
=8
public static ﬁnal int icXYZNumberX;
// Public Class Methods
public static ICC_Proﬁle getInstance(java.io.InputStream s) throws java.io.IOException;
public static ICC_Proﬁle getInstance(String ﬁleName) throws java.io.IOException;
public static ICC_Proﬁle getInstance(byte[ ] data);
public static ICC_Proﬁle getInstance(int cspace);
// Property Accessor Methods (by property name)
public int getColorSpaceType();
public byte[ ] getData();
public byte[ ] getData(int tagSignature);
public int getMajorVersion();
public int getMinorVersion();
public int getNumComponents();
public int getPCSType();
public int getProﬁleClass();
// Public Instance Methods
public void setData(int tagSignature, byte[ ] tagData);
public void write(String ﬁleName) throws java.io.IOException;
public void write(java.io.OutputStream s) throws java.io.IOException;
// Protected Methods Overriding Object
protected void ﬁnalize();
}
Subc lasses: ICC_ProfileGray, ICC_ProfileRGB
Passed To: ICC_ColorSpace.ICC_ColorSpace(), java.awt.image.ColorConvertOp.ColorConvertOp()
Retur ned By: ICC_ColorSpace.getProfile(), ICC_Profile.getInstance(),
java.awt.image.ColorConvertOp.getICC_Profiles()
ICC_ProfileGray
Ja va 1.2
java.awt.color
A specialized subclass of ICC_Proﬁle that is used to repr esent certain grayscale color
spaces that meet criteria that allow color space conversions to be optimized. Applica-
tions never need to use this class.
public class ICC_ProﬁleGray extends ICC_Proﬁle {
// No Constructor
// Public Instance Methods
public ﬂoat getGamma();
public short[ ] getTRC();
// Public Methods Overriding ICC_Proﬁle
public ﬂoat[ ] getMediaWhitePoint();
}
Hierar chy: Object→ICC_Profile→ICC_ProfileGray
ICC_ProfileRGB
Ja va 1.2
java.awt.color
A specialized subclass of ICC_Proﬁle that is used to repr esent certain RGB color spaces
that meet criteria that allow color space conversions to be optimized. Applications
never need to use this class.
java.awt.
color
java.awt.color.ICC_ProﬁleRGB
Chapter 10 – The java.awt.color Package
237

public class ICC_ProﬁleRGB extends ICC_Proﬁle {
// No Constructor
// Public Constants
=2
public static ﬁnal int BLUECOMPONENT;
=1
public static ﬁnal int GREENCOMPONENT;
=0
public static ﬁnal int REDCOMPONENT;
// Public Instance Methods
public ﬂoat[ ][ ] getMatrix();
// Public Methods Overriding ICC_Proﬁle
public ﬂoat getGamma(int component);
public ﬂoat[ ] getMediaWhitePoint();
public short[ ] getTRC(int component);
}
Hierar chy: Object→ICC_Profile→ICC_ProfileRGB
ProfileDataException
Ja va 1.2
java.awt.color
serializable unchecked
Signals that an error occurred while reading ICC proﬁle data.
public class ProﬁleDataException extends RuntimeException {
// Public Constructors
public ProﬁleDataException(String s);
}
Hierar chy: Object→Throwable(Serializable)→Exception→RuntimeException→ProfileDataException
java.awt.color.ICC_ProfileRGB
238 Chapter 10 – The java.awt.color Package

CHAPTER 11
The java.awt.datatransfer Package
The java.awt.datatransfer package contains classes and interfaces that deﬁne a frame-
work for user-driven interapplication and intra-application data transfer. It also
contains classes that support data transfer through cut-and-paste. The Java 2 plat-
for m java.awt.dnd package implements drag-and-drop using the framework deﬁned
by this package.
The Transferable inter face is implemented by any class that allows data to be trans-
ferr ed. The DataFlavor class deﬁnes the type of data to be transferred. Clipboard and
ClipboardOwner ar e used for implementing cut-and-paste. StringSelection is a utility
class that enables easy data transfer of strings. Figure 11-1 shows the class hierar-
chy of this package. See Chapter 6, Data Transfer, for more details about data
transfer.
Clipboard
Ja va 1.1
java.awt.datatransfer
PJ1.1
This class repr esents a clipboard on which data may be transferred using the cut-and-
paste metaphor. When data is cut, it should be encapsulated in a Transferable object and
register ed with a Clipboard object by calling setContents(). A Clipboard can hold only a sin-
gle piece of data at a time, so a ClipboardOwner object must be speciﬁed when data is
placed on the clipboard. This object is notiﬁed that it no longer owns the clipboard
when the data is replaced by other, mor e recent, data.
When a paste is requested by the user, an application requests the data on the clip-
board by calling getContents(), which retur ns a Transferable object. The methods of this
object can be used to negotiate a mutually compatible data format and then actually
transfer the data.
A clipboard name is passed to the Clipboard() constructor and may be retrieved with get-
Name(). This name is not actually used in Java 1.1, however.
Note that while an application can create its own private Clipboard objects for intra-
application cut-and-paste, it is more common for an application to use the system clip-
board to enable cut-and-paste between applications. You can obtain the system
java.awt.
datatransfer
239

FINAL CLASS
extends
implements
KEY
CLASS
INTERFACE
java.awt.datatransfer
Clipboard
DataFlavor
java.lang
StringSelection
Object
UnsupportedFlavorException
Exception
SystemFlavorMap
ClipboardOwner
Transferable
FlavorMap
Figur e 11−1: The java.awt.datatransfer package
clipboard by calling the getSystemClipboard() method of the current Toolkit object.
Untrusted applet code is not allowed to access the system clipboard, so untrusted
applets cannot participate in interapplication cut-and-paste.
public class Clipboard {
// Public Constructors
public Clipboard(String name);
// Public Instance Methods
synchronized
public Transferable getContents(Object requestor);
public String getName();
synchronized
public void setContents(T ransferable contents, ClipboardOwner owner);
// Protected Instance Fields
protected Transferable contents;
protected ClipboardOwner owner;
}
Passed To: ClipboardOwner.lostOwnership(), StringSelection.lostOwnership()
Retur ned By: Toolkit.getSystemClipboard()
ClipboardOwner
Ja va 1.1
java.awt.datatransfer
PJ1.1
This interface deﬁnes the single method that an object that places data on a clipboard
must implement. This method is used to notify the object when its data on the clip-
board has been replaced by other, mor e recent, data. An object that places data on a
clipboard must remain ready to satisfy requests for that data until lostOwnership() is
called.
public abstract interface ClipboardOwner {
// Public Instance Methods
public abstract void lostOwnership(Clipboard clipboard, Transferable contents);
}
Implementations: StringSelection
Passed To: Clipboard.setContents()
Type Of: Clipboard.owner
java.awt.datatransfer.Clipboard
240 Chapter 11 – The java.awt.datatransfer Package

DataFlavor
Ja va 1.1
java.awt.datatransfer
cloneable serializable PJ1.1
This class deﬁnes a data format for the purpose of data transfer through Transferable
objects. A DataFlavor is characterized by three values. The ﬁrst is a descriptive human-
readable name, passed to a DataFlavor() constructor or set with setHumanPresentableName().
The second value is a MIME type that speciﬁes the data format, while the third is the
repr esentation class of the data. This third value is the class of object that is retur ned by
the getTransferData() method of Transferable when data is actually transferred.
In Java 1.1, you can specify either a MIME type or a repr esentation class, but not both.
If you specify a MIME type, the repr esentation class is java.io.InputStream, and data is
transferr ed thr ough an input stream. If, on the other hand, you use a Class object to
specify the repr esentation class, the MIME type is automatically set to the special value:
application/x-java-serialized-object class=classname
In this case, data is transferred through object serialization.
The plainTextFlavor and stringFlavor constants are predeﬁned DataFlavor objects for transfer-
ring text. They illustrate these two distinctly differ ent types of data transfer. plainTextFlavor
is “text/plain” data transferred through an input stream, while stringFlavor is a String
object transferred directly through serialization.
In Java 1.2, DataFlavor pr ovides several new ways to specify data formats. First, the
MIME type constant “application/x-java-serialized-object” is now available as the con-
stant javaSerializedObjectMimeType. Two similar MIME type constants have also been
deﬁned. javaJVMLocalObjectMimeType repr esents a local refer ence to a Java object. Data ﬂa-
vors of this type can be used only for transfers within a single Java VM. javaRemoteOb-
jectMimeType is a MIME type that repr esents a remote refer ence to a java.r mi.Remote
object. In this case, a refer ence to the object, rather than the object data itself, is trans-
ferr ed. This refer ence can be used with RMI. Note that all three of these MIME type
constants are incomplete as is. In order to use them, you must add class=classname to
the MIME type string, specifying the class name of the object or remote object being
transferr ed.
Another change in Java 1.2 is the addition of the predeﬁned DataFlavor javaF ileListFlavor.
This DataFlavor repr esents a list of ﬁlenames and is transferred as a java.util.List object
containing java.io.F ile objects. javaFileListFlavor has been added because ﬁles and groups of
ﬁles are commonly used with the drag-and-drop interface of the java.awt.dnd package.
public class DataFlavor implements Cloneable, java.io.Externalizable {
// Public Constructors
1.2 public DataFlavor();
1.2 public DataFlavor(String mimeType) throws ClassNotFoundException;
public DataFlavor(Class representationClass, String humanPresentableName);
public DataFlavor(String mimeType, String humanPresentableName);
1.2 public DataFlavor(String mimeType, String humanPresentableName, ClassLoader classLoader)
throws ClassNotFoundException;
// Public Constants
1.2 public static ﬁnal DataFlavor javaFileListFlavor;
="application/x-java-jvm-local-objectref"
1.2 public static ﬁnal String javaJVMLocalObjectMimeType;
="application/x-java-remote-object"
1.2 public static ﬁnal String javaRemoteObjectMimeType;
="application/x-java-serialized-object"
1.2 public static ﬁnal String javaSerializedObjectMimeType;
public static ﬁnal DataFlavor plainTextFlavor;
public static ﬁnal DataFlavor stringFlavor;
// Protected Class Methods
1.2 protected static ﬁnal Class tr yToLoadClass(String className, ClassLoader fallback)
throws ClassNotFoundException;
java.awt.
datatransfer
java.awt.datatransfer.DataFlavor
Chapter 11 – The java.awt.datatransfer Package
241

// Property Accessor Methods (by property name)
default:false
1.2 public boolean isFlavorJavaF ileListType();
1.2 public boolean isFlavorRemoteObjectType();
1.2 public boolean isFlavorSerializedObjectType();
default:null
public String getHumanPresentableName();
public void setHumanPresentableName(String humanPresentableName);
public String getMimeType();
default:false
1.2 public boolean isMimeTypeSerializedObject();
1.2 public String getPrimar yType();
default:null
public Class getRepresentationClass();
1.2 public boolean isRepresentationClassInputStream();
1.2 public boolean isRepresentationClassRemote();
1.2 public boolean isRepresentationClassSerializable();
1.2 public String getSubType();
// Public Instance Methods
1.2 public boolean equals(String s);
public boolean equals(DataFlavor dataFlavor);
1.2 public String getParameter(String paramName);
public boolean isMimeTypeEqual(String mimeType);
public ﬁnal boolean isMimeTypeEqual(DataFlavor dataFlavor);
// Methods Implementing Externalizable
synchronized
1.2 public void readExter nal(java.io.ObjectInput is) throws java.io.IOException,
ClassNotFoundException;
synchronized
1.2 public void writeExter nal(java.io.ObjectOutput os) throws java.io.IOException;
// Public Methods Overriding Object
1.2 public Object clone() throws CloneNotSupportedException;
1.2 public boolean equals(Object o);
1.2 public String toString();
// Deprecated Protected Methods
# protected String nor malizeMimeType(String mimeType);
# protected String nor malizeMimeTypeParameter(String parameterName, String parameterValue);
}
Hierar chy: Object→DataFlavor(Cloneable, java.io.Exter nalizable(Serializable))
Passed To: DataFlavor.{equals(), isMimeTypeEqual()}, FlavorMap.getNativesForFlavors(),
StringSelection.{getTransferData(), isDataFlavorSuppor ted()}, SystemFlavorMap.{encodeDataFlavor(),
getNativesForFlavors()}, Transferable.{getTransferData(), isDataFlavorSuppor ted()},
Unsuppor tedFlavorException.Unsuppor tedFlavorException(),
java.awt.dnd.DropTargetContext.isDataFlavorSuppor ted(),
java.awt.dnd.DropTargetContext.TransferableProxy.{getTransferData(), isDataFlavorSuppor ted()},
java.awt.dnd.DropTargetDragEvent.isDataFlavorSuppor ted(),
java.awt.dnd.DropTargetDropEvent.isDataFlavorSuppor ted()
Retur ned By: StringSelection.getTransferDataFlavors(), SystemFlavorMap.decodeDataFlavor(),
Transferable.getTransferDataFlavors(), java.awt.dnd.DropTargetContext.getCur rentDataFlavors(),
java.awt.dnd.DropTargetContext.TransferableProxy.getTransferDataFlavors(),
java.awt.dnd.DropTargetDragEvent.getCur rentDataFlavors(),
java.awt.dnd.DropTargetDropEvent.getCur rentDataFlavors(),
java.awt.dnd.peer.DropTargetContextPeer.getTransferDataFlavors()
Type Of: DataFlavor.{javaFileListFlavor, plainTextFlavor, stringFlavor}
java.awt.datatransfer.DataFlavor
242 Chapter 11 – The java.awt.datatransfer Package

FlavorMap
Ja va 1.2
java.awt.datatransfer
This interface deﬁnes methods that map between Java DataFlavor objects and platform-
dependent strings that repr esent the data transfer type to the native system. getFlavorsFor-
Natives() retur ns a java.util.Map object that maps from native data format names to DataFla-
vor objects. getNativesForFlavors() retur ns a Map fr om DataFlavor objects to native data
for mat names. For both these methods, you may specify either an array of the desired
keys or null, to obtain a Map that contains all known key-to-value mappings.
public abstract interface FlavorMap {
// Public Instance Methods
public abstract java.util.Map getFlavorsForNatives(String[ ] natives);
public abstract java.util.Map getNativesForFlavors(DataFlavor[ ] ﬂavors);
}
Implementations: SystemFlavorMap
Passed To: java.awt.dnd.DragSource.star tDrag(), java.awt.dnd.DropTarget.{DropTarget(), setFlavorMap()}
Retur ned By: SystemFlavorMap.getDefaultFlavorMap(), java.awt.dnd.DragSource.getFlavorMap(),
java.awt.dnd.DropTarget.getFlavorMap()
StringSelection
Ja va 1.1
java.awt.datatransfer
PJ1.1
This convenience class implements the Transferable and ClipboardOwner inter faces in order
to make it easy to transfer String values through the AWT data transfer mechanism.
StringSelection can transfer String values using either the DataFlavor.stringFlavor or DataFla-
vor.plainTextFlavor data ﬂavors.
To create a StringSelection object, simply pass the String you want to transfer to the
StringSelection() constructor. You can then make the StringSelection available for transfer
by passing it to the setContents() method of the Clipboard. You need never call the meth-
ods of StringSelection yourself.
public class StringSelection implements ClipboardOwner, Transferable {
// Public Constructors
public StringSelection(String data);
// Methods Implementing ClipboardOwner
empty
public void lostOwnership(Clipboard clipboard, Transferable contents);
// Methods Implementing Transferable
synchronized
public Object getTransferData(DataFlavor ﬂavor) throws UnsupportedFlavorException,
java.io.IOException;
synchronized
public DataFlavor[ ] getTransferDataFlavors();
public boolean isDataFlavorSuppor ted(DataFlavor ﬂavor);
}
Hierar chy: Object→StringSelection(ClipboardOwner, Transferable)
SystemFlavorMap
Ja va 1.2
java.awt.datatransfer
This FlavorMap implementation reads the mappings from DataFlavor objects to native data
for mat names for the system from an external ﬁle. In Sun’s Java SDK implementation,
for example, this class reads the ﬂavor map.properties ﬁle.
SystemFlavorMap does not have a public constructor. You can obtain an instance by call-
ing getDefaultFlavorMap(). SystemFlavorMap also deﬁnes several static methods that you can
use without instantiating the class.
java.awt.
datatransfer
java.awt.datatransfer.SystemFlavorMap
Chapter 11 – The java.awt.datatransfer Package
243

public ﬁnal class SystemFlavorMap implements FlavorMap {
// No Constructor
// Public Class Methods
public static DataFlavor decodeDataFlavor(String atom) throws ClassNotFoundException;
public static String decodeJavaMIMEType(String atom);
public static String encodeDataFlavor(DataFlavor df);
public static String encodeJavaMIMEType(String mimeType);
public static FlavorMap getDefaultFlavorMap();
public static boolean isJavaMIMEType(String atom);
// Methods Implementing FlavorMap
synchronized
public java.util.Map getFlavorsForNatives(String[ ] natives);
synchronized
public java.util.Map getNativesForFlavors(DataFlavor[ ] ﬂavors);
}
Hierar chy: Object→SystemFlavorMap(FlavorMap)
Tr ansferable
Ja va 1.1
java.awt.datatransfer
PJ1.1
This interface deﬁnes the methods that a class must deﬁne if it is to act as the source
object in a data transfer operation.
getTransferDataFlavors() should retur n an array of DataFlavor objects that specify the data
types or formats in which the object can provide its data. The DataFlavor objects should
be ordered from best format (most richly descriptive) to worst format. isDataFlavorSup-
por ted() must retur n a boolean value that indicates whether it can transfer data using a
speciﬁed DataFlavor. Finally, getTransferData() must retur n an object that repr esents the
data formatted as requir ed by the speciﬁed DataFlavor.
StringSelection is a predeﬁned class that implements the Transferable inter face for the trans-
fer of string data.
public abstract interface Tr ansferable {
// Public Instance Methods
public abstract Object getTransferData(DataFlavor ﬂavor) throws UnsupportedFlavorException, java.io.IOException;
public abstract DataFlavor[ ] getTransferDataFlavors();
public abstract boolean isDataFlavorSuppor ted(DataFlavor ﬂavor);
}
Implementations: StringSelection, java.awt.dnd.DropTargetContext.TransferableProxy
Passed To: Clipboard.setContents(), ClipboardOwner.lostOwnership(), StringSelection.lostOwnership(),
java.awt.dnd.DragGestureEvent.star tDrag(), java.awt.dnd.DragSource.{createDragSourceContext(), startDrag()},
java.awt.dnd.DragSourceContext.DragSourceContext(),
java.awt.dnd.DropTargetContext.createTransferableProxy()
Retur ned By: Clipboard.getContents(), java.awt.dnd.DragSourceContext.getTransferable(),
java.awt.dnd.DropTargetContext.{createTransferableProxy(), getTransferable()},
java.awt.dnd.DropTargetDropEvent.getTransferable(), java.awt.dnd.peer.DropTargetContextPeer.getTransferable()
Type Of: Clipboard.contents, java.awt.dnd.DropTargetContext.TransferableProxy.transferable
Unsuppor tedFlavorException
Ja va 1.1
java.awt.datatransfer
serializable checked PJ1.1
Signals that a Transferable object cannot provide data in the requested format.
java.awt.datatransfer.SystemFlavorMap
244 Chapter 11 – The java.awt.datatransfer Package

public class Unsuppor tedFlavorException extends Exception {
// Public Constructors
public Unsuppor tedFlavorException(DataFlavor ﬂavor);
}
Hierar chy: Object→Throwable(Serializable)→Exception→Unsuppor tedFlavorException
Thrown By: StringSelection.getTransferData(), Transferable.getTransferData(),
java.awt.dnd.DropTargetContext.TransferableProxy.getTransferData()
java.awt.
datatransfer
java.awt.datatransfer.Unsuppor tedFlavorException
Chapter 11 – The java.awt.datatransfer Package
245

CHAPTER 12
The java.awt.dnd Package
The java.awt.dnd package contains classes and interfaces that support data transfer
thr ough the drag-and-drop metaphor; the package is new in Java 1.2. This
functionality is built upon the data transfer framework of the java.awt.datatransfer
package.
A DragSource object is a proxy for an object that initiates a drag, while a DropTarget
object is a proxy for an object that wishes to accept drops. All inter-object commu-
nication during the drag process is done through the various event classes deﬁned
by this package. Figure 12-1 shows the class hierarchy of this package. See Chap-
ter 6, Data Transfer, for more details on drag-and-drop.
Autoscroll
Ja va 1.2
java.awt.dnd
This interface allows a scrollable component to scroll itself as part of the drag-and-drop
pr ocess, so that a user can drop an object anywhere within the component’s scrollable
content. Consider, for example, the problem of cutting a paragraph of text from the top
of a long document and dragging it down to the bottom of the same document. While
the drag-and-drop operation is in progr ess, the user obviously cannot operate the
scr ollbar, since the mouse is already in use. So some other technique is necessary to
enable scrolling during a drag-and-drop operation.
The Autoscroll inter face enables this specialized form of scr olling. When an object is ﬁrst
dragged over a component that implements Autoscroll, the drag-and-drop system calls
the component’s getAutoscrollInsets() method. This deﬁnes an autoscroll region at the
edges of the component. If, during the drag, the user places the mouse within this
autoscr oll region and holds it there (for a platform-dependent amount of time), the
drag-and-dr op system begins to call the autoscroll() method repeatedly (at a platform-
dependent repetition rate) until the user once again moves the mouse. The autoscroll()
method of the component is responsible for scrolling the content. The direction of the
scr oll is determined by the position of the mouse pointer, which is passed as an argu-
ment to autoscroll().
246

extends
implements
KEY
CLASS
ABSTRACT CLASS
FINAL CLASS
INTERFACE
java.lang
Object
DragGestureRecognizer
java.io
Serializable
java.util
EventObject
EventListener
DnDConstants
DropTarget
DropTargetContext
DragGestureEvent
DragSourceEvent
DropTargetEvent
MouseDragGestureRecognizer
java.awt.event
DragSourceDragEvent
DragSourceDropEvent
DropTargetDragEvent
DropTargetDropEvent
DragGestureListener
DragSourceListener
DropTargetListener
java.awt.dnd
DragSource
DragSourceContext
MouseListener
MouseMotionListener
AutoScroll
Figur e 12−1: The java.awt.dnd package
public abstract interface Autoscroll {
// Public Instance Methods
public abstract void autoscroll(Point cursorLocn);
public abstract Insets getAutoscrollInsets();
}
DnDConstants
Ja va 1.2
java.awt.dnd
Successful completion of a drag-and-drop operation can result in a number of differ ent
types of actions being perfor med. This interface deﬁnes constants that repr esent the
possible actions:
java.awt.dnd
java.awt.dnd.DnDConstants
Chapter 12 – The java.awt.dnd Package
247

ACTION_COPY
This is the most common action: the dragged object is to be copied in some way.
ACTION_COPY is also used as a default action when there is only one possible
action, even if that action is not really a copy.
ACTION_MOVE
The dragged object is to be copied by the destination. The source object deletes its
copy after the object is successfully transferred.
ACTION_COPY_OR_MOVE
This constant is the combination of ACTION_COPY and ACTION_MOVE. Many drop tar-
gets can accept drops of either type; this constant is used to indicate that fact.
ACTION_LINK or ACTION_REFERENCE
These two constants are synonyms. They indicate that the destination object
should create a link to the transferred object or share a refer ence to the transferred
object with the source object. Note that this action has a particularly vague mean-
ing; its use is not recommended except for intra-application drag-and-drop of spe-
cialized data types.
ACTION_NONE
This constant speciﬁes that no actions are supported. It is used internally by the
drag-and-dr op API but is not commonly used by application-level code.
public ﬁnal class DnDConstants {
// No Constructor
// Public Constants
=1
public static ﬁnal int ACTION_COPY;
=3
public static ﬁnal int ACTION_COPY_OR_MOVE;
=1073741824
public static ﬁnal int ACTION_LINK;
=2
public static ﬁnal int ACTION_MOVE;
=0
public static ﬁnal int ACTION_NONE;
=1073741824
public static ﬁnal int ACTION_REFERENCE;
}
DragGestureEvent
Ja va 1.2
java.awt.dnd
serializable event
This event type is ﬁred by a DragGestureRecognizer and sent to the dragGestureRecognized()
method of a DragGestureListener. Unlike many event classes, which are mer ely holders of
event information, DragGestureEvent also deﬁnes the star tDrag() method, which can be
used to initiate the drag-and-drop process.
When the dragGestureRecognized() method is invoked, it should start the drag-and-drop
pr ocess by invoking this star tDrag() method, passing in the initial drag cursor to display,
the Transferable data to transfer, and the DragSourceListener that monitors the drag process.
If there is to be an image dragged along with the drag cursor, the image and its offset
fr om the cursor hotspot may also be passed to star tDrag().
The other methods of DragGestureEvent() ar e accessor methods that retur n infor mation
about the event. Most applications do not need to call them.
public class DragGestureEvent extends java.util.EventObject {
// Public Constructors
public DragGestureEvent(DragGestureRecognizer dgr, int act, Point ori, java.util.List evs);
// Property Accessor Methods (by property name)
public Component getComponent();
java.awt.dnd.DnDConstants
248 Chapter 12 – The java.awt.dnd Package

public int getDragAction();
public Point getDragOrigin();
public DragSource getDragSource();
public DragGestureRecognizer getSourceAsDragGestureRecognizer();
public java.awt.event.InputEvent getTriggerEvent();
// Public Instance Methods
public java.util.Iterator iterator();
public void star tDrag(Cursor dragCursor, java.awt.datatransfer.Transferable transferable, DragSourceListener dsl)
throws InvalidDnDOperationException;
public void star tDrag(Cursor dragCursor, Image dragImage, Point imageOffset,
java.awt.datatransfer.Transferable transferable, DragSourceListener dsl)
throws InvalidDnDOperationException;
public Object[ ] toAr ray();
public Object[ ] toAr ray(Object[ ] array);
}
Hierar chy: Object→java.util.EventObject(Serializable)→DragGestureEvent
Passed To: Toolkit.createDragSourceContextPeer(), DragGestureListener.dragGestureRecognized(),
DragSource.{createDragSourceContext(), startDrag()}, DragSourceContext.DragSourceContext()
Retur ned By: DragSourceContext.getTrigger()
DragGestureListener
Ja va 1.2
java.awt.dnd
event listener
This interface deﬁnes the method that is invoked by a DragGestureRecognizer when the
user initiates a drag-and-drop action. When dragGestureRecognized() is called, the DragGes-
tureListener should prepar e a Transferable object to be transferred through the drag-and-
dr op pr ocess and then initiate that process by calling the star tDrag() method of the
DragGestureEvent object.
You do not typically pass a DragGestureListener to an addDragGestureListener() method.
Instead, you specify the DragGestureListener when you call the createDefaultDragGestureRec-
ognizer() method of a DragSource object. This method creates a DragGestureRecognizer and
automatically registers the DragGestureListener with it.
public abstract interface DragGestureListener extends java.util.EventListener {
// Public Instance Methods
public abstract void dragGestureRecognized(DragGestureEvent dge);
}
Hierar chy: (DragGestureListener(java.util.EventListener))
Passed To: Toolkit.createDragGestureRecognizer(), DragGestureRecognizer.{addDragGestureListener(),
DragGestureRecognizer(), removeDragGestureListener()}, DragSource.{createDefaultDragGestureRecognizer(),
createDragGestureRecognizer()}, MouseDragGestureRecognizer.MouseDragGestureRecognizer()
Type Of: DragGestureRecognizer.dragGestureListener
DragGestureRecognizer
Ja va 1.2
java.awt.dnd
Drag-and-dr op operations may be initiated in differ ent ways on differ ent native plat-
for ms. This abstract class is the superclass of the platform-dependent classes that are
used to recognize the platform-dependent gesture used to begin a drag. As an abstract
class, you cannot instantiate a DragGestureRecognizer dir ectly. Instead, you typically create
a DragGestureRecognizer by calling the createDefaultDragGestureRecognizer() method of a Drag-
Source object. If you want to allow the user to initiate drags with nonstandard gestures,
java.awt.dnd
java.awt.dnd.DragGestureRecognizer
Chapter 12 – The java.awt.dnd Package
249

you may implement your own DragGestureRecognizer subclass and instantiate it by calling
the createDragGestureRecognizer() method of java.awt.Toolkit.
When you create a DragGestureRecognizer, you specify the Component it is to look for drag
gestur es over and the DragGestureListener it is to notify when it recognizes one. The cre-
ation process automatically links these three objects together, so you typically never
need to do anything with a DragGestureRecognizer other than create it.
One additional piece of information you must supply when you create a DragGestureRec-
ognizer is a bit mask of allowed drag actions. ACTION_COPY, ACTION_MOVE, and ACTION_LINK
actions are usually initiated with differ ent gestur es (dif ferent modiﬁer keys). A DragGes-
tureRecognizer must know which actions are available so it can know which gestures to
recognize and which to ignore.
public abstract class DragGestureRecognizer {
// Protected Constructors
protected DragGestureRecognizer(DragSource ds);
protected DragGestureRecognizer(DragSource ds, Component c);
protected DragGestureRecognizer(DragSource ds, Component c, int sa);
protected DragGestureRecognizer(DragSource ds, Component c, int sa, DragGestureListener dgl);
// Event Registration Methods (by event name)
synchronized
public void addDragGestureListener(DragGestureListener dgl)
throws java.util.TooManyListenersException;
synchronized
public void removeDragGestureListener(DragGestureListener dgl);
// Property Accessor Methods (by property name)
synchronized
public Component getComponent();
synchronized
public void setComponent(Component c);
public DragSource getDragSource();
synchronized
public int getSourceActions();
synchronized
public void setSourceActions(int actions);
public java.awt.event.InputEvent getTriggerEvent();
// Public Instance Methods
public void resetRecognizer();
// Protected Instance Methods
synchronized
protected void appendEvent(java.awt.e vent.InputEvent awtie);
synchronized
protected void ﬁreDragGestureRecognized(int dragAction, Point p);
protected abstract void registerListeners();
protected abstract void unregisterListeners();
// Protected Instance Fields
protected Component component;
protected DragGestureListener dragGestureListener;
protected DragSource dragSource;
protected java.util.ArrayList events;
protected int sourceActions;
}
Subc lasses: MouseDragGestureRecognizer
Passed To: DragGestureEvent.DragGestureEvent()
Retur ned By: Toolkit.createDragGestureRecognizer(),
DragGestureEvent.getSourceAsDragGestureRecognizer(), DragSource.{createDefaultDragGestureRecognizer(),
createDragGestureRecognizer()}
DragSource
Ja va 1.2
java.awt.dnd
This class coordinates the initiation of drag-and-drop operations. Despite the central
role it plays in the drag-and-drop system, it is not used much in typical drag-and-drop
code.
java.awt.dnd.DragGestureRecognizer
250 Chapter 12 – The java.awt.dnd Package

You can create a DragSource object by calling the constructor, but because the DragSource
object does not hold any state, you can continually reuse a single object. Call the static
getDefaultDragSource() method to obtain a refer ence to a shared default DragSource object.
Once you have obtained a DragSource object, call createDefaultDragGestureRecognizer() to
cr eate and register a DragGestureRecognizer object that detects user gestures that should
initiate drags. If you want to drag an image that repr esents the dragged data along with
the drag cursor, you may also call the isDragImageSuppor ted() method to ﬁnd out whether
that option is supported on the native platform.
After you have called these two methods, you typically never need to use the Drag-
Source again. The star tDrag() method of the DragSource is responsible for initiating a drag
action, but it is easier to invoke it through the star tDrag() utility method of the DragGes-
tureEvent class instead.
public class DragSource {
// Public Constructors
public DragSource();
// Public Constants
public static ﬁnal Cursor DefaultCopyDrop;
public static ﬁnal Cursor DefaultCopyNoDrop;
public static ﬁnal Cursor DefaultLinkDrop;
public static ﬁnal Cursor DefaultLinkNoDrop;
public static ﬁnal Cursor DefaultMoveDrop;
public static ﬁnal Cursor DefaultMoveNoDrop;
// Public Class Methods
public static DragSource getDefaultDragSource();
public static boolean isDragImageSuppor ted();
// Public Instance Methods
public DragGestureRecognizer createDefaultDragGestureRecognizer(Component c, int actions,
DragGestureListener dgl);
public DragGestureRecognizer createDragGestureRecognizer(Class recognizerAbstractClass, Component c,
int actions, DragGestureListener dgl);
default:SystemFlavorMap
public java.awt.datatransfer.FlavorMap getFlavorMap();
public void star tDrag(DragGestureEvent trigger, Cursor dragCursor, java.awt.datatransfer.Transferable transferable,
DragSourceListener dsl) throws InvalidDnDOperationException;
public void star tDrag(DragGestureEvent trigger, Cursor dragCursor, java.awt.datatransfer.Transferable transferable,
DragSourceListener dsl, java.awt.datatransfer.FlavorMap ﬂavorMap)
throws InvalidDnDOperationException;
public void star tDrag(DragGestureEvent trigger, Cursor dragCursor, Image dragImage, Point dragOffset,
java.awt.datatransfer.Transferable transferable, DragSourceListener dsl)
throws InvalidDnDOperationException;
public void star tDrag(DragGestureEvent trigger, Cursor dragCursor, Image dragImage, Point imageOffset,
java.awt.datatransfer.Transferable transferable, DragSourceListener dsl,
java.awt.datatransfer.FlavorMap ﬂavorMap) throws InvalidDnDOperationException;
// Protected Instance Methods
protected DragSourceContext createDragSourceContext(java.awt.dnd.peer.DragSourceContextPeer dscp,
DragGestureEvent dgl, Cursor dragCursor,
Image dragImage, Point imageOffset,
java.awt.datatransfer.Transferable t,
DragSourceListener dsl);
}
Passed To: Toolkit.createDragGestureRecognizer(), DragGestureRecognizer.DragGestureRecognizer(),
MouseDragGestureRecognizer.MouseDragGestureRecognizer()
java.awt.dnd
java.awt.dnd.DragSour ce
Chapter 12 – The java.awt.dnd Package
251

Retur ned By: DragGestureEvent.getDragSource(), DragGestureRecognizer.getDragSource(),
DragSource.getDefaultDragSource(), DragSourceContext.getDragSource()
Type Of: DragGestureRecognizer.dragSource
DragSourceContext
Ja va 1.2
java.awt.dnd
This class contains state information about a drag operation currently in progr ess. It is
the DragSourceContext that is responsible for communicating with the native drag-and-
dr op system of the underlying platform and relaying drag-and-drop events to the Drag-
SourceListener. Although this is an important class, it does its work in the background,
and you typically do not need to use it. If you do want to use it, for example, to per-
for m cursor animation with the setCursor() method, you may obtain the current Drag-
SourceContext fr om any DragSourceEvent object.
public class DragSourceContext implements DragSourceListener {
// Public Constructors
public DragSourceContext(java.awt.dnd.peer.DragSourceContextPeer dscp, DragGestureEvent trigger,
Cursor dragCursor, Image dragImage, Point offset, java.awt.datatransfer.Transferable t,
DragSourceListener dsl);
// Protected Constants
=3
protected static ﬁnal int CHANGED;
=0
protected static ﬁnal int DEFAULT;
=1
protected static ﬁnal int ENTER;
=2
protected static ﬁnal int OVER;
// Event Registration Methods (by event name)
synchronized
public void addDragSourceListener(DragSourceListener dsl)
throws java.util.TooManyListenersException;
synchronized
public void removeDragSourceListener(DragSourceListener dsl);
// Property Accessor Methods (by property name)
public Component getComponent();
public Cursor getCursor();
public void setCursor(Cursor c);
public DragSource getDragSource();
public int getSourceActions();
public java.awt.datatransfer.Transferable getTransferable();
public DragGestureEvent getTrigger();
// Public Instance Methods
public void transferablesFlavorsChanged();
// Methods Implementing DragSourceListener
synchronized
public void dragDropEnd(DragSourceDropEvent dsde);
synchronized
public void dragEnter(DragSourceDragEvent dsde);
synchronized
public void dragExit(DragSourceEvent dse);
synchronized
public void dragOver(DragSourceDragEvent dsde);
synchronized
public void dropActionChanged(DragSourceDragEvent dsde);
// Protected Instance Methods
protected void updateCur rentCursor(int dropOp, int targetAct, int status);
}
Hierar chy: Object→DragSourceContext(DragSourceListener(java.util.EventListener))
Passed To: DragSourceDragEvent.DragSourceDragEvent(), DragSourceDropEvent.DragSourceDropEvent(),
DragSourceEvent.DragSourceEvent(), java.awt.dnd.peer.DragSourceContextPeer.star tDrag()
Retur ned By: DragSource.createDragSourceContext(), DragSourceEvent.getDragSourceContext()
java.awt.dnd.DragSour ce
252 Chapter 12 – The java.awt.dnd Package

DragSourceDragEvent
Ja va 1.2
java.awt.dnd
serializable event
This event type is ﬁred by a DragSourceContext and passed to the dragEnter(), dragOver(),
dragExit(), and dragActionChanged() methods of a DragSourceListener. These methods may
use the notiﬁcation as an opportunity to perfor m drag-over animation effects, by chang-
ing the cursor, for example.
isLocalDropTarget() speciﬁes whether the drop target currently under the cursor is in the
same Java VM as the drag source. getUserAction() retur ns the current drag action selected
by the user. This is usually a function of the modiﬁer keys the user is holding down;
these modiﬁers are available from getGestureModiﬁers(). getTargetActions() retur ns a bit mask
of the actions that the drop target can support, and getDropAction() is the intersection of
the user action with the set of target actions.
public class DragSourceDragEvent extends DragSourceEvent {
// Public Constructors
public DragSourceDragEvent(DragSourceContext dsc, int dropAction, int actions, int modiﬁers);
// Property Accessor Methods (by property name)
public int getDropAction();
public int getGestureModiﬁers();
public int getTargetActions();
public int getUserAction();
}
Hierar chy: Object→java.util.EventObject(Serializable)→DragSourceEvent→DragSourceDragEvent
Passed To: DragSourceContext.{dragEnter(), dragOver(), dropActionChanged()},
DragSourceListener.{dragEnter(), dragOver(), dropActionChanged()}
DragSourceDropEvent
Ja va 1.2
java.awt.dnd
serializable event
This event type is ﬁred by the DragSourceContext and is passed to the dragDropEnd()
method of a DragSourceListener to signify that the drag-and-drop operation is complete.
getDropSuccess() retur ns tr ue if the drop occurs and the data is successfully transferred. It
retur ns false if the drag is cancelled, if the drop is perfor med over an invalid drop tar-
get, or if the data transfer is not successful. getDropAction() retur ns the action (see DnD-
Constants) that is actually perfor med. The user’s selected action may change during the
drag, so this value may not be the same as the initially selected action.
public class DragSourceDropEvent extends DragSourceEvent {
// Public Constructors
public DragSourceDropEvent(DragSourceContext dsc);
public DragSourceDropEvent(DragSourceContext dsc, int action, boolean success);
// Public Instance Methods
public int getDropAction();
public boolean getDropSuccess();
}
Hierar chy: Object→java.util.EventObject(Serializable)→DragSourceEvent→DragSourceDropEvent
Passed To: DragSourceContext.dragDropEnd(), DragSourceListener.dragDropEnd()
DragSourceEvent
Ja va 1.2
java.awt.dnd
serializable event
This class is the superclass of event types ﬁred by a DragSourceContext to notify a Drag-
SourceListener about events in the drag-and-drop process. Although applications typically
do not need to do so, they can call getDragSourceContext() or getSource() to obtain a
java.awt.dnd
java.awt.dnd.DragSour ceEvent
Chapter 12 – The java.awt.dnd Package
253

refer ence to the current DragSourceContext. This object can be used, for example, to per-
for m drag over animation effects by changing the current drag cursor. If you are writing
a DragSourceListener that handles drags on more than one component, you can determine
which component initiated the drag by calling getSource() to obtain a DragSourceContext
and then calling its getComponent() method.
See also DragSourceDragEvent and DragSourceDropEvent.
public class DragSourceEvent extends java.util.EventObject {
// Public Constructors
public DragSourceEvent(DragSourceContext dsc);
// Public Instance Methods
public DragSourceContext getDragSourceContext();
}
Hierar chy: Object→java.util.EventObject(Serializable)→DragSourceEvent
Subc lasses: DragSourceDragEvent, DragSourceDropEvent
Passed To: DragSourceContext.dragExit(), DragSourceListener.dragExit()
DragSourceListener
Ja va 1.2
java.awt.dnd
event listener
This interface is implemented by objects that allow data to be transferred through drag-
and-dr op and want to be notiﬁed about the progr ess of the drag-and-drop process. The
methods of this interface are invoked by a DragSourceContext at various interesting points
during the drag-and-drop. The methods are passed a DragSourceDragEvent or a DragSource-
DropEvent, both of which are subclasses of DragSourceEvent. The methods are:
dragDropEnd()
Invoked when the drag-and-drop operation is complete and has ended in success
or failure. This is the only method that is passed a DragSourceDropEvent, instead of a
DragSourceDragEvent. If the drag is of type ACTION_MOVE and the getDropSuccess()
method of DragSourceDropEvent retur ns tr ue, the DragSourceListener knows that the
data has been safely transferred to the drop target and should delete the source
copy of that data.
dragEnter()
Called when the drag cursor has entered an active drop target that has indicated
an interest in and capability to receive a drop. This method should initiate any
custom drag over effects.
dragExit()
Invoked when the drag cursor has left a receptive drop target. This method should
ter minate any custom drag over effects.
dragOver()
Called continuously while the mouse remains within a receptive drop target.
Because this method is called very frequently, it should not perfor m any lengthy
operations.
dropActionChanged()
Invoked if the user changes his desired drop action, typically by changing the key-
board modiﬁers she is holding down. If you are displaying a custom drag cursor,
this method may need to modify the currently displayed cursor.
java.awt.dnd.DragSour ceEvent
254 Chapter 12 – The java.awt.dnd Package

public abstract interface DragSourceListener extends java.util.EventListener {
// Public Instance Methods
public abstract void dragDropEnd(DragSourceDropEvent dsde);
public abstract void dragEnter(DragSourceDragEvent dsde);
public abstract void dragExit(DragSourceEvent dse);
public abstract void dragOver(DragSourceDragEvent dsde);
public abstract void dropActionChanged(DragSourceDragEvent dsde);
}
Hierar chy: (DragSourceListener(java.util.EventListener))
Implementations: DragSourceContext
Passed To: DragGestureEvent.star tDrag(), DragSource.{createDragSourceContext(), startDrag()},
DragSourceContext.{addDragSourceListener(), DragSourceContext(), removeDragSourceListener()}
DropTarget
Ja va 1.2
java.awt.dnd
serializable
This class holds the state necessary for a Component to accept drops. Create a DropTarget
by specifying the Component with which it is to be associated and the DropTargetListener
that responds to interesting events during a drag-and-drop operation. You may option-
ally specify a bit mask of drop actions that this DropTarget can support and a boolean
value that indicates whether the DropTarget is currently active. If you do not specify these
optional values, your DropTarget supports ACTION_COPY_OR_MOVE and is active.
Once you have created a DropTarget, you often never have to do anything else with it.
The DropTarget() constructor automatically connects the DropTarget with the Component it
serves and the DropTargetListener it notiﬁes, so you do not have to perfor m any of the
registration yourself. In fact, the only time you typically need to use the DropTarget object
you create is if you need to activate or deactivate it with setActive().
public class DropTarget implements DropTargetListener, Serializable {
// Public Constructors
public DropTarget();
public DropTarget(Component c, DropTargetListener dtl);
public DropTarget(Component c, int ops, DropTargetListener dtl);
public DropTarget(Component c, int ops, DropTargetListener dtl, boolean act);
public DropTarget(Component c, int ops, DropTargetListener dtl, boolean act, java.awt.datatransfer.FlavorMap fm);
// Inner Classes
protected static class DropTargetAutoScroller implements java.awt.event.ActionListener ;
// Event Registration Methods (by event name)
synchronized
public void addDropTargetListener(DropTargetListener dtl)
throws java.util.TooManyListenersException;
synchronized
public void removeDropTargetListener(DropTargetListener dtl);
// Property Accessor Methods (by property name)
synchronized default:true
public boolean isActive();
synchronized
public void setActive(boolean isActive);
synchronized default:null
public Component getComponent();
synchronized
public void setComponent(Component c);
synchronized default:3
public int getDefaultActions();
synchronized
public void setDefaultActions(int ops);
public DropTargetContext getDropTargetContext();
default:SystemFlavorMap
public java.awt.datatransfer.FlavorMap getFlavorMap();
public void setFlavorMap(java.awt.datatransfer.FlavorMap fm);
// Public Instance Methods
public void addNotify(java.awt.peer.ComponentPeer peer);
public void removeNotify(java.awt.peer.ComponentPeer peer);
java.awt.dnd
java.awt.dnd.DropTarget
Chapter 12 – The java.awt.dnd Package
255

// Methods Implementing DropTargetListener
synchronized
public void dragEnter(DropTargetDragEvent dtde);
synchronized
public void dragExit(DropTargetEvent dte);
synchronized
public void dragOver(DropTargetDragEvent dtde);
synchronized
public void drop(DropTargetDropEvent dtde);
public void dropActionChanged(DropTargetDragEvent dtde);
// Protected Instance Methods
protected void clearAutoscroll();
protected DropTarget.DropTargetAutoScroller createDropTargetAutoScroller(Component c, Point p);
protected DropTargetContext createDropTargetContext();
protected void initializeAutoscrolling(Point p);
protected void updateAutoscroll(Point dragCursorLocn);
}
Hierar chy: Object→DropTarget(DropTargetListener(java.util.EventListener), Serializable)
Passed To: Component.setDropTarget(), java.awt.dnd.peer.DropTargetPeer.{addDropTarget(),
removeDropTarget()}
Retur ned By: Component.getDropTarget(), DropTargetContext.getDropTarget(),
java.awt.dnd.peer.DropTargetContextPeer.getDropTarget()
DropTarget.DropTargetAutoScroller
Ja va 1.2
java.awt.dnd
This protected inner class implements autoscrolling behavior for a drop target. If the
dr op target is associated with a component that implements Autoscroll, this class invokes
the autoscroll() method of that component as appropriate. Applications never need to
use this class directly. Applications that want to override the default autoscrolling
behavior can subclass this class and override the createDropTargetAutoScroller() method of
DropTarget to retur n an instance of the subclass.
protected static class DropTarget.DropTargetAutoScroller implements java.awt.event.ActionListener {
// Protected Constructors
protected DropTargetAutoScroller(Component c, Point p);
// Methods Implementing ActionListener
synchronized
public void actionPerfor med(java.awt.e vent.ActionEvent e);
// Protected Instance Methods
protected void stop();
synchronized
protected void updateLocation(Point newLocn);
}
Retur ned By: DropTarget.createDropTargetAutoScroller()
DropTargetContext
Ja va 1.2
java.awt.dnd
This class contains state information about a drag operation currently in progr ess above
a DropTarget. The DropTargetContext is responsible for communicating with the native drag-
and-dr op system of the underlying platform and relaying drag-and-drop events from
that native system to the DropTargetListener.
Although this is an important class, it does its work internally, and application-level
code does not typically need to use it. DropTargetContext does deﬁne some important
methods, such as acceptDrag() and acceptDrop(), but these are typically invoked through
the utility methods of DropTargetDragEvent and DropTargetDropEvent. If you ever do need to
use a DropTargetContext dir ectly, it is available from any DropTargetEvent.
java.awt.dnd.DropTarget
256 Chapter 12 – The java.awt.dnd Package

public class DropTargetContext {
// No Constructor
// Inner Classes
protected class Tr ansferableProxy implements java.awt.datatransfer.Transferable;
// Public Instance Methods
synchronized
public void addNotify(java.awt.dnd.peer.DropTargetContextPeer dtcp);
public void dropComplete(boolean success) throws InvalidDnDOperationException;
public Component getComponent();
public DropTarget getDropTarget();
synchronized
public void removeNotify();
// Protected Instance Methods
protected void acceptDrag(int dragOperation);
protected void acceptDrop(int dropOperation);
protected java.awt.datatransfer.Transferable createTransferableProxy(java.awt.datatransfer.Transferable t,
boolean local);
protected java.awt.datatransfer.DataFlavor[ ] getCur rentDataFlavors();
protected java.util.List getCur rentDataFlavorsAsList();
protected int getTargetActions();
synchronized
protected java.awt.datatransfer.Transferable getTransferable() throws
InvalidDnDOperationException;
protected boolean isDataFlavorSuppor ted(java.awt.datatransfer.DataFlavor df);
protected void rejectDrag();
protected void rejectDrop();
protected void setTargetActions(int actions);
}
Passed To: DropTargetDragEvent.DropTargetDragEvent(), DropTargetDropEvent.DropTargetDropEvent(),
DropTargetEvent.DropTargetEvent()
Retur ned By: DropTarget.{createDropTargetContext(), getDropTargetContext()},
DropTargetEvent.getDropTargetContext()
Type Of: DropTargetEvent.context
DropTargetContext.TransferableProxy
Ja va 1.2
java.awt.dnd
This protected inner class is used by the protected createTransferableProxy() method of
DropTargetContext. Applications never need to use this class. This class is not deﬁned by
the JFC drag-and-drop speciﬁcation and its inclusion in the public API of java.awt.dnd
was probably unintentional.
protected class DropTargetContext.TransferableProxy implements java.awt.datatransfer.Transferable {
// No Constructor
// Methods Implementing Transferable
synchronized
public Object getTransferData(java.awt.datatransfer.DataFlavor df)
throws java.awt.datatransfer.Unsuppor tedFlavorException, java.io.IOException;
synchronized
public java.awt.datatransfer.DataFlavor[ ] getTransferDataFlavors();
synchronized
public boolean isDataFlavorSuppor ted(java.awt.datatransfer.DataFlavor ﬂavor);
// Protected Instance Fields
protected boolean isLocal;
protected java.awt.datatransfer.Transferable transferable;
}
DropTargetDragEvent
Ja va 1.2
java.awt.dnd
serializable event
This event is ﬁred by a DropTargetContext and passed to the dragEnter(), dragOver(), and
dropActionChanged() methods of a DropTargetListener. Each of these methods should use
java.awt.dnd
java.awt.dnd.DropTargetDragEvent
Chapter 12 – The java.awt.dnd Package
257

getDropAction(), getCur rentDataFlavors(), and related methods to check whether the drop tar-
get knows how to handle the drag action and is able to interpret the data formats
of fered. If so, the method should call acceptDrag(). If not, it should call rejectDrag(). See
DropTargetListener for further details.
public class DropTargetDragEvent extends DropTargetEvent {
// Public Constructors
public DropTargetDragEvent(DropTargetContext dtc, Point cursorLocn, int dropAction, int srcActions);
// Property Accessor Methods (by property name)
public java.awt.datatransfer.DataFlavor[ ] getCur rentDataFlavors();
public java.util.List getCur rentDataFlavorsAsList();
public int getDropAction();
public Point getLocation();
public int getSourceActions();
// Public Instance Methods
public void acceptDrag(int dragOperation);
public boolean isDataFlavorSuppor ted(java.awt.datatransfer.DataFlavor df);
public void rejectDrag();
}
Hierar chy: Object→java.util.EventObject(Serializable)→DropTargetEvent→DropTargetDragEvent
Passed To: DropTarget.{dragEnter(), dragOver(), dropActionChanged()}, DropTargetListener.{dragEnter(),
dragOver(), dropActionChanged()}
DropTargetDropEvent
Ja va 1.2
java.awt.dnd
serializable event
This event is ﬁred by a DropTargetContext and delivered to the drop() method of a DropTar-
getListener. This method should call getDropAction() to ensure that it is able to perfor m the
requested action. It should also call getCur rentDataFlavors() or isDataFlavorSuppor ted() to
ensur e that it can interpret the data that is transferred. If it cannot perfor m the action or
interpr et the data, it should call rejectDrag() and retur n.
If the DropTargetListener can perfor m the action and interpret the data, it should accept
the drop. It does this in a four-step process. First, it calls acceptDrop() to signal that it
accepts the drop. Second, it calls getTransferable() to obtain a java.awt.datatransfer.Transferable
object. Third, it calls the getTransferData() method of Transferable to actually transfer the
data.
Finally, if the data transfer fails for any reason, the DropTargetListener should pass false to
the dropComplete() method of the DropTargetDropEvent, indicating that the drop action is
complete but that it was not successful. If the data transfer is successful and the data
has been safely and completely transferred, the drop() method should pass tr ue to the
dropComplete() method. This notiﬁes the system that the data has been successfully trans-
ferr ed. The notiﬁcation is passed on to the DragSourceListener, which can then complete
its part of the action. For example, if the action is ACTION_MOVE, the DragSourceListener
deletes its copy of the data once it receives notiﬁcation that the DropTargetListener has
successfully copied it.
public class DropTargetDropEvent extends DropTargetEvent {
// Public Constructors
public DropTargetDropEvent(DropTargetContext dtc, Point cursorLocn, int dropAction, int srcActions);
public DropTargetDropEvent(DropTargetContext dtc, Point cursorLocn, int dropAction, int srcActions,
boolean isLocal);
// Property Accessor Methods (by property name)
public java.awt.datatransfer.DataFlavor[ ] getCur rentDataFlavors();
public java.util.List getCur rentDataFlavorsAsList();
public int getDropAction();
java.awt.dnd.DropTargetDragEvent
258 Chapter 12 – The java.awt.dnd Package

public boolean isLocalTransfer();
public Point getLocation();
public int getSourceActions();
public java.awt.datatransfer.Transferable getTransferable();
// Public Instance Methods
public void acceptDrop(int dropAction);
public void dropComplete(boolean success);
public boolean isDataFlavorSuppor ted(java.awt.datatransfer.DataFlavor df);
public void rejectDrop();
}
Hierar chy: Object→java.util.EventObject(Serializable)→DropTargetEvent→DropTargetDropEvent
Passed To: DropTarget.drop(), DropTargetListener.drop()
DropTargetEvent
Ja va 1.2
java.awt.dnd
serializable event
This class is the superclass of both DropTargetDragEvent and DropTargetDropEvent. getDropTar-
getContext() retur ns the DropTargetContext object that generated the event, and getSource()
retur ns the corresponding DropTarget object. Applications rarely need to use these meth-
ods, however.
public class DropTargetEvent extends java.util.EventObject {
// Public Constructors
public DropTargetEvent(DropTargetContext dtc);
// Public Instance Methods
public DropTargetContext getDropTargetContext();
// Protected Instance Fields
protected DropTargetContext context;
}
Hierar chy: Object→java.util.EventObject(Serializable)→DropTargetEvent
Subc lasses: DropTargetDragEvent, DropTargetDropEvent
Passed To: DropTarget.dragExit(), DropTargetListener.dragExit()
DropTargetListener
Ja va 1.2
java.awt.dnd
event listener
This interface is implemented by objects that want to be able to receive dropped data.
Its methods are invoked by a DropTargetContext at various interesting points in the drag-
and-dr op pr ocess. The methods of this interface are passed a DropTargetEvent or one of
its subclasses, a DropTargetDragEvent or a DropTargetDropEvent. The methods are:
dragEnter()
Invoked when a drag enters the Component associated with the DropTargetListener.
This method should call getDropAction() to determine whether it can perfor m the
requested action and either getCur rentDataFlavors() or isDataFlavorSuppor ted() to deter-
mine whether it can interpret the data that is being offer ed. If so, it should call the
acceptDrag() method of the event object. If not, it should call the rejectDrag() method.
If this method accepts the drag, it may also perfor m or initiate custom graphical
drag under effects on the associated Component. These effects provide feedback to
the user that the drop target Component is interested in receiving the drop.
java.awt.dnd
java.awt.dnd.DropTargetListener
Chapter 12 – The java.awt.dnd Package
259

dragExit()
Called when a previously accepted drag leaves the DropTarget. If the dragEnter()
method perfor med any custom drag under effects, this method should undo them.
dragOver()
Invoked continuously while the mouse pointer remains over the DragTarget. In most
cases, this method need not do anything. If the DropTarget is a complex one that is
capable of accepting drags in some regions but not in other regions, this method
should behave like dragEnter() and call the acceptDrag() or rejectDrag() methods of the
event object to inform the system whether a drag is possible at the current loca-
tion. In this case, this method is also responsible for any custom drag under graph-
ical effects.
drop()
Called when data is dropped over the DropTarget. This method should determine
whether the DropTarget can accept the drop and call the acceptDrop() or rejectDrop()
method of the DropTargetDropEvent event object. If it accepts the drop, it must then
transfer the data, perfor m the requested action, and call dropComplete(). See DropTar-
getDropEvent for details on this process. This method need not undo your drag
under effects; the dragExit() method is invoked for this purpose.
dropActionChanged()
Invoked when the user changes the requested action in mid-drag. This typically
occurs if the user changes the modiﬁer keys currently held down. This method
should behave like dragEnter() to evaluate whether the drop target can perfor m the
requested action on the offer ed data and then call acceptDrag() or rejectDrag() and
begin or end custom drag under effects, as appropriate.
public abstract interface DropTargetListener extends java.util.EventListener {
// Public Instance Methods
public abstract void dragEnter(DropTargetDragEvent dtde);
public abstract void dragExit(DropTargetEvent dte);
public abstract void dragOver(DropTargetDragEvent dtde);
public abstract void drop(DropTargetDropEvent dtde);
public abstract void dropActionChanged(DropTargetDragEvent dtde);
}
Hierar chy: (DropTargetListener(java.util.EventListener))
Implementations: DropTarget
Passed To: DropTarget.{addDropTargetListener(), DropTarget(), removeDropTargetListener()}
InvalidDnDOperationException
Ja va 1.2
java.awt.dnd
serializable unchecked
Signals that a misconﬁguration or error of some sort prevents a drag-and-drop opera-
tion from completing normally. This exception is thrown by methods throughout the
java.awt.dnd package.
public class InvalidDnDOperationException extends java.lang.IllegalStateException {
// Public Constructors
public InvalidDnDOperationException();
public InvalidDnDOperationException(String msg);
}
Hierar chy: Object→Throwable(Serializable)→Exception→RuntimeException→
java.lang .IllegalStateException→InvalidDnDOperationException
java.awt.dnd.DropTargetListener
260 Chapter 12 – The java.awt.dnd Package

Thrown By: Toolkit.createDragSourceContextPeer(), DragGestureEvent.star tDrag(), DragSource.star tDrag(),
DropTargetContext.{dropComplete(), getTransferable()}, java.awt.dnd.peer.DragSourceContextPeer.{setCursor(),
star tDrag()}, java.awt.dnd.peer.DropTargetContextPeer.getTransferable()
MouseDragGestureRecognizer
Ja va 1.2
java.awt.dnd
This class is a DragGestureRecognizer that is designed to recognize mouse gestures (as
opposed, for example, to keyboard gestures). Like DragGestureRecognizer, this is an
abstract class and cannot be instantiated. The createDefaultDragGestureRecognizer() method
of DragSource retur ns a platfor m-speciﬁc concr ete subclass of this class. Most applica-
tions do not need to use this class. Applications that want to support custom drag-and-
dr op gestur es may ﬁnd it convenient to subclass this class.
public abstract class MouseDragGestureRecognizer extends DragGestureRecognizer
implements java.awt.event.MouseListener, java.awt.e vent.MouseMotionListener {
// Protected Constructors
protected MouseDragGestureRecognizer(DragSource ds);
protected MouseDragGestureRecognizer(DragSource ds, Component c);
protected MouseDragGestureRecognizer(DragSource ds, Component c, int act);
protected MouseDragGestureRecognizer(DragSource ds, Component c, int act, DragGestureListener dgl);
// Methods Implementing MouseListener
empty
public void mouseClicked(java.awt.e vent.MouseEvent e);
empty
public void mouseEntered(java.awt.e vent.MouseEvent e);
empty
public void mouseExited(java.awt.e vent.MouseEvent e);
empty
public void mousePressed(java.awt.e vent.MouseEvent e);
empty
public void mouseReleased(java.awt.e vent.MouseEvent e);
// Methods Implementing MouseMotionListener
empty
public void mouseDragged(java.awt.e vent.MouseEvent e);
empty
public void mouseMoved(java.awt.e vent.MouseEvent e);
// Protected Methods Overriding DragGestureRecognizer
protected void registerListeners();
protected void unregisterListeners();
}
Hierar chy: Object→DragGestureRecognizer→
MouseDragGestureRecognizer(java.awt.event.MouseListener(java.util.EventListener),
java.awt.event.MouseMotionListener(java.util.EventListener))
java.awt.dnd
java.awt.dnd.MouseDragGestureRecognizer
Chapter 12 – The java.awt.dnd Package
261

CHAPTER 13
The java.awt.dnd.peer Package
The interfaces of the java.awt.dnd.peer package precisely specify the native drag-and-
dr op capabilities that are requir ed to implement the java.awt.dnd package. Appli-
cation-level code never needs to use this package. Figure 13-1 shows the class
hierarchy of this package.
INTERFACE
KEY
java.awt.dnd.peer
DragSourceContextPeer
DropTargetContextPeer
DropTargetPeer
Figur e 13−1: The java.awt.dnd.peer package
DragSourceContextPeer
Ja va 1.2
java.awt.dnd.peer
This interface deﬁnes methods that the java.awt.dnd.DragSourceContext class uses to com-
municate with the underlying native drag-and-drop subsystem. Application-level code
never uses this interface.
public abstract interface DragSourceContextPeer {
// Public Instance Methods
public abstract Cursor getCursor();
public abstract void setCursor(Cursor c) throws InvalidDnDOperationException;
public abstract void star tDrag(DragSourceContext dsc, Cursor c, Image dragImage, Point imageOffset)
throws InvalidDnDOperationException;
public abstract void transferablesFlavorsChanged();
}
262

Passed To: DragSource.createDragSourceContext(), DragSourceContext.DragSourceContext()
Retur ned By: Toolkit.createDragSourceContextPeer()
DropTargetContextPeer
Ja va 1.2
java.awt.dnd.peer
This interface deﬁnes methods that the java.awt.dnd.DropTargetContext class uses to commu-
nicate with the underlying native drag-and-drop subsystem. Application-level code
never uses this interface.
public abstract interface DropTargetContextPeer {
// Property Accessor Methods (by property name)
public abstract DropTarget getDropTarget();
public abstract int getTargetActions();
public abstract void setTargetActions(int actions);
public abstract java.awt.datatransfer.Transferable getTransferable() throws InvalidDnDOperationException;
public abstract boolean isTransferableJVMLocal();
public abstract java.awt.datatransfer.DataFlavor[ ] getTransferDataFlavors();
// Public Instance Methods
public abstract void acceptDrag(int dragAction);
public abstract void acceptDrop(int dropAction);
public abstract void dropComplete(boolean success);
public abstract void rejectDrag();
public abstract void rejectDrop();
}
Passed To: DropTargetContext.addNotify()
DropTargetPeer
Ja va 1.2
java.awt.dnd.peer
This interface deﬁnes methods that the java.awt.dnd.DropTarget class uses to communicate
with the underlying native drag-and-drop subsystem. Application-level code never uses
this interface.
public abstract interface DropTargetPeer {
// Public Instance Methods
public abstract void addDropTarget(DropTarget dt);
public abstract void removeDropTarget(DropTarget dt);
}
java.awt.
dnd.peer
java.awt.dnd.peer.DropTargetPeer
Chapter 13 – The java.awt.dnd.peer Package
263

CHAPTER 14
The java.awt.event Package
The java.awt.event package deﬁnes classes and interfaces used for event handling in
the AWT and Swing. The members of this package fall into three categories:
Events
The classes with names ending in “Event” repr esent speciﬁc types of events,
generated by the AWT or by one of the AWT or Swing components.
Listeners
The interfaces in this package are all event listeners; their names end with
“Listener”. These interfaces deﬁne the methods that must be implemented by
any object that wants to be notiﬁed when a particular event occurs. Note that
ther e is a Listener inter face for each Event class.
Adapters
Each of the classes with a name ending in “Adapter” provides a no-op imple-
mentation for an event listener interface that deﬁnes more than one method.
When you are inter ested in only a single method of an event listener inter-
face, it is easier to subclass an Adapter class than to implement all of the meth-
ods of the corresponding Listener inter face.
Figur e 14-1 shows the class hierarchy of this package.
The Swing user-inter face components use some of these event classes and inter-
faces and also deﬁne others in the javax.swing .event package. The java.beans package
also deﬁnes a few commonly used event classes and listener interfaces. Note that
this package is part of the Java 1.1 event model. In Java 1.0, events were repr e-
sented by the java.awt.Event class. See Chapter 2, Swing and AWT Architectur e, for
an introduction to events and event handling.
264

ABSTRACT CLASS
extends
implements
KEY
CLASS
INTERFACE
Object
java.lang
ActionEvent
AWTEvent
ComponentListener
ContainerListener
FocusListener
KeyListener
MouseListener
MouseMotionListener
TextListener
ItemListener
WindowListener
java.awt.event
ActionListener
AdjustmentListener
java.awt
ComponentAdapter
ContainerAdapter
FocusAdapter
KeyAdapter
MouseAdapter
MouseMotionAdapter
WindowAdapter
AdjustmentEvent
ComponentEvent
ItemEvent
InputMethodEvent
ContainerEvent
FocusEvent
InputEvent
PaintEvent
WindowEvent
KeyEvent
MouseEvent
EventListener
java.io
Serializable
java.util
EventObject
AWTEventListener
InputMethodListener
InvocationEvent
TextEvent
ActiveEvent
Figur e 14−1: The java.awt.event package
ActionEvent
Ja va 1.1
java.awt.e vent
serializable event PJ1.1
An object of this class repr esents a high-level action event generated by an AWT com-
ponent. Instead of repr esenting a dir ect user event, such as a mouse or keyboard event,
ActionEvent repr esents some sort of action perfor med by the user on an AWT
component.
The getID() method retur ns the type of action that has occurred. For AWT-generated
action events, this type is always ActionEvent.ACTION_PERFORMED; custom components can
generate action events of other types.
java.awt.
event
java.awt.event.ActionEvent
Chapter 14 – The java.awt.event Package
265

The getActionCommand() method retur ns a String that serves as a kind of name for the
action that the event repr esents. The Button and MenuItem components have a setAction-
Command() method that allows the programmer to specify an action command string to
be included with any action events generated by those components. It is this value that
is retur ned by the getActionCommand() method. When more than one Button or other
component notiﬁes the same ActionListener, you can use getActionCommand() to help deter-
mine the appropriate response to the event. This is generally a better technique than
using the source object retur ned by getSource(). If no action command string is explicitly
set, getActionCommand() retur ns the label of the Button or MenuItem. Inter nationalized pr o-
grams should not rely on these labels being constant.
getModiﬁers() retur ns a value that indicates the keyboard modiﬁers that were in effect
when the action event was triggered. Use the various _MASK constants, along with the &
operator, to decode this value.
public class ActionEvent extends AWTEvent {
// Public Constructors
public ActionEvent(Object source, int id, String command);
public ActionEvent(Object source, int id, String command, int modiﬁers);
// Public Constants
=1001
public static ﬁnal int ACTION_FIRST;
=1001
public static ﬁnal int ACTION_LAST;
=1001
public static ﬁnal int ACTION_PERFORMED;
=8
public static ﬁnal int ALT_MASK;
=2
public static ﬁnal int CTRL_MASK;
=4
public static ﬁnal int META_MASK;
=1
public static ﬁnal int SHIFT_MASK;
// Public Instance Methods
public String getActionCommand();
public int getModiﬁers();
// Public Methods Overriding AWTEvent
public String paramString();
}
Hierar chy: Object→java.util.EventObject(Serializable)→AWTEvent→ActionEvent
Passed To: Too many methods to list.
ActionListener
Ja va 1.1
java.awt.e vent
event listener PJ1.1
This interface deﬁnes the method that an object must implement to listen for action
events on AWT components. When an ActionEvent occurs, an AWT component notiﬁes
its register ed ActionListener objects by invoking their actionPerfor med() methods.
public abstract interface ActionListener extends java.util.EventListener {
// Public Instance Methods
public abstract void actionPerfor med(ActionEvent e);
}
Hierar chy: (ActionListener(java.util.EventListener))
Implementations: AWTEventMulticaster, java.awt.dnd.DropTarget.DropTargetAutoScroller,
javax.swing .Action, javax.swing .DefaultCellEditor.EditorDelegate, javax.swing .JComboBox,
javax.swing .ToolT ipManager.insideT imerAction, javax.swing .ToolT ipManager.outsideT imerAction,
javax.swing .ToolT ipManager.stillInsideT imerAction, javax.swing .text.html.FormV iew,
javax.swing .tree.DefaultTreeCellEditor
Passed To: Too many methods to list.
java.awt.event.ActionEvent
266 Chapter 14 – The java.awt.event Package

Retur ned By: AWTEventMulticaster.{add(), remove()}, javax.swing .AbstractButton.createActionListener(),
javax.swing .JComponent.getActionForKeyStroke()
Type Of: javax.swing .AbstractButton.actionListener
AdjustmentEvent
Ja va 1.1
java.awt.e vent
serializable event PJ1.1
An event of this type indicates that an adjustment has been made to an Adjustable
object — usually, this means that the user has interacted with a Scrollbar component.
The getValue() method retur ns the new value of the Adjustable object. This is usually the
most important piece of information stored in the event. getAdjustable() retur ns the
Adjustable object that was the source of the event. It is a convenient alternative to
the inherited getSource() method.
The getID() method retur ns the type of an AdjustmentEvent. The standard AWT compo-
nents 
only 
generate 
adjustment 
events 
of 
the 
type
AdjustmentEvent.ADJUST-
MENT_VALUE_CHANGED. Ther e ar e several types of adjustments that can be made to an
Adjustable object, however, and the getAdjustmentType() method retur ns one of ﬁve con-
stants to indicate which type has occurred. UNIT_INCREMENT indicates that the Adjustable
value has been incremented by one unit, as in a scroll-line-down operation.
UNIT_DECREMENT indicates the opposite: scroll-line-up. BLOCK_INCREMENT and BLOCK_DEC-
REMENT indicate that the Adjustable object has been incremented or decremented by mul-
tiple units, as in a scroll-page-down or scroll-page-up operation. Finally, the TRACK
constant indicates that the Adjustable value has been set to an absolute value unrelated
to its previous value, as when the user drags a scrollbar to a new position.
public class AdjustmentEvent extends AWTEvent {
// Public Constructors
public AdjustmentEvent(Adjustable source, int id, int type, int value);
// Public Constants
=601
public static ﬁnal int ADJUSTMENT_FIRST;
=601
public static ﬁnal int ADJUSTMENT_LAST;
=601
public static ﬁnal int ADJUSTMENT_VALUE_CHANGED;
=3
public static ﬁnal int BLOCK_DECREMENT;
=4
public static ﬁnal int BLOCK_INCREMENT;
=5
public static ﬁnal int TRACK;
=2
public static ﬁnal int UNIT_DECREMENT;
=1
public static ﬁnal int UNIT_INCREMENT;
// Public Instance Methods
public Adjustable getAdjustable();
public int getAdjustmentType();
public int getValue();
// Public Methods Overriding AWTEvent
public String paramString();
}
Hierar chy: Object→java.util.EventObject(Serializable)→AWTEvent→AdjustmentEvent
Passed To: AWTEventMulticaster.adjustmentValueChanged(), Scrollbar.processAdjustmentEvent(),
AdjustmentListener.adjustmentValueChanged()
AdjustmentListener
Ja va 1.1
java.awt.e vent
event listener PJ1.1
This interface deﬁnes the method that an object must implement to listen for adjust-
ment events on AWT components. When an AdjustmentEvent occurs, an AWT component
notiﬁes its register ed AdjustmentListener objects by invoking their adjustmentValueChanged()
methods.
java.awt.
event
java.awt.event.AdjustmentListener
Chapter 14 – The java.awt.event Package
267

public abstract interface AdjustmentListener extends java.util.EventListener {
// Public Instance Methods
public abstract void adjustmentValueChanged(AdjustmentEvent e);
}
Hierar chy: (AdjustmentListener(java.util.EventListener))
Implementations: AWTEventMulticaster
Passed To: Adjustable.{addAdjustmentListener(), removeAdjustmentListener()}, AWTEventMulticaster.{add(),
remove()}, Scrollbar.{addAdjustmentListener(), removeAdjustmentListener()},
javax.swing .JScrollBar.{addAdjustmentListener(), removeAdjustmentListener()}
Retur ned By: AWTEventMulticaster.{add(), remove()}
AWTEventListener
Ja va 1.2
java.awt.e vent
event listener
This interface is implemented by objects, such as GUI macro recorders, that want to be
notiﬁed of all AWT events that occur on Component and MenuComponent objects through-
out the system. Register an AWTEventListener with the addAWTEventListener() method of
Toolkit.
public abstract interface AWTEventListener extends java.util.EventListener {
// Public Instance Methods
public abstract void eventDispatched(AWTEvent event);
}
Hierar chy: (AWTEventListener(java.util.EventListener))
Passed To: Toolkit.{addAWTEventListener(), removeAWTEventListener()}
ComponentAdapter
Ja va 1.1
java.awt.e vent
event adapter PJ1.1
This class is a trivial implementation of ComponentListener; it provides empty bodies for
each of the methods of that interface. When you are not interested in all of these meth-
ods, it is often easier to subclass ComponentAdapter than it is to implement ComponentLis-
tener fr om scratch.
public abstract class ComponentAdapter implements ComponentListener {
// Public Constructors
public ComponentAdapter();
// Methods Implementing ComponentListener
empty
public void componentHidden(ComponentEvent e);
empty
public void componentMoved(ComponentEvent e);
empty
public void componentResized(ComponentEvent e);
empty
public void componentShown(ComponentEvent e);
}
Hierar chy: Object→ComponentAdapter(ComponentListener(java.util.EventListener))
Subc lasses: javax.swing .JViewpor t.ViewListener
ComponentEvent
Ja va 1.1
java.awt.e vent
serializable event PJ1.1
An event of this type serves as notiﬁcation that the source Component has been moved,
resized, shown, or hidden. Note that this event is a notiﬁcation only: the AWT handles
these Component operations internally, and the recipient of the event need take no
action itself.
java.awt.event.AdjustmentListener
268 Chapter 14 – The java.awt.event Package

getComponent() retur ns the component that was moved, resized, shown, or hidden. It is
simply a convenient alternative to getSource(). getID() retur ns one of four COMPONENT_
constants to indicate what operation was perfor med on the Component.
public class ComponentEvent extends AWTEvent {
// Public Constructors
public ComponentEvent(Component source, int id);
// Public Constants
=100
public static ﬁnal int COMPONENT_FIRST;
=103
public static ﬁnal int COMPONENT_HIDDEN;
=103
public static ﬁnal int COMPONENT_LAST;
=100
public static ﬁnal int COMPONENT_MOVED;
=101
public static ﬁnal int COMPONENT_RESIZED;
=102
public static ﬁnal int COMPONENT_SHOWN;
// Public Instance Methods
public Component getComponent();
// Public Methods Overriding AWTEvent
public String paramString();
}
Hierar chy: Object→java.util.EventObject(Serializable)→AWTEvent→ComponentEvent
Subc lasses: ContainerEvent, FocusEvent, InputEvent, PaintEvent, WindowEvent
Passed To: AWTEventMulticaster.{componentHidden(), componentMoved(), componentResized(),
componentShown()}, Component.processComponentEvent(), ComponentAdapter.{componentHidden(),
componentMoved(), componentResized(), componentShown()}, ComponentListener.{componentHidden(),
componentMoved(), componentResized(), componentShown()},
javax.swing .JViewpor t.ViewListener.componentResized()
ComponentListener
Ja va 1.1
java.awt.e vent
event listener PJ1.1
This interface deﬁnes the methods that an object must implement to listen for compo-
nent events on AWT components. When a ComponentEvent occurs, an AWT component
notiﬁes its register ed ComponentListener objects by invoking one of their methods. An
easy way to implement this interface is by subclassing the ComponentAdapter class.
public abstract interface ComponentListener extends java.util.EventListener {
// Public Instance Methods
public abstract void componentHidden(ComponentEvent e);
public abstract void componentMoved(ComponentEvent e);
public abstract void componentResized(ComponentEvent e);
public abstract void componentShown(ComponentEvent e);
}
Hierar chy: (ComponentListener(java.util.EventListener))
Implementations: AWTEventMulticaster, ComponentAdapter
Passed To: AWTEventMulticaster.{add(), remove()}, Component.{addComponentListener(),
removeComponentListener()}
Retur ned By: AWTEventMulticaster.{add(), remove()}
ContainerAdapter
Ja va 1.1
java.awt.e vent
event adapter PJ1.1
This class is a trivial implementation of ContainerListener; it provides empty bodies for
each of the methods of that interface. When you are not interested in all of these meth-
ods, it is often easier to subclass ContainerAdapter than it is to implement ContainerListener
fr om scratch.
java.awt.
event
java.awt.event.ContainerAdapter
Chapter 14 – The java.awt.event Package
269

public abstract class ContainerAdapter implements ContainerListener {
// Public Constructors
public ContainerAdapter();
// Methods Implementing ContainerListener
empty
public void componentAdded(ContainerEvent e);
empty
public void componentRemoved(ContainerEvent e);
}
Hierar chy: Object→ContainerAdapter(ContainerListener(java.util.EventListener))
ContainerEvent
Ja va 1.1
java.awt.e vent
serializable event PJ1.1
An event of this type serves as notiﬁcation that the source Container has had a child
added to it or removed from it. Note that this event is a notiﬁcation only; the AWT adds
or removes the child internally, and the recipient of this event need take no action
itself.
getChild() retur ns the child Component that was added or removed, and getContainer()
retur ns the Container to which it was added or from which it was removed. getContainer()
is simply a convenient alternative to getSource(). getID() retur ns the constant COMPO-
NENT_ADDED or COMPONENT_REMOVED to indicate whether the speciﬁed child was added
or removed.
public class ContainerEvent extends ComponentEvent {
// Public Constructors
public ContainerEvent(Component source, int id, Component child);
// Public Constants
=300
public static ﬁnal int COMPONENT_ADDED;
=301
public static ﬁnal int COMPONENT_REMOVED;
=300
public static ﬁnal int CONTAINER_FIRST;
=301
public static ﬁnal int CONTAINER_LAST;
// Public Instance Methods
public Component getChild();
public Container getContainer();
// Public Methods Overriding ComponentEvent
public String paramString();
}
Hierar chy: Object→java.util.EventObject(Serializable)→AWTEvent→ComponentEvent→ContainerEvent
Passed To: AWTEventMulticaster.{componentAdded(), componentRemoved()},
Container.processContainerEvent(), ContainerAdapter.{componentAdded(), componentRemoved()},
ContainerListener.{componentAdded(), componentRemoved()},
javax.swing .JComponent.AccessibleJComponent.AccessibleContainerHandler.{componentAdded(),
componentRemoved()}
ContainerListener
Ja va 1.1
java.awt.e vent
event listener PJ1.1
This interface deﬁnes the methods that an object must implement to listen for container
events on AWT components. When a ContainerEvent occurs, an AWT component notiﬁes
its register ed ContainerListener objects by invoking one of their methods. An easy way to
implement this interface is by subclassing the ContainerAdapter class.
public abstract interface ContainerListener extends java.util.EventListener {
// Public Instance Methods
public abstract void componentAdded(ContainerEvent e);
java.awt.event.ContainerAdapter
270 Chapter 14 – The java.awt.event Package

public abstract void componentRemoved(ContainerEvent e);
}
Hierar chy: (ContainerListener(java.util.EventListener))
Implementations: AWTEventMulticaster, ContainerAdapter,
javax.swing .JComponent.AccessibleJComponent.AccessibleContainerHandler
Passed To: AWTEventMulticaster.{add(), remove()}, Container.{addContainerListener(),
removeContainerListener()}
Retur ned By: AWTEventMulticaster.{add(), remove()}
Type Of: javax.swing .JComponent.AccessibleJComponent.accessibleContainerHandler
FocusAdapter
Ja va 1.1
java.awt.e vent
event adapter PJ1.1
This class is a trivial implementation of FocusListener; it provides empty bodies for each
of the methods of that interface. When you are not interested in all of these methods, it
is often easier to subclass FocusAdapter than it is to implement FocusListener fr om scratch.
public abstract class FocusAdapter implements FocusListener {
// Public Constructors
public FocusAdapter();
// Methods Implementing FocusListener
empty
public void focusGained(FocusEvent e);
empty
public void focusLost(FocusEvent e);
}
Hierar chy: Object→FocusAdapter(FocusListener(java.util.EventListener))
FocusEvent
Ja va 1.1
java.awt.e vent
serializable event PJ1.1
An event of this type indicates that a Component has gained or lost focus on a temporary
or permanent basis. Use the inherited getComponent() method to determine which com-
ponent has gained or lost focus. Use getID() to determine the type of focus event; it
retur ns FOCUS_GAINED or FOCUS_LOST.
When focus is lost, you can call isTemporar y() to determine whether it is a temporary loss
of focus. Temporary focus loss occurs when the window that contains the component
loses focus, for example, or when focus is temporarily diverted to a popup menu or a
scr ollbar. Similarly, you can also use isTemporar y() to determine whether focus is being
granted to a component on a temporary basis.
public class FocusEvent extends ComponentEvent {
// Public Constructors
public FocusEvent(Component source, int id);
public FocusEvent(Component source, int id, boolean temporary);
// Public Constants
=1004
public static ﬁnal int FOCUS_FIRST;
=1004
public static ﬁnal int FOCUS_GAINED;
=1005
public static ﬁnal int FOCUS_LAST;
=1005
public static ﬁnal int FOCUS_LOST;
// Public Instance Methods
public boolean isTemporar y();
// Public Methods Overriding ComponentEvent
public String paramString();
}
java.awt.
event
java.awt.event.FocusEvent
Chapter 14 – The java.awt.event Package
271

Hierar chy: Object→java.util.EventObject(Serializable)→AWTEvent→ComponentEvent→FocusEvent
Passed To: AWTEventMulticaster.{focusGained(), focusLost()}, Component.processFocusEvent(),
FocusAdapter.{focusGained(), focusLost()}, FocusListener.{focusGained(), focusLost()},
javax.swing .JComponent.processFocusEvent(), javax.swing .text.DefaultCaret.{focusGained(), focusLost()}
FocusListener
Ja va 1.1
java.awt.e vent
event listener PJ1.1
This interface deﬁnes the methods that an object must implement to listen for focus
events on AWT components. When a FocusEvent occurs, an AWT component notiﬁes its
register ed FocusListener objects by invoking one of their methods. An easy way to imple-
ment this interface is by subclassing the FocusAdapter class.
public abstract interface FocusListener extends java.util.EventListener {
// Public Instance Methods
public abstract void focusGained(FocusEvent e);
public abstract void focusLost(FocusEvent e);
}
Hierar chy: (FocusListener(java.util.EventListener))
Implementations: AWTEventMulticaster, FocusAdapter, javax.swing .text.DefaultCaret
Passed To: Too many methods to list.
Retur ned By: AWTEventMulticaster.{add(), remove()}
InputEvent
Ja va 1.1
java.awt.e vent
serializable event PJ1.1
This abstract class serves as the superclass for the raw user input event types MouseEvent
and KeyEvent. Use the inherited getComponent() method to determine in which component
the event occurred. Use getWhen() to obtain a timestamp for the event. Use getModiﬁers()
to determine which keyboard modiﬁer keys or mouse buttons were down when the
event occurred. You can decode the getModiﬁers() retur n value using the various _MASK
constants deﬁned by this class. The class also deﬁnes four convenience methods for
deter mining the state of keyboard modiﬁers.
As of Java 1.1, input events are deliver ed to the appropriate listener objects before they
ar e deliver ed to the AWT components themselves. If a listener calls the consume()
method of the event, the event is not passed on to the component. For example, if a
listener register ed on a Button consumes a mouse click, it prevents the button itself from
responding to that event. You can use isConsumed() to test whether some other listener
object has already consumed the event.
public abstract class InputEvent extends ComponentEvent {
// No Constructor
// Public Constants
=32
1.2 public static ﬁnal int ALT_GRAPH_MASK;
=8
public static ﬁnal int ALT_MASK;
=16
public static ﬁnal int BUTTON1_MASK;
=8
public static ﬁnal int BUTTON2_MASK;
=4
public static ﬁnal int BUTTON3_MASK;
=2
public static ﬁnal int CTRL_MASK;
=4
public static ﬁnal int META_MASK;
=1
public static ﬁnal int SHIFT_MASK;
// Property Accessor Methods (by property name)
public boolean isAltDown();
1.2 public boolean isAltGraphDown();
java.awt.event.FocusEvent
272 Chapter 14 – The java.awt.event Package

Overrides:AWTEvent
public boolean isConsumed();
public boolean isControlDown();
public boolean isMetaDown();
public int getModiﬁers();
public boolean isShiftDown();
public long getWhen();
// Public Methods Overriding AWTEvent
public void consume();
}
Hierar chy: Object→java.util.EventObject(Serializable)→AWTEvent→ComponentEvent→InputEvent
Subc lasses: KeyEvent, MouseEvent
Passed To: java.awt.dnd.DragGestureRecognizer.appendEvent()
Retur ned By: java.awt.dnd.DragGestureEvent.getTriggerEvent(),
java.awt.dnd.DragGestureRecognizer.getTriggerEvent()
InputMethodEvent
Ja va 1.2
java.awt.e vent
serializable event
Events of this type are sent from an input method to the text input component or text
composition window that is using the services of the input method. An InputMethodEvent
is generated each time the user makes an edit to the text that is being composed. Input
method details are usually hidden by text input components. Application-level code
should never have to use this class.
The getText() method retur ns a java.text.AttributedCharacterIterator that contains the current
input method text. getCommittedCharacterCount() speciﬁes how many characters of that
text have been fully composed and committed, so that they are ready to be integrated
into the text input component. The input method does not send these committed char-
acters again. Any characters retur ned by the iterator beyond the speciﬁed number of
committed characters are characters that are still undergoing composition and are not
ready to be integrated into the text input component. These characters may be
repeated in future InputMethodEvent objects, as the user continues to edit them.
public class InputMethodEvent extends AWTEvent {
// Public Constructors
public InputMethodEvent(Component source, int id, java.awt.font.TextHitInfo caret,
java.awt.font.TextHitInfo visiblePosition);
public InputMethodEvent(Component source, int id, java.text.AttributedCharacterIterator text,
int committedCharacterCount, java.awt.font.TextHitInfo caret,
java.awt.font.TextHitInfo visiblePosition);
// Public Constants
=1101
public static ﬁnal int CARET_POSITION_CHANGED;
=1100
public static ﬁnal int INPUT_METHOD_FIRST;
=1101
public static ﬁnal int INPUT_METHOD_LAST;
=1100
public static ﬁnal int INPUT_METHOD_TEXT_CHANGED;
// Property Accessor Methods (by property name)
public java.awt.font.TextHitInfo getCaret();
public int getCommittedCharacterCount();
Overrides:AWTEvent
public boolean isConsumed();
public java.text.AttributedCharacterIterator getText();
public java.awt.font.TextHitInfo getV isiblePosition();
// Public Methods Overriding AWTEvent
public void consume();
public String paramString();
}
java.awt.
event
java.awt.event.InputMethodEvent
Chapter 14 – The java.awt.event Package
273

Hierar chy: Object→java.util.EventObject(Serializable)→AWTEvent→InputMethodEvent
Passed To: AWTEventMulticaster.{caretPositionChanged(), inputMethodTextChanged()},
Component.processInputMethodEvent(), InputMethodListener.{caretPositionChanged(),
inputMethodTextChanged()}, javax.swing .text.JTextComponent.processInputMethodEvent()
InputMethodListener
Ja va 1.2
java.awt.e vent
event listener
This interface deﬁnes the methods that a text input component must deﬁne in order to
receive notiﬁcations from an input method. caretPositionChanged() is invoked when the
user has moved the editing cursor. inputMethodTextChanged() is invoked when the user has
edited text being composed by the input method.
Input method details are usually hidden by text input components. Application-level
code should never have to use or implement this interface.
public abstract interface InputMethodListener extends java.util.EventListener {
// Public Instance Methods
public abstract void caretPositionChanged(InputMethodEvent event);
public abstract void inputMethodTextChanged(InputMethodEvent event);
}
Hierar chy: (InputMethodListener(java.util.EventListener))
Implementations: AWTEventMulticaster
Passed To: AWTEventMulticaster.{add(), remove()}, Component.{addInputMethodListener(),
removeInputMethodListener()}, javax.swing .text.JTextComponent.addInputMethodListener()
Retur ned By: AWTEventMulticaster.{add(), remove()}
InvocationEvent
Ja va 1.2
java.awt.e vent
serializable event
An event of this type is not generated by an asynchronous external event, such as user
input. Instead, an InvocationEvent is placed on the event queue by the invokeLater() and
invokeAndWait()
methods of
EventQueue.
InvocationEvent
implements
java.awt.ActiveEvent,
which means that it is an event that knows how to dispatch itself, with its own dis-
patch() method. When an InvocationEvent reaches the front of the event queue, its dis-
patch() method is called, and this invokes the run() method of the Runnable object
speciﬁed when the InvocationEvent was created. This technique provides a simple
method for running arbitrary code from the event dispatch thread.
Applications need not be concerned with these details; they can simply use the invoke-
Later() and invokeAndWait() methods of EventQueue.
public class InvocationEvent extends AWTEvent implements ActiveEvent {
// Public Constructors
public InvocationEvent(Object source, Runnable runnable);
public InvocationEvent(Object source, Runnable runnable, Object notiﬁer, boolean catchExceptions);
// Protected Constructors
protected InvocationEvent(Object source, int id, Runnable runnable, Object notiﬁer, boolean catchExceptions);
// Public Constants
=1200
public static ﬁnal int INVOCATION_DEFAULT;
=1200
public static ﬁnal int INVOCATION_FIRST;
=1200
public static ﬁnal int INVOCATION_LAST;
// Public Instance Methods
public Exception getException();
java.awt.event.InputMethodEvent
274 Chapter 14 – The java.awt.event Package

// Methods Implementing ActiveEvent
public void dispatch();
// Public Methods Overriding AWTEvent
public String paramString();
// Protected Instance Fields
protected boolean catchExceptions;
protected Object notiﬁer;
protected Runnable runnable;
}
Hierar chy: Object→java.util.EventObject(Serializable)→AWTEvent→InvocationEvent(ActiveEvent)
ItemEvent
Ja va 1.1
java.awt.e vent
serializable event PJ1.1
An event of this type indicates that an item within an ItemSelectable component has had
its selection state changed. getItemSelectable() is a convenient alternative to getSource()
that retur ns the ItemSelectable object that originated the event. getItem() retur ns an object
that repr esents the item that was selected or deselected.
getID() retur ns the type of the ItemEvent. The standard AWT components always generate
item events of type ITEM_STATE_CHANGED. The getStateChange() method retur ns the new
selection state of the item: it retur ns one of the constants SELECTED or DESELECTED. (This
value can be misleading for Checkbox components that are part of a CheckboxGroup. If the
user attempts to deselect a selected component, a DESELECTED event is delivered, but
the CheckboxGroup immediately reselects the component to enforce its requir ement that
at least one Checkbox be selected at all times.)
public class ItemEvent extends AWTEvent {
// Public Constructors
public ItemEvent(ItemSelectable source, int id, Object item, int stateChange);
// Public Constants
=2
public static ﬁnal int DESELECTED;
=701
public static ﬁnal int ITEM_FIRST;
=701
public static ﬁnal int ITEM_LAST;
=701
public static ﬁnal int ITEM_STATE_CHANGED;
=1
public static ﬁnal int SELECTED;
// Public Instance Methods
public Object getItem();
public ItemSelectable getItemSelectable();
public int getStateChange();
// Public Methods Overriding AWTEvent
public String paramString();
}
Hierar chy: Object→java.util.EventObject(Serializable)→AWTEvent→ItemEvent
Passed To: AWTEventMulticaster.itemStateChanged(), Checkbox.processItemEvent(),
CheckboxMenuItem.processItemEvent(), Choice.processItemEvent(), java.awt.List.processItemEvent(),
ItemListener.itemStateChanged(), javax.swing .AbstractButton.fireItemStateChanged(),
javax.swing .DefaultButtonModel.fireItemStateChanged(),
javax.swing .DefaultCellEditor.EditorDelegate.itemStateChanged(),
javax.swing .JComboBox.fireItemStateChanged(),
javax.swing .JToggleButton.AccessibleJToggleButton.itemStateChanged()
java.awt.
event
java.awt.event.ItemEvent
Chapter 14 – The java.awt.event Package
275

ItemListener
Ja va 1.1
java.awt.e vent
event listener PJ1.1
This interface deﬁnes the method that an object must implement to listen for item
events on AWT components. When an ItemEvent occurs, an AWT component notiﬁes its
register ed ItemListener objects by invoking their itemStateChanged() methods.
public abstract interface ItemListener extends java.util.EventListener {
// Public Instance Methods
public abstract void itemStateChanged(ItemEvent e);
}
Hierar chy: (ItemListener(java.util.EventListener))
Implementations: AWTEventMulticaster, javax.swing .DefaultCellEditor.EditorDelegate,
javax.swing .JToggleButton.AccessibleJToggleButton
Passed To: Too many methods to list.
Retur ned By: AWTEventMulticaster.{add(), remove()}, javax.swing .AbstractButton.createItemListener()
Type Of: javax.swing .AbstractButton.itemListener
KeyAdapter
Ja va 1.1
java.awt.e vent
event adapter PJ1.1
This class is a trivial implementation of KeyListener; it provides empty bodies for each of
the methods of that interface. When you are not interested in all of these methods, it is
often easier to subclass KeyAdapter than it is to implement KeyListener fr om scratch.
public abstract class KeyAdapter implements KeyListener {
// Public Constructors
public KeyAdapter();
// Methods Implementing KeyListener
empty
public void keyPressed(KeyEvent e);
empty
public void keyReleased(KeyEvent e);
empty
public void keyTyped(KeyEvent e);
}
Hierar chy: Object→KeyAdapter(KeyListener(java.util.EventListener))
KeyEvent
Ja va 1.1
java.awt.e vent
serializable event PJ1.1
An event of this type indicates that the user has pressed or released a key on the key-
board. Call getID() to determine the particular type of key event that has occurred. The
constant KEY_PRESSED indicates that a key has been pressed, while the constant
KEY_RELEASED indicates that a key has been released. Not all keystrokes actually corre-
spond to or generate Unicode characters. Modiﬁer keys and function keys, for example,
do not correspond to characters. Furthermor e, for internationalized input, multiple
keystr okes ar e sometimes requir ed to generate a single character of input. Therefor e,
getID() retur ns a third constant, KEY_TYPED, to indicate a KeyEvent that actually contains a
character value.
For KEY_PRESSED and KEY_RELEASED key events, use getKeyCode() to obtain the virtual
keycode of the key that was pressed or released. KeyEvent deﬁnes a number of VK_ con-
stants that repr esent these virtual keys. Note that not all keys on all keyboards have
corr esponding constants in the KeyEvent class, and not all keyboards can generate all of
the virtual keycodes deﬁned by this class. As of Java 1.1, the VK_ constants for letter
keys, number keys, and some other keys have the same values as the ASCII encodings
of the letters and numbers. You should not rely on this to always be the case, however.
java.awt.event.ItemListener
276 Chapter 14 – The java.awt.event Package

If the key that was pressed or released corresponds directly to a Unicode character, you
can obtain that character by calling getKeyChar(). If ther e is not a corresponding Unicode
character, this method retur ns the constant CHAR_UNDEFINED. The isActionKey() method
retur ns tr ue if the key that was pressed or released does not have a corresponding
character.
For KEY_TYPED key events, use getKeyChar() to retur n the Unicode character that was
typed. If you call getKeyCode() for this type of key event, it retur ns VK_UNDEFINED.
See InputEvent for information on inherited methods you can use to obtain the keyboard
modiﬁers that were down during the event and other important methods. Use getCompo-
nent(), inherited from ComponentEvent, to deter mine over what component the event
occurr ed. The static method getKeyText() retur ns a (possibly localized) textual name for a
given keycode. The static method getKeyModiﬁersText() retur ns a (possibly localized) tex-
tual description for a set of modiﬁers.
KeyEvent has methods that allow you to change the keycode, key character, or modiﬁers
of an event. These methods, along with the consume() method, allow a KeyListener to per-
for m ﬁltering of key events before they are passed to the underlying AWT component.
public class KeyEvent extends InputEvent {
// Public Constructors
public KeyEvent(Component source, int id, long when, int modiﬁers, int keyCode);
public KeyEvent(Component source, int id, long when, int modiﬁers, int keyCode, char keyChar);
// Public Constants
=’\uFFFF’
public static ﬁnal char CHAR_UNDEFINED;
=400
public static ﬁnal int KEY_FIRST;
=402
public static ﬁnal int KEY_LAST;
=401
public static ﬁnal int KEY_PRESSED;
=402
public static ﬁnal int KEY_RELEASED;
=400
public static ﬁnal int KEY_TYPED;
=48
public static ﬁnal int VK_0;
=49
public static ﬁnal int VK_1;
=50
public static ﬁnal int VK_2;
=51
public static ﬁnal int VK_3;
=52
public static ﬁnal int VK_4;
=53
public static ﬁnal int VK_5;
=54
public static ﬁnal int VK_6;
=55
public static ﬁnal int VK_7;
=56
public static ﬁnal int VK_8;
=57
public static ﬁnal int VK_9;
=65
public static ﬁnal int VK_A;
=30
public static ﬁnal int VK_ACCEPT;
=107
public static ﬁnal int VK_ADD;
=65481
1.2 public static ﬁnal int VK_AGAIN;
=256
1.2 public static ﬁnal int VK_ALL_CANDIDATES;
=240
1.2 public static ﬁnal int VK_ALPHANUMERIC;
=18
public static ﬁnal int VK_ALT;
=65406
1.2 public static ﬁnal int VK_ALT_GRAPH;
=150
1.2 public static ﬁnal int VK_AMPERSAND;
=151
1.2 public static ﬁnal int VK_ASTERISK;
=512
1.2 public static ﬁnal int VK_AT;
=66
public static ﬁnal int VK_B;
=192
public static ﬁnal int VK_BACK_QUOTE;
=92
public static ﬁnal int VK_BACK_SLASH;
=8
public static ﬁnal int VK_BACK_SPACE;
=161
1.2 public static ﬁnal int VK_BRACELEFT;
=162
1.2 public static ﬁnal int VK_BRACERIGHT;
=67
public static ﬁnal int VK_C;
=3
public static ﬁnal int VK_CANCEL;
java.awt.
event
java.awt.event.KeyEvent
Chapter 14 – The java.awt.event Package
277

=20
public static ﬁnal int VK_CAPS_LOCK;
=514
1.2 public static ﬁnal int VK_CIRCUMFLEX;
=12
public static ﬁnal int VK_CLEAR;
=93
public static ﬁnal int VK_CLOSE_BRACKET;
=258
1.2 public static ﬁnal int VK_CODE_INPUT;
=513
1.2 public static ﬁnal int VK_COLON;
=44
public static ﬁnal int VK_COMMA;
=65312
1.2 public static ﬁnal int VK_COMPOSE;
=17
public static ﬁnal int VK_CONTROL;
=28
public static ﬁnal int VK_CONVERT;
=65485
1.2 public static ﬁnal int VK_COPY;
=65489
1.2 public static ﬁnal int VK_CUT;
=68
public static ﬁnal int VK_D;
=134
1.2 public static ﬁnal int VK_DEAD_ABOVEDOT;
=136
1.2 public static ﬁnal int VK_DEAD_ABOVERING;
=129
1.2 public static ﬁnal int VK_DEAD_ACUTE;
=133
1.2 public static ﬁnal int VK_DEAD_BREVE;
=138
1.2 public static ﬁnal int VK_DEAD_CARON;
=139
1.2 public static ﬁnal int VK_DEAD_CEDILLA;
=130
1.2 public static ﬁnal int VK_DEAD_CIRCUMFLEX;
=135
1.2 public static ﬁnal int VK_DEAD_DIAERESIS;
=137
1.2 public static ﬁnal int VK_DEAD_DOUBLEACUTE;
=128
1.2 public static ﬁnal int VK_DEAD_GRAVE;
=141
1.2 public static ﬁnal int VK_DEAD_IOTA;
=132
1.2 public static ﬁnal int VK_DEAD_MACRON;
=140
1.2 public static ﬁnal int VK_DEAD_OGONEK;
=143
1.2 public static ﬁnal int VK_DEAD_SEMIVOICED_SOUND;
=131
1.2 public static ﬁnal int VK_DEAD_TILDE;
=142
1.2 public static ﬁnal int VK_DEAD_VOICED_SOUND;
=110
public static ﬁnal int VK_DECIMAL;
=127
public static ﬁnal int VK_DELETE;
=111
public static ﬁnal int VK_DIVIDE;
=515
1.2 public static ﬁnal int VK_DOLLAR;
=40
public static ﬁnal int VK_DOWN;
=69
public static ﬁnal int VK_E;
=35
public static ﬁnal int VK_END;
=10
public static ﬁnal int VK_ENTER;
=61
public static ﬁnal int VK_EQUALS;
=27
public static ﬁnal int VK_ESCAPE;
=516
1.2 public static ﬁnal int VK_EURO_SIGN;
=517
1.2 public static ﬁnal int VK_EXCLAMATION_MARK;
=70
public static ﬁnal int VK_F;
=112
public static ﬁnal int VK_F1;
=121
public static ﬁnal int VK_F10;
=122
public static ﬁnal int VK_F11;
=123
public static ﬁnal int VK_F12;
=61440
1.2 public static ﬁnal int VK_F13;
=61441
1.2 public static ﬁnal int VK_F14;
=61442
1.2 public static ﬁnal int VK_F15;
=61443
1.2 public static ﬁnal int VK_F16;
=61444
1.2 public static ﬁnal int VK_F17;
=61445
1.2 public static ﬁnal int VK_F18;
=61446
1.2 public static ﬁnal int VK_F19;
=113
public static ﬁnal int VK_F2;
=61447
1.2 public static ﬁnal int VK_F20;
=61448
1.2 public static ﬁnal int VK_F21;
=61449
1.2 public static ﬁnal int VK_F22;
=61450
1.2 public static ﬁnal int VK_F23;
java.awt.event.KeyEvent
278 Chapter 14 – The java.awt.event Package

=61451
1.2 public static ﬁnal int VK_F24;
=114
public static ﬁnal int VK_F3;
=115
public static ﬁnal int VK_F4;
=116
public static ﬁnal int VK_F5;
=117
public static ﬁnal int VK_F6;
=118
public static ﬁnal int VK_F7;
=119
public static ﬁnal int VK_F8;
=120
public static ﬁnal int VK_F9;
=24
public static ﬁnal int VK_FINAL;
=65488
1.2 public static ﬁnal int VK_FIND;
=243
1.2 public static ﬁnal int VK_FULL_WIDTH;
=71
public static ﬁnal int VK_G;
=160
1.2 public static ﬁnal int VK_GREATER;
=72
public static ﬁnal int VK_H;
=244
1.2 public static ﬁnal int VK_HALF_WIDTH;
=156
public static ﬁnal int VK_HELP;
=242
1.2 public static ﬁnal int VK_HIRAGANA;
=36
public static ﬁnal int VK_HOME;
=73
public static ﬁnal int VK_I;
=155
public static ﬁnal int VK_INSERT;
=518
1.2 public static ﬁnal int VK_INVERTED_EXCLAMATION_MARK;
=74
public static ﬁnal int VK_J;
=260
1.2 public static ﬁnal int VK_JAPANESE_HIRAGANA;
=259
1.2 public static ﬁnal int VK_JAPANESE_KATAKANA;
=261
1.2 public static ﬁnal int VK_JAPANESE_ROMAN;
=75
public static ﬁnal int VK_K;
=21
public static ﬁnal int VK_KANA;
=25
public static ﬁnal int VK_KANJI;
=241
1.2 public static ﬁnal int VK_KATAKANA;
=225
1.2 public static ﬁnal int VK_KP_DOWN;
=226
1.2 public static ﬁnal int VK_KP_LEFT;
=227
1.2 public static ﬁnal int VK_KP_RIGHT;
=224
1.2 public static ﬁnal int VK_KP_UP;
=76
public static ﬁnal int VK_L;
=37
public static ﬁnal int VK_LEFT;
=519
1.2 public static ﬁnal int VK_LEFT_PARENTHESIS;
=153
1.2 public static ﬁnal int VK_LESS;
=77
public static ﬁnal int VK_M;
=157
public static ﬁnal int VK_META;
=45
1.2 public static ﬁnal int VK_MINUS;
=31
public static ﬁnal int VK_MODECHANGE;
=106
public static ﬁnal int VK_MULTIPLY;
=78
public static ﬁnal int VK_N;
=29
public static ﬁnal int VK_NONCONVERT;
=144
public static ﬁnal int VK_NUM_LOCK;
=520
1.2 public static ﬁnal int VK_NUMBER_SIGN;
=96
public static ﬁnal int VK_NUMPAD0;
=97
public static ﬁnal int VK_NUMPAD1;
=98
public static ﬁnal int VK_NUMPAD2;
=99
public static ﬁnal int VK_NUMPAD3;
=100
public static ﬁnal int VK_NUMPAD4;
=101
public static ﬁnal int VK_NUMPAD5;
=102
public static ﬁnal int VK_NUMPAD6;
=103
public static ﬁnal int VK_NUMPAD7;
=104
public static ﬁnal int VK_NUMPAD8;
=105
public static ﬁnal int VK_NUMPAD9;
=79
public static ﬁnal int VK_O;
=91
public static ﬁnal int VK_OPEN_BRACKET;
java.awt.
event
java.awt.event.KeyEvent
Chapter 14 – The java.awt.event Package
279

=80
public static ﬁnal int VK_P;
=34
public static ﬁnal int VK_PAGE_DOWN;
=33
public static ﬁnal int VK_PAGE_UP;
=65487
1.2 public static ﬁnal int VK_PASTE;
=19
public static ﬁnal int VK_PAUSE;
=46
public static ﬁnal int VK_PERIOD;
=521
1.2 public static ﬁnal int VK_PLUS;
=257
1.2 public static ﬁnal int VK_PREVIOUS_CANDIDATE;
=154
public static ﬁnal int VK_PRINTSCREEN;
=65482
1.2 public static ﬁnal int VK_PROPS;
=81
public static ﬁnal int VK_Q;
=222
public static ﬁnal int VK_QUOTE;
=152
1.2 public static ﬁnal int VK_QUOTEDBL;
=82
public static ﬁnal int VK_R;
=39
public static ﬁnal int VK_RIGHT;
=522
1.2 public static ﬁnal int VK_RIGHT_PARENTHESIS;
=245
1.2 public static ﬁnal int VK_ROMAN_CHARACTERS;
=83
public static ﬁnal int VK_S;
=145
public static ﬁnal int VK_SCROLL_LOCK;
=59
public static ﬁnal int VK_SEMICOLON;
=108
public static ﬁnal int VK_SEPARATER;
=16
public static ﬁnal int VK_SHIFT;
=47
public static ﬁnal int VK_SLASH;
=32
public static ﬁnal int VK_SPACE;
=65480
1.2 public static ﬁnal int VK_STOP;
=109
public static ﬁnal int VK_SUBTRACT;
=84
public static ﬁnal int VK_T;
=9
public static ﬁnal int VK_TAB;
=85
public static ﬁnal int VK_U;
=0
public static ﬁnal int VK_UNDEFINED;
=523
1.2 public static ﬁnal int VK_UNDERSCORE;
=65483
1.2 public static ﬁnal int VK_UNDO;
=38
public static ﬁnal int VK_UP;
=86
public static ﬁnal int VK_V;
=87
public static ﬁnal int VK_W;
=88
public static ﬁnal int VK_X;
=89
public static ﬁnal int VK_Y;
=90
public static ﬁnal int VK_Z;
// Public Class Methods
public static String getKeyModiﬁersText(int modiﬁers);
public static String getKeyText(int keyCode);
// Property Accessor Methods (by property name)
public boolean isActionKey();
public char getKeyChar();
public void setKeyChar(char keyChar);
public int getKeyCode();
public void setKeyCode(int keyCode);
// Public Instance Methods
public void setModiﬁers(int modiﬁers);
// Public Methods Overriding ComponentEvent
public String paramString();
}
Hierar chy: Object→java.util.EventObject(Serializable)→AWTEvent→ComponentEvent→InputEvent→
KeyEvent
Subc lasses: javax.swing .event.MenuKeyEvent
Passed To: Too many methods to list.
java.awt.event.KeyEvent
280 Chapter 14 – The java.awt.event Package

KeyListener
Ja va 1.1
java.awt.e vent
event listener PJ1.1
This interface deﬁnes the methods that an object must implement to listen for key
events on AWT components. When a KeyEvent occurs, an AWT component notiﬁes its
register ed KeyListener objects by invoking one of their methods. An easy way to imple-
ment this interface is by subclassing the KeyAdapter class.
public abstract interface KeyListener extends java.util.EventListener {
// Public Instance Methods
public abstract void keyPressed(KeyEvent e);
public abstract void keyReleased(KeyEvent e);
public abstract void keyTyped(KeyEvent e);
}
Hierar chy: (KeyListener(java.util.EventListener))
Implementations: AWTEventMulticaster, KeyAdapter
Passed To: AWTEventMulticaster.{add(), remove()}, Component.{addKeyListener(), removeKeyListener()}
Retur ned By: AWTEventMulticaster.{add(), remove()}
MouseAdapter
Ja va 1.1
java.awt.e vent
event adapter PJ1.1
This class is a trivial implementation of MouseListener; it provides empty bodies for each
of the methods of that interface. When you are not interested in all of these methods, it
is often easier to subclass MouseAdapter than it is to implement MouseListener fr om
scratch.
public abstract class MouseAdapter implements MouseListener {
// Public Constructors
public MouseAdapter();
// Methods Implementing MouseListener
empty
public void mouseClicked(MouseEvent e);
empty
public void mouseEntered(MouseEvent e);
empty
public void mouseExited(MouseEvent e);
empty
public void mousePressed(MouseEvent e);
empty
public void mouseReleased(MouseEvent e);
}
Hierar chy: Object→MouseAdapter(MouseListener(java.util.EventListener))
Subc lasses: javax.swing .ToolT ipManager, javax.swing .text.html.FormV iew.MouseEventListener,
javax.swing .text.html.HTMLEditorKit.LinkController
MouseEvent
Ja va 1.1
java.awt.e vent
serializable event PJ1.1
An event of this type indicates that the user has moved the mouse or pressed one of
the mouse buttons. Call getID() to determine the speciﬁc type of mouse event that has
occurr ed. This method retur ns one of the following seven constants, which corresponds
to a method in either the MouseListener or MouseMotionListener inter face:
MOUSE_PRESSED
The user has pressed a mouse button.
java.awt.
event
java.awt.event.MouseEvent
Chapter 14 – The java.awt.event Package
281

MOUSE_RELEASED
The user has released a mouse button.
MOUSE_CLICKED
The user has pressed and released a mouse button without any intervening mouse
drag.
MOUSE_DRAGGED
The user has moved the mouse while holding a button down.
MOUSE_MOVED
The user has moved the mouse without holding any buttons down.
MOUSE_ENTERED
The mouse pointer has entered the component.
MOUSE_EXITED
The mouse pointer has left the component.
Use getX() and getY() or getPoint() to obtain the coordinates of the mouse event. Use trans-
latePoint() to modify these coordinates by a speciﬁed amount.
Use getModiﬁers() and other methods and constants inherited from InputEvent to deter-
mine the mouse button or keyboard modiﬁers that were down when the event
occurr ed. See InputEvent for details. Note that mouse button modiﬁers are not reported
for MOUSE_RELEASED events, since, technically, the mouse button in question is no
longer pressed.
Use getComponent(), inherited from ComponentEvent, to deter mine over which component
the event occurred. For mouse events of type MOUSE_CLICKED, MOUSE_PRESSED, or
MOUSE_RELEASED, call getClickCount() to determine how many consecutive clicks have
occurr ed. If you are using popup menus, use isPopupTrigger() to test whether the current
event repr esents the standard platform-dependent popup menu trigger event.
public class MouseEvent extends InputEvent {
// Public Constructors
public MouseEvent(Component source, int id, long when, int modiﬁers, int x, int y, int clickCount,
boolean popupTrigger);
// Public Constants
=500
public static ﬁnal int MOUSE_CLICKED;
=506
public static ﬁnal int MOUSE_DRAGGED;
=504
public static ﬁnal int MOUSE_ENTERED;
=505
public static ﬁnal int MOUSE_EXITED;
=500
public static ﬁnal int MOUSE_FIRST;
=506
public static ﬁnal int MOUSE_LAST;
=503
public static ﬁnal int MOUSE_MOVED;
=501
public static ﬁnal int MOUSE_PRESSED;
=502
public static ﬁnal int MOUSE_RELEASED;
// Property Accessor Methods (by property name)
public int getClickCount();
public Point getPoint();
public boolean isPopupTrigger();
public int getX();
public int getY();
// Public Instance Methods
synchronized
public void translatePoint(int x, int y);
// Public Methods Overriding ComponentEvent
public String paramString();
}
java.awt.event.MouseEvent
282 Chapter 14 – The java.awt.event Package

Hierar chy: Object→java.util.EventObject(Serializable)→AWTEvent→ComponentEvent→InputEvent→
MouseEvent
Subc lasses: javax.swing .event.MenuDragMouseEvent
Passed To: Too many methods to list.
Retur ned By: javax.swing .SwingUtilities.convertMouseEvent()
MouseListener
Ja va 1.1
java.awt.e vent
event listener PJ1.1
This interface deﬁnes the methods that an object must implement to listen for mouse
events on AWT components. When a MouseEvent occurs, an AWT component notiﬁes its
register ed MouseListener objects (or MouseMotionListener objects, if the event involves
mouse motion) by invoking one of their methods. An easy way to implement this inter-
face is by subclassing the MouseAdapter class.
public abstract interface MouseListener extends java.util.EventListener {
// Public Instance Methods
public abstract void mouseClicked(MouseEvent e);
public abstract void mouseEntered(MouseEvent e);
public abstract void mouseExited(MouseEvent e);
public abstract void mousePressed(MouseEvent e);
public abstract void mouseReleased(MouseEvent e);
}
Hierar chy: (MouseListener(java.util.EventListener))
Implementations: AWTEventMulticaster, java.awt.dnd.MouseDragGestureRecognizer, MouseAdapter,
javax.swing .event.MouseInputListener, javax.swing .text.DefaultCaret
Passed To: AWTEventMulticaster.{add(), remove()}, Component.{addMouseListener(),
removeMouseListener()}
Retur ned By: AWTEventMulticaster.{add(), remove()}
MouseMotionAdapter
Ja va 1.1
java.awt.e vent
event adapter PJ1.1
This class is a trivial implementation of MouseMotionListener; it provides empty bodies for
each of the methods of that interface. When you are not interested in all of these meth-
ods, it is often easier to subclass MouseMotionAdapter than it is to implement MouseMotion-
Listener fr om scratch.
public abstract class MouseMotionAdapter implements MouseMotionListener {
// Public Constructors
public MouseMotionAdapter();
// Methods Implementing MouseMotionListener
empty
public void mouseDragged(MouseEvent e);
empty
public void mouseMoved(MouseEvent e);
}
Hierar chy: Object→MouseMotionAdapter(MouseMotionListener(java.util.EventListener))
MouseMotionListener
Ja va 1.1
java.awt.e vent
event listener PJ1.1
This interface deﬁnes the methods that an object must implement to listen for mouse
motion events on AWT components. When a MouseEvent involving a mouse drag or
mouse motion with no buttons down occurs, an AWT component notiﬁes its register ed
java.awt.
event
java.awt.event.MouseMotionListener
Chapter 14 – The java.awt.event Package
283

MouseMotionListener objects by invoking one of their methods. An easy way to implement
this is by subclassing the MouseMotionAdapter class.
public abstract interface MouseMotionListener extends java.util.EventListener {
// Public Instance Methods
public abstract void mouseDragged(MouseEvent e);
public abstract void mouseMoved(MouseEvent e);
}
Hierar chy: (MouseMotionListener(java.util.EventListener))
Implementations: AWTEventMulticaster, java.awt.dnd.MouseDragGestureRecognizer, MouseMotionAdapter,
javax.swing .ToolT ipManager, javax.swing .event.MouseInputListener, javax.swing .text.DefaultCaret
Passed To: AWTEventMulticaster.{add(), remove()}, Component.{addMouseMotionListener(),
removeMouseMotionListener()}
Retur ned By: AWTEventMulticaster.{add(), remove()}
PaintEvent
Ja va 1.1
java.awt.e vent
serializable event PJ1.1
An event of this type indicates that a component should have its update() method
invoked. (The update() method typically, by default, invokes the paint() method.)
PaintEvent dif fers fr om the other event types in java.awt.event in that it does not have a
corr esponding EventListener inter face. PaintEvent is essentially for internal use by the AWT
redisplay framework, so your programs should not try to handle it the way they handle
other events. Instead, applets and custom components should simply override their
paint() and/or update() methods to redraw themselves appropriately. AWT automatically
invokes update() (which typically invokes paint()) when a PaintEvent arrives.
Although you do not typically use PaintEvent, redraw events are implemented through
this class for simplicity, so that they are on equal footing with other event types and so
that advanced programs can manipulate them through the EventQueue.
public class PaintEvent extends ComponentEvent {
// Public Constructors
public PaintEvent(Component source, int id, Rectangle updateRect);
// Public Constants
=800
public static ﬁnal int PAINT;
=800
public static ﬁnal int PAINT_FIRST;
=801
public static ﬁnal int PAINT_LAST;
=801
public static ﬁnal int UPDATE;
// Public Instance Methods
public Rectangle getUpdateRect();
public void setUpdateRect(Rectangle updateRect);
// Public Methods Overriding ComponentEvent
public String paramString();
}
Hierar chy: Object→java.util.EventObject(Serializable)→AWTEvent→ComponentEvent→PaintEvent
TextEvent
Ja va 1.1
java.awt.e vent
serializable event PJ1.1
An event of this type indicates that the user has edited the text value that appears in a
TextF ield, TextArea, or other TextComponent. This event is triggered by any change to the dis-
played text. Note that this is not the same as the ActionEvent sent by the TextF ield object
when the user edits the text and strikes the Retur n key.
java.awt.event.MouseMotionListener
284 Chapter 14 – The java.awt.event Package

Use the inherited getSource() to determine the object that was the source of this event.
You have to cast that object to its TextComponent type. Call getID() to determine the type
of a TextEvent. The standard AWT components always generate text events of type
TEXT_VALUE_CHANGED.
public class TextEvent extends AWTEvent {
// Public Constructors
public TextEvent(Object source, int id);
// Public Constants
=900
public static ﬁnal int TEXT_FIRST;
=900
public static ﬁnal int TEXT_LAST;
=900
public static ﬁnal int TEXT_VALUE_CHANGED;
// Public Methods Overriding AWTEvent
public String paramString();
}
Hierar chy: Object→java.util.EventObject(Serializable)→AWTEvent→TextEvent
Passed To: AWTEventMulticaster.textValueChanged(), TextComponent.processTextEvent(),
TextListener.textValueChanged()
TextListener
Ja va 1.1
java.awt.e vent
event listener PJ1.1
This interface deﬁnes the method that an object must implement to listen for text
events on AWT components. When a TextEvent occurs, an AWT component notiﬁes its
register ed TextListener objects by invoking their textValueChanged() methods.
public abstract interface TextListener extends java.util.EventListener {
// Public Instance Methods
public abstract void textValueChanged(TextEvent e);
}
Hierar chy: (TextListener(java.util.EventListener))
Implementations: AWTEventMulticaster
Passed To: AWTEventMulticaster.{add(), remove()}, TextComponent.{addTextListener(), removeTextListener()}
Retur ned By: AWTEventMulticaster.{add(), remove()}
Type Of: TextComponent.textListener
WindowAdapter
Ja va 1.1
java.awt.e vent
event adapter PJ1.1
This class is a trivial implementation of WindowListener; it provides empty bodies for each
of the methods of that interface. When you are not interested in all of these methods, it
is often easier to subclass WindowAdapter than it is to implement WindowListener fr om
scratch.
public abstract class WindowAdapter implements WindowListener {
// Public Constructors
public WindowAdapter();
// Methods Implementing WindowListener
empty
public void windowActivated(W indowEvent e);
empty
public void windowClosed(W indowEvent e);
empty
public void windowClosing(W indowEvent e);
empty
public void windowDeactivated(W indowEvent e);
empty
public void windowDeiconiﬁed(W indowEvent e);
empty
public void windowIconiﬁed(W indowEvent e);
java.awt.
event
java.awt.event.WindowAdapter
Chapter 14 – The java.awt.event Package
285

empty
public void windowOpened(W indowEvent e);
}
Hierar chy: Object→WindowAdapter(W indowListener(java.util.EventListener))
Subc lasses: javax.swing .JMenu.WinListener
WindowEvent
Ja va 1.1
java.awt.e vent
serializable event PJ1.1
An event of this type indicates that an important action has occurred for a Window
object. Call getW indow() to determine the Window object that is the source of this event.
Call getID() to determine the speciﬁc type of event that has occurred. Each of the follow-
ing seven constants corresponds to one of the methods of the WindowListener inter face:
WINDOW_OPENED
Indicates that the window has been created and opened; it is delivered only the
ﬁrst time that a window is opened.
WINDOW_CLOSING
Indicates that the user has requested that the window be closed through the sys-
tem menu, through a close button on the window’s border, or by invoking a plat-
for m-deﬁned keystr oke, such as Alt-F4 in Windows. The application should
respond to this event by calling hide() or dispose() on the Window object.
WINDOW_CLOSED
Deliver ed after a window is closed by a call to hide() or dispose().
WINDOW_ICONIFIED
Deliver ed when the user iconiﬁes the window.
WINDOW_DEICONIFIED
Deliver ed when the user deiconiﬁes the window.
WINDOW_ACTIVATED
Deliver ed when the window is activated—that is, when it is given the keyboard
focus and becomes the active window.
WINDOW_DEACTIVATED
Deliver ed when the window ceases to be the active window, typically when the
user activates some other window.
public class WindowEvent extends ComponentEvent {
// Public Constructors
public WindowEvent(W indow source, int id);
// Public Constants
=205
public static ﬁnal int WINDOW_ACTIVATED;
=202
public static ﬁnal int WINDOW_CLOSED;
=201
public static ﬁnal int WINDOW_CLOSING;
=206
public static ﬁnal int WINDOW_DEACTIVATED;
=204
public static ﬁnal int WINDOW_DEICONIFIED;
=200
public static ﬁnal int WINDOW_FIRST;
=203
public static ﬁnal int WINDOW_ICONIFIED;
=206
public static ﬁnal int WINDOW_LAST;
=200
public static ﬁnal int WINDOW_OPENED;
// Public Instance Methods
public Window getW indow();
java.awt.event.WindowAdapter
286 Chapter 14 – The java.awt.event Package

// Public Methods Overriding ComponentEvent
public String paramString();
}
Hierar chy: Object→java.util.EventObject(Serializable)→AWTEvent→ComponentEvent→WindowEvent
Passed To: Too many methods to list.
WindowListener
Ja va 1.1
java.awt.e vent
event listener PJ1.1
This interface deﬁnes the methods that an object must implement to listen for window
events on AWT components. When a WindowEvent occurs, an AWT component notiﬁes
its register ed WindowListener objects by invoking one of their methods. An easy way to
implement this interface is by subclassing the WindowAdapter class.
public abstract interface WindowListener extends java.util.EventListener {
// Public Instance Methods
public abstract void windowActivated(W indowEvent e);
public abstract void windowClosed(W indowEvent e);
public abstract void windowClosing(W indowEvent e);
public abstract void windowDeactivated(W indowEvent e);
public abstract void windowDeiconiﬁed(W indowEvent e);
public abstract void windowIconiﬁed(W indowEvent e);
public abstract void windowOpened(W indowEvent e);
}
Hierar chy: (W indowListener(java.util.EventListener))
Implementations: AWTEventMulticaster, WindowAdapter
Passed To: AWTEventMulticaster.{add(), remove()}, Window.{addW indowListener(), removeWindowListener()}
Retur ned By: AWTEventMulticaster.{add(), remove()}
java.awt.
event
java.awt.event.WindowListener
Chapter 14 – The java.awt.event Package
287

CHAPTER 15
The java.awt.font Package
The java.awt.font package contains classes and interfaces related to fonts; it is new
in Java 1.2. Note, however, that the Font class itself is part of the java.awt package.
This package contains low-level classes for obtaining information about the mea-
sur ements of font glyphs and lines of text. It also contains classes for the low-level
layout of text. LineMetrics and TextLayout ar e the two most important classes in this
package. Figure 15-1 shows the class hierarchy of this package.
Most programs can rely on the higher-level text display features of java.awt and
javax.swing and do not have to use this package.
FontRenderContext
Ja va 1.2
java.awt.font
This class stores the information necessary to precisely measure the size of text. It is
used by a number of Font methods and also by TextLayout and LineBreakMeasurer. Although
FontRenderContext has a public constructor, it is mor e common to obtain a FontRenderCon-
text by calling the getFontRenderContext() method of a Graphics2D object.
public class FontRenderContext {
// Public Constructors
public FontRenderContext(java.awt.geom.AfﬁneTransform tx, boolean isAntiAliased,
boolean usesFractionalMetrics);
// Protected Constructors
protected FontRenderContext();
// Property Accessor Methods (by property name)
public boolean isAntiAliased();
public java.awt.geom.AfﬁneTransform getTransfor m();
// Public Instance Methods
public boolean usesFractionalMetrics();
}
288

extends
implements
KEY
CLASS
ABSTRACT CLASS
FINAL CLASS
INTERFACE
java.lang
Object
java.io
Serializable
java.awt.font
Cloneable
FontRenderContext
GlyphJustificationInfo
GlyphMetrics
GlyphVector
GraphicAttribute
LineBreakMeasurer
LineMetrics
TextAttribute
TextHitInfo
TextLayout
TransformAttribute
ImageGraphicAttribute
ShapeGraphicAttribute
OpenType
MultipleMaster
Figur e 15−1: The java.awt.font package
Passed To: Too many methods to list.
Retur ned By: Graphics2D.getFontRenderContext(), GlyphVector.getFontRenderContext()
GlyphJustificationInfo
Ja va 1.2
java.awt.font
This class contains information about how much whitespace may be added to or
removed from the left and right sides of a glyph without unduly compromising the
appearance of the text output. This information is used by algorithms that perfor m ﬁll
justiﬁcation to force a line of text to an exact size. Only applications that perfor m high-
end typography need to use this class.
public ﬁnal class GlyphJustiﬁcationInfo {
// Public Constructors
public GlyphJustiﬁcationInfo(ﬂoat weight, boolean growAbsorb, int growPriority, ﬂoat growLeftLimit,
ﬂoat growRightLimit, boolean shrinkAbsorb, int shrinkPriority, ﬂoat shrinkLeftLimit,
ﬂoat shrinkRightLimit);
// Public Constants
=2
public static ﬁnal int PRIORITY_INTERCHAR;
=0
public static ﬁnal int PRIORITY_KASHIDA;
=3
public static ﬁnal int PRIORITY_NONE;
=1
public static ﬁnal int PRIORITY_WHITESPACE;
java.awt.font
java.awt.font.GlyphJustiﬁcationInfo
Chapter 15 – The java.awt.font Package
289

// Public Instance Fields
public ﬁnal boolean growAbsorb;
public ﬁnal ﬂoat growLeftLimit;
public ﬁnal int growPriority;
public ﬁnal ﬂoat growRightLimit;
public ﬁnal boolean shrinkAbsorb;
public ﬁnal ﬂoat shrinkLeftLimit;
public ﬁnal int shrinkPriority;
public ﬁnal ﬂoat shrinkRightLimit;
public ﬁnal ﬂoat weight;
}
Retur ned By: GlyphVector.getGlyphJustificationInfo(), GraphicAttribute.getJustificationInfo()
GlyphMetrics
Ja va 1.2
java.awt.font
This class contains measurements for a single glyph of a font. Although GlyphMetrics has
a public constructor, the only way to obtain actual metrics for a glyph is by calling the
getGlyphMetrics() method of a GlyphVector.
Each glyph has an origin. The getAdvance() method retur ns the standard distance
between the origin of this glyph and the origin of the next glyph in the GlyphVector fr om
which the GlyphMetrics was obtained. getBounds2D() retur ns the bounding box of the
glyph. This rectangle is positioned relative to the origin of the glyph. getLSB() retur ns
the left-side bearing of the glyph: the distance between the origin and the left side of
the bounding box. getRSB() retur ns the right-side bearing: the distance between the
right side of the bounding box and the start of the next glyph. For some glyphs, these
bearing values may be negative.
getType() retur ns the type of the glyph; the retur n value is one of the constants deﬁned
by the class. Most glyphs are of STANDARD type. Glyphs with no visible repr esentation
ar e of type WHITESPACE. Glyphs that repr esent mor e than one character have type LIGA-
TURE. Accents and other diacritical marks that modify other glyphs have type COMBINING.
Finally, when one character is repr esented by two or more glyphs, the extra glyph or
glyphs have the type COMPONENT.
public ﬁnal class GlyphMetrics {
// Public Constructors
public GlyphMetrics(ﬂoat advance, java.awt.geom.Rectangle2D bounds, byte glyphType);
// Public Constants
=2
public static ﬁnal byte COMBINING;
=3
public static ﬁnal byte COMPONENT;
=1
public static ﬁnal byte LIGATURE;
=0
public static ﬁnal byte STANDARD;
=4
public static ﬁnal byte WHITESPACE;
// Property Accessor Methods (by property name)
public ﬂoat getAdvance();
public java.awt.geom.Rectangle2D getBounds2D();
public boolean isCombining();
public boolean isComponent();
public boolean isLigature();
public ﬂoat getLSB();
public ﬂoat getRSB();
public boolean isStandard();
java.awt.font.GlyphJustiﬁcationInfo
290 Chapter 15 – The java.awt.font Package

public int getType();
public boolean isWhitespace();
}
Retur ned By: GlyphVector.getGlyphMetrics()
GlyphVector
Ja va 1.2
java.awt.font
cloneable
This class repr esents an array of glyphs taken from a single font that are to be drawn
on a single line. You obtain a GlyphVector by calling the createGlyphVector() method of a
Font object, and you draw a GlyphVector with the drawGlyphVector() method of a Graphics2D
object.
When a string is drawn using the drawString() method of Graphics or Graphics2D, the char-
acters of the string ﬁrst must be converted to font glyphs, and then those glyphs must
be drawn. Thus, if a string is to be drawn repeatedly, it can be more efﬁcient to sepa-
rate these two steps, converting the string to a GlyphVector once and then drawing that
GlyphVector multiple times.
public abstract class GlyphVector implements Cloneable {
// Public Constructors
public GlyphVector();
// Property Accessor Methods (by property name)
public abstract Font getFont();
public abstract FontRenderContext getFontRenderContext();
public abstract java.awt.geom.Rectangle2D getLogicalBounds();
public abstract int getNumGlyphs();
public abstract Shape getOutline();
public abstract Shape getOutline(ﬂoat x, ﬂoat y);
public abstract java.awt.geom.Rectangle2D getV isualBounds();
// Public Instance Methods
public abstract boolean equals(GlyphVector set);
public abstract int getGlyphCode(int glyphIndex);
public abstract int[ ] getGlyphCodes(int beginGlyphIndex, int numEntries, int[ ] codeReturn);
public abstract GlyphJustiﬁcationInfo getGlyphJustiﬁcationInfo(int glyphIndex);
public abstract Shape getGlyphLogicalBounds(int glyphIndex);
public abstract GlyphMetrics getGlyphMetrics(int glyphIndex);
public abstract Shape getGlyphOutline(int glyphIndex);
public abstract java.awt.geom.Point2D getGlyphPosition(int glyphIndex);
public abstract ﬂoat[ ] getGlyphPositions(int beginGlyphIndex, int numEntries, ﬂoat[ ] positionReturn);
public abstract java.awt.geom.AfﬁneTransform getGlyphTransfor m(int glyphIndex);
public abstract Shape getGlyphV isualBounds(int glyphIndex);
public abstract void perfor mDefaultLayout();
public abstract void setGlyphPosition(int glyphIndex, java.awt.geom.Point2D newPos);
public abstract void setGlyphTransfor m(int glyphIndex, java.awt.geom.AfﬁneTransform newTX);
}
Hierar chy: Object→GlyphVector(Cloneable)
Passed To: Graphics2D.drawGlyphVector(), GlyphVector.equals()
Retur ned By: Font.createGlyphVector()
GraphicAttribute
Ja va 1.2
java.awt.font
This abstract class repr esents a graphic to be embedded in a line of text in lieu of a
regular font glyph. A GraphicAttribute is used as the value of an TextAttribute.CHAR_REPLACE-
MENT
attribute in a
java.text.AttributedString
or
java.text.AttributedCharacterIterator.
Most
java.awt.font
java.awt.font.GraphicAttr ibute
Chapter 15 – The java.awt.font Package
291

applications use one of the two subclasses ImageGraphicAttribute and ShapeGraphicAttribute.
Few applications need to create custom subclasses of their own.
The draw() method is responsible for actually drawing the desired graphic. The other
methods retur n various measurements for the graphic. The constants are possible align-
ment values retur ned by getAligment().
public abstract class GraphicAttribute {
// Protected Constructors
protected GraphicAttribute(int alignment);
// Public Constants
=-2
public static ﬁnal int BOTTOM_ALIGNMENT;
=1
public static ﬁnal int CENTER_BASELINE;
=2
public static ﬁnal int HANGING_BASELINE;
=0
public static ﬁnal int ROMAN_BASELINE;
=-1
public static ﬁnal int TOP_ALIGNMENT;
// Property Accessor Methods (by property name)
public abstract ﬂoat getAdvance();
public ﬁnal int getAlignment();
public abstract ﬂoat getAscent();
public java.awt.geom.Rectangle2D getBounds();
public abstract ﬂoat getDescent();
public GlyphJustiﬁcationInfo getJustiﬁcationInfo();
// Public Instance Methods
public abstract void draw(Graphics2D graphics, ﬂoat x, ﬂoat y);
}
Subc lasses: ImageGraphicAttribute, ShapeGraphicAttribute
ImageGraphicAttribute
Ja va 1.2
java.awt.font
This concrete subclass of GraphicAttribute allows an image to be drawn within a string of
text. Create an ImageGraphicAttribute by specifying an image to draw, an alignment (one
of the constants deﬁned by GraphicAttribute), and, optionally, an origin for the image.
The origin coordinates are relative to the image itself. Use the ImageGraphicAttribute by
specifying it as the value of a TextAttribute.CHAR_REPLACEMENT attribute in a java.text.Attribut-
edString or java.text.AttributedCharacterIterator.
See also ShapeGraphicAttribute.
public ﬁnal class ImageGraphicAttribute extends GraphicAttribute {
// Public Constructors
public ImageGraphicAttribute(Image image, int alignment);
public ImageGraphicAttribute(Image image, int alignment, ﬂoat originX, ﬂoat originY);
// Public Instance Methods
public boolean equals(ImageGraphicAttribute rhs);
// Public Methods Overriding GraphicAttribute
public void draw(Graphics2D graphics, ﬂoat x, ﬂoat y);
public ﬂoat getAdvance();
public ﬂoat getAscent();
public java.awt.geom.Rectangle2D getBounds();
public ﬂoat getDescent();
// Public Methods Overriding Object
public boolean equals(Object rhs);
public int hashCode();
}
java.awt.font.GraphicAttr ibute
292 Chapter 15 – The java.awt.font Package

Hierar chy: Object→GraphicAttribute→ImageGraphicAttribute
Passed To: ImageGraphicAttribute.equals()
LineBreakMeasurer
Ja va 1.2
java.awt.font
This class breaks a paragraph of text into individual lines of a speciﬁed width, where
each line is repr esented by a TextLayout object. When you create a LineBreakMeasurer, you
must specify the paragraph to be broken with a java.text.AttributedCharacterIterator, which is
usually is obtained from a java.text.AttributedString. You may optionally specify a
java.text.BreakIterator to indicate where line breaks are allowed. The default is to use the
line breaking rules of the current locale. You must also pass a FontRenderContext to the
LineBreakMeasurer() constructor. The FontRenderContext is usually obtained with the get-
FontRenderContext() method of Graphics2D.
Once you have created a LineBreakMeasurer for your paragraph, you use it by repeatedly
calling nextLayout() to create TextLayout objects that repr esent lines. nextLayout() retur ns null
when it reaches the end of the paragraph. The desired width of each line is passed as
an argument to nextLayout(). This allows the ﬁrst line of a paragraph to be made shorter
than the following lines, for example.
public ﬁnal class LineBreakMeasurer {
// Public Constructors
public LineBreakMeasurer(java.text.AttributedCharacterIterator text, FontRenderContext frc);
public LineBreakMeasurer(java.text.AttributedCharacterIterator text, java.text.BreakIterator breakIter,
FontRenderContext frc);
// Public Instance Methods
public void deleteChar(java.text.AttributedCharacterIterator newParagraph, int deletePos);
public int getPosition();
public void inser tChar(java.text.AttributedCharacterIterator newParagraph, int inser tPos);
public TextLayout nextLayout(ﬂoat maxAdvance);
public TextLayout nextLayout(ﬂoat wrappingWidth, int offsetLimit, boolean requireNextWord);
public int nextOffset(ﬂoat maxAdvance);
public int nextOffset(ﬂoat wrappingWidth, int offsetLimit, boolean requireNextWord);
public void setPosition(int newPosition);
}
LineMetrics
Ja va 1.2
java.awt.font
This class provides access to various measurements for the characters in a font. The
name LineMetrics is somewhat confusing; it refers to the general line metrics of a font,
not the metrics of some particular line of text render ed with the font. LineMetrics pr o-
vides more accurate metrics than java.awt.FontMetrics and also includes some metrics that
ar e simply not available through that class.
Obtain a LineMetrics object by calling one of the getLineMetrics() methods of Font or Font-
Metrics. These methods requir e that you supply some form of text to measure. The
retur ned LineMetrics object does not contain the width of that text, but the font measure-
ments it does retur n may depend on the content of the text. For example, the metrics
for English text may differ from metrics for Japanese text. (Note, however, that the ini-
tial implementation from Sun simply ignores the text you specify.) If the supplied text
contains characters from more than one language, the retur ned metrics may apply only
to a preﬁx of the text. The getNumChars() method retur ns the length of this preﬁx.
Once you have obtained a LineMetrics object, you can call its various accessor methods
to obtain information about the font. getAscent() retur ns the distance between the base-
line and the top of the tallest character. getDescent() retur ns the distance between the
java.awt.font
java.awt.font.LineMetr ics
Chapter 15 – The java.awt.font Package
293

baseline and the bottom of the lowest descender. getLeading() retur ns the recommended
interline spacing for the font (so named for the strips of lead that used to be placed
between rows of movable type). getHeight() retur ns the distance between the baseline of
one line and the baseline of the next. It is equal to the sum of the ascent, descent, and
leading. getUnder lineOffset() retur ns the recommended position of an underline, relative
to the baseline for the font, and getUnder lineThickness() retur ns the recommended thick-
ness of an underline. Two similar methods retur n the position and thickness of lines
used to strike through characters in the font.
public abstract class LineMetrics {
// Public Constructors
public LineMetrics();
// Property Accessor Methods (by property name)
public abstract ﬂoat getAscent();
public abstract int getBaselineIndex();
public abstract ﬂoat[ ] getBaselineOffsets();
public abstract ﬂoat getDescent();
public abstract ﬂoat getHeight();
public abstract ﬂoat getLeading();
public abstract int getNumChars();
public abstract ﬂoat getStrikethroughOffset();
public abstract ﬂoat getStrikethroughThickness();
public abstract ﬂoat getUnder lineOffset();
public abstract ﬂoat getUnder lineThickness();
}
Retur ned By: Font.getLineMetrics(), FontMetrics.getLineMetrics()
MultipleMaster
Ja va 1.2
java.awt.font
This interface describes capabilities of Type 1 Multiple Master fonts. If a Font object rep-
resents a Multiple Master font, it implements the MultipleMaster inter face. Most fonts have
only one parameter that you can vary: the point size. A Multiple Master font is a gener-
alization that allows you to vary any number of design axes of the font. These design
axes may be things such as font weight, average glyph width, italic angle, and so forth.
The methods of the MultipleMaster inter face allow you to query the names, defaults, and
valid ranges of these design axes and derive new versions of the font by specifying val-
ues for each axis.
public abstract interface MultipleMaster {
// Property Accessor Methods (by property name)
public abstract ﬂoat[ ] getDesignAxisDefaults();
public abstract String[ ] getDesignAxisNames();
public abstract ﬂoat[ ] getDesignAxisRanges();
public abstract int getNumDesignAxes();
// Public Instance Methods
public abstract Font deriveMMFont(ﬂoat[ ] axes);
public abstract Font deriveMMFont(ﬂoat[ ] glyphWidths, ﬂoat avgStemWidth, ﬂoat typicalCapHeight,
ﬂoat typicalXHeight, ﬂoat italicAngle);
}
OpenType
Ja va 1.2
java.awt.font
This interface is implemented by Font objects that repr esent OpenT ype and TrueT ype
fonts. It allows access to tables of raw font data. You should use this interface only if
you are intimately familiar with the font data format for OpenType and TrueT ype fonts.
java.awt.font.LineMetr ics
294 Chapter 15 – The java.awt.font Package

public abstract interface OpenType {
// Public Constants
=1633906292
public static ﬁnal int TA G_ACNT;
=1635148146
public static ﬁnal int TA G_AVAR;
=1111577413
public static ﬁnal int TA G_BASE;
=1650745716
public static ﬁnal int TA G_BDAT;
=1651273571
public static ﬁnal int TA G_BLOC;
=1651731566
public static ﬁnal int TA G_BSLN;
=1128678944
public static ﬁnal int TA G_CFF;
=1668112752
public static ﬁnal int TA G_CMAP;
=1668702578
public static ﬁnal int TA G_CVAR;
=1668707360
public static ﬁnal int TA G_CVT;
=1146308935
public static ﬁnal int TA G_DSIG;
=1161970772
public static ﬁnal int TA G_EBDT;
=1161972803
public static ﬁnal int TA G_EBLC;
=1161974595
public static ﬁnal int TA G_EBSC;
=1717859171
public static ﬁnal int TA G_FDSC;
=1717920116
public static ﬁnal int TA G_FEAT;
=1718449272
public static ﬁnal int TA G_FMTX;
=1718642541
public static ﬁnal int TA G_FPGM;
=1719034226
public static ﬁnal int TA G_FVAR;
=1734439792
public static ﬁnal int TA G_GASP;
=1195656518
public static ﬁnal int TA G_GDEF;
=1735162214
public static ﬁnal int TA G_GLYF;
=1196445523
public static ﬁnal int TA G_GPOS;
=1196643650
public static ﬁnal int TA G_GSUB;
=1735811442
public static ﬁnal int TA G_GVAR;
=1751412088
public static ﬁnal int TA G_HDMX;
=1751474532
public static ﬁnal int TA G_HEAD;
=1751672161
public static ﬁnal int TA G_HHEA;
=1752003704
public static ﬁnal int TA G_HMTX;
=1246975046
public static ﬁnal int TA G_JSTF;
=1786082164
public static ﬁnal int TA G_JUST;
=1801810542
public static ﬁnal int TA G_KERN;
=1818452338
public static ﬁnal int TA G_LCAR;
=1819239265
public static ﬁnal int TA G_LOCA;
=1280594760
public static ﬁnal int TA G_LTSH;
=1835104368
public static ﬁnal int TA G_MAXP;
=1296909912
public static ﬁnal int TA G_MMFX;
=1296913220
public static ﬁnal int TA G_MMSD;
=1836020340
public static ﬁnal int TA G_MORT;
=1851878757
public static ﬁnal int TA G_NAME;
=1836020340
public static ﬁnal int TA G_OPBD;
=1330851634
public static ﬁnal int TA G_OS2;
=1346587732
public static ﬁnal int TA G_PCLT;
=1886352244
public static ﬁnal int TA G_POST;
=1886545264
public static ﬁnal int TA G_PREP;
=1886547824
public static ﬁnal int TA G_PROP;
=1953653099
public static ﬁnal int TA G_TRAK;
=1954115633
public static ﬁnal int TA G_TYP1;
=1447316824
public static ﬁnal int TA G_VDMX;
=1986553185
public static ﬁnal int TA G_VHEA;
=1986884728
public static ﬁnal int TA G_VMTX;
// Public Instance Methods
public abstract byte[ ] getFontTable(String strSfntTag);
public abstract byte[ ] getFontTable(int sfntTag);
public abstract byte[ ] getFontTable(String strSfntTag, int offset, int count);
public abstract byte[ ] getFontTable(int sfntTag, int offset, int count);
java.awt.font
java.awt.font.OpenType
Chapter 15 – The java.awt.font Package
295

public abstract int getFontTableSize(String strSfntTag);
public abstract int getFontTableSize(int sfntTag);
public abstract int getVersion();
}
ShapeGraphicAttribute
Ja va 1.2
java.awt.font
This concrete subclass of GraphicAttribute allows an arbitrary shape to be drawn within a
string of text. Create a ShapeGraphicAttribute by specifying a shape to draw and an align-
ment (one of the constants deﬁned by GraphicAttribute) that speciﬁes how the shape is
aligned with the rest of the text. Pass tr ue for the third argument, stroke, if the shape
should simply be drawn, or pass false if the shape should be ﬁlled. Use the ShapeGraphi-
cAttribute by specifying it as the value of a TextAttribute.CHAR_REPLACEMENT attribute in a
java.text.AttributedString or java.text.AttributedCharacterIterator
See also ImageGraphicAttribute.
public ﬁnal class ShapeGraphicAttribute extends GraphicAttribute {
// Public Constructors
public ShapeGraphicAttribute(Shape shape, int alignment, boolean stroke);
// Public Constants
=false
public static ﬁnal boolean FILL;
=true
public static ﬁnal boolean STROKE;
// Public Instance Methods
public boolean equals(ShapeGraphicAttribute rhs);
// Public Methods Overriding GraphicAttribute
public void draw(Graphics2D graphics, ﬂoat x, ﬂoat y);
public ﬂoat getAdvance();
public ﬂoat getAscent();
public java.awt.geom.Rectangle2D getBounds();
public ﬂoat getDescent();
// Public Methods Overriding Object
public boolean equals(Object rhs);
public int hashCode();
}
Hierar chy: Object→GraphicAttribute→ShapeGraphicAttribute
Passed To: ShapeGraphicAttribute.equals()
TextAttribute
Ja va 1.2
java.awt.font
serializable
This class deﬁnes constants that serve as attribute names and attribute values for use
with java.text.AttributedString and java.text.AttributedCharacterIterator objects. The constants of
type TextAttribute serve as attribute names. The other constants deﬁne commonly used
values for those attributes. Note that the value of the CHAR_REPLACEMENT attribute should
be a GraphicAttribute object, and the value of the TRANSFORM attribute should be a Trans-
for mAttribute object.
public ﬁnal class TextAttribute extends java.text.AttributedCharacterIterator.Attribute {
// Protected Constructors
protected TextAttribute(String name);
// Public Constants
public static ﬁnal TextAttribute BACKGROUND;
public static ﬁnal TextAttribute BIDI_EMBEDDING;
public static ﬁnal TextAttribute CHAR_REPLACEMENT;
java.awt.font.OpenType
296 Chapter 15 – The java.awt.font Package

public static ﬁnal TextAttribute FAMILY;
public static ﬁnal TextAttribute FONT;
public static ﬁnal TextAttribute FOREGROUND;
public static ﬁnal TextAttribute INPUT_METHOD_HIGHLIGHT;
public static ﬁnal TextAttribute JUSTIFICATION;
public static ﬁnal Float JUSTIFICATION_FULL;
public static ﬁnal Float JUSTIFICATION_NONE;
public static ﬁnal TextAttribute POSTURE;
public static ﬁnal Float POSTURE_OBLIQUE;
public static ﬁnal Float POSTURE_REGULAR;
public static ﬁnal TextAttribute RUN_DIRECTION;
public static ﬁnal Boolean RUN_DIRECTION_LTR;
public static ﬁnal Boolean RUN_DIRECTION_RTL;
public static ﬁnal TextAttribute SIZE;
public static ﬁnal TextAttribute STRIKETHROUGH;
public static ﬁnal Boolean STRIKETHROUGH_ON;
public static ﬁnal TextAttribute SUPERSCRIPT;
public static ﬁnal Integer SUPERSCRIPT_SUB;
public static ﬁnal Integer SUPERSCRIPT_SUPER;
public static ﬁnal TextAttribute SWAP_COLORS;
public static ﬁnal Boolean SWAP_COLORS_ON;
public static ﬁnal TextAttribute TRANSFORM;
public static ﬁnal TextAttribute UNDERLINE;
public static ﬁnal Integer UNDERLINE_ON;
public static ﬁnal TextAttribute WEIGHT;
public static ﬁnal Float WEIGHT_BOLD;
public static ﬁnal Float WEIGHT_DEMIBOLD;
public static ﬁnal Float WEIGHT_DEMILIGHT;
public static ﬁnal Float WEIGHT_EXTRA_LIGHT;
public static ﬁnal Float WEIGHT_EXTRABOLD;
public static ﬁnal Float WEIGHT_HEAVY;
public static ﬁnal Float WEIGHT_LIGHT;
public static ﬁnal Float WEIGHT_MEDIUM;
public static ﬁnal Float WEIGHT_REGULAR;
public static ﬁnal Float WEIGHT_SEMIBOLD;
public static ﬁnal Float WEIGHT_ULTRABOLD;
public static ﬁnal TextAttribute WIDTH;
public static ﬁnal Float WIDTH_CONDENSED;
public static ﬁnal Float WIDTH_EXTENDED;
public static ﬁnal Float WIDTH_REGULAR;
public static ﬁnal Float WIDTH_SEMI_CONDENSED;
public static ﬁnal Float WIDTH_SEMI_EXTENDED;
// Protected Methods Overriding AttributedCharacterIterator.Attribute
protected Object readResolve() throws java.io.InvalidObjectException;
}
Hierar chy: Object→java.text.AttributedCharacterIterator.Attribute(Serializable)→TextAttribute
Type Of: Too many fields to list.
TextHitInfo
Ja va 1.2
java.awt.font
This class encapsulates the position of a character within a string of text and the bias,
or side, of the character. The hitTestChar() method of TextLayout takes the position of a
mouse click and retur ns a TextHitInfo that speciﬁes where the click occurred.
getCharIndex() retur ns the position of the character that was hit. getInser tionIndex() retur ns
the position at which characters should be inserted or deleted. This may or may not be
java.awt.font
java.awt.font.TextHitInfo
Chapter 15 – The java.awt.font Package
297

the same as the value retur ned by getCharIndex(). isLeadingEdge() speciﬁes whether the hit
was on the leading edge of the character.
If you want to place the insertion cursor at the position of the mouse click, it is not suf-
ﬁcient to know which character was clicked on; you must also know whether the lead-
ing edge or the trailing edge of the character was clicked on. This is particularly
important when working with bidirectional text, such as Arabic or Hebrew. If the TextHit-
Info speciﬁes that the trailing edge was selected, the insertion cursor should be placed
befor e the character. Otherwise, it should be placed after the character.
In bidirectional text, positioning the cursor correctly in response to user requests to
move it left or right can be quite tricky. TextHitInfo is also retur ned by the getNextLeftHit()
and getNextRightHit() methods of TextLayout, to help solve this problem.
public ﬁnal class TextHitInfo {
// No Constructor
// Public Class Methods
public static TextHitInfo afterOffset(int offset);
public static TextHitInfo beforeOffset(int offset);
public static TextHitInfo leading(int charIndex);
public static TextHitInfo trailing(int charIndex);
// Property Accessor Methods (by property name)
public int getCharIndex();
public int getInser tionIndex();
public boolean isLeadingEdge();
public TextHitInfo getOtherHit();
// Public Instance Methods
public boolean equals(TextHitInfo hitInfo);
public TextHitInfo getOffsetHit(int delta);
// Public Methods Overriding Object
public boolean equals(Object obj);
public int hashCode();
public String toString();
}
Passed To: Too many methods to list.
Retur ned By: Too many methods to list.
TextLayout
Ja va 1.2
java.awt.font
cloneable
This class repr esents and displays a line of styled, possibly bidirectional, text and pro-
vides algorithms for the visual manipulation of that text. This is a powerful and com-
plex class. Many applications prefer to use high-level Swing components, such as
JTextF ield and JTextPane, to handle text display and editing. Some applications may want
to use the lower-level GlyphVector class for maximum text drawing speed.
Using the TextLayout() constructor, you can create a TextLayout fr om a java.text.AttributedChar-
acterIterator, from a string and a font, or from a string and a java.util.Map of attributes. All
versions of the constructor also requir e a FontRenderContext, obtained with the getFontRen-
derContext() method of Graphics2D.
Once you have created a TextLayout, you can draw it by calling its draw() method. TextLay-
out also provides various other methods to support applications that allow the user to
edit the text. If the user clicks on the text, you can determine what character was
clicked on with hitTestChar(), which retur ns a TextHitInfo. Once you have an insertion posi-
tion speciﬁed with a TextHitInfo, you can obtain a Shape appr opriate for use as an inser-
tion cursor by calling getCaretShape(). The retur ned shape is relative to the origin of the
TextLayout, and it takes into account whether the text is italic. getCaretShapes() is passed a
java.awt.font.TextHitInfo
298 Chapter 15 – The java.awt.font Package

character index within the TextLayout; it retur ns an array of one or two Shape objects that
repr esent insertion cursors for that character position. Usually this array contains only
one cursor, but in bidirectional text, it may contain both a primary insertion cursor and
a secondary insertion cursor.
If the user selects text by clicking and dragging with the mouse, you can call getV isual-
HighlightShape() to determine how to highlight the selected text. This method retur ns a
Shape object suitable for drawing the highlighted regions. Alternatively, you can use get-
LogicalHightlightShape() to highlight a speciﬁed contiguous group of characters in the Text-
Layout. Note, however, that in bidirectional text, this logical highlight might map to two
visually disjoint regions.
public ﬁnal class TextLayout implements Cloneable {
// Public Constructors
public TextLayout(java.text.AttributedCharacterIterator text, FontRenderContext frc);
public TextLayout(String string, Font font, FontRenderContext frc);
public TextLayout(String string, java.util.Map attributes, FontRenderContext frc);
// Public Constants
public static ﬁnal TextLayout.CaretPolicy DEFAULT_CARET_POLICY;
// Inner Classes
public static class CaretPolicy;
// Property Accessor Methods (by property name)
public ﬂoat getAdvance();
public ﬂoat getAscent();
public byte getBaseline();
public ﬂoat[ ] getBaselineOffsets();
public java.awt.geom.Rectangle2D getBounds();
public int getCharacterCount();
public ﬂoat getDescent();
public ﬂoat getLeading();
public boolean isLeftToRight();
public boolean isVer tical();
public ﬂoat getV isibleAdvance();
// Public Instance Methods
public void draw(Graphics2D g2, ﬂoat x, ﬂoat y);
public boolean equals(TextLayout rhs);
public Shape getBlackBoxBounds(int ﬁrstEndpoint, int secondEndpoint);
public ﬂoat[ ] getCaretInfo(TextHitInfo hit);
public ﬂoat[ ] getCaretInfo(TextHitInfo hit, java.awt.geom.Rectangle2D bounds);
public Shape getCaretShape(TextHitInfo hit);
public Shape getCaretShape(TextHitInfo hit, java.awt.geom.Rectangle2D bounds);
public Shape[ ] getCaretShapes(int offset);
public Shape[ ] getCaretShapes(int offset, java.awt.geom.Rectangle2D bounds);
public Shape[ ] getCaretShapes(int offset, java.awt.geom.Rectangle2D bounds, TextLayout.CaretPolicy policy);
public byte getCharacterLevel(int index);
public TextLayout getJustiﬁedLayout(ﬂoat justiﬁcationWidth);
public Shape getLogicalHighlightShape(int ﬁrstEndpoint, int secondEndpoint);
public Shape getLogicalHighlightShape(int ﬁrstEndpoint, int secondEndpoint,
java.awt.geom.Rectangle2D bounds);
public int[ ] getLogicalRangesForV isualSelection(TextHitInfo ﬁrstEndpoint, TextHitInfo secondEndpoint);
public TextHitInfo getNextLeftHit(int offset);
public TextHitInfo getNextLeftHit(TextHitInfo hit);
public TextHitInfo getNextLeftHit(int offset, TextLayout.CaretPolicy policy);
public TextHitInfo getNextRightHit(int offset);
public TextHitInfo getNextRightHit(TextHitInfo hit);
public TextHitInfo getNextRightHit(int offset, TextLayout.CaretPolicy policy);
public Shape getOutline(java.awt.geom.AfﬁneTransform tx);
public Shape getV isualHighlightShape(TextHitInfo ﬁrstEndpoint, TextHitInfo secondEndpoint);
public Shape getV isualHighlightShape(TextHitInfo ﬁrstEndpoint, TextHitInfo secondEndpoint,
java.awt.geom.Rectangle2D bounds);
java.awt.font
java.awt.font.TextLayout
Chapter 15 – The java.awt.font Package
299

public TextHitInfo getV isualOtherHit(TextHitInfo hit);
public TextHitInfo hitTestChar(ﬂoat x, ﬂoat y);
public TextHitInfo hitTestChar(ﬂoat x, ﬂoat y, java.awt.geom.Rectangle2D bounds);
// Public Methods Overriding Object
public boolean equals(Object obj);
public int hashCode();
public String toString();
// Protected Methods Overriding Object
protected Object clone();
// Protected Instance Methods
empty
protected void handleJustify(ﬂoat justiﬁcationWidth);
}
Hierar chy: Object→TextLayout(Cloneable)
Passed To: TextLayout.equals(), TextLayout.CaretPolicy.getStrongCaret()
Retur ned By: LineBreakMeasurer.nextLayout(), TextLayout.getJustifiedLayout()
TextLayout.CaretPolicy
Ja va 1.2
java.awt.font
This class deﬁnes a policy for deciding which insertion position is the dominant one in
bidir ectional text. Most applications never need to use this class.
If you want to specify a policy other than the default, you should subclass this class
and override getStrongCaret() to choose between two TextHitInfo objects, retur ning the one
that repr esents the dominant insertion position. Then pass an instance of your subclass
to the getCaretShapes(), getNextLeftHit(), and getNextRightHit() methods of TextLayout.
public static class TextLayout.CaretPolicy {
// Public Constructors
public CaretPolicy();
// Public Instance Methods
public TextHitInfo getStrongCaret(TextHitInfo hit1, TextHitInfo hit2, TextLayout layout);
}
Passed To: TextLayout.{getCaretShapes(), getNextLeftHit(), getNextRightHit()}
Type Of: TextLayout.DEFAULT_CARET_POLICY
TextLine.TextLineMetrics
Ja va 1.2
java.awt.font
This public inner class is deﬁned within a private class. It was inadvertently included in
the public API of java.awt.font but should be considered private.
public static ﬁnal class TextLine.TextLineMetrics {
// Public Constructors
public TextLineMetrics(ﬂoat ascent, ﬂoat descent, ﬂoat leading, ﬂoat advance);
// Public Instance Fields
public ﬁnal ﬂoat advance;
public ﬁnal ﬂoat ascent;
public ﬁnal ﬂoat descent;
public ﬁnal ﬂoat leading;
}
java.awt.font.TextLayout
300 Chapter 15 – The java.awt.font Package

Tr ansfor mAttribute
Ja va 1.2
java.awt.font
serializable
This class is a simple immutable wrapper around a java.awt.geom.AfﬁneTransfor m. This
wrapper makes it safe to use a transform as the value of a TextAttribute.TRANSFORM
attribute.
public ﬁnal class Tr ansfor mAttribute implements Serializable {
// Public Constructors
public Tr ansfor mAttribute(java.awt.geom.AfﬁneTransform transform);
// Public Instance Methods
public java.awt.geom.AfﬁneTransform getTransfor m();
}
Hierar chy: Object→Transfor mAttribute(Serializable)
java.awt.font
java.awt.font.Transfor mAttr ibute
Chapter 15 – The java.awt.font Package
301

CHAPTER 16
The java.awt.geom Package
The java.awt.geom package contains Java 2D classes and interfaces related to shapes
and geometry; the package is new in Java 1.2. Most of the classes in this package
ar e java.awt.Shape implementations that can be drawn and ﬁlled by a java.awt.Graph-
ics2D object. Note that some implementations store data using single-precision
ﬂoating-point coordinates, while others use double-precision coordinates. Other
important classes include AfﬁneTransfor m, Area, GeneralPath, and PathIterator. Figur e
16-1 shows the class hierarchy of this package.
AffineTransfor m
Ja va 1.2
java.awt.geom
cloneable serializable
An AfﬁneTransfor m repr esents an arbitrary linear transformation of a point, vector, shape,
or coordinate system by any combination of translation, rotation, scaling, ﬂipping, and
skewing. This is one of the most fundamental classes in Java 2D: the Java 2D rendering
pr ocess uses an AfﬁneTransfor m to convert from user coordinate space to the coordinate
space of the physical device. In addition to this implicit use of AfﬁneTransfor m, the class is
often used explicitly in Java 2D programming.
The transformations speciﬁed by AfﬁneTransfor m objects are quite general. But they are
all linear: straight lines remain straight, and parallel lines remain parallel under any
AfﬁneTransfor m. Although it is possible to imagine more general, nonlinear, transfor ma-
tions, Java 2D works only with afﬁne transformations. AfﬁneTransfor m is not an imple-
mentation of some more general Transfor m inter face.
Mathematically, an afﬁne transformation is repr esented by a 2-by-3 matrix of six num-
bers. The AfﬁneTransfor m class has constructors and methods that allow you to work with
this matrix directly, but unless you remember your linear algebra, you typically use the
higher-level methods of this class.
You can use a constructor to create an AfﬁneTransfor m, but it is usually easier to use one
of the static methods to create an AfﬁneTransfor m suitable for rotation about the origin,
rotation about an arbitrary point, scaling, shearing, or translation. Or, if you have an
existing AfﬁneTransfor m object that you want to reuse, you can use one of the setTo()
302

extends
implements
KEY
CLASS
ABSTRACT CLASS
FINAL CLASS
INTERFACE
java.awt
Object
java.lang
java.geom
Shape
AffineTransform
CubicCurve2D
PathIterator
Area
Dimension2D
FlatteningPathIterator
GeneralPath
Line2D
QuadCurve2D
Point2D
RectangularShape
Arc2D
NoninvertibleTransformException
IllegalPathStateException
Cloneable
Exception
RuntimeException
java.io
Serializable
CubicCurve2D.Double
CubicCurve2D.Float
Point2D.Double
Point2D.Float
QuadCurve2D.Double
QuadCurve2D.Float
Line2D.Double
Line2D.Float
Arc2D.Double
Arc2D.Float
Ellipse2D
Ellipse2D.Double
Ellipse2D.Float
Rectangle2D
Rectangle2D.Double
Rectangle2D.Float
RoundRectangle2D
RoundRectangle2D.Double
RoundRectangle2D.Float
Figur e 16−1: The java.awt.geom package
java.awt.
geom
java.awt.geom.AfﬁneTransfor m
Chapter 16 – The java.awt.geom Package
303

methods to specify a rotation, scale, shear, or translation to replace the existing trans-
for m. Note that a ﬂip transform is simply scaling by -1.0 in the X or Y dimension.
Often, however, you have an AfﬁneTransfor m that you want to transform further. The
rotate(), scale(), shear(), and translate() methods do this. Or, mor e generally, you can use
concatenate() or preConcatenate() to transform one AfﬁneTransfor m by another.
Once an AfﬁneTransfor m object is set to the desired transformation, the transfor m() method
can be used to transform points, or arrays of points, in the desired way. deltaTransfor m()
transfor ms a point or array of points, leaving out any translation component of the
transfor m. This is useful for transforming dimensions and position-independent vectors,
rather than transforming absolute coordinates. inverseTransfor m() per forms the inverse of
the transformation speciﬁed by an AfﬁneTransfor m. Finally, createTransfor medShape() retur ns
a java.awt.Shape that repr esents a transfor med version of the speciﬁed Shape.
isIdentity() retur ns tr ue if an AfﬁneTransfor m is an identity transform—that is, if it perfor ms
no transform at all. getType() retur ns a value that provides basic information about the
transfor m. The value retur ned is TYPE_IDENTITY, TYPE_GENERAL_TRANSFORM, or a bitmask of
the remaining type constants.
public class AfﬁneTransfor m implements Cloneable, Serializable {
// Public Constructors
public AfﬁneTransfor m();
public AfﬁneTransfor m(double[ ] ﬂatmatrix);
public AfﬁneTransfor m(ﬂoat[ ] ﬂatmatrix);
public AfﬁneTransfor m(AfﬁneTransform Tx);
public AfﬁneTransfor m(double m00, double m10, double m01, double m11, double m02, double m12);
public AfﬁneTransfor m(ﬂoat m00, ﬂoat m10, ﬂoat m01, ﬂoat m11, ﬂoat m02, ﬂoat m12);
// Public Constants
=64
public static ﬁnal int TYPE_FLIP;
=16
public static ﬁnal int TYPE_GENERAL_ROTATION;
=4
public static ﬁnal int TYPE_GENERAL_SCALE;
=32
public static ﬁnal int TYPE_GENERAL_TRANSFORM;
=0
public static ﬁnal int TYPE_IDENTITY;
=24
public static ﬁnal int TYPE_MASK_ROTATION;
=6
public static ﬁnal int TYPE_MASK_SCALE;
=8
public static ﬁnal int TYPE_QUADRANT_ROTATION;
=1
public static ﬁnal int TYPE_TRANSLATION;
=2
public static ﬁnal int TYPE_UNIFORM_SCALE;
// Public Class Methods
public static AfﬁneTransform getRotateInstance(double theta);
public static AfﬁneTransform getRotateInstance(double theta, double x, double y);
public static AfﬁneTransform getScaleInstance(double sx, double sy);
public static AfﬁneTransform getShearInstance(double shx, double shy);
public static AfﬁneTransform getTranslateInstance(double tx, double ty);
// Property Accessor Methods (by property name)
default:1.0
public double getDeter minant();
default:true
public boolean isIdentity();
default:1.0
public double getScaleX();
default:1.0
public double getScaleY();
default:0.0
public double getShearX();
default:0.0
public double getShearY();
default:0.0
public double getTranslateX();
default:0.0
public double getTranslateY();
default:0
public int getType();
// Public Instance Methods
public void concatenate(AfﬁneTransform Tx);
public AfﬁneTransform createInverse() throws NoninvertibleTransformException;
public Shape createTransfor medShape(Shape pSrc);
java.awt.geom.AfﬁneTransfor m
304 Chapter 16 – The java.awt.geom Package

public Point2D deltaTransfor m(Point2D ptSrc, Point2D ptDst);
public void deltaTransfor m(double[ ] srcPts, int srcOff, double[ ] dstPts, int dstOff, int numPts);
public void getMatrix(double[ ] ﬂatmatrix);
public Point2D inverseTransfor m(Point2D ptSrc, Point2D ptDst) throws NoninvertibleTransformException;
public void inverseTransfor m(double[ ] srcPts, int srcOff, double[ ] dstPts, int dstOff, int numPts)
throws NoninvertibleTransformException;
public void preConcatenate(AfﬁneTransform Tx);
public void rotate(double theta);
public void rotate(double theta, double x, double y);
public void scale(double sx, double sy);
public void setToIdentity();
public void setToRotation(double theta);
public void setToRotation(double theta, double x, double y);
public void setToScale(double sx, double sy);
public void setToShear(double shx, double shy);
public void setToTranslation(double tx, double ty);
public void setTransfor m(AfﬁneTransform Tx);
public void setTransfor m(double m00, double m10, double m01, double m11, double m02, double m12);
public void shear(double shx, double shy);
public Point2D transfor m(Point2D ptSrc, Point2D ptDst);
public void transfor m(ﬂoat[ ] srcPts, int srcOff, ﬂoat[ ] dstPts, int dstOff, int numPts);
public void transfor m(Point2D[ ] ptSrc, int srcOff, Point2D[ ] ptDst, int dstOff, int numPts);
public void transfor m(ﬂoat[ ] srcPts, int srcOff, double[ ] dstPts, int dstOff, int numPts);
public void transfor m(double[ ] srcPts, int srcOff, double[ ] dstPts, int dstOff, int numPts);
public void transfor m(double[ ] srcPts, int srcOff, ﬂoat[ ] dstPts, int dstOff, int numPts);
public void translate(double tx, double ty);
// Public Methods Overriding Object
public Object clone();
public boolean equals(Object obj);
public int hashCode();
public String toString();
}
Hierar chy: Object→AffineTransfor m(Cloneable, Serializable)
Passed To: Too many methods to list.
Retur ned By: Font.getTransfor m(), Graphics2D.getTransfor m(),
GraphicsConfiguration.{getDefaultTransfor m(), getNor malizingTransfor m()},
java.awt.font.FontRenderContext.getTransfor m(), java.awt.font.GlyphVector.getGlyphTransfor m(),
java.awt.font.Transfor mAttribute.getTransfor m(), AffineTransfor m.{createInverse(), getRotateInstance(),
getScaleInstance(), getShearInstance(), getTranslateInstance()},
java.awt.image.AffineTransfor mOp.getTransfor m(), java.awt.image.renderable.RenderContext.getTransfor m()
Arc2D
Ja va 1.2
java.awt.geom
cloneable shape
This abstract class is a java.awt.Shape that repr esents an arc. The arc is deﬁned as a por-
tion of an ellipse, where the ellipse is deﬁned by a rectangle. The start and end points
of the arc on that ellipse are deﬁned by a start angle and an extent angle, measured in
degr ees counterclockwise from the positive X axis. Unless the ellipse is actually a per-
fect circle, the speciﬁed angles are not true angles: a line drawn from the center of the
ellipse to the upper-right corner of the bounding rectangle is always considered to form
a 45-degr ee angle with the X axis, regardless of the true angle it forms.
In addition to the coordinates of the rectangle and the angles that specify the start and
end points of the arc, the shape of an Arc2D is also speciﬁed by its arcType pr operty. If
the type of the arc is speciﬁed as CHORD, the two end points are joined by a straight
line. If the type is speciﬁed as PIE, each of the two end points is joined to the center of
java.awt.
geom
java.awt.geom.Ar c2D
Chapter 16 – The java.awt.geom Package
305

the ellipse, forming a wedge, or slice of pie. If the type is speciﬁed as OPEN, the end
points are not joined and the resulting shape is an open curve that does not enclose a
region.
Arc2D is an abstract class and cannot be instantiated. Arc2D.Float and Arc2D.Double ar e
concr ete subclasses that use ﬂoat and double ﬁelds to store arc coordinates and angles.
public abstract class Arc2D extends RectangularShape {
// Protected Constructors
protected Arc2D(int type);
// Public Constants
=1
public static ﬁnal int CHORD;
=0
public static ﬁnal int OPEN;
=2
public static ﬁnal int PIE;
// Inner Classes
public static class Double extends Arc2D;
public static class Float extends Arc2D;
// Property Accessor Methods (by property name)
public abstract double getAngleExtent();
public abstract void setAngleExtent(double angExt);
public abstract double getAngleStar t();
public void setAngleStar t(Point2D p);
public abstract void setAngleStar t(double angSt);
public int getArcType();
public void setArcType(int type);
Overrides:RectangularShape
public Rectangle2D getBounds2D();
public Point2D getEndPoint();
public Point2D getStar tPoint();
// Public Instance Methods
public boolean containsAngle(double angle);
public void setAngles(Point2D p1, Point2D p2);
public void setAngles(double x1, double y1, double x2, double y2);
public void setArc(Arc2D a);
public void setArc(Rectangle2D rect, double angSt, double angExt, int closure);
public void setArc(Point2D loc, Dimension2D size, double angSt, double angExt, int closure);
public abstract void setArc(double x, double y, double w, double h, double angSt, double angExt, int closure);
public void setArcByCenter(double x, double y, double radius, double angSt, double angExt, int closure);
public void setArcByTangent(Point2D p1, Point2D p2, Point2D p3, double radius);
// Public Methods Overriding RectangularShape
public boolean contains(Rectangle2D r);
public boolean contains(double x, double y);
public boolean contains(double x, double y, double w, double h);
public PathIterator getPathIterator(AfﬁneTransform at);
public boolean intersects(double x, double y, double w, double h);
public void setFrame(double x, double y, double w, double h);
// Protected Instance Methods
protected abstract Rectangle2D makeBounds(double x, double y, double w, double h);
}
Hierar chy: Object→RectangularShape(Cloneable, Shape)→Arc2D
Subc lasses: Arc2D.Double, Arc2D.Float
Passed To: Arc2D.setArc()
Arc2D.Double
Ja va 1.2
java.awt.geom
cloneable shape
This class is a concrete implementation of Arc2D that uses double ﬁelds to store the coor-
dinates and angles of the arc. For efﬁciency, these x, y, width, height, star t, and extent
java.awt.geom.Ar c2D
306 Chapter 16 – The java.awt.geom Package

ﬁelds are declar ed public and may be used directly by Java programs. See Arc2D for
mor e infor mation.
public static class Arc2D.Double extends Arc2D {
// Public Constructors
public Double();
public Double(int type);
public Double(Rectangle2D ellipseBounds, double star t, double extent, int type);
public Double(double x, double y, double w, double h, double star t, double extent, int type);
// Public Methods Overriding Arc2D
default:0.0
public double getAngleExtent();
default:0.0
public double getAngleStar t();
public void setAngleExtent(double angExt);
public void setAngleStar t(double angSt);
public void setArc(double x, double y, double w, double h, double angSt, double angExt, int closure);
// Protected Methods Overriding Arc2D
protected Rectangle2D makeBounds(double x, double y, double w, double h);
// Public Methods Overriding RectangularShape
default:0.0
public double getHeight();
default:0.0
public double getW idth();
default:0.0
public double getX();
default:0.0
public double getY();
default:true
public boolean isEmpty();
// Public Instance Fields
public double extent;
public double height;
public double star t;
public double width;
public double x;
public double y;
}
Arc2D.Float
Ja va 1.2
java.awt.geom
cloneable shape
This class is a concrete implementation of Arc2D that uses ﬂoat ﬁelds to store the coordi-
nates and angles of the arc. For efﬁciency, these x, y, width, height, star t, and extent ﬁelds
ar e declar ed public and may be used directly by Java programs. See Arc2D for more
infor mation.
public static class Arc2D.Float extends Arc2D {
// Public Constructors
public Float();
public Float(int type);
public Float(Rectangle2D ellipseBounds, ﬂoat star t, ﬂoat extent, int type);
public Float(ﬂoat x, ﬂoat y, ﬂoat w, ﬂoat h, ﬂoat star t, ﬂoat extent, int type);
// Public Methods Overriding Arc2D
default:0.0
public double getAngleExtent();
default:0.0
public double getAngleStar t();
public void setAngleExtent(double angExt);
public void setAngleStar t(double angSt);
public void setArc(double x, double y, double w, double h, double angSt, double angExt, int closure);
// Protected Methods Overriding Arc2D
protected Rectangle2D makeBounds(double x, double y, double w, double h);
// Public Methods Overriding RectangularShape
default:0.0
public double getHeight();
default:0.0
public double getW idth();
default:0.0
public double getX();
default:0.0
public double getY();
java.awt.
geom
java.awt.geom.Ar c2D.Float
Chapter 16 – The java.awt.geom Package
307

default:true
public boolean isEmpty();
// Public Instance Fields
public ﬂoat extent;
public ﬂoat height;
public ﬂoat star t;
public ﬂoat width;
public ﬂoat x;
public ﬂoat y;
}
Area
Ja va 1.2
java.awt.geom
cloneable shape
Area is an implementation of java.awt.Shape that repr esents an arbitrary enclosed area.
The Area() constructor is passed an arbitrary Shape that deﬁnes the initial area. If this
Shape object repr esents an open curve that does not enclose an area, the curve is auto-
matically closed with a straight line between the end points. Once an Area object has
been created, it can be combined with another Area object with the add(), subtract(), inter-
sect(), and exclusiveOr() methods. For example, you can construct an Area object that rep-
resents a hexagon minus the intersection of two circles.
public class Area implements Cloneable, Shape {
// Public Constructors
public Area();
public Area(Shape s);
// Property Accessor Methods (by property name)
Implements:Shape
public Rectangle getBounds();
Implements:Shape default:Rectangle2D.Double
public Rectangle2D getBounds2D();
default:true
public boolean isEmpty();
default:true
public boolean isPolygonal();
default:true
public boolean isRectangular();
default:true
public boolean isSingular();
// Public Instance Methods
public void add(Area rhs);
public Area createTransfor medArea(AfﬁneTransform t);
public boolean equals(Area other);
public void exclusiveOr(Area rhs);
public void intersect(Area rhs);
public void reset();
public void subtract(Area rhs);
public void transfor m(AfﬁneTransform t);
// Methods Implementing Shape
public boolean contains(Point2D p);
public boolean contains(Rectangle2D p);
public boolean contains(double x, double y);
public boolean contains(double x, double y, double w, double h);
public Rectangle getBounds();
default:Rectangle2D.Double
public Rectangle2D getBounds2D();
public PathIterator getPathIterator(AfﬁneTransform at);
public PathIterator getPathIterator(AfﬁneTransform at, double ﬂatness);
public boolean intersects(Rectangle2D p);
public boolean intersects(double x, double y, double w, double h);
// Public Methods Overriding Object
public Object clone();
}
Hierar chy: Object→Area(Cloneable, Shape)
java.awt.geom.Ar c2D.Float
308 Chapter 16 – The java.awt.geom Package

Passed To: Area.{add(), equals(), exclusiveOr(), intersect(), subtract()}
Retur ned By: Area.createTransfor medArea()
CubicCur ve2D
Ja va 1.2
java.awt.geom
cloneable shape
This abstract class is a java.awt.Shape that repr esents a smooth cubic Bezier curve (or
spline) between end points p1 (x1, y1) and p2 (x2, y2). The precise shape of the curve is
deﬁned by two control points, cp1 (ctr lx1, ctr ly1) and cp2 (ctr lx2, ctr ly2). Note that the
curve does not pass through cp1 and cp2 but that it does remain inside the quadrilateral
deﬁned by p1, cp1, cp2, and p2.
CubicCur ve2D does not itself enclose an area, so the contains() methods test whether a
point or rectangle is within the area deﬁned by the curve and the straight line between
its end points.
CubicCur ve2D is an abstract class and cannot be instantiated. CubicCur ve2D.Float and Cubic-
Cur ve2D.Double ar e concr ete subclasses that use ﬂoat and double ﬁelds to store the end
points and control points. See also QuadCur ve2D, which is a quadratic Bezier curve that
uses only a single control point.
public abstract class CubicCur ve2D implements Cloneable, Shape {
// Protected Constructors
protected CubicCur ve2D();
// Inner Classes
public static class Double extends CubicCurve2D;
public static class Float extends CubicCurve2D;
// Public Class Methods
public static double getFlatness(double[ ] coords, int offset);
public static double getFlatness(double x1, double y1, double ctrlx1, double ctrly1, double ctrlx2, double ctrly2,
double x2, double y2);
public static double getFlatnessSq(double[ ] coords, int offset);
public static double getFlatnessSq(double x1, double y1, double ctrlx1, double ctrly1, double ctrlx2,
double ctrly2, double x2, double y2);
public static int solveCubic(double[ ] eqn);
public static void subdivide(CubicCurve2D src, CubicCurve2D left, CubicCurve2D right);
public static void subdivide(double[ ] src, int srcoff, double[ ] left, int leftoff, double[ ] right, int rightoff);
// Property Accessor Methods (by property name)
Implements:Shape
public Rectangle getBounds();
Implements:Shape
public abstract Rectangle2D getBounds2D();
public abstract Point2D getCtr lP1();
public abstract Point2D getCtr lP2();
public abstract double getCtr lX1();
public abstract double getCtr lX2();
public abstract double getCtr lY1();
public abstract double getCtr lY2();
public double getFlatness();
public double getFlatnessSq();
public abstract Point2D getP1();
public abstract Point2D getP2();
public abstract double getX1();
public abstract double getX2();
public abstract double getY1();
public abstract double getY2();
// Public Instance Methods
public void setCur ve(CubicCurve2D c);
public void setCur ve(double[ ] coords, int offset);
public void setCur ve(Point2D[ ] pts, int offset);
java.awt.
geom
java.awt.geom.CubicCur ve2D
Chapter 16 – The java.awt.geom Package
309

public void setCur ve(Point2D p1, Point2D cp1, Point2D cp2, Point2D p2);
public abstract void setCur ve(double x1, double y1, double ctrlx1, double ctrly1, double ctrlx2, double ctrly2,
double x2, double y2);
public void subdivide(CubicCurve2D left, CubicCurve2D right);
// Methods Implementing Shape
public boolean contains(Point2D p);
public boolean contains(Rectangle2D r);
public boolean contains(double x, double y);
public boolean contains(double x, double y, double w, double h);
public Rectangle getBounds();
public abstract Rectangle2D getBounds2D();
public PathIterator getPathIterator(AfﬁneTransform at);
public PathIterator getPathIterator(AfﬁneTransform at, double ﬂatness);
public boolean intersects(Rectangle2D r);
public boolean intersects(double x, double y, double w, double h);
// Public Methods Overriding Object
public Object clone();
}
Hierar chy: Object→CubicCur ve2D(Cloneable, Shape)
Subc lasses: CubicCur ve2D.Double, CubicCurve2D.Float
Passed To: CubicCur ve2D.{setCur ve(), subdivide()}
CubicCur ve2D.Double
Ja va 1.2
java.awt.geom
cloneable shape
This class is a concrete implementation of CubicCur ve2D that uses double ﬁelds to store
the end points and control points of the curve. The X and Y coordinates of these four
points are stor ed in public ﬁelds and may be used directly by Java programs. See Cubic-
Cur ve2D for more infor mation.
public static class CubicCur ve2D.Double extends CubicCurve2D {
// Public Constructors
public Double();
public Double(double x1, double y1, double ctrlx1, double ctrly1, double ctrlx2, double ctrly2, double x2,
double y2);
// Public Methods Overriding CubicCurve2D
default:Rectangle2D.Double
public Rectangle2D getBounds2D();
default:Point2D.Double
public Point2D getCtr lP1();
default:Point2D.Double
public Point2D getCtr lP2();
default:0.0
public double getCtr lX1();
default:0.0
public double getCtr lX2();
default:0.0
public double getCtr lY1();
default:0.0
public double getCtr lY2();
default:Point2D.Double
public Point2D getP1();
default:Point2D.Double
public Point2D getP2();
default:0.0
public double getX1();
default:0.0
public double getX2();
default:0.0
public double getY1();
default:0.0
public double getY2();
public void setCur ve(double x1, double y1, double ctrlx1, double ctrly1, double ctrlx2, double ctrly2, double x2,
double y2);
// Public Instance Fields
public double ctr lx1;
public double ctr lx2;
public double ctr ly1;
public double ctr ly2;
java.awt.geom.CubicCur ve2D
310 Chapter 16 – The java.awt.geom Package

public double x1;
public double x2;
public double y1;
public double y2;
}
CubicCur ve2D.Float
Ja va 1.2
java.awt.geom
cloneable shape
This class is a concrete implementation of CubicCur ve2D that uses ﬂoat ﬁelds to store the
end points and control points of the curve. The X and Y coordinates of these four
points are stor ed in public ﬁelds and may be used directly by Java programs. See Cubic-
Cur ve2D for more infor mation.
public static class CubicCur ve2D.Float extends CubicCurve2D {
// Public Constructors
public Float();
public Float(ﬂoat x1, ﬂoat y1, ﬂoat ctrlx1, ﬂoat ctrly1, ﬂoat ctrlx2, ﬂoat ctrly2, ﬂoat x2, ﬂoat y2);
// Public Instance Methods
public void setCur ve(ﬂoat x1, ﬂoat y1, ﬂoat ctrlx1, ﬂoat ctrly1, ﬂoat ctrlx2, ﬂoat ctrly2, ﬂoat x2, ﬂoat y2);
// Public Methods Overriding CubicCurve2D
default:Rectangle2D.Float
public Rectangle2D getBounds2D();
default:Point2D.Float
public Point2D getCtr lP1();
default:Point2D.Float
public Point2D getCtr lP2();
default:0.0
public double getCtr lX1();
default:0.0
public double getCtr lX2();
default:0.0
public double getCtr lY1();
default:0.0
public double getCtr lY2();
default:Point2D.Float
public Point2D getP1();
default:Point2D.Float
public Point2D getP2();
default:0.0
public double getX1();
default:0.0
public double getX2();
default:0.0
public double getY1();
default:0.0
public double getY2();
public void setCur ve(double x1, double y1, double ctrlx1, double ctrly1, double ctrlx2, double ctrly2, double x2,
double y2);
// Public Instance Fields
public ﬂoat ctr lx1;
public ﬂoat ctr lx2;
public ﬂoat ctr ly1;
public ﬂoat ctr ly2;
public ﬂoat x1;
public ﬂoat x2;
public ﬂoat y1;
public ﬂoat y2;
}
Dimension2D
Ja va 1.2
java.awt.geom
cloneable
This class repr esents a two-dimensional size in terms of its width and height. The
accessor methods deﬁned by this class query and set the width and height using values
of type double. Note, however, that this class is abstract and does not actually store a
size itself. java.awt.Dimension is a concrete subclass that stores a width and height as
integers.
java.awt.
geom
java.awt.geom.Dimension2D
Chapter 16 – The java.awt.geom Package
311

public abstract class Dimension2D implements Cloneable {
// Protected Constructors
protected Dimension2D();
// Property Accessor Methods (by property name)
public abstract double getHeight();
public abstract double getW idth();
// Public Instance Methods
public void setSize(Dimension2D d);
public abstract void setSize(double width, double height);
// Public Methods Overriding Object
public Object clone();
}
Hierar chy: Object→Dimension2D(Cloneable)
Subc lasses: Dimension
Passed To: Arc2D.setArc(), Dimension2D.setSize(), RectangularShape.setFrame()
Ellipse2D
Ja va 1.2
java.awt.geom
cloneable shape
This abstract class is a java.awt.Shape that repr esents an ellipse (or a circle). Ellipse2D is a
subclass of RectangularShape, and for this reason, the ellipse is deﬁned by its bounding
rectangle. The width and height of the bounding rectangle specify the length of the two
axes of the ellipse. (If the width and height are equal, the ellipse is a circle.) The X and
Y coordinates of the ellipse specify the upper-left corner of the bounding rectangle;
note that this point actually falls outside of the ellipse. The setFrameFromCenter() method,
inherited from RectangularShape, allows you to deﬁne the ellipse by specifying the center
and one corner. Note that Ellipse2D can only repr esent ellipses whose axes are parallel
to the X and Y axes of the coordinate system. In order to work with rotated ellipses,
use the createTransfor medShape() method of AfﬁneTransfor m or some other transformation
method.
Ellipse2D is an abstract class and cannot be instantiated. The concrete subclasses
Ellipse2D.Double and Ellipse2D.Float repr esent ellipses using double and ﬂoat ﬁelds to con-
tain the rectangular coordinates.
public abstract class Ellipse2D extends RectangularShape {
// Protected Constructors
protected Ellipse2D();
// Inner Classes
public static class Double extends Ellipse2D;
public static class Float extends Ellipse2D;
// Public Methods Overriding RectangularShape
public boolean contains(double x, double y);
public boolean contains(double x, double y, double w, double h);
public PathIterator getPathIterator(AfﬁneTransform at);
public boolean intersects(double x, double y, double w, double h);
}
Hierar chy: Object→RectangularShape(Cloneable, Shape)→Ellipse2D
Subc lasses: Ellipse2D.Double, Ellipse2D.Float
Ellipse2D.Double
Ja va 1.2
java.awt.geom
cloneable shape
This class is a concrete implementation of Ellipse2D that uses double ﬁelds to store the
coordinates of the bounding rectangle of the ellipse. These x, y, width, height ﬁelds are
java.awt.geom.Dimension2D
312 Chapter 16 – The java.awt.geom Package

declar ed public and may be used directly by Java programs. See Ellipse2D for more
infor mation.
public static class Ellipse2D.Double extends Ellipse2D {
// Public Constructors
public Double();
public Double(double x, double y, double w, double h);
// Public Methods Overriding RectangularShape
default:Rectangle2D.Double
public Rectangle2D getBounds2D();
default:0.0
public double getHeight();
default:0.0
public double getW idth();
default:0.0
public double getX();
default:0.0
public double getY();
default:true
public boolean isEmpty();
public void setFrame(double x, double y, double w, double h);
// Public Instance Fields
public double height;
public double width;
public double x;
public double y;
}
Ellipse2D.Float
Ja va 1.2
java.awt.geom
cloneable shape
This class is a concrete implementation of Ellipse2D that uses ﬂoat ﬁelds to store the
coordinates of the bounding rectangle of the ellipse. Note that these x, y, width, height
ﬁelds are declar ed public and may be used directly by Java programs. See Ellipse2D for
mor e infor mation.
public static class Ellipse2D.Float extends Ellipse2D {
// Public Constructors
public Float();
public Float(ﬂoat x, ﬂoat y, ﬂoat w, ﬂoat h);
// Public Instance Methods
public void setFrame(ﬂoat x, ﬂoat y, ﬂoat w, ﬂoat h);
// Public Methods Overriding RectangularShape
default:Rectangle2D.Float
public Rectangle2D getBounds2D();
default:0.0
public double getHeight();
default:0.0
public double getW idth();
default:0.0
public double getX();
default:0.0
public double getY();
default:true
public boolean isEmpty();
public void setFrame(double x, double y, double w, double h);
// Public Instance Fields
public ﬂoat height;
public ﬂoat width;
public ﬂoat x;
public ﬂoat y;
}
FlatteningPathIterator
Ja va 1.2
java.awt.geom
This class is a PathIterator that ﬂattens the curves retur ned by another PathIterator, appr ox-
imating them with straight-line segments that are easier to work with. The cur rentSeg-
ment() methods of FlatteningPathIterator ar e guaranteed never to retur n SEG_QUADTO or
SEG_CUBICTO curve segments.
java.awt.
geom
java.awt.geom.FlatteningPathIterator
Chapter 16 – The java.awt.geom Package
313

The ﬂatness of a cubic or quadratic curve is the distance from the curve to its control
points. Smaller distances imply ﬂatter curves (i.e., curves that are closer to a straight
line). The ﬂatness argument to the FlatteningPathIterator() constructor speciﬁes how ﬂat a
curve must be before it is appr oximated with a ﬂat line. Smaller values of ﬂatness result
in increasingly accurate approximations of the curves.
When a FlatteningPathIterator encounters a curve that is not ﬂat enough to approximate
with a straight line, it subdivides the curve into two curves, each of which is ﬂatter than
the original curve. This process of subdivision continues recursively until the sub-
divided curves are ﬂat enough to be approximated with line segments, up to the num-
ber of times speciﬁed by the limit argument. If limit is not speciﬁed, a default of 10 is
used, which means that no curve is broken down into more than 1,024 separate line
segments.
You should rarely need to use a FlatteningPathIterator explicitly in Java 2D programming.
The two-argument version of the getPathIterator() method of Shape takes a ﬂatness argu-
ment and retur ns a ﬂattened path that does not contain any curves. Implementations of
this method typically use FlatteningPathIterator inter nally.
public class FlatteningPathIterator implements PathIterator {
// Public Constructors
public FlatteningPathIterator(PathIterator src, double ﬂatness);
public FlatteningPathIterator(PathIterator src, double ﬂatness, int limit);
// Public Instance Methods
public double getFlatness();
public int getRecursionLimit();
// Methods Implementing PathIterator
public int cur rentSegment(double[ ] coords);
public int cur rentSegment(ﬂoat[ ] coords);
public int getW indingRule();
public boolean isDone();
public void next();
}
Hierar chy: Object→FlatteningPathIterator(PathIterator)
GeneralPath
Ja va 1.2
java.awt.geom
cloneable shape
This class repr esents an arbitrary path or shape that consists of any number of line seg-
ments and quadratic and cubic Bezier curves. After creating a GeneralPath object, you
must deﬁne a current point by calling moveTo(). Once an initial current point is estab-
lished, you can create the path by calling lineTo(), quadTo(), and cur veTo(). These methods
draw line segments, quadratic curves, and cubic curves from the current point to a new
point (which becomes the new current point).
The shape deﬁned by a GeneralPath need not be closed, although you may close it by
calling the closePath() method, which appends a line segment between the current point
and the initial point. Similarly, the path need not be continuous: you can call moveTo() at
any time to change the current point without adding a connecting line or curve to the
path. The append() method allows you to add a Shape or PathIterator to a GeneralPath,
optionally connecting it to the current point with a straight line.
The GeneralPath() constructor allows you to specify an estimate of the number of path
segments that will be added. Specifying an accurate estimate can increase efﬁciency. It
also allows you to specify the winding rule to use for the path. A winding rule is used
to determine what points are contained within a GeneralPath. The choice of winding
rules matters only for those paths that intersect themselves. The two choices are
WIND_EVEN_ODD and WIND_NON_ZERO.
java.awt.geom.FlatteningPathIterator
314 Chapter 16 – The java.awt.geom Package

Note the close correspondence between the path elements (lines, quadratic curves, and
cubic curves) that may be appended to a GeneralPath and those that are enumerated by
a PathIterator object.
public ﬁnal class GeneralPath implements Cloneable, Shape {
// Public Constructors
public GeneralPath();
public GeneralPath(int rule);
public GeneralPath(Shape s);
public GeneralPath(int rule, int initialCapacity);
// Public Constants
=0
public static ﬁnal int WIND_EVEN_ODD;
=1
public static ﬁnal int WIND_NON_ZERO;
// Property Accessor Methods (by property name)
Implements:Shape
public Rectangle getBounds();
Implements:Shape synchronized default:Rectangle2D.Float
public Rectangle2D getBounds2D();
synchronized default:null
public Point2D getCur rentPoint();
synchronized default:1
public int getW indingRule();
public void setW indingRule(int rule);
// Public Instance Methods
public void append(Shape s, boolean connect);
public void append(PathIterator pi, boolean connect);
synchronized
public void closePath();
synchronized
public Shape createTransfor medShape(AfﬁneTransform at);
synchronized
public void cur veTo(ﬂoat x1, ﬂoat y1, ﬂoat x2, ﬂoat y2, ﬂoat x3, ﬂoat y3);
synchronized
public void lineTo(ﬂoat x, ﬂoat y);
synchronized
public void moveTo(ﬂoat x, ﬂoat y);
synchronized
public void quadTo(ﬂoat x1, ﬂoat y1, ﬂoat x2, ﬂoat y2);
synchronized
public void reset();
public void transfor m(AfﬁneTransform at);
// Methods Implementing Shape
public boolean contains(Rectangle2D r);
public boolean contains(Point2D p);
public boolean contains(double x, double y);
public boolean contains(double x, double y, double w, double h);
public Rectangle getBounds();
synchronized default:Rectangle2D.Float
public Rectangle2D getBounds2D();
public PathIterator getPathIterator(AfﬁneTransform at);
public PathIterator getPathIterator(AfﬁneTransform at, double ﬂatness);
public boolean intersects(Rectangle2D r);
public boolean intersects(double x, double y, double w, double h);
// Public Methods Overriding Object
public Object clone();
}
Hierar chy: Object→GeneralPath(Cloneable, Shape)
IllegalPathStateException
Ja va 1.2
java.awt.geom
serializable unchecked
Signals that a path is not in an appropriate state for some requested operation. This
exception is thrown if you attempt to append a path segment to a GeneralPath befor e
per forming an initial moveTo().
public class IllegalPathStateException extends RuntimeException {
// Public Constructors
public IllegalPathStateException();
public IllegalPathStateException(String s);
}
java.awt.
geom
java.awt.geom.IllegalPathStateException
Chapter 16 – The java.awt.geom Package
315

Hierar chy: Object→Throwable(Serializable)→Exception→RuntimeException→
IllegalPathStateException
Line2D
Ja va 1.2
java.awt.geom
cloneable shape
This abstract class is a java.awt.Shape that repr esents a line segment between two end
points. Line2D deﬁnes various methods for computing the distance between a point and
a line or line segment and for computing the position of a point relative to a line. Note,
however, that the setLine() method for specifying the end points of the line segment is
abstract. The concrete subclasses Line2D.Double and Line2D.Float use double and ﬂoat ﬁelds
to store the coordinates of the end points. They deﬁne the setLine() method and con-
structors that accept the line segment end points as arguments. Since a line does not
contain an area, the contains() methods of Line2D and of its subclasses always retur n
false.
public abstract class Line2D implements Cloneable, Shape {
// Protected Constructors
protected Line2D();
// Inner Classes
public static class Double extends Line2D;
public static class Float extends Line2D;
// Public Class Methods
public static boolean linesIntersect(double X1, double Y1, double X2, double Y2, double X3, double Y3,
double X4, double Y4);
public static double ptLineDist(double X1, double Y1, double X2, double Y2, double PX, double PY);
public static double ptLineDistSq(double X1, double Y1, double X2, double Y2, double PX, double PY);
public static double ptSegDist(double X1, double Y1, double X2, double Y2, double PX, double PY);
public static double ptSegDistSq(double X1, double Y1, double X2, double Y2, double PX, double PY);
public static int relativeCCW(double X1, double Y1, double X2, double Y2, double PX, double PY);
// Property Accessor Methods (by property name)
Implements:Shape
public Rectangle getBounds();
Implements:Shape
public abstract Rectangle2D getBounds2D();
public abstract Point2D getP1();
public abstract Point2D getP2();
public abstract double getX1();
public abstract double getX2();
public abstract double getY1();
public abstract double getY2();
// Public Instance Methods
public boolean intersectsLine(Line2D l);
public boolean intersectsLine(double X1, double Y1, double X2, double Y2);
public double ptLineDist(Point2D pt);
public double ptLineDist(double PX, double PY);
public double ptLineDistSq(Point2D pt);
public double ptLineDistSq(double PX, double PY);
public double ptSegDist(Point2D pt);
public double ptSegDist(double PX, double PY);
public double ptSegDistSq(Point2D pt);
public double ptSegDistSq(double PX, double PY);
public int relativeCCW(Point2D p);
public int relativeCCW(double PX, double PY);
public void setLine(Line2D l);
public void setLine(Point2D p1, Point2D p2);
public abstract void setLine(double X1, double Y1, double X2, double Y2);
// Methods Implementing Shape
constant
public boolean contains(Point2D p);
constant
public boolean contains(Rectangle2D r);
java.awt.geom.IllegalPathStateException
316 Chapter 16 – The java.awt.geom Package

constant
public boolean contains(double x, double y);
constant
public boolean contains(double x, double y, double w, double h);
public Rectangle getBounds();
public abstract Rectangle2D getBounds2D();
public PathIterator getPathIterator(AfﬁneTransform at);
public PathIterator getPathIterator(AfﬁneTransform at, double ﬂatness);
public boolean intersects(Rectangle2D r);
public boolean intersects(double x, double y, double w, double h);
// Public Methods Overriding Object
public Object clone();
}
Hierar chy: Object→Line2D(Cloneable, Shape)
Subc lasses: Line2D.Double, Line2D.Float
Passed To: Line2D.{intersectsLine(), setLine()}, Rectangle2D.intersectsLine()
Line2D.Double
Ja va 1.2
java.awt.geom
cloneable shape
This class is a concrete implementation of Line2D that uses double ﬁelds to store the end
points of the line segment. These end points are stor ed in public ﬁelds and may be
dir ectly set and queried by programs. See Line2D for more infor mation.
public static class Line2D.Double extends Line2D {
// Public Constructors
public Double();
public Double(Point2D p1, Point2D p2);
public Double(double X1, double Y1, double X2, double Y2);
// Public Methods Overriding Line2D
default:Rectangle2D.Double
public Rectangle2D getBounds2D();
default:Point2D.Double
public Point2D getP1();
default:Point2D.Double
public Point2D getP2();
default:0.0
public double getX1();
default:0.0
public double getX2();
default:0.0
public double getY1();
default:0.0
public double getY2();
public void setLine(double X1, double Y1, double X2, double Y2);
// Public Instance Fields
public double x1;
public double x2;
public double y1;
public double y2;
}
Line2D.Float
Ja va 1.2
java.awt.geom
cloneable shape
This class is a concrete implementation of Line2D that uses ﬂoat ﬁelds to store the end
points of the line segment. These end points are stor ed in public ﬁelds and may be
dir ectly set and queried by programs. See Line2D for more infor mation.
public static class Line2D.Float extends Line2D {
// Public Constructors
public Float();
public Float(Point2D p1, Point2D p2);
public Float(ﬂoat X1, ﬂoat Y1, ﬂoat X2, ﬂoat Y2);
java.awt.
geom
java.awt.geom.Line2D.Float
Chapter 16 – The java.awt.geom Package
317

// Public Instance Methods
public void setLine(ﬂoat X1, ﬂoat Y1, ﬂoat X2, ﬂoat Y2);
// Public Methods Overriding Line2D
default:Rectangle2D.Float
public Rectangle2D getBounds2D();
default:Point2D.Float
public Point2D getP1();
default:Point2D.Float
public Point2D getP2();
default:0.0
public double getX1();
default:0.0
public double getX2();
default:0.0
public double getY1();
default:0.0
public double getY2();
public void setLine(double X1, double Y1, double X2, double Y2);
// Public Instance Fields
public ﬂoat x1;
public ﬂoat x2;
public ﬂoat y1;
public ﬂoat y2;
}
Noninver tibleTransfor mException
Ja va 1.2
java.awt.geom
serializable checked
Thr own when the inverse of a noninvertible AfﬁneTransfor m is requir ed. An example of a
noninvertible transformation is scaling the X dimension by a factor of 0. This maps all
points onto a vertical line, leaving no information about transforming those points back
to their original locations. This transform is noninvertible because division by zero is
not possible.
public class Noninver tibleTransfor mException extends Exception {
// Public Constructors
public Noninver tibleTransfor mException(String s);
}
Hierar chy: Object→Throwable(Serializable)→Exception→NoninvertibleTransfor mException
Thrown By: AffineTransfor m.{createInverse(), inverseTransfor m()}
PathIterator
Ja va 1.2
java.awt.geom
This interface is the basic Java 2D mechanism for deﬁning arbitrary shapes. The most
important requir ement of the java.awt.Shape inter face is that every shape be able to
retur n a PathIterator that traverses the outline of the shape. The information retur ned by
a PathIterator is sufﬁcient to allow the Java 2D rendering engine to stroke (draw) or ﬁll
arbitrarily complex shapes.
A PathIterator br eaks a shape or path down into individual path segments. The cur rentSeg-
ment() method retur ns the current segment. The next() method moves the iterator on to
the next segment, and isDone() retur ns tr ue if there are no mor e segments left to iterate.
getW indingRule() retur ns the winding rule for the shape—this value is used to determine
which points are inside complex self-intersecting shapes. The two possible values are
WIND_EVEN_ODD and WIND_NON_ZERO.
cur rentSegment() is the most important method of PathIterator. Its retur n value, one of the
ﬁve integer constants whose names begin with SEG, speciﬁes the type of the current
segment. cur rentSegment() retur ns the coordinates of the current segment in the ﬂoat or
double array passed as an argument. This array must have at least six elements. The seg-
ment types and their meanings are as follows:
java.awt.geom.Line2D.Float
318 Chapter 16 – The java.awt.geom Package

SEG_MOVETO
Deﬁnes a path starting point rather than an actual segment. The current point of
the path is set to the X,Y point speciﬁed in the ﬁrst two elements of the array. This
is the ﬁrst segment type of all paths. Paths may be disjoint, and may have more
than one SEG_MOVETO segment.
SEG_LINETO
Deﬁnes a line between the current point and the X,Y end point stored in the ﬁrst
two elements of the array. The end point of the line segment becomes the new
curr ent point.
SEG_QUADTO
Deﬁnes a quadratic Bezier curve between the current point and an end point
stor ed in the third and fourth elements of the array, using a control point stored in
the ﬁrst and second elements of the array. The end point of the curve becomes the
curr ent point.
SEG_CUBICTO
Deﬁnes a cubic Bezier curve between the current point and an end point stored in
the ﬁfth and sixth elements of the array, using two control points stored in the ﬁrst
thr ough fourth elements of the array. The end point of the curve becomes the cur-
rent point.
SEG_CLOSE
Speciﬁes that the path should be closed by drawing a straight line from the current
point back to the point speciﬁed by the most recent SEG_MOVETO segment. No val-
ues are stor ed in the array for this segment type.
public abstract interface PathIterator {
// Public Constants
=4
public static ﬁnal int SEG_CLOSE;
=3
public static ﬁnal int SEG_CUBICTO;
=1
public static ﬁnal int SEG_LINETO;
=0
public static ﬁnal int SEG_MOVETO;
=2
public static ﬁnal int SEG_QUADTO;
=0
public static ﬁnal int WIND_EVEN_ODD;
=1
public static ﬁnal int WIND_NON_ZERO;
// Public Instance Methods
public abstract int cur rentSegment(ﬂoat[ ] coords);
public abstract int cur rentSegment(double[ ] coords);
public abstract int getW indingRule();
public abstract boolean isDone();
public abstract void next();
}
Implementations: FlatteningPathIterator
Passed To: FlatteningPathIterator.FlatteningPathIterator(), GeneralPath.append()
Retur ned By: Too many methods to list.
Point2D
Ja va 1.2
java.awt.geom
cloneable
This abstract class repr esents a point in two-dimensional space. It has methods for get-
ting and setting the X and Y coordinates of the point as double values and for comput-
ing the distance between points.
java.awt.
geom
java.awt.geom.Point2D
Chapter 16 – The java.awt.geom Package
319

Point2D is abstract; it does not store actual coordinates and cannot be instantiated. You
must use one of its concrete subclasses instead. Point2D.Double stor es the coordinates of
a point using double ﬁelds, while Point2D.Float stor es the coordinates using ﬂoat ﬁelds.
Finally, java.awt.Point stor es the coordinates using int ﬁelds.
public abstract class Point2D implements Cloneable {
// Protected Constructors
protected Point2D();
// Inner Classes
public static class Double extends Point2D;
public static class Float extends Point2D;
// Public Class Methods
public static double distance(double X1, double Y1, double X2, double Y2);
public static double distanceSq(double X1, double Y1, double X2, double Y2);
// Property Accessor Methods (by property name)
public abstract double getX();
public abstract double getY();
// Public Instance Methods
public double distance(Point2D pt);
public double distance(double PX, double PY);
public double distanceSq(Point2D pt);
public double distanceSq(double PX, double PY);
public void setLocation(Point2D p);
public abstract void setLocation(double x, double y);
// Public Methods Overriding Object
public Object clone();
public boolean equals(Object obj);
public int hashCode();
}
Hierar chy: Object→Point2D(Cloneable)
Subc lasses: Point, Point2D.Double, Point2D.Float
Passed To: Too many methods to list.
Retur ned By: Too many methods to list.
Point2D.Double
Ja va 1.2
java.awt.geom
cloneable
This class is a concrete implementation of Point2D that stores the X and Y coordinates of
a point using double ﬁelds. These ﬁelds are public and can be queried and set directly,
without using accessor methods.
public static class Point2D.Double extends Point2D {
// Public Constructors
public Double();
public Double(double x, double y);
// Public Methods Overriding Point2D
default:0.0
public double getX();
default:0.0
public double getY();
public void setLocation(double x, double y);
// Public Methods Overriding Object
public String toString();
// Public Instance Fields
public double x;
public double y;
}
java.awt.geom.Point2D
320 Chapter 16 – The java.awt.geom Package

Point2D.Float
Ja va 1.2
java.awt.geom
cloneable
This class is a concrete implementation of Point2D that stores the X and Y coordinates of
a point using ﬂoat ﬁelds. These ﬁelds are public and can be queried and set directly,
without using accessor methods.
public static class Point2D.Float extends Point2D {
// Public Constructors
public Float();
public Float(ﬂoat x, ﬂoat y);
// Public Instance Methods
public void setLocation(ﬂoat x, ﬂoat y);
// Public Methods Overriding Point2D
default:0.0
public double getX();
default:0.0
public double getY();
public void setLocation(double x, double y);
// Public Methods Overriding Object
public String toString();
// Public Instance Fields
public ﬂoat x;
public ﬂoat y;
}
QuadCur ve2D
Ja va 1.2
java.awt.geom
cloneable shape
This abstract class is a java.awt.Shape that repr esents a smooth quadratic Bezier curve (or
spline) between end points p1 (x1, y1) and p2 (x2, y2). The precise shape of the curve is
deﬁned by a control point, cp (ctr lx, ctr ly). Note that the curve does not pass through cp
but that it does remain inside the triangle deﬁned by p1, cp, and p2.
QuadCur ve2D does not itself enclose an area, so the contains() methods test whether a
point or rectangle is within the area deﬁned by the curve and the straight line between
its end points.
QuadCur ve2D is an abstract class and cannot be instantiated. QuadCur ve2D.Float and Quad-
Cur ve2D.Double ar e concr ete subclasses that use ﬂoat and double ﬁelds to store the end
points and control point. See also CubicCur ve2D, which is a cubic Bezier curve that uses
two control points.
public abstract class QuadCur ve2D implements Cloneable, Shape {
// Protected Constructors
protected QuadCur ve2D();
// Inner Classes
public static class Double extends QuadCurve2D;
public static class Float extends QuadCurve2D;
// Public Class Methods
public static double getFlatness(double[ ] coords, int offset);
public static double getFlatness(double x1, double y1, double ctrlx, double ctrly, double x2, double y2);
public static double getFlatnessSq(double[ ] coords, int offset);
public static double getFlatnessSq(double x1, double y1, double ctrlx, double ctrly, double x2, double y2);
public static int solveQuadratic(double[ ] eqn);
public static void subdivide(QuadCurve2D src, QuadCurve2D left, QuadCurve2D right);
public static void subdivide(double[ ] src, int srcoff, double[ ] left, int leftoff, double[ ] right, int rightoff);
// Property Accessor Methods (by property name)
Implements:Shape
public Rectangle getBounds();
Implements:Shape
public abstract Rectangle2D getBounds2D();
public abstract Point2D getCtr lPt();
java.awt.
geom
java.awt.geom.QuadCur ve2D
Chapter 16 – The java.awt.geom Package
321

public abstract double getCtr lX();
public abstract double getCtr lY();
public double getFlatness();
public double getFlatnessSq();
public abstract Point2D getP1();
public abstract Point2D getP2();
public abstract double getX1();
public abstract double getX2();
public abstract double getY1();
public abstract double getY2();
// Public Instance Methods
public void setCur ve(QuadCurve2D c);
public void setCur ve(double[ ] coords, int offset);
public void setCur ve(Point2D[ ] pts, int offset);
public void setCur ve(Point2D p1, Point2D cp, Point2D p2);
public abstract void setCur ve(double x1, double y1, double ctrlx, double ctrly, double x2, double y2);
public void subdivide(QuadCurve2D left, QuadCurve2D right);
// Methods Implementing Shape
public boolean contains(Point2D p);
public boolean contains(Rectangle2D r);
public boolean contains(double x, double y);
public boolean contains(double x, double y, double w, double h);
public Rectangle getBounds();
public abstract Rectangle2D getBounds2D();
public PathIterator getPathIterator(AfﬁneTransform at);
public PathIterator getPathIterator(AfﬁneTransform at, double ﬂatness);
public boolean intersects(Rectangle2D r);
public boolean intersects(double x, double y, double w, double h);
// Public Methods Overriding Object
public Object clone();
}
Hierar chy: Object→QuadCur ve2D(Cloneable, Shape)
Subc lasses: QuadCur ve2D.Double, QuadCurve2D.Float
Passed To: QuadCur ve2D.{setCur ve(), subdivide()}
QuadCur ve2D.Double
Ja va 1.2
java.awt.geom
cloneable shape
This class is a concrete implementation of QuadCur ve2D that uses double ﬁelds to store
the end points and control point of the curve. The X and Y coordinates of these three
points are stor ed in public ﬁelds and may be used directly by Java programs. See Quad-
Cur ve2D for more infor mation.
public static class QuadCur ve2D.Double extends QuadCurve2D {
// Public Constructors
public Double();
public Double(double x1, double y1, double ctrlx, double ctrly, double x2, double y2);
// Public Methods Overriding QuadCurve2D
default:Rectangle2D.Double
public Rectangle2D getBounds2D();
default:Point2D.Double
public Point2D getCtr lPt();
default:0.0
public double getCtr lX();
default:0.0
public double getCtr lY();
default:Point2D.Double
public Point2D getP1();
default:Point2D.Double
public Point2D getP2();
default:0.0
public double getX1();
default:0.0
public double getX2();
java.awt.geom.QuadCur ve2D
322 Chapter 16 – The java.awt.geom Package

default:0.0
public double getY1();
default:0.0
public double getY2();
public void setCur ve(double x1, double y1, double ctrlx, double ctrly, double x2, double y2);
// Public Instance Fields
public double ctr lx;
public double ctr ly;
public double x1;
public double x2;
public double y1;
public double y2;
}
QuadCur ve2D.Float
Ja va 1.2
java.awt.geom
cloneable shape
This class is a concrete implementation of QuadCur ve2D that uses ﬂoat ﬁelds to store the
end points and control point of the curve. The X and Y coordinates of these three
points are stor ed in public ﬁelds and may be used directly by Java programs. See Quad-
Cur ve2D for more infor mation.
public static class QuadCur ve2D.Float extends QuadCurve2D {
// Public Constructors
public Float();
public Float(ﬂoat x1, ﬂoat y1, ﬂoat ctrlx, ﬂoat ctrly, ﬂoat x2, ﬂoat y2);
// Public Instance Methods
public void setCur ve(ﬂoat x1, ﬂoat y1, ﬂoat ctrlx, ﬂoat ctrly, ﬂoat x2, ﬂoat y2);
// Public Methods Overriding QuadCurve2D
default:Rectangle2D.Float
public Rectangle2D getBounds2D();
default:Point2D.Float
public Point2D getCtr lPt();
default:0.0
public double getCtr lX();
default:0.0
public double getCtr lY();
default:Point2D.Float
public Point2D getP1();
default:Point2D.Float
public Point2D getP2();
default:0.0
public double getX1();
default:0.0
public double getX2();
default:0.0
public double getY1();
default:0.0
public double getY2();
public void setCur ve(double x1, double y1, double ctrlx, double ctrly, double x2, double y2);
// Public Instance Fields
public ﬂoat ctr lx;
public ﬂoat ctr ly;
public ﬂoat x1;
public ﬂoat x2;
public ﬂoat y1;
public ﬂoat y2;
}
Rectangle2D
Ja va 1.2
java.awt.geom
cloneable shape
This abstract java.awt.Shape repr esents a rectangle speciﬁed by the location of its upper-
left corner, its width, and its height. Various methods compute intersections and unions
of rectangles, test whether a rectangle contains a point or contains another rectangle,
and test whether a rectangle intersects a line or another rectangle. The outcode() method
deter mines the spatial relationship between a point and a rectangle. The retur n value is
the sum of the OUT_ constants that specify which edges of the rectangle a point is out-
side of. A value of 0 means that the point is inside the rectangle, of course. Other
java.awt.
geom
java.awt.geom.Rectangle2D
Chapter 16 – The java.awt.geom Package
323

inter esting methods include setFrameFromDiagonal() and setFrameFromCenter(), inherited
fr om RectangularShape.
Rectangle2D is an abstract class that does not deﬁne any ﬁelds to store the size and posi-
tion of the rectangle and cannot be instantiated. Choose a concrete subclass based on
the type of data ﬁelds you desire: Rectangle2D.Double uses double ﬁelds, Rectangle2D.Float
uses ﬂoat ﬁelds, and java.awt.Rectangle uses int ﬁelds.
public abstract class Rectangle2D extends RectangularShape {
// Protected Constructors
protected Rectangle2D();
// Public Constants
=8
public static ﬁnal int OUT_BOTTOM;
=1
public static ﬁnal int OUT_LEFT;
=4
public static ﬁnal int OUT_RIGHT;
=2
public static ﬁnal int OUT_TOP;
// Inner Classes
public static class Double extends Rectangle2D;
public static class Float extends Rectangle2D;
// Public Class Methods
public static void intersect(Rectangle2D src1, Rectangle2D src2, Rectangle2D dest);
public static void union(Rectangle2D src1, Rectangle2D src2, Rectangle2D dest);
// Public Instance Methods
public void add(Point2D pt);
public void add(Rectangle2D r);
public void add(double newx, double newy);
public abstract Rectangle2D createIntersection(Rectangle2D r);
public abstract Rectangle2D createUnion(Rectangle2D r);
public boolean intersectsLine(Line2D l);
public boolean intersectsLine(double x1, double y1, double x2, double y2);
public int outcode(Point2D p);
public abstract int outcode(double x, double y);
public void setRect(Rectangle2D r);
public abstract void setRect(double x, double y, double w, double h);
// Public Methods Overriding RectangularShape
public boolean contains(double x, double y);
public boolean contains(double x, double y, double w, double h);
public Rectangle2D getBounds2D();
public PathIterator getPathIterator(AfﬁneTransform at);
public PathIterator getPathIterator(AfﬁneTransform at, double ﬂatness);
public boolean intersects(double x, double y, double w, double h);
public void setFrame(double x, double y, double w, double h);
// Public Methods Overriding Object
public boolean equals(Object obj);
public int hashCode();
}
Hierar chy: Object→RectangularShape(Cloneable, Shape)→Rectangle2D
Subc lasses: Rectangle, Rectangle2D.Double, Rectangle2D.Float
Passed To: Too many methods to list.
Retur ned By: Too many methods to list.
Rectangle2D.Double
Ja va 1.2
java.awt.geom
cloneable shape
This concrete subclass of Rectangle2D stor es the position and size of the rectangle in
ﬁelds of type double. These ﬁelds are declar ed public and can be set and queried
dir ectly without relying on accessor methods.
java.awt.geom.Rectangle2D
324 Chapter 16 – The java.awt.geom Package

public static class Rectangle2D.Double extends Rectangle2D {
// Public Constructors
public Double();
public Double(double x, double y, double w, double h);
// Public Methods Overriding Rectangle2D
public Rectangle2D createIntersection(Rectangle2D r);
public Rectangle2D createUnion(Rectangle2D r);
default:Rectangle2D.Double
public Rectangle2D getBounds2D();
public int outcode(double x, double y);
public void setRect(Rectangle2D r);
public void setRect(double x, double y, double w, double h);
// Public Methods Overriding RectangularShape
default:0.0
public double getHeight();
default:0.0
public double getW idth();
default:0.0
public double getX();
default:0.0
public double getY();
default:true
public boolean isEmpty();
// Public Methods Overriding Object
public String toString();
// Public Instance Fields
public double height;
public double width;
public double x;
public double y;
}
Rectangle2D.Float
Ja va 1.2
java.awt.geom
cloneable shape
This concrete subclass of Rectangle2D stor es the position and size of the rectangle in
ﬁelds of type ﬂoat. These ﬁelds are declar ed public and can be set and queried directly
without relying on accessor methods.
public static class Rectangle2D.Float extends Rectangle2D {
// Public Constructors
public Float();
public Float(ﬂoat x, ﬂoat y, ﬂoat w, ﬂoat h);
// Public Instance Methods
public void setRect(ﬂoat x, ﬂoat y, ﬂoat w, ﬂoat h);
// Public Methods Overriding Rectangle2D
public Rectangle2D createIntersection(Rectangle2D r);
public Rectangle2D createUnion(Rectangle2D r);
default:Rectangle2D.Float
public Rectangle2D getBounds2D();
public int outcode(double x, double y);
public void setRect(Rectangle2D r);
public void setRect(double x, double y, double w, double h);
// Public Methods Overriding RectangularShape
default:0.0
public double getHeight();
default:0.0
public double getW idth();
default:0.0
public double getX();
default:0.0
public double getY();
default:true
public boolean isEmpty();
// Public Methods Overriding Object
public String toString();
// Public Instance Fields
public ﬂoat height;
public ﬂoat width;
java.awt.
geom
java.awt.geom.Rectangle2D.Float
Chapter 16 – The java.awt.geom Package
325

public ﬂoat x;
public ﬂoat y;
}
RectangularShape
Ja va 1.2
java.awt.geom
cloneable shape
This abstract class is the base class for several java.awt.Shape implementations that have
a rectangular outline or bounding box. Its methods allow you to set and query the size
and position of the bounding rectangle in several interesting ways.
public abstract class RectangularShape implements Cloneable, Shape {
// Protected Constructors
protected RectangularShape();
// Property Accessor Methods (by property name)
Implements:Shape
public Rectangle getBounds();
Implements:Shape
public abstract Rectangle2D getBounds2D();
public double getCenterX();
public double getCenterY();
public abstract boolean isEmpty();
public Rectangle2D getFrame();
public void setFrame(Rectangle2D r);
public void setFrame(Point2D loc, Dimension2D size);
public abstract void setFrame(double x, double y, double w, double h);
public abstract double getHeight();
public double getMaxX();
public double getMaxY();
public double getMinX();
public double getMinY();
public abstract double getW idth();
public abstract double getX();
public abstract double getY();
// Public Instance Methods
public void setFrameFromCenter(Point2D center, Point2D corner);
public void setFrameFromCenter(double centerX, double centerY, double cornerX, double cornerY);
public void setFrameFromDiagonal(Point2D p1, Point2D p2);
public void setFrameFromDiagonal(double x1, double y1, double x2, double y2);
// Methods Implementing Shape
public boolean contains(Point2D p);
public boolean contains(Rectangle2D r);
public abstract boolean contains(double x, double y);
public abstract boolean contains(double x, double y, double w, double h);
public Rectangle getBounds();
public abstract Rectangle2D getBounds2D();
public abstract PathIterator getPathIterator(AfﬁneTransform at);
public PathIterator getPathIterator(AfﬁneTransform at, double ﬂatness);
public boolean intersects(Rectangle2D r);
public abstract boolean intersects(double x, double y, double w, double h);
// Public Methods Overriding Object
public Object clone();
}
Hierar chy: Object→RectangularShape(Cloneable, Shape)
Subc lasses: Arc2D, Ellipse2D, Rectangle2D, RoundRectangle2D
java.awt.geom.Rectangle2D.Float
326 Chapter 16 – The java.awt.geom Package

RoundRectangle2D
Ja va 1.2
java.awt.geom
cloneable shape
This abstract java.awt.Shape repr esents a rectangle with rounded corners, speciﬁed by the
position of the upper-left corner (before rounding), the width and height of the rectan-
gle, and the width and height of the arc used to round the corners. RoundRectangle2D is
abstract and may not be instantiated. Use the concrete subclasses RoundRectangle2D.Dou-
ble and RoundRectangle2D.Float, depending on the precision you desire for the rectangle
coordinates and dimensions.
public abstract class RoundRectangle2D extends RectangularShape {
// Protected Constructors
protected RoundRectangle2D();
// Inner Classes
public static class Double extends RoundRectangle2D;
public static class Float extends RoundRectangle2D;
// Property Accessor Methods (by property name)
public abstract double getArcHeight();
public abstract double getArcW idth();
// Public Instance Methods
public void setRoundRect(RoundRectangle2D rr);
public abstract void setRoundRect(double x, double y, double w, double h, double arcWidth, double arcHeight);
// Public Methods Overriding RectangularShape
public boolean contains(double x, double y);
public boolean contains(double x, double y, double w, double h);
public PathIterator getPathIterator(AfﬁneTransform at);
public boolean intersects(double x, double y, double w, double h);
public void setFrame(double x, double y, double w, double h);
}
Hierar chy: Object→RectangularShape(Cloneable, Shape)→RoundRectangle2D
Subc lasses: RoundRectangle2D.Double, RoundRectangle2D.Float
Passed To: RoundRectangle2D.setRoundRect(), RoundRectangle2D.Double.setRoundRect(),
RoundRectangle2D.Float.setRoundRect()
RoundRectangle2D.Double
Ja va 1.2
java.awt.geom
cloneable shape
This concrete subclass of RoundRectangle2D stor es the position and size of the rectangle
and the size of the rounded corners in ﬁelds of type double. These ﬁelds are declar ed
public and can be set and queried directly without relying on accessor methods.
public static class RoundRectangle2D.Double extends RoundRectangle2D {
// Public Constructors
public Double();
public Double(double x, double y, double w, double h, double arcw, double arch);
// Public Methods Overriding RoundRectangle2D
default:0.0
public double getArcHeight();
default:0.0
public double getArcW idth();
public void setRoundRect(RoundRectangle2D rr);
public void setRoundRect(double x, double y, double w, double h, double arcw, double arch);
// Public Methods Overriding RectangularShape
default:Rectangle2D.Double
public Rectangle2D getBounds2D();
default:0.0
public double getHeight();
default:0.0
public double getW idth();
default:0.0
public double getX();
default:0.0
public double getY();
java.awt.
geom
java.awt.geom.RoundRectangle2D.Double
Chapter 16 – The java.awt.geom Package
327

default:true
public boolean isEmpty();
// Public Instance Fields
public double archeight;
public double arcwidth;
public double height;
public double width;
public double x;
public double y;
}
RoundRectangle2D.Float
Ja va 1.2
java.awt.geom
cloneable shape
This concrete subclass of RoundRectangle2D stor es the position and size of the rectangle
and the size of the rounded corners in ﬁelds of type ﬂoat. These ﬁelds are declar ed
public and can be set and queried directly without relying on accessor methods.
public static class RoundRectangle2D.Float extends RoundRectangle2D {
// Public Constructors
public Float();
public Float(ﬂoat x, ﬂoat y, ﬂoat w, ﬂoat h, ﬂoat arcw, ﬂoat arch);
// Public Instance Methods
public void setRoundRect(ﬂoat x, ﬂoat y, ﬂoat w, ﬂoat h, ﬂoat arcw, ﬂoat arch);
// Public Methods Overriding RoundRectangle2D
default:0.0
public double getArcHeight();
default:0.0
public double getArcW idth();
public void setRoundRect(RoundRectangle2D rr);
public void setRoundRect(double x, double y, double w, double h, double arcw, double arch);
// Public Methods Overriding RectangularShape
default:Rectangle2D.Float
public Rectangle2D getBounds2D();
default:0.0
public double getHeight();
default:0.0
public double getW idth();
default:0.0
public double getX();
default:0.0
public double getY();
default:true
public boolean isEmpty();
// Public Instance Fields
public ﬂoat archeight;
public ﬂoat arcwidth;
public ﬂoat height;
public ﬂoat width;
public ﬂoat x;
public ﬂoat y;
}
java.awt.geom.RoundRectangle2D.Double
328 Chapter 16 – The java.awt.geom Package

CHAPTER 17
The java.awt.im Package
The java.awt.im package contains classes and interfaces used by input methods and
by the text-editing user interface components that interact with input methods.
Most applications rely on GUI components that have input method support built
in and do not need to use this package directly. In other words, input method
details are usually hidden by text input components, and application-level code
should never have to use these classes and interfaces. Figure 17-1 shows the class
hierarchy of this package, which is new in Java 1.2.
extends
KEY
CLASS
FINAL CLASS
INTERFACE
InputMethodHighlight
java.awt.im
java.lang
Object
InputContext
Character.Subset
InputMethodRequests
InputSubset
Figur e 17−1: The java.awt.im package
InputContext
Ja va 1.2
java.awt.im
This class serves as an intermediary between input methods and the text input compo-
nents that use them. An InputContext stor es the state related to one pending text compo-
sition operation. By default, there is one InputContext per Window. Components can
obtain this shared input context with the Component.getInputContext() method. Compo-
nents that need a private InputContext can create their own with InputContext.getInstance().
java.awt.im
329

public class InputContext {
// Protected Constructors
protected InputContext();
// Public Class Methods
public static InputContext getInstance();
// Property Accessor Methods (by property name)
constant
public Object getInputMethodControlObject();
// Public Instance Methods
synchronized empty
public void dispatchEvent(AWTEvent event);
empty
public void dispose();
synchronized empty
public void endComposition();
empty
public void removeNotify(Component client);
constant
public boolean selectInputMethod(java.util.Locale locale);
empty
public void setCharacterSubsets(Character.Subset[ ] subsets);
}
Retur ned By: Component.getInputContext(), Window.getInputContext(), InputContext.getInstance()
InputMethodHighlight
Ja va 1.2
java.awt.im
This class deﬁnes the highlighted or unhighlighted state of text being processed by an
input method. For input methods, highlighting can be used to distinguish converted
fr om unconverted text, as well as to distinguish selected from unselected text. Input-
MethodHighlight objects are used as attribute values retur ned by java.text.AttributedCharacterIt-
erator objects. Note the various InputMethodHighlight constants predeﬁned by this class.
public class InputMethodHighlight {
// Public Constructors
public InputMethodHighlight(boolean selected, int state);
public InputMethodHighlight(boolean selected, int state, int variation);
// Public Constants
=1
public static ﬁnal int CONVERTED_TEXT;
=0
public static ﬁnal int RAW_TEXT;
public static ﬁnal InputMethodHighlight SELECTED_CONVERTED_TEXT_HIGHLIGHT;
public static ﬁnal InputMethodHighlight SELECTED_RAW_TEXT_HIGHLIGHT;
public static ﬁnal InputMethodHighlight UNSELECTED_CONVERTED_TEXT_HIGHLIGHT;
public static ﬁnal InputMethodHighlight UNSELECTED_RAW_TEXT_HIGHLIGHT;
// Public Instance Methods
public int getState();
public int getVariation();
public boolean isSelected();
}
Type Of: InputMethodHighlight.{SELECTED_CONVERTED_TEXT_HIGHLIGHT,
SELECTED_RAW_TEXT_HIGHLIGHT, UNSELECTED_CONVERTED_TEXT_HIGHLIGHT,
UNSELECTED_RAW_TEXT_HIGHLIGHT}
InputMethodRequests
Ja va 1.2
java.awt.im
This interface deﬁnes the methods that a component must implement in order to accept
text input from input methods. A component need not implement these methods
dir ectly, but it must retur n an object that implements this interface from a getInputMethod-
Requests() method.
java.awt.im.InputContext
330 Chapter 17 – The java.awt.im Package

public abstract interface InputMethodRequests {
// Public Instance Methods
public abstract java.text.AttributedCharacterIterator cancelLatestCommittedText(
java.text.AttributedCharacterIterator.Attribute[ ] attributes);
public abstract java.text.AttributedCharacterIterator getCommittedText(int beginIndex, int endIndex,
java.text.AttributedCharacterIterator.Attribute[ ] attributes);
public abstract int getCommittedTextLength();
public abstract int getInser tPositionOffset();
public abstract java.awt.font.TextHitInfo getLocationOffset(int x, int y);
public abstract java.text.AttributedCharacterIterator getSelectedText(
java.text.AttributedCharacterIterator.Attribute[ ] attributes);
public abstract Rectangle getTextLocation(java.awt.font.TextHitInfo offset);
}
Retur ned By: Component.getInputMethodRequests(),
javax.swing .text.JTextComponent.getInputMethodRequests()
InputSubset
Ja va 1.2
java.awt.im
This class deﬁnes Character$Subset constants that are useful to input methods.
public ﬁnal class InputSubset extends Character.Subset {
// No Constructor
// Public Constants
public static ﬁnal InputSubset HALFWIDTH_KATAKANA;
public static ﬁnal InputSubset HANJA;
public static ﬁnal InputSubset KANJI;
public static ﬁnal InputSubset LATIN;
public static ﬁnal InputSubset LATIN_DIGITS;
public static ﬁnal InputSubset SIMPLIFIED_HANZI;
public static ﬁnal InputSubset TRADITIONAL_HANZI;
}
Hierar chy: Object→Character.Subset→InputSubset
Type Of: InputSubset.{HALFWIDTH_KATAKANA, HANJA, KANJI, LATIN, LATIN_DIGITS, SIMPLIFIED_HANZI,
TRADITIONAL_HANZI}
java.awt.im
java.awt.im.InputSubset
Chapter 17 – The java.awt.im Package
331

CHAPTER 18
The java.awt.image Package
The java.awt.image package contains classes and interfaces for manipulating images.
Note that the java.awt.Image class itself is not part of this package. In Java 1.0 and
Java 1.1, the image processing model was optimized for streaming image data
loaded over a network and processed on the ﬂy. It involved the ImageProducer,
ImageConsumer, and ImageObser ver inter faces and the ImageF ilter class. This image-pro-
cessing model is complex and difﬁcult to use. Much of it has been superseded in
Java 1.2.
In Java 2D, the image-processing model has been extended (and simpliﬁed) to
accommodate image data that is stored and manipulated in memory. The key
pieces of this new image-processing model are the BufferedImage class, which rep-
resents an image in memory, and the BufferedImageOp inter face, which repr esents
an image-processing operation. Every BufferedImage contains a Raster object that
hold the pixels of the image and a ColorModel object that can interpret those pixel
values as Color objects. A Raster object, in turn, contains a DataBuffer that holds the
raw image data and a SampleModel object that knows how to extract pixel values
fr om that raw data.
Figur e 18-1 shows the class hierarchy of this package. See Chapter 4, Graphics
with AWT and Java 2D, for a discussion of images and image processing.
AffineTransfor mOp
Ja va 1.2
java.awt.image
This class is a
BufferedImageOp
and a
RasterOp
that perfor ms
an arbitrary
java.awt.geom.AfﬁneTransfor m on a BufferedImage or Raster. To create an AfﬁneTransfor mOp, you
must specify the desired AfﬁneTransfor m and the interpolation mode to use when interpo-
lation is necessary to determine the pixel or color values of the destination. TYPE_NEAR-
EST_NEIGHBOR is the quicker form of interpolation, but TYPE_BILINEAR pr oduces better
results. You may also specify the type of interpolation to use by specifying a
java.awt.RenderingHints object that contains an interpolation hint.
332

extends
implements
KEY
CLASS
ABSTRACT CLASS
INTERFACE
FINAL CLASS
java.lang
Object
java.awt
Image
java.awt.image
AfflineTransformOp
DataBufferByte
BandCombineOp
ColorConvertOp
LookupOp
ColorModel
MemoryImageSource
ImageFilter
Kernel
PixelGrabber
LookupTable
Raster
SampleModel
ComponentColorModel
DirectColorModel
BufferedImageFilter
CropImageFilter
ReplicateScaleFilter
RGBImageFilter
ByteLookupTable
ShortLookupTable
WritableRaster
ComponentSampleModel
MultiPixelPackedSampleModel
SinglePixelPackedSampleModel
Rendered Image
ImageOpException
BufferedImage
RasterFormatException
RuntimeException
ConvolveOp
RescaleOp
DataBuffer
DataBufferInt
DataBufferShort
DataBufferUshort
WritableRenderedImage
Cloneable
PixelInterleavedSampleModel
BandedSampleModel
AreaAveragingScaleFilter
PackedColorModel
IndexColorModel
RasterOp
BufferedImageOp
TileObserver
ImageProducer
ImageConsumer
ImageObserver
FilteredImageSource
Figur e 18−1: The java.awt.image package
java.awt.
image
java.awt.image.AfﬁneTransfor mOp
Chapter 18 – The java.awt.image Package
333

To use an AfﬁneTransfor mOp, simply pass a BufferedImage or Raster to the ﬁlter() method.
Note that for this operation the destination image or raster cannot be the same as the
source image or raster. See BufferedImageOp for further details.
public class AfﬁneTransfor mOp implements BufferedImageOp, RasterOp {
// Public Constructors
public AfﬁneTransfor mOp(java.awt.geom.AfﬁneTransform xform, RenderingHints hints);
public AfﬁneTransfor mOp(java.awt.geom.AfﬁneTransform xform, int interpolationType);
// Public Constants
=2
public static ﬁnal int TYPE_BILINEAR;
=1
public static ﬁnal int TYPE_NEAREST_NEIGHBOR;
// Public Instance Methods
public ﬁnal int getInterpolationType();
public ﬁnal java.awt.geom.AfﬁneTransform getTransfor m();
// Methods Implementing BufferedImageOp
public BufferedImage createCompatibleDestImage(BufferedImage src, ColorModel destCM);
public ﬁnal BufferedImage ﬁlter(BufferedImage src, BufferedImage dst);
public ﬁnal java.awt.geom.Rectangle2D getBounds2D(BufferedImage src);
public ﬁnal java.awt.geom.Point2D getPoint2D(java.awt.geom.Point2D srcPt, java.awt.geom.Point2D dstPt);
public ﬁnal RenderingHints getRenderingHints();
// Methods Implementing RasterOp
public WritableRaster createCompatibleDestRaster(Raster src);
public ﬁnal WritableRaster ﬁlter(Raster src, WritableRaster dst);
public ﬁnal java.awt.geom.Rectangle2D getBounds2D(Raster src);
}
Hierar chy: Object→AffineTransfor mOp(BufferedImageOp, RasterOp)
AreaAveragingScaleF ilter
Ja va 1.1
java.awt.image
cloneable PJ1.1
This class implements an ImageF ilter that scales an image to a speciﬁed pixel size. It uses
a scaling algorithm that averages adjacent pixel values when shrinking an image, which
pr oduces relatively smooth scaled images. Its superclass, ReplicateScaleF ilter, implements
a faster, less smooth scaling algorithm. The easiest way to use this ﬁlter is to call the
getScaledInstance() method of java.awt.Image, specifying an appropriate hint constant.
The methods of this class are ImageConsumer methods intended for communication
between the image ﬁlter and the FilteredImageSource that uses it. Applications do not usu-
ally call these methods directly.
public class AreaAveragingScaleF ilter extends ReplicateScaleFilter {
// Public Constructors
public AreaAveragingScaleF ilter(int width, int height);
// Public Methods Overriding ReplicateScaleFilter
public void setPixels(int x, int y, int w, int h, ColorModel model, int[ ] pixels, int off, int scansize);
public void setPixels(int x, int y, int w, int h, ColorModel model, byte[ ] pixels, int off, int scansize);
// Public Methods Overriding ImageF ilter
public void setHints(int hints);
}
Hierar chy: Object→ImageF ilter(Cloneable, ImageConsumer)→ReplicateScaleF ilter→
AreaAveragingScaleF ilter
BandCombineOp
Ja va 1.2
java.awt.image
This RasterOp allows the bands of image data in a Raster to be arbitrarily combined using
a matrix. For example, you can use a BandCombineOp to convert three bands of color
java.awt.image.AfﬁneTransfor mOp
334 Chapter 18 – The java.awt.image Package

image data to a single band of grayscale image data. The number of columns of the
matrix should be equal to the number of bands in the source raster or the number of
bands plus one, if you are adding constant values as part of the combination. The num-
ber of rows in the matrix should be equal to the number of bands in the destination
Raster.
As an example, consider the following matrix with four columns and three rows, used
to convert a Raster with three bands to another three-banded raster:




m11
m12
m13
m21
m22
m23
m31
m32
m33
c1
c2
c3




This matrix is used to convert the source bands s1, s2, and s3 into destination bands d1,
d2, and d3, using the following formulas:
d1 = s1*m11 + s2*m21 + s3*m31 + c1;
d2 = s1*m12 + s2*m22 + s3*m32 + c2;
d3 = s1*m13 + s2*m23 + s3*m33 + c3;
If the constants c1, c2, and c3 ar e all 0, they can be omitted from the vector.
After creating a BandCombineOp for a speciﬁed vector, you perfor m the operation by
passing a source and optional destination Raster to the ﬁlter() method. Because this oper-
ation processes each pixel independently, you can specify the same Raster object as
both source and destination. BandCombineOp does not implement BufferedImageOp and
cannot be used to process BufferedImage objects. See RasterOp for further details.
public class BandCombineOp implements RasterOp {
// Public Constructors
public BandCombineOp(ﬂoat[ ][ ] matrix, RenderingHints hints);
// Public Instance Methods
public ﬁnal ﬂoat[ ][ ] getMatrix();
// Methods Implementing RasterOp
public WritableRaster createCompatibleDestRaster(Raster src);
public WritableRaster ﬁlter(Raster src, WritableRaster dst);
public ﬁnal java.awt.geom.Rectangle2D getBounds2D(Raster src);
public ﬁnal java.awt.geom.Point2D getPoint2D(java.awt.geom.Point2D srcPt, java.awt.geom.Point2D dstPt);
public ﬁnal RenderingHints getRenderingHints();
}
Hierar chy: Object→BandCombineOp(RasterOp)
BandedSampleModel
Ja va 1.2
java.awt.image
This SampleModel repr esents image data stored so that each color component is in a
separate data element of a DataBuffer and each band of color components is in a sepa-
rate bank of the DataBuffer. For example, it can be used to repr esent RGB colors stored
in three separate banks of shor t values. Most applications never need to use this class.
See SampleModel for further information.
public ﬁnal class BandedSampleModel extends ComponentSampleModel {
// Public Constructors
public BandedSampleModel(int dataType, int w, int h, int numBands);
public BandedSampleModel(int dataType, int w, int h, int scanlineStride, int[ ] bankIndices, int[ ] bandOffsets);
// Public Methods Overriding ComponentSampleModel
public SampleModel createCompatibleSampleModel(int w, int h);
public DataBuffer createDataBuffer();
public SampleModel createSubsetSampleModel(int[ ] bands);
java.awt.
image
java.awt.image.BandedSampleModel
Chapter 18 – The java.awt.image Package
335

public Object getDataElements(int x, int y, Object obj, DataBuffer data);
public int[ ] getPixel(int x, int y, int[ ] iArray, DataBuffer data);
public int[ ] getPixels(int x, int y, int w, int h, int[ ] iArray, DataBuffer data);
public int getSample(int x, int y, int b, DataBuffer data);
public int[ ] getSamples(int x, int y, int w, int h, int b, int[ ] iArray, DataBuffer data);
public void setDataElements(int x, int y, Object obj, DataBuffer data);
public void setPixel(int x, int y, int[ ] iArray, DataBuffer data);
public void setPixels(int x, int y, int w, int h, int[ ] iArray, DataBuffer data);
public void setSample(int x, int y, int b, int s, DataBuffer data);
public void setSamples(int x, int y, int w, int h, int b, int[ ] iArray, DataBuffer data);
}
Hierar chy: Object→SampleModel→ComponentSampleModel→BandedSampleModel
BufferedImage
Ja va 1.2
java.awt.image
This is the central class in the simpliﬁed, immediate-mode imaging API introduced in
Java 1.2 as part of Java 2D. A BufferedImage repr esents an image as a rectangular array of
pixels in a Raster object and a ColorModel object that is capable of interpreting the pixel
values of the Raster. BufferedImage extends java.awt.Image and can therefor e be used any-
wher e that an Image can. However, a BufferedImage always holds its image data in mem-
ory, so there is no need for the complicated ImageObser ver inter face to handle
asynchr onous notiﬁcations as image data loads over a network.
If you know the data format of the image you need, you can create a BufferedImage by
calling the BufferedImage() constructor. For example, to create an off-scr een image with
an alpha channel for use in complex color compositing operations, you can call
BufferedImage() with the desired image size and an image type of TYPE_INT_ARGB. If you
want to create an off-scr een image and you do not need an alpha channel, it is easier
to simply call the createImage() method of a java.awt.Component. Although this method is
declar ed to retur n an Image, in Java 1.2 it is guaranteed to retur n a BufferedImage. The
advantage to using this method is that it creates a BufferedImage with a type that is the
same as (or can be efﬁciently converted to) the type used on your screen. If you do not
have a Component handy, you can achieve the same effect by calling the createCompati-
bleImage() method of the java.awt.GraphicsConﬁguration object that repr esents your screen
conﬁguration.
Once you have created a BufferedImage, you can call createGraphics() to obtain a Graph-
ics2D object that you can use to draw into the image. You can draw a BufferedImage onto
the screen or into any other image, using any of the drawImage() methods of Graphics or
Graphics2D. You can perfor m image processing on a BufferedImage by passing it to the ﬁl-
ter() method of any BufferedImageOp object. Finally, you can query and set individual pix-
els (or blocks of pixels) in a BufferedImage with getRGB() and setRGB(). These methods use
the default ARGB color model: each pixel contains 8 bits of alpha, red, green, and blue
data.
BufferedImage implements WritableRenderedImage, which in turn implements RenderedImage.
These interfaces are used primarily by the forthcoming Java Advanced Imaging (JAI)
API (javax.jai.*). Their methods allow an image to be divided up into multiple rectangu-
lar tiles. The BufferedImage class deﬁnes each image as a single tile, so most of these
methods have trivial implementations. Most applications can simply ignore the Rendered-
Image and WritableRenderedImage methods of this class.
public class BufferedImage extends Image implements WritableRenderedImage {
// Public Constructors
public BufferedImage(int width, int height, int imageType);
java.awt.image.BandedSampleModel
336 Chapter 18 – The java.awt.image Package

public BufferedImage(ColorModel cm, WritableRaster raster, boolean isRasterPremultiplied,
java.util.Hashtable proper ties);
public BufferedImage(int width, int height, int imageType, IndexColorModel cm);
// Public Constants
=5
public static ﬁnal int TYPE_3BYTE_BGR;
=6
public static ﬁnal int TYPE_4BYTE_ABGR;
=7
public static ﬁnal int TYPE_4BYTE_ABGR_PRE;
=12
public static ﬁnal int TYPE_BYTE_BINARY;
=10
public static ﬁnal int TYPE_BYTE_GRAY;
=13
public static ﬁnal int TYPE_BYTE_INDEXED;
=0
public static ﬁnal int TYPE_CUSTOM;
=2
public static ﬁnal int TYPE_INT_ARGB;
=3
public static ﬁnal int TYPE_INT_ARGB_PRE;
=4
public static ﬁnal int TYPE_INT_BGR;
=1
public static ﬁnal int TYPE_INT_RGB;
=9
public static ﬁnal int TYPE_USHORT_555_RGB;
=8
public static ﬁnal int TYPE_USHORT_565_RGB;
=11
public static ﬁnal int TYPE_USHORT_GRAY;
// Property Accessor Methods (by property name)
public boolean isAlphaPremultiplied();
public WritableRaster getAlphaRaster();
Implements:RenderedImage
public ColorModel getColorModel();
Implements:RenderedImage
public Raster getData();
Implements:RenderedImage
public Raster getData(Rectangle rect);
Implements:WritableRenderedImage
public void setData(Raster r);
Overrides:Image
public Graphics getGraphics();
Implements:RenderedImage
public int getHeight();
Overrides:Image
public int getHeight(ImageObserver obser ver);
Implements:RenderedImage constant
public int getMinT ileX();
Implements:RenderedImage constant
public int getMinT ileY();
Implements:RenderedImage
public int getMinX();
Implements:RenderedImage
public int getMinY();
Implements:RenderedImage constant
public int getNumXT iles();
Implements:RenderedImage constant
public int getNumYT iles();
Implements:RenderedImage constant
public String[ ] getProper tyNames();
public WritableRaster getRaster();
Implements:RenderedImage
public SampleModel getSampleModel();
Overrides:Image
public ImageProducer getSource();
Implements:RenderedImage constant
public java.util.Vector getSources();
Implements:RenderedImage
public int getT ileGridXOffset();
Implements:RenderedImage
public int getT ileGridYOffset();
Implements:RenderedImage
public int getT ileHeight();
Implements:RenderedImage
public int getT ileWidth();
public int getType();
Implements:RenderedImage
public int getW idth();
Overrides:Image
public int getW idth(ImageObserver obser ver);
Implements:WritableRenderedImage
public Point[ ] getWritableT ileIndices();
// Public Instance Methods
public void coerceData(boolean isAlphaPremultiplied);
public Graphics2D createGraphics();
public int getRGB(int x, int y);
public int[ ] getRGB(int star tX, int star tY, int w, int h, int[ ] rgbArray, int offset, int scansize);
public BufferedImage getSubimage(int x, int y, int w, int h);
synchronized
public void setRGB(int x, int y, int rgb);
public void setRGB(int star tX, int star tY, int w, int h, int[ ] rgbArray, int offset, int scansize);
// Other Methods Implementing RenderedImage
public WritableRaster copyData(WritableRaster outRaster);
public Object getProper ty(String name);
java.awt.
image
java.awt.image.BufferedImage
Chapter 18 – The java.awt.image Package
337

public Raster getT ile(int tileX, int tileY);
// Methods Implementing WritableRenderedImage
empty
public void addT ileObserver(T ileObserver to);
public WritableRaster getWritableT ile(int tileX, int tileY);
public Point[ ] getWritableT ileIndices();
constant
public boolean hasT ileWriters();
public boolean isT ileWritable(int tileX, int tileY);
empty
public void releaseWritableT ile(int tileX, int tileY);
empty
public void removeT ileObserver(T ileObserver to);
public void setData(Raster r);
// Public Methods Overriding Image
empty
public void ﬂush();
public Object getProper ty(String name, ImageObserver obser ver);
// Public Methods Overriding Object
public String toString();
}
Hierar chy: Object→Image→BufferedImage(WritableRenderedImage(RenderedImage))
Passed To: Too many methods to list.
Retur ned By: Too many methods to list.
BufferedImageF ilter
Ja va 1.2
java.awt.image
cloneable
This class allows a Java 1.2 BufferedImageOp image-pr ocessing operation to be used as an
ImageF ilter in the Java 1.0 and Java 1.1 image processing model. Create a BufferedImage-
Filter by passing a BufferedImageOp to the constructor. Then use the resulting BufferedIm-
ageF ilter with a FilteredImageSource exactly as you would use RGBImageF ilter, CropImageF ilter,
or any other Java 1.0 or Java 1.1 image ﬁlter.
public class BufferedImageF ilter extends ImageFilter implements Cloneable {
// Public Constructors
public BufferedImageF ilter(BufferedImageOp op);
// Public Instance Methods
public BufferedImageOp getBufferedImageOp();
// Public Methods Overriding ImageF ilter
public void imageComplete(int status);
public void setColorModel(ColorModel model);
public void setDimensions(int width, int height);
public void setPixels(int x, int y, int w, int h, ColorModel model, int[ ] pixels, int off, int scansize);
public void setPixels(int x, int y, int w, int h, ColorModel model, byte[ ] pixels, int off, int scansize);
}
Hierar chy: Object→ImageF ilter(Cloneable, ImageConsumer)→BufferedImageF ilter(Cloneable)
BufferedImageOp
Ja va 1.2
java.awt.image
This interface describes an image-processing operation that can be perfor med on any
BufferedImage. Java 2D includes a number of versatile implementations of this interface
that most applications can rely for all their image-processing needs.
To use a BufferedImageOp, call its ﬁlter() method. This method processes a speciﬁed
source image and stores the results in a speciﬁed destination image. If no destination
image is speciﬁed, the method creates and retur ns an appropriate one. You can pass a
source image to getBounds2D() to get the bounding box of the destination image that
would be produced if that source image were to be passed to ﬁlter(). Given a point in a
java.awt.image.BufferedImage
338 Chapter 18 – The java.awt.image Package

(hypothetical) source image, getPoint2D() retur ns the corresponding point in the destina-
tion image. If a destination Point2D object is provided, it is used to retur n the destination
point; otherwise a Point2D object is allocated for this purpose. getRenderingHints() retur ns
the rendering hints associated with this implementation of BufferedImageOp, or null if it
has no rendering hints. Finally, createCompatibleDestImage() is an internal method that
implementations must deﬁne but that applications never need to call.
public abstract interface BufferedImageOp {
// Public Instance Methods
public abstract BufferedImage createCompatibleDestImage(BufferedImage src, ColorModel destCM);
public abstract BufferedImage ﬁlter(BufferedImage src, BufferedImage dest);
public abstract java.awt.geom.Rectangle2D getBounds2D(BufferedImage src);
public abstract java.awt.geom.Point2D getPoint2D(java.awt.geom.Point2D srcPt, java.awt.geom.Point2D dstPt);
public abstract RenderingHints getRenderingHints();
}
Implementations: AffineTransfor mOp, ColorConvertOp, ConvolveOp, LookupOp, RescaleOp
Passed To: Graphics2D.drawImage(), BufferedImageF ilter.BufferedImageF ilter()
Retur ned By: BufferedImageF ilter.getBufferedImageOp()
ByteLookupTable
Ja va 1.2
java.awt.image
This concrete subclass of LookupTable contains one or more byte arrays that serve as
lookup tables for a LookupOp image-pr ocessing operation. Applications never need to
use a ByteLookupTable dir ectly; they need to create one only to pass to the LookupOp()
constructor. Create a ByteLookupTable by passing the byte array or arrays to the
ByteLookupTable() constructor, along with an offset that is subtracted from each source
color component before the lookup is perfor med. See also LookupTable.
public class ByteLookupTable extends LookupTable {
// Public Constructors
public ByteLookupTable(int offset, byte[ ][ ] data);
public ByteLookupTable(int offset, byte[ ] data);
// Public Instance Methods
public ﬁnal byte[ ][ ] getTable();
public byte[ ] lookupPixel(byte[ ] src, byte[ ] dst);
// Public Methods Overriding LookupTable
public int[ ] lookupPixel(int[ ] src, int[ ] dst);
}
Hierar chy: Object→LookupTable→ByteLookupTable
ColorConver tOp
Ja va 1.2
java.awt.image
This class is a BufferedImageOp and a RasterOp that converts the colors of a BufferedImage
or a Raster fr om one color space to another color space. If the ﬁlter() method is called
with two distinct source and destination BufferedImage objects speciﬁed, it converts the
colors from the java.awt.color.ColorSpace of the source image to the ColorSpace of the desti-
nation image. If no destination image is passed to ﬁlter(), the destination ColorSpace must
have been speciﬁed when the ColorConvertOp() constructor was called. Finally, if this Col-
orConvertOp is to be used to ﬁlter Raster object, both the source and destination color
spaces must be speciﬁed, either in the form of ColorSpace objects or as an array of two
java.awt.color.ICC_PROFILE objects.
In addition to optionally specifying the source and destination color spaces when you
invoke the ColorConvertOp() constructor, you may also specify a RenderingHints object. If
java.awt.
image
java.awt.image.ColorConvertOp
Chapter 18 – The java.awt.image Package
339

the hints object is non-null, the ColorConvertOp may use the color rendering and dithering
hints it contains.
To use a ColorConvertOp, simply pass a source and optional destination image or raster to
the ﬁlter() method. Because the ColorConvertOp works on each pixel of the image or raster
independently, you may specify the same object for both source and destination. In this
case, the image or raster is modiﬁed in place. See BufferedImageOp for further details.
public class ColorConver tOp implements BufferedImageOp, RasterOp {
// Public Constructors
public ColorConver tOp(RenderingHints hints);
public ColorConver tOp(java.awt.color.ICC_Proﬁle[ ] proﬁles, RenderingHints hints);
public ColorConver tOp(java.awt.color.ColorSpace cspace, RenderingHints hints);
public ColorConver tOp(java.awt.color.ColorSpace srcCspace, java.awt.color.ColorSpace dstCspace,
RenderingHints hints);
// Public Instance Methods
public ﬁnal java.awt.color.ICC_Proﬁle[ ] getICC_Proﬁles();
// Methods Implementing BufferedImageOp
public BufferedImage createCompatibleDestImage(BufferedImage src, ColorModel destCM);
public ﬁnal BufferedImage ﬁlter(BufferedImage src, BufferedImage dest);
public ﬁnal java.awt.geom.Rectangle2D getBounds2D(BufferedImage src);
public ﬁnal java.awt.geom.Point2D getPoint2D(java.awt.geom.Point2D srcPt, java.awt.geom.Point2D dstPt);
public ﬁnal RenderingHints getRenderingHints();
// Methods Implementing RasterOp
public WritableRaster createCompatibleDestRaster(Raster src);
public ﬁnal WritableRaster ﬁlter(Raster src, WritableRaster dest);
public ﬁnal java.awt.geom.Rectangle2D getBounds2D(Raster src);
}
Hierar chy: Object→ColorConvertOp(BufferedImageOp, RasterOp)
ColorModel
Ja va 1.0
java.awt.image
PJ1.1
This abstract class deﬁnes a scheme for repr esenting colors as pixels. The primary job
of a ColorModel object is to extract individual color components from pixel values. Most
applications do not need to work with ColorModel objects directly; those that do usually
need only to instantiate an appropriate ColorModel subclass for use by some other
method or constructor.
In Java 1.0 and 1.1, this is a fairly simple class: pixel values are supplied as int values,
and the getRed(), getGreen(), getBlue(), and getAlpha() methods retur n the red, green, blue,
and alpha components of the pixel. The getRGB() method converts a pixel to the pixel
for mat used by the default ARGB color model. This color model is retur ned by the
static getRGBDefault() method; it packs 8-bit color and alpha components into a 32-bit int
in 0xAARRGGBB for mat.
With the introduction of Java 2D in Java 1.2, this class has become more complicated.
Now the ColorModel is not tied to the default RGB java.awt.color.ColorSpace and provides
methods for extracting color components from any color space. The getComponents()
method and its variants retur n an array of color components for a given pixel value. If
the ColorModel is deﬁned in terms of the CMYK color space, for example, these compo-
nents are not red, green, and blue, but cyan, magenta, yellow, and black. Note, how-
ever, that because every ColorSpace can convert colors to the default RGB color space,
the getRed(), getGreen(), getBlue(), and getRGB() methods still work, regardless of color
space.
Another generalization to the ColorModel class in Java 1.2 is that pixel values are no
longer assumed to ﬁt in int values. Each method that extracts color components from
pixels comes in two forms. In the ﬁrst, the pixel value is speciﬁed as an int. In the
java.awt.image.ColorConvertOp
340 Chapter 18 – The java.awt.image Package

second form, it is speciﬁed as a Object. This object is an array of primitive values. The
type of these values is known as the transfer type of the color model and is speciﬁed
by one of the constants DataBuffer.TYPE_BYTE, Databuffer.TYPE_USHORT, or DataBuffer.TYPE_INT.
In simple cases, the elements of the transfer type arrays contain color components, and
the ColorModel object provides a trivial mapping between pixel values and color compo-
nent values.
Other ColorModel additions in Java 1.2 include the implementation of the Transparency
inter face and its getTransparency() method. This method retur ns a Transparency constant
that speciﬁes the level of transparency supported by the ColorModel. For ColorModel
objects that support transparency, the isAlphaPremultiplied() method speciﬁes whether the
color components have been premultiplied by the alpha component. (Premultiplication
makes alpha compositing operations more efﬁcient.) Also, the getNor malizedComponents()
and getUnnor malizedComponents() convert back and forth between normalized and unnor-
malized color component values. A normalized component is a ﬂoat value between 0.0
and 1.0 that has not been premultiplied by an alpha value. An unnormalized compo-
nent is an integral value with a range that depends on the number of bits used by the
color model, possibly premultiplied by the alpha value.
Ther e ar e a number of ColorModel subclasses, suitable for distinctly differ ent types of
color models. See also ComponentColorModel, DirectColorModel, IndexColorModel, and Packed-
ColorModel.
public abstract class ColorModel implements Transparency {
// Public Constructors
public ColorModel(int bits);
// Protected Constructors
1.2 protected ColorModel(int pixel_bits, int[ ] bits, java.awt.color.ColorSpace cspace, boolean hasAlpha,
boolean isAlphaPremultiplied, int transparency, int transferType);
// Public Class Methods
public static ColorModel getRGBdefault();
// Property Accessor Methods (by property name)
1.2 public ﬁnal boolean isAlphaPremultiplied();
1.2 public ﬁnal java.awt.color.ColorSpace getColorSpace();
1.2 public int[ ] getComponentSize();
1.2 public int getComponentSize(int componentIdx);
1.2 public int getNumColorComponents();
1.2 public int getNumComponents();
public int getPixelSize();
Implements:Transparency
1.2 public int getTransparency();
// Public Instance Methods
1.2 public ColorModel coerceData(WritableRaster raster, boolean isAlphaPremultiplied);
1.2 public SampleModel createCompatibleSampleModel(int w, int h);
1.2 public WritableRaster createCompatibleWritableRaster(int w, int h);
1.2 public int getAlpha(Object inData);
public abstract int getAlpha(int pixel);
constant
1.2 public WritableRaster getAlphaRaster(WritableRaster raster);
1.2 public int getBlue(Object inData);
public abstract int getBlue(int pixel);
1.2 public int[ ] getComponents(int pixel, int[ ] components, int offset);
1.2 public int[ ] getComponents(Object pixel, int[ ] components, int offset);
1.2 public int getDataElement(int[ ] components, int offset);
1.2 public Object getDataElements(int rgb, Object pixel);
1.2 public Object getDataElements(int[ ] components, int offset, Object obj);
1.2 public int getGreen(Object inData);
public abstract int getGreen(int pixel);
1.2 public ﬂoat[ ] getNor malizedComponents(int[ ] components, int offset, ﬂoat[ ] normComponents,
int normOffset);
java.awt.
image
java.awt.image.ColorModel
Chapter 18 – The java.awt.image Package
341

public abstract int getRed(int pixel);
1.2 public int getRed(Object inData);
public int getRGB(int pixel);
1.2 public int getRGB(Object inData);
1.2 public int[ ] getUnnor malizedComponents(ﬂoat[ ] normComponents, int normOffset, int[ ] components,
int offset);
1.2 public ﬁnal boolean hasAlpha();
1.2 public boolean isCompatibleRaster(Raster raster);
1.2 public boolean isCompatibleSampleModel(SampleModel sm);
// Methods Implementing Transparency
1.2 public int getTransparency();
// Public Methods Overriding Object
1.2 public boolean equals(Object obj);
empty
public void ﬁnalize();
1.2 public String toString();
// Protected Instance Fields
protected int pixel_bits;
1.2 protected int transferType;
}
Hierar chy: Object→ColorModel(Transparency)
Subc lasses: ComponentColorModel, IndexColorModel, PackedColorModel
Passed To: Too many methods to list.
Retur ned By: Component.getColorModel(), GraphicsConfiguration.getColorModel(),
PaintContext.getColorModel(), Toolkit.getColorModel(), BufferedImage.getColorModel(),
ColorModel.{coerceData(), getRGBdefault()}, ComponentColorModel.coerceData(),
DirectColorModel.coerceData(), PixelGrabber.getColorModel(), RenderedImage.getColorModel(),
java.awt.peer.ComponentPeer.getColorModel()
Type Of: RGBImageF ilter.{newmodel, origmodel}
ComponentColorModel
Ja va 1.2
java.awt.image
This ColorModel is used with image data in which the color and transparency compo-
nents of pixels are stor ed separately, instead of being combined together into a single
int value. This class works only with pixel values speciﬁed as an array of primitive val-
ues of the speciﬁed transfer type. The number of elements in these pixel arrays must
match the number of color and transparency components in the speciﬁed color space.
This class perfor ms the trivial mapping between the array elements of the pixel value
and the color components of the color it repr esents. The methods of this class that are
passed int pixel values can throw IllegalArgumentException. Only applications that are
doing custom image processing need to use this, or any, ColorModel.
public class ComponentColorModel extends ColorModel {
// Public Constructors
public ComponentColorModel(java.awt.color.ColorSpace colorSpace, int[ ] bits, boolean hasAlpha,
boolean isAlphaPremultiplied, int transparency, int transferType);
// Public Methods Overriding ColorModel
public ColorModel coerceData(WritableRaster raster, boolean isAlphaPremultiplied);
public SampleModel createCompatibleSampleModel(int w, int h);
public WritableRaster createCompatibleWritableRaster(int w, int h);
public boolean equals(Object obj);
public int getAlpha(Object inData);
public int getAlpha(int pixel);
public WritableRaster getAlphaRaster(WritableRaster raster);
java.awt.image.ColorModel
342 Chapter 18 – The java.awt.image Package

public int getBlue(Object inData);
public int getBlue(int pixel);
public int[ ] getComponents(Object pixel, int[ ] components, int offset);
public int[ ] getComponents(int pixel, int[ ] components, int offset);
public int getDataElement(int[ ] components, int offset);
public Object getDataElements(int rgb, Object pixel);
public Object getDataElements(int[ ] components, int offset, Object obj);
public int getGreen(Object inData);
public int getGreen(int pixel);
public int getRed(int pixel);
public int getRed(Object inData);
public int getRGB(int pixel);
public int getRGB(Object inData);
public boolean isCompatibleRaster(Raster raster);
public boolean isCompatibleSampleModel(SampleModel sm);
}
Hierar chy: Object→ColorModel(Transparency)→ComponentColorModel
ComponentSampleModel
Ja va 1.2
java.awt.image
This SampleModel repr esents image data stored so that each component of each pixel is
stor ed in a separate element of the DataBuffer. The arguments to the ComponentSample-
Model allow great ﬂexibility in this model. For example, it can repr esent RGB values
interleaved into a single bank of bytes or ARGB values stored in four separate banks of
bytes. Additionally, it can handle offsets at the end of scanlines and an offset at the
beginning of each bank.
Java 2D deﬁnes two subclasses of ComponentSampleModel that are mor e ef ﬁcient for par-
ticular types of image data. When each band of pixel components is stored in a sepa-
rate bank of the DataBuffer, it is easier and more efﬁcient to use the BandedSampleModel
subclass. When the components of a pixel are stor ed in adjacent data elements of a sin-
gle bank of the DataBuffer, it is easier and more efﬁcient to use PixelInter leavedSample-
Model.
Most applications never need to use this class or its subclasses. See SampleModel for fur-
ther information.
public class ComponentSampleModel extends SampleModel {
// Public Constructors
public ComponentSampleModel(int dataType, int w, int h, int pixelStride, int scanlineStride, int[ ] bandOffsets);
public ComponentSampleModel(int dataType, int w, int h, int pixelStride, int scanlineStride, int[ ] bankIndices,
int[ ] bandOffsets);
// Property Accessor Methods (by property name)
public ﬁnal int[ ] getBandOffsets();
public ﬁnal int[ ] getBankIndices();
Overrides:SampleModel
public ﬁnal int getNumDataElements();
public ﬁnal int getPixelStride();
Overrides:SampleModel
public ﬁnal int[ ] getSampleSize();
Overrides:SampleModel
public ﬁnal int getSampleSize(int band);
public ﬁnal int getScanlineStride();
// Public Instance Methods
public int getOffset(int x, int y);
public int getOffset(int x, int y, int b);
// Public Methods Overriding SampleModel
public SampleModel createCompatibleSampleModel(int w, int h);
public DataBuffer createDataBuffer();
java.awt.
image
java.awt.image.ComponentSampleModel
Chapter 18 – The java.awt.image Package
343

public SampleModel createSubsetSampleModel(int[ ] bands);
public Object getDataElements(int x, int y, Object obj, DataBuffer data);
public int[ ] getPixel(int x, int y, int[ ] iArray, DataBuffer data);
public int[ ] getPixels(int x, int y, int w, int h, int[ ] iArray, DataBuffer data);
public int getSample(int x, int y, int b, DataBuffer data);
public int[ ] getSamples(int x, int y, int w, int h, int b, int[ ] iArray, DataBuffer data);
public void setDataElements(int x, int y, Object obj, DataBuffer data);
public void setPixel(int x, int y, int[ ] iArray, DataBuffer data);
public void setPixels(int x, int y, int w, int h, int[ ] iArray, DataBuffer data);
public void setSample(int x, int y, int b, int s, DataBuffer data);
public void setSamples(int x, int y, int w, int h, int b, int[ ] iArray, DataBuffer data);
// Protected Instance Fields
protected int[ ] bandOffsets;
protected int[ ] bankIndices;
protected int numBands;
protected int numBanks;
protected int pixelStride;
protected int scanlineStride;
}
Hierar chy: Object→SampleModel→ComponentSampleModel
Subc lasses: BandedSampleModel, PixelInterleavedSampleModel
ConvolveOp
Ja va 1.2
java.awt.image
This class is a BufferedImageOp and a RasterOp that perfor ms an arbitrary convolution on
an image. Convolution is a versatile image-processing operation that can be used, for
example, to blur or sharpen an image or perfor m edge detection on an image. The
convolution to be perfor med is speciﬁed by a matrix of ﬂoating-point numbers, in the
for m of a Ker nel object. Because convolution looks at the neighbors of each pixel in an
image, special care must be taken when operating on the pixels at the edges of the
image. By default, a ConvolveOp uses imaginary color components of all zeros when it
reaches the edges of an image. You can pass EDGE_NO_OP to the constructor to specify
that the edges of the image should simply be left unprocessed. Finally, you can pass a
RenderingHints object to the ConvolveOp() constructor. If this argument is not null, the Con-
volveOp may use its color and dithering hints.
To use a ConvolveOp, simply pass a source and optional destination image or raster to its
ﬁlter() method. Note that you cannot specify the same object as both source and desti-
nation. See BufferedImageOp for further details.
public class ConvolveOp implements BufferedImageOp, RasterOp {
// Public Constructors
public ConvolveOp(Kernel kernel);
public ConvolveOp(Kernel kernel, int edgeCondition, RenderingHints hints);
// Public Constants
=1
public static ﬁnal int EDGE_NO_OP;
=0
public static ﬁnal int EDGE_ZERO_FILL;
// Public Instance Methods
public int getEdgeCondition();
public ﬁnal Kernel getKer nel();
// Methods Implementing BufferedImageOp
public BufferedImage createCompatibleDestImage(BufferedImage src, ColorModel destCM);
public ﬁnal BufferedImage ﬁlter(BufferedImage src, BufferedImage dst);
public ﬁnal java.awt.geom.Rectangle2D getBounds2D(BufferedImage src);
public ﬁnal java.awt.geom.Point2D getPoint2D(java.awt.geom.Point2D srcPt, java.awt.geom.Point2D dstPt);
java.awt.image.ComponentSampleModel
344 Chapter 18 – The java.awt.image Package

public ﬁnal RenderingHints getRenderingHints();
// Methods Implementing RasterOp
public WritableRaster createCompatibleDestRaster(Raster src);
public ﬁnal WritableRaster ﬁlter(Raster src, WritableRaster dst);
public ﬁnal java.awt.geom.Rectangle2D getBounds2D(Raster src);
}
Hierar chy: Object→ConvolveOp(BufferedImageOp, RasterOp)
CropImageF ilter
Ja va 1.0
java.awt.image
cloneable PJ1.1
This class implements an ImageF ilter that crops an image to a speciﬁed rectangle. The
methods deﬁned by this class are used for communication between the ﬁlter and its Fil-
teredImageSource and should never be called directly.
public class CropImageF ilter extends ImageFilter {
// Public Constructors
public CropImageF ilter(int x, int y, int w, int h);
// Public Methods Overriding ImageF ilter
public void setDimensions(int w, int h);
public void setPixels(int x, int y, int w, int h, ColorModel model, int[ ] pixels, int off, int scansize);
public void setPixels(int x, int y, int w, int h, ColorModel model, byte[ ] pixels, int off, int scansize);
public void setProper ties(java.util.Hashtable props);
}
Hierar chy: Object→ImageF ilter(Cloneable, ImageConsumer)→CropImageF ilter
DataBuffer
Ja va 1.2
java.awt.image
This abstract class stores image data at the lowest level. A DataBuffer stor es one or more
arrays, or banks, of data of a speciﬁed size and a given type. The Raster class uses a
DataBuffer to store image data and a SampleModel to interpret the storage format of that
data. Most applications never need to use DataBuffer objects directly.
Speciﬁc concrete subclasses of DataBuffer ar e implemented for speciﬁc types of data. See
also DataBufferByte, DataBufferShor t, DataBufferUShor t, and DataBufferInt.
public abstract class DataBuffer {
// Protected Constructors
protected DataBuffer(int dataType, int size);
protected DataBuffer(int dataType, int size, int numBanks);
protected DataBuffer(int dataType, int size, int numBanks, int[ ] offsets);
protected DataBuffer(int dataType, int size, int numBanks, int offset);
// Public Constants
=0
public static ﬁnal int TYPE_BYTE;
=5
public static ﬁnal int TYPE_DOUBLE;
=4
public static ﬁnal int TYPE_FLOAT;
=3
public static ﬁnal int TYPE_INT;
=2
public static ﬁnal int TYPE_SHORT;
=32
public static ﬁnal int TYPE_UNDEFINED;
=1
public static ﬁnal int TYPE_USHORT;
// Public Class Methods
public static int getDataTypeSize(int type);
// Property Accessor Methods (by property name)
public int getDataType();
public int getNumBanks();
java.awt.
image
java.awt.image.DataBuffer
Chapter 18 – The java.awt.image Package
345

public int getOffset();
public int[ ] getOffsets();
public int getSize();
// Public Instance Methods
public int getElem(int i);
public abstract int getElem(int bank, int i);
public double getElemDouble(int i);
public double getElemDouble(int bank, int i);
public ﬂoat getElemFloat(int i);
public ﬂoat getElemFloat(int bank, int i);
public void setElem(int i, int val);
public abstract void setElem(int bank, int i, int val);
public void setElemDouble(int i, double val);
public void setElemDouble(int bank, int i, double val);
public void setElemFloat(int i, ﬂoat val);
public void setElemFloat(int bank, int i, ﬂoat val);
// Protected Instance Fields
protected int banks;
protected int dataType;
protected int offset;
protected int[ ] offsets;
protected int size;
}
Subc lasses: DataBufferByte, DataBufferInt, DataBufferShort, DataBufferUShort
Passed To: Too many methods to list.
Retur ned By: BandedSampleModel.createDataBuffer(), ComponentSampleModel.createDataBuffer(),
MultiPixelPackedSampleModel.createDataBuffer(), Raster.getDataBuffer(), SampleModel.createDataBuffer(),
SinglePixelPackedSampleModel.createDataBuffer()
Type Of: Raster.dataBuffer
DataBufferByte
Ja va 1.2
java.awt.image
This class stores image data in one or more byte arrays. The arrays, or banks, of data
can be passed directly to the DataBufferByte() constructor, or they can be created by the
constructor. You may specify an offset into each array at which the data begins.
getElem() and setElem() allow you to get and set the values of a particular element of a
particular bank. Most applications never use this class directly.
public ﬁnal class DataBufferByte extends DataBuffer {
// Public Constructors
public DataBufferByte(int size);
public DataBufferByte(byte[ ][ ] dataArray, int size);
public DataBufferByte(byte[ ] dataArray, int size);
public DataBufferByte(int size, int numBanks);
public DataBufferByte(byte[ ][ ] dataArray, int size, int[ ] offsets);
public DataBufferByte(byte[ ] dataArray, int size, int offset);
// Public Instance Methods
public byte[ ][ ] getBankData();
public byte[ ] getData();
public byte[ ] getData(int bank);
// Public Methods Overriding DataBuffer
public int getElem(int i);
public int getElem(int bank, int i);
public void setElem(int i, int val);
java.awt.image.DataBuffer
346 Chapter 18 – The java.awt.image Package

public void setElem(int bank, int i, int val);
}
Hierar chy: Object→DataBuffer→DataBufferByte
DataBufferInt
Ja va 1.2
java.awt.image
This class stores image data in one or more int arrays. The arrays, or banks, of data can
be passed directly to the DataBufferInt() constructor, or they can be created by the con-
structor. You may specify an offset into each array at which the data begins. getElem()
and setElem() allow you to get and set the values of a particular element of a particular
bank. Most applications never use this class directly.
public ﬁnal class DataBufferInt extends DataBuffer {
// Public Constructors
public DataBufferInt(int size);
public DataBufferInt(int[ ][ ] dataArray, int size);
public DataBufferInt(int[ ] dataArray, int size);
public DataBufferInt(int size, int numBanks);
public DataBufferInt(int[ ][ ] dataArray, int size, int[ ] offsets);
public DataBufferInt(int[ ] dataArray, int size, int offset);
// Public Instance Methods
public int[ ][ ] getBankData();
public int[ ] getData();
public int[ ] getData(int bank);
// Public Methods Overriding DataBuffer
public int getElem(int i);
public int getElem(int bank, int i);
public void setElem(int i, int val);
public void setElem(int bank, int i, int val);
}
Hierar chy: Object→DataBuffer→DataBufferInt
DataBufferShor t
Ja va 1.2
java.awt.image
This class stores image data in one or more shor t arrays. The arrays, or banks, of data
can be passed directly to the DataBufferShor t() constructor, or they can be created by the
constructor. You may specify an offset into each array at which the data begins.
getElem() and setElem() allow you to get and set the values of a particular element of a
particular bank. Most applications never use this class directly.
public ﬁnal class DataBufferShor t extends DataBuffer {
// Public Constructors
public DataBufferShor t(int size);
public DataBufferShor t(shor t[ ][ ] dataArray, int size);
public DataBufferShor t(shor t[ ] dataArray, int size);
public DataBufferShor t(int size, int numBanks);
public DataBufferShor t(shor t[ ][ ] dataArray, int size, int[ ] offsets);
public DataBufferShor t(shor t[ ] dataArray, int size, int offset);
// Public Instance Methods
public short[ ][ ] getBankData();
public short[ ] getData();
public short[ ] getData(int bank);
// Public Methods Overriding DataBuffer
public int getElem(int i);
java.awt.
image
java.awt.image.DataBufferShor t
Chapter 18 – The java.awt.image Package
347

public int getElem(int bank, int i);
public void setElem(int i, int val);
public void setElem(int bank, int i, int val);
}
Hierar chy: Object→DataBuffer→DataBufferShor t
DataBufferUShor t
Ja va 1.2
java.awt.image
This class stores unsigned image data in one or more shor t arrays. The arrays, or banks,
of data can be passed directly to the DataBufferUShor t() constructor, or they can be cre-
ated by the constructor. You may specify an offset into each array at which the data
begins. getElem() and setElem() allow you to get and set the values of a particular ele-
ment of a particular bank. Most applications never use this class directly.
public ﬁnal class DataBufferUShor t extends DataBuffer {
// Public Constructors
public DataBufferUShor t(int size);
public DataBufferUShor t(shor t[ ][ ] dataArray, int size);
public DataBufferUShor t(shor t[ ] dataArray, int size);
public DataBufferUShor t(int size, int numBanks);
public DataBufferUShor t(shor t[ ][ ] dataArray, int size, int[ ] offsets);
public DataBufferUShor t(shor t[ ] dataArray, int size, int offset);
// Public Instance Methods
public short[ ][ ] getBankData();
public short[ ] getData();
public short[ ] getData(int bank);
// Public Methods Overriding DataBuffer
public int getElem(int i);
public int getElem(int bank, int i);
public void setElem(int i, int val);
public void setElem(int bank, int i, int val);
}
Hierar chy: Object→DataBuffer→DataBufferUShor t
DirectColorModel
Ja va 1.0
java.awt.image
PJ1.1
This ColorModel works only with RGB color spaces. It extracts red, green, blue, and,
optionally, alpha values directly from the bits of the pixel, using bitmasks to specify
which bits correspond to which color components. The default RGB color model is a
DirectColorModel. Only applications that are doing custom image processing need to use
this, or any, ColorModel.
Prior to Java 1.2, this class extended ColorModel dir ectly. In Java 1.2, it extends PackedCol-
orModel, which itself extends ColorModel. The Java 1.2 methods of this class that accept
pixel values as an array of a primitive transfer type expect that array argument to have
a length of 1.
public class DirectColorModel extends PackedColorModel {
// Public Constructors
public DirectColorModel(int bits, int rmask, int gmask, int bmask);
public DirectColorModel(int bits, int rmask, int gmask, int bmask, int amask);
1.2 public DirectColorModel(java.awt.color.ColorSpace space, int bits, int rmask, int gmask, int bmask, int amask,
boolean isAlphaPremultiplied, int transferType);
java.awt.image.DataBufferShor t
348 Chapter 18 – The java.awt.image Package

// Property Accessor Methods (by property name)
public ﬁnal int getAlphaMask();
public ﬁnal int getBlueMask();
public ﬁnal int getGreenMask();
public ﬁnal int getRedMask();
// Public Methods Overriding ColorModel
1.2 public ﬁnal ColorModel coerceData(WritableRaster raster, boolean isAlphaPremultiplied);
1.2 public ﬁnal WritableRaster createCompatibleWritableRaster(int w, int h);
1.2 public int getAlpha(Object inData);
public ﬁnal int getAlpha(int pixel);
1.2 public int getBlue(Object inData);
public ﬁnal int getBlue(int pixel);
1.2 public ﬁnal int[ ] getComponents(Object pixel, int[ ] components, int offset);
1.2 public ﬁnal int[ ] getComponents(int pixel, int[ ] components, int offset);
1.2 public int getDataElement(int[ ] components, int offset);
1.2 public Object getDataElements(int rgb, Object pixel);
1.2 public Object getDataElements(int[ ] components, int offset, Object obj);
1.2 public int getGreen(Object inData);
public ﬁnal int getGreen(int pixel);
1.2 public int getRed(Object inData);
public ﬁnal int getRed(int pixel);
public ﬁnal int getRGB(int pixel);
1.2 public int getRGB(Object inData);
1.2 public boolean isCompatibleRaster(Raster raster);
1.2 public String toString();
}
Hierar chy: Object→ColorModel(Transparency)→PackedColorModel→DirectColorModel
FilteredImageSource
Ja va 1.0
java.awt.image
PJ1.1
This class is an ImageProducer that produces image data ﬁltered from some other Image-
Producer. A FilteredImageSource is created with a speciﬁed ImageProducer and a speciﬁed
ImageF ilter. For example, an applet might use the following code to download and crop
an image:
Image full_image = getImage(getDocumentBase(), "images/1.gif");
ImageF ilter cropper = new CropImageF ilter(10, 10, 100, 100);
ImageProducer prod = new FilteredImageSource(full_image.getSource(), cropper);
Image cropped_image = createImage(prod);
The methods of this class are the standard ImageProducer methods that you can invoke to
add and remove ImageConsumer objects.
public class FilteredImageSource implements ImageProducer {
// Public Constructors
public FilteredImageSource(ImageProducer orig, ImageF ilter imgf);
// Methods Implementing ImageProducer
synchronized
public void addConsumer(ImageConsumer ic);
synchronized
public boolean isConsumer(ImageConsumer ic);
synchronized
public void removeConsumer(ImageConsumer ic);
public void requestTopDownLeftRightResend(ImageConsumer ic);
public void star tProduction(ImageConsumer ic);
}
Hierar chy: Object→FilteredImageSource(ImageProducer)
java.awt.
image
java.awt.image.FilteredImageSour ce
Chapter 18 – The java.awt.image Package
349

ImageConsumer
Ja va 1.0
java.awt.image
PJ1.1
This interface deﬁnes the methods necessary for a class that consumes image data to
communicate with a class that produces image data. The methods deﬁned by this inter-
face should never be called by a program directly; instead, they are invoked by an
ImageProducer to pass the image data and other information about the image to the
ImageConsumer. The constants deﬁned by this interface are values passed to the setHints()
and imageComplete() methods. Unless you want to do low-level manipulation of image
data, you never need to use or implement an ImageConsumer.
public abstract interface ImageConsumer {
// Public Constants
=4
public static ﬁnal int COMPLETESCANLINES;
=4
public static ﬁnal int IMAGEABORTED;
=1
public static ﬁnal int IMAGEERROR;
=1
public static ﬁnal int RANDOMPIXELORDER;
=16
public static ﬁnal int SINGLEFRAME;
=2
public static ﬁnal int SINGLEFRAMEDONE;
=8
public static ﬁnal int SINGLEPASS;
=3
public static ﬁnal int STATICIMAGEDONE;
=2
public static ﬁnal int TOPDOWNLEFTRIGHT;
// Public Instance Methods
public abstract void imageComplete(int status);
public abstract void setColorModel(ColorModel model);
public abstract void setDimensions(int width, int height);
public abstract void setHints(int hintﬂags);
public abstract void setPixels(int x, int y, int w, int h, ColorModel model, int[ ] pixels, int off, int scansize);
public abstract void setPixels(int x, int y, int w, int h, ColorModel model, byte[ ] pixels, int off, int scansize);
public abstract void setProper ties(java.util.Hashtable props);
}
Implementations: ImageF ilter, PixelGrabber
Passed To: Too many methods to list.
Type Of: ImageF ilter.consumer
ImageF ilter
Ja va 1.0
java.awt.image
cloneable PJ1.1
This class is used in conjunction with a FilteredImageSource. It accepts image data
thr ough the ImageConsumer inter face and passes it on to an ImageConsumer speciﬁed by
the controlling FilteredImageSource. ImageF ilter is the superclass of all image ﬁlters; it per-
for ms no ﬁltering itself. You must subclass it to perfor m the desired ﬁltering. See also
CropImageF ilter and RGBImageF ilter. The ImageF ilter methods are the ImageConsumer methods
invoked by an ImageProducer. You should not call them directly. See FilteredImageSource
for an example of using an ImageF ilter.
public class ImageF ilter implements Cloneable, ImageConsumer {
// Public Constructors
public ImageF ilter();
// Public Instance Methods
public ImageFilter getF ilterInstance(ImageConsumer ic);
public void resendTopDownLeftRight(ImageProducer ip);
// Methods Implementing ImageConsumer
public void imageComplete(int status);
public void setColorModel(ColorModel model);
public void setDimensions(int width, int height);
java.awt.image.ImageConsumer
350 Chapter 18 – The java.awt.image Package

public void setHints(int hints);
public void setPixels(int x, int y, int w, int h, ColorModel model, int[ ] pixels, int off, int scansize);
public void setPixels(int x, int y, int w, int h, ColorModel model, byte[ ] pixels, int off, int scansize);
public void setProper ties(java.util.Hashtable props);
// Public Methods Overriding Object
public Object clone();
// Protected Instance Fields
protected ImageConsumer consumer;
}
Hierar chy: Object→ImageF ilter(Cloneable, ImageConsumer)
Subc lasses: BufferedImageF ilter, CropImageF ilter, ReplicateScaleF ilter, RGBImageF ilter
Passed To: FilteredImageSource.F ilteredImageSource()
Retur ned By: ImageF ilter.getF ilterInstance()
ImageObser ver
Ja va 1.0
java.awt.image
PJ1.1
This interface deﬁnes a method and associated constants used by classes that want to
receive information asynchronously about the status of an image. Many methods that
query information about an image take an ImageObser ver as an argument. If the speciﬁed
infor mation is not available when requested, it is passed to the ImageObser ver when it
becomes available. Component implements this interface, and components are the most
commonly used image observers.
public abstract interface ImageObser ver {
// Public Constants
=128
public static ﬁnal int ABORT;
=32
public static ﬁnal int ALLBITS;
=64
public static ﬁnal int ERROR;
=16
public static ﬁnal int FRAMEBITS;
=2
public static ﬁnal int HEIGHT;
=4
public static ﬁnal int PROPERTIES;
=8
public static ﬁnal int SOMEBITS;
=1
public static ﬁnal int WIDTH;
// Public Instance Methods
public abstract boolean imageUpdate(Image img, int infoﬂags, int x, int y, int width, int height);
}
Implementations: Component
Passed To: Too many methods to list.
Retur ned By: javax.swing .ImageIcon.getImageObser ver()
ImageProducer
Ja va 1.0
java.awt.image
PJ1.1
This interface deﬁnes the methods that any class that produces image data must deﬁne
to enable communication with ImageConsumer classes. An ImageConsumer registers itself as
inter ested in a producer’s image by calling the addConsumer() method. Most applications
never need to use or implement this interface.
public abstract interface ImageProducer {
// Public Instance Methods
public abstract void addConsumer(ImageConsumer ic);
public abstract boolean isConsumer(ImageConsumer ic);
java.awt.
image
java.awt.image.ImageProducer
Chapter 18 – The java.awt.image Package
351

public abstract void removeConsumer(ImageConsumer ic);
public abstract void requestTopDownLeftRightResend(ImageConsumer ic);
public abstract void star tProduction(ImageConsumer ic);
}
Implementations: FilteredImageSource, MemoryImageSource,
java.awt.image.renderable.RenderableImageProducer
Passed To: Component.createImage(), Toolkit.createImage(), FilteredImageSource.F ilteredImageSource(),
ImageF ilter.resendTopDownLeftRight(), PixelGrabber.PixelGrabber(),
java.awt.peer.ComponentPeer.createImage()
Retur ned By: Image.getSource(), BufferedImage.getSource()
ImagingOpException
Ja va 1.2
java.awt.image
serializable unchecked
Thr own by the ﬁlter() methods of BufferedImageOp and RasterOp if, for any reason, they
ar e unable to ﬁlter the speciﬁed image.
public class ImagingOpException extends RuntimeException {
// Public Constructors
public ImagingOpException(String s);
}
Hierar chy: Object→Throwable(Serializable)→Exception→RuntimeException→ImagingOpException
IndexColorModel
Ja va 1.0
java.awt.image
PJ1.1
This ColorModel is used with RGB color spaces and determines the red, green, blue, and,
optionally, alpha components of a pixel by using the pixel value as an index into col-
or map arrays. If no array of alpha values is speciﬁed, all pixels are fully opaque, except
for one optionally speciﬁed reserved value that is fully transparent. This color model is
useful when working with image data that is deﬁned in terms of a colormap. Only
applications that are doing custom image processing need to use this, or any, Color-
Model.
public class IndexColorModel extends ColorModel {
// Public Constructors
public IndexColorModel(int bits, int size, byte[ ] cmap, int star t, boolean hasalpha);
public IndexColorModel(int bits, int size, byte[ ] r, byte[ ] g, byte[ ] b);
public IndexColorModel(int bits, int size, byte[ ] cmap, int star t, boolean hasalpha, int trans);
public IndexColorModel(int bits, int size, byte[ ] r, byte[ ] g, byte[ ] b, byte[ ] a);
public IndexColorModel(int bits, int size, byte[ ] r, byte[ ] g, byte[ ] b, int trans);
1.2 public IndexColorModel(int bits, int size, int[ ] cmap, int star t, boolean hasalpha, int trans, int transferType);
// Public Instance Methods
1.2 public BufferedImage conver tToIntDiscrete(Raster raster, boolean forceARGB);
public ﬁnal void getAlphas(byte[ ] a);
public ﬁnal void getBlues(byte[ ] b);
public ﬁnal void getGreens(byte[ ] g);
public ﬁnal int getMapSize();
public ﬁnal void getReds(byte[ ] r);
1.2 public ﬁnal void getRGBs(int[ ] rgb);
public ﬁnal int getTransparentPixel();
// Public Methods Overriding ColorModel
1.2 public SampleModel createCompatibleSampleModel(int w, int h);
1.2 public WritableRaster createCompatibleWritableRaster(int w, int h);
1.2 public void ﬁnalize();
java.awt.image.ImageProducer
352 Chapter 18 – The java.awt.image Package

public ﬁnal int getAlpha(int pixel);
public ﬁnal int getBlue(int pixel);
1.2 public int[ ] getComponents(Object pixel, int[ ] components, int offset);
1.2 public int[ ] getComponents(int pixel, int[ ] components, int offset);
1.2 public int[ ] getComponentSize();
1.2 public int getDataElement(int[ ] components, int offset);
1.2 public Object getDataElements(int rgb, Object pixel);
1.2 public Object getDataElements(int[ ] components, int offset, Object pixel);
public ﬁnal int getGreen(int pixel);
public ﬁnal int getRed(int pixel);
public ﬁnal int getRGB(int pixel);
1.2 public int getTransparency();
1.2 public boolean isCompatibleRaster(Raster raster);
1.2 public boolean isCompatibleSampleModel(SampleModel sm);
1.2 public String toString();
}
Hierar chy: Object→ColorModel(Transparency)→IndexColorModel
Passed To: BufferedImage.BufferedImage(), RGBImageF ilter.filterIndexColorModel()
Retur ned By: RGBImageF ilter.filterIndexColorModel()
Kernel
Ja va 1.2
java.awt.image
cloneable
This class repr esents a matrix of ﬂoat values, for use with the ConvolveOp image-pr ocess-
ing operation. Convolution is perfor med by combining a pixel value with the values of
the pixels that surround it. The convolution kernel speciﬁes the relative contribution of
each pixel to the end result. For example, to blur an image, you can use a kernel like
this:




0. 111
0. 111
0. 111
0. 111
0. 111
0. 111
0. 111
0. 111
0. 111




This matrix speciﬁes that the destination pixel is composed of one-ninth (0.111) of the
source pixel plus one-ninth of each of the eight pixels that surround it.
To create a Ker nel, pass the width and height of the kernel to the constructor, along
with the array of ﬂoat values that comprise the kernel. The array should be organized
by rows. Note that a Ker nel need not have a square array. Kernels typically have an odd
number of rows and columns and are placed symmetrically about the source pixel
being processed. However, if the number of rows or columns is even, the origin of the
Ker nel is such that the extra row or column is to the bottom or the right of the pixel
being processed.
public class Kernel implements Cloneable {
// Public Constructors
public Kernel(int width, int height, ﬂoat[ ] data);
// Property Accessor Methods (by property name)
public ﬁnal int getHeight();
public ﬁnal int getW idth();
public ﬁnal int getXOrigin();
public ﬁnal int getYOrigin();
// Public Instance Methods
public ﬁnal ﬂoat[ ] getKer nelData(ﬂoat[ ] data);
java.awt.
image
java.awt.image.Ker nel
Chapter 18 – The java.awt.image Package
353

// Public Methods Overriding Object
public Object clone();
}
Hierar chy: Object→Ker nel(Cloneable)
Passed To: ConvolveOp.ConvolveOp()
Retur ned By: ConvolveOp.getKer nel()
LookupOp
Ja va 1.2
java.awt.image
This class is a BufferedImageOp and RasterOp that processes an image by one or more
lookup tables to convert the value of each component of each pixel to a new value.
LookupOp is useful for operations such as brightening or darkening an image, reducing
the number of colors in an image, or thresholding an image. When you create a
LookupOp object, you specify the lookup table or tables with a LookupTable object, typi-
cally a ByteLookupTable or Shor tLookupTable. If the LookupTable contains one table, that table
is used for all color bands of the image (but not alpha bands). Otherwise, the LookupT-
able should contain one table for each color band or one table for each of the color and
transpar ency bands. If you specify a RenderingHints object when you create a LookupOp,
the operation may use the color rendering and dithering hints it contains.
To use a LookupOp, simply pass a source and optional destination image or raster to the
ﬁlter() method. Because LookupOp pr ocesses pixels independently of each other, you can
use the same objects as both source and destination. Because of the nature of lookup
tables, however, you cannot use LookupOp with images that use an IndexColorModel. If the
lookup tables used by a LookupOp describe a simple linear function, you can also use a
RescaleOp to achieve the same effect. See BufferedImageOp for further details.
public class LookupOp implements BufferedImageOp, RasterOp {
// Public Constructors
public LookupOp(LookupTable lookup, RenderingHints hints);
// Public Instance Methods
public ﬁnal LookupTable getTable();
// Methods Implementing BufferedImageOp
public BufferedImage createCompatibleDestImage(BufferedImage src, ColorModel destCM);
public ﬁnal BufferedImage ﬁlter(BufferedImage src, BufferedImage dst);
public ﬁnal java.awt.geom.Rectangle2D getBounds2D(BufferedImage src);
public ﬁnal java.awt.geom.Point2D getPoint2D(java.awt.geom.Point2D srcPt, java.awt.geom.Point2D dstPt);
public ﬁnal RenderingHints getRenderingHints();
// Methods Implementing RasterOp
public WritableRaster createCompatibleDestRaster(Raster src);
public ﬁnal WritableRaster ﬁlter(Raster src, WritableRaster dst);
public ﬁnal java.awt.geom.Rectangle2D getBounds2D(Raster src);
}
Hierar chy: Object→LookupOp(BufferedImageOp, RasterOp)
LookupTable
Ja va 1.2
java.awt.image
This abstract class deﬁnes one or more lookup tables used by the LookupOp image-pr o-
cessing operation. lookupPixel() per forms the table-lookup operation. This method is
passed an array of color component source values. It transforms this array into a new
array of destination values by replacing each source value with the value found in the
appr opriate lookup table at the index that corresponds to the source value. Note, how-
ever, that an offset may be speciﬁed for the lookup tables. If so, the offset is subtracted
java.awt.image.Ker nel
354 Chapter 18 – The java.awt.image Package

fr om the source values before the lookup is perfor med. See the concrete subclasses
ByteLookupTable and Shor tLookupTable.
public abstract class LookupTable {
// Protected Constructors
protected LookupTable(int offset, int numComponents);
// Public Instance Methods
public int getNumComponents();
public int getOffset();
public abstract int[ ] lookupPixel(int[ ] src, int[ ] dest);
}
Subc lasses: ByteLookupTable, ShortLookupTable
Passed To: LookupOp.LookupOp()
Retur ned By: LookupOp.getTable()
Memor yImageSource
Ja va 1.0
java.awt.image
PJ1.1
This class is an ImageProducer that produces an image from data stored in memory. The
various constructors specify image data, color model, array offset, scanline length, and
pr operties in slightly differ ent ways. The instance methods implement the standard
ImageProducer inter face that allows an ImageConsumer object to register interest in the
image.
public class Memor yImageSource implements ImageProducer {
// Public Constructors
public Memor yImageSource(int w, int h, int[ ] pix, int off, int scan);
public Memor yImageSource(int w, int h, ColorModel cm, int[ ] pix, int off, int scan);
public Memor yImageSource(int w, int h, ColorModel cm, byte[ ] pix, int off, int scan);
public Memor yImageSource(int w, int h, int[ ] pix, int off, int scan, java.util.Hashtable props);
public Memor yImageSource(int w, int h, ColorModel cm, byte[ ] pix, int off, int scan, java.util.Hashtable props);
public Memor yImageSource(int w, int h, ColorModel cm, int[ ] pix, int off, int scan, java.util.Hashtable props);
// Public Instance Methods
1.1 public void newPixels();
synchronized
1.1 public void newPixels(byte[ ] newpix, ColorModel newmodel, int offset, int scansize);
synchronized
1.1 public void newPixels(int[ ] newpix, ColorModel newmodel, int offset, int scansize);
synchronized
1.1 public void newPixels(int x, int y, int w, int h);
synchronized
1.1 public void newPixels(int x, int y, int w, int h, boolean framenotify);
synchronized
1.1 public void setAnimated(boolean animated);
synchronized
1.1 public void setFullBufferUpdates(boolean fullbuffers);
// Methods Implementing ImageProducer
synchronized
public void addConsumer(ImageConsumer ic);
synchronized
public boolean isConsumer(ImageConsumer ic);
synchronized
public void removeConsumer(ImageConsumer ic);
empty
public void requestTopDownLeftRightResend(ImageConsumer ic);
public void star tProduction(ImageConsumer ic);
}
Hierar chy: Object→Memor yImageSource(ImageProducer)
MultiPixelPackedSampleModel
Ja va 1.2
java.awt.image
This SampleModel knows how to interpret single-banded image data in a DataBuffer that
is organized so that more than one pixel is packed into a single element of the data
buf fer.
For example, a
MultiPixelPackedSampleModel
can be used to repr esent
a
monochr ome image in which eight pixels are packed in a byte or 8-bit indexed color
java.awt.
image
java.awt.image.MultiPixelPackedSampleModel
Chapter 18 – The java.awt.image Package
355

data in which four pixels are packed into an int. Most applications never need to use
this class. See also SampleModel for further information.
public class MultiPixelPackedSampleModel extends SampleModel {
// Public Constructors
public MultiPixelPackedSampleModel(int dataType, int w, int h, int numberOfBits);
public MultiPixelPackedSampleModel(int dataType, int w, int h, int numberOfBits, int scanlineStride,
int dataBitOffset);
// Public Instance Methods
public int getBitOffset(int x);
public int getDataBitOffset();
public int getOffset(int x, int y);
public int getPixelBitStride();
public int getScanlineStride();
// Public Methods Overriding SampleModel
public SampleModel createCompatibleSampleModel(int w, int h);
public DataBuffer createDataBuffer();
constant
public int getNumDataElements();
public SampleModel createSubsetSampleModel(int[ ] bands);
public Object getDataElements(int x, int y, Object obj, DataBuffer data);
public int[ ] getPixel(int x, int y, int[ ] iArray, DataBuffer data);
public int getSample(int x, int y, int b, DataBuffer data);
public int[ ] getSampleSize();
public int getSampleSize(int band);
public int getTransferType();
public void setDataElements(int x, int y, Object obj, DataBuffer data);
public void setPixel(int x, int y, int[ ] iArray, DataBuffer data);
public void setSample(int x, int y, int b, int s, DataBuffer data);
}
Hierar chy: Object→SampleModel→MultiPixelPackedSampleModel
PackedColorModel
Ja va 1.2
java.awt.image
This abstract ColorModel is used with image data in which color component and trans-
par ency values are packed into contiguous bits of a byte, shor t, or int. It uses bitmasks
and bit-shifting operations to extract the color and transparency components from the
pixel value. DirectColorModel is a concrete subclass that works with RGB color spaces.
Only applications that are doing custom image processing need to use this, or any, Col-
orModel.
public abstract class PackedColorModel extends ColorModel {
// Public Constructors
public PackedColorModel(java.awt.color.ColorSpace space, int bits, int[ ] colorMaskArray, int alphaMask,
boolean isAlphaPremultiplied, int trans, int transferType);
public PackedColorModel(java.awt.color.ColorSpace space, int bits, int rmask, int gmask, int bmask, int amask,
boolean isAlphaPremultiplied, int trans, int transferType);
// Public Instance Methods
public ﬁnal int getMask(int index);
public ﬁnal int[ ] getMasks();
// Public Methods Overriding ColorModel
public SampleModel createCompatibleSampleModel(int w, int h);
public boolean equals(Object obj);
public WritableRaster getAlphaRaster(WritableRaster raster);
public boolean isCompatibleSampleModel(SampleModel sm);
}
java.awt.image.MultiPixelPackedSampleModel
356 Chapter 18 – The java.awt.image Package

Hierar chy: Object→ColorModel(Transparency)→PackedColorModel
Subc lasses: DirectColorModel
PixelGrabber
Ja va 1.0
java.awt.image
PJ1.1
This class is an ImageConsumer that extracts a speciﬁed rectangular array of pixels (in the
default RGB color model) from a speciﬁed Image or ImageProducer and stores them in a
speciﬁed array (using the speciﬁed offset into the array and speciﬁed scanline size).
Use this class when you want to inspect or manipulate the data of an image or some
rectangular portion of an image.
The method grabPixels() makes the PixelGrabber start grabbing pixels. status() retur ns the
status of the pixel-grabbing process. The retur n value uses the same ﬂag value con-
stants that the ImageObser ver class does. The remaining methods are the standard Image-
Consumer methods and should not be called directly.
public class PixelGrabber implements ImageConsumer {
// Public Constructors
1.1 public PixelGrabber(Image img, int x, int y, int w, int h, boolean forceRGB);
public PixelGrabber(ImageProducer ip, int x, int y, int w, int h, int[ ] pix, int off, int scansize);
public PixelGrabber(Image img, int x, int y, int w, int h, int[ ] pix, int off, int scansize);
// Property Accessor Methods (by property name)
synchronized
1.1 public ColorModel getColorModel();
Implements:ImageConsumer empty
public void setColorModel(ColorModel model);
synchronized
1.1 public int getHeight();
synchronized
1.1 public Object getPixels();
synchronized
1.1 public int getStatus();
synchronized
1.1 public int getW idth();
// Public Instance Methods
synchronized
1.1 public void abor tGrabbing();
public boolean grabPixels() throws InterruptedException;
synchronized
public boolean grabPixels(long ms) throws InterruptedException;
synchronized
1.1 public void star tGrabbing();
synchronized
public int status();
// Methods Implementing ImageConsumer
synchronized
public void imageComplete(int status);
empty
public void setColorModel(ColorModel model);
public void setDimensions(int width, int height);
empty
public void setHints(int hints);
public void setPixels(int srcX, int srcY, int srcW, int srcH, ColorModel model, int[ ] pixels, int srcOff, int srcScan);
public void setPixels(int srcX, int srcY, int srcW, int srcH, ColorModel model, byte[ ] pixels, int srcOff, int srcScan);
empty
public void setProper ties(java.util.Hashtable props);
}
Hierar chy: Object→PixelGrabber(ImageConsumer)
PixelInter leavedSampleModel
Ja va 1.2
java.awt.image
This SampleModel repr esents image data stored so that each component of each pixel is
stor ed in a separate element of the DataBuffer and all pixel components are stor ed in the
same bank of the DataBuffer. For example, it can be used to repr esent RGB pixels in
which the red, green, and blue components are interleaved into a single bank of byte
values. Most applications never need to use this class or its subclasses. See SampleModel
for further information.
java.awt.
image
java.awt.image.PixelInterleavedSampleModel
Chapter 18 – The java.awt.image Package
357

public class PixelInter leavedSampleModel extends ComponentSampleModel {
// Public Constructors
public PixelInter leavedSampleModel(int dataType, int w, int h, int pixelStride, int scanlineStride,
int[ ] bandOffsets);
// Public Methods Overriding ComponentSampleModel
public SampleModel createCompatibleSampleModel(int w, int h);
public SampleModel createSubsetSampleModel(int[ ] bands);
}
Hierar chy: Object→SampleModel→ComponentSampleModel→PixelInter leavedSampleModel
Raster
Ja va 1.2
java.awt.image
This class repr esents a rectangular array of pixels. A Raster is composed of a DataBuffer
that contains raw pixel data and a matching SampleModel that knows how to extract
pixel data from that DataBuffer. A Raster object is used within a BufferedImage object,
which also contains a ColorModel object to interpret the pixel values of the Raster as col-
ors. Most applications can simply used BufferedImage objects and never have to work
with Raster objects directly.
Raster does not have any public constructors. You can call the static method creat-
eRaster() or createWritableRaster() to create a Raster using arbitrary DataBuffer and Sample-
Model
objects. However,
you usually obtain more
efﬁcient results if you use
createBandedRaster(), createInter leavedRaster(), or createPackedRaster() to create a Raster using
one of the data formats supported by the built-in DataBuffer and SampleModel subclasses.
Raster contains a number of methods to read individual pixels and blocks of pixels.
Note, however, that there are no methods to set pixel values. If you want to modify
pixels in a Raster, you must use the WritableRaster subclass. A Raster can have a parent
Raster that contains the actual data. The createChild() method uses this feature to retur n a
Raster object that repr esents a rectangular subset of the current raster. (It can also retur n
a child Raster that contains only a subset of the bands of the parent raster: for example,
a Raster that contains only the alpha band of transparency values of its parent.) Finally,
while BufferedImage objects have only a width and height, Raster objects have a size and
location. Thus, you can specify an origin when you create a Raster.
public class Raster {
// Protected Constructors
protected Raster(SampleModel sampleModel, Point origin);
protected Raster(SampleModel sampleModel, DataBuffer dataBuffer, Point origin);
protected Raster(SampleModel sampleModel, DataBuffer dataBuffer, Rectangle aRegion,
Point sampleModelTranslate, Raster parent);
// Public Class Methods
public static WritableRaster createBandedRaster(int dataType, int w, int h, int bands, Point location);
public static WritableRaster createBandedRaster(int dataType, int w, int h, int scanlineStride, int[ ] bankIndices,
int[ ] bandOffsets, Point location);
public static WritableRaster createBandedRaster(DataBuffer dataBuffer, int w, int h, int scanlineStride,
int[ ] bankIndices, int[ ] bandOffsets, Point location);
public static WritableRaster createInter leavedRaster(int dataType, int w, int h, int bands, Point location);
public static WritableRaster createInter leavedRaster(int dataType, int w, int h, int scanlineStride, int pixelStride,
int[ ] bandOffsets, Point location);
public static WritableRaster createInter leavedRaster(DataBuffer dataBuffer, int w, int h, int scanlineStride,
int pixelStride, int[ ] bandOffsets, Point location);
public static WritableRaster createPackedRaster(DataBuffer dataBuffer, int w, int h, int bitsPerPixel,
Point location);
public static WritableRaster createPackedRaster(int dataType, int w, int h, int[ ] bandMasks, Point location);
java.awt.image.PixelInterleavedSampleModel
358 Chapter 18 – The java.awt.image Package

public static WritableRaster createPackedRaster(DataBuffer dataBuffer, int w, int h, int scanlineStride,
int[ ] bandMasks, Point location);
public static WritableRaster createPackedRaster(int dataType, int w, int h, int bands, int bitsPerBand,
Point location);
public static Raster createRaster(SampleModel sm, DataBuffer db, Point location);
public static WritableRaster createWritableRaster(SampleModel sm, Point location);
public static WritableRaster createWritableRaster(SampleModel sm, DataBuffer db, Point location);
// Property Accessor Methods (by property name)
public Rectangle getBounds();
public DataBuffer getDataBuffer();
public ﬁnal int getHeight();
public ﬁnal int getMinX();
public ﬁnal int getMinY();
public ﬁnal int getNumBands();
public ﬁnal int getNumDataElements();
public Raster getParent();
public SampleModel getSampleModel();
public ﬁnal int getSampleModelTranslateX();
public ﬁnal int getSampleModelTranslateY();
public ﬁnal int getTransferType();
public ﬁnal int getW idth();
// Public Instance Methods
public Raster createChild(int parentX, int parentY, int width, int height, int childMinX, int childMinY,
int[ ] bandList);
public WritableRaster createCompatibleWritableRaster();
public WritableRaster createCompatibleWritableRaster(Rectangle rect);
public WritableRaster createCompatibleWritableRaster(int w, int h);
public WritableRaster createCompatibleWritableRaster(int x, int y, int w, int h);
public Raster createTranslatedChild(int childMinX, int childMinY);
public Object getDataElements(int x, int y, Object outData);
public Object getDataElements(int x, int y, int w, int h, Object outData);
public int[ ] getPixel(int x, int y, int[ ] iArray);
public ﬂoat[ ] getPixel(int x, int y, ﬂoat[ ] fArray);
public double[ ] getPixel(int x, int y, double[ ] dArray);
public int[ ] getPixels(int x, int y, int w, int h, int[ ] iArray);
public ﬂoat[ ] getPixels(int x, int y, int w, int h, ﬂoat[ ] fArray);
public double[ ] getPixels(int x, int y, int w, int h, double[ ] dArray);
public int getSample(int x, int y, int b);
public double getSampleDouble(int x, int y, int b);
public ﬂoat getSampleFloat(int x, int y, int b);
public int[ ] getSamples(int x, int y, int w, int h, int b, int[ ] iArray);
public ﬂoat[ ] getSamples(int x, int y, int w, int h, int b, ﬂoat[ ] fArray);
public double[ ] getSamples(int x, int y, int w, int h, int b, double[ ] dArray);
// Protected Instance Fields
protected DataBuffer dataBuffer;
protected int height;
protected int minX;
protected int minY;
protected int numBands;
protected int numDataElements;
protected Raster parent;
protected SampleModel sampleModel;
protected int sampleModelTranslateX;
protected int sampleModelTranslateY;
protected int width;
}
Subc lasses: WritableRaster
java.awt.
image
java.awt.image.Raster
Chapter 18 – The java.awt.image Package
359

Passed To: Too many methods to list.
Retur ned By: PaintContext.getRaster(), BufferedImage.{getData(), getT ile()}, Raster.{createChild(),
createRaster(), createTranslatedChild(), getParent()}, RenderedImage.{getData(), getT ile()}
Type Of: Raster.parent
RasterFor matException
Ja va 1.2
java.awt.image
serializable unchecked
Signals that a Raster is improperly conﬁgured.
public class RasterFor matException extends RuntimeException {
// Public Constructors
public RasterFor matException(String s);
}
Hierar chy: Object→Throwable(Serializable)→Exception→RuntimeException→RasterFor matException
RasterOp
Ja va 1.2
java.awt.image
This interface deﬁnes an image-processing operation that can be perfor med on a Raster.
It is very similar to the BufferedImageOp, except that the operation is perfor med dir ectly
on the uninterpreted pixels of Raster data, rather than on the color values of a Buffered-
Image. Many of the implementations of BufferedImageOp ar e also implementations of Ras-
terOp. See BufferedImageOp for details.
public abstract interface RasterOp {
// Public Instance Methods
public abstract WritableRaster createCompatibleDestRaster(Raster src);
public abstract WritableRaster ﬁlter(Raster src, WritableRaster dest);
public abstract java.awt.geom.Rectangle2D getBounds2D(Raster src);
public abstract java.awt.geom.Point2D getPoint2D(java.awt.geom.Point2D srcPt, java.awt.geom.Point2D dstPt);
public abstract RenderingHints getRenderingHints();
}
Implementations: AffineTransfor mOp, BandCombineOp, ColorConvertOp, ConvolveOp, LookupOp,
RescaleOp
RenderedImage
Ja va 1.2
java.awt.image
This interface describes the methods of render ed images. RenderedImage exists primarily
for use by the forthcoming Java Advanced Imaging API (javax.jai.*), but it is also imple-
mented (through WritableRenderedImage) by BufferedImage, meaning that BufferedImage
images will be able to interoperate with JAI-render ed images.
The getSources() method and the tile-related methods of RenderedImage ar e used in the
JAI, and are not of interest in Java 2D. BufferedImage objects contain only a single tile, so
the BufferedImage class deﬁnes implementations of these methods. Methods that are of
inter est include getData(), getSampleModel(), and getColorModel(). These methods retur n a
copy of the Raster that contains pixels, the SampleModel that speciﬁes the internal organi-
zation of the Raster, and the ColorModel that speciﬁes how to interpret the pixels as col-
ors, respectively. getW idth(), getHeight(), and copyData() ar e also useful in Java 2D
pr ograms.
java.awt.image.Raster
360 Chapter 18 – The java.awt.image Package

public abstract interface RenderedImage {
// Property Accessor Methods (by property name)
public abstract ColorModel getColorModel();
public abstract Raster getData();
public abstract Raster getData(Rectangle rect);
public abstract int getHeight();
public abstract int getMinT ileX();
public abstract int getMinT ileY();
public abstract int getMinX();
public abstract int getMinY();
public abstract int getNumXT iles();
public abstract int getNumYT iles();
public abstract String[ ] getProper tyNames();
public abstract SampleModel getSampleModel();
public abstract java.util.Vector getSources();
public abstract int getT ileGridXOffset();
public abstract int getT ileGridYOffset();
public abstract int getT ileHeight();
public abstract int getT ileWidth();
public abstract int getW idth();
// Public Instance Methods
public abstract WritableRaster copyData(WritableRaster raster);
public abstract Object getProper ty(String name);
public abstract Raster getT ile(int tileX, int tileY);
}
Implementations: WritableRenderedImage
Passed To: Graphics2D.drawRenderedImage()
Retur ned By: java.awt.image.renderable.ContextualRenderedImageFactor y.create(),
java.awt.image.renderable.ParameterBlock.getRenderedSource(),
java.awt.image.renderable.RenderableImage.{createDefaultRendering(), createRendering(),
createScaledRendering()}, java.awt.image.renderable.RenderableImageOp.{createDefaultRendering(),
createRendering(), createScaledRendering()}, java.awt.image.renderable.RenderedImageFactor y.create()
ReplicateScaleF ilter
Ja va 1.1
java.awt.image
cloneable PJ1.1
This class implements an ImageF ilter that scales an image to a speciﬁed pixel size. It uses
a simple scaling algorithm in which rows and columns of image pixels are duplicated
or omitted as necessary to achieve the desired size. See AreaAveragingScaleF ilter for a scal-
ing ﬁlter that results in smoother images. The methods of this class are ImageConsumer
methods used for communication between the image ﬁlter and the FilteredImageSource
that uses it. Applications usually do not call these methods directly. The easiest way to
use this ﬁlter is to call the getScaledInstance() method of Image, specifying an appropriate
hint constant.
public class ReplicateScaleF ilter extends ImageFilter {
// Public Constructors
public ReplicateScaleF ilter(int width, int height);
// Public Methods Overriding ImageF ilter
public void setDimensions(int w, int h);
public void setPixels(int x, int y, int w, int h, ColorModel model, int[ ] pixels, int off, int scansize);
public void setPixels(int x, int y, int w, int h, ColorModel model, byte[ ] pixels, int off, int scansize);
public void setProper ties(java.util.Hashtable props);
// Protected Instance Fields
protected int destHeight;
java.awt.
image
java.awt.image.ReplicateScaleFilter
Chapter 18 – The java.awt.image Package
361

protected int destW idth;
protected Object outpixbuf;
protected int[ ] srccols;
protected int srcHeight;
protected int[ ] srcrows;
protected int srcW idth;
}
Hierar chy: Object→ImageF ilter(Cloneable, ImageConsumer)→ReplicateScaleF ilter
Subc lasses: AreaAveragingScaleF ilter
RescaleOp
Ja va 1.2
java.awt.image
This class is a BufferedImageOp and a RasterOp that perfor ms a linear scaling on the com-
ponents of each pixel in an image by multiplying them by a scale factor and adding a
constant. When you create a RescaleOp, you specify either a single scale factor and a
single offset or an array of scale factors and an array of constants. If only one scale fac-
tor and constant are speciﬁed, then all color bands of the image are rescaled identi-
cally. Otherwise, there should be one scale factor and constant for each color band or
for each color band plus the alpha transparency band. In this case, each color band,
and possibly the alpha band, is rescaled independently.
To use a RescaleOp, simply pass a source and optional destination image or raster to the
ﬁlter() method. Because RescaleOp pr ocesses pixels independently of each other, you can
use the same objects as both source and destination. Because of the nature of the
rescaling, however, you cannot use LookupOp with images that use an IndexColorModel.
RescaleOp per forms a linear rescaling. If you want to perfor m a nonlinear rescaling, you
can do so with a LookupOp and a LookupTable that describes the desired scaling. See
BufferedImageOp for further details.
public class RescaleOp implements BufferedImageOp, RasterOp {
// Public Constructors
public RescaleOp(ﬂoat scaleFactor, ﬂoat offset, RenderingHints hints);
public RescaleOp(ﬂoat[ ] scaleFactors, ﬂoat[ ] offsets, RenderingHints hints);
// Public Instance Methods
public ﬁnal int getNumFactors();
public ﬁnal ﬂoat[ ] getOffsets(ﬂoat[ ] offsets);
public ﬁnal ﬂoat[ ] getScaleFactors(ﬂoat[ ] scaleFactors);
// Methods Implementing BufferedImageOp
public BufferedImage createCompatibleDestImage(BufferedImage src, ColorModel destCM);
public ﬁnal BufferedImage ﬁlter(BufferedImage src, BufferedImage dst);
public ﬁnal java.awt.geom.Rectangle2D getBounds2D(BufferedImage src);
public ﬁnal java.awt.geom.Point2D getPoint2D(java.awt.geom.Point2D srcPt, java.awt.geom.Point2D dstPt);
public ﬁnal RenderingHints getRenderingHints();
// Methods Implementing RasterOp
public WritableRaster createCompatibleDestRaster(Raster src);
public ﬁnal WritableRaster ﬁlter(Raster src, WritableRaster dst);
public ﬁnal java.awt.geom.Rectangle2D getBounds2D(Raster src);
}
Hierar chy: Object→RescaleOp(BufferedImageOp, RasterOp)
RGBImageF ilter
Ja va 1.0
java.awt.image
cloneable PJ1.1
This abstract class is an ImageF ilter that provides an easy way to implement ﬁlters that
modify the colors of an image. To create a color ﬁlter that modiﬁes the colors of an
java.awt.image.ReplicateScaleFilter
362 Chapter 18 – The java.awt.image Package

image, you should subclass RGBImageF ilter and provide a deﬁnition of ﬁlterRGB() that con-
verts the input pixel value (in the default RGB color model) to an output value. If the
conversion does not depend on the location of the pixel, set the canF ilterIndexColorModel
variable to tr ue so that the RGBImageF ilter can save time by ﬁltering the colormap of an
image that uses an IndexColorModel, instead of ﬁltering each pixel of the image.
public abstract class RGBImageF ilter extends ImageFilter {
// Public Constructors
public RGBImageF ilter();
// Public Instance Methods
public IndexColorModel ﬁlterIndexColorModel(IndexColorModel icm);
public abstract int ﬁlterRGB(int x, int y, int rgb);
public void ﬁlterRGBPixels(int x, int y, int w, int h, int[ ] pixels, int off, int scansize);
public void substituteColorModel(ColorModel oldcm, ColorModel newcm);
// Public Methods Overriding ImageF ilter
public void setColorModel(ColorModel model);
public void setPixels(int x, int y, int w, int h, ColorModel model, int[ ] pixels, int off, int scansize);
public void setPixels(int x, int y, int w, int h, ColorModel model, byte[ ] pixels, int off, int scansize);
// Protected Instance Fields
protected boolean canF ilterIndexColorModel;
protected ColorModel newmodel;
protected ColorModel origmodel;
}
Hierar chy: Object→ImageF ilter(Cloneable, ImageConsumer)→RGBImageF ilter
Subc lasses: javax.swing .GrayF ilter
SampleModel
Ja va 1.2
java.awt.image
This abstract class deﬁnes methods for extracting the pixels of an image from an arbi-
trary DataBuffer, regardless of how those pixels are stor ed in the DataBuffer. Image data is
stor ed in a Raster object, which consists of a DataBuffer to hold the raw data and a Sam-
pleModel to interpret the storage format. Only appliations that read or write image data
dir ectly fr om ﬁles or other sources ever need to use this class. See also the concrete
subclasses ComponentSampleModel, SinglePixelPackedSampleModel, and MultiPixelPackedSample-
Model.
public abstract class SampleModel {
// Public Constructors
public SampleModel(int dataType, int w, int h, int numBands);
// Property Accessor Methods (by property name)
public ﬁnal int getDataType();
public ﬁnal int getHeight();
public ﬁnal int getNumBands();
public abstract int getNumDataElements();
public abstract int[ ] getSampleSize();
public abstract int getSampleSize(int band);
public int getTransferType();
public ﬁnal int getW idth();
// Public Instance Methods
public abstract SampleModel createCompatibleSampleModel(int w, int h);
public abstract DataBuffer createDataBuffer();
public abstract SampleModel createSubsetSampleModel(int[ ] bands);
public abstract Object getDataElements(int x, int y, Object obj, DataBuffer data);
public Object getDataElements(int x, int y, int w, int h, Object obj, DataBuffer data);
public int[ ] getPixel(int x, int y, int[ ] iArray, DataBuffer data);
public ﬂoat[ ] getPixel(int x, int y, ﬂoat[ ] fArray, DataBuffer data);
java.awt.
image
java.awt.image.SampleModel
Chapter 18 – The java.awt.image Package
363

public double[ ] getPixel(int x, int y, double[ ] dArray, DataBuffer data);
public int[ ] getPixels(int x, int y, int w, int h, int[ ] iArray, DataBuffer data);
public ﬂoat[ ] getPixels(int x, int y, int w, int h, ﬂoat[ ] fArray, DataBuffer data);
public double[ ] getPixels(int x, int y, int w, int h, double[ ] dArray, DataBuffer data);
public abstract int getSample(int x, int y, int b, DataBuffer data);
public double getSampleDouble(int x, int y, int b, DataBuffer data);
public ﬂoat getSampleFloat(int x, int y, int b, DataBuffer data);
public int[ ] getSamples(int x, int y, int w, int h, int b, int[ ] iArray, DataBuffer data);
public ﬂoat[ ] getSamples(int x, int y, int w, int h, int b, ﬂoat[ ] fArray, DataBuffer data);
public double[ ] getSamples(int x, int y, int w, int h, int b, double[ ] dArray, DataBuffer data);
public abstract void setDataElements(int x, int y, Object obj, DataBuffer data);
public void setDataElements(int x, int y, int w, int h, Object obj, DataBuffer data);
public void setPixel(int x, int y, int[ ] iArray, DataBuffer data);
public void setPixel(int x, int y, ﬂoat[ ] fArray, DataBuffer data);
public void setPixel(int x, int y, double[ ] dArray, DataBuffer data);
public void setPixels(int x, int y, int w, int h, int[ ] iArray, DataBuffer data);
public void setPixels(int x, int y, int w, int h, ﬂoat[ ] fArray, DataBuffer data);
public void setPixels(int x, int y, int w, int h, double[ ] dArray, DataBuffer data);
public abstract void setSample(int x, int y, int b, int s, DataBuffer data);
public void setSample(int x, int y, int b, ﬂoat s, DataBuffer data);
public void setSample(int x, int y, int b, double s, DataBuffer data);
public void setSamples(int x, int y, int w, int h, int b, int[ ] iArray, DataBuffer data);
public void setSamples(int x, int y, int w, int h, int b, ﬂoat[ ] fArray, DataBuffer data);
public void setSamples(int x, int y, int w, int h, int b, double[ ] dArray, DataBuffer data);
// Protected Instance Fields
protected int dataType;
protected int height;
protected int numBands;
protected int width;
}
Subc lasses: ComponentSampleModel, MultiPixelPackedSampleModel, SinglePixelPackedSampleModel
Passed To: ColorModel.isCompatibleSampleModel(), ComponentColorModel.isCompatibleSampleModel(),
IndexColorModel.isCompatibleSampleModel(), PackedColorModel.isCompatibleSampleModel(),
Raster.{createRaster(), createWritableRaster(), Raster()}, WritableRaster.WritableRaster()
Retur ned By: Too many methods to list.
Type Of: Raster.sampleModel
Shor tLookupTable
Ja va 1.2
java.awt.image
This concrete subclass of LookupTable contains one or more shor t arrays that serve as
lookup tables for a LookupOp image-pr ocessing operation. Applications never need to
use a Shor tLookupTable dir ectly; they need to create one only to pass to the LookupOp()
constructor. Create a Shor tLookupTable by passing the shor t array or arrays to the Shor t-
LookupTable() constructor, along with an offset that is subtracted from each source color
component before the lookup is perfor med. See also ByteLookupTable().
public class Shor tLookupTable extends LookupTable {
// Public Constructors
public Shor tLookupTable(int offset, shor t[ ][ ] data);
public Shor tLookupTable(int offset, shor t[ ] data);
// Public Instance Methods
public ﬁnal short[ ][ ] getTable();
public short[ ] lookupPixel(shor t[ ] src, shor t[ ] dst);
java.awt.image.SampleModel
364 Chapter 18 – The java.awt.image Package

// Public Methods Overriding LookupTable
public int[ ] lookupPixel(int[ ] src, int[ ] dst);
}
Hierar chy: Object→LookupTable→Shor tLookupTable
SinglePixelPackedSampleModel
Ja va 1.2
java.awt.image
This SampleModel knows how to interpret image data in a DataBuffer that is organized so
that each pixel is stored in a single data element and each data element contains
exactly one pixel. For example, it can be used to repr esent RGB and ARGB data
packed into a int element or 8-bit grayscale data stored in byte elements. The bitMasks
array passed to the constructor speciﬁes the bitmask used to extract each color compo-
nent from the data element. For example, to extract the red color component of an
RGB color from an int, you specify a bitmask of 0x00FF0000. Most applications never
need to use this class. See SampleModel for further information.
public class SinglePixelPackedSampleModel extends SampleModel {
// Public Constructors
public SinglePixelPackedSampleModel(int dataType, int w, int h, int[ ] bitMasks);
public SinglePixelPackedSampleModel(int dataType, int w, int h, int scanlineStride, int[ ] bitMasks);
// Public Instance Methods
public int[ ] getBitMasks();
public int[ ] getBitOffsets();
public int getOffset(int x, int y);
public int getScanlineStride();
// Public Methods Overriding SampleModel
public SampleModel createCompatibleSampleModel(int w, int h);
constant
public int getNumDataElements();
public DataBuffer createDataBuffer();
public SampleModel createSubsetSampleModel(int[ ] bands);
public Object getDataElements(int x, int y, Object obj, DataBuffer data);
public int[ ] getPixel(int x, int y, int[ ] iArray, DataBuffer data);
public int[ ] getPixels(int x, int y, int w, int h, int[ ] iArray, DataBuffer data);
public int getSample(int x, int y, int b, DataBuffer data);
public int[ ] getSamples(int x, int y, int w, int h, int b, int[ ] iArray, DataBuffer data);
public int[ ] getSampleSize();
public int getSampleSize(int band);
public void setDataElements(int x, int y, Object obj, DataBuffer data);
public void setPixel(int x, int y, int[ ] iArray, DataBuffer data);
public void setPixels(int x, int y, int w, int h, int[ ] iArray, DataBuffer data);
public void setSample(int x, int y, int b, int s, DataBuffer data);
public void setSamples(int x, int y, int w, int h, int b, int[ ] iArray, DataBuffer data);
}
Hierar chy: Object→SampleModel→SinglePixelPackedSampleModel
TileObser ver
Ja va 1.2
java.awt.image
This interface is implemented by objects that wish to be notiﬁed when a WritableRen-
deredImage is about to be written to. It is used as part of the Java Advanced Imaging API
(javax.jai.*) and is not of interest to Java 2D programs. In particular, note that while
BufferedImage objects allow TileObser ver objects to be register ed, they never send out noti-
ﬁcations to them. Only programs using the JAI will ever implement this interface. It is
used in the java.awt.image package simply for future compatibility with the JAI.
java.awt.
image
java.awt.image.TileObser ver
Chapter 18 – The java.awt.image Package
365

public abstract interface TileObser ver {
// Public Instance Methods
public abstract void tileUpdate(WritableRenderedImage source, int tileX, int tileY, boolean willBeWritable);
}
Passed To: BufferedImage.{addT ileObserver(), removeTileObser ver()},
WritableRenderedImage.{addT ileObserver(), removeTileObser ver()}
WritableRaster
Ja va 1.2
java.awt.image
This class extends Raster to add methods for setting pixel values in the Raster. It does
not have any public constructors. You create WritableRaster objects with the static meth-
ods deﬁned by the Raster class. WritableRaster is used by BufferedImage, and, in practice,
most rasters used in a program are WritableRaster objects. Most applications can use the
featur es of BufferedImage and never need to use WritableRaster or Raster dir ectly. See Raster
for more infor mation.
public class WritableRaster extends Raster {
// Protected Constructors
protected WritableRaster(SampleModel sampleModel, Point origin);
protected WritableRaster(SampleModel sampleModel, DataBuffer dataBuffer, Point origin);
protected WritableRaster(SampleModel sampleModel, DataBuffer dataBuffer, Rectangle aRegion,
Point sampleModelTranslate, WritableRaster parent);
// Public Instance Methods
public WritableRaster createWritableChild(int parentX, int parentY, int w, int h, int childMinX, int childMinY,
int[ ] bandList);
public WritableRaster createWritableTranslatedChild(int childMinX, int childMinY);
public WritableRaster getWritableParent();
public void setDataElements(int x, int y, Raster inRaster);
public void setDataElements(int x, int y, Object inData);
public void setDataElements(int x, int y, int w, int h, Object inData);
public void setPixel(int x, int y, ﬂoat[ ] fArray);
public void setPixel(int x, int y, int[ ] iArray);
public void setPixel(int x, int y, double[ ] dArray);
public void setPixels(int x, int y, int w, int h, double[ ] dArray);
public void setPixels(int x, int y, int w, int h, ﬂoat[ ] fArray);
public void setPixels(int x, int y, int w, int h, int[ ] iArray);
public void setRect(Raster srcRaster);
public void setRect(int dx, int dy, Raster srcRaster);
public void setSample(int x, int y, int b, double s);
public void setSample(int x, int y, int b, ﬂoat s);
public void setSample(int x, int y, int b, int s);
public void setSamples(int x, int y, int w, int h, int b, double[ ] dArray);
public void setSamples(int x, int y, int w, int h, int b, ﬂoat[ ] fArray);
public void setSamples(int x, int y, int w, int h, int b, int[ ] iArray);
}
Hierar chy: Object→Raster→WritableRaster
Passed To: Too many methods to list.
Retur ned By: Too many methods to list.
WritableRenderedImage
Ja va 1.2
java.awt.image
This interface deﬁnes methods that allow image data to be written into a RenderedImage
in a way that allows for notiﬁcation of updates. Most of the methods of this interface
java.awt.image.TileObser ver
366 Chapter 18 – The java.awt.image Package

exist for use with the forthcoming Java Advanced Imaging (JAI) API (javax.jai.*) and are
not of interest to programs using Java 2D. Nevertheless, BufferedImage implements this
inter face, so that Java 2D BufferedImage objects can interoperate with future JAI Rendered-
Image objects. BufferedImage objects contain only a single tile and provide trivial imple-
mentations of all the tile-related methods. setData() is the only method of interest to Java
2D programs.
public abstract interface WritableRenderedImage extends RenderedImage {
// Public Instance Methods
public abstract void addT ileObserver(T ileObserver to);
public abstract WritableRaster getWritableT ile(int tileX, int tileY);
public abstract Point[ ] getWritableT ileIndices();
public abstract boolean hasT ileWriters();
public abstract boolean isT ileWritable(int tileX, int tileY);
public abstract void releaseWritableT ile(int tileX, int tileY);
public abstract void removeT ileObserver(T ileObserver to);
public abstract void setData(Raster r);
}
Hierar chy: (WritableRenderedImage(RenderedImage))
Implementations: BufferedImage
Passed To: TileObser ver.tileUpdate()
java.awt.
image
java.awt.image.Wr itableRenderedImage
Chapter 18 – The java.awt.image Package
367

CHAPTER 19
The java.awt.image.renderable Package
The java.awt.image.renderable package contains classes and interfaces used by the
Java Advanced Imaging (JAI) standard extension (javax.jai.*). In general, these
classes and interfaces are not of interest to Java 2D programs, but the package is
part of the core Java platform so that the JAI can be tightly coupled to the core
image-pr ocessing featur es. Only image-processing applications that use the JAI
ever need to use the classes and interfaces in this package. Figure 19-1 shows the
class hierarchy of this package, which is new in Java 1.2.
extends
implements
INTERFACE
KEY
CLASS
RenderableImageOp
java.awt.image.renderable
java.lang
Object
ParameterBlock
RenderableImage
Runnable
Cloneable
java.io
java.awt.image
RenderableImageProducer
RenderContext
RenderedImageFactory
ContextualRenderedImageFactory
Serializable
ImageProducer
Figur e 19−1: The java.awt.image.r enderable package
368

ContextualRenderedImageFactor y
Ja va 1.2
java.awt.image.renderable
This interface is implemented by classes that, given a RenderContext and a ParameterBlock
of arguments, can produce a java.awt.image.RenderedImage. Implementations of this inter-
face are used to perfor m rendering-independent image ﬁltering by RenderableImageOp.
public abstract interface ContextualRenderedImageFactor y extends RenderedImageFactory {
// Public Instance Methods
public abstract RenderedImage create(RenderContext renderContext, ParameterBlock paramBlock);
public abstract java.awt.geom.Rectangle2D getBounds2D(ParameterBlock paramBlock);
public abstract Object getProper ty(ParameterBlock paramBlock, String name);
public abstract String[ ] getProper tyNames();
public abstract boolean isDynamic();
public abstract RenderContext mapRenderContext(int i, RenderContext renderContext,
ParameterBlock paramBlock, RenderableImage image);
}
Hierar chy: (ContextualRenderedImageFactor y(RenderedImageFactor y))
Passed To: RenderableImageOp.RenderableImageOp()
ParameterBlock
Ja va 1.2
java.awt.image.renderable
cloneable serializable
This utility class maintains a list of parameter objects and a list of source objects for use
by a RenderableImageOp. Various methods allow sources and parameters to added, set,
and queried.
public class ParameterBlock implements Cloneable, Serializable {
// Public Constructors
public ParameterBlock();
public ParameterBlock(java.util.Vector sources);
public ParameterBlock(java.util.Vector sources, java.util.Vector parameters);
// Property Accessor Methods (by property name)
default:0
public int getNumParameters();
default:0
public int getNumSources();
public Class[ ] getParamClasses();
public java.util.Vector getParameters();
public void setParameters(java.util.Vector parameters);
public java.util.Vector getSources();
public void setSources(java.util.Vector sources);
// Public Instance Methods
public ParameterBlock add(int i);
public ParameterBlock add(ﬂoat f);
public ParameterBlock add(long l);
public ParameterBlock add(shor t s);
public ParameterBlock add(Object obj);
public ParameterBlock add(double d);
public ParameterBlock add(byte b);
public ParameterBlock add(char c);
public ParameterBlock addSource(Object source);
public byte getByteParameter(int index);
public char getCharParameter(int index);
public double getDoubleParameter(int index);
public ﬂoat getFloatParameter(int index);
public int getIntParameter(int index);
public long getLongParameter(int index);
public Object getObjectParameter(int index);
public RenderableImage getRenderableSource(int index);
awt.image.
renderable
java.awt.image.renderable.ParameterBlock
Chapter 19 – The java.awt.image.renderable Package
369

public RenderedImage getRenderedSource(int index);
public short getShor tParameter(int index);
public Object getSource(int index);
public void removeParameters();
public void removeSources();
public ParameterBlock set(long l, int index);
public ParameterBlock set(int i, int index);
public ParameterBlock set(shor t s, int index);
public ParameterBlock set(Object obj, int index);
public ParameterBlock set(char c, int index);
public ParameterBlock set(byte b, int index);
public ParameterBlock set(ﬂoat f, int index);
public ParameterBlock set(double d, int index);
public ParameterBlock setSource(Object source, int index);
public Object shallowClone();
// Public Methods Overriding Object
public Object clone();
// Protected Instance Fields
protected java.util.Vector parameters;
protected java.util.Vector sources;
}
Hierar chy: Object→ParameterBlock(Cloneable, Serializable)
Passed To: ContextualRenderedImageFactor y.{create(), getBounds2D(), getProper ty(), mapRenderContext()},
RenderableImageOp.{RenderableImageOp(), setParameterBlock()}, RenderedImageFactor y.create()
Retur ned By: Too many methods to list.
RenderableImage
Ja va 1.2
java.awt.image.renderable
This interface repr esents a rendering-independent (and resolution-independent) image.
A RenderableImage may be passed to the drawRenderableImage() method of Graphics2D.
However, a working, concrete implementation RenderableImage requir es the forthcoming
Java Advanced Imaging API. Java 2D programs that are not using the JAI will never use
this interface.
public abstract interface RenderableImage {
// Public Constants
="HINTS_OBSERVED"
public static ﬁnal String HINTS_OBSERVED;
// Property Accessor Methods (by property name)
public abstract boolean isDynamic();
public abstract ﬂoat getHeight();
public abstract ﬂoat getMinX();
public abstract ﬂoat getMinY();
public abstract String[ ] getProper tyNames();
public abstract java.util.Vector getSources();
public abstract ﬂoat getW idth();
// Public Instance Methods
public abstract RenderedImage createDefaultRendering();
public abstract RenderedImage createRendering(RenderContext renderContext);
public abstract RenderedImage createScaledRendering(int w, int h, RenderingHints hints);
public abstract Object getProper ty(String name);
}
Implementations: RenderableImageOp
java.awt.image.renderable.ParameterBlock
370 Chapter 19 – The java.awt.image.renderable Package

Passed To: Graphics2D.drawRenderableImage(), ContextualRenderedImageFactor y.mapRenderContext(),
RenderableImageProducer.RenderableImageProducer()
Retur ned By: ParameterBlock.getRenderableSource()
RenderableImageOp
Ja va 1.2
java.awt.image.renderable
This class deﬁnes an image-processing operation on a RenderableImage and is itself a
RenderableImage, allowing processing operations to be pipelined, or streamed. Although
this is a concrete class, the image-processing operation itself is deﬁned in an external
ContextualRenderedImageFactor object.
public class RenderableImageOp implements RenderableImage {
// Public Constructors
public RenderableImageOp(ContextualRenderedImageFactory CRIF, ParameterBlock paramBlock);
// Public Instance Methods
public ParameterBlock getParameterBlock();
public ParameterBlock setParameterBlock(ParameterBlock paramBlock);
// Methods Implementing RenderableImage
public RenderedImage createDefaultRendering();
public RenderedImage createRendering(RenderContext renderContext);
public RenderedImage createScaledRendering(int w, int h, RenderingHints hints);
public ﬂoat getHeight();
public ﬂoat getMinX();
public ﬂoat getMinY();
public Object getProper ty(String name);
public String[ ] getProper tyNames();
public java.util.Vector getSources();
public ﬂoat getW idth();
public boolean isDynamic();
}
Hierar chy: Object→RenderableImageOp(RenderableImage)
RenderableImageProducer
Ja va 1.2
java.awt.image.renderable
runnable
This class is an adapter that allows RenderableImage objects of the Java Advanced Imag-
ing API to be used with the Java 1.0 ImageProducer/ImageConsumer image-pr ocessing
model. The JAI is a forthcoming standard extension. This class exists in a core AWT
package solely for future inter operability.
public class RenderableImageProducer implements ImageProducer, Runnable {
// Public Constructors
public RenderableImageProducer(RenderableImage rdblImage, RenderContext rc);
// Public Instance Methods
synchronized
public void setRenderContext(RenderContext rc);
// Methods Implementing ImageProducer
synchronized
public void addConsumer(ImageConsumer ic);
synchronized
public boolean isConsumer(ImageConsumer ic);
synchronized
public void removeConsumer(ImageConsumer ic);
empty
public void requestTopDownLeftRightResend(ImageConsumer ic);
synchronized
public void star tProduction(ImageConsumer ic);
awt.image.
renderable
java.awt.image.renderable.RenderableImageProducer
Chapter 19 – The java.awt.image.renderable Package
371

// Methods Implementing Runnable
public void run();
}
Hierar chy: Object→RenderableImageProducer(ImageProducer, Runnable)
RenderContext
Ja va 1.2
java.awt.image.renderable
cloneable
This class contains the information necessary to produce a device-speciﬁc java.awt.-
image.RenderedImage fr om a RenderableImage. That information is a transformation from
user coordinates to device coordinates, an optional java.awt.Shape describing the area of
inter est in the RenderableImage, and an optional set of java.awt.RenderingHints.
public class RenderContext implements Cloneable {
// Public Constructors
public RenderContext(java.awt.geom.AfﬁneTransform usr2dev);
public RenderContext(java.awt.geom.AfﬁneTransform usr2dev, Shape aoi);
public RenderContext(java.awt.geom.AfﬁneTransform usr2dev, RenderingHints hints);
public RenderContext(java.awt.geom.AfﬁneTransform usr2dev, Shape aoi, RenderingHints hints);
// Public Instance Methods
public void concetenateTransfor m(java.awt.geom.AfﬁneTransform modTransform);
public Shape getAreaOfInterest();
public RenderingHints getRenderingHints();
public java.awt.geom.AfﬁneTransform getTransfor m();
public void preConcetenateTransfor m(java.awt.geom.AfﬁneTransform modTransform);
public void setAreaOfInterest(Shape newAoi);
public void setRenderingHints(RenderingHints hints);
public void setTransfor m(java.awt.geom.AfﬁneTransform newTransform);
// Public Methods Overriding Object
public Object clone();
}
Hierar chy: Object→RenderContext(Cloneable)
Passed To: ContextualRenderedImageFactor y.{create(), mapRenderContext()},
RenderableImage.createRendering(), RenderableImageOp.createRendering(),
RenderableImageProducer.{RenderableImageProducer(), setRenderContext()}
Retur ned By: ContextualRenderedImageFactor y.mapRenderContext()
RenderedImageFactor y
Ja va 1.2
java.awt.image.renderable
This interface is implemented by classes that, given a ParameterBlock of arguments and a
set of RenderingHints, can create RenderedImage objects, typically through the process of
rendering a RenderableImage object. The subinterface ContextualRenderedImageFactor y is
used more often than RenderedImageFactor y.
public abstract interface RenderedImageFactor y {
// Public Instance Methods
public abstract RenderedImage create(ParameterBlock paramBlock, RenderingHints hints);
}
Implementations: ContextualRenderedImageFactor y
java.awt.image.renderable.RenderableImageProducer
372 Chapter 19 – The java.awt.image.renderable Package

CHAPTER 20
The java.awt.peer Package
The interfaces in the java.awt.peer package deﬁne the native GUI capabilities that
ar e requir ed by the heavyweight AWT components of the java.awt package. Appli-
cation-level code never needs to use this package. Because the package is rarely
used and because the interfaces of this package closely mirror the component
classes of java.awt, no descriptions are provided for the individual interfaces listed
her e. Figur e 20-1 shows the class hierarchy of this package.
ButtonPeer
Ja va 1.0
java.awt.peer
PJ1.1
public abstract interface ButtonPeer extends ComponentPeer {
// Public Instance Methods
public abstract void setLabel(String label);
}
CanvasPeer
Ja va 1.0
java.awt.peer
PJ1.1
public abstract interface CanvasPeer extends ComponentPeer {
}
CheckboxMenuItemPeer
Ja va 1.0
java.awt.peer
PJ1.1
public abstract interface CheckboxMenuItemPeer extends MenuItemPeer {
// Public Instance Methods
public abstract void setState(boolean t);
}
java.awt.
peer
373

INTERFACE
KEY
extends
ComponentPeer
java.awt.peer
ButtonPeer
CanvasPeer
CheckboxPeer
ChoicePeer
ContainerPeer
LabelPeer
ListPeer
ScrollbarPeer
TextComponentPeer
WindowPeer
ScrollPanePeer
FramePeer
DialogPeer
FileDialogPeer
TextFieldPeer
TextAreaPeer
MenuComponentPeer
MenuBarPeer
MenuItemPeer
CheckboxMenuItemPeer
MenuPeer
LightweightPeer
PanelPeer
PopupMenuPeer
FontPeer
Figur e 20−1: The java.awt.peer package
CheckboxPeer
Ja va 1.0
java.awt.peer
PJ1.1
public abstract interface CheckboxPeer extends ComponentPeer {
// Public Instance Methods
public abstract void setCheckboxGroup(CheckboxGroup g);
public abstract void setLabel(String label);
public abstract void setState(boolean state);
}
ChoicePeer
Ja va 1.0
java.awt.peer
PJ1.1
public abstract interface ChoicePeer extends ComponentPeer {
// Public Instance Methods
1.1 public abstract void add(String item, int index);
public abstract void addItem(String item, int index);
1.1 public abstract void remove(int index);
java.awt.peer.CheckboxMenuItemPeer
374 Chapter 20 – The java.awt.peer Package

public abstract void select(int index);
}
ComponentPeer
Ja va 1.0
java.awt.peer
PJ1.1
public abstract interface ComponentPeer {
// Property Accessor Methods (by property name)
public abstract java.awt.image.ColorModel getColorModel();
1.1 public abstract boolean isFocusTraversable();
public abstract Graphics getGraphics();
1.1 public abstract Point getLocationOnScreen();
1.1 public abstract Dimension getMinimumSize();
1.1 public abstract Dimension getPrefer redSize();
public abstract Toolkit getToolkit();
// Public Instance Methods
public abstract int checkImage(Image img, int w, int h, java.awt.image.ImageObserver o);
public abstract Image createImage(java.awt.image.ImageProducer producer);
public abstract Image createImage(int width, int height);
public abstract void disable();
public abstract void dispose();
public abstract void enable();
public abstract FontMetrics getFontMetrics(Font font);
1.1 public abstract void handleEvent(AWTEvent e);
public abstract void hide();
public abstract Dimension minimumSize();
public abstract void paint(Graphics g);
public abstract Dimension prefer redSize();
public abstract boolean prepareImage(Image img, int w, int h, java.awt.image.ImageObserver o);
public abstract void print(Graphics g);
public abstract void repaint(long tm, int x, int y, int width, int height);
public abstract void requestFocus();
public abstract void reshape(int x, int y, int width, int height);
public abstract void setBackground(Color c);
1.1 public abstract void setBounds(int x, int y, int width, int height);
1.1 public abstract void setCursor(Cursor cursor);
1.1 public abstract void setEnabled(boolean b);
public abstract void setFont(Font f);
public abstract void setForeground(Color c);
1.1 public abstract void setV isible(boolean b);
public abstract void show();
}
ContainerPeer
Ja va 1.0
java.awt.peer
PJ1.1
public abstract interface ContainerPeer extends ComponentPeer {
// Public Instance Methods
1.1 public abstract void beginValidate();
1.1 public abstract void endValidate();
1.1 public abstract Insets getInsets();
java.awt.
peer
java.awt.peer.ContainerPeer
Chapter 20 – The java.awt.peer Package
375

public abstract Insets insets();
}
DialogPeer
Ja va 1.0
java.awt.peer
PJ1.1
public abstract interface DialogPeer extends WindowPeer {
// Public Instance Methods
public abstract void setResizable(boolean resizeable);
public abstract void setT itle(String title);
}
FileDialogPeer
Ja va 1.0
java.awt.peer
PJ1.1
public abstract interface FileDialogPeer extends DialogPeer {
// Public Instance Methods
public abstract void setDirector y(String dir);
public abstract void setF ile(String ﬁle);
public abstract void setF ilenameF ilter(java.io.F ilenameF ilter ﬁlter);
}
FontPeer
Ja va 1.1
java.awt.peer
PJ1.1
public abstract interface FontPeer {
}
FramePeer
Ja va 1.0
java.awt.peer
PJ1.1
public abstract interface FramePeer extends WindowPeer {
// Property Accessor Methods (by property name)
1.2 public abstract int getState();
1.2 public abstract void setState(int state);
// Public Instance Methods
public abstract void setIconImage(Image im);
public abstract void setMenuBar(MenuBar mb);
public abstract void setResizable(boolean resizeable);
public abstract void setT itle(String title);
}
LabelPeer
Ja va 1.0
java.awt.peer
PJ1.1
public abstract interface LabelPeer extends ComponentPeer {
// Public Instance Methods
public abstract void setAlignment(int alignment);
public abstract void setText(String label);
}
java.awt.peer.ContainerPeer
376 Chapter 20 – The java.awt.peer Package

LightweightPeer
Ja va 1.1
java.awt.peer
PJ1.1
public abstract interface LightweightPeer extends ComponentPeer {
}
ListPeer
Ja va 1.0
java.awt.peer
PJ1.1
public abstract interface ListPeer extends ComponentPeer {
// Public Instance Methods
1.1 public abstract void add(String item, int index);
public abstract void addItem(String item, int index);
public abstract void clear();
public abstract void delItems(int star t, int end);
public abstract void deselect(int index);
1.1 public abstract Dimension getMinimumSize(int rows);
1.1 public abstract Dimension getPrefer redSize(int rows);
public abstract int[ ] getSelectedIndexes();
public abstract void makeV isible(int index);
public abstract Dimension minimumSize(int v);
public abstract Dimension prefer redSize(int v);
1.1 public abstract void removeAll();
public abstract void select(int index);
1.1 public abstract void setMultipleMode(boolean b);
public abstract void setMultipleSelections(boolean v);
}
MenuBarPeer
Ja va 1.0
java.awt.peer
PJ1.1
public abstract interface MenuBarPeer extends MenuComponentPeer {
// Public Instance Methods
public abstract void addHelpMenu(Menu m);
public abstract void addMenu(Menu m);
public abstract void delMenu(int index);
}
MenuComponentPeer
Ja va 1.0
java.awt.peer
PJ1.1
public abstract interface MenuComponentPeer {
// Public Instance Methods
public abstract void dispose();
}
java.awt.
peer
java.awt.peer.MenuComponentPeer
Chapter 20 – The java.awt.peer Package
377

MenuItemPeer
Ja va 1.0
java.awt.peer
PJ1.1
public abstract interface MenuItemPeer extends MenuComponentPeer {
// Public Instance Methods
public abstract void disable();
public abstract void enable();
1.1 public abstract void setEnabled(boolean b);
public abstract void setLabel(String label);
}
MenuPeer
Ja va 1.0
java.awt.peer
PJ1.1
public abstract interface MenuPeer extends MenuItemPeer {
// Public Instance Methods
public abstract void addItem(MenuItem item);
public abstract void addSeparator();
public abstract void delItem(int index);
}
PanelPeer
Ja va 1.0
java.awt.peer
PJ1.1
public abstract interface PanelPeer extends ContainerPeer {
}
PopupMenuPeer
Ja va 1.1
java.awt.peer
PJ1.1
public abstract interface PopupMenuPeer extends MenuPeer {
// Public Instance Methods
public abstract void show(Event e);
}
ScrollbarPeer
Ja va 1.0
java.awt.peer
PJ1.1
public abstract interface ScrollbarPeer extends ComponentPeer {
// Public Instance Methods
public abstract void setLineIncrement(int l);
public abstract void setPageIncrement(int l);
public abstract void setValues(int value, int visible, int minimum, int maximum);
}
java.awt.peer.MenuItemPeer
378 Chapter 20 – The java.awt.peer Package

ScrollPanePeer
Ja va 1.1
java.awt.peer
PJ1.1
public abstract interface ScrollPanePeer extends ContainerPeer {
// Public Instance Methods
public abstract void childResized(int w, int h);
public abstract int getHScrollbarHeight();
public abstract int getVScrollbarW idth();
public abstract void setScrollPosition(int x, int y);
public abstract void setUnitIncrement(Adjustable adj, int u);
public abstract void setValue(Adjustable adj, int v);
}
TextAreaPeer
Ja va 1.0
java.awt.peer
PJ1.1
public abstract interface TextAreaPeer extends TextComponentPeer {
// Public Instance Methods
1.1 public abstract Dimension getMinimumSize(int rows, int columns);
1.1 public abstract Dimension getPrefer redSize(int rows, int columns);
1.1 public abstract void inser t(String text, int pos);
public abstract void inser tText(String txt, int pos);
public abstract Dimension minimumSize(int rows, int cols);
public abstract Dimension prefer redSize(int rows, int cols);
1.1 public abstract void replaceRange(String text, int star t, int end);
public abstract void replaceText(String txt, int star t, int end);
}
TextComponentPeer
Ja va 1.0
java.awt.peer
PJ1.1
public abstract interface TextComponentPeer extends ComponentPeer {
// Property Accessor Methods (by property name)
1.1 public abstract int getCaretPosition();
1.1 public abstract void setCaretPosition(int pos);
public abstract int getSelectionEnd();
public abstract int getSelectionStar t();
public abstract String getText();
public abstract void setText(String l);
// Public Instance Methods
public abstract void select(int selStar t, int selEnd);
public abstract void setEditable(boolean editable);
}
TextF ieldPeer
Ja va 1.0
java.awt.peer
PJ1.1
public abstract interface TextF ieldPeer extends TextComponentPeer {
// Public Instance Methods
1.1 public abstract Dimension getMinimumSize(int columns);
1.1 public abstract Dimension getPrefer redSize(int columns);
public abstract Dimension minimumSize(int cols);
public abstract Dimension prefer redSize(int cols);
java.awt.
peer
java.awt.peer.TextFieldPeer
Chapter 20 – The java.awt.peer Package
379

1.1 public abstract void setEchoChar(char echoChar);
public abstract void setEchoCharacter(char c);
}
WindowPeer
Ja va 1.0
java.awt.peer
PJ1.1
public abstract interface WindowPeer extends ContainerPeer {
// Public Constants
=1
1.2 public static ﬁnal int CONSUME_EVENT;
=2
1.2 public static ﬁnal int FOCUS_NEXT;
=3
1.2 public static ﬁnal int FOCUS_PREVIOUS;
=0
1.2 public static ﬁnal int IGNORE_EVENT;
// Public Instance Methods
1.2 public abstract int handleFocusTraversalEvent(java.awt.e vent.Ke yEvent e);
public abstract void toBack();
public abstract void toFront();
}
java.awt.peer.TextFieldPeer
380 Chapter 20 – The java.awt.peer Package

CHAPTER 21
The java.awt.pr int Package
The java.awt.print package contains classes and interfaces that support printing. It
has been introduced in Java 1.2 and supersedes the PrintJob class of the java.awt
package. The most important class in this package is PrinterJob; it coordinates the
printing process. The Printable and Pageable inter faces repr esent printable objects or
documents that can be printed with a PrinterJob. Figur e 21-1 shows the class hierar-
chy of this package. See Chapter 5, Printing, for more details on printing.
CLASS
INTERFACE
ABSTRACT CLASS
KEY
extends
implements
PageFormat
java.awt.print
java.lang
Book
Cloneable
Paper
PrinterException
Pageable
Exception
Object
PrinterJob
Printable
PrinterGraphics
PrinterAbortException
PrinterIOException
Figur e 21−1: The java.awt.print package
java.awt.
print
381

Book
Ja va 1.2
java.awt.print
This class implements a multi-page Pageable document out of individual single-page
Printable objects. Each page of the Book can have its own PageFor mat speciﬁed. You might
use this class, for example, in a database-reporting application when you want to print
a report that consists of single-page tables and graphs in mixed portrait and landscape
modes.
The append() and setPage() methods allow you to specify the Printable pages that make
up the book, along with their PageFor mat objects. The remaining methods implement the
Pageable inter face and are used by a PrinterJob to print the Book.
As with all Pageable objects, the Printable objects added to a Book must print only a single
page. (See Pageable for details.) Note that the three-argument version of append() takes a
numPages argument. This argument does not specify the number of pages in the Printable;
instead, it speciﬁes the number of identical copies of the single-page Printable to be
printed.
public class Book implements Pageable {
// Public Constructors
public Book();
// Public Instance Methods
public void append(Printable painter, PageFormat page);
public void append(Printable painter, PageFormat page, int numPages);
public void setPage(int pageIndex, Printable painter, PageFormat page) throws IndexOutOfBoundsException;
// Methods Implementing Pageable
default:0
public int getNumberOfPages();
public PageFormat getPageFor mat(int pageIndex) throws IndexOutOfBoundsException;
public Printable getPrintable(int pageIndex) throws IndexOutOfBoundsException;
}
Hierar chy: Object→Book(Pageable)
Pageable
Ja va 1.2
java.awt.print
This interface is implemented by multipage documents that know how to print them-
selves in more sophisticated ways than the Printable inter face allows. There are two pri-
mary differ ences between Pageable and Printable. The ﬁrst is that a Pageable object knows
how many pages are in the document and can print them in an arbitrary order. This
allows a printer dialog to give the user the choice to print only a range of pages within
the document. It also allows the user to request that the pages be printed in reverse
order, which is useful on some printers that stack document pages in reverse order. The
second differ ence between Pageable and Printable is that each page of a Pageable may
have a differ ent PageFor mat associated with it. This is useful when a document contains
pages in portrait orientation and some pages in landscape orientation, for example.
The heart of the Pageable inter face is the method getPrintable(), which retur ns a Printable
object able to print the speciﬁed page of the document. The Printable objects retur ned
by this method are used differ ently and must be implemented differ ently than Printable
objects that are designed to be printed alone. While standalone Printable objects may
print multiple pages, the Printable objects retur ned by a Pageable repr esent only a single
page. In other words, the getPrintable() method of Pageable is called once for every page
in the document, and the Printable it retur ns is used to print only that one page.
The Pageable inter face lends itself to two distinct implementation strategies. In the ﬁrst,
the getPrintable() method retur ns a dif ferent Printable object for each page of the docu-
ment. This Printable object knows exactly what page to print and can ignore the pageIndex
java.awt.pr int.Book
382 Chapter 21 – The java.awt.pr int Package

argument passed to its print() method. The second strategy is to implement a single Print-
able object and have the getPrintable() method always retur n this one object, regardless
of page number. In this case, the print() method uses the pageIndex argument to decide
what page to print. Note that a Printable implemented in this way must be more ﬂexible
than a standalone Printable object, since its pages may be printed in any order and are
not guaranteed to be accessed sequentially.
Finally, as with standalone Printable objects, Printable objects retur ned by Pageable objects
must be prepar ed to have their print() methods called multiple times for the same page
number. This is a requir ement for banded raster printing in low-memory environments.
See Printable for details.
public abstract interface Pageable {
// Public Constants
=-1
public static ﬁnal int UNKNOWN_NUMBER_OF_PAGES;
// Public Instance Methods
public abstract int getNumberOfPages();
public abstract PageFormat getPageFor mat(int pageIndex) throws IndexOutOfBoundsException;
public abstract Printable getPrintable(int pageIndex) throws IndexOutOfBoundsException;
}
Implementations: Book
Passed To: PrinterJob.setPageable()
PageFormat
Ja va 1.2
java.awt.print
cloneable
This class is a combination of a Paper object that speciﬁes page size and imageable area
with a ﬁeld that speciﬁes the orientation of the page. The orientation values are the fol-
lowing:
PORTRAIT
This is the normal orientation of a piece of paper. The origin is at the top left, with
the X axis running from left to right and the Y axis running from top to bottom.
LANDSCAPE
This is the orientation that results from rotating a piece of paper 90 degrees clock-
wise. The origin is at the bottom left of the sheet of paper, with the X axis running
fr om bottom to top and the Y axis running from left to right.
REVERSE_LANDSCAPE
This is the orientation that results from rotating a piece of paper 90 degrees coun-
terclockwise. The origin is at the top right of the sheet of paper, with the X axis
running from top to bottom and the Y axis running from right to left.
Printable and Pageable objects are not responsible for perfor ming the rotations necessary
to print in these orientations. The appropriate transform has already been done in the
Graphics object passed to the print() method of Printable.
public class PageFormat implements Cloneable {
// Public Constructors
public PageFormat();
// Public Constants
=0
public static ﬁnal int LANDSCAPE;
=1
public static ﬁnal int PORTRAIT;
=2
public static ﬁnal int REVERSE_LANDSCAPE;
// Property Accessor Methods (by property name)
java.awt.
print
java.awt.pr int.PageFor mat
Chapter 21 – The java.awt.pr int Package
383

default:792.0
public double getHeight();
default:648.0
public double getImageableHeight();
default:468.0
public double getImageableW idth();
default:72.0
public double getImageableX();
default:72.0
public double getImageableY();
public double[ ] getMatrix();
default:1
public int getOrientation();
public void setOrientation(int orientation) throws IllegalArgumentException;
public Paper getPaper();
public void setPaper(Paper paper);
default:612.0
public double getW idth();
// Public Methods Overriding Object
public Object clone();
}
Hierar chy: Object→PageFor mat(Cloneable)
Passed To: Book.{append(), setPage()}, Printable.print(), PrinterJob.{defaultPage(), pageDialog(),
setPrintable(), validatePage()}
Retur ned By: Book.getPageFor mat(), Pageable.getPageFor mat(), PrinterJob.{defaultPage(), pageDialog(),
validatePage()}
Paper
Ja va 1.2
java.awt.print
cloneable
This class describes the width, height, and imageable area of a piece of paper. The
imageable area is the region of a page that should be printed on—the area inside the
margins. Most printers cannot print all the way to the edges of the page and requir e
margins of at least a quarter inch on all sides. All coordinates and sizes used by this
class are measur ed in printer’s points, where one point is deﬁned as exactly 1/72nd of
an inch.
public class Paper implements Cloneable {
// Public Constructors
public Paper();
// Property Accessor Methods (by property name)
default:792.0
public double getHeight();
default:648.0
public double getImageableHeight();
default:468.0
public double getImageableW idth();
default:72.0
public double getImageableX();
default:72.0
public double getImageableY();
default:612.0
public double getW idth();
// Public Instance Methods
public void setImageableArea(double x, double y, double width, double height);
public void setSize(double width, double height);
// Public Methods Overriding Object
public Object clone();
}
Hierar chy: Object→Paper(Cloneable)
Passed To: PageFor mat.setPaper()
Retur ned By: PageFor mat.getPaper()
Printable
Ja va 1.2
java.awt.print
java.awt.pr int.PageFor mat
384 Chapter 21 – The java.awt.pr int Package

This interface is implemented by objects that know how to print themselves. It should
be implemented by objects that always print a single page, or by multipage documents
that know how to print their pages in sequential order only. Multipage documents that
ar e able to print their pages in arbitrary order should implement the somewhat more
complex Pageable inter face.
When a PrinterJob prints a Printable object, it calls the print() method one or more times to
print the pages. This method should print the page speciﬁed by pageIndex, using the
speciﬁed Graphics object and the page size and orientation speciﬁed in the PageFor mat
object.
The PrinterJob guarantees that it prints the pages of a Printable in strictly sequential order.
The pageIndex argument begins at 0 and increases. After printing a page, the print()
method should retur n the PA GE_EXISTS constant. Since the PrinterJob has no way of know-
ing how many pages there are in a Printable object, it keeps increasing the page number
until the print() method retur ns the NO_SUCH_PAGE constant. When this value is retur ned,
the PrinterJob knows that it has reached the end of the print job.
Ther e is a very important twist in this communication protocol between PrinterJob and
Printable. While the PrinterJob guarantees that it does not try to print pages out of order, it
is allowed to print the same page multiple times. This means, for example, that the
print() method may be called with a pageIndex argument of 0 three times in a row. Printable
objects must be implemented with this possibility in mind. The reason that this is nec-
essary is that, in some cases, printing is done into a very large (high-resolution) off-
scr een image, and this image data is then transferred to the printer. On systems with
limited memory, this printing technique must be done in multiple passes, printing only
a fraction, or band, of the page at each pass.
The Printable inter face is also used by Pageable objects that know how to print their
pages out of order. When a Printable object is retur ned by a Pageable object, the PrinterJob
uses it differ ently than it does a standalone Printable object. See Pageable for details.
public abstract interface Printable {
// Public Constants
=1
public static ﬁnal int NO_SUCH_PAGE;
=0
public static ﬁnal int PA GE_EXISTS;
// Public Instance Methods
public abstract int print(Graphics graphics, PageFormat pageFormat, int pageIndex) throws PrinterException;
}
Passed To: Book.{append(), setPage()}, PrinterJob.setPrintable()
Retur ned By: Book.getPrintable(), Pageable.getPrintable()
PrinterAbor tException
Ja va 1.2
java.awt.print
serializable checked
Signals that a print job has been aborted, typically because of a user request to termi-
nate it.
public class PrinterAbor tException extends PrinterException {
// Public Constructors
public PrinterAbor tException();
java.awt.
print
java.awt.pr int.Pr interAbortException
Chapter 21 – The java.awt.pr int Package
385

public PrinterAbor tException(String msg);
}
Hierar chy: Object→Throwable(Serializable)→Exception→PrinterException→PrinterAbor tException
PrinterException
Ja va 1.2
java.awt.print
serializable checked
This class serves as the superclass for all exceptions that may arise in the process of
printing. See the subclasses PrinterAbor tException and PrinterIOException. PrinterException and
its subclasses are checked exceptions, they must be declared in the throws clauses of
methods that may throw them.
public class PrinterException extends Exception {
// Public Constructors
public PrinterException();
public PrinterException(String msg);
}
Hierar chy: Object→Throwable(Serializable)→Exception→PrinterException
Subc lasses: PrinterAbor tException, PrinterIOException
Thrown By: Printable.print(), PrinterJob.print()
PrinterGraphics
Ja va 1.2
java.awt.print
This interface is implemented by any Graphics object that is passed to the print() method
of a Printable object. This means that a Printable can always cast its Graphics object to a
PrinterGraphics object and use the getPrinterJob() method to obtain the PrinterJob that is in
use.
public abstract interface PrinterGraphics {
// Public Instance Methods
public abstract PrinterJob getPrinterJob();
}
PrinterIOException
Ja va 1.2
java.awt.print
serializable checked
Indicates that an I/O error occurred during the printing process. This usually means
that the PrinterJob had trouble communicating with the printer or print server.
public class PrinterIOException extends PrinterException {
// Public Constructors
public PrinterIOException(java.io.IOException exception);
// Public Instance Methods
public java.io.IOException getIOException();
}
Hierar chy: Object→Throwable(Serializable)→Exception→PrinterException→PrinterIOException
PrinterJob
Ja va 1.2
java.awt.print
This class controls printing of Printable and Pageable objects. Applications typically use
this class as follows:
java.awt.pr int.Pr interAbortException
386 Chapter 21 – The java.awt.pr int Package

•
Create a PrinterJob by calling the static method getPrinterJob(). This requir es appr opri-
ate security permissions, so untrusted applets cannot do this.
•
Conﬁgur e the PrinterJob, if desir ed, by calling setJobName() and setCopies().
•
Interactive applications that want to give the user a choice about page orientation
and margins should call pageDialog(), passing in a default PageFor mat object. This
method retur ns a new PageFor mat object that contains the user’s choices. While
pageDialog() is suitable for simple single-page Printable objects, it typically is not nec-
essary for more complex multipage documents, since these often have implicit or
explicit margin sizes and page orientation already speciﬁed.
•
Call setPrintable() or setPageable() to specify the object to be printed. You can use the
PageFor mat object retur ned by pageDialog(), defaultPage(), or validatePage() when creat-
ing the Printable or Pageable object used in this step. Or you can pass such a PageFor-
mat object to the two-argument version of setPrintable().
•
If your application is an interactive one, call printDialog() to give the user a chance
to specify what range of pages to print or to cancel the print job. printDialog() con-
ﬁgur es the PrinterJob and retur ns tr ue if the user wants to proceed with the print
job. If printDialog() retur ns false, you should not continue with the print job. Non-
interactive jobs that run unattended should skip this step.
•
Finally, call print() to begin printing. If you are using more than one thread, you
can abort the print job by calling cancel().
PrinterJob is the preferr ed class for printing in Java 1.2. Do not confuse it with
java.awt.PrintJob, which was introduced in Java 1.1.
public abstract class PrinterJob {
// Public Constructors
public PrinterJob();
// Public Class Methods
public static PrinterJob getPrinterJob();
// Property Accessor Methods (by property name)
public abstract boolean isCancelled();
public abstract int getCopies();
public abstract void setCopies(int copies);
public abstract String getJobName();
public abstract void setJobName(String jobName);
public abstract String getUserName();
// Public Instance Methods
public abstract void cancel();
public PageFormat defaultPage();
public abstract PageFormat defaultPage(PageFormat page);
public abstract PageFormat pageDialog(PageFormat page);
public abstract void print() throws PrinterException;
public abstract boolean printDialog();
public abstract void setPageable(Pageable document) throws NullPointerException;
public abstract void setPrintable(Printable painter);
public abstract void setPrintable(Printable painter, PageFormat format);
public abstract PageFormat validatePage(PageFormat page);
}
Retur ned By: PrinterGraphics.getPrinterJob(), PrinterJob.getPrinterJob()
java.awt.
print
java.awt.pr int.Pr interJob
Chapter 21 – The java.awt.pr int Package
387

CHAPTER 22
The javax.accessibility Package
The javax.accessibility package contains classes and interfaces that deﬁne the con-
tract between an accessible application and an assistive technology, such as a
scr een reader for the vision impaired. All accessible GUI components implement
the Accessible inter face and must be able to retur n an AccessibleContext object. Acces-
sibleContext is the main entry point for an assistive technology to obtain information
about the component. The methods of AccessibleContext retur n instances of many of
the other classes and interfaces in this package. Figure 22-1 shows the class hierar-
chy of this package, which is new in Java 1.2.
Typically, only GUI component developers and developers of assistive technolo-
gies need to use this package. Chapter 3, Swing Programming Topics, contains an
overview of accessibility.
Accessible
Ja va 1.2
javax.accessibility
accessible
This interface is the primary point of interaction between assistive technologies and
accessible objects. All accessible objects implement the getAccessibleContext() method of
this interface, providing a way for an assistive technology to obtain an AccessibleContext
object that describes the accessible object. Component developers should implement
this interface for their components, but application developers should never have to
use it.
public abstract interface Accessible {
// Public Instance Methods
public abstract AccessibleContext getAccessibleContext();
}
Implementations: Too many classes to list.
Passed To: AccessibleContext.setAccessibleParent(),
javax.swing .JTree.AccessibleJTree.AccessibleJTreeNode.AccessibleJTreeNode()
388

ABSTRACT CLASS
extends
implements
KEY
CLASS
INTERFACE
java.lang
Object
ListResourceBundle
AccessibleBundle
javax.accessibility
AccessibleRole
AccessibleState
AccessibleResourceBundle
java.util
AccessibleContext
AccessibleHyperlink
AccessibleStateSet
Accessible
AccessibleAction
AccessibleComponent
AccessibleSelection
AccessibleHypertext
AccessibleValue
AccessibleText
Figur e 22−1: The javax.accessibility package
Retur ned By: Too many methods to list.
Type Of: AccessibleContext.accessibleParent
AccessibleAction
Ja va 1.2
javax.accessibility
This interface allows an assistive technology to obtain human-readable descriptions of
the actions that an accessible object can perfor m and request that the object perfor m
any one of them. Any accessible object that can perfor m one or more actions should
retur n an AccessibleAction object from the getAccessibleAction() method of its AccessibleCon-
text object. Applications never need to use or implement this interface.
public abstract interface AccessibleAction {
// Public Instance Methods
public abstract boolean doAccessibleAction(int i);
public abstract int getAccessibleActionCount();
public abstract String getAccessibleActionDescription(int i);
}
Implementations: AccessibleHyper link, javax.swing .AbstractButton.AccessibleAbstractButton,
javax.swing .JComboBox.AccessibleJComboBox, javax.swing .JTree.AccessibleJTree.AccessibleJTreeNode
Retur ned By: AccessibleContext.getAccessibleAction(),
javax.swing .AbstractButton.AccessibleAbstractButton.getAccessibleAction(),
javax.swing .JComboBox.AccessibleJComboBox.getAccessibleAction(),
javax.swing .JList.AccessibleJList.AccessibleJListChild.getAccessibleAction(),
javax.swing .JTable.AccessibleJTable.AccessibleJTableCell.getAccessibleAction(),
javax.swing .JTree.AccessibleJTree.AccessibleJTreeNode.getAccessibleAction(),
javax.swing .table.JTableHeader.AccessibleJTableHeader.AccessibleJTableHeaderEntr y.getAccessibleAction()
javax.
accessibility
javax.accessibility.AccessibleAction
Chapter 22 – The javax.accessibility Package
389

AccessibleBundle
Ja va 1.2
javax.accessibility
This class is the abstract superclass of both AccessibleRole and AccessibleState. It deﬁnes
the localized toDisplayString() method. Applications never need to use this class.
public abstract class AccessibleBundle {
// Public Constructors
public AccessibleBundle();
// Public Instance Methods
public String toDisplayString();
public String toDisplayString(java.util.Locale locale);
// Public Methods Overriding Object
public String toString();
// Protected Instance Methods
protected String toDisplayString(String resourceBundleName, java.util.Locale locale);
// Protected Instance Fields
protected String key;
}
Subc lasses: AccessibleRole, AccessibleState
AccessibleComponent
Ja va 1.2
javax.accessibility
This interface allows an assistive technology to query and set basic graphical attributes
for an accessible object. Any accessible object that displays itself on the screen should
retur n an object of this type from the getAccessibleComponent() method of its AccessibleCon-
text. Applications never need to use or implement this interface.
public abstract interface AccessibleComponent {
// Event Registration Methods (by event name)
public abstract void addFocusListener(java.awt.e vent.FocusListener l);
public abstract void removeFocusListener(java.awt.e vent.FocusListener l);
// Property Accessor Methods (by property name)
public abstract java.awt.Color getBackground();
public abstract void setBackground(java.awt.Color c);
public abstract java.awt.Rectangle getBounds();
public abstract void setBounds(java.awt.Rectangle r);
public abstract java.awt.Cursor getCursor();
public abstract void setCursor(java.awt.Cursor cursor);
public abstract boolean isEnabled();
public abstract void setEnabled(boolean b);
public abstract boolean isFocusTraversable();
public abstract java.awt.Font getFont();
public abstract void setFont(java.awt.Font f);
public abstract java.awt.Color getForeground();
public abstract void setForeground(java.awt.Color c);
public abstract java.awt.Point getLocation();
public abstract void setLocation(java.awt.Point p);
public abstract java.awt.Point getLocationOnScreen();
public abstract boolean isShowing();
public abstract java.awt.Dimension getSize();
public abstract void setSize(java.awt.Dimension d);
public abstract boolean isV isible();
public abstract void setV isible(boolean b);
// Public Instance Methods
public abstract boolean contains(java.awt.Point p);
public abstract Accessible getAccessibleAt(java.awt.Point p);
javax.accessibility.AccessibleBundle
390 Chapter 22 – The javax.accessibility Package

public abstract java.awt.FontMetrics getFontMetrics(java.awt.Font f);
public abstract void requestFocus();
}
Implementations: javax.swing .Box.AccessibleBox, javax.swing .Box.Filler.AccessibleBoxF iller,
javax.swing .CellRendererPane.AccessibleCellRendererPane, javax.swing .JApplet.AccessibleJApplet,
javax.swing .JComponent.AccessibleJComponent, javax.swing .JDialog .AccessibleJDialog,
javax.swing .JFrame.AccessibleJFrame, javax.swing .JList.AccessibleJList.AccessibleJListChild,
javax.swing .JPopupMenu.W indowPopup.AccessibleW indowPopup,
javax.swing .JTable.AccessibleJTable.AccessibleJTableCell,
javax.swing .JTree.AccessibleJTree.AccessibleJTreeNode, javax.swing .JWindow.AccessibleJW indow,
javax.swing .table.JTableHeader.AccessibleJTableHeader.AccessibleJTableHeaderEntr y
Retur ned By: AccessibleContext.getAccessibleComponent(),
javax.swing .Box.AccessibleBox.getAccessibleComponent(),
javax.swing .Box.Filler.AccessibleBoxF iller.getAccessibleComponent(),
javax.swing .CellRendererPane.AccessibleCellRendererPane.getAccessibleComponent(),
javax.swing .JApplet.AccessibleJApplet.getAccessibleComponent(),
javax.swing .JComponent.AccessibleJComponent.getAccessibleComponent(),
javax.swing .JDialog .AccessibleJDialog.getAccessibleComponent(),
javax.swing .JFrame.AccessibleJFrame.getAccessibleComponent(),
javax.swing .JList.AccessibleJList.AccessibleJListChild.getAccessibleComponent(),
javax.swing .JPopupMenu.W indowPopup.AccessibleW indowPopup.getAccessibleComponent(),
javax.swing .JTable.AccessibleJTable.AccessibleJTableCell.getAccessibleComponent(),
javax.swing .JTree.AccessibleJTree.AccessibleJTreeNode.getAccessibleComponent(),
javax.swing .JWindow.AccessibleJW indow.getAccessibleComponent(),
javax.swing .table.JTableHeader.AccessibleJTableHeader.AccessibleJTableHeaderEntr y.getAccessibleComponent()
AccessibleContext
Ja va 1.2
javax.accessibility
accessible context
This abstract class deﬁnes methods that provide basic information about an accessible
object. Every Accessible object must be able to retur n an AccessibleContext to describe
itself. The methods of AccessibleContext ar e largely self-explanatory. They allow an assis-
tive technology to query the name, description, role, parent, children, and so on of the
accessible object. In addition to this generic accessibility information, a number of
AccessibleContext methods retur n mor e specialized objects that contain more specialized
types of accessibility information. For example, if an accessible object is a GUI compo-
nent, getAccessibleComponent() retur ns an AccessibleComponent object that contains further
details about the accessible object. Applications never have to use this class.
public abstract class AccessibleContext {
// Public Constructors
public AccessibleContext();
// Public Constants
="AccessibleActiveDescendant"
public static ﬁnal String ACCESSIBLE_ACTIVE_DESCENDANT_PROPERTY;
="AccessibleCaret"
public static ﬁnal String ACCESSIBLE_CARET_PROPERTY;
="AccessibleChild"
public static ﬁnal String ACCESSIBLE_CHILD_PROPERTY;
="AccessibleDescription"
public static ﬁnal String ACCESSIBLE_DESCRIPTION_PROPERTY;
="AccessibleName"
public static ﬁnal String ACCESSIBLE_NAME_PROPERTY;
="AccessibleSelection"
public static ﬁnal String ACCESSIBLE_SELECTION_PROPERTY;
="AccessibleState"
public static ﬁnal String ACCESSIBLE_STATE_PROPERTY;
="AccessibleText"
public static ﬁnal String ACCESSIBLE_TEXT_PROPERTY;
="AccessibleValue"
public static ﬁnal String ACCESSIBLE_VALUE_PROPERTY;
="AccessibleVisibleData"
public static ﬁnal String ACCESSIBLE_VISIBLE_DATA_PROPERTY;
javax.
accessibility
javax.accessibility.AccessibleContext
Chapter 22 – The javax.accessibility Package
391

// Event Registration Methods (by event name)
public void addProper tyChangeListener(java.beans.Proper tyChangeListener listener);
public void removeProper tyChangeListener(java.beans.Proper tyChangeListener listener);
// Property Accessor Methods (by property name)
constant
public AccessibleAction getAccessibleAction();
public abstract int getAccessibleChildrenCount();
constant
public AccessibleComponent getAccessibleComponent();
public String getAccessibleDescription();
public void setAccessibleDescription(String s);
public abstract int getAccessibleIndexInParent();
public String getAccessibleName();
public void setAccessibleName(String s);
public Accessible getAccessibleParent();
public void setAccessibleParent(Accessible a);
public abstract AccessibleRole getAccessibleRole();
constant
public AccessibleSelection getAccessibleSelection();
public abstract AccessibleStateSet getAccessibleStateSet();
constant
public AccessibleText getAccessibleText();
constant
public AccessibleValue getAccessibleValue();
public abstract java.util.Locale getLocale() throws java.awt.IllegalComponentStateException;
// Public Instance Methods
public void ﬁreProper tyChange(String proper tyName, Object oldValue, Object newValue);
public abstract Accessible getAccessibleChild(int i);
// Protected Instance Fields
protected String accessibleDescription;
protected String accessibleName;
protected Accessible accessibleParent;
}
Subc lasses: javax.swing .Box.AccessibleBox, javax.swing .Box.Filler.AccessibleBoxF iller,
javax.swing .CellRendererPane.AccessibleCellRendererPane, javax.swing .JApplet.AccessibleJApplet,
javax.swing .JComponent.AccessibleJComponent, javax.swing .JDialog .AccessibleJDialog,
javax.swing .JFrame.AccessibleJFrame, javax.swing .JList.AccessibleJList.AccessibleJListChild,
javax.swing .JPopupMenu.W indowPopup.AccessibleW indowPopup,
javax.swing .JTable.AccessibleJTable.AccessibleJTableCell,
javax.swing .JTree.AccessibleJTree.AccessibleJTreeNode, javax.swing .JWindow.AccessibleJW indow,
javax.swing .table.JTableHeader.AccessibleJTableHeader.AccessibleJTableHeaderEntr y
Retur ned By: Too many methods to list.
Type Of: javax.swing .Box.accessibleContext, javax.swing .Box.Filler.accessibleContext,
javax.swing .CellRendererPane.accessibleContext, javax.swing .JApplet.accessibleContext,
javax.swing .JColorChooser.accessibleContext, javax.swing .JComponent.accessibleContext,
javax.swing .JDialog.accessibleContext, javax.swing .JFileChooser.accessibleContext,
javax.swing .JFrame.accessibleContext, javax.swing .JWindow.accessibleContext
AccessibleHyper link
Ja va 1.2
javax.accessibility
This abstract class is an AccessibleAction that describes a hyperlink or set of hyperlinks,
such as those found in an HTML image map. In addition to the AccessibleAction methods,
this class deﬁnes getAccessibleActionObject(), which should retur n an object describing the
link, typically a java.net.URL object. getAccessibleActionAnchor() should retur n the object that
displays the link. For HTML hypertext, this is the string or image that appears between
the HTML <A> and </A> tags. Applications never need to use this class.
javax.accessibility.AccessibleContext
392 Chapter 22 – The javax.accessibility Package

public abstract class AccessibleHyper link implements AccessibleAction {
// Public Constructors
public AccessibleHyper link();
// Property Accessor Methods (by property name)
Implements:AccessibleAction
public abstract int getAccessibleActionCount();
public abstract int getEndIndex();
public abstract int getStar tIndex();
public abstract boolean isValid();
// Public Instance Methods
public abstract Object getAccessibleActionAnchor(int i);
public abstract Object getAccessibleActionObject(int i);
// Methods Implementing AccessibleAction
public abstract boolean doAccessibleAction(int i);
public abstract int getAccessibleActionCount();
public abstract String getAccessibleActionDescription(int i);
}
Hierar chy: Object→AccessibleHyper link(AccessibleAction)
Subc lasses: javax.swing .JEditorPane.JEditorPaneAccessibleHyper textSuppor t.HTMLLink
Retur ned By: AccessibleHyper text.getLink(),
javax.swing .JEditorPane.JEditorPaneAccessibleHyper textSuppor t.getLink()
AccessibleHyper text
Ja va 1.2
javax.accessibility
This interface extends AccessibleText. It allows an assistive technology to query the text
of an accessible object and the hyperlinks contained in that text. Accessible com-
ponents that display hyperlinked text should retur n an object of this type from the get-
AccessibleText()
method of their
AccessibleContext.
The
getLink()
method of the
AccessibleHyper text object should retur n AccessibleHyper link objects describing the links.
Applications never need to use or implement this interface.
public abstract interface AccessibleHyper text extends AccessibleText {
// Public Instance Methods
public abstract AccessibleHyperlink getLink(int linkIndex);
public abstract int getLinkCount();
public abstract int getLinkIndex(int charIndex);
}
Hierar chy: (AccessibleHyper text(AccessibleText))
Implementations: javax.swing .JEditorPane.JEditorPaneAccessibleHyper textSuppor t
AccessibleResourceBundle
Ja va 1.2
javax.accessibility
This class is a java.util.ResourceBundle that contains all the localized strings for the
javax.accessibility package. It is used internally by the package and is not intended for use
by applications, components, or assistive technologies.
public class AccessibleResourceBundle extends java.util.ListResourceBundle {
// Public Constructors
public AccessibleResourceBundle();
// Public Methods Overriding ListResourceBundle
public Object[ ][ ] getContents();
}
javax.
accessibility
javax.accessibility.AccessibleResour ceBundle
Chapter 22 – The javax.accessibility Package
393

Hierar chy: Object→java.util.ResourceBundle→java.util.ListResourceBundle→
AccessibleResourceBundle
AccessibleRole
Ja va 1.2
javax.accessibility
This class exists only to provide a type-safe enumeration of constants that may be
legally retur ned by the getAccessibleRole() method of an AccessibleContext object. An Acces-
sibleRole object describes the role or basic function of an accessible object. The prede-
ﬁned AccessibleRole objects describe the roles played by various Swing components.
This set of predeﬁned roles should be sufﬁcient for most purposes, although a special-
ized component that perfor ms a specialized role could create a new role constant for
itself by subclassing AccessibleRole. AccessibleRole inherits toDisplayString() fr om it super-
class. This method retur ns a localized human-readable string describing the role. Appli-
cations never need to use this class.
public class AccessibleRole extends AccessibleBundle {
// Protected Constructors
protected AccessibleRole(String key);
// Public Constants
public static ﬁnal AccessibleRole ALERT;
public static ﬁnal AccessibleRole AWT_COMPONENT;
public static ﬁnal AccessibleRole CHECK_BOX;
public static ﬁnal AccessibleRole COLOR_CHOOSER;
public static ﬁnal AccessibleRole COLUMN_HEADER;
public static ﬁnal AccessibleRole COMBO_BOX;
public static ﬁnal AccessibleRole DESKTOP_ICON;
public static ﬁnal AccessibleRole DESKTOP_PANE;
public static ﬁnal AccessibleRole DIALOG;
public static ﬁnal AccessibleRole DIRECTORY_PANE;
public static ﬁnal AccessibleRole FILE_CHOOSER;
public static ﬁnal AccessibleRole FILLER;
public static ﬁnal AccessibleRole FRAME;
public static ﬁnal AccessibleRole GLASS_PANE;
public static ﬁnal AccessibleRole INTERNAL_FRAME;
public static ﬁnal AccessibleRole LABEL;
public static ﬁnal AccessibleRole LAYERED_PANE;
public static ﬁnal AccessibleRole LIST;
public static ﬁnal AccessibleRole MENU;
public static ﬁnal AccessibleRole MENU_BAR;
public static ﬁnal AccessibleRole MENU_ITEM;
public static ﬁnal AccessibleRole OPTION_PANE;
public static ﬁnal AccessibleRole PA GE_TAB;
public static ﬁnal AccessibleRole PA GE_TAB_LIST;
public static ﬁnal AccessibleRole PANEL;
public static ﬁnal AccessibleRole PASSWORD_TEXT;
public static ﬁnal AccessibleRole POPUP_MENU;
public static ﬁnal AccessibleRole PROGRESS_BAR;
public static ﬁnal AccessibleRole PUSH_BUTTON;
public static ﬁnal AccessibleRole RADIO_BUTTON;
public static ﬁnal AccessibleRole ROOT_PANE;
public static ﬁnal AccessibleRole RO W_HEADER;
public static ﬁnal AccessibleRole SCROLL_BAR;
public static ﬁnal AccessibleRole SCROLL_PANE;
public static ﬁnal AccessibleRole SEPARATOR;
public static ﬁnal AccessibleRole SLIDER;
public static ﬁnal AccessibleRole SPLIT_PANE;
public static ﬁnal AccessibleRole SWING_COMPONENT;
javax.accessibility.AccessibleResour ceBundle
394 Chapter 22 – The javax.accessibility Package

public static ﬁnal AccessibleRole TABLE;
public static ﬁnal AccessibleRole TEXT;
public static ﬁnal AccessibleRole TOGGLE_BUTTON;
public static ﬁnal AccessibleRole TOOL_BAR;
public static ﬁnal AccessibleRole TOOL_TIP;
public static ﬁnal AccessibleRole TREE;
public static ﬁnal AccessibleRole UNKNOWN;
public static ﬁnal AccessibleRole VIEWPORT;
public static ﬁnal AccessibleRole WINDOW;
}
Hierar chy: Object→AccessibleBundle→AccessibleRole
Retur ned By: Too many methods to list.
Type Of: Too many fields to list.
AccessibleSelection
Ja va 1.2
javax.accessibility
This interface allows an assistive technology to query and set the selection state of an
accessible object that allows selection of items that are themselves accessible objects.
An accessible object with selectable children should retur n an AccessibleSelection object
fr om the getAccessibleSelection() method of its AccessibleContext. It should also be sure to
implement Accessible objects to repr esent each of the selectable children. As an exam-
ple, note that JTextComponent allows text to be selected, but this is not a selectable child,
so it does not support the AccessibleSelection inter face. On the other hand, JList allows
selection of discrete child list items. It supports the AccessibleSelection inter face and
deﬁnes the JList.AccessibleJList.AccessibleJListChild to provide accessibility support for the
individual items in the list. Applications never need to use or implement this interface.
public abstract interface AccessibleSelection {
// Public Instance Methods
public abstract void addAccessibleSelection(int i);
public abstract void clearAccessibleSelection();
public abstract Accessible getAccessibleSelection(int i);
public abstract int getAccessibleSelectionCount();
public abstract boolean isAccessibleChildSelected(int i);
public abstract void removeAccessibleSelection(int i);
public abstract void selectAllAccessibleSelection();
}
Implementations: javax.swing .JList.AccessibleJList, javax.swing .JMenu.AccessibleJMenu,
javax.swing .JMenuBar.AccessibleJMenuBar, javax.swing .JTabbedPane.AccessibleJTabbedPane,
javax.swing .JTable.AccessibleJTable, javax.swing .JTree.AccessibleJTree,
javax.swing .JTree.AccessibleJTree.AccessibleJTreeNode
Retur ned By: AccessibleContext.getAccessibleSelection(),
javax.swing .JList.AccessibleJList.getAccessibleSelection(),
javax.swing .JList.AccessibleJList.AccessibleJListChild.getAccessibleSelection(),
javax.swing .JMenu.AccessibleJMenu.getAccessibleSelection(),
javax.swing .JMenuBar.AccessibleJMenuBar.getAccessibleSelection(),
javax.swing .JTabbedPane.AccessibleJTabbedPane.getAccessibleSelection(),
javax.swing .JTable.AccessibleJTable.getAccessibleSelection(),
javax.swing .JTable.AccessibleJTable.AccessibleJTableCell.getAccessibleSelection(),
javax.swing .JTree.AccessibleJTree.getAccessibleSelection(),
javax.swing .JTree.AccessibleJTree.AccessibleJTreeNode.getAccessibleSelection(),
javax.swing .table.JTableHeader.AccessibleJTableHeader.AccessibleJTableHeaderEntr y.getAccessibleSelection()
javax.
accessibility
javax.accessibility.AccessibleSelection
Chapter 22 – The javax.accessibility Package
395

AccessibleState
Ja va 1.2
javax.accessibility
This class exists to provide a type-safe enumeration of constants that describe the vari-
ous states that accessible components may exist in. AccessibleState objects are aggr e-
gated into AccessibleStateSet objects, which are retur ned by the getAccessibleStateSet()
method of an AccessibleContext. Every accessible object that is capable of existing in
mor e than one state should retur n an appropriate set of AccessibleState constants from its
AccessibleContext object. AccessibleState inherits toDisplayString() fr om it superclass. This
method retur ns a localized human-readable string describing the role. Applications
never need to use this class.
public class AccessibleState extends AccessibleBundle {
// Protected Constructors
protected AccessibleState(String key);
// Public Constants
public static ﬁnal AccessibleState ACTIVE;
public static ﬁnal AccessibleState ARMED;
public static ﬁnal AccessibleState BUSY;
public static ﬁnal AccessibleState CHECKED;
public static ﬁnal AccessibleState COLLAPSED;
public static ﬁnal AccessibleState EDITABLE;
public static ﬁnal AccessibleState ENABLED;
public static ﬁnal AccessibleState EXPANDABLE;
public static ﬁnal AccessibleState EXPANDED;
public static ﬁnal AccessibleState FOCUSABLE;
public static ﬁnal AccessibleState FOCUSED;
public static ﬁnal AccessibleState HORIZONTAL;
public static ﬁnal AccessibleState ICONIFIED;
public static ﬁnal AccessibleState MODAL;
public static ﬁnal AccessibleState MULTI_LINE;
public static ﬁnal AccessibleState MULTISELECTABLE;
public static ﬁnal AccessibleState OPAQUE;
public static ﬁnal AccessibleState PRESSED;
public static ﬁnal AccessibleState RESIZABLE;
public static ﬁnal AccessibleState SELECTABLE;
public static ﬁnal AccessibleState SELECTED;
public static ﬁnal AccessibleState SHOWING;
public static ﬁnal AccessibleState SINGLE_LINE;
public static ﬁnal AccessibleState TRANSIENT;
public static ﬁnal AccessibleState VERTICAL;
public static ﬁnal AccessibleState VISIBLE;
}
Hierar chy: Object→AccessibleBundle→AccessibleState
Passed To: AccessibleStateSet.{AccessibleStateSet(), add(), addAll(), contains(), remove()}
Retur ned By: AccessibleStateSet.toAr ray()
Type Of: Too many fields to list.
AccessibleStateSet
Ja va 1.2
javax.accessibility
This class maintains a list of AccessibleState objects. Every accessible object that can exist
in more than one state should retur n an appropriate AccessibleStateSet describing its cur-
rent state from the getAccessibleStateSet() method of its AccessibleContext. Applications
never need to use this class.
javax.accessibility.AccessibleState
396 Chapter 22 – The javax.accessibility Package

public class AccessibleStateSet {
// Public Constructors
public AccessibleStateSet();
public AccessibleStateSet(AccessibleState[ ] states);
// Public Instance Methods
public boolean add(AccessibleState state);
public void addAll(AccessibleState[ ] states);
public void clear();
public boolean contains(AccessibleState state);
public boolean remove(AccessibleState state);
public AccessibleState[ ] toAr ray();
// Public Methods Overriding Object
public String toString();
// Protected Instance Fields
protected java.util.Vector states;
}
Retur ned By: Too many methods to list.
AccessibleText
Ja va 1.2
javax.accessibility
This interface allows an assistive technology to query the textual contents, textual selec-
tion, and text-insertion positions of an accessible object that contains nonstatic text. An
accessible object that contains nonstatic text should retur n an AccessibleText object from
the getAccessibleText() method of its AccessibleContext. Note that components such as JBut-
ton and JLabel do not support this interface. They display only static text, and their con-
tents are adequately described by the getAccessibleName() and getAccessibleDescription()
methods of the AccessibleContext. Applications never need to use or implement this inter-
face.
public abstract interface AccessibleText {
// Public Constants
=1
public static ﬁnal int CHARACTER;
=3
public static ﬁnal int SENTENCE;
=2
public static ﬁnal int WORD;
// Property Accessor Methods (by property name)
public abstract int getCaretPosition();
public abstract int getCharCount();
public abstract String getSelectedText();
public abstract int getSelectionEnd();
public abstract int getSelectionStar t();
// Public Instance Methods
public abstract String getAfterIndex(int par t, int index);
public abstract String getAtIndex(int par t, int index);
public abstract String getBeforeIndex(int par t, int index);
public abstract javax.swing.text.AttributeSet getCharacterAttribute(int i);
public abstract java.awt.Rectangle getCharacterBounds(int i);
public abstract int getIndexAtPoint(java.awt.Point p);
}
Implementations: AccessibleHyper text, javax.swing .text.JTextComponent.AccessibleJTextComponent
Retur ned By: AccessibleContext.getAccessibleText(),
javax.swing .JEditorPane.AccessibleJEditorPaneHTML.getAccessibleText(),
javax.swing .JList.AccessibleJList.AccessibleJListChild.getAccessibleText(),
javax.swing .JTable.AccessibleJTable.AccessibleJTableCell.getAccessibleText(),
javax.
accessibility
javax.accessibility.AccessibleText
Chapter 22 – The javax.accessibility Package
397

javax.swing .JTree.AccessibleJTree.AccessibleJTreeNode.getAccessibleText(),
javax.swing .table.JTableHeader.AccessibleJTableHeader.AccessibleJTableHeaderEntr y.getAccessibleText(),
javax.swing .text.JTextComponent.AccessibleJTextComponent.getAccessibleText()
AccessibleValue
Ja va 1.2
javax.accessibility
This interface allows an assistive technology to set and query the numerical value dis-
played or maintained by an accessible object, such as a JScrollBar. It also allows an assis-
tive technology to query the legal range of values supported by the accessible object.
An accessible object that maintains a numerical value should retur n an AccessibleValue
object from the getAccessibleValue() method of its AccessibleContext. Applications never
need to use or implement this interface.
public abstract interface AccessibleValue {
// Public Instance Methods
public abstract Number getCur rentAccessibleValue();
public abstract Number getMaximumAccessibleValue();
public abstract Number getMinimumAccessibleValue();
public abstract boolean setCur rentAccessibleValue(Number n);
}
Implementations: javax.swing .AbstractButton.AccessibleAbstractButton,
javax.swing .JInternalFrame.AccessibleJInter nalFrame,
javax.swing .JInternalFrame.JDesktopIcon.AccessibleJDesktopIcon,
javax.swing .JProgressBar.AccessibleJProgressBar, javax.swing .JScrollBar.AccessibleJScrollBar,
javax.swing .JSlider.AccessibleJSlider, javax.swing .JSplitPane.AccessibleJSplitPane
Retur ned By: AccessibleContext.getAccessibleValue(),
javax.swing .AbstractButton.AccessibleAbstractButton.getAccessibleValue(),
javax.swing .JInternalFrame.AccessibleJInter nalFrame.getAccessibleValue(),
javax.swing .JInternalFrame.JDesktopIcon.AccessibleJDesktopIcon.getAccessibleValue(),
javax.swing .JList.AccessibleJList.AccessibleJListChild.getAccessibleValue(),
javax.swing .JProgressBar.AccessibleJProgressBar.getAccessibleValue(),
javax.swing .JScrollBar.AccessibleJScrollBar.getAccessibleValue(),
javax.swing .JSlider.AccessibleJSlider.getAccessibleValue(),
javax.swing .JSplitPane.AccessibleJSplitPane.getAccessibleValue(),
javax.swing .JTable.AccessibleJTable.AccessibleJTableCell.getAccessibleValue(),
javax.swing .JTree.AccessibleJTree.AccessibleJTreeNode.getAccessibleValue(),
javax.swing .table.JTableHeader.AccessibleJTableHeader.AccessibleJTableHeaderEntr y.getAccessibleValue()
javax.accessibility.AccessibleText
398 Chapter 22 – The javax.accessibility Package

CHAPTER 23
The javax.swing Package
This large package contains the most important classes and interfaces of Swing.
Swing is a core part of Java 1.2 and is also available as a standard extension to
Java 1.1. The GUI component classes are at the heart of Swing. These classes have
names that begin with the letter J. Figur e 23-1 shows the hierarchy of Swing com-
ponents in javax.swing. Note that this diagram does not show the fact that all the
Swing components implement javax.accessibility.Accessible; see the individual class
synopses for this information.
Most Swing components rely on a model object to hold their state information.
Various interfaces deﬁne the methods that these state objects must implement, and
various abstract and concrete classes implement these interfaces. These model
inter faces and classes are recognizable by the word “Model” in their names. Figure
23-2 shows the model objects and layout managers in javax.swing.
Classes with the word “Manager” in their names typically manage some important
part of the Swing user-inter face or application environment. Other important
classes and interfaces deﬁned by this package include: Action, Icon, KeyStroke, Timer,
and SwingUtilities. Figur e 23-3 shows the rest of the classes and interfaces in
javax.swing.
All Swing components are accessible, which means that they implement the
javax.accessiblity.Accessible inter face and deﬁne getAccessibleContext() methods. This
method retur ns a javax.accessibility.AccessibleContext object that provides support to
accessibility tools, such as screen readers for the vision impaired. Each accessible
component has its own speciﬁc subclass of AccessibleContext, which is typically
deﬁned as a protected inner class of the component. These AccessibleContext inner
classes have been omitted from this chapter and from Figure 23-1 because they
contain little useful information and they detract from other, mor e important
classes. Practically everything you need to know about an AccessibleContext subclass
can be found in the single-line inner class synopsis that appears in the containing
class, the accessible ﬂag of the containing class, and in Chapter 22, The
javax.accessibility Package.
javax.swing
399

CLASS
INTERFACE
ABSTRACT CLASS
KEY
extends
implements
java.io
javax.swing
java.awt.event
javax.swing.event
javax.swing.text
Box
CellRendererPane
JComponent
Dialog
JDialog
Frame
JFrame
Window
JWindow
ItemSelectable
Adjustable
AbstractButton
JColorChooser
JComboBox
JButton
JMenuItem
JToggleButton
JCheckBoxMenuItem
JMenu
JRadioButtonMenuItem
JCheckBox
JFileChooser
RootPaneContainer
Applet
JApplet
SwingConstants
ScrollPaneConstants
JInternalFrame
JLabel
JLayeredPane
JDesktopPane
JToolTip
JMenuBar
JOptionPane
JPopupMenu
JRootPane
JScrollPane
JSlider
JTabbedPane
JToolBar
JTree
JPanel
JProgressBar
JScrollBar
JSeparator
JTable
JTextComponent
JEditorPane
JTextPane
JTextArea
JTextField
JPasswordField
Container
WindowConstants
ListCellRenderer
MenuElement
ActionListener
ListDataListener
TableModelListener
TableColumnModelListener
ListSelectionListener
CellEditorListener
Serializable
java.awt
java.applet
JViewport
JList
JSplitPane
Scrollable
JRadioButton
DefaultListCellRenderer
Figur e 23−1: Components of the javax.swing package
400 Chapter 23 – The javax.swing Package

See Chapter 2, Swing and AWT Architectur e, for an overview of GUI programming
in Java, and see Chapter 3, Swing Programming Topics, for detailed explanations
of many important Swing components and capabilities.
CLASS
INTERFACE
ABSTRACT CLASS
LayoutManager2
KEY
extends
implements
AbstractListModel
DefaultComboBoxModel
java.lang
Object
javax.swing
DefaultBoundedRangeModel
DefaultButtonModel
DefaultListSelectionModel
DefaultSingleSelectionModel
java.io
Serializable
BoundedRangeModel
ListSelectionModel
SingleSelectionModel
DefaultListModel
ScrollPaneLayout
ViewportLayout
BoxLayout
OverlayLayout
java.awt
ItemSelectable
LayoutManager
ButtonModel
ScrollPaneConstants
MutableComboBoxModel
ComboBoxModel
ListModel
Cloneable
Figur e 23−2: Models and layout managers of the java.swing package
AbstractAction
Ja va 1.2
javax.swing
cloneable serializable
This class implements all the methods of the Action inter face except for the crucial
actionPerfor med() method that provides the substance of the action. Subclassing AbstractAc-
tion is one of the easiest ways to deﬁne Action objects for your application. Note the
one- and two-argument constructors. These constructors automatically deﬁne name and
icon attributes for the action and are simpler than using putValue().
public abstract class AbstractAction implements Action, Cloneable, Serializable {
// Public Constructors
public AbstractAction();
public AbstractAction(String name);
public AbstractAction(String name, Icon icon);
// Event Registration Methods (by event name)
Implements:Action synchronized
public void addProper tyChangeListener(
java.beans.Proper tyChangeListener listener);
Implements:Action synchronized
public void removeProper tyChangeListener(
java.beans.Proper tyChangeListener listener);
javax.swing
javax.swing.AbstractAction
Chapter 23 – The javax.swing Package
401

CLASS
INTERFACE
ABSTRACT CLASS
KEY
extends
implements
LookAndFeel
java.lang
Object
java.io
Serializable
javax.swing
Cloneable
AbstractAction
Action
BorderFactory
ButtonGroup
DefaultDesktopManager
FocusManager
ImageIcon
KeyStroke
MenuSelectionManager
ProgressMonitor
RepaintManager
SizeRequirements
SwingUtilities
Timer
UIManager
UnsupportedLookAndFeelException
java.awt.event
ActionListener
javax.swing.table
TableCellEditor
javax.swing.tree
TreeCellEditor
DefaultFocusManager
ComboBoxEditor
Renderer
DesktopManager
Icon
SwingConstants
java.util
java.awt
java.awt.image
UIDefaults
DebugGraphics
GrayFilter
FilterInputStream
DefaultCellEditor
Hashtable
Graphics
RGBImageFilter
Exception
ProgressMonitorInputStream
CellEditor
Figur e 23−3: Other classes and interfaces of the javax.swing package
javax.swing.AbstractAction
402 Chapter 23 – The javax.swing Package

// Methods Implementing Action
synchronized
public void addProper tyChangeListener(java.beans.Proper tyChangeListener listener);
public Object getValue(String key);
public boolean isEnabled();
synchronized
public void putValue(String key, Object newValue);
synchronized
public void removeProper tyChangeListener(java.beans.Proper tyChangeListener listener);
synchronized
public void setEnabled(boolean newValue);
// Methods Implementing ActionListener
public abstract void actionPerfor med(java.awt.e vent.ActionEvent e);
// Protected Methods Overriding Object
protected Object clone() throws CloneNotSupportedException;
// Protected Instance Methods
protected void ﬁreProper tyChange(String proper tyName, Object oldValue, Object newValue);
// Protected Instance Fields
protected javax.swing.e vent.SwingPropertyChangeSuppor t changeSuppor t;
protected boolean enabled;
}
Hierar chy: Object→AbstractAction(Action(java.awt.event.ActionListener(java.util.EventListener)),
Cloneable, Serializable)
Subc lasses: javax.swing .text.TextAction
AbstractButton
Ja va 1.2
javax.swing
serializable swing component
This class serves as the superclass for Swing components with buttonlike behavior.
Because it is a general-purpose class, it deﬁnes a large number of properties. Like
Swing labels, Swing buttons can display text and/or an icon, and several properties
specify the relative positioning of the text and icon. (See JLabel for details on these posi-
tioning properties.) Swing buttons can display differ ent icons when in differ ent states.
In addition to the default icon, AbstractButton has properties that specify icons to be dis-
played when the button is pressed, selected, disabled, disabled and selected, rolled
over, and rolled over and selected. If the rolloverIcon pr operty is speciﬁed and if the
rolloverEnabled pr operty is tr ue, the rolloverIcon is displayed when the mouse is over the
button.
By default, an AbstractButton displays a single line of text in a single font. However, as of
Swing 1.1.1 and Java 1.2.2, if the text pr operty begins with “<html>”, the button text is
for matted as HTML and may contain multiple fonts and multiple lines.
A Swing button may be enabled and disabled with setEnabled(). Disabled buttons are
typically displayed with grayed-out graphics, although some other disabled icon can
also be speciﬁed. A mnemonic can be speciﬁed with setMnemonic(). This causes the
mnemonic character to be underlined in the button’s text and allows the button to be
operated via the keyboard.
Swing buttons generate three types of events. A java.awt.event.ActionEvent is generated
when any button is pushed. A java.awt.event.ItemEvent is generated when a toggle-type
button is selected or deselected. And a javax.swing .event.ChangeEvent is generated when
the button’s internal state changes—for example, when the mouse pointer enters the
button or when the user arms the button by pressing the mouse button.
public abstract class AbstractButton extends JComponent implements java.awt.ItemSelectable, SwingConstants {
// Public Constructors
public AbstractButton();
// Public Constants
="borderPainted"
public static ﬁnal String BORDER_PAINTED_CHANGED_PROPERTY;
javax.swing
javax.swing.AbstractButton
Chapter 23 – The javax.swing Package
403

="contentAreaF illed"
public static ﬁnal String CONTENT_AREA_FILLED_CHANGED_PROPERTY;
="disabledIcon"
public static ﬁnal String DISABLED_ICON_CHANGED_PROPERTY;
="disabledSelectedIcon"
public static ﬁnal String DISABLED_SELECTED_ICON_CHANGED_PROPERTY;
="focusPainted"
public static ﬁnal String FOCUS_PAINTED_CHANGED_PROPERTY;
="horizontalAlignment"
public static ﬁnal String HORIZONTAL_ALIGNMENT_CHANGED_PROPERTY;
="horizontalTextPosition"
public static ﬁnal String HORIZONTAL_TEXT_POSITION_CHANGED_PROPERTY;
="icon"
public static ﬁnal String ICON_CHANGED_PROPERTY;
="margin"
public static ﬁnal String MARGIN_CHANGED_PROPERTY;
="mnemonic"
public static ﬁnal String MNEMONIC_CHANGED_PROPERTY;
="model"
public static ﬁnal String MODEL_CHANGED_PROPERTY;
="pressedIcon"
public static ﬁnal String PRESSED_ICON_CHANGED_PROPERTY;
="rolloverEnabled"
public static ﬁnal String ROLLOVER_ENABLED_CHANGED_PROPERTY;
="rolloverIcon"
public static ﬁnal String ROLLOVER_ICON_CHANGED_PROPERTY;
="rolloverSelectedIcon"
public static ﬁnal String ROLLOVER_SELECTED_ICON_CHANGED_PROPERTY;
="selectedIcon"
public static ﬁnal String SELECTED_ICON_CHANGED_PROPERTY;
="text"
public static ﬁnal String TEXT_CHANGED_PROPERTY;
="ver ticalAlignment"
public static ﬁnal String VERTICAL_ALIGNMENT_CHANGED_PROPERTY;
="ver ticalTextPosition"
public static ﬁnal String VERTICAL_TEXT_POSITION_CHANGED_PROPERTY;
// Inner Classes
protected abstract class AccessibleAbstractButton extends JComponent.AccessibleJComponent
implements AccessibleAction, AccessibleValue;
protected class ButtonChangeListener implements javax.swing.e vent.ChangeListener, Serializable;
// Event Registration Methods (by event name)
public void addActionListener(java.awt.e vent.ActionListener l);
public void removeActionListener(java.awt.e vent.ActionListener l);
public void addChangeListener(javax.swing .event.ChangeListener l);
public void removeChangeListener(javax.swing .event.ChangeListener l);
Implements:ItemSelectable
public void addItemListener(java.awt.e vent.ItemListener l);
Implements:ItemSelectable
public void removeItemListener(java.awt.e vent.ItemListener l);
// Property Accessor Methods (by property name)
public String getActionCommand();
public void setActionCommand(String actionCommand);
public boolean isBorderPainted();
bound
public void setBorderPainted(boolean b);
public boolean isContentAreaF illed();
bound
public void setContentAreaF illed(boolean b);
public Icon getDisabledIcon();
bound
public void setDisabledIcon(Icon disabledIcon);
public Icon getDisabledSelectedIcon();
public void setDisabledSelectedIcon(Icon disabledSelectedIcon);
public boolean isFocusPainted();
bound
public void setFocusPainted(boolean b);
public int getHorizontalAlignment();
bound
public void setHorizontalAlignment(int alignment);
public int getHorizontalTextPosition();
bound
public void setHorizontalTextPosition(int textPosition);
public Icon getIcon();
bound
public void setIcon(Icon defaultIcon);
public java.awt.Insets getMargin();
bound
public void setMargin(java.awt.Insets m);
public int getMnemonic();
bound
public void setMnemonic(int mnemonic);
public void setMnemonic(char mnemonic);
public ButtonModel getModel();
bound
public void setModel(ButtonModel newModel);
public Icon getPressedIcon();
bound
public void setPressedIcon(Icon pressedIcon);
public boolean isRolloverEnabled();
javax.swing.AbstractButton
404 Chapter 23 – The javax.swing Package

bound
public void setRolloverEnabled(boolean b);
public Icon getRolloverIcon();
bound
public void setRolloverIcon(Icon rolloverIcon);
public Icon getRolloverSelectedIcon();
bound
public void setRolloverSelectedIcon(Icon rolloverSelectedIcon);
public boolean isSelected();
public void setSelected(boolean b);
public Icon getSelectedIcon();
bound
public void setSelectedIcon(Icon selectedIcon);
Implements:ItemSelectable synchronized
public Object[ ] getSelectedObjects();
public String getText();
bound preferred
public void setText(String text);
public javax.swing.plaf.ButtonUI getUI();
public void setUI(javax.swing .plaf.ButtonUI ui);
public int getVer ticalAlignment();
bound
public void setVer ticalAlignment(int alignment);
public int getVer ticalTextPosition();
bound
public void setVer ticalTextPosition(int textPosition);
// Public Instance Methods
public void doClick();
public void doClick(int pressTime);
// Methods Implementing ItemSelectable
public void addItemListener(java.awt.e vent.ItemListener l);
synchronized
public Object[ ] getSelectedObjects();
public void removeItemListener(java.awt.e vent.ItemListener l);
// Public Methods Overriding JComponent
public void setEnabled(boolean b);
empty
public void updateUI();
// Protected Methods Overriding JComponent
protected void paintBorder(java.awt.Graphics g);
protected String paramString();
// Protected Instance Methods
protected int checkHorizontalKey(int key, String exception);
protected int checkVer ticalKey(int key, String exception);
protected java.awt.event.ActionListener createActionListener();
protected javax.swing.e vent.ChangeListener createChangeListener();
protected java.awt.event.ItemListener createItemListener();
protected void ﬁreActionPerfor med(java.awt.e vent.ActionEvent event);
protected void ﬁreItemStateChanged(java.awt.e vent.ItemEvent event);
protected void ﬁreStateChanged();
protected void init(String text, Icon icon);
// Protected Instance Fields
protected java.awt.event.ActionListener actionListener;
protected transient javax.swing.e vent.ChangeEvent changeEvent;
protected javax.swing.e vent.ChangeListener changeListener;
protected java.awt.event.ItemListener itemListener;
protected ButtonModel model;
// Deprecated Public Methods
# public String getLabel();
bound
# public void setLabel(String label);
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→JComponent(Serializable)→AbstractButton(java.awt.ItemSelectable, SwingConstants)
Subc lasses: JButton, JMenuItem, JToggleButton
Passed To: ButtonGroup.{add(), remove()}
javax.swing
javax.swing.AbstractButton
Chapter 23 – The javax.swing Package
405

AbstractButton.ButtonChangeListener
Ja va 1.2
javax.swing
serializable
This protected inner class is a simple Serializable implementation of javax.swing .-
event.ChangeListener that AbstractButton uses internally to receive change notiﬁcations from
its ButtonModel. Application-level code never needs to use this class.
protected class AbstractButton.ButtonChangeListener implements javax.swing.e vent.ChangeListener,
Serializable {
// No Constructor
// Methods Implementing ChangeListener
public void stateChanged(javax.swing .event.ChangeEvent e);
}
AbstractListModel
Ja va 1.2
javax.swing
serializable model
This abstract class provides a partial implementation of the ListModel inter face. Subclass-
ing AbstractListModel is usually easier than implementing ListModel fr om scratch. Note,
however, that the DefaultListModel class is a usually an adequate ListModel implementa-
tion, so you shouldn’t need to subclass AbstractListModel very often. Furthermor e, the JList
component provides convenience methods that often make it unnecessary to work with
any kind of ListModel at all.
public abstract class AbstractListModel implements ListModel, Serializable {
// Public Constructors
public AbstractListModel();
// Event Registration Methods (by event name)
Implements:ListModel
public void addListDataListener(javax.swing .event.ListDataListener l);
Implements:ListModel
public void removeListDataListener(javax.swing .event.ListDataListener l);
// Methods Implementing ListModel
public void addListDataListener(javax.swing .event.ListDataListener l);
public abstract Object getElementAt(int index);
public abstract int getSize();
public void removeListDataListener(javax.swing .event.ListDataListener l);
// Protected Instance Methods
protected void ﬁreContentsChanged(Object source, int index0, int index1);
protected void ﬁreInter valAdded(Object source, int index0, int index1);
protected void ﬁreInter valRemoved(Object source, int index0, int index1);
// Protected Instance Fields
protected javax.swing.e vent.EventListenerList listenerList;
}
Hierar chy: Object→AbstractListModel(ListModel, Serializable)
Subc lasses: DefaultComboBoxModel, DefaultListModel
Action
Ja va 1.2
javax.swing
event listener
An action is a single piece of application functionality, such as saving a ﬁle or printing
a document. The actions perfor med by an application may be made available to the
user in several differ ent ways: in a pulldown or popup menu, in a toolbar, and from a
keyboard binding, for example.
The Action inter face extends java.awt.event.ActionListener and adds the ability to enable or
disable the action. If an editor contains an empty document, its print action probably
should not be enabled, for example. setEnabled() speciﬁes whether the action is
javax.swing.AbstractButton.ButtonChangeListener
406 Chapter 23 – The javax.swing Package

enabled. When an action is enabled or disabled, this change is broadcast by a
java.beans.Proper tyChangeEvent.
The Action inter face also deﬁnes methods that associate attributes with an action. The
putValue() method maps an arbitrary attribute name to an arbitrary attribute value. The
getValue() method queries an attribute value. The constants deﬁned by the Action inter-
face specify predeﬁned names for commonly used attributes. NAME and SMALL_ICON ar e
the most commonly used. Finally, the actionPerfor med() method, inherited from ActionLis-
tener, is responsible for perfor ming the action.
JMenu, JPopupMenu, and JToolBar deﬁne methods that allow Action objects to be added to
them. These methods query the action for its name and an icon that repr esents the
action and use this information to present the action to the user. If the action is
enabled, the component allows the user to invoke it. The JTextComponent and Keymap
classes from the javax.swing .text package additionally provide techniques for mapping
keystr okes to Action objects.
AbstractAction pr ovides a useful starting point for deﬁning your own Action classes.
public abstract interface Action extends java.awt.event.ActionListener {
// Public Constants
="Default"
public static ﬁnal String DEFAULT;
="LongDescription"
public static ﬁnal String LONG_DESCRIPTION;
="Name"
public static ﬁnal String NAME;
="Shor tDescription"
public static ﬁnal String SHORT_DESCRIPTION;
="SmallIcon"
public static ﬁnal String SMALL_ICON;
// Event Registration Methods (by event name)
public abstract void addProper tyChangeListener(java.beans.Proper tyChangeListener listener);
public abstract void removeProper tyChangeListener(java.beans.Proper tyChangeListener listener);
// Public Instance Methods
public abstract Object getValue(String key);
public abstract boolean isEnabled();
public abstract void putValue(String key, Object value);
public abstract void setEnabled(boolean b);
}
Hierar chy: (Action(java.awt.event.ActionListener(java.util.EventListener)))
Implementations: AbstractAction
Passed To: JMenu.{add(), insert()}, JPopupMenu.{add(), insert()}, JToolBar.add(),
javax.swing .text.JTextComponent.loadKeymap(), javax.swing .text.Keymap.{addActionForKeyStroke(),
getKeyStrokesForAction(), setDefaultAction()}, javax.swing .text.TextAction.augmentList()
Retur ned By: JTextF ield.getActions(), javax.swing .text.DefaultEditorKit.getActions(),
javax.swing .text.EditorKit.getActions(), javax.swing .text.JTextComponent.getActions(),
javax.swing .text.Keymap.{getAction(), getBoundActions(), getDefaultAction()},
javax.swing .text.StyledEditorKit.getActions(), javax.swing .text.TextAction.augmentList(),
javax.swing .text.html.HTMLEditorKit.getActions()
BorderFactor y
Ja va 1.2
javax.swing
The static methods of this class retur n various types of Border objects. These methods
may retur n pr eviously cr eated shar ed objects, making their use more memory-ef ﬁcient
than creating unshared Border objects with the new operator. See the various classes of
the javax.swing .border package for more infor mation on the types of borders supported by
Swing.
javax.swing
javax.swing.BorderFactor y
Chapter 23 – The javax.swing Package
407

public class BorderFactor y {
// No Constructor
// Public Class Methods
public static javax.swing.border.Border createBevelBorder(int type);
public static javax.swing.border.Border createBevelBorder(int type, java.awt.Color highlight,
java.awt.Color shadow);
public static javax.swing.border.Border createBevelBorder(int type, java.awt.Color highlightOuter,
java.awt.Color highlightInner,
java.awt.Color shadowOuter,
java.awt.Color shadowInner);
public static javax.swing.border.CompoundBorder createCompoundBorder();
public static javax.swing.border.CompoundBorder createCompoundBorder(
javax.swing .border.Border outsideBorder,
javax.swing .border.Border insideBorder);
public static javax.swing.border.Border createEmptyBorder();
public static javax.swing.border.Border createEmptyBorder(int top, int left, int bottom, int right);
public static javax.swing.border.Border createEtchedBorder();
public static javax.swing.border.Border createEtchedBorder(java.awt.Color highlight, java.awt.Color shadow);
public static javax.swing.border.Border createLineBorder(java.awt.Color color);
public static javax.swing.border.Border createLineBorder(java.awt.Color color, int thickness);
public static javax.swing.border.Border createLoweredBevelBorder();
public static javax.swing.border.MatteBorder createMatteBorder(int top, int left, int bottom, int right,
Icon tileIcon);
public static javax.swing.border.MatteBorder createMatteBorder(int top, int left, int bottom, int right,
java.awt.Color color);
public static javax.swing.border.Border createRaisedBevelBorder();
public static javax.swing.border.T itledBorder createT itledBorder(javax.swing .border.Border border);
public static javax.swing.border.T itledBorder createT itledBorder(String title);
public static javax.swing.border.T itledBorder createT itledBorder(javax.swing .border.Border border, String title);
public static javax.swing.border.T itledBorder createT itledBorder(javax.swing .border.Border border, String title,
int titleJustiﬁcation, int titlePosition);
public static javax.swing.border.T itledBorder createT itledBorder(javax.swing .border.Border border, String title,
int titleJustiﬁcation, int titlePosition,
java.awt.Font titleFont);
public static javax.swing.border.T itledBorder createT itledBorder(javax.swing .border.Border border, String title,
int titleJustiﬁcation, int titlePosition,
java.awt.Font titleFont, java.awt.Color titleColor);
}
BoundedRangeModel
Ja va 1.2
javax.swing
model
This interface deﬁnes the data model used by the JScrollBar, JSlider, and JProgressBar com-
ponents. The model is deﬁned by four integer properties that obey the following rela-
tionship:
minimum <= value <= value+extent <= maximum
The value pr operty speciﬁes the value currently displayed by the component. It must be
between the values speciﬁed by the minimum and maximum pr operties. The extent pr op-
erty speciﬁes the amount of data displayed. For JScrollBar components, this property
speciﬁes the size of the scrollbar thumb, or knob. Note the convenience method
setRangeProper ties() that sets all properties of the model at once.
When 
any 
value 
changes, 
interested 
listeners 
are
notiﬁed 
with 
a
javax.swing .event.ChangeEvent. One additional property deﬁned by this interface is valueIsAd-
justing. If this property is tr ue, it means that a series of rapid property changes (such as
those caused when the user drags the scrollbar) is in progr ess. This property is false for
javax.swing.BorderFactor y
408 Chapter 23 – The javax.swing Package

the last change in the series, so listeners can therefor e choose to ignore transient
changes that have this property set to tr ue.
DefaultBoundedRangeModel is an implementation of this interface appropriate for most
uses.
public abstract interface BoundedRangeModel {
// Event Registration Methods (by event name)
public abstract void addChangeListener(javax.swing .event.ChangeListener x);
public abstract void removeChangeListener(javax.swing .event.ChangeListener x);
// Property Accessor Methods (by property name)
public abstract int getExtent();
public abstract void setExtent(int newExtent);
public abstract int getMaximum();
public abstract void setMaximum(int newMaximum);
public abstract int getMinimum();
public abstract void setMinimum(int newMinimum);
public abstract int getValue();
public abstract void setValue(int newValue);
public abstract boolean getValueIsAdjusting();
public abstract void setValueIsAdjusting(boolean b);
// Public Instance Methods
public abstract void setRangeProper ties(int value, int extent, int min, int max, boolean adjusting);
}
Implementations: DefaultBoundedRangeModel
Passed To: JProgressBar.{JProgressBar(), setModel()}, JScrollBar.setModel(), JSlider.{JSlider(), setModel()}
Retur ned By: JProgressBar.getModel(), JScrollBar.getModel(), JSlider.getModel(),
JTextF ield.getHorizontalV isibility()
Type Of: JProgressBar.model, JScrollBar.model, JSlider.sliderModel
Box
Ja va 1.2
javax.swing
serializable accessible swing component
This class is a container that uses the BoxLayout layout manager to arrange its children in
a row or a column. Pass one of the constants BoxLayout.X_AXIS or BoxLayout.Y_AXIS to the
constructor to create a horizontal or vertical box or use the static methods createHorizon-
talBox() and createVer ticalBox(). A horizontal box attempts to lay out its children from left
to right, one next to the other, at their preferr ed widths and tries to make each child as
tall as the tallest child. A vertical box does the opposite: it lays out its children from top
to bottom, trying both to maintain the preferr ed height of each child and to make all
childr en as wide as the widest child.
The arrangement of children in a Box is often improved with the use of struts and glue:
invisible components that exist only to improve the appearance of a layout. A horizon-
tal strut has 0 height and has a speciﬁed value as its minimum, preferr ed, and maxi-
mum width. A vertical strut has 0 width and a ﬁxed height. Struts are useful for
inserting ﬁxed amounts of space between components in a Box. Use createHorizontalStr ut()
and createVer ticalStr ut() to create struts.
Glue is a component with a preferr ed width or height of 0 but with an inﬁnite maxi-
mum width or height. Glue is used to specify where extra space in a layout should go.
For example, if you have three ﬁxed-sized JButton components in a row that is wider
than the sum of the button widths, placing glue between them forces them to be
evenly spaced. Use createHorizontalGlue() and createVer ticalGlue() to create glue compo-
nents.
javax.swing
javax.swing.Box
Chapter 23 – The javax.swing Package
409

public class Box extends Container implements Accessible {
// Public Constructors
public Box(int axis);
// Inner Classes
protected class AccessibleBox extends AccessibleContext implements AccessibleComponent, Serializable;
public static class Filler extends Component implements Accessible;
// Public Class Methods
public static Component createGlue();
public static Box createHorizontalBox();
public static Component createHorizontalGlue();
public static Component createHorizontalStr ut(int width);
public static Component createRigidArea(java.awt.Dimension d);
public static Box createVer ticalBox();
public static Component createVer ticalGlue();
public static Component createVer ticalStr ut(int height);
// Property Accessor Methods (by property name)
Implements:Accessible
public AccessibleContext getAccessibleContext();
Overrides:Container
public void setLayout(java.awt.LayoutManager l);
// Methods Implementing Accessible
public AccessibleContext getAccessibleContext();
// Protected Instance Fields
protected AccessibleContext accessibleContext;
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→Box(Accessible)
Retur ned By: Box.{createHorizontalBox(), createVer ticalBox()}
Box.F iller
Ja va 1.2
javax.swing
serializable accessible swing component
This class implements the invisible component used to create struts and glue for use
with the Box container. It allows you to create an invisible component with any speci-
ﬁed minimum, preferr ed, and maximum sizes.
public static class Box.F iller extends Component implements Accessible {
// Public Constructors
public Filler(java.awt.Dimension min, java.awt.Dimension pref, java.awt.Dimension max);
// Inner Classes
protected class AccessibleBoxF iller extends AccessibleContext implements AccessibleComponent, Serializable;
// Property Accessor Methods (by property name)
Implements:Accessible
public AccessibleContext getAccessibleContext();
Overrides:Component
public java.awt.Dimension getMaximumSize();
Overrides:Component
public java.awt.Dimension getMinimumSize();
Overrides:Component
public java.awt.Dimension getPrefer redSize();
// Public Instance Methods
public void changeShape(java.awt.Dimension min, java.awt.Dimension pref, java.awt.Dimension max);
// Methods Implementing Accessible
public AccessibleContext getAccessibleContext();
// Protected Instance Fields
protected AccessibleContext accessibleContext;
}
BoxLayout
Ja va 1.2
javax.swing
serializable layout manager
This class is a layout manager that arranges its children into a row or a column. It is the
layout manager used by the Box container. See Box for details.
javax.swing.Box
410 Chapter 23 – The javax.swing Package

public class BoxLayout implements java.awt.LayoutManager2, Serializable {
// Public Constructors
public BoxLayout(Container target, int axis);
// Public Constants
=0
public static ﬁnal int X_AXIS;
=1
public static ﬁnal int Y_AXIS;
// Methods Implementing LayoutManager
empty
public void addLayoutComponent(String name, Component comp);
public void layoutContainer(Container target);
public java.awt.Dimension minimumLayoutSize(Container target);
public java.awt.Dimension prefer redLayoutSize(Container target);
empty
public void removeLayoutComponent(Component comp);
// Methods Implementing LayoutManager2
empty
public void addLayoutComponent(Component comp, Object constraints);
public ﬂoat getLayoutAlignmentX(Container target);
public ﬂoat getLayoutAlignmentY(Container target);
public void invalidateLayout(Container target);
public java.awt.Dimension maximumLayoutSize(Container target);
}
Hierar chy: Object→BoxLayout(java.awt.LayoutManager2(java.awt.LayoutManager), Serializable)
ButtonGroup
Ja va 1.2
javax.swing
serializable
This class enforces mutual exclusion (radio behavior) for a group of toggle buttons.
Once buttons are added to a ButtonGroup with the add() method, mutual exclusion is
automatic, and no further action is necessary.
public class ButtonGroup implements Serializable {
// Public Constructors
public ButtonGroup();
// Property Accessor Methods (by property name)
public java.util.Enumeration getElements();
default:null
public ButtonModel getSelection();
// Public Instance Methods
public void add(AbstractButton b);
public boolean isSelected(ButtonModel m);
public void remove(AbstractButton b);
public void setSelected(ButtonModel m, boolean b);
// Protected Instance Fields
protected java.util.Vector buttons;
}
Hierar chy: Object→ButtonGroup(Serializable)
Passed To: ButtonModel.setGroup(), DefaultButtonModel.setGroup()
Type Of: DefaultButtonModel.group
ButtonModel
Ja va 1.2
javax.swing
model
This interface deﬁnes the model for Swing buttons. This model consists of ﬁve boolean
pr operties that specify the current selection state of the button and three other proper-
ties that specify an optional mnemonic, ButtonGroup, and action command (a string
passed with a java.awt.event.ActionEvent) for the button.
javax.swing
javax.swing.ButtonModel
Chapter 23 – The javax.swing Package
411

public abstract interface ButtonModel extends java.awt.ItemSelectable {
// Event Registration Methods (by event name)
public abstract void addActionListener(java.awt.e vent.ActionListener l);
public abstract void removeActionListener(java.awt.e vent.ActionListener l);
public abstract void addChangeListener(javax.swing .event.ChangeListener l);
public abstract void removeChangeListener(javax.swing .event.ChangeListener l);
public abstract void addItemListener(java.awt.e vent.ItemListener l);
public abstract void removeItemListener(java.awt.e vent.ItemListener l);
// Property Accessor Methods (by property name)
public abstract String getActionCommand();
public abstract void setActionCommand(String s);
public abstract boolean isAr med();
public abstract void setAr med(boolean b);
public abstract boolean isEnabled();
public abstract void setEnabled(boolean b);
public abstract int getMnemonic();
public abstract void setMnemonic(int key);
public abstract boolean isPressed();
public abstract void setPressed(boolean b);
public abstract boolean isRollover();
public abstract void setRollover(boolean b);
public abstract boolean isSelected();
public abstract void setSelected(boolean b);
// Public Instance Methods
public abstract void setGroup(ButtonGroup group);
}
Hierar chy: (ButtonModel(java.awt.ItemSelectable))
Implementations: DefaultButtonModel
Passed To: AbstractButton.setModel(), ButtonGroup.{isSelected(), setSelected()}, JMenu.setModel()
Retur ned By: AbstractButton.getModel(), ButtonGroup.getSelection()
Type Of: AbstractButton.model
CellEditor
Ja va 1.2
javax.swing
This interface deﬁnes general methods that must be implemented by any cell editor
object. isCellEditable() should retur n tr ue if the cell is editable and if the speciﬁed event is
an appropriate event to trigger an edit. (For example, some programs might requir e a
double-click to edit a cell.) shouldSelectCell() should retur n tr ue if the given event should
cause the cell to become selected or false otherwise. However, this is only a minor sec-
ondary purpose of the method. Despite its name, the primary purpose of shouldSelect-
Cell() is to cause the cell editor to begin editing the cell. The editor can use the
speciﬁed event to set the initial state (e.g., cursor position) of the editor.
getCellEditorValue() retur ns the value being edited. cancelCellEditing() cancels an edit. stop-
CellEditing() instructs the editor to stop editing and accept a partially edited value. An
editor may retur n false if it cannot accept the current value (because the partial value is
not valid, for example). If the editor stops or cancels editing itself, it sends a
javax.swing .event.ChangeEvent to any register ed javax.swing .event.CellEditorListener objects.
javax.swing .table.TableCellEditor and javax.swing .tree.TreeCellEditor ar e table- and tree-speciﬁc
cell editor interfaces; DefaultCellEditor is an implementation of both those interfaces.
javax.swing.ButtonModel
412 Chapter 23 – The javax.swing Package

public abstract interface CellEditor {
// Event Registration Methods (by event name)
public abstract void addCellEditorListener(javax.swing .event.CellEditorListener l);
public abstract void removeCellEditorListener(javax.swing .event.CellEditorListener l);
// Public Instance Methods
public abstract void cancelCellEditing();
public abstract Object getCellEditorValue();
public abstract boolean isCellEditable(java.util.EventObject anEvent);
public abstract boolean shouldSelectCell(java.util.EventObject anEvent);
public abstract boolean stopCellEditing();
}
Implementations: javax.swing .table.TableCellEditor, javax.swing .tree.TreeCellEditor
CellRendererPane
Ja va 1.2
javax.swing
serializable accessible swing component
This class is used by Swing components that rely on cell render er inter faces, such as
ListCellRenderer,
javax.swing .table.TableCellRenderer,
and
javax.swing .tree.TreeCellRenderer.
The
methods of this class are used to paint a single cell render er component at various
speciﬁed locations within a container.
public class CellRendererPane extends Container implements Accessible {
// Public Constructors
public CellRendererPane();
// Inner Classes
protected class AccessibleCellRendererPane extends AccessibleContext implements AccessibleComponent,
Serializable;
// Property Accessor Methods (by property name)
Implements:Accessible default:AccessibleCellRendererPane
public AccessibleContext getAccessibleContext();
// Public Instance Methods
public void paintComponent(java.awt.Graphics g, Component c, Container p, java.awt.Rectangle r);
public void paintComponent(java.awt.Graphics g, Component c, Container p, int x, int y, int w, int h);
public void paintComponent(java.awt.Graphics g, Component c, Container p, int x, int y, int w, int h,
boolean shouldValidate);
// Methods Implementing Accessible
default:AccessibleCellRendererPane
public AccessibleContext getAccessibleContext();
// Public Methods Overriding Container
empty
public void invalidate();
empty
public void paint(java.awt.Graphics g);
empty
public void update(java.awt.Graphics g);
// Protected Methods Overriding Container
protected void addImpl(Component x, Object constraints, int index);
// Protected Instance Fields
protected AccessibleContext accessibleContext;
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→CellRendererPane(Accessible)
ComboBoxEditor
Ja va 1.2
javax.swing
This interface deﬁnes the methods that must be implemented by an object that wishes
to serve as the editor object for a JComboBox component. It is typically implemented as
part of a pluggable look-and-feel and is not normally used by application programmers.
javax.swing
javax.swing.ComboBoxEditor
Chapter 23 – The javax.swing Package
413

public abstract interface ComboBoxEditor {
// Event Registration Methods (by event name)
public abstract void addActionListener(java.awt.e vent.ActionListener l);
public abstract void removeActionListener(java.awt.e vent.ActionListener l);
// Public Instance Methods
public abstract Component getEditorComponent();
public abstract Object getItem();
public abstract void selectAll();
public abstract void setItem(Object anObject);
}
Passed To: JComboBox.{configureEditor(), setEditor()}
Retur ned By: JComboBox.getEditor()
Type Of: JComboBox.editor
ComboBoxModel
Ja va 1.2
javax.swing
model
This interface deﬁnes the basic model used by the JComboBox component. The JCom-
boBox allows the user to select a value from a list or type a value directly. Therefor e,
ComboBoxModel extends ListModel to add support for a selected item, in addition to the
list of items that ListModel alr eady supports. See also MutableComboBoxModel and Default-
ComboBoxModel.
public abstract interface ComboBoxModel extends ListModel {
// Public Instance Methods
public abstract Object getSelectedItem();
public abstract void setSelectedItem(Object anItem);
}
Hierar chy: (ComboBoxModel(ListModel))
Implementations: MutableComboBoxModel
Passed To: JComboBox.{JComboBox(), setModel()}, JComboBox.KeySelectionManager.selectionForKey()
Retur ned By: JComboBox.getModel()
Type Of: JComboBox.dataModel
DebugGraphics
Ja va 1.2
javax.swing
This subclass of java.awt.Graphics reimplements most of the methods of its superclass to
facilitate debugging of drawing operations. Instances of this class are rar ely used
dir ectly; pr ograms can enable graphics debugging by calling setDebugGraphicsOptions() on
any Swing component.
public class DebugGraphics extends java.awt.Graphics {
// Public Constructors
public DebugGraphics();
public DebugGraphics(java.awt.Graphics graphics);
public DebugGraphics(java.awt.Graphics graphics, JComponent component);
// Public Constants
=4
public static ﬁnal int BUFFERED_OPTION;
=2
public static ﬁnal int FLASH_OPTION;
=1
public static ﬁnal int LOG_OPTION;
=-1
public static ﬁnal int NONE_OPTION;
javax.swing.ComboBoxEditor
414 Chapter 23 – The javax.swing Package

// Public Class Methods
public static java.awt.Color ﬂashColor();
public static int ﬂashCount();
public static int ﬂashT ime();
public static java.io.PrintStream logStream();
public static void setFlashColor(java.awt.Color ﬂashColor);
public static void setFlashCount(int ﬂashCount);
public static void setFlashT ime(int ﬂashTime);
public static void setLogStream(java.io.PrintStream stream);
// Property Accessor Methods (by property name)
Overrides:Graphics
public java.awt.Shape getClip();
Overrides:Graphics
public void setClip(java.awt.Shape clip);
Overrides:Graphics
public void setClip(int x, int y, int width, int height);
Overrides:Graphics
public java.awt.Rectangle getClipBounds();
Overrides:Graphics
public java.awt.Color getColor();
Overrides:Graphics
public void setColor(java.awt.Color aColor);
default:0
public int getDebugOptions();
public void setDebugOptions(int options);
default:false
public boolean isDrawingBuffer();
Overrides:Graphics
public java.awt.Font getFont();
Overrides:Graphics
public void setFont(java.awt.Font aFont);
Overrides:Graphics
public java.awt.FontMetrics getFontMetrics();
Overrides:Graphics
public java.awt.FontMetrics getFontMetrics(java.awt.Font f);
// Public Methods Overriding Graphics
public void clearRect(int x, int y, int width, int height);
public void clipRect(int x, int y, int width, int height);
public void copyArea(int x, int y, int width, int height, int destX, int destY);
public java.awt.Graphics create();
public java.awt.Graphics create(int x, int y, int width, int height);
public void dispose();
public void draw3DRect(int x, int y, int width, int height, boolean raised);
public void drawArc(int x, int y, int width, int height, int star tAngle, int arcAngle);
public void drawBytes(byte[ ] data, int offset, int length, int x, int y);
public void drawChars(char[ ] data, int offset, int length, int x, int y);
public boolean drawImage(java.awt.Image img, int x, int y, java.awt.image.ImageObserver obser ver);
public boolean drawImage(java.awt.Image img, int x, int y, java.awt.Color bgcolor,
java.awt.image.ImageObserver obser ver);
public boolean drawImage(java.awt.Image img, int x, int y, int width, int height,
java.awt.image.ImageObserver obser ver);
public boolean drawImage(java.awt.Image img, int x, int y, int width, int height, java.awt.Color bgcolor,
java.awt.image.ImageObserver obser ver);
public boolean drawImage(java.awt.Image img, int dx1, int dy1, int dx2, int dy2, int sx1, int sy1, int sx2, int sy2,
java.awt.image.ImageObserver obser ver);
public boolean drawImage(java.awt.Image img, int dx1, int dy1, int dx2, int dy2, int sx1, int sy1, int sx2, int sy2,
java.awt.Color bgcolor, java.awt.image.ImageObserver obser ver);
public void drawLine(int x1, int y1, int x2, int y2);
public void drawOval(int x, int y, int width, int height);
public void drawPolygon(int[ ] xPoints, int[ ] yPoints, int nPoints);
public void drawPolyline(int[ ] xPoints, int[ ] yPoints, int nPoints);
public void drawRect(int x, int y, int width, int height);
public void drawRoundRect(int x, int y, int width, int height, int arcWidth, int arcHeight);
public void drawString(java.text.AttributedCharacterIterator iterator, int x, int y);
public void drawString(String aString, int x, int y);
public void ﬁll3DRect(int x, int y, int width, int height, boolean raised);
public void ﬁllArc(int x, int y, int width, int height, int star tAngle, int arcAngle);
public void ﬁllOval(int x, int y, int width, int height);
public void ﬁllPolygon(int[ ] xPoints, int[ ] yPoints, int nPoints);
public void ﬁllRect(int x, int y, int width, int height);
javax.swing
javax.swing.DebugGraphics
Chapter 23 – The javax.swing Package
415

public void ﬁllRoundRect(int x, int y, int width, int height, int arcWidth, int arcHeight);
public void setPaintMode();
public void setXORMode(java.awt.Color aColor);
public void translate(int x, int y);
}
Hierar chy: Object→java.awt.Graphics→DebugGraphics
DefaultBoundedRangeModel
Ja va 1.2
javax.swing
serializable model
This class is an implementation of the BoundedRangeModel appr opriate for most uses. See
BoundedRangeModel for details.
public class DefaultBoundedRangeModel implements BoundedRangeModel, Serializable {
// Public Constructors
public DefaultBoundedRangeModel();
public DefaultBoundedRangeModel(int value, int extent, int min, int max);
// Event Registration Methods (by event name)
Implements:BoundedRangeModel
public void addChangeListener(javax.swing .event.ChangeListener l);
Implements:BoundedRangeModel
public void removeChangeListener(javax.swing .event.ChangeListener l);
// Methods Implementing BoundedRangeModel
public void addChangeListener(javax.swing .event.ChangeListener l);
default:0
public int getExtent();
default:100
public int getMaximum();
default:0
public int getMinimum();
default:0
public int getValue();
default:false
public boolean getValueIsAdjusting();
public void removeChangeListener(javax.swing .event.ChangeListener l);
public void setExtent(int n);
public void setMaximum(int n);
public void setMinimum(int n);
public void setRangeProper ties(int newValue, int newExtent, int newMin, int newMax, boolean adjusting);
public void setValue(int n);
public void setValueIsAdjusting(boolean b);
// Public Methods Overriding Object
public String toString();
// Protected Instance Methods
protected void ﬁreStateChanged();
// Protected Instance Fields
protected transient javax.swing.e vent.ChangeEvent changeEvent;
protected javax.swing.e vent.EventListenerList listenerList;
}
Hierar chy: Object→DefaultBoundedRangeModel(BoundedRangeModel, Serializable)
DefaultButtonModel
Ja va 1.2
javax.swing
serializable model
This class is a straightforward implementation of the ButtonModel inter face that is suitable
for most uses. It is the default model for JButton and JMenuItem.
public class DefaultButtonModel implements ButtonModel, Serializable {
// Public Constructors
public DefaultButtonModel();
// Public Constants
=1
public static ﬁnal int ARMED;
=8
public static ﬁnal int ENABLED;
javax.swing.DebugGraphics
416 Chapter 23 – The javax.swing Package

=4
public static ﬁnal int PRESSED;
=16
public static ﬁnal int ROLLOVER;
=2
public static ﬁnal int SELECTED;
// Event Registration Methods (by event name)
Implements:ButtonModel
public void addActionListener(java.awt.e vent.ActionListener l);
Implements:ButtonModel
public void removeActionListener(java.awt.e vent.ActionListener l);
Implements:ButtonModel
public void addChangeListener(javax.swing .event.ChangeListener l);
Implements:ButtonModel
public void removeChangeListener(javax.swing .event.ChangeListener l);
Implements:ButtonModel
public void addItemListener(java.awt.e vent.ItemListener l);
Implements:ButtonModel
public void removeItemListener(java.awt.e vent.ItemListener l);
// Methods Implementing ButtonModel
public void addActionListener(java.awt.e vent.ActionListener l);
public void addChangeListener(javax.swing .event.ChangeListener l);
public void addItemListener(java.awt.e vent.ItemListener l);
default:null
public String getActionCommand();
default:0
public int getMnemonic();
default:false
public boolean isAr med();
default:true
public boolean isEnabled();
default:false
public boolean isPressed();
default:false
public boolean isRollover();
default:false
public boolean isSelected();
public void removeActionListener(java.awt.e vent.ActionListener l);
public void removeChangeListener(javax.swing .event.ChangeListener l);
public void removeItemListener(java.awt.e vent.ItemListener l);
public void setActionCommand(String actionCommand);
public void setAr med(boolean b);
public void setEnabled(boolean b);
public void setGroup(ButtonGroup group);
public void setMnemonic(int key);
public void setPressed(boolean b);
public void setRollover(boolean b);
public void setSelected(boolean b);
// Methods Implementing ItemSelectable
constant default:null
public Object[ ] getSelectedObjects();
// Protected Instance Methods
protected void ﬁreActionPerfor med(java.awt.e vent.ActionEvent e);
protected void ﬁreItemStateChanged(java.awt.e vent.ItemEvent e);
protected void ﬁreStateChanged();
// Protected Instance Fields
protected String actionCommand;
protected transient javax.swing.e vent.ChangeEvent changeEvent;
protected ButtonGroup group;
protected javax.swing.e vent.EventListenerList listenerList;
protected int mnemonic;
protected int stateMask;
}
Hierar chy: Object→DefaultButtonModel(ButtonModel(java.awt.ItemSelectable), Serializable)
Subc lasses: JToggleButton.ToggleButtonModel
DefaultCellEditor
Ja va 1.2
javax.swing
serializable
This class implements both the javax.swing .table.TableCellEditor and the javax.swing .tree.Tree-
CellEditor inter faces. It is the default editor class used by JTable. Instances of this class can
be created to use a speciﬁed JTextF ield, JCheckBox, or JComboBox as the editor component.
public class DefaultCellEditor implements Serializable, javax.swing.table.TableCellEditor,
javax.swing .tree.TreeCellEditor {
javax.swing
javax.swing.DefaultCellEditor
Chapter 23 – The javax.swing Package
417

// Public Constructors
public DefaultCellEditor(JComboBox comboBox);
public DefaultCellEditor(JTextF ield textF ield);
public DefaultCellEditor(JCheckBox checkBox);
// Inner Classes
protected class EditorDelegate implements java.awt.event.ActionListener, java.awt.e vent.ItemListener,
Serializable;
// Event Registration Methods (by event name)
Implements:CellEditor
public void addCellEditorListener(javax.swing .event.CellEditorListener l);
Implements:CellEditor
public void removeCellEditorListener(javax.swing .event.CellEditorListener l);
// Public Instance Methods
public int getClickCountToStar t();
public Component getComponent();
public void setClickCountToStar t(int count);
// Methods Implementing CellEditor
public void addCellEditorListener(javax.swing .event.CellEditorListener l);
public void cancelCellEditing();
public Object getCellEditorValue();
public boolean isCellEditable(java.util.EventObject anEvent);
public void removeCellEditorListener(javax.swing .event.CellEditorListener l);
public boolean shouldSelectCell(java.util.EventObject anEvent);
public boolean stopCellEditing();
// Methods Implementing TableCellEditor
public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row,
int column);
// Methods Implementing TreeCellEditor
public Component getTreeCellEditorComponent(JTree tree, Object value, boolean isSelected,
boolean expanded, boolean leaf, int row);
// Protected Instance Methods
protected void ﬁreEditingCanceled();
protected void ﬁreEditingStopped();
// Protected Instance Fields
protected transient javax.swing.e vent.ChangeEvent changeEvent;
protected int clickCountToStar t;
protected DefaultCellEditor.EditorDelegate delegate;
protected JComponent editorComponent;
protected javax.swing.e vent.EventListenerList listenerList;
}
Hierar chy: Object→DefaultCellEditor(Serializable, javax.swing .table.TableCellEditor(CellEditor),
javax.swing .tree.TreeCellEditor(CellEditor))
DefaultCellEditor.EditorDelegate
Ja va 1.2
javax.swing
serializable
This DefaultCellEditor class can use a JTextF ield, JComboBox, or JCheckBox as the cell editor
component. This protected inner class is used internally by DefaultCellEditor to encapsu-
late the differ ences between these three editor components. Application-level code
never needs to use this class.
protected class DefaultCellEditor.EditorDelegate implements java.awt.event.ActionListener,
java.awt.e vent.ItemListener, Serializable {
// Protected Constructors
protected EditorDelegate();
// Property Accessor Methods (by property name)
constant
public Object getCellEditorValue();
javax.swing.DefaultCellEditor
418 Chapter 23 – The javax.swing Package

// Public Instance Methods
empty
public void cancelCellEditing();
constant
public boolean isCellEditable(java.util.EventObject anEvent);
empty
public void setValue(Object x);
constant
public boolean star tCellEditing(java.util.EventObject anEvent);
constant
public boolean stopCellEditing();
// Methods Implementing ActionListener
public void actionPerfor med(java.awt.e vent.ActionEvent e);
// Methods Implementing ItemListener
public void itemStateChanged(java.awt.e vent.ItemEvent e);
// Protected Instance Fields
protected Object value;
}
Type Of: DefaultCellEditor.delegate
DefaultComboBoxModel
Ja va 1.2
javax.swing
serializable model
This MutableComboBoxModel implementation is the default model object used by the
JComboBox component. In addition to the methods of the MutableComboBoxModel, Com-
boBoxModel, and ListModel inter faces, DefaultComboBoxModel also implements methods to
remove all elements from the list and to ﬁnd a speciﬁed element in the list.
public class DefaultComboBoxModel extends AbstractListModel implements MutableComboBoxModel,
Serializable {
// Public Constructors
public DefaultComboBoxModel();
public DefaultComboBoxModel(Object[ ] items);
public DefaultComboBoxModel(java.util.Vector v);
// Public Instance Methods
public int getIndexOf(Object anObject);
public void removeAllElements();
// Methods Implementing ComboBoxModel
default:null
public Object getSelectedItem();
public void setSelectedItem(Object anObject);
// Methods Implementing ListModel
public Object getElementAt(int index);
default:0
public int getSize();
// Methods Implementing MutableComboBoxModel
public void addElement(Object anObject);
public void inser tElementAt(Object anObject, int index);
public void removeElement(Object anObject);
public void removeElementAt(int index);
}
Hierar chy: Object→AbstractListModel(ListModel, Serializable)→
DefaultComboBoxModel(MutableComboBoxModel(ComboBoxModel(ListModel)), Serializable)
DefaultDesktopManager
Ja va 1.2
javax.swing
serializable
This class is a simple default implementation of the DesktopManager inter face. It can be
used as a starting point for pluggable look-and-feel DesktopManager implementations. It
is also used to manage JInter nalFrame components that are not within a JDesktopPane.
Appliations typically do not need to use this class.
javax.swing
javax.swing.DefaultDesktopManager
Chapter 23 – The javax.swing Package
419

public class DefaultDesktopManager implements DesktopManager, Serializable {
// Public Constructors
public DefaultDesktopManager();
// Methods Implementing DesktopManager
public void activateFrame(JInternalFrame f);
public void beginDraggingFrame(JComponent f);
public void beginResizingFrame(JComponent f, int direction);
public void closeFrame(JInternalFrame f);
public void deactivateFrame(JInternalFrame f);
public void deiconifyFrame(JInternalFrame f);
public void dragFrame(JComponent f, int newX, int newY);
public void endDraggingFrame(JComponent f);
public void endResizingFrame(JComponent f);
public void iconifyFrame(JInternalFrame f);
public void maximizeFrame(JInternalFrame f);
public void minimizeFrame(JInternalFrame f);
public void openFrame(JInternalFrame f);
public void resizeFrame(JComponent f, int newX, int newY, int newWidth, int newHeight);
public void setBoundsForFrame(JComponent f, int newX, int newY, int newWidth, int newHeight);
// Protected Instance Methods
protected java.awt.Rectangle getBoundsForIconOf(JInternalFrame f);
protected java.awt.Rectangle getPreviousBounds(JInternalFrame f);
protected void removeIconFor(JInternalFrame f);
protected void setPreviousBounds(JInternalFrame f, java.awt.Rectangle r);
protected void setWasIcon(JInternalFrame f, Boolean value);
protected boolean wasIcon(JInternalFrame f);
}
Hierar chy: Object→DefaultDesktopManager(DesktopManager, Serializable)
DefaultFocusManager
Ja va 1.2
javax.swing
This class is the default FocusManager used by Swing components. It uses the Ta b and
Shift-Tab keys to move focus forward and backward.
public class DefaultFocusManager extends FocusManager {
// Public Constructors
public DefaultFocusManager();
// Public Instance Methods
public boolean compareTabOrder(Component a, Component b);
public Component getComponentAfter(Container aContainer, Component aComponent);
public Component getComponentBefore(Container aContainer, Component aComponent);
public Component getF irstComponent(Container aContainer);
public Component getLastComponent(Container aContainer);
// Public Methods Overriding FocusManager
public void focusNextComponent(Component aComponent);
public void focusPreviousComponent(Component aComponent);
public void processKeyEvent(Component focusedComponent, java.awt.e vent.Ke yEvent anEvent);
}
Hierar chy: Object→FocusManager→DefaultFocusManager
DefaultListCellRenderer
Ja va 1.2
javax.swing
serializable accessible swing component
This class is the default ListCellRenderer used by the JList component to render the items
of the list. This class extends JLabel and uses JLabel featur es to render list items. Since
JList uses this class by default, you should not have to instantiate or use it directly.
javax.swing.DefaultDesktopManager
420 Chapter 23 – The javax.swing Package

public class DefaultListCellRenderer extends JLabel implements ListCellRenderer, Serializable {
// Public Constructors
public DefaultListCellRenderer();
// Inner Classes
public static class UIResource extends DefaultListCellRenderer implements javax.swing.plaf.UIResource;
// Methods Implementing ListCellRenderer
public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected,
boolean cellHasFocus);
// Protected Class Fields
protected static javax.swing.border.Border noFocusBorder;
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→JComponent(Serializable)→JLabel(Accessible, SwingConstants)→
DefaultListCellRenderer(ListCellRenderer, Serializable)
Subc lasses: DefaultListCellRenderer.UIResource
DefaultListCellRenderer.UIResource
Ja va 1.2
javax.swing
serializable accessible swing component
This class is a trivial wrapper around DefaultListCellRenderer. It implements the empty
javax.swing .plaf.UIResource marker interface in order to distinguish cell render ers supplied
by a look-and-feel from cell render ers supplied by the user. Like all classes that imple-
ment UIResource, this class is used by implementors of custom look-and-feels. Applica-
tions do not need to use this class.
public static class DefaultListCellRenderer.UIResource extends DefaultListCellRenderer
implements javax.swing.plaf.UIResource {
// Public Constructors
public UIResource();
}
DefaultListModel
Ja va 1.2
javax.swing
serializable model
This class is a ListModel implementation that is based on AbstractListModel, with the addi-
tion of java.util.Vector methods for modifying the values contained in the list. This class is
suitable for most uses of the JList component, but you may on occasion want to imple-
ment a custom ListModel, probably by subclassing AbstractListModel.
public class DefaultListModel extends AbstractListModel {
// Public Constructors
public DefaultListModel();
// Property Accessor Methods (by property name)
default:true
public boolean isEmpty();
Overrides:AbstractListModel default:0
public int getSize();
public void setSize(int newSize);
// Public Instance Methods
public void add(int index, Object element);
public void addElement(Object obj);
public int capacity();
public void clear();
public boolean contains(Object elem);
public void copyInto(Object[ ] anArray);
public Object elementAt(int index);
public java.util.Enumeration elements();
javax.swing
javax.swing.DefaultListModel
Chapter 23 – The javax.swing Package
421

public void ensureCapacity(int minCapacity);
public Object ﬁrstElement();
public Object get(int index);
public int indexOf(Object elem);
public int indexOf(Object elem, int index);
public void inser tElementAt(Object obj, int index);
public Object lastElement();
public int lastIndexOf(Object elem);
public int lastIndexOf(Object elem, int index);
public Object remove(int index);
public void removeAllElements();
public boolean removeElement(Object obj);
public void removeElementAt(int index);
public void removeRange(int fromIndex, int toIndex);
public Object set(int index, Object element);
public void setElementAt(Object obj, int index);
public int size();
public Object[ ] toAr ray();
public void trimToSize();
// Public Methods Overriding AbstractListModel
public Object getElementAt(int index);
// Public Methods Overriding Object
public String toString();
}
Hierar chy: Object→AbstractListModel(ListModel, Serializable)→DefaultListModel
DefaultListSelectionModel
Ja va 1.2
javax.swing
cloneable serializable model
This class is the default implementation of the ListSelectionModel inter face. It is used by
JList and JTable components. Typical applications do not need to explicitly use this class
or the ListSelectionModel inter face.
public class DefaultListSelectionModel implements Cloneable, ListSelectionModel, Serializable {
// Public Constructors
public DefaultListSelectionModel();
// Event Registration Methods (by event name)
Implements:ListSelectionModel
public void addListSelectionListener(javax.swing .event.ListSelectionListener l);
Implements:ListSelectionModel
public void removeListSelectionListener(
javax.swing .event.ListSelectionListener l);
// Public Instance Methods
default:true
public boolean isLeadAnchorNotiﬁcationEnabled();
public void setLeadAnchorNotiﬁcationEnabled(boolean ﬂag);
// Methods Implementing ListSelectionModel
public void addListSelectionListener(javax.swing .event.ListSelectionListener l);
public void addSelectionInter val(int index0, int index1);
public void clearSelection();
default:-1
public int getAnchorSelectionIndex();
default:-1
public int getLeadSelectionIndex();
default:-1
public int getMaxSelectionIndex();
default:-1
public int getMinSelectionIndex();
default:2
public int getSelectionMode();
default:false
public boolean getValueIsAdjusting();
public void inser tIndexInterval(int index, int length, boolean before);
public boolean isSelectedIndex(int index);
default:true
public boolean isSelectionEmpty();
public void removeIndexInter val(int index0, int index1);
javax.swing.DefaultListModel
422 Chapter 23 – The javax.swing Package

public void removeListSelectionListener(javax.swing .event.ListSelectionListener l);
public void removeSelectionInter val(int index0, int index1);
public void setAnchorSelectionIndex(int anchorIndex);
public void setLeadSelectionIndex(int leadIndex);
public void setSelectionInter val(int index0, int index1);
public void setSelectionMode(int selectionMode);
public void setValueIsAdjusting(boolean isAdjusting);
// Public Methods Overriding Object
public Object clone() throws CloneNotSupportedException;
public String toString();
// Protected Instance Methods
protected void ﬁreValueChanged(boolean isAdjusting);
protected void ﬁreValueChanged(int ﬁrstIndex, int lastIndex);
protected void ﬁreValueChanged(int ﬁrstIndex, int lastIndex, boolean isAdjusting);
// Protected Instance Fields
protected boolean leadAnchorNotiﬁcationEnabled;
protected javax.swing.e vent.EventListenerList listenerList;
}
Hierar chy: Object→DefaultListSelectionModel(Cloneable, ListSelectionModel, Serializable)
Type Of: javax.swing .tree.DefaultTreeSelectionModel.listSelectionModel
DefaultSingleSelectionModel
Ja va 1.2
javax.swing
serializable model
This class is the default implementation of the SingleSelectionModel inter face. It is used by
JMenuBar, JPopupMenu, and JTabbedPane.
public class DefaultSingleSelectionModel implements Serializable, SingleSelectionModel {
// Public Constructors
public DefaultSingleSelectionModel();
// Event Registration Methods (by event name)
Implements:SingleSelectionModel
public void addChangeListener(javax.swing .event.ChangeListener l);
Implements:SingleSelectionModel
public void removeChangeListener(javax.swing .event.ChangeListener l);
// Methods Implementing SingleSelectionModel
public void addChangeListener(javax.swing .event.ChangeListener l);
public void clearSelection();
default:-1
public int getSelectedIndex();
default:false
public boolean isSelected();
public void removeChangeListener(javax.swing .event.ChangeListener l);
public void setSelectedIndex(int index);
// Protected Instance Methods
protected void ﬁreStateChanged();
// Protected Instance Fields
protected transient javax.swing.e vent.ChangeEvent changeEvent;
protected javax.swing.e vent.EventListenerList listenerList;
}
Hierar chy: Object→DefaultSingleSelectionModel(Serializable, SingleSelectionModel)
DesktopManager
Ja va 1.2
javax.swing
This interface deﬁnes the methods that must be deﬁned by a pluggable look-and-feel to
manage JInter nalFrame windows within a JDesktopPane container. Application program-
mers do not need to use this class.
javax.swing
javax.swing.DesktopManager
Chapter 23 – The javax.swing Package
423

public abstract interface DesktopManager {
// Public Instance Methods
public abstract void activateFrame(JInternalFrame f);
public abstract void beginDraggingFrame(JComponent f);
public abstract void beginResizingFrame(JComponent f, int direction);
public abstract void closeFrame(JInternalFrame f);
public abstract void deactivateFrame(JInternalFrame f);
public abstract void deiconifyFrame(JInternalFrame f);
public abstract void dragFrame(JComponent f, int newX, int newY);
public abstract void endDraggingFrame(JComponent f);
public abstract void endResizingFrame(JComponent f);
public abstract void iconifyFrame(JInternalFrame f);
public abstract void maximizeFrame(JInternalFrame f);
public abstract void minimizeFrame(JInternalFrame f);
public abstract void openFrame(JInternalFrame f);
public abstract void resizeFrame(JComponent f, int newX, int newY, int newWidth, int newHeight);
public abstract void setBoundsForFrame(JComponent f, int newX, int newY, int newWidth, int newHeight);
}
Implementations: DefaultDesktopManager
Passed To: JDesktopPane.setDesktopManager()
Retur ned By: JDesktopPane.getDesktopManager()
FocusManager
Ja va 1.2
javax.swing
This abstract class deﬁnes three instance methods that must be implemented by an
object that wants to manage keyboard focus for an application. It also deﬁnes static
methods that manipulate the installed focus manager. Applications that mix AWT com-
ponents with Swing components should call disableSwingFocusManager() to disable
Swing’s focus management and rely on the AWT focus manager. Call setCur rentManager()
to replace the current focus manager with a custom manager of your own.
public abstract class FocusManager {
// Public Constructors
public FocusManager();
// Public Constants
="FocusManagerClassName"
public static ﬁnal String FOCUS_MANAGER_CLASS_PROPERTY;
// Public Class Methods
public static void disableSwingFocusManager();
public static FocusManager getCur rentManager();
public static boolean isFocusManagerEnabled();
public static void setCur rentManager(FocusManager aFocusManager);
// Public Instance Methods
public abstract void focusNextComponent(Component aComponent);
public abstract void focusPreviousComponent(Component aComponent);
public abstract void processKeyEvent(Component focusedComponent, java.awt.e vent.Ke yEvent anEvent);
}
Subc lasses: DefaultFocusManager
Passed To: FocusManager.setCur rentManager()
Retur ned By: FocusManager.getCur rentManager()
javax.swing.DesktopManager
424 Chapter 23 – The javax.swing Package

GrayFilter
Ja va 1.2
javax.swing
cloneable
This class is a java.awt.image.ImageF ilter that converts a color image to a grayscale image,
suitable for use as an icon that repr esents a disabled action or an unavailable option. In
addition to the usual ImageF ilter methods, GrayF ilter pr ovides the static createDisabledImage()
method, which is all that most applications ever need to use. The AbstractButton and JLa-
bel classes use GrayF ilter to automatically create a grayscale version of an image, if no
disabled image is explicitly provided.
public class GrayFilter extends java.awt.image.RGBImageFilter {
// Public Constructors
public GrayFilter(boolean b, int p);
// Public Class Methods
public static java.awt.Image createDisabledImage(java.awt.Image i);
// Public Methods Overriding RGBImageF ilter
public int ﬁlterRGB(int x, int y, int rgb);
}
Hierar chy: Object→java.awt.image.ImageF ilter(Cloneable, java.awt.image.ImageConsumer)→
java.awt.image.RGBImageF ilter→GrayF ilter
Icon
Ja va 1.2
javax.swing
This interface deﬁnes the Swing notion of an icon: an object that knows how to draw a
graphic of a ﬁxed width and height at a ﬁxed location. Icons are most commonly
implemented with images; see ImageIcon.
public abstract interface Icon {
// Public Instance Methods
public abstract int getIconHeight();
public abstract int getIconW idth();
public abstract void paintIcon(Component c, java.awt.Graphics g, int x, int y);
}
Implementations: ImageIcon, javax.swing .plaf.IconUIResource
Passed To: Too many methods to list.
Retur ned By: Too many methods to list.
Type Of: JInter nalFrame.frameIcon, JOptionPane.icon, javax.swing .border.MatteBorder.tileIcon,
javax.swing .tree.DefaultTreeCellEditor.editingIcon, javax.swing .tree.DefaultTreeCellRenderer.{closedIcon,
leafIcon, openIcon}
ImageIcon
Ja va 1.2
javax.swing
serializable
This class is an implementation of the Icon inter face that uses an Image to draw the icon.
The various constructors allow the image to be speciﬁed as an Image object, as a URL,
as a ﬁle name, or as an array of binary data. Every ImageIcon can have a short textual
description that may be used for accessibility (e.g., to describe the icon to a blind user).
public class ImageIcon implements Icon, Serializable {
// Public Constructors
public ImageIcon();
public ImageIcon(java.awt.Image image);
public ImageIcon(String ﬁlename);
public ImageIcon(java.net.URL location);
javax.swing
javax.swing.ImageIcon
Chapter 23 – The javax.swing Package
425

public ImageIcon(byte[ ] imageData);
public ImageIcon(String ﬁlename, String description);
public ImageIcon(java.net.URL location, String description);
public ImageIcon(byte[ ] imageData, String description);
public ImageIcon(java.awt.Image image, String description);
// Protected Constants
protected static ﬁnal Component component;
protected static ﬁnal java.awt.MediaTracker tracker;
// Property Accessor Methods (by property name)
default:null
public String getDescription();
public void setDescription(String description);
Implements:Icon default:-1
public int getIconHeight();
Implements:Icon default:-1
public int getIconW idth();
default:null
public java.awt.Image getImage();
public void setImage(java.awt.Image image);
default:0
public int getImageLoadStatus();
default:null
public java.awt.image.ImageObserver getImageObser ver();
public void setImageObser ver(java.awt.image.ImageObserver obser ver);
// Methods Implementing Icon
default:-1
public int getIconHeight();
default:-1
public int getIconW idth();
synchronized
public void paintIcon(Component c, java.awt.Graphics g, int x, int y);
// Protected Instance Methods
protected void loadImage(java.awt.Image image);
}
Hierar chy: Object→ImageIcon(Icon, Serializable)
JApplet
Ja va 1.2
javax.swing
serializable accessible swing component bean container
This class is the Swing version of its superclass, java.applet.Applet. It creates a JRootPane as
its sole child, and, like JFrame, JDialog, and similar classes, it implements RootPaneCon-
tainer. Calling add() or setLayout() on a JApplet raises an exception. Instead, call getContent-
Pane() to obtain a refer ence to an internal container on which you can call add() and
setLayout(). The default layout manager for this content pane is a BorderLayout. Because
JApplet is a RootPaneContainer, it can display a Swing menubar. Use setJMenuBar() and getJ-
MenuBar().
public class JApplet extends java.applet.Applet implements Accessible, RootPaneContainer {
// Public Constructors
public JApplet();
// Inner Classes
protected class AccessibleJApplet extends AccessibleContext implements AccessibleComponent, Serializable;
// Property Accessor Methods (by property name)
Implements:Accessible default:AccessibleJApplet
public AccessibleContext getAccessibleContext();
Implements:RootPaneContainer default:JPanel
public Container getContentPane();
Implements:RootPaneContainer hidden
public void setContentPane(Container contentPane);
Implements:RootPaneContainer default:JPanel
public Component getGlassPane();
Implements:RootPaneContainer hidden
public void setGlassPane(Component glassPane);
default:null
public JMenuBar getJMenuBar();
hidden
public void setJMenuBar(JMenuBar menuBar);
Implements:RootPaneContainer
public JLayeredPane getLayeredPane();
Implements:RootPaneContainer hidden
public void setLayeredPane(JLayeredPane layeredPane);
Overrides:Container
public void setLayout(java.awt.LayoutManager manager);
Implements:RootPaneContainer
public JRootPane getRootPane();
// Methods Implementing Accessible
default:AccessibleJApplet
public AccessibleContext getAccessibleContext();
javax.swing.ImageIcon
426 Chapter 23 – The javax.swing Package

// Methods Implementing RootPaneContainer
default:JPanel
public Container getContentPane();
default:JPanel
public Component getGlassPane();
public JLayeredPane getLayeredPane();
public JRootPane getRootPane();
hidden
public void setContentPane(Container contentPane);
hidden
public void setGlassPane(Component glassPane);
hidden
public void setLayeredPane(JLayeredPane layeredPane);
// Public Methods Overriding Container
public void remove(Component comp);
public void update(java.awt.Graphics g);
// Protected Methods Overriding Container
protected void addImpl(Component comp, Object constraints, int index);
protected String paramString();
// Protected Methods Overriding Component
protected void processKeyEvent(java.awt.e vent.Ke yEvent e);
// Protected Instance Methods
protected JRootPane createRootPane();
protected boolean isRootPaneCheckingEnabled();
hidden
protected void setRootPane(JRootPane root);
protected void setRootPaneCheckingEnabled(boolean enabled);
// Protected Instance Fields
protected AccessibleContext accessibleContext;
protected JRootPane rootPane;
protected boolean rootPaneCheckingEnabled;
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→java.awt.Panel→java.applet.Applet→JApplet(Accessible, RootPaneContainer)
JButton
Ja va 1.2
javax.swing
serializable accessible(action,value) swing component
This class implements a push button. The constructors allow a textual label and/or an
icon to be speciﬁed for the button. isDefaultButton() checks to see if the button is the
default button register ed with the setDefaultButton() method of JRootPane. A JButton gener-
ates a java.awt.event.ActionEvent when clicked. Most of the interesting properties and meth-
ods of JButton ar e implemented by AbstractButton. The default JButton model is
DefaultButtonModel.
public class JButton extends AbstractButton implements Accessible {
// Public Constructors
public JButton();
public JButton(Icon icon);
public JButton(String text);
public JButton(String text, Icon icon);
// Inner Classes
protected class AccessibleJButton extends AbstractButton.AccessibleAbstractButton;
// Property Accessor Methods (by property name)
Implements:Accessible default:AccessibleJButton expert
public AccessibleContext getAccessibleContext();
default:false
public boolean isDefaultButton();
default:true
public boolean isDefaultCapable();
bound
public void setDefaultCapable(boolean defaultCapable);
Overrides:JComponent default:"ButtonUI" expert
public String getUIClassID();
// Methods Implementing Accessible
default:AccessibleJButton expert
public AccessibleContext getAccessibleContext();
javax.swing
javax.swing.JButton
Chapter 23 – The javax.swing Package
427

// Public Methods Overriding AbstractButton
public void updateUI();
// Protected Methods Overriding AbstractButton
protected String paramString();
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→JComponent(Serializable)→AbstractButton(java.awt.ItemSelectable, SwingConstants)→
JButton(Accessible)
Passed To: JRootPane.setDefaultButton(), JToolBar.createActionChangeListener()
Retur ned By: JRootPane.getDefaultButton(), JToolBar.add()
Type Of: JRootPane.defaultButton
JCheckBox
Ja va 1.2
javax.swing
serializable accessible(action,value) swing component
This class implements a check button: a toggle button with default graphics that indi-
cate that the button does not have mutually exclusive behavior. Because JCheckBox sup-
plies its own default and selected icons, you typically do not use the constructors that
take Icon arguments. The initial selection state of a JCheckBox can be speciﬁed in the call
to the constructor. The state can also be set with setSelected() and queried with isSe-
lected(). Use JRadioButton and ButtonGroup instead of JCheckBox if you want to display a set
of mutually exclusive choices. The default JCheckBox model is JToggleButton.ToggleButton-
Model. Note that java.awt.Checkbox is spelled with a lowercase b, while JCheckBox has an
uppercase B.
public class JCheckBox extends JToggleButton implements Accessible {
// Public Constructors
public JCheckBox();
public JCheckBox(Icon icon);
public JCheckBox(String text);
public JCheckBox(String text, Icon icon);
public JCheckBox(Icon icon, boolean selected);
public JCheckBox(String text, boolean selected);
public JCheckBox(String text, Icon icon, boolean selected);
// Inner Classes
protected class AccessibleJCheckBox extends JToggleButton.AccessibleJToggleButton;
// Property Accessor Methods (by property name)
Implements:Accessible default:AccessibleJCheckBox expert
public AccessibleContext getAccessibleContext();
Overrides:JToggleButton default:"CheckBoxUI" expert
public String getUIClassID();
// Methods Implementing Accessible
default:AccessibleJCheckBox expert
public AccessibleContext getAccessibleContext();
// Public Methods Overriding JToggleButton
public void updateUI();
// Protected Methods Overriding JToggleButton
protected String paramString();
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→JComponent(Serializable)→AbstractButton(java.awt.ItemSelectable, SwingConstants)→
JToggleButton(Accessible)→JCheckBox(Accessible)
Passed To: DefaultCellEditor.DefaultCellEditor()
javax.swing.JButton
428 Chapter 23 – The javax.swing Package

JCheckBoxMenuItem
Ja va 1.2
javax.swing
serializable accessible(action,value) swing component
This class implements a check button that appears within a pulldown or popup menu.
Its use is similar to that of JCheckBox. Use isSelected() to query the selection state of the
menu item and setSelected() to select or deselect the item. For menu items with mutu-
ally-exclusive selection behavior, use JRadioButtonMenuItem instead. The default JCheckBox-
MenuItem model is JToggleButton.ToggleButtonModel.
public class JCheckBoxMenuItem extends JMenuItem implements Accessible, SwingConstants {
// Public Constructors
public JCheckBoxMenuItem();
public JCheckBoxMenuItem(String text);
public JCheckBoxMenuItem(Icon icon);
public JCheckBoxMenuItem(String text, Icon icon);
public JCheckBoxMenuItem(String text, boolean b);
public JCheckBoxMenuItem(String text, Icon icon, boolean b);
// Inner Classes
protected class AccessibleJCheckBoxMenuItem extends JMenuItem.AccessibleJMenuItem;
// Property Accessor Methods (by property name)
Implements:Accessible default:AccessibleJCheckBoxMenuItem
public AccessibleContext
getAccessibleContext();
Overrides:AbstractButton synchronized default:null
public Object[ ] getSelectedObjects();
default:false
public boolean getState();
synchronized hidden
public void setState(boolean b);
Overrides:JMenuItem
public String getUIClassID();
// Methods Implementing Accessible
default:AccessibleJCheckBoxMenuItem
public AccessibleContext getAccessibleContext();
// Protected Methods Overriding JMenuItem
protected String paramString();
// Public Methods Overriding JComponent
empty
public void requestFocus();
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→JComponent(Serializable)→AbstractButton(java.awt.ItemSelectable, SwingConstants)→
JMenuItem(Accessible, MenuElement)→JCheckBoxMenuItem(Accessible, SwingConstants)
JColorChooser
Ja va 1.2
javax.swing
serializable accessible swing component
This component allows the user to select a color. The easiest way to use it is to call the
static showDialog() method, specifying a parent Component for the dialog, a title, and an
initial default color. The method creates a JColorChooser in a modal JDialog and blocks
until the user dismisses the dialog. If the user dismisses the dialog with the OK button,
the method retur ns the selected color. If the user dismisses the dialog with the Cancel
button, or in any other way, showDialog() retur ns null.
If you need more contr ol over the color selection dialog, you can call createDialog(). This
static method creates a JDialog that contains the JColorChooser component you specify. It
allows you to specify java.awt.event.ActionListener objects to respond to the OK and Cancel
buttons. It does not automatically display the dialog for you, nor does it wait for the
user to make a selection.
You can also create and manipulate a JColorChooser on your own, placing it in any dia-
log or other container. You can register a java.beans.Proper tyChangeListener object (with the
inherited addProper tyChangeListener() method) to receive notiﬁcation when the color pr op-
erty changes.
javax.swing
javax.swing.JColorChooser
Chapter 23 – The javax.swing Package
429

JColorChooser is highly customizable. You can specify how colors are selected by specify-
ing a custom subclass of javax.swing .colorchooser.AbstractColorChooserPanel to addChooser-
Panel() or setChooserPanels(). And you can customize the way that colors are previewed
by specifying an appropriate component to setPreviewPanel(). The default JColorChooser
model is a javax.swing .colorchooser.DefaultColorSelectionModel.
public class JColorChooser extends JComponent implements Accessible {
// Public Constructors
public JColorChooser();
public JColorChooser(java.awt.Color initialColor);
public JColorChooser(javax.swing .colorchooser.ColorSelectionModel model);
// Public Constants
="chooserPanels"
public static ﬁnal String CHOOSER_PANELS_PROPERTY;
="previewPanel"
public static ﬁnal String PREVIEW_PANEL_PROPERTY;
="selectionModel"
public static ﬁnal String SELECTION_MODEL_PROPERTY;
// Inner Classes
protected class AccessibleJColorChooser extends JComponent.AccessibleJComponent;
// Public Class Methods
public static JDialog createDialog(Component c, String title, boolean modal, JColorChooser chooserPane,
java.awt.e vent.ActionListener okListener,
java.awt.e vent.ActionListener cancelListener);
public static java.awt.Color showDialog(Component component, String title, java.awt.Color initialColor);
// Property Accessor Methods (by property name)
Implements:Accessible default:AccessibleJColorChooser
public AccessibleContext getAccessibleContext();
public javax.swing.colorchooser.AbstractColorChooserPanel[ ] getChooserPanels();
bound hidden
public void setChooserPanels(javax.swing .colorchooser.AbstractColorChooserPanel[ ] panels);
public java.awt.Color getColor();
public void setColor(int c);
public void setColor(java.awt.Color color);
public void setColor(int r, int g, int b);
default:null
public JComponent getPreviewPanel();
bound hidden
public void setPreviewPanel(JComponent preview);
default:DefaultColorSelectionModel
public javax.swing.colorchooser.ColorSelectionModel getSelectionModel();
bound hidden
public void setSelectionModel(javax.swing .colorchooser.ColorSelectionModel newModel);
public javax.swing.plaf.ColorChooserUI getUI();
bound hidden
public void setUI(javax.swing .plaf.ColorChooserUI ui);
Overrides:JComponent default:"ColorChooserUI"
public String getUIClassID();
// Public Instance Methods
public void addChooserPanel(javax.swing .colorchooser.AbstractColorChooserPanel panel);
public javax.swing.colorchooser.AbstractColorChooserPanel removeChooserPanel(
javax.swing .colorchooser.AbstractColorChooserPanel panel);
// Methods Implementing Accessible
default:AccessibleJColorChooser
public AccessibleContext getAccessibleContext();
// Public Methods Overriding JComponent
public void updateUI();
// Protected Methods Overriding JComponent
protected String paramString();
// Protected Instance Fields
protected AccessibleContext accessibleContext;
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→JComponent(Serializable)→JColorChooser(Accessible)
Passed To: JColorChooser.createDialog(),
javax.swing .colorchooser.AbstractColorChooserPanel.{installChooserPanel(), uninstallChooserPanel()}
javax.swing.JColorChooser
430 Chapter 23 – The javax.swing Package

JComboBox
Ja va 1.2
javax.swing
serializable accessible(action) swing component
This class implements a combo box: a combination of a popup list of selectable items
and an item editor that displays the selected value and, optionally, allows the user to
enter an item that does not appear on the list. The editor is usually a text ﬁeld, but a
JComboBox can be conﬁgured to use another component as its ComboBoxEditor.
Typically, you create a JComboBox by passing a Vector or array of objects to a constructor.
Alter natively, you can create an empty JComboBox and add items to it with addItem(). You
can set and query the selection with setSelectedItem(), setSelectedIndex(), getSelectedItem(),
and getSelectedIndex(). The JComboBox generates a java.awt.event.ActionEvent when the selec-
tion changes. The default JComboBox model is a private implementation of the ComboBox-
Model inter face. If you want to implement keyboard shortcuts for a JComboBox,
implement the JComboBox.KeySelectionManager inter face and pass an instance to the setKey-
SelectionManager() method.
public class JComboBox extends JComponent implements Accessible, java.awt.e vent.ActionListener,
java.awt.ItemSelectable, javax.swing .event.ListDataListener {
// Public Constructors
public JComboBox();
public JComboBox(java.util.Vector items);
public JComboBox(ComboBoxModel aModel);
public JComboBox(Object[ ] items);
// Inner Classes
protected class AccessibleJComboBox extends JComponent.AccessibleJComponent implements
AccessibleAction;
public abstract static interface KeySelectionManager;
// Event Registration Methods (by event name)
public void addActionListener(java.awt.e vent.ActionListener l);
public void removeActionListener(java.awt.e vent.ActionListener l);
Implements:ItemSelectable
public void addItemListener(java.awt.e vent.ItemListener aListener);
Implements:ItemSelectable
public void removeItemListener(java.awt.e vent.ItemListener aListener);
// Property Accessor Methods (by property name)
Implements:Accessible default:AccessibleJComboBox
public AccessibleContext getAccessibleContext();
default:"comboBoxChanged"
public String getActionCommand();
public void setActionCommand(String aCommand);
default:false
public boolean isEditable();
preferred
public void setEditable(boolean aFlag);
public ComboBoxEditor getEditor();
exper t
public void setEditor(ComboBoxEditor anEditor);
Overrides:JComponent default:false
public boolean isFocusTraversable();
default:0
public int getItemCount();
default:null
public JComboBox.KeySelectionManager getKeySelectionManager();
exper t
public void setKeySelectionManager(JComboBox.Ke ySelectionManager aManager);
default:true
public boolean isLightWeightPopupEnabled();
exper t
public void setLightWeightPopupEnabled(boolean aFlag);
default:8
public int getMaximumRowCount();
preferred
public void setMaximumRowCount(int count);
default:DefaultComboBoxModel
public ComboBoxModel getModel();
bound
public void setModel(ComboBoxModel aModel);
default:false
public boolean isPopupV isible();
public void setPopupV isible(boolean v);
public ListCellRenderer getRenderer();
exper t
public void setRenderer(ListCellRenderer aRenderer);
default:-1
public int getSelectedIndex();
preferred
public void setSelectedIndex(int anIndex);
default:null
public Object getSelectedItem();
preferred
public void setSelectedItem(Object anObject);
javax.swing
javax.swing.JComboBox
Chapter 23 – The javax.swing Package
431

Implements:ItemSelectable
public Object[ ] getSelectedObjects();
public javax.swing.plaf.ComboBoxUI getUI();
exper t
public void setUI(javax.swing .plaf.ComboBoxUI ui);
Overrides:JComponent default:"ComboBoxUI"
public String getUIClassID();
// Public Instance Methods
public void addItem(Object anObject);
public void conﬁgureEditor(ComboBoxEditor anEditor, Object anItem);
public Object getItemAt(int index);
public void hidePopup();
public void inser tItemAt(Object anObject, int index);
public void removeAllItems();
public void removeItem(Object anObject);
public void removeItemAt(int anIndex);
public boolean selectW ithKeyChar(char keyChar);
public void showPopup();
// Methods Implementing Accessible
default:AccessibleJComboBox
public AccessibleContext getAccessibleContext();
// Methods Implementing ActionListener
public void actionPerfor med(java.awt.e vent.ActionEvent e);
// Methods Implementing ItemSelectable
public void addItemListener(java.awt.e vent.ItemListener aListener);
public Object[ ] getSelectedObjects();
public void removeItemListener(java.awt.e vent.ItemListener aListener);
// Methods Implementing ListDataListener
public void contentsChanged(javax.swing .event.ListDataEvent e);
public void inter valAdded(javax.swing .event.ListDataEvent e);
public void inter valRemoved(javax.swing .event.ListDataEvent e);
// Public Methods Overriding JComponent
public void processKeyEvent(java.awt.e vent.Ke yEvent e);
preferred
public void setEnabled(boolean b);
public void updateUI();
// Protected Methods Overriding JComponent
protected String paramString();
// Protected Instance Methods
protected JComboBox.KeySelectionManager createDefaultKeySelectionManager();
protected void ﬁreActionEvent();
protected void ﬁreItemStateChanged(java.awt.e vent.ItemEvent e);
protected void installAncestorListener();
protected void selectedItemChanged();
// Protected Instance Fields
protected String actionCommand;
protected ComboBoxModel dataModel;
protected ComboBoxEditor editor;
protected boolean isEditable;
protected JComboBox.KeySelectionManager keySelectionManager;
protected boolean lightWeightPopupEnabled;
protected int maximumRowCount;
protected ListCellRenderer renderer;
protected Object selectedItemReminder;
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→JComponent(Serializable)→JComboBox(Accessible,
java.awt.event.ActionListener(java.util.EventListener), java.awt.ItemSelectable,
javax.swing .event.ListDataListener(java.util.EventListener))
Passed To: DefaultCellEditor.DefaultCellEditor(), javax.swing .plaf.ComboBoxUI.{isFocusTraversable(),
isPopupV isible(), setPopupV isible()}
javax.swing.JComboBox
432 Chapter 23 – The javax.swing Package

JComboBox.KeySelectionManager
Ja va 1.2
javax.swing
This interface deﬁnes the method that must be implemented to bind characters to items
in a JComboBox. Given a character, selectionForKey() should retur n the index of the item
that should be selected or -1 if the character does not correspond to an item in the list.
public abstract static interface JComboBox.KeySelectionManager {
// Public Instance Methods
public abstract int selectionForKey(char aKey, ComboBoxModel aModel);
}
Passed To: JComboBox.setKeySelectionManager()
Retur ned By: JComboBox.{createDefaultKeySelectionManager(), getKeySelectionManager()}
Type Of: JComboBox.keySelectionManager
JComponent
Ja va 1.2
javax.swing
serializable swing component
JComponent is the root of the Swing component hierarchy. It inherits the properties and
methods of java.awt.Component and java.awt.Container, including such commonly used
pr operties as foreground, background, font, cursor, enabled, and visible.
In addition to these inherited properties, JComponent deﬁnes a number of new proper-
ties that are commonly used. The border pr operty speciﬁes a Border object that displays a
border (or a blank space) around the component. doubleBuffered speciﬁes whether the
JComponent should automatically use double-buffering to reduce ﬂickering during
redraws. opaque speciﬁes whether the component draws its background or lets its par-
ent’ background show through. toolT ipText speciﬁes the text to appear in a tooltip when
the mouse pointer lingers over the component.
In addition to the standard get/set property accessor methods, JComponent also deﬁnes
getClientProper ty() and putClientProper ty(). In effect, every JComponent maintains a hashtable
that maps arbitrary property names to values. You can use this to associate arbitrary
data with any Swing component. It is also occasionally used to specify properties that
ar e speciﬁc to certain look-and-feels.
public abstract class JComponent extends Container implements Serializable {
// Public Constructors
public JComponent();
// Public Constants
="ToolTipText"
public static ﬁnal String TOOL_TIP_TEXT_KEY;
=-1
public static ﬁnal int UNDEFINED_CONDITION;
=1
public static ﬁnal int WHEN_ANCESTOR_OF_FOCUSED_COMPONENT;
=0
public static ﬁnal int WHEN_FOCUSED;
=2
public static ﬁnal int WHEN_IN_FOCUSED_WINDOW;
// Inner Classes
public abstract class AccessibleJComponent extends AccessibleContext implements AccessibleComponent,
Serializable;
// Public Class Methods
public static boolean isLightweightComponent(Component c);
// Event Registration Methods (by event name)
public void addAncestorListener(javax.swing .event.AncestorListener listener);
public void removeAncestorListener(javax.swing .event.AncestorListener listener);
Overrides:Component synchronized
public void addProper tyChangeListener(
java.beans.Proper tyChangeListener listener);
Overrides:Component synchronized
public void removeProper tyChangeListener(
java.beans.Proper tyChangeListener listener);
javax.swing
javax.swing.JComponent
Chapter 23 – The javax.swing Package
433

synchronized
public void addVetoableChangeListener(java.beans.VetoableChangeListener listener);
synchronized
public void removeVetoableChangeListener(java.beans.VetoableChangeListener listener);
// Property Accessor Methods (by property name)
public AccessibleContext getAccessibleContext();
Overrides:Container
public ﬂoat getAlignmentX();
public void setAlignmentX(ﬂoat alignmentX);
Overrides:Container
public ﬂoat getAlignmentY();
public void setAlignmentY(ﬂoat alignmentY);
public boolean getAutoscrolls();
exper t
public void setAutoscrolls(boolean autoscrolls);
Overrides:Component bound preferred
public void setBackground(java.awt.Color bg);
public javax.swing.border.Border getBorder();
bound preferred
public void setBorder(javax.swing .border.Border border);
public int getDebugGraphicsOptions();
preferred
public void setDebugGraphicsOptions(int debugOptions);
Overrides:Component
public boolean isDoubleBuffered();
public void setDoubleBuffered(boolean aFlag);
Overrides:Component bound preferred
public void setEnabled(boolean enabled);
constant
public boolean isFocusCycleRoot();
Overrides:Component
public boolean isFocusTraversable();
Overrides:Component bound preferred
public void setForeground(java.awt.Color fg);
Overrides:Component
public java.awt.Graphics getGraphics();
Overrides:Component
public int getHeight();
Overrides:Container
public java.awt.Insets getInsets();
exper t
public java.awt.Insets getInsets(java.awt.Insets insets);
constant
public boolean isManagingFocus();
Overrides:Container
public java.awt.Dimension getMaximumSize();
bound
public void setMaximumSize(java.awt.Dimension maximumSize);
Overrides:Container
public java.awt.Dimension getMinimumSize();
bound
public void setMinimumSize(java.awt.Dimension minimumSize);
public Component getNextFocusableComponent();
exper t
public void setNextFocusableComponent(Component aComponent);
Overrides:Component
public boolean isOpaque();
public void setOpaque(boolean isOpaque);
constant
public boolean isOptimizedDrawingEnabled();
public boolean isPaintingT ile();
Overrides:Container
public java.awt.Dimension getPrefer redSize();
bound preferred
public void setPrefer redSize(java.awt.Dimension preferredSize);
public KeyStroke[ ] getRegisteredKeyStrokes();
public boolean isRequestFocusEnabled();
exper t
public void setRequestFocusEnabled(boolean aFlag);
public JRootPane getRootPane();
public String getToolT ipText();
public String getToolT ipText(java.awt.e vent.MouseEvent event);
preferred
public void setToolT ipText(String text);
public Container getTopLevelAncestor();
exper t
public String getUIClassID();
constant
public boolean isValidateRoot();
Overrides:Component
public void setV isible(boolean aFlag);
public java.awt.Rectangle getV isibleRect();
Overrides:Component
public int getW idth();
Overrides:Component
public int getX();
Overrides:Component
public int getY();
// Public Instance Methods
public void computeV isibleRect(java.awt.Rectangle visibleRect);
public JToolT ip createToolT ip();
public void ﬁreProper tyChange(String proper tyName, long oldValue, long newValue);
public void ﬁreProper tyChange(String proper tyName, int oldValue, int newValue);
javax.swing.JComponent
434 Chapter 23 – The javax.swing Package

public void ﬁreProper tyChange(String proper tyName, boolean oldValue, boolean newValue);
public void ﬁreProper tyChange(String proper tyName, shor t oldValue, shor t newValue);
public void ﬁreProper tyChange(String proper tyName, char oldValue, char newValue);
public void ﬁreProper tyChange(String proper tyName, byte oldValue, byte newValue);
public void ﬁreProper tyChange(String proper tyName, ﬂoat oldValue, ﬂoat newValue);
public void ﬁreProper tyChange(String proper tyName, double oldValue, double newValue);
public java.awt.event.ActionListener getActionForKeyStroke(KeyStroke aKeyStroke);
public ﬁnal Object getClientProper ty(Object key);
public int getConditionForKeyStroke(KeyStroke aKeyStroke);
constant
public java.awt.Point getToolT ipLocation(java.awt.e vent.MouseEvent event);
public void grabFocus();
public void paintImmediately(java.awt.Rectangle r);
public void paintImmediately(int x, int y, int w, int h);
public ﬁnal void putClientProper ty(Object key, Object value);
public void registerKeyboardAction(java.awt.e vent.ActionListener anAction, KeyStroke aKeyStroke,
int aCondition);
public void registerKeyboardAction(java.awt.e vent.ActionListener anAction, String aCommand,
Ke yStroke aKeyStroke, int aCondition);
public void repaint(java.awt.Rectangle r);
public boolean requestDefaultFocus();
public void resetKeyboardActions();
public void revalidate();
public void scrollRectToV isible(java.awt.Rectangle aRect);
bound preferred
public void setFont(java.awt.Font font);
public void unregisterKeyboardAction(KeyStroke aKeyStroke);
empty
public void updateUI();
// Public Methods Overriding Container
public void addNotify();
public void paint(java.awt.Graphics g);
public void removeNotify();
public void update(java.awt.Graphics g);
// Protected Methods Overriding Container
protected String paramString();
// Public Methods Overriding Component
synchronized
public void addProper tyChangeListener(String proper tyName,
java.beans.Proper tyChangeListener listener);
public boolean contains(int x, int y);
public java.awt.Rectangle getBounds(java.awt.Rectangle rv);
public java.awt.Point getLocation(java.awt.Point rv);
public java.awt.Dimension getSize(java.awt.Dimension rv);
public boolean hasFocus();
synchronized
public void removeProper tyChangeListener(String proper tyName,
java.beans.Proper tyChangeListener listener);
public void repaint(long tm, int x, int y, int width, int height);
public void requestFocus();
public void reshape(int x, int y, int w, int h);
// Protected Methods Overriding Component
protected void ﬁreProper tyChange(String proper tyName, Object oldValue, Object newValue);
protected void processFocusEvent(java.awt.e vent.FocusEvent e);
protected void processKeyEvent(java.awt.e vent.Ke yEvent e);
protected void processMouseMotionEvent(java.awt.e vent.MouseEvent e);
// Protected Instance Methods
protected void ﬁreVetoableChange(String proper tyName, Object oldValue, Object newValue)
throws java.beans.PropertyVetoException;
protected java.awt.Graphics getComponentGraphics(java.awt.Graphics g);
protected void paintBorder(java.awt.Graphics g);
protected void paintChildren(java.awt.Graphics g);
protected void paintComponent(java.awt.Graphics g);
javax.swing
javax.swing.JComponent
Chapter 23 – The javax.swing Package
435

empty
protected void processComponentKeyEvent(java.awt.e vent.Ke yEvent e);
bound
protected void setUI(javax.swing .plaf.ComponentUI newUI);
// Protected Instance Fields
protected AccessibleContext accessibleContext;
protected javax.swing.e vent.EventListenerList listenerList;
protected transient javax.swing.plaf.ComponentUI ui;
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→JComponent(Serializable)
Subc lasses: Too many classes to list.
Passed To: Too many methods to list.
Retur ned By: JColorChooser.getPreviewPanel(), JFileChooser.getAccessor y(), JToolT ip.getComponent(),
javax.swing .colorchooser.ColorChooserComponentFactor y.getPreviewPanel(),
javax.swing .event.AncestorEvent.getComponent()
Type Of: DefaultCellEditor.editorComponent
JComponent.AccessibleJComponent
Ja va 1.2
javax.swing
serializable accessible context
This class provides default accessibility support for Swing components. It is typically
subclassed by component developers; application programmers never need to use it.
public abstract class JComponent.AccessibleJComponent extends AccessibleContext
implements AccessibleComponent, Serializable {
// Protected Constructors
protected AccessibleJComponent();
// Inner Classes
protected class AccessibleContainerHandler implements java.awt.event.ContainerListener ;
// Event Registration Methods (by event name)
Implements:AccessibleComponent
public void addFocusListener(java.awt.e vent.FocusListener l);
Implements:AccessibleComponent
public void removeFocusListener(java.awt.e vent.FocusListener l);
Overrides:AccessibleContext
public void addProper tyChangeListener(
java.beans.Proper tyChangeListener listener);
Overrides:AccessibleContext
public void removeProper tyChangeListener(
java.beans.Proper tyChangeListener listener);
// Methods Implementing AccessibleComponent
public void addFocusListener(java.awt.e vent.FocusListener l);
public boolean contains(java.awt.Point p);
public Accessible getAccessibleAt(java.awt.Point p);
public java.awt.Color getBackground();
public java.awt.Rectangle getBounds();
public java.awt.Cursor getCursor();
public java.awt.Font getFont();
public java.awt.FontMetrics getFontMetrics(java.awt.Font f);
public java.awt.Color getForeground();
public java.awt.Point getLocation();
public java.awt.Point getLocationOnScreen();
public java.awt.Dimension getSize();
public boolean isEnabled();
public boolean isFocusTraversable();
public boolean isShowing();
public boolean isV isible();
public void removeFocusListener(java.awt.e vent.FocusListener l);
public void requestFocus();
public void setBackground(java.awt.Color c);
javax.swing.JComponent
436 Chapter 23 – The javax.swing Package

public void setBounds(java.awt.Rectangle r);
public void setCursor(java.awt.Cursor cursor);
public void setEnabled(boolean b);
public void setFont(java.awt.Font f);
public void setForeground(java.awt.Color c);
public void setLocation(java.awt.Point p);
public void setSize(java.awt.Dimension d);
public void setV isible(boolean b);
// Public Methods Overriding AccessibleContext
public Accessible getAccessibleChild(int i);
public int getAccessibleChildrenCount();
public AccessibleComponent getAccessibleComponent();
public String getAccessibleDescription();
public int getAccessibleIndexInParent();
public String getAccessibleName();
public Accessible getAccessibleParent();
public AccessibleRole getAccessibleRole();
public AccessibleStateSet getAccessibleStateSet();
public java.util.Locale getLocale();
// Protected Instance Methods
protected String getBorderT itle(javax.swing .border.Border b);
// Protected Instance Fields
protected java.awt.event.ContainerListener accessibleContainerHandler;
}
Subc lasses: Too many classes to list.
JDesktopPane
Ja va 1.2
javax.swing
serializable accessible swing component
This class is a container for JInter nalFrame windows. It provides window management
functionality appropriate for the currently installed look-and-feel.
public class JDesktopPane extends JLayeredPane implements Accessible {
// Public Constructors
public JDesktopPane();
// Inner Classes
protected class AccessibleJDesktopPane extends JComponent.AccessibleJComponent;
// Property Accessor Methods (by property name)
Implements:Accessible default:AccessibleJDesktopPane
public AccessibleContext getAccessibleContext();
public JInternalFrame[ ] getAllFrames();
default:DefaultDesktopManager
public DesktopManager getDesktopManager();
public void setDesktopManager(DesktopManager d);
Overrides:JComponent constant default:true
public boolean isOpaque();
public javax.swing.plaf.DesktopPaneUI getUI();
public void setUI(javax.swing .plaf.DesktopPaneUI ui);
Overrides:JComponent default:"DesktopPaneUI"
public String getUIClassID();
// Public Instance Methods
public JInternalFrame[ ] getAllFramesInLayer(int layer);
// Methods Implementing Accessible
default:AccessibleJDesktopPane
public AccessibleContext getAccessibleContext();
// Protected Methods Overriding JLayeredPane
protected String paramString();
// Public Methods Overriding JComponent
public void updateUI();
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→JComponent(Serializable)→JLayeredPane(Accessible)→JDesktopPane(Accessible)
javax.swing
javax.swing.JDesktopPane
Chapter 23 – The javax.swing Package
437

Retur ned By: JInter nalFrame.getDesktopPane(), JInternalFrame.JDesktopIcon.getDesktopPane(),
JOptionPane.getDesktopPaneForComponent()
JDialog
Ja va 1.2
javax.swing
serializable accessible swing component bean container
This class is used to display Swing dialog boxes. Every JDialog component has an auto-
matically created JRootPane as its single child. Components must not be added directly
to the JDialog component. Instead, they should be added to the container retur ned by
getContentPane() method. The default layout manager of this content pane is java.awt.Bor-
derLayout. Unlike its java.awt.Dialog superclass, JDialog can display a menubar. Specify one
with setJMenuBar(). setDefaultCloseOperation() speciﬁes how the JDialog should behave
when the user attempts to close it. The argument should be one of the constants
deﬁned by the WindowConstants inter face. The default is HIDE_ON_CLOSE. JDialog uses a
native window. Use JInter nalFrame for lightweight dialogs.
public class JDialog extends java.awt.Dialog implements Accessible, RootPaneContainer, WindowConstants {
// Public Constructors
public JDialog();
public JDialog(java.awt.Dialog owner);
public JDialog(java.awt.Frame owner);
public JDialog(java.awt.Dialog owner, String title);
public JDialog(java.awt.Frame owner, boolean modal);
public JDialog(java.awt.Frame owner, String title);
public JDialog(java.awt.Dialog owner, boolean modal);
public JDialog(java.awt.Frame owner, String title, boolean modal);
public JDialog(java.awt.Dialog owner, String title, boolean modal);
// Inner Classes
protected class AccessibleJDialog extends AccessibleContext implements AccessibleComponent, Serializable;
// Property Accessor Methods (by property name)
Implements:Accessible default:AccessibleJDialog
public AccessibleContext getAccessibleContext();
Implements:RootPaneContainer default:JPanel
public Container getContentPane();
Implements:RootPaneContainer hidden
public void setContentPane(Container contentPane);
default:1
public int getDefaultCloseOperation();
preferred
public void setDefaultCloseOperation(int operation);
Implements:RootPaneContainer default:JPanel
public Component getGlassPane();
Implements:RootPaneContainer hidden
public void setGlassPane(Component glassPane);
default:null
public JMenuBar getJMenuBar();
hidden
public void setJMenuBar(JMenuBar menu);
Implements:RootPaneContainer
public JLayeredPane getLayeredPane();
Implements:RootPaneContainer hidden
public void setLayeredPane(JLayeredPane layeredPane);
Overrides:Container
public void setLayout(java.awt.LayoutManager manager);
Implements:RootPaneContainer
public JRootPane getRootPane();
// Public Instance Methods
public void setLocationRelativeTo(Component c);
// Methods Implementing Accessible
default:AccessibleJDialog
public AccessibleContext getAccessibleContext();
// Methods Implementing RootPaneContainer
default:JPanel
public Container getContentPane();
default:JPanel
public Component getGlassPane();
public JLayeredPane getLayeredPane();
public JRootPane getRootPane();
hidden
public void setContentPane(Container contentPane);
hidden
public void setGlassPane(Component glassPane);
hidden
public void setLayeredPane(JLayeredPane layeredPane);
// Protected Methods Overriding Dialog
protected String paramString();
javax.swing.JDesktopPane
438 Chapter 23 – The javax.swing Package

// Protected Methods Overriding Window
protected void processW indowEvent(java.awt.e vent.WindowEvent e);
// Public Methods Overriding Container
public void remove(Component comp);
public void update(java.awt.Graphics g);
// Protected Methods Overriding Container
protected void addImpl(Component comp, Object constraints, int index);
// Protected Methods Overriding Component
protected void processKeyEvent(java.awt.e vent.Ke yEvent e);
// Protected Instance Methods
protected JRootPane createRootPane();
protected void dialogInit();
protected boolean isRootPaneCheckingEnabled();
hidden
protected void setRootPane(JRootPane root);
hidden
protected void setRootPaneCheckingEnabled(boolean enabled);
// Protected Instance Fields
protected AccessibleContext accessibleContext;
protected JRootPane rootPane;
protected boolean rootPaneCheckingEnabled;
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→java.awt.W indow→java.awt.Dialog→JDialog(Accessible, RootPaneContainer,
WindowConstants)
Retur ned By: JColorChooser.createDialog(), JOptionPane.createDialog()
JEditorPane
Ja va 1.2
javax.swing
serializable accessible(text,hyper text) swing component
This class is a subclass of javax.swing .text.JTextComponent that can be easily conﬁgured to
display and edit differ ent for matted-text content types using a javax.swing .text.EditorKit
object. To conﬁgur e a JEditorPane, call setEditorKit() to specify an appropriate editor kit for
the desired content type. Alternatively, use the static registerEditorKitForContentType() to reg-
ister a mapping between content types and their corresponding editor kits and then call
setContentType(). With such a mapping in place, you may also use setPage() to specify a
URL to be displayed. The JEditorPane deter mines the content type of the URL, installs an
appr opriate EditorKit, and loads the contents of the URL into the JEditorPane. Swing comes
with 
two 
predeﬁned
EditorKit
subclasses:
javax.swing .text.html.HTMLEditorKit
and
javax.swing .text.rtf.RTFEditorKit.
public class JEditorPane extends javax.swing.text.JTextComponent {
// Public Constructors
public JEditorPane();
public JEditorPane(String url) throws java.io.IOException;
public JEditorPane(java.net.URL initialPage) throws java.io.IOException;
public JEditorPane(String type, String text);
// Inner Classes
protected class AccessibleJEditorPane extends javax.swing.text.JTextComponent.AccessibleJTextComponent;
protected class AccessibleJEditorPaneHTML extends JEditorPane.AccessibleJEditorPane;
protected class JEditorPaneAccessibleHyper textSuppor t extends JEditorPane.AccessibleJEditorPane
implements AccessibleHypertext;
// Public Class Methods
public static javax.swing.text.EditorKit createEditorKitForContentType(String type);
public static void registerEditorKitForContentType(String type, String classname);
public static void registerEditorKitForContentType(String type, String classname, ClassLoader loader);
javax.swing
javax.swing.JEditorPane
Chapter 23 – The javax.swing Package
439

// Event Registration Methods (by event name)
synchronized
public void addHyper linkListener(javax.swing .event.HyperlinkListener listener);
synchronized
public void removeHyper linkListener(javax.swing .event.HyperlinkListener listener);
// Property Accessor Methods (by property name)
Overrides:JTextComponent default:AccessibleJEditorPane
public AccessibleContext getAccessibleContext();
default:"text/plain"
public ﬁnal String getContentType();
public ﬁnal void setContentType(String type);
public ﬁnal javax.swing.text.EditorKit getEditorKit();
bound expert
public void setEditorKit(javax.swing .text.EditorKit kit);
Overrides:JComponent constant default:true
public boolean isManagingFocus();
default:null
public java.net.URL getPage();
bound expert
public void setPage(java.net.URL page) throws java.io.IOException;
public void setPage(String url) throws java.io.IOException;
Overrides:JComponent
public java.awt.Dimension getPrefer redSize();
Overrides:JTextComponent default:false
public boolean getScrollableTracksV iewportHeight();
Overrides:JTextComponent default:false
public boolean getScrollableTracksV iewportW idth();
Overrides:JTextComponent default:""
public String getText();
Overrides:JTextComponent
public void setText(String t);
Overrides:JComponent default:"EditorPaneUI"
public String getUIClassID();
// Public Instance Methods
public void ﬁreHyper linkUpdate(javax.swing .event.HyperlinkEvent e);
public javax.swing.text.EditorKit getEditorKitForContentType(String type);
public void read(java.io.InputStream in, Object desc) throws java.io.IOException;
public void setEditorKitForContentType(String type, javax.swing .text.EditorKit k);
// Public Methods Overriding JTextComponent
public void replaceSelection(String content);
// Protected Methods Overriding JTextComponent
protected String paramString();
protected void processComponentKeyEvent(java.awt.e vent.Ke yEvent e);
// Protected Instance Methods
protected javax.swing.text.EditorKit createDefaultEditorKit();
protected java.io.InputStream getStream(java.net.URL page) throws java.io.IOException;
protected void scrollToReference(String reference);
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→JComponent(Serializable)→javax.swing .text.JTextComponent(Accessible, Scrollable)→
JEditorPane
Subc lasses: JTextPane
Passed To: javax.swing .text.EditorKit.{deinstall(), install()}, javax.swing .text.StyledEditorKit.{deinstall(),
install()}, javax.swing .text.StyledEditorKit.StyledTextAction.{getStyledDocument(), getStyledEditorKit(),
setCharacterAttributes(), setParagraphAttributes()}, javax.swing .text.html.HTMLEditorKit.{deinstall(), install()},
javax.swing .text.html.HTMLEditorKit.HTMLTextAction.{getHTMLDocument(), getHTMLEditorKit()},
javax.swing .text.html.HTMLEditorKit.InsertHTMLTextAction.{inser tAtBoundry(), insertHTML()},
javax.swing .text.html.HTMLEditorKit.LinkController.activateLink()
Retur ned By: javax.swing .text.StyledEditorKit.StyledTextAction.getEditor()
JF ileChooser
Ja va 1.2
javax.swing
serializable accessible swing component
This component allows the user to select a ﬁle. After creating a JF ileChooser component,
and setting any desired properties, the easiest way to use it is to call showOpenDialog() or
showSaveDialog(). These methods display the JF ileChooser in a modal dialog box, using the
component you specify as its parent. They also customize the Okay button to read
Open or Save (or locale-appropriate equivalents). You can also call showDialog() and
explicitly specify the text to appear in the Okay button. The methods retur n
javax.swing.JEditorPane
440 Chapter 23 – The javax.swing Package

APPROVE_OPTION if the user selects a ﬁle and clicks the Save or Open button. They retur n
CANCEL_OPTION if the user clicks the Cancel button or otherwise dismisses the dialog.
They retur n ERROR_OPTION if some sort of error or exception occurs during ﬁle selection.
When the retur n value is APPROVE_OPTION, you can call getSelectedF ile() to obtain a File
object that repr esents the ﬁle the user selected.
Other commonly used JF ileChooser pr operties ar e cur rentDirectory, which speciﬁes the ini-
tial or most recently selected directory displayed by the JF ileChooser, and ﬁleSelection-
Mode, which speciﬁes whether the JF ileChooser should allow the user to choose a ﬁle, a
dir ectory, or either. The legal values for the ﬁleSelectionMode pr operty ar e FILES_ONLY,
DIRECTORIES_ONLY, and FILES_AND_DIRECTORIES.
You can selectively ﬁlter ﬁles, so that only certain choices are displayed to the user, by
passing a javax.swing .ﬁlechooser.F ileF ilter object to setF ileF ilter(). This allows you, for exam-
ple, to tell the JF ileChooser to display only ﬁles that have an extension of .htm or .html.
The default FileF ilter is one that display all ﬁles. You can obtain an instance of it by call-
ing getAcceptAllF ileF ilter(). You can provide a set of ﬁle ﬁlters for the user to choose from
by setting the choosableF ileF ilters pr operty to an array of FileF ilter objects.
In addition to ﬁle ﬁlters, JF ileChooser pr ovides another powerful way to customize the
ﬁle selection dialog. The accessor y pr operty allows you to specify a JComponent ﬁle selec-
tion accessory to be displayed within the JF ileChooser. Such accessories are typically
used as ﬁle previewers. For example, you might write an accessory to display a thumb-
nail version of a selected image ﬁle. The accessory object must register a Proper tyChange-
Listener on the JF ileChooser, so that it can receive notiﬁcation of changes in the selectedF ile
pr operty.
public class JF ileChooser extends JComponent implements Accessible {
// Public Constructors
public JF ileChooser();
public JF ileChooser(javax.swing .ﬁlechooser.F ileSystemV ie w fsv);
public JF ileChooser(java.io.F ile currentDirectory);
public JF ileChooser(String currentDirectoryPath);
public JF ileChooser(java.io.F ile currentDirectory, javax.swing .ﬁlechooser.F ileSystemV ie w fsv);
public JF ileChooser(String currentDirectoryPath, javax.swing .ﬁlechooser.F ileSystemV ie w fsv);
// Public Constants
="AccessoryChangedProper ty"
public static ﬁnal String ACCESSORY_CHANGED_PROPERTY;
="ApproveButtonMnemonicChangedProper ty"
public static ﬁnal String
APPROVE_BUTTON_MNEMONIC_CHANGED_PROPERTY;
="ApproveButtonTextChangedProper ty"
public static ﬁnal String
APPROVE_BUTTON_TEXT_CHANGED_PROPERTY;
="ApproveButtonToolTipTextChangedProper ty"
public static ﬁnal String
APPROVE_BUTTON_TOOL_TIP_TEXT_CHANGED_PROPERTY;
=0
public static ﬁnal int APPROVE_OPTION;
="ApproveSelection"
public static ﬁnal String APPROVE_SELECTION;
=1
public static ﬁnal int CANCEL_OPTION;
="CancelSelection"
public static ﬁnal String CANCEL_SELECTION;
="ChoosableF ileF ilterChangedProper ty"
public static ﬁnal String
CHOOSABLE_FILE_FILTER_CHANGED_PROPERTY;
=2
public static ﬁnal int CUSTOM_DIALOG;
="DialogTitleChangedProper ty"
public static ﬁnal String DIALOG_TITLE_CHANGED_PROPERTY;
="DialogTypeChangedProper ty"
public static ﬁnal String DIALOG_TYPE_CHANGED_PROPERTY;
=1
public static ﬁnal int DIRECTORIES_ONLY;
="directoryChanged"
public static ﬁnal String DIRECTORY_CHANGED_PROPERTY;
=-1
public static ﬁnal int ERROR_OPTION;
="ﬁleF ilterChanged"
public static ﬁnal String FILE_FILTER_CHANGED_PROPERTY;
="F ileHidingChanged"
public static ﬁnal String FILE_HIDING_CHANGED_PROPERTY;
="ﬁleSelectionChanged"
public static ﬁnal String FILE_SELECTION_MODE_CHANGED_PROPERTY;
="F ileSystemViewChanged"
public static ﬁnal String FILE_SYSTEM_VIEW_CHANGED_PROPERTY;
javax.swing
javax.swing.JFileChooser
Chapter 23 – The javax.swing Package
441

="ﬁleViewChanged"
public static ﬁnal String FILE_VIEW_CHANGED_PROPERTY;
=2
public static ﬁnal int FILES_AND_DIRECTORIES;
=0
public static ﬁnal int FILES_ONLY;
="ﬁleF ilterChanged"
public static ﬁnal String MULTI_SELECTION_ENABLED_CHANGED_PROPERTY;
=0
public static ﬁnal int OPEN_DIALOG;
=1
public static ﬁnal int SAVE_DIALOG;
="SelectedF ileChangedProper ty"
public static ﬁnal String SELECTED_FILE_CHANGED_PROPERTY;
="SelectedF ilesChangedProper ty"
public static ﬁnal String SELECTED_FILES_CHANGED_PROPERTY;
// Inner Classes
protected class AccessibleJF ileChooser extends JComponent.AccessibleJComponent;
// Event Registration Methods (by event name)
public void addActionListener(java.awt.e vent.ActionListener l);
public void removeActionListener(java.awt.e vent.ActionListener l);
// Property Accessor Methods (by property name)
public javax.swing.ﬁlechooser.F ileF ilter getAcceptAllF ileF ilter();
Implements:Accessible default:AccessibleJFileChooser
public AccessibleContext getAccessibleContext();
default:null
public JComponent getAccessor y();
bound preferred
public void setAccessor y(JComponent newAccessory);
default:0
public int getApproveButtonMnemonic();
bound preferred
public void setApproveButtonMnemonic(int mnemonic);
public void setApproveButtonMnemonic(char mnemonic);
default:null
public String getApproveButtonText();
bound preferred
public void setApproveButtonText(String approveButtonText);
default:null
public String getApproveButtonToolT ipText();
bound preferred
public void setApproveButtonToolT ipText(String toolTipText);
public javax.swing.ﬁlechooser.F ileF ilter[ ] getChoosableF ileF ilters();
public java.io.File getCur rentDirectory();
bound preferred
public void setCur rentDirectory(java.io.F ile dir);
default:null
public String getDialogT itle();
bound preferred
public void setDialogT itle(String dialogTitle);
default:0
public int getDialogType();
bound preferred
public void setDialogType(int dialogType);
default:false
public boolean isDirector ySelectionEnabled();
public javax.swing.ﬁlechooser.F ileF ilter getF ileF ilter();
bound preferred
public void setF ileF ilter(javax.swing .ﬁlechooser.F ileF ilter ﬁlter);
default:true
public boolean isF ileHidingEnabled();
bound preferred
public void setF ileHidingEnabled(boolean b);
default:true
public boolean isF ileSelectionEnabled();
default:0
public int getF ileSelectionMode();
bound preferred
public void setF ileSelectionMode(int mode);
public javax.swing.ﬁlechooser.F ileSystemV ie w getF ileSystemV iew();
bound expert
public void setF ileSystemV iew(javax.swing .ﬁlechooser.F ileSystemV ie w fsv);
default:null
public javax.swing.ﬁlechooser.F ileV ie w getF ileV iew();
bound preferred
public void setF ileV iew(javax.swing .ﬁlechooser.F ileV ie w ﬁleView);
default:false
public boolean isMultiSelectionEnabled();
bound
public void setMultiSelectionEnabled(boolean b);
default:null
public java.io.File getSelectedF ile();
bound preferred
public void setSelectedF ile(java.io.F ile ﬁle);
public java.io.File[ ] getSelectedF iles();
bound
public void setSelectedF iles(java.io.F ile[ ] selectedF iles);
public javax.swing.plaf.F ileChooserUI getUI();
Overrides:JComponent default:"FileChooserUI" expert
public String getUIClassID();
// Public Instance Methods
public boolean accept(java.io.F ile f);
bound preferred
public void addChoosableF ileF ilter(javax.swing .ﬁlechooser.F ileF ilter ﬁlter);
public void approveSelection();
public void cancelSelection();
public void changeToParentDirector y();
javax.swing.JFileChooser
442 Chapter 23 – The javax.swing Package

public void ensureF ileIsV isible(java.io.F ile f);
public String getDescription(java.io.F ile f);
public Icon getIcon(java.io.F ile f);
public String getName(java.io.F ile f);
public String getTypeDescription(java.io.F ile f);
public boolean isTraversable(java.io.F ile f);
public boolean removeChoosableF ileF ilter(javax.swing .ﬁlechooser.F ileF ilter f);
public void rescanCur rentDirectory();
public void resetChoosableF ileF ilters();
public int showDialog(Component parent, String approveButtonText);
public int showOpenDialog(Component parent);
public int showSaveDialog(Component parent);
// Methods Implementing Accessible
default:AccessibleJF ileChooser
public AccessibleContext getAccessibleContext();
// Public Methods Overriding JComponent
public void updateUI();
// Protected Methods Overriding JComponent
protected String paramString();
// Protected Instance Methods
protected void ﬁreActionPerfor med(String command);
protected void setup(javax.swing .ﬁlechooser.F ileSystemV ie w view);
// Protected Instance Fields
protected AccessibleContext accessibleContext;
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→JComponent(Serializable)→JF ileChooser(Accessible)
Passed To: javax.swing .plaf.FileChooserUI.{ensureF ileIsV isible(), getAcceptAllF ileF ilter(),
getApproveButtonText(), getDialogT itle(), getF ileV iew(), rescanCurrentDirector y()}
JFrame
Ja va 1.2
javax.swing
serializable accessible swing component bean container
This class is used to display the main window (or windows) of a Swing application.
Every JFrame has a single automatically created JRootPane child. You should not add chil-
dr en dir ectly to the JFrame, but instead call getContentPane() and add children to the con-
tainer retur ned by that method. Similarly, if you set a layout manager, you should do so
on the container retur ned by getContentPane(). The default layout manager for this con-
tainer is an instance of java.awt.BorderLayout.
The JFrame has two other features of interest. First, setJMenuBar() automatically places a
speciﬁed menubar at the top of the window, leaving the content pane free for other
application content. Second, setDefaultCloseOperation() speciﬁes how the window should
respond when the user attempts to close it (e.g., by typing Alt-F4 in Windows). The
argument to this method should be one of the constants deﬁned by javax.swing .Window-
Constants. The default is HIDE_ON_CLOSE. In addition to these features, JFrame also inher-
its useful methods from java.awt.Frame, including setCursor(), setIconImage(), setResizable(),
and setT itle().
JFrame uses a heavyweight native window. To create a lightweight window that appears
entir ely within the conﬁnes of a containing window, you can use JInter nalFrame.
public class JFrame extends java.awt.Frame implements Accessible, RootPaneContainer, WindowConstants {
// Public Constructors
public JFrame();
public JFrame(String title);
javax.swing
javax.swing.JFrame
Chapter 23 – The javax.swing Package
443

// Inner Classes
protected class AccessibleJFrame extends AccessibleContext implements AccessibleComponent, Serializable;
// Property Accessor Methods (by property name)
Implements:Accessible default:AccessibleJFrame
public AccessibleContext getAccessibleContext();
Implements:RootPaneContainer default:JPanel
public Container getContentPane();
Implements:RootPaneContainer hidden
public void setContentPane(Container contentPane);
default:1
public int getDefaultCloseOperation();
preferred
public void setDefaultCloseOperation(int operation);
Implements:RootPaneContainer default:JPanel
public Component getGlassPane();
Implements:RootPaneContainer hidden
public void setGlassPane(Component glassPane);
default:null
public JMenuBar getJMenuBar();
hidden
public void setJMenuBar(JMenuBar menubar);
Implements:RootPaneContainer
public JLayeredPane getLayeredPane();
Implements:RootPaneContainer hidden
public void setLayeredPane(JLayeredPane layeredPane);
Overrides:Container
public void setLayout(java.awt.LayoutManager manager);
Implements:RootPaneContainer
public JRootPane getRootPane();
// Methods Implementing Accessible
default:AccessibleJFrame
public AccessibleContext getAccessibleContext();
// Methods Implementing RootPaneContainer
default:JPanel
public Container getContentPane();
default:JPanel
public Component getGlassPane();
public JLayeredPane getLayeredPane();
public JRootPane getRootPane();
hidden
public void setContentPane(Container contentPane);
hidden
public void setGlassPane(Component glassPane);
hidden
public void setLayeredPane(JLayeredPane layeredPane);
// Protected Methods Overriding Frame
protected String paramString();
// Protected Methods Overriding Window
protected void processW indowEvent(java.awt.e vent.WindowEvent e);
// Public Methods Overriding Container
public void remove(Component comp);
public void update(java.awt.Graphics g);
// Protected Methods Overriding Container
protected void addImpl(Component comp, Object constraints, int index);
// Protected Methods Overriding Component
protected void processKeyEvent(java.awt.e vent.Ke yEvent e);
// Protected Instance Methods
protected JRootPane createRootPane();
protected void frameInit();
protected boolean isRootPaneCheckingEnabled();
hidden
protected void setRootPane(JRootPane root);
hidden
protected void setRootPaneCheckingEnabled(boolean enabled);
// Protected Instance Fields
protected AccessibleContext accessibleContext;
protected JRootPane rootPane;
protected boolean rootPaneCheckingEnabled;
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→java.awt.W indow→java.awt.Frame(java.awt.MenuContainer)→JFrame(Accessible,
RootPaneContainer, WindowConstants)
JInter nalFrame
Ja va 1.2
javax.swing
serializable accessible(value) swing component bean container
This class is a lightweight Swing component that simulates a heavyweight native win-
dow, complete with titlebar and other window decorations appropriate to the installed
javax.swing.JFrame
444 Chapter 23 – The javax.swing Package

look-and-feel. Because it is a lightweight component, with no native window of its
own, a JInter nalFrame is constrained to stay within the bounds of its container. This con-
tainer is typically a JDesktopPane. Within a JDesktopPane, a JInter nalFrame can be moved,
resized, iconiﬁed, and maximized, much like a JFrame can be.
JInter nalFrame is like JFrame in many ways. A JInter nalFrame has a JRootPane as its only
child. Components should not be added directly to a JInter nalFrame, but rather to the
container retur ned by getContentPane(). setJMenuBar() speciﬁes a menubar for the
lightweight window, and setDefaultCloseOperation() speciﬁes how it should respond when
the user closes it. See JFrame for more on these two methods.
setT itle() sets the title displayed in the internal frame’s titlebar. setFrameIcon() speciﬁes a
small image to be displayed in the titlebar and possibly also in the iconiﬁed repr esenta-
tion of the JInter nalFrame. setIconiﬁable() speciﬁes whether the user is allowed to iconify
the window, setIcon() actually iconiﬁes or deiconiﬁes the window, and isIcon() queries
whether the window is currently iconiﬁed. setDesktopIcon() speciﬁes the internal JInter nal-
Frame.JDesktopIcon object used to repr esent the iconiﬁed version of the JInter nalFrame.
This last method should not be used by application-level code.
Similarly, setMaximizable() speciﬁes whether the user can maximize the window, and set-
Maximum() maximizes the window. setResizable() speciﬁes whether the window can be
resized. setSelected() selects or deselects the window, and toFront() and toBack() move the
window to the top and bottom of the stacking order relative to other JInter nalFrame win-
dows. Finally, as with all components, setV isible() makes the window visible or invisible.
public class JInter nalFrame extends JComponent implements Accessible, RootPaneContainer, WindowConstants {
// Public Constructors
public JInter nalFrame();
public JInter nalFrame(String title);
public JInter nalFrame(String title, boolean resizable);
public JInter nalFrame(String title, boolean resizable, boolean closable);
public JInter nalFrame(String title, boolean resizable, boolean closable, boolean maximizable);
public JInter nalFrame(String title, boolean resizable, boolean closable, boolean maximizable, boolean iconiﬁable);
// Public Constants
="contentPane"
public static ﬁnal String CONTENT_PANE_PROPERTY;
="frameIcon"
public static ﬁnal String FRAME_ICON_PROPERTY;
="glassPane"
public static ﬁnal String GLASS_PANE_PROPERTY;
="closed"
public static ﬁnal String IS_CLOSED_PROPERTY;
="icon"
public static ﬁnal String IS_ICON_PROPERTY;
="maximum"
public static ﬁnal String IS_MAXIMUM_PROPERTY;
="selected"
public static ﬁnal String IS_SELECTED_PROPERTY;
="layeredPane"
public static ﬁnal String LAYERED_PANE_PROPERTY;
="menuBar"
public static ﬁnal String MENU_BAR_PROPERTY;
="rootPane"
public static ﬁnal String ROOT_PANE_PROPERTY;
="title"
public static ﬁnal String TITLE_PROPERTY;
// Inner Classes
protected class AccessibleJInter nalFrame extends JComponent.AccessibleJComponent implements
AccessibleValue;
public static class JDesktopIcon extends JComponent implements Accessible;
// Event Registration Methods (by event name)
public void addInter nalFrameListener(javax.swing .event.InternalFrameListener l);
public void removeInter nalFrameListener(javax.swing .event.InternalFrameListener l);
// Property Accessor Methods (by property name)
Implements:Accessible default:AccessibleJInternalFrame
public AccessibleContext getAccessibleContext();
default:false
public boolean isClosable();
bound preferred
public void setClosable(boolean b);
default:false
public boolean isClosed();
bound constrained
public void setClosed(boolean b) throws java.beans.PropertyVetoException;
Implements:RootPaneContainer default:JPanel
public Container getContentPane();
javax.swing
javax.swing.JInter nalFrame
Chapter 23 – The javax.swing Package
445

Implements:RootPaneContainer bound hidden
public void setContentPane(Container c);
default:1
public int getDefaultCloseOperation();
public void setDefaultCloseOperation(int operation);
public JInternalFrame.JDesktopIcon getDesktopIcon();
bound
public void setDesktopIcon(JInternalFrame.JDesktopIcon d);
default:null
public JDesktopPane getDesktopPane();
public Icon getFrameIcon();
bound
public void setFrameIcon(Icon icon);
Implements:RootPaneContainer default:JPanel
public Component getGlassPane();
Implements:RootPaneContainer hidden
public void setGlassPane(Component glass);
default:false
public boolean isIcon();
bound constrained
public void setIcon(boolean b) throws java.beans.PropertyVetoException;
default:false
public boolean isIconiﬁable();
public void setIconiﬁable(boolean b);
default:null
public JMenuBar getJMenuBar();
preferred
public void setJMenuBar(JMenuBar m);
default:0
public int getLayer();
exper t
public void setLayer(Integer layer);
Implements:RootPaneContainer
public JLayeredPane getLayeredPane();
Implements:RootPaneContainer bound hidden
public void setLayeredPane(JLayeredPane layered);
Overrides:Container
public void setLayout(java.awt.LayoutManager manager);
default:false
public boolean isMaximizable();
bound preferred
public void setMaximizable(boolean b);
default:false
public boolean isMaximum();
constrained
public void setMaximum(boolean b) throws java.beans.PropertyVetoException;
default:false
public boolean isResizable();
bound preferred
public void setResizable(boolean b);
Implements:RootPaneContainer
public JRootPane getRootPane();
default:false
public boolean isSelected();
bound constrained
public void setSelected(boolean selected) throws java.beans.PropertyVetoException;
default:""
public String getT itle();
public void setT itle(String title);
public javax.swing.plaf.InternalFrameUI getUI();
exper t
public void setUI(javax.swing .plaf.InternalFrameUI ui);
Overrides:JComponent default:"InternalFrameUI"
public String getUIClassID();
constant default:null
public ﬁnal String getWar ningString();
// Public Instance Methods
public void dispose();
public void moveToBack();
public void moveToFront();
public void pack();
public void toBack();
public void toFront();
// Methods Implementing Accessible
default:AccessibleJInternalFrame
public AccessibleContext getAccessibleContext();
// Methods Implementing RootPaneContainer
default:JPanel
public Container getContentPane();
default:JPanel
public Component getGlassPane();
public JLayeredPane getLayeredPane();
public JRootPane getRootPane();
bound hidden
public void setContentPane(Container c);
hidden
public void setGlassPane(Component glass);
bound hidden
public void setLayeredPane(JLayeredPane layered);
// Public Methods Overriding JComponent
public void reshape(int x, int y, int width, int height);
public void setV isible(boolean b);
public void updateUI();
javax.swing.JInter nalFrame
446 Chapter 23 – The javax.swing Package

// Protected Methods Overriding JComponent
protected void paintComponent(java.awt.Graphics g);
protected String paramString();
// Public Methods Overriding Container
public void remove(Component comp);
// Protected Methods Overriding Container
protected void addImpl(Component comp, Object constraints, int index);
// Public Methods Overriding Component
public void show();
// Protected Instance Methods
protected JRootPane createRootPane();
protected void ﬁreInter nalFrameEvent(int id);
protected boolean isRootPaneCheckingEnabled();
hidden
protected void setRootPane(JRootPane root);
protected void setRootPaneCheckingEnabled(boolean enabled);
// Protected Instance Fields
protected boolean closable;
protected JInternalFrame.JDesktopIcon desktopIcon;
protected Icon frameIcon;
protected boolean iconable;
protected boolean isClosed;
protected boolean isIcon;
protected boolean isMaximum;
protected boolean isSelected;
protected boolean maximizable;
protected boolean resizable;
protected JRootPane rootPane;
protected boolean rootPaneCheckingEnabled;
protected String title;
// Deprecated Public Methods
default:null
# public JMenuBar getMenuBar();
# public void setMenuBar(JMenuBar m);
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→JComponent(Serializable)→JInter nalFrame(Accessible, RootPaneContainer, WindowConstants)
Passed To: Too many methods to list.
Retur ned By: JDesktopPane.{getAllFrames(), getAllFramesInLayer()},
JInter nalFrame.JDesktopIcon.getInter nalFrame(), JOptionPane.createInter nalFrame()
JInter nalFrame.JDesktopIcon
Ja va 1.2
javax.swing
serializable accessible swing component
This inner class repr esents an iconiﬁed version of a JInter nalFrame to be displayed by a
JDesktopPane. The appearance of the JDesktopIcon is left entirely to the current look-and-
feel, and JDesktopIcon does not deﬁne any properties you can set to change its appear-
ance. JDesktopIcon may be removed in future versions of Swing; it should not be used
by application-level code.
public static class JInter nalFrame.JDesktopIcon extends JComponent implements Accessible {
// Public Constructors
public JDesktopIcon(JInternalFrame f);
// Inner Classes
protected class AccessibleJDesktopIcon extends JComponent.AccessibleJComponent implements
AccessibleValue;
javax.swing
javax.swing.JInter nalFrame.JDesktopIcon
Chapter 23 – The javax.swing Package
447

// Property Accessor Methods (by property name)
Implements:Accessible
public AccessibleContext getAccessibleContext();
public JDesktopPane getDesktopPane();
public JInternalFrame getInter nalFrame();
public void setInter nalFrame(JInternalFrame f);
public javax.swing.plaf.DesktopIconUI getUI();
public void setUI(javax.swing .plaf.DesktopIconUI ui);
Overrides:JComponent
public String getUIClassID();
// Methods Implementing Accessible
public AccessibleContext getAccessibleContext();
// Public Methods Overriding JComponent
public void updateUI();
}
Passed To: JInter nalFrame.setDesktopIcon()
Retur ned By: JInter nalFrame.getDesktopIcon()
Type Of: JInter nalFrame.desktopIcon
JLabel
Ja va 1.2
javax.swing
serializable accessible swing component
This class displays a short string of text and/or an Icon. JLabel is a display-only compo-
nent with no behavior, so the displayed text and/or icon does not respond to any input
events. JLabel does not maintain any state and therefor e does not use a model. By
default, a JLabel displays a single line of text in a single font. However, as of Swing 1.1.1
and Java 1.2.2, if the text pr operty begins with “<html>”, the label is formatted as HTML
text and may contain multiple fonts and multiple lines.
The icon, text, and font pr operties need no explanation. disabledIcon speciﬁes an alternate
icon to display when the JLabel is disabled. By default, a grayscale version of the regu-
lar icon is used. horizontalAlignment and verticalAlignment specify the justiﬁcation of the
label, and horizontalTextPosition and verticalTextPosition specify the position of the text rela-
tive to the icon. Each of these properties should be set to one of the LEFT, CENTER, RIGHT,
TOP, or BO TTOM constants deﬁned by the SwingConstants inter face. The iconTextGap pr operty
speciﬁes the number of pixels between the text and the icon.
Although JLabel does not have any behavior of its own, it can display a mnemonic char-
acter. If the displayedMnemonic pr operty is set, the speciﬁed character is underlined in the
label. If the labelFor pr operty refers to another component, the JLabel requests keyboard
focus for that component when the mnemonic is used. This is useful for labeling
JTextF ield components, for example.
public class JLabel extends JComponent implements Accessible, SwingConstants {
// Public Constructors
public JLabel();
public JLabel(Icon image);
public JLabel(String text);
public JLabel(Icon image, int horizontalAlignment);
public JLabel(String text, int horizontalAlignment);
public JLabel(String text, Icon icon, int horizontalAlignment);
// Inner Classes
protected class AccessibleJLabel extends JComponent.AccessibleJComponent;
// Property Accessor Methods (by property name)
Implements:Accessible default:AccessibleJLabel expert
public AccessibleContext getAccessibleContext();
default:null
public Icon getDisabledIcon();
bound
public void setDisabledIcon(Icon disabledIcon);
javax.swing.JInter nalFrame.JDesktopIcon
448 Chapter 23 – The javax.swing Package

default:0
public int getDisplayedMnemonic();
bound
public void setDisplayedMnemonic(int key);
public void setDisplayedMnemonic(char aChar);
default:10
public int getHorizontalAlignment();
bound
public void setHorizontalAlignment(int alignment);
default:11
public int getHorizontalTextPosition();
bound expert
public void setHorizontalTextPosition(int textPosition);
default:null
public Icon getIcon();
bound preferred
public void setIcon(Icon icon);
default:4
public int getIconTextGap();
bound
public void setIconTextGap(int iconTextGap);
default:null
public Component getLabelFor();
bound
public void setLabelFor(Component c);
default:""
public String getText();
bound preferred
public void setText(String text);
public javax.swing.plaf.LabelUI getUI();
exper t
public void setUI(javax.swing .plaf.LabelUI ui);
Overrides:JComponent default:"LabelUI"
public String getUIClassID();
default:0
public int getVer ticalAlignment();
bound
public void setVer ticalAlignment(int alignment);
default:0
public int getVer ticalTextPosition();
bound expert
public void setVer ticalTextPosition(int textPosition);
// Methods Implementing Accessible
default:AccessibleJLabel expert
public AccessibleContext getAccessibleContext();
// Public Methods Overriding JComponent
public void updateUI();
// Protected Methods Overriding JComponent
protected String paramString();
// Protected Instance Methods
protected int checkHorizontalKey(int key, String message);
protected int checkVer ticalKey(int key, String message);
// Protected Instance Fields
protected Component labelFor;
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→JComponent(Serializable)→JLabel(Accessible, SwingConstants)
Subc lasses: DefaultListCellRenderer, javax.swing .table.DefaultTableCellRenderer,
javax.swing .tree.DefaultTreeCellRenderer
JLayeredPane
Ja va 1.2
javax.swing
serializable accessible swing component
This class is a Swing container that layers its children according to a speciﬁed stacking
order. When you add a child to a JLayeredPane, you specify an Integer as the constraints
argument to the add() methods. This Integer object speciﬁes the layer number for the
child, where higher numbers are near er the top of the stack. JLayeredPane deﬁnes a
number of _LAYER constants as predeﬁned layers. The layer of a child can also be set
with setLayer(). If multiple children are in the same layer, their relative stacking order is
deter mined by their insertion order. This position within a layer can be modiﬁed with
setPosition(), moveToFront(), and moveToBack(). JLayeredPane is typically used without a layout
manager; children have their size and position explicitly set.
All JFrame, JDialog, JApplet, and JInter nalFrame objects contain a JRootPane which, in turn,
contains a JLayeredPane. This internal JLayeredPane is used to correctly layer lightweight
menus, dialogs, ﬂoating palettes, internal frames, and so forth.
javax.swing
javax.swing.JLayeredPane
Chapter 23 – The javax.swing Package
449

public class JLayeredPane extends JComponent implements Accessible {
// Public Constructors
public JLayeredPane();
// Public Constants
public static ﬁnal Integer DEFAULT_LAYER;
public static ﬁnal Integer DRAG_LAYER;
public static ﬁnal Integer FRAME_CONTENT_LAYER;
="layeredContainerLayer"
public static ﬁnal String LAYER_PROPERTY;
public static ﬁnal Integer MODAL_LAYER;
public static ﬁnal Integer PALETTE_LAYER;
public static ﬁnal Integer POPUP_LAYER;
// Inner Classes
protected class AccessibleJLayeredPane extends JComponent.AccessibleJComponent;
// Public Class Methods
public static int getLayer(JComponent c);
public static JLayeredPane getLayeredPaneAbove(Component c);
public static void putLayer(JComponent c, int layer);
// Property Accessor Methods (by property name)
Implements:Accessible default:AccessibleJLayeredPane
public AccessibleContext getAccessibleContext();
Overrides:JComponent default:true
public boolean isOptimizedDrawingEnabled();
// Public Instance Methods
public int getComponentCountInLayer(int layer);
public Component[ ] getComponentsInLayer(int layer);
public int getIndexOf(Component c);
public int getLayer(Component c);
public int getPosition(Component c);
public int highestLayer();
public int lowestLayer();
public void moveToBack(Component c);
public void moveToFront(Component c);
public void setLayer(Component c, int layer);
public void setLayer(Component c, int layer, int position);
public void setPosition(Component c, int position);
// Methods Implementing Accessible
default:AccessibleJLayeredPane
public AccessibleContext getAccessibleContext();
// Public Methods Overriding JComponent
public void paint(java.awt.Graphics g);
// Protected Methods Overriding JComponent
protected String paramString();
// Public Methods Overriding Container
public void remove(int index);
// Protected Methods Overriding Container
protected void addImpl(Component comp, Object constraints, int index);
// Protected Instance Methods
protected java.util.Hashtable getComponentToLayer();
protected Integer getObjectForLayer(int layer);
protected int inser tIndexForLayer(int layer, int position);
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→JComponent(Serializable)→JLayeredPane(Accessible)
Subc lasses: JDesktopPane
Passed To: JApplet.setLayeredPane(), JDialog.setLayeredPane(), JFrame.setLayeredPane(),
JInter nalFrame.setLayeredPane(), JRootPane.setLayeredPane(), JWindow.setLayeredPane(),
RootPaneContainer.setLayeredPane()
javax.swing.JLayeredPane
450 Chapter 23 – The javax.swing Package

Retur ned By: JApplet.getLayeredPane(), JDialog.getLayeredPane(), JFrame.getLayeredPane(),
JInter nalFrame.getLayeredPane(), JLayeredPane.getLayeredPaneAbove(), JRootPane.{createLayeredPane(),
getLayeredPane()}, JWindow.getLayeredPane(), RootPaneContainer.getLayeredPane()
Type Of: JRootPane.layeredPane
JList
Ja va 1.2
javax.swing
serializable accessible(selection) swing component
This class displays a list of items (typically strings) and allows the user to select one or
mor e of them. The objects to be displayed are stor ed in a ListModel object. Two JList
constructors allow list items to be speciﬁed as a static array or Vector of objects, how-
ever. For a dynamic list of elements, you may want to use your own instance of Default-
ListModel, which maintains a Vector-like list of objects. By default, JList displays lists of
strings. To display other types of list items, deﬁne an appropriate ListCellRenderer class
and pass an instance of it to setCellRenderer().
The selection state of the JList is maintained by a ListSelectionModel object. By default,
JList uses a DefaultListSelectionModel object. Application programmers rarely need to work
with the ListSelectionModel dir ectly because JList pr ovides a number of methods to query
and set the selection state. setSelectionMode() speciﬁes the types of selections allowed by
the JList. Its argument should be one of the three constants deﬁned by ListSelectionModel.
SINGLE_SELECTION allows only a single item to be selected, while SINGLE_INTERVAL_SELEC-
TION allows multiple items in a single contiguous block to be selected and MULTI-
PLE_INTERVAL_SELECTION allows any number of items, contiguous or not, to be selected.
JList generates a javax.swing .event.ListSelectionEvent when the selection state changes and
sends it to the valueChanged() methods of any register ed javax.swing .event.ListSelectionListener
objects.
public class JList extends JComponent implements Accessible, Scrollable {
// Public Constructors
public JList();
public JList(Object[ ] listData);
public JList(ListModel dataModel);
public JList(java.util.Vector listData);
// Inner Classes
protected class AccessibleJList extends JComponent.AccessibleJComponent implements AccessibleSelection,
javax.swing .event.ListDataListener, javax.swing .event.ListSelectionListener, java.beans.Proper tyChangeListener;
// Event Registration Methods (by event name)
public void addListSelectionListener(javax.swing .event.ListSelectionListener listener);
public void removeListSelectionListener(javax.swing .event.ListSelectionListener listener);
// Property Accessor Methods (by property name)
Implements:Accessible default:AccessibleJList
public AccessibleContext getAccessibleContext();
default:-1
public int getAnchorSelectionIndex();
default:DefaultListCellRenderer.UIResource
public ListCellRenderer getCellRenderer();
bound
public void setCellRenderer(ListCellRenderer cellRenderer);
default:-1
public int getF irstV isibleIndex();
default:-1
public int getF ixedCellHeight();
bound
public void setF ixedCellHeight(int height);
default:-1
public int getF ixedCellWidth();
bound
public void setF ixedCellWidth(int width);
default:-1
public int getLastV isibleIndex();
default:-1
public int getLeadSelectionIndex();
default:-1
public int getMaxSelectionIndex();
default:-1
public int getMinSelectionIndex();
public ListModel getModel();
bound
public void setModel(ListModel model);
javax.swing
javax.swing.JList
Chapter 23 – The javax.swing Package
451

Implements:Scrollable
public java.awt.Dimension getPrefer redScrollableViewpor tSize();
default:null
public Object getPrototypeCellValue();
bound
public void setPrototypeCellValue(Object prototypeCellValue);
Implements:Scrollable default:false
public boolean getScrollableTracksV iewportHeight();
Implements:Scrollable default:false
public boolean getScrollableTracksV iewportW idth();
default:-1
public int getSelectedIndex();
public void setSelectedIndex(int index);
public int[ ] getSelectedIndices();
public void setSelectedIndices(int[ ] indices);
default:null
public Object getSelectedValue();
public Object[ ] getSelectedValues();
default:ColorUIResource
public java.awt.Color getSelectionBackground();
bound
public void setSelectionBackground(java.awt.Color selectionBackground);
default:true
public boolean isSelectionEmpty();
default:ColorUIResource
public java.awt.Color getSelectionForeground();
bound
public void setSelectionForeground(java.awt.Color selectionForeground);
default:2
public int getSelectionMode();
public void setSelectionMode(int selectionMode);
default:DefaultListSelectionModel
public ListSelectionModel getSelectionModel();
bound
public void setSelectionModel(ListSelectionModel selectionModel);
public javax.swing.plaf.ListUI getUI();
public void setUI(javax.swing .plaf.ListUI ui);
Overrides:JComponent default:"ListUI"
public String getUIClassID();
default:false
public boolean getValueIsAdjusting();
public void setValueIsAdjusting(boolean b);
default:8
public int getV isibleRowCount();
bound
public void setV isibleRowCount(int visibleRowCount);
// Public Instance Methods
public void addSelectionInter val(int anchor, int lead);
public void clearSelection();
public void ensureIndexIsV isible(int index);
public java.awt.Rectangle getCellBounds(int index1, int index2);
public java.awt.Point indexToLocation(int index);
public boolean isSelectedIndex(int index);
public int locationToIndex(java.awt.Point location);
public void removeSelectionInter val(int index0, int index1);
public void setListData(Object[ ] listData);
public void setListData(java.util.Vector listData);
public void setSelectedValue(Object anObject, boolean shouldScroll);
public void setSelectionInter val(int anchor, int lead);
// Methods Implementing Accessible
default:AccessibleJList
public AccessibleContext getAccessibleContext();
// Methods Implementing Scrollable
public java.awt.Dimension getPrefer redScrollableViewpor tSize();
public int getScrollableBlockIncrement(java.awt.Rectangle visibleRect, int orientation, int direction);
default:false
public boolean getScrollableTracksV iewportHeight();
default:false
public boolean getScrollableTracksV iewportW idth();
public int getScrollableUnitIncrement(java.awt.Rectangle visibleRect, int orientation, int direction);
// Public Methods Overriding JComponent
public void updateUI();
// Protected Methods Overriding JComponent
protected String paramString();
// Protected Instance Methods
protected ListSelectionModel createSelectionModel();
protected void ﬁreSelectionValueChanged(int ﬁrstIndex, int lastIndex, boolean isAdjusting);
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→JComponent(Serializable)→JList(Accessible, Scrollable)
javax.swing.JList
452 Chapter 23 – The javax.swing Package

Passed To: DefaultListCellRenderer.getListCellRendererComponent(),
JList.AccessibleJList.AccessibleJListChild.AccessibleJListChild(),
ListCellRenderer.getListCellRendererComponent(), javax.swing .plaf.ListUI.{getCellBounds(), indexToLocation(),
locationToIndex()}
JMenu
Ja va 1.2
javax.swing
serializable accessible(action,selection,value) swing component
This class implements a pulldown menu in a menubar or a pull-right menu nested
within another menu. As a subclass of JMenuItem, JMenu is effectively a menu button
with an associated JPopupMenu that appears when the button is activated. Menu items
can be added to a JMenu with the add(), inser t(), addSeparator(), and inser tSeparator() meth-
ods. Note that you can add String and Action objects in addition to regular JMenuItem
objects. In these cases, an appropriate JMenuItem is automatically created for the String or
Action. JMenu generates a javax.swing .event.MenuEvent when it is selected and when its
menu is popped up or down. The default JMenu model is DefaultButtonModel.
public class JMenu extends JMenuItem implements Accessible, MenuElement {
// Public Constructors
public JMenu();
public JMenu(String s);
public JMenu(String s, boolean b);
// Inner Classes
protected class AccessibleJMenu extends JMenuItem.AccessibleJMenuItem implements AccessibleSelection;
protected class WinListener extends java.awt.event.W indowAdapter implements Serializable;
// Event Registration Methods (by event name)
public void addMenuListener(javax.swing .event.MenuListener l);
public void removeMenuListener(javax.swing .event.MenuListener l);
// Property Accessor Methods (by property name)
Overrides:JMenuItem hidden
public void setAccelerator(KeyStroke keyStroke);
Implements:Accessible default:AccessibleJMenu
public AccessibleContext getAccessibleContext();
Implements:MenuElement default:JMenu
public Component getComponent();
default:200
public int getDelay();
exper t
public void setDelay(int d);
default:0
public int getItemCount();
default:0
public int getMenuComponentCount();
public Component[ ] getMenuComponents();
Overrides:AbstractButton bound expert hidden
public void setModel(ButtonModel newModel);
public JPopupMenu getPopupMenu();
default:false
public boolean isPopupMenuV isible();
exper t hidden
public void setPopupMenuV isible(boolean b);
Overrides:AbstractButton default:false
public boolean isSelected();
Overrides:AbstractButton expert hidden
public void setSelected(boolean b);
Implements:MenuElement
public MenuElement[ ] getSubElements();
public boolean isTearOff();
default:false
public boolean isTopLevelMenu();
Overrides:JMenuItem default:"MenuUI"
public String getUIClassID();
// Public Instance Methods
public JMenuItem add(String s);
public JMenuItem add(JMenuItem menuItem);
public JMenuItem add(Action a);
public void addSeparator();
public JMenuItem getItem(int pos);
public Component getMenuComponent(int n);
public void inser t(String s, int pos);
public JMenuItem inser t(JMenuItem mi, int pos);
public JMenuItem inser t(Action a, int pos);
public void inser tSeparator(int index);
javax.swing
javax.swing.JMenu
Chapter 23 – The javax.swing Package
453

public boolean isMenuComponent(Component c);
public void remove(JMenuItem item);
public void setMenuLocation(int x, int y);
// Methods Implementing Accessible
default:AccessibleJMenu
public AccessibleContext getAccessibleContext();
// Methods Implementing MenuElement
default:JMenu
public Component getComponent();
public MenuElement[ ] getSubElements();
public void menuSelectionChanged(boolean isIncluded);
// Public Methods Overriding JMenuItem
public void updateUI();
// Protected Methods Overriding JMenuItem
protected String paramString();
// Public Methods Overriding AbstractButton
public void doClick(int pressTime);
// Protected Methods Overriding JComponent
protected void processKeyEvent(java.awt.e vent.Ke yEvent e);
// Public Methods Overriding Container
public Component add(Component c);
public void remove(Component c);
public void remove(int pos);
public void removeAll();
// Protected Instance Methods
protected java.beans.PropertyChangeListener createActionChangeListener(JMenuItem b);
protected JMenu.WinListener createW inListener(JPopupMenu p);
protected void ﬁreMenuCanceled();
protected void ﬁreMenuDeselected();
protected void ﬁreMenuSelected();
// Protected Instance Fields
protected JMenu.WinListener popupListener;
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→JComponent(Serializable)→AbstractButton(java.awt.ItemSelectable, SwingConstants)→
JMenuItem(Accessible, MenuElement)→JMenu(Accessible, MenuElement)
Passed To: JMenuBar.{add(), setHelpMenu()}
Retur ned By: JMenuBar.{add(), getHelpMenu(), getMenu()}
JMenu.W inListener
Ja va 1.2
javax.swing
serializable
This protected inner class is a java.awt.event.W indowListener that is used internally by JMenu
to determine when the popup window containing the menu items closes. Application-
level code never needs to use this class.
protected class JMenu.W inListener extends java.awt.event.W indowAdapter implements Serializable {
// Public Constructors
public WinListener(JPopupMenu p);
// Public Methods Overriding WindowAdapter
public void windowClosing(java.awt.e vent.WindowEvent e);
}
Retur ned By: JMenu.createW inListener()
Type Of: JMenu.popupListener
javax.swing.JMenu
454 Chapter 23 – The javax.swing Package

JMenuBar
Ja va 1.2
javax.swing
serializable accessible(selection) swing component
This class implements a menu bar. JMenu objects are placed in a JMenuBar with the add()
method and can be removed with the remove() methods. A Help menu should be sin-
gled out for special treatment (typically by placing it at the right-hand edge of the
menu bar) with setHelpMenu(). JMenuBar uses a SingleSelectionModel object to keep track of
which of its JMenuItem childr en (if any) is currently selected. By default, JMenuBar uses a
DefaultSingleSelectionModel model object.
In AWT, the MenuBar class is not a Component. In Swing, JMenuBar is a JComponent and can
be laid out in an application like any other component. Note, however, that JFrame, JDia-
log, JApplet, and JInter nalFrame all have setJMenuBar() methods that automatically position a
JMenuBar at the top of the window. This is the easiest and most common way to lay out
a menu bar.
public class JMenuBar extends JComponent implements Accessible, MenuElement {
// Public Constructors
public JMenuBar();
// Inner Classes
protected class AccessibleJMenuBar extends JComponent.AccessibleJComponent implements
AccessibleSelection;
// Property Accessor Methods (by property name)
Implements:Accessible default:AccessibleJMenuBar
public AccessibleContext getAccessibleContext();
default:true
public boolean isBorderPainted();
bound
public void setBorderPainted(boolean b);
Implements:MenuElement default:JMenuBar
public Component getComponent();
public JMenu getHelpMenu();
public void setHelpMenu(JMenu menu);
Overrides:JComponent constant default:true
public boolean isManagingFocus();
public java.awt.Insets getMargin();
bound
public void setMargin(java.awt.Insets m);
default:0
public int getMenuCount();
default:false
public boolean isSelected();
public void setSelected(Component sel);
default:DefaultSingleSelectionModel
public SingleSelectionModel getSelectionModel();
bound
public void setSelectionModel(SingleSelectionModel model);
Implements:MenuElement
public MenuElement[ ] getSubElements();
public javax.swing.plaf.MenuBarUI getUI();
public void setUI(javax.swing .plaf.MenuBarUI ui);
Overrides:JComponent default:"MenuBarUI"
public String getUIClassID();
// Public Instance Methods
public JMenu add(JMenu c);
public Component getComponentAtIndex(int i);
public int getComponentIndex(Component c);
public JMenu getMenu(int index);
// Methods Implementing Accessible
default:AccessibleJMenuBar
public AccessibleContext getAccessibleContext();
// Methods Implementing MenuElement
default:JMenuBar
public Component getComponent();
public MenuElement[ ] getSubElements();
empty
public void menuSelectionChanged(boolean isIncluded);
empty
public void processKeyEvent(java.awt.e vent.Ke yEvent e, MenuElement[ ] path,
MenuSelectionManager manager);
empty
public void processMouseEvent(java.awt.e vent.MouseEvent event, MenuElement[ ] path,
MenuSelectionManager manager);
// Public Methods Overriding JComponent
public void addNotify();
javax.swing
javax.swing.JMenuBar
Chapter 23 – The javax.swing Package
455

public void removeNotify();
public void updateUI();
// Protected Methods Overriding JComponent
protected void paintBorder(java.awt.Graphics g);
protected String paramString();
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→JComponent(Serializable)→JMenuBar(Accessible, MenuElement)
Passed To: JApplet.setJMenuBar(), JDialog.setJMenuBar(), JFrame.setJMenuBar(),
JInter nalFrame.{setJMenuBar(), setMenuBar()}, JRootPane.{setJMenuBar(), setMenuBar()}
Retur ned By: JApplet.getJMenuBar(), JDialog.getJMenuBar(), JFrame.getJMenuBar(),
JInter nalFrame.{getJMenuBar(), getMenuBar()}, JRootPane.{getJMenuBar(), getMenuBar()}
Type Of: JRootPane.menuBar
JMenuItem
Ja va 1.2
javax.swing
serializable accessible(action,value) swing component
This class implements an item in a pulldown or popup menu. As a subclass of Abstract-
Button, it shar es most of the properties of JButton. One new feature is that it allows an
accelerator to be speciﬁed. An accelerator is a keyboard binding for the menu item.
Like all Swing buttons, JMenuItem also supports a mnemonic. Accelerators differ from
mnemonics in two important ways, however. First, accelerators can be used at any
time, while menu item mnemonics can be used only when the menu that contains
them is displayed. Second, accelerators are speciﬁed with a KeyStroke object, rather than
a simple character. This allows complex bindings that include function keys and arbi-
trary modiﬁer keys.
In addition to its AbstractButton functionality, JMenuItem also implements the MenuElement
inter face. The default JMenuItem model is DefaultButtonModel, and the UI delegate class is
MenuItemUI.
public class JMenuItem extends AbstractButton implements Accessible, MenuElement {
// Public Constructors
public JMenuItem();
public JMenuItem(Icon icon);
public JMenuItem(String text);
public JMenuItem(String text, Icon icon);
public JMenuItem(String text, int mnemonic);
// Inner Classes
protected class AccessibleJMenuItem extends AbstractButton.AccessibleAbstractButton implements
javax.swing .event.ChangeListener ;
// Event Registration Methods (by event name)
public void addMenuDragMouseListener(javax.swing .event.MenuDragMouseListener l);
public void removeMenuDragMouseListener(javax.swing .event.MenuDragMouseListener l);
public void addMenuKeyListener(javax.swing .event.MenuKe yListener l);
public void removeMenuKeyListener(javax.swing .event.MenuKe yListener l);
// Property Accessor Methods (by property name)
default:null
public KeyStroke getAccelerator();
bound preferred
public void setAccelerator(KeyStroke keyStroke);
Implements:Accessible default:AccessibleJMenuItem
public AccessibleContext getAccessibleContext();
default:false
public boolean isAr med();
hidden
public void setAr med(boolean b);
Implements:MenuElement default:JMenuItem
public Component getComponent();
Implements:MenuElement
public MenuElement[ ] getSubElements();
Overrides:JComponent default:"MenuItemUI"
public String getUIClassID();
javax.swing.JMenuBar
456 Chapter 23 – The javax.swing Package

// Public Instance Methods
public void processMenuDragMouseEvent(javax.swing .event.MenuDragMouseEvent e);
public void processMenuKeyEvent(javax.swing .event.MenuKe yEvent e);
bound expert hidden
public void setUI(javax.swing .plaf.MenuItemUI ui);
// Methods Implementing Accessible
default:AccessibleJMenuItem
public AccessibleContext getAccessibleContext();
// Methods Implementing MenuElement
default:JMenuItem
public Component getComponent();
public MenuElement[ ] getSubElements();
public void menuSelectionChanged(boolean isIncluded);
public void processKeyEvent(java.awt.e vent.Ke yEvent e, MenuElement[ ] path, MenuSelectionManager manager);
public void processMouseEvent(java.awt.e vent.MouseEvent e, MenuElement[ ] path,
MenuSelectionManager manager);
// Public Methods Overriding AbstractButton
bound preferred
public void setEnabled(boolean b);
public void updateUI();
// Protected Methods Overriding AbstractButton
protected void init(String text, Icon icon);
protected String paramString();
// Protected Instance Methods
protected void ﬁreMenuDragMouseDragged(javax.swing .event.MenuDragMouseEvent event);
protected void ﬁreMenuDragMouseEntered(javax.swing .event.MenuDragMouseEvent event);
protected void ﬁreMenuDragMouseExited(javax.swing .event.MenuDragMouseEvent event);
protected void ﬁreMenuDragMouseReleased(javax.swing .event.MenuDragMouseEvent event);
protected void ﬁreMenuKeyPressed(javax.swing .event.MenuKe yEvent event);
protected void ﬁreMenuKeyReleased(javax.swing .event.MenuKe yEvent event);
protected void ﬁreMenuKeyTyped(javax.swing .event.MenuKe yEvent event);
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→JComponent(Serializable)→AbstractButton(java.awt.ItemSelectable, SwingConstants)→
JMenuItem(Accessible, MenuElement)
Subc lasses: JCheckBoxMenuItem, JMenu, JRadioButtonMenuItem
Passed To: JMenu.{add(), createActionChangeListener(), insert(), remove()}, JPopupMenu.{add(),
createActionChangeListener()}
Retur ned By: JMenu.{add(), getItem(), insert()}, JPopupMenu.add()
JOptionPane
Ja va 1.2
javax.swing
serializable accessible swing component bean container
This component is used to display various types of simple dialog boxes to the user
(yes, its name is misleading). It is almost always used through one of the showXXXDialog()
static methods. The fact that there are more than 20 of these methods demonstrates the highly-conﬁgurable nature of
this class. The showInter nalXXXDialog() methods display dialogs in lightweight JInter nalFrame windows. The other
static methods display methods in heavyweight JDialog windows.
You can create and display a simple message dialog with showMessageDialog() and showIn-
ter nalMessageDialog(). These methods display a dialog box that contains the speciﬁed
message, an optional icon, and an Okay button that dismisses the dialog. The dialog is
modal, meaning it blocks, retur ning only when the user has dismissed the dialog. The
parentComponent argument speciﬁes the component that serves as the parent of the dialog
(the dialog typically pops up over this component), while title speciﬁes a string to
appear in the titlebar of the dialog. The message argument is more complex. It is
declar ed as an Object. You typically pass a String value, which is automatically displayed
in a JLabel. However, you can also specify an Icon, which is also displayed in a JLabel, or
any JComponent, which is displayed as is. Furthermor e, instead of specifying a single
javax.swing
javax.swing.JOptionPane
Chapter 23 – The javax.swing Package
457

message object, you can specify an array of objects that contains any combination of
strings, icons, and components. The messageType argument must be one of the constants
WARNING_MESSAGE, QUESTION_MESSAGE, INFO_MESSAGE, ERROR_MESSAGE, or PLAIN_MES-
SAGE. These constants specify the basic type of message you are displaying. The current
look-and-feel may customize the appearance of the dialog based on this value. Typi-
cally, the customization is limited to the display of one of a standard set of icons. If
you’d like to override the default icon for the dialog, you can also explicitly specify an
icon argument.
The showConﬁr mDialog() and showInter nalConﬁr mDialog() methods are much like showMes-
sageDialog() and showInter nalMessageDialog(), except that they ask the user to make a
choice and provide several push buttons that repr esent the options available to the
user. (It is the options repr esented by these buttons from which the name JOptionPane
derives.) For example, showConﬁr mDialog() can be used to display a dialog that asks “Do
you really want to quit?” and allows the user to respond by pushing either a Yes button
or a No button. The parentComponent, title, message, messageType, and icon arguments to these
methods are the same as for the message dialogs. The conﬁrm dialogs add an optionType
argument and a retur n value. optionType speciﬁes which buttons should appear in the dia-
log. It should be one of the constants DEFAULT_OPTION, YES_NO_OPTION, YES_NO_CAN-
CEL_OPTION, or OK_CANCEL_OPTION. DEFAULT_OPTION pr ovides a single Okay button; the
others provide buttons as indicated by their names. Like the message dialogs, the con-
ﬁr m dialogs are modal, and the static methods that display them block until the user
has dismissed the dialog. Since conﬁrm dialogs present choices to the user, they have
retur n values that indicate the choice the user selected. This retur n value is one of the
constants OK_OPTION, CANCEL_OPTION, YES_OPTION, NO_OPTION, or CLOSED_OPTION. This last
value indicates that the user closed the dialog window without selecting any of the
available buttons; typically, it should be treated as a CANCEL_OPTION response.
showOptionDialog() and showInter nalOptionDialog() ar e generalizations of the conﬁrm dialog.
They take an options argument, which speciﬁes what buttons to display in the dialog
box, and an initialValue argument, which speciﬁes which of these buttons should be the
default button. The options argument is an array of objects. Typically, you specify string
values that the JOptionPane displays in JButton components. You can provide arbitrary
components in the options array, but if you do so, you must arrange for each component
to update the state of the JOptionPane by calling its setValue() method when selected.
The ﬁnal category of dialogs are the input dialogs, created with showInputDialog() and
showInter nalInputDialog(). Most versions of these methods take the same arguments as the
message dialogs. However, in addition to displaying a message, they also contain a
JTextF ield in which the user can enter whatever input value is requested. These dialogs
ar e modal, and the methods that display them block until the user has dismissed the
dialog. If the user dismisses the dialog with the Okay button, the methods retur n the
user’s input as a String. If the user dismisses the dialog with the Cancel button, these
methods retur n null. One version of both showInputDialog() and showInter nalInputDialog() ar e
dif ferent. These methods take additional selectionValues and initialSelectionValue arguments.
Instead of asking the user to enter a string, they ask the user to choose among the val-
ues contained in the selectionValues array (presenting initialSelectionValue as the default value).
The display of these values is left to the current look-and-feel, although they are typi-
cally displayed using a JComboBox or JList component. The selectionValues array typically
contains strings, but it may also contain Icon objects or other objects that can be mean-
ingfully displayed by JList and JComboBox components. When you pass an array of selec-
tionValues to showInputDialog() or showInter nalInputDialog(), the retur n value is the value the
user has chosen or null, if the user selected the Cancel button.
Instead of using one of the static methods to display a JOptionPane dialog, you can also
cr eate a JOptionPane component, set properties as desired, and then create a dialog to
contain it by calling the createDialog() or createInter nalFrame() instance method.
javax.swing.JOptionPane
458 Chapter 23 – The javax.swing Package

public class JOptionPane extends JComponent implements Accessible {
// Public Constructors
public JOptionPane();
public JOptionPane(Object message);
public JOptionPane(Object message, int messageType);
public JOptionPane(Object message, int messageType, int optionType);
public JOptionPane(Object message, int messageType, int optionType, Icon icon);
public JOptionPane(Object message, int messageType, int optionType, Icon icon, Object[ ] options);
public JOptionPane(Object message, int messageType, int optionType, Icon icon, Object[ ] options,
Object initialValue);
// Public Constants
=2
public static ﬁnal int CANCEL_OPTION;
=-1
public static ﬁnal int CLOSED_OPTION;
=-1
public static ﬁnal int DEFAULT_OPTION;
=0
public static ﬁnal int ERROR_MESSAGE;
="icon"
public static ﬁnal String ICON_PROPERTY;
=1
public static ﬁnal int INFORMATION_MESSAGE;
="initialSelectionValue"
public static ﬁnal String INITIAL_SELECTION_VALUE_PROPERTY;
="initialValue"
public static ﬁnal String INITIAL_VALUE_PROPERTY;
="inputValue"
public static ﬁnal String INPUT_VALUE_PROPERTY;
="message"
public static ﬁnal String MESSAGE_PROPERTY;
="messageType"
public static ﬁnal String MESSAGE_TYPE_PROPERTY;
=1
public static ﬁnal int NO_OPTION;
=2
public static ﬁnal int OK_CANCEL_OPTION;
=0
public static ﬁnal int OK_OPTION;
="optionType"
public static ﬁnal String OPTION_TYPE_PROPERTY;
="options"
public static ﬁnal String OPTIONS_PROPERTY;
=-1
public static ﬁnal int PLAIN_MESSAGE;
=3
public static ﬁnal int QUESTION_MESSAGE;
="selectionValues"
public static ﬁnal String SELECTION_VALUES_PROPERTY;
public static ﬁnal Object UNINITIALIZED_VALUE;
="value"
public static ﬁnal String VALUE_PROPERTY;
="wantsInput"
public static ﬁnal String WANTS_INPUT_PROPERTY;
=2
public static ﬁnal int WARNING_MESSAGE;
=1
public static ﬁnal int YES_NO_CANCEL_OPTION;
=0
public static ﬁnal int YES_NO_OPTION;
=0
public static ﬁnal int YES_OPTION;
// Inner Classes
protected class AccessibleJOptionPane extends JComponent.AccessibleJComponent;
// Public Class Methods
public static JDesktopPane getDesktopPaneForComponent(Component parentComponent);
public static java.awt.Frame getFrameForComponent(Component parentComponent);
public static java.awt.Frame getRootFrame();
public static void setRootFrame(java.awt.Frame newRootFrame);
public static int showConﬁr mDialog(Component parentComponent, Object message);
public static int showConﬁr mDialog(Component parentComponent, Object message, String title, int optionType);
public static int showConﬁr mDialog(Component parentComponent, Object message, String title, int optionType,
int messageType);
public static int showConﬁr mDialog(Component parentComponent, Object message, String title, int optionType,
int messageType, Icon icon);
public static String showInputDialog(Object message);
public static String showInputDialog(Component parentComponent, Object message);
public static String showInputDialog(Component parentComponent, Object message, String title,
int messageType);
public static Object showInputDialog(Component parentComponent, Object message, String title,
int messageType, Icon icon, Object[ ] selectionValues,
Object initialSelectionValue);
public static int showInter nalConﬁr mDialog(Component parentComponent, Object message);
javax.swing
javax.swing.JOptionPane
Chapter 23 – The javax.swing Package
459

public static int showInter nalConﬁr mDialog(Component parentComponent, Object message, String title,
int optionType);
public static int showInter nalConﬁr mDialog(Component parentComponent, Object message, String title,
int optionType, int messageType);
public static int showInter nalConﬁr mDialog(Component parentComponent, Object message, String title,
int optionType, int messageType, Icon icon);
public static String showInter nalInputDialog(Component parentComponent, Object message);
public static String showInter nalInputDialog(Component parentComponent, Object message, String title,
int messageType);
public static Object showInter nalInputDialog(Component parentComponent, Object message, String title,
int messageType, Icon icon, Object[ ] selectionValues,
Object initialSelectionValue);
public static void showInter nalMessageDialog(Component parentComponent, Object message);
public static void showInter nalMessageDialog(Component parentComponent, Object message, String title,
int messageType);
public static void showInter nalMessageDialog(Component parentComponent, Object message, String title,
int messageType, Icon icon);
public static int showInter nalOptionDialog(Component parentComponent, Object message, String title,
int optionType, int messageType, Icon icon, Object[ ] options,
Object initialValue);
public static void showMessageDialog(Component parentComponent, Object message);
public static void showMessageDialog(Component parentComponent, Object message, String title,
int messageType);
public static void showMessageDialog(Component parentComponent, Object message, String title,
int messageType, Icon icon);
public static int showOptionDialog(Component parentComponent, Object message, String title, int optionType,
int messageType, Icon icon, Object[ ] options, Object initialValue);
// Property Accessor Methods (by property name)
Implements:Accessible default:AccessibleJOptionPane expert
public AccessibleContext getAccessibleContext();
default:null
public Icon getIcon();
bound preferred
public void setIcon(Icon newIcon);
default:null
public Object getInitialSelectionValue();
bound
public void setInitialSelectionValue(Object newValue);
default:null
public Object getInitialValue();
bound preferred
public void setInitialValue(Object newInitialValue);
public Object getInputValue();
bound preferred
public void setInputValue(Object newValue);
default:2147483647
public int getMaxCharactersPerLineCount();
public Object getMessage();
bound preferred
public void setMessage(Object newMessage);
default:-1
public int getMessageType();
bound preferred
public void setMessageType(int newType);
default:null
public Object[ ] getOptions();
bound
public void setOptions(Object[ ] newOptions);
default:-1
public int getOptionType();
bound preferred
public void setOptionType(int newType);
default:null
public Object[ ] getSelectionValues();
bound
public void setSelectionValues(Object[ ] newValues);
public javax.swing.plaf.OptionPaneUI getUI();
bound hidden
public void setUI(javax.swing .plaf.OptionPaneUI ui);
Overrides:JComponent default:"OptionPaneUI"
public String getUIClassID();
public Object getValue();
bound preferred
public void setValue(Object newValue);
default:false
public boolean getWantsInput();
public void setWantsInput(boolean newValue);
// Public Instance Methods
public JDialog createDialog(Component parentComponent, String title);
javax.swing.JOptionPane
460 Chapter 23 – The javax.swing Package

public JInternalFrame createInter nalFrame(Component parentComponent, String title);
public void selectInitialValue();
// Methods Implementing Accessible
default:AccessibleJOptionPane expert
public AccessibleContext getAccessibleContext();
// Public Methods Overriding JComponent
public void updateUI();
// Protected Methods Overriding JComponent
protected String paramString();
// Protected Instance Fields
protected transient Icon icon;
protected transient Object initialSelectionValue;
protected transient Object initialValue;
protected transient Object inputValue;
protected transient Object message;
protected int messageType;
protected transient Object[ ] options;
protected int optionType;
protected transient Object[ ] selectionValues;
protected transient Object value;
protected boolean wantsInput;
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→JComponent(Serializable)→JOptionPane(Accessible)
Passed To: javax.swing .plaf.OptionPaneUI.{containsCustomComponents(), selectInitialValue()}
JPanel
Ja va 1.2
javax.swing
serializable accessible swing component
This component is a lightweight container that is commonly used to group other com-
ponents within graphical user interfaces. Use setLayout() to specify a java.awt.LayoutManager
to control the arrangement of components within the JPanel. Various JPanel() construc-
tors make it easy to set the values of the inherited layout and doubleBuffered pr operties.
public class JPanel extends JComponent implements Accessible {
// Public Constructors
public JPanel();
public JPanel(boolean isDoubleBuffered);
public JPanel(java.awt.LayoutManager layout);
public JPanel(java.awt.LayoutManager layout, boolean isDoubleBuffered);
// Inner Classes
protected class AccessibleJPanel extends JComponent.AccessibleJComponent;
// Property Accessor Methods (by property name)
Implements:Accessible default:AccessibleJPanel
public AccessibleContext getAccessibleContext();
Overrides:JComponent default:"PanelUI" expert
public String getUIClassID();
// Methods Implementing Accessible
default:AccessibleJPanel
public AccessibleContext getAccessibleContext();
// Public Methods Overriding JComponent
public void updateUI();
// Protected Methods Overriding JComponent
protected String paramString();
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→JComponent(Serializable)→JPanel(Accessible)
Subc lasses: javax.swing .colorchooser.AbstractColorChooserPanel
javax.swing
javax.swing.JPanel
Chapter 23 – The javax.swing Package
461

JPasswordF ield
Ja va 1.2
javax.swing
serializable accessible(text) swing component
This JTextF ield subclass is designed for entering passwords and other sensitive data. It
does not display the characters of the entered text, preventing it from being read by
onlookers. Use setEchoChar() to specify the character that should appear (e.g., an aster-
isk) in place of the characters entered by the user.
JPasswordF ield overrides and deprecates the getText() method of JTextF ield. Instead, use get-
Password() to obtain the user’s input. This method retur ns an array of characters instead
of an immutable String object. This means that after you use the password, you can set
the elements of the array to 0 for additional security.
public class JPasswordF ield extends JTextF ield {
// Public Constructors
public JPasswordF ield();
public JPasswordF ield(String text);
public JPasswordF ield(int columns);
public JPasswordF ield(String text, int columns);
public JPasswordF ield(javax.swing .text.Document doc, String txt, int columns);
// Inner Classes
protected class AccessibleJPasswordF ield extends JTextF ield.AccessibleJTextF ield;
// Property Accessor Methods (by property name)
Overrides:JTextF ield default:AccessibleJPasswordF ield
public AccessibleContext getAccessibleContext();
default:*
public char getEchoChar();
public void setEchoChar(char c);
public char[ ] getPassword();
Overrides:JTextF ield default:"PasswordF ieldUI"
public String getUIClassID();
// Public Instance Methods
public boolean echoCharIsSet();
// Protected Methods Overriding JTextF ield
protected String paramString();
// Public Methods Overriding JTextComponent
public void copy();
public void cut();
// Deprecated Public Methods
Overrides:JTextComponent default:""
# public String getText();
Overrides:JTextComponent
# public String getText(int offs, int len) throws javax.swing.text.BadLocationException;
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→JComponent(Serializable)→javax.swing .text.JTextComponent(Accessible, Scrollable)→
JTextF ield(SwingConstants)→JPasswordF ield
JPopupMenu
Ja va 1.2
javax.swing
serializable accessible swing component
This component displays a menu of choices in a popup window. It is used both for
standalone popup menus that are posted when the user clicks the right mouse button
and for the pulldown and pull-right menus that appear when the user selects a JMenu
component. JPopupMenu uses a SingleSelectionModel to maintain its selection state.
After you create a JPopupMenu object, you can add items to it with the add() and addSep-
arator() methods. The java.awt.event.ActionListener of a menu item is notiﬁed when that item
is selected. After adding items to the menu, you can pop it up at a speciﬁed location
with the show() method. This is usually done only after calling the isPopupTrigger() method
of a java.awt.event.MouseEvent object. The menu automatically pops itself down when the
user selects an item or stops interacting with it. Call setLightWeightPopupEnabled() to spec-
ify whether the popup should use a lightweight window or a heavyweight native
javax.swing.JPasswordField
462 Chapter 23 – The javax.swing Package

window. Call the static setDefaultLightWeightPopupEnabled() to specify a default behavior for
all popup menus.
public class JPopupMenu extends JComponent implements Accessible, MenuElement {
// Public Constructors
public JPopupMenu();
public JPopupMenu(String label);
// Inner Classes
protected class AccessibleJPopupMenu extends JComponent.AccessibleJComponent;
public static class Separator extends JSeparator;
// Public Class Methods
public static boolean getDefaultLightWeightPopupEnabled();
public static void setDefaultLightWeightPopupEnabled(boolean aFlag);
// Event Registration Methods (by event name)
public void addPopupMenuListener(javax.swing .event.PopupMenuListener l);
public void removePopupMenuListener(javax.swing .event.PopupMenuListener l);
// Property Accessor Methods (by property name)
Implements:Accessible default:AccessibleJPopupMenu
public AccessibleContext getAccessibleContext();
default:true
public boolean isBorderPainted();
public void setBorderPainted(boolean b);
Implements:MenuElement default:JPopupMenu
public Component getComponent();
default:null
public Component getInvoker();
exper t
public void setInvoker(Component invoker);
default:null
public String getLabel();
bound
public void setLabel(String label);
default:true
public boolean isLightWeightPopupEnabled();
exper t
public void setLightWeightPopupEnabled(boolean aFlag);
public java.awt.Insets getMargin();
default:DefaultSingleSelectionModel
public SingleSelectionModel getSelectionModel();
exper t
public void setSelectionModel(SingleSelectionModel model);
Implements:MenuElement
public MenuElement[ ] getSubElements();
public javax.swing.plaf.PopupMenuUI getUI();
bound expert hidden
public void setUI(javax.swing .plaf.PopupMenuUI ui);
Overrides:JComponent default:"PopupMenuUI"
public String getUIClassID();
Overrides:Component default:false
public boolean isV isible();
Overrides:JComponent
public void setV isible(boolean b);
// Public Instance Methods
public JMenuItem add(Action a);
public JMenuItem add(JMenuItem menuItem);
public JMenuItem add(String s);
public void addSeparator();
public Component getComponentAtIndex(int i);
public int getComponentIndex(Component c);
public void inser t(Action a, int index);
public void inser t(Component component, int index);
public void pack();
public void setPopupSize(java.awt.Dimension d);
public void setPopupSize(int width, int height);
exper t hidden
public void setSelected(Component sel);
public void show(Component invoker, int x, int y);
// Methods Implementing Accessible
default:AccessibleJPopupMenu
public AccessibleContext getAccessibleContext();
// Methods Implementing MenuElement
default:JPopupMenu
public Component getComponent();
public MenuElement[ ] getSubElements();
public void menuSelectionChanged(boolean isIncluded);
empty
public void processKeyEvent(java.awt.e vent.Ke yEvent e, MenuElement[ ] path,
MenuSelectionManager manager);
empty
public void processMouseEvent(java.awt.e vent.MouseEvent event, MenuElement[ ] path,
MenuSelectionManager manager);
javax.swing
javax.swing.JPopupMenu
Chapter 23 – The javax.swing Package
463

// Public Methods Overriding JComponent
public void updateUI();
// Protected Methods Overriding JComponent
protected void paintBorder(java.awt.Graphics g);
protected String paramString();
// Public Methods Overriding Container
public void remove(Component comp);
public void remove(int pos);
// Public Methods Overriding Component
public void setLocation(int x, int y);
// Protected Instance Methods
protected java.beans.PropertyChangeListener createActionChangeListener(JMenuItem b);
protected void ﬁrePopupMenuCanceled();
protected void ﬁrePopupMenuW illBecomeInvisible();
protected void ﬁrePopupMenuW illBecomeVisible();
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→JComponent(Serializable)→JPopupMenu(Accessible, MenuElement)
Passed To: JMenu.createW inListener(), JMenu.W inListener.W inListener()
Retur ned By: JMenu.getPopupMenu()
JPopupMenu.Separator
Ja va 1.2
javax.swing
serializable accessible swing component
This inner class is a JSeparator component customized for use in JPopupMenu compo-
nents. The addSeparator() method of JPopupMenu retur ns an instance of this class. This
class is a trivial subclass of JSeparator that does nothing except to override the UI dele-
gate class name and ensure that the separator is never vertical. Application-level code
never needs to use this class.
public static class JPopupMenu.Separator extends JSeparator {
// Public Constructors
public Separator();
// Property Accessor Methods (by property name)
Overrides:JSeparator
public String getUIClassID();
}
JProgressBar
Ja va 1.2
javax.swing
serializable accessible(value) swing component
This class implements a progr ess bar: a component that graphically displays a non-
adjustable integer value. It is typically used to display a program’s progr ess on some
time consuming task, but can also be used to simulate the display of a graphic equal-
izer, for example. ProgressMonitor is a useful class that displays a JProgressBar in a dialog
box.
Like JScrollBar and JSlider, JProgressBar uses a BoundedRangeModel to maintain its state. The
value pr operty is the most important; it speciﬁes the currently displayed value. JProgress-
Bar ﬁr es a javax.swing .event.ChangeEvent when its value pr operty changes. value must be
between the minimum and maximum values. The orientation pr operty should be one of the
HORIZONTAL or VERTICAL constants deﬁned by SwingConstants. Set the borderPainted pr operty
to false if you do not want the JProgressBar to display a border around itself.
javax.swing.JPopupMenu
464 Chapter 23 – The javax.swing Package

public class JProgressBar extends JComponent implements Accessible, SwingConstants {
// Public Constructors
public JProgressBar();
public JProgressBar(BoundedRangeModel newModel);
public JProgressBar(int orient);
public JProgressBar(int min, int max);
public JProgressBar(int orient, int min, int max);
// Inner Classes
protected class AccessibleJProgressBar extends JComponent.AccessibleJComponent implements
AccessibleValue;
// Event Registration Methods (by event name)
public void addChangeListener(javax.swing .event.ChangeListener l);
public void removeChangeListener(javax.swing .event.ChangeListener l);
// Property Accessor Methods (by property name)
Implements:Accessible default:AccessibleJProgressBar expert
public AccessibleContext
getAccessibleContext();
default:true
public boolean isBorderPainted();
bound
public void setBorderPainted(boolean b);
default:100
public int getMaximum();
preferred
public void setMaximum(int n);
default:0
public int getMinimum();
preferred
public void setMinimum(int n);
default:DefaultBoundedRangeModel
public BoundedRangeModel getModel();
exper t
public void setModel(BoundedRangeModel newModel);
default:0
public int getOrientation();
bound preferred
public void setOrientation(int newOrientation);
default:0.0
public double getPercentComplete();
default:"0%"
public String getString();
bound
public void setString(String s);
default:false
public boolean isStringPainted();
bound
public void setStringPainted(boolean b);
public javax.swing.plaf.ProgressBarUI getUI();
exper t
public void setUI(javax.swing .plaf.ProgressBarUI ui);
Overrides:JComponent default:"ProgressBarUI" expert
public String getUIClassID();
default:0
public int getValue();
preferred
public void setValue(int n);
// Methods Implementing Accessible
default:AccessibleJProgressBar expert
public AccessibleContext getAccessibleContext();
// Public Methods Overriding JComponent
public void updateUI();
// Protected Methods Overriding JComponent
protected void paintBorder(java.awt.Graphics g);
protected String paramString();
// Protected Instance Methods
protected javax.swing.e vent.ChangeListener createChangeListener();
protected void ﬁreStateChanged();
// Protected Instance Fields
protected transient javax.swing.e vent.ChangeEvent changeEvent;
protected javax.swing.e vent.ChangeListener changeListener;
protected BoundedRangeModel model;
protected int orientation;
protected boolean paintBorder;
protected boolean paintString;
protected String progressString;
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→JComponent(Serializable)→JProgressBar(Accessible, SwingConstants)
javax.swing
javax.swing.JProg ressBar
Chapter 23 – The javax.swing Package
465

JRadioButton
Ja va 1.2
javax.swing
serializable accessible(action,value) swing component
This class implements a radio button: a toggle button with default graphics that indicate
mutually exclusive behavior. Because JRadioButton supplies its own default and selected
icons, you typically do not use the constructors that take Icon arguments. The selection
state of a JRadioButton is stored in a JToggleButton.ToggleButtonModel object by default. The
initial selection state can be speciﬁed in the call to the constructor. The current state
can be set with setSelected() and queried with isSelected().
The default graphics of the JRadioButton ar e designed to indicate to the user that the but-
ton repr esents one of a group of mutually exclusive choices. (The name “radio button”
refers to the mechanical station-preset buttons on old-style car radios: only one button
could be pressed at a time.) JRadioButton does not implement or enforce mutual exclu-
sion; this is done by adding JRadioButton components to a ButtonGroup object.
public class JRadioButton extends JToggleButton implements Accessible {
// Public Constructors
public JRadioButton();
public JRadioButton(Icon icon);
public JRadioButton(String text);
public JRadioButton(String text, Icon icon);
public JRadioButton(Icon icon, boolean selected);
public JRadioButton(String text, boolean selected);
public JRadioButton(String text, Icon icon, boolean selected);
// Inner Classes
protected class AccessibleJRadioButton extends JToggleButton.AccessibleJToggleButton;
// Property Accessor Methods (by property name)
Implements:Accessible default:AccessibleJRadioButton expert
public AccessibleContext
getAccessibleContext();
Overrides:JToggleButton default:"RadioButtonUI" expert
public String getUIClassID();
// Methods Implementing Accessible
default:AccessibleJRadioButton expert
public AccessibleContext getAccessibleContext();
// Public Methods Overriding JToggleButton
public void updateUI();
// Protected Methods Overriding JToggleButton
protected String paramString();
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→JComponent(Serializable)→AbstractButton(java.awt.ItemSelectable, SwingConstants)→
JToggleButton(Accessible)→JRadioButton(Accessible)
JRadioButtonMenuItem
Ja va 1.2
javax.swing
serializable accessible(action,value) swing component
This class implements a radio button that appears within a pulldown or popup menu.
Its use is similar to that of JRadioButton. Use isSelected() to query the selection state of the
menu item and setSelected() to select or deselect the item. By default, the selection state
is stored in a JToggleButton.ToggleButtonModel object. Note that JRadioButtonMenuItem, like
JRadioButton, does not implement mutually exclusive selection behavior on its own. Each
JRadioButtonMenuItem in a mutually exclusive selection group must be added to a corre-
sponding ButtonGroup object. It is this ButtonGroup that enforces mutual exclusion.
public class JRadioButtonMenuItem extends JMenuItem implements Accessible {
// Public Constructors
public JRadioButtonMenuItem();
public JRadioButtonMenuItem(Icon icon);
javax.swing.JRadioButton
466 Chapter 23 – The javax.swing Package

public JRadioButtonMenuItem(String text);
public JRadioButtonMenuItem(String text, Icon icon);
public JRadioButtonMenuItem(Icon icon, boolean selected);
public JRadioButtonMenuItem(String text, boolean b);
public JRadioButtonMenuItem(String text, Icon icon, boolean selected);
// Inner Classes
protected class AccessibleJRadioButtonMenuItem extends JMenuItem.AccessibleJMenuItem;
// Property Accessor Methods (by property name)
Implements:Accessible default:AccessibleJRadioButtonMenuItem
public AccessibleContext
getAccessibleContext();
Overrides:JMenuItem
public String getUIClassID();
// Methods Implementing Accessible
default:AccessibleJRadioButtonMenuItem
public AccessibleContext getAccessibleContext();
// Protected Methods Overriding JMenuItem
protected String paramString();
// Public Methods Overriding JComponent
empty
public void requestFocus();
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→JComponent(Serializable)→AbstractButton(java.awt.ItemSelectable, SwingConstants)→
JMenuItem(Accessible, MenuElement)→JRadioButtonMenuItem(Accessible)
JRootPane
Ja va 1.2
javax.swing
serializable accessible swing component
This component is used internally by all the top-level Swing containers: JW indow, JFrame,
JDialog, JApplet, and JInter nalFrame. Most applications can simply use these top-level con-
tainers; they never need to use JRootPane dir ectly.
JRootPane is a container that manages a ﬁxed hierarchy of children, including a content
pane and an optional menubar. You cannot add children directly to a JRootPane; instead,
you must add them to the container retur ned by its getContentPane() method. Each of the
top-level Swing containers that uses a JRootPane also provides a getContentPane() method
that retur ns the content pane of its JRootPane. Similarly, to add a menubar to a JRootPane
or top-level container that uses JRootPane, you can use the setJMenuBar() method. JRoot-
Pane has a custom layout manager that manages its various children. You should not try
to set your own layout manager on a JRootPane—instead, set it on the content pane.
The content pane and menubar are not actually direct children of the JRootPane. Instead,
they are childr en of a JLayeredPane that is itself a child of the JRootPane. The JLayeredPane
of a JRootPane pr ovides the layering features requir ed for Swing to implement modal
dialogs, ﬂoating palettes, popup menus, tooltips, and drag-and-drop-style graphical
ef fects. These features are used internally by Swing; only very advanced applications
need to use them directly.
In addition to its JLayeredPane, a JRootPane also contains another child, known as the
glass pane. This child ﬁlls the entire JRootPane and sits on top of the JLayeredPane. The
glass pane either must be hidden or must be a transparent component. Otherwise it
obscur es all other contents of the JRootPane. The glass pane can be used both to inter-
cept mouse events destined for other components within the JRootPane and for the tem-
porary display of graphics on top of the components of a JRootPane. Again, these glass
pane features are used internally by Swing, and only advanced applications need to use
them directly.
public class JRootPane extends JComponent implements Accessible {
// Public Constructors
javax.swing
javax.swing.JRootPane
Chapter 23 – The javax.swing Package
467

public JRootPane();
// Inner Classes
protected class AccessibleJRootPane extends JComponent.AccessibleJComponent;
protected class RootLayout implements java.awt.LayoutManager2, Serializable;
// Property Accessor Methods (by property name)
Implements:Accessible default:AccessibleJRootPane
public AccessibleContext getAccessibleContext();
default:JPanel
public Container getContentPane();
public void setContentPane(Container content);
default:null
public JButton getDefaultButton();
public void setDefaultButton(JButton defaultButton);
Overrides:JComponent constant default:true
public boolean isFocusCycleRoot();
default:JPanel
public Component getGlassPane();
public void setGlassPane(Component glass);
default:null
public JMenuBar getJMenuBar();
public void setJMenuBar(JMenuBar menu);
public JLayeredPane getLayeredPane();
public void setLayeredPane(JLayeredPane layered);
Overrides:JComponent constant default:true
public boolean isValidateRoot();
// Methods Implementing Accessible
default:AccessibleJRootPane
public AccessibleContext getAccessibleContext();
// Public Methods Overriding JComponent
public void addNotify();
public void removeNotify();
// Protected Methods Overriding JComponent
protected String paramString();
// Public Methods Overriding Container
public Component ﬁndComponentAt(int x, int y);
// Protected Methods Overriding Container
protected void addImpl(Component comp, Object constraints, int index);
// Protected Instance Methods
protected Container createContentPane();
protected Component createGlassPane();
protected JLayeredPane createLayeredPane();
protected java.awt.LayoutManager createRootLayout();
// Protected Instance Fields
protected Container contentPane;
protected JButton defaultButton;
protected JRootPane.DefaultAction defaultPressAction;
protected JRootPane.DefaultAction defaultReleaseAction;
protected Component glassPane;
protected JLayeredPane layeredPane;
protected JMenuBar menuBar;
// Deprecated Public Methods
default:null
# public JMenuBar getMenuBar();
# public void setMenuBar(JMenuBar menu);
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→JComponent(Serializable)→JRootPane(Accessible)
Passed To: JApplet.setRootPane(), JDialog.setRootPane(), JFrame.setRootPane(),
JInter nalFrame.setRootPane(), JWindow.setRootPane()
Retur ned By: JApplet.{createRootPane(), getRootPane()}, JComponent.getRootPane(),
JDialog.{createRootPane(), getRootPane()}, JFrame.{createRootPane(), getRootPane()},
JInter nalFrame.{createRootPane(), getRootPane()}, JWindow.{createRootPane(), getRootPane()},
RootPaneContainer.getRootPane(), SwingUtilities.getRootPane()
Type Of: JApplet.rootPane, JDialog.rootPane, JFrame.rootPane, JInternalFrame.rootPane, JWindow.rootPane
javax.swing.JRootPane
468 Chapter 23 – The javax.swing Package

JRootPane.RootLayout
Ja va 1.2
javax.swing
serializable layout manager
This protected inner class is a custom java.awt.LayoutManager that is responsible for the
layout of the children of a JRootPane. Application-level code never needs to use this
class.
protected class JRootPane.RootLayout implements java.awt.LayoutManager2, Serializable {
// Protected Constructors
protected RootLayout();
// Methods Implementing LayoutManager
empty
public void addLayoutComponent(String name, Component comp);
public void layoutContainer(Container parent);
public java.awt.Dimension minimumLayoutSize(Container parent);
public java.awt.Dimension prefer redLayoutSize(Container parent);
empty
public void removeLayoutComponent(Component comp);
// Methods Implementing LayoutManager2
empty
public void addLayoutComponent(Component comp, Object constraints);
constant
public ﬂoat getLayoutAlignmentX(Container target);
constant
public ﬂoat getLayoutAlignmentY(Container target);
empty
public void invalidateLayout(Container target);
public java.awt.Dimension maximumLayoutSize(Container target);
}
JScrollBar
Ja va 1.2
javax.swing
serializable accessible(value) swing component
This class implements a scrollbar component that can be used to scroll the visible
region of some entity, within a maximum and a minimum range. The minimum and maxi-
mum pr operties specify the range within which scrolling takes place. The value pr operty
speciﬁes the current value of the scrollbar — the beginning of the visible region. visi-
bleAmount speciﬁes how much of the range is visible at once and also speciﬁes the size
of the displayed thumb, or knob, of the scrollbar. The values of these properties are all
stor ed in a BoundedRangeModel object. JScrollBar uses DefaultBoundedRangeModel by default.
(The visibleAmount pr operty corr esponds to the extent pr operty of BoundedRangeModel.)
The orientation pr operty speciﬁes whether the JScrollBar is a horizontal or a vertical scroll-
bar. Use either the HORIZONTAL or the VERTICAL constant deﬁned by the SwingConstants
inter face. unitIncrement speciﬁes the amount by which the scrollbar thumb should move
when the user clicks on the arrows at either end of the scrollbar. The default is 1. The
blockIncrement pr operty speciﬁes the amount that the scrollbar should move when the
user scrolls a block at a time (how this is accomplished varies in differ ent look-and-
feels).
JScrollBar ﬁr es a java.awt.event.AdjustmentEvent when one of the value, minimum, maximum, vis-
ibleAmount, or valueIsAdjusting pr operties changes. Some programs may prefer to instead
handle the javax.swing .event.ChangeEvent events generated by the model of the JScrollBar. In
either case, if the valueIsAdjusting pr operty of the JScrollBar or its model is tr ue, the change
is one in a series of changes. Listeners that prefer not to track these transient changes
can ignore events when valueIsAdjusting is tr ue.
public class JScrollBar extends JComponent implements Accessible, java.awt.Adjustable {
// Public Constructors
public JScrollBar();
public JScrollBar(int orientation);
public JScrollBar(int orientation, int value, int extent, int min, int max);
// Inner Classes
protected class AccessibleJScrollBar extends JComponent.AccessibleJComponent implements AccessibleValue;
javax.swing
javax.swing.JScrollBar
Chapter 23 – The javax.swing Package
469

// Event Registration Methods (by event name)
Implements:Adjustable
public void addAdjustmentListener(java.awt.e vent.AdjustmentListener l);
Implements:Adjustable
public void removeAdjustmentListener(java.awt.e vent.AdjustmentListener l);
// Property Accessor Methods (by property name)
Implements:Accessible default:AccessibleJScrollBar
public AccessibleContext getAccessibleContext();
Implements:Adjustable default:10
public int getBlockIncrement();
public int getBlockIncrement(int direction);
Implements:Adjustable bound preferred
public void setBlockIncrement(int blockIncrement);
Implements:Adjustable default:100
public int getMaximum();
Implements:Adjustable preferred
public void setMaximum(int maximum);
Overrides:JComponent
public java.awt.Dimension getMaximumSize();
Implements:Adjustable default:0
public int getMinimum();
Implements:Adjustable preferred
public void setMinimum(int minimum);
Overrides:JComponent
public java.awt.Dimension getMinimumSize();
default:DefaultBoundedRangeModel
public BoundedRangeModel getModel();
bound expert
public void setModel(BoundedRangeModel newModel);
Implements:Adjustable default:1
public int getOrientation();
bound preferred
public void setOrientation(int orientation);
public javax.swing.plaf.ScrollBarUI getUI();
Overrides:JComponent default:"ScrollBarUI"
public String getUIClassID();
Implements:Adjustable default:1
public int getUnitIncrement();
public int getUnitIncrement(int direction);
Implements:Adjustable bound preferred
public void setUnitIncrement(int unitIncrement);
Implements:Adjustable default:0
public int getValue();
Implements:Adjustable preferred
public void setValue(int value);
default:false
public boolean getValueIsAdjusting();
exper t
public void setValueIsAdjusting(boolean b);
Implements:Adjustable default:10
public int getV isibleAmount();
Implements:Adjustable preferred
public void setV isibleAmount(int extent);
// Public Instance Methods
public void setValues(int newValue, int newExtent, int newMin, int newMax);
// Methods Implementing Accessible
default:AccessibleJScrollBar
public AccessibleContext getAccessibleContext();
// Public Methods Overriding JComponent
public void setEnabled(boolean x);
public void updateUI();
// Protected Methods Overriding JComponent
protected String paramString();
// Protected Instance Methods
protected void ﬁreAdjustmentValueChanged(int id, int type, int value);
// Protected Instance Fields
protected int blockIncrement;
protected BoundedRangeModel model;
protected int orientation;
protected int unitIncrement;
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→JComponent(Serializable)→JScrollBar(Accessible, java.awt.Adjustable)
Subc lasses: JScrollPane.ScrollBar
Passed To: JScrollPane.{setHorizontalScrollBar(), setVer ticalScrollBar()}
Retur ned By: JScrollPane.{createHorizontalScrollBar(), createVer ticalScrollBar(), getHorizontalScrollBar(),
getVer ticalScrollBar()}, ScrollPaneLayout.{getHorizontalScrollBar(), getVer ticalScrollBar()}
Type Of: JScrollPane.{horizontalScrollBar, ver ticalScrollBar}, ScrollPaneLayout.{hsb, vsb}
javax.swing.JScrollBar
470 Chapter 23 – The javax.swing Package

JScrollPane
Ja va 1.2
javax.swing
serializable accessible swing component bean container
This class is a container that allows a child component to be scrolled horizontally and
vertically. The component to be scrolled is not a direct child of the JScrollPane, so it
must not be added directly with the add() method. Instead, it is a child of a JV iewpor t
contained within the JScrollPane. You specify the component to be scrolled by passing it
to the JScrollPane() constructor or to the setV iewpor tView() method. Any type of component
can be used within a JScrollPane, but components that implement the Scrollable inter face
work best. The horizontalScrollBarPolicy and verticalScrollBarPolicy pr operties contr ol the pol-
icy for displaying scrollbars. The legal values are the various ALWAYS, AS_NEEDED, and
NEVER constants deﬁned by the ScrollPaneConstants inter face. Another useful property is
viewpor tBorder, which allows you to specify a border to appear around the JV iewpor t that
contains the component being scrolled.
In addition to the main scrolled component, JScrollPane supports column header and
row header components. The column header appears above the main scrolling compo-
nent and scrolls horizontally, but not vertically, so that it is always visible at the top of
the JScrollPane. Similarly, the row header component scrolls vertically but not horizon-
tally, so it is always visible at the left of the JScrollPane. Specify the row and column
header components with setColumnHeaderV iew() and setRowHeaderV iew(). The JScrollPane
can also display arbitrary components in each of its four corners. Use setCor ner() to
specify a component for a corner. The ScrollPaneConstants inter face deﬁnes constants that
specify which corner a component should appear in. Note that the space available in
the corners of a JScrollPane is determined by the width of the scrollbars and the widths
of the column and row headers, if any. The layout management of the scrollable JV iew-
por t, the scrollbars, the column and row headers, and the corners is provided by the
ScrollPaneLayout class, a specialized java.awt.LayoutManager.
See also the JScrollBar and JV iewpor t components, the ScrollPaneLayout layout manager, and
the Scrollable and ScrollPaneConstants inter faces.
public class JScrollPane extends JComponent implements Accessible, ScrollPaneConstants {
// Public Constructors
public JScrollPane();
public JScrollPane(Component view);
public JScrollPane(int vsbPolicy, int hsbPolicy);
public JScrollPane(Component view, int vsbPolicy, int hsbPolicy);
// Inner Classes
protected class AccessibleJScrollPane extends JComponent.AccessibleJComponent implements
javax.swing .event.ChangeListener ;
protected class ScrollBar extends JScrollBar implements javax.swing.plaf.UIResource;
// Property Accessor Methods (by property name)
Implements:Accessible default:AccessibleJScrollPane
public AccessibleContext getAccessibleContext();
default:null
public JVie wport getColumnHeader();
bound
public void setColumnHeader(JViewpor t columnHeader);
default:ScrollBar
public JScrollBar getHorizontalScrollBar();
bound expert
public void setHorizontalScrollBar(JScrollBar horizontalScrollBar);
default:30
public int getHorizontalScrollBarPolicy();
bound preferred
public void setHorizontalScrollBarPolicy(int policy);
Overrides:Container hidden
public void setLayout(java.awt.LayoutManager layout);
Overrides:JComponent default:false
public boolean isOpaque();
default:null
public JVie wport getRowHeader();
bound expert
public void setRowHeader(JViewpor t rowHeader);
public javax.swing.plaf.ScrollPaneUI getUI();
public void setUI(javax.swing .plaf.ScrollPaneUI ui);
Overrides:JComponent default:"ScrollPaneUI" hidden
public String getUIClassID();
Overrides:JComponent constant default:true hidden
public boolean isValidateRoot();
javax.swing
javax.swing.JScrollPane
Chapter 23 – The javax.swing Package
471

default:ScrollBar
public JScrollBar getVer ticalScrollBar();
bound expert
public void setVer ticalScrollBar(JScrollBar ver ticalScrollBar);
default:20
public int getVer ticalScrollBarPolicy();
bound preferred
public void setVer ticalScrollBarPolicy(int policy);
public JVie wport getV iewport();
bound expert
public void setV iewport(JViewpor t viewpor t);
default:null
public javax.swing.border.Border getV iewportBorder();
bound preferred
public void setV iewportBorder(javax.swing .border.Border viewpor tBorder);
public java.awt.Rectangle getV iewportBorderBounds();
// Public Instance Methods
public JScrollBar createHorizontalScrollBar();
public JScrollBar createVer ticalScrollBar();
public Component getCor ner(String key);
public void setColumnHeaderV iew(Component view);
public void setCor ner(String key, Component corner);
public void setRowHeaderV iew(Component view);
public void setV iewportV iew(Component view);
// Methods Implementing Accessible
default:AccessibleJScrollPane
public AccessibleContext getAccessibleContext();
// Public Methods Overriding JComponent
public void updateUI();
// Protected Methods Overriding JComponent
protected String paramString();
// Protected Instance Methods
protected JVie wport createV iewport();
// Protected Instance Fields
protected JVie wport columnHeader;
protected JScrollBar horizontalScrollBar;
protected int horizontalScrollBarPolicy;
protected Component lowerLeft;
protected Component lowerRight;
protected JVie wport rowHeader;
protected Component upperLeft;
protected Component upperRight;
protected JScrollBar ver ticalScrollBar;
protected int ver ticalScrollBarPolicy;
protected JVie wport viewpor t;
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→JComponent(Serializable)→JScrollPane(Accessible, ScrollPaneConstants)
Passed To: ScrollPaneLayout.{getV iewpor tBorderBounds(), syncW ithScrollPane()}
Retur ned By: JTable.createScrollPaneForTable()
JScrollPane.ScrollBar
Ja va 1.2
javax.swing
serializable accessible(action) swing component
This protected inner class is a trivial subclass of JScrollBar that is used for the scrollbars
of a JScrollPane. This subclass exists for two simple reasons: to implement the
javax.swing .plaf.UIResource inter face and to make the scrollbars work with the Scrollable
inter face. Application-level code never needs to use this class.
protected class JScrollPane.ScrollBar extends JScrollBar implements javax.swing.plaf.UIResource {
// Public Constructors
public ScrollBar(int orientation);
// Property Accessor Methods (by property name)
Overrides:JScrollBar
public void setBlockIncrement(int blockIncrement);
javax.swing.JScrollPane
472 Chapter 23 – The javax.swing Package

Overrides:JScrollBar
public void setUnitIncrement(int unitIncrement);
// Public Methods Overriding JScrollBar
public int getBlockIncrement(int direction);
public int getUnitIncrement(int direction);
}
JSeparator
Ja va 1.2
javax.swing
serializable accessible swing component
This simple component draws a horizontal or vertical line that is as wide or as tall as
the component itself. The orientation pr operty is the only property of interest. It should
be SwingConstants.HORIZONTAL or SwingConstants.VERTICAL. Ther e ar e no properties control-
ling the thickness, color, or other attributes of the JSeparator. Separator objects are com-
monly used in JPopupMenu and JToolBar components. Note, however, that these
components deﬁne addSeparator() methods and implement custom subclasses of JSepara-
tor. These custom subclasses have their own UI delegate subclasses, which allows them
to provide a visual appearance precisely tailored for menus and toolbars.
public class JSeparator extends JComponent implements Accessible, SwingConstants {
// Public Constructors
public JSeparator();
public JSeparator(int orientation);
// Inner Classes
protected class AccessibleJSeparator extends JComponent.AccessibleJComponent;
// Property Accessor Methods (by property name)
Implements:Accessible default:AccessibleJSeparator
public AccessibleContext getAccessibleContext();
Overrides:JComponent constant default:false
public boolean isFocusTraversable();
default:0
public int getOrientation();
bound preferred
public void setOrientation(int orientation);
public javax.swing.plaf.SeparatorUI getUI();
bound expert hidden
public void setUI(javax.swing .plaf.SeparatorUI ui);
Overrides:JComponent default:"SeparatorUI"
public String getUIClassID();
// Methods Implementing Accessible
default:AccessibleJSeparator
public AccessibleContext getAccessibleContext();
// Public Methods Overriding JComponent
public void updateUI();
// Protected Methods Overriding JComponent
protected String paramString();
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→JComponent(Serializable)→JSeparator(Accessible, SwingConstants)
Subc lasses: JPopupMenu.Separator, JToolBar.Separator
JSlider
Ja va 1.2
javax.swing
serializable accessible(value) swing component
This class implements a component that allows the user to drag a knob, or pointer, in
order to graphically adjust an integer value. The minimum and maximum pr operties spec-
ify the range of the slider, and the value pr operty speciﬁes the current value. extent spec-
iﬁes the width of the knob and also an adjustment increment. The values of these
pr operties ar e maintained by a BoundedRangeModel object. By default, JSlider uses a
DefaultBoundedRangeModel object. orientation speciﬁes the orientation of the slider; it
should be one of the SwingConstants values HORIZONTAL or VERTICAL. If the inverted pr operty
is tr ue, the range is inverted to run from right to left or from top to bottom.
javax.swing
javax.swing.JSlider
Chapter 23 – The javax.swing Package
473

A JSlider can display optional tick marks and labels along its length. The paintT icks and
paintLabels pr operties specify whether they should be displayed. majorT ickSpacing and
minorT ickSpacing specify the spacing of long and short tick marks. Note that these spac-
ings are measur ed in the coordinate space deﬁned by the JSlider minimum and maxi-
mum value; they are not pixel spacings. If the snapToT icks pr operty is set tr ue, the user
can only adjust the value pr operty to a value at which a tick mark appears. If you set
paintLabels and majorT ickSpacing, the JSlider automatically displays a numeric label for
each major tick mark. You can call createStandardLabels() to force this behavior, even
when tick marks are not displayed. You can also specify custom labels by setting the
labelTable pr operty to a java.util.Dictionar y that maps Integer coordinates to JComponent
labels.
A JSlider ﬁr es a javax.swing .event.ChangeEvent when one of its value, maximum, minimum,
extent, or valueIsAdjusting pr operties changes. If valueIsAdjusting is tr ue when an event is
ﬁr ed, it means that the event is one of a series of changes. Listeners that do not want to
track these rapid-ﬁre transient changes can ignore them.
public class JSlider extends JComponent implements Accessible, SwingConstants {
// Public Constructors
public JSlider();
public JSlider(BoundedRangeModel brm);
public JSlider(int orientation);
public JSlider(int min, int max);
public JSlider(int min, int max, int value);
public JSlider(int orientation, int min, int max, int value);
// Inner Classes
protected class AccessibleJSlider extends JComponent.AccessibleJComponent implements AccessibleValue;
// Event Registration Methods (by event name)
public void addChangeListener(javax.swing .event.ChangeListener l);
public void removeChangeListener(javax.swing .event.ChangeListener l);
// Property Accessor Methods (by property name)
Implements:Accessible default:AccessibleJSlider
public AccessibleContext getAccessibleContext();
default:0
public int getExtent();
exper t
public void setExtent(int extent);
default:false
public boolean getInver ted();
bound
public void setInver ted(boolean b);
default:null
public java.util.Dictionary getLabelTable();
bound hidden
public void setLabelTable(java.util.Dictionary labels);
default:0
public int getMajorT ickSpacing();
bound
public void setMajorT ickSpacing(int n);
default:100
public int getMaximum();
preferred
public void setMaximum(int maximum);
default:0
public int getMinimum();
preferred
public void setMinimum(int minimum);
default:0
public int getMinorT ickSpacing();
bound
public void setMinorT ickSpacing(int n);
default:DefaultBoundedRangeModel
public BoundedRangeModel getModel();
bound
public void setModel(BoundedRangeModel newModel);
default:0
public int getOrientation();
bound preferred
public void setOrientation(int orientation);
default:false
public boolean getPaintLabels();
bound
public void setPaintLabels(boolean b);
default:false
public boolean getPaintT icks();
bound
public void setPaintT icks(boolean b);
default:true
public boolean getPaintTrack();
bound
public void setPaintTrack(boolean b);
default:false
public boolean getSnapToT icks();
bound
public void setSnapToT icks(boolean b);
public javax.swing.plaf.SliderUI getUI();
javax.swing.JSlider
474 Chapter 23 – The javax.swing Package

bound hidden
public void setUI(javax.swing .plaf.SliderUI ui);
Overrides:JComponent default:"SliderUI"
public String getUIClassID();
default:50
public int getValue();
preferred
public void setValue(int n);
default:false
public boolean getValueIsAdjusting();
exper t
public void setValueIsAdjusting(boolean b);
// Public Instance Methods
public java.util.Hashtable createStandardLabels(int increment);
public java.util.Hashtable createStandardLabels(int increment, int star t);
// Methods Implementing Accessible
default:AccessibleJSlider
public AccessibleContext getAccessibleContext();
// Public Methods Overriding JComponent
public void updateUI();
// Protected Methods Overriding JComponent
protected String paramString();
// Protected Instance Methods
protected javax.swing.e vent.ChangeListener createChangeListener();
protected void ﬁreStateChanged();
protected void updateLabelUIs();
// Protected Instance Fields
protected transient javax.swing.e vent.ChangeEvent changeEvent;
protected javax.swing.e vent.ChangeListener changeListener;
protected int majorT ickSpacing;
protected int minorT ickSpacing;
protected int orientation;
protected BoundedRangeModel sliderModel;
protected boolean snapToT icks;
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→JComponent(Serializable)→JSlider(Accessible, SwingConstants)
JSplitPane
Ja va 1.2
javax.swing
serializable accessible(value) swing component
This class is a container that splits itself horizontally or vertically to display two chil-
dr en. The orientation of the pane is speciﬁed by the orientation pr operty, which should
be set to either the HORIZONTAL_SPLIT or VERTICAL_SPLIT constant. The two children are
speciﬁed by a pair of properties that depend on the orientation of the JSplitPane. If the
orientation is HORIZONTAL_SPLIT, the children are speciﬁed with setLeftComponent() and
setRightComponent(). For a VERTICAL_SPLIT JSplitPane, the children are speciﬁed with setTop-
Component() and setBottomComponent(). The position of the divider between the two
panes of a JSplitPane can be set with setDividerLocation(). The argument can be an integer
that speciﬁes a pixel position or a double between 0.0 and 1.0 that speciﬁes a percent-
age of the size of the JSplitPane.
JSplitPane allows the user to adjust the relative sizes of the two children by dragging the
divider that appears between the children. The adjustment is constrained, however, so
that a child is never made smaller than its speciﬁed minimum size. If the continuousLayout
pr operty is set to tr ue, the children are resized continuously while the user drags the
divider. If this property is false, however, the child components are not resized until the
user ﬁnishes the drag. Although the divider location of a JSplitPane can be thought of in
ter ms of the BoundedRangeModel, the JSplitPane implementation does not use a separate
model object.
javax.swing
javax.swing.JSplitPane
Chapter 23 – The javax.swing Package
475

public class JSplitPane extends JComponent implements Accessible {
// Public Constructors
public JSplitPane();
public JSplitPane(int newOrientation);
public JSplitPane(int newOrientation, boolean newContinuousLayout);
public JSplitPane(int newOrientation, Component newLeftComponent, Component newRightComponent);
public JSplitPane(int newOrientation, boolean newContinuousLayout, Component newLeftComponent,
Component newRightComponent);
// Public Constants
="bottom"
public static ﬁnal String BOTTOM;
="continuousLayout"
public static ﬁnal String CONTINUOUS_LAYOUT_PROPERTY;
="divider"
public static ﬁnal String DIVIDER;
="dividerSize"
public static ﬁnal String DIVIDER_SIZE_PROPERTY;
=1
public static ﬁnal int HORIZONTAL_SPLIT;
="lastDividerLocation"
public static ﬁnal String LAST_DIVIDER_LOCATION_PROPERTY;
="left"
public static ﬁnal String LEFT;
="oneTouchExpandable"
public static ﬁnal String ONE_TOUCH_EXPANDABLE_PROPERTY;
="orientation"
public static ﬁnal String ORIENTATION_PROPERTY;
="right"
public static ﬁnal String RIGHT;
="top"
public static ﬁnal String TOP;
=0
public static ﬁnal int VERTICAL_SPLIT;
// Inner Classes
protected class AccessibleJSplitPane extends JComponent.AccessibleJComponent implements AccessibleValue;
// Property Accessor Methods (by property name)
Implements:Accessible default:AccessibleJSplitPane expert
public AccessibleContext getAccessibleContext();
default:JButton
public Component getBottomComponent();
public void setBottomComponent(Component comp);
default:false
public boolean isContinuousLayout();
bound
public void setContinuousLayout(boolean newContinuousLayout);
default:0
public int getDividerLocation();
public void setDividerLocation(int location);
public void setDividerLocation(double propor tionalLocation);
default:8
public int getDividerSize();
bound
public void setDividerSize(int newSize);
default:0
public int getLastDividerLocation();
bound
public void setLastDividerLocation(int newLastLocation);
default:JButton preferred
public Component getLeftComponent();
public void setLeftComponent(Component comp);
default:93
public int getMaximumDividerLocation();
default:93
public int getMinimumDividerLocation();
default:false
public boolean isOneTouchExpandable();
bound
public void setOneTouchExpandable(boolean newValue);
default:1
public int getOrientation();
bound
public void setOrientation(int orientation);
default:JButton
public Component getRightComponent();
preferred
public void setRightComponent(Component comp);
default:JButton
public Component getTopComponent();
public void setTopComponent(Component comp);
exper t
public javax.swing.plaf.SplitPaneUI getUI();
public void setUI(javax.swing .plaf.SplitPaneUI ui);
Overrides:JComponent default:"SplitPaneUI" expert
public String getUIClassID();
Overrides:JComponent constant default:true hidden
public boolean isValidateRoot();
// Public Instance Methods
public void resetToPrefer redSizes();
// Methods Implementing Accessible
default:AccessibleJSplitPane expert
public AccessibleContext getAccessibleContext();
// Public Methods Overriding JComponent
public void updateUI();
javax.swing.JSplitPane
476 Chapter 23 – The javax.swing Package

// Protected Methods Overriding JComponent
protected void paintChildren(java.awt.Graphics g);
protected String paramString();
// Public Methods Overriding Container
public void remove(Component component);
public void remove(int index);
public void removeAll();
// Protected Methods Overriding Container
protected void addImpl(Component comp, Object constraints, int index);
// Protected Instance Fields
protected boolean continuousLayout;
protected int dividerSize;
protected int lastDividerLocation;
protected Component leftComponent;
protected boolean oneTouchExpandable;
protected int orientation;
protected Component rightComponent;
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→JComponent(Serializable)→JSplitPane(Accessible)
Passed To: javax.swing .plaf.SplitPaneUI.{finishedPaintingChildren(), getDividerLocation(),
getMaximumDividerLocation(), getMinimumDividerLocation(), resetToPrefer redSizes(), setDividerLocation()}
JTabbedPane
Ja va 1.2
javax.swing
serializable accessible(selection) swing component bean container
JTabbedPane is a container that can contain any number of children. It displays one child
at a time, but displays a tab for each child. The user can click on these tabs to adjust
the currently displayed child. JTabbedPane uses a SingleSelectionModel to keep track of the
curr ently selected and displayed child. By default, the tabs appear at the top of the
JTabbedPane. You can override this default, however, with setTabPlacement(). The argu-
ment to this method should be one of the TOP, BO TTOM, LEFT, or RIGHT constants deﬁned
by the SwingConstants inter face.
Although you can add children to a JTabbedPane with the standard add() methods, this
does not give you much ﬂexibility in specifying the contents of the tab for that child.
Instead, JTabbedPane pr ovides several addTab() methods that allow you to specify the
child along with the String, Icon, and tooltip text to use for its tab. A corresponding
inser tTab() method allows you to specify a child, the contents of its tab, and the position
of the tab within the list of tabs. Use setSelectedComponent() or setSelectedIndex() to specify
which child is currently displayed. setEnabledAt() allows you to enable or disable a tab,
speciﬁed by its position within the list of tabs. setDisabledIconAt() allows you to specify
an icon to display when a tab is disabled. Various other methods whose names end
with “At” allow you to alter properties of individual tabs, speciﬁed by position.
public class JTabbedPane extends JComponent implements Accessible, Serializable, SwingConstants {
// Public Constructors
public JTabbedPane();
public JTabbedPane(int tabPlacement);
// Inner Classes
protected class AccessibleJTabbedPane extends JComponent.AccessibleJComponent implements
AccessibleSelection, javax.swing .event.ChangeListener ;
protected class ModelListener implements javax.swing.e vent.ChangeListener, Serializable;
// Event Registration Methods (by event name)
public void addChangeListener(javax.swing .event.ChangeListener l);
javax.swing
javax.swing.JTab bedPane
Chapter 23 – The javax.swing Package
477

public void removeChangeListener(javax.swing .event.ChangeListener l);
// Property Accessor Methods (by property name)
Implements:Accessible default:AccessibleJTabbedPane
public AccessibleContext getAccessibleContext();
default:DefaultSingleSelectionModel
public SingleSelectionModel getModel();
bound
public void setModel(SingleSelectionModel model);
default:null
public Component getSelectedComponent();
preferred
public void setSelectedComponent(Component c);
default:-1
public int getSelectedIndex();
preferred
public void setSelectedIndex(int index);
default:0
public int getTabCount();
default:1
public int getTabPlacement();
bound preferred
public void setTabPlacement(int tabPlacement);
default:0
public int getTabRunCount();
public javax.swing.plaf.TabbedPaneUI getUI();
bound hidden
public void setUI(javax.swing .plaf.TabbedPaneUI ui);
Overrides:JComponent default:"TabbedPaneUI"
public String getUIClassID();
// Public Instance Methods
public void addTab(String title, Component component);
public void addTab(String title, Icon icon, Component component);
public void addTab(String title, Icon icon, Component component, String tip);
public java.awt.Color getBackgroundAt(int index);
public java.awt.Rectangle getBoundsAt(int index);
public Component getComponentAt(int index);
public Icon getDisabledIconAt(int index);
public java.awt.Color getForegroundAt(int index);
public Icon getIconAt(int index);
public String getT itleAt(int index);
public int indexOfComponent(Component component);
public int indexOfTab(Icon icon);
public int indexOfTab(String title);
public void inser tTab(String title, Icon icon, Component component, String tip, int index);
public boolean isEnabledAt(int index);
public void removeTabAt(int index);
preferred
public void setBackgroundAt(int index, java.awt.Color background);
public void setComponentAt(int index, Component component);
preferred
public void setDisabledIconAt(int index, Icon disabledIcon);
public void setEnabledAt(int index, boolean enabled);
preferred
public void setForegroundAt(int index, java.awt.Color foreground);
preferred
public void setIconAt(int index, Icon icon);
preferred
public void setT itleAt(int index, String title);
// Methods Implementing Accessible
default:AccessibleJTabbedPane
public AccessibleContext getAccessibleContext();
// Public Methods Overriding JComponent
public String getToolT ipText(java.awt.e vent.MouseEvent event);
public void updateUI();
// Protected Methods Overriding JComponent
protected String paramString();
// Public Methods Overriding Container
public Component add(Component component);
public void add(Component component, Object constraints);
public Component add(Component component, int index);
public Component add(String title, Component component);
public void add(Component component, Object constraints, int index);
public void remove(Component component);
public void removeAll();
// Protected Instance Methods
protected javax.swing.e vent.ChangeListener createChangeListener();
protected void ﬁreStateChanged();
javax.swing.JTab bedPane
478 Chapter 23 – The javax.swing Package

// Protected Instance Fields
protected transient javax.swing.e vent.ChangeEvent changeEvent;
protected javax.swing.e vent.ChangeListener changeListener;
protected SingleSelectionModel model;
protected int tabPlacement;
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→JComponent(Serializable)→JTabbedPane(Accessible, Serializable, SwingConstants)
Passed To: javax.swing .plaf.TabbedPaneUI.{getTabBounds(), getTabRunCount(), tabForCoordinate()}
JTabbedPane.ModelListener
Ja va 1.2
javax.swing
serializable
This protected inner class is a trivial ChangeListener implementation used internally by
JTabbedPane to listen for changes from its SingleSelectionModel. Applications never need to
use this class, and it probably should not have been made part of the public API. If you
want to use a differ ent listener implementation, override the createChangeListener()
method of JTabbedPane.
protected class JTabbedPane.ModelListener implements javax.swing.e vent.ChangeListener, Serializable {
// Protected Constructors
protected ModelListener();
// Methods Implementing ChangeListener
public void stateChanged(javax.swing .event.ChangeEvent e);
}
JTable
Ja va 1.2
javax.swing
serializable accessible(selection) swing component
JTable is a powerful and complex Swing component for displaying and editing tabular
data. JTable relies on the auxiliary classes and interfaces in the javax.swing .table package.
Two JTable constructors exist that make it easy to display tabular data that is stored in
an Object[][] or in a Vector of rows, where each row is a Vector of cell values. These con-
venience constructors take an additional array or Vector of objects to be used as column
headers for the table. If your data is not already in one of these pure tabular forms, you
must provide a javax.swing .table.TableModel object that enables the JTable to ﬁnd the value
for each cell. You typically do this by subclassing javax.swing .table.AbstractTableModel.
When displaying a JTable that contains more than a few rows or columns, it is common
to place the JTable within a JScrollPane. JTable components created with the convenience
constructors or with a simple default subclass of AbstractTableModel ar e not editable.
However, you can enable editing on a cell-by-cell basis by overriding the isCellEditable()
and setValueAt() methods of the AbstractTableModel.
Unlike most Swing components, JTable relies on more than one associated model object.
In addition to the TableModel object that contains table data, a JTable also uses a
TableColumnModel object to keep track of the columns of the table and their ordering and
selection state and a ListSelectionModel used to keep track of selected rows in the table.
The cell values retur ned by the TableModel ar e generic objects. By default, JTable knows
how to display and edit String, Boolean, and Number values. If you want to display
another type of objects, you can create a custom javax.swing .table.TableCellRenderer object
and pass it to setDefaultRenderer(). If you want to allow users to edit values of this type,
you can create a custom javax.swing .table.TableCellEditor and pass it to setDefaultEditor().
public class JTable extends JComponent implements Accessible, javax.swing .event.CellEditorListener,
javax.swing .event.ListSelectionListener, Scrollable, javax.swing .event.TableColumnModelListener,
javax.swing
javax.swing.JTable
Chapter 23 – The javax.swing Package
479

javax.swing .event.TableModelListener {
// Public Constructors
public JTable();
public JTable(javax.swing .table.TableModel dm);
public JTable(int numRows, int numColumns);
public JTable(Object[ ][ ] rowData, Object[ ] columnNames);
public JTable(javax.swing .table.TableModel dm, javax.swing .table.TableColumnModel cm);
public JTable(java.util.Vector rowData, java.util.Vector columnNames);
public JTable(javax.swing .table.TableModel dm, javax.swing .table.TableColumnModel cm, ListSelectionModel sm);
// Public Constants
=4
public static ﬁnal int AUTO_RESIZE_ALL_COLUMNS;
=3
public static ﬁnal int AUTO_RESIZE_LAST_COLUMN;
=1
public static ﬁnal int AUTO_RESIZE_NEXT_COLUMN;
=0
public static ﬁnal int AUTO_RESIZE_OFF;
=2
public static ﬁnal int AUTO_RESIZE_SUBSEQUENT_COLUMNS;
// Inner Classes
protected class AccessibleJTable extends JComponent.AccessibleJComponent implements AccessibleSelection,
javax.swing .event.CellEditorListener, javax.swing .event.ListSelectionListener, java.beans.Proper tyChangeListener,
javax.swing .event.TableColumnModelListener, javax.swing .event.TableModelListener ;
// Property Accessor Methods (by property name)
Implements:Accessible default:AccessibleJTable
public AccessibleContext getAccessibleContext();
default:true
public boolean getAutoCreateColumnsFromModel();
public void setAutoCreateColumnsFromModel(boolean createColumns);
default:2
public int getAutoResizeMode();
public void setAutoResizeMode(int mode);
default:null
public javax.swing.table.TableCellEditor getCellEditor();
public javax.swing.table.TableCellEditor getCellEditor(int row, int column);
public void setCellEditor(javax.swing .table.TableCellEditor anEditor);
default:false
public boolean getCellSelectionEnabled();
public void setCellSelectionEnabled(boolean ﬂag);
default:0
public int getColumnCount();
default:DefaultTableColumnModel
public javax.swing.table.TableColumnModel getColumnModel();
public void setColumnModel(javax.swing .table.TableColumnModel newModel);
default:false
public boolean getColumnSelectionAllowed();
public void setColumnSelectionAllowed(boolean ﬂag);
default:false
public boolean isEditing();
default:-1
public int getEditingColumn();
public void setEditingColumn(int aColumn);
default:-1
public int getEditingRow();
public void setEditingRow(int aRow);
default:null
public Component getEditorComponent();
default:ColorUIResource
public java.awt.Color getGridColor();
public void setGridColor(java.awt.Color newColor);
public java.awt.Dimension getIntercellSpacing();
public void setIntercellSpacing(java.awt.Dimension newSpacing);
Overrides:JComponent constant default:true
public boolean isManagingFocus();
default:DefaultTableModel
public javax.swing.table.TableModel getModel();
public void setModel(javax.swing .table.TableModel newModel);
Implements:Scrollable
public java.awt.Dimension getPrefer redScrollableViewpor tSize();
public void setPrefer redScrollableViewpor tSize(java.awt.Dimension size);
default:0
public int getRowCount();
default:16
public int getRowHeight();
public void setRowHeight(int newHeight);
default:1
public int getRowMargin();
public void setRowMargin(int rowMargin);
default:true
public boolean getRowSelectionAllowed();
public void setRowSelectionAllowed(boolean ﬂag);
Implements:Scrollable constant default:false
public boolean getScrollableTracksV iewportHeight();
Implements:Scrollable default:true
public boolean getScrollableTracksV iewportW idth();
javax.swing.JTable
480 Chapter 23 – The javax.swing Package

default:-1
public int getSelectedColumn();
default:0
public int getSelectedColumnCount();
public int[ ] getSelectedColumns();
default:-1
public int getSelectedRow();
default:0
public int getSelectedRowCount();
public int[ ] getSelectedRows();
default:ColorUIResource
public java.awt.Color getSelectionBackground();
bound
public void setSelectionBackground(java.awt.Color selectionBackground);
default:ColorUIResource
public java.awt.Color getSelectionForeground();
bound
public void setSelectionForeground(java.awt.Color selectionForeground);
default:DefaultListSelectionModel
public ListSelectionModel getSelectionModel();
public void setSelectionModel(ListSelectionModel newModel);
default:true
public boolean getShowHorizontalLines();
public void setShowHorizontalLines(boolean b);
default:true
public boolean getShowVer ticalLines();
public void setShowVer ticalLines(boolean b);
public javax.swing.table.JTableHeader getTableHeader();
public void setTableHeader(javax.swing .table.JTableHeader newHeader);
public javax.swing.plaf.TableUI getUI();
public void setUI(javax.swing .plaf.TableUI ui);
Overrides:JComponent default:"TableUI"
public String getUIClassID();
// Public Instance Methods
public void addColumn(javax.swing .table.TableColumn aColumn);
public void addColumnSelectionInter val(int index0, int index1);
public void addRowSelectionInter val(int index0, int index1);
public void clearSelection();
public int columnAtPoint(java.awt.Point point);
public int conver tColumnIndexToModel(int viewColumnIndex);
public int conver tColumnIndexToV iew(int modelColumnIndex);
public void createDefaultColumnsFromModel();
public boolean editCellAt(int row, int column);
public boolean editCellAt(int row, int column, java.util.EventObject e);
public java.awt.Rectangle getCellRect(int row, int column, boolean includeSpacing);
public javax.swing.table.TableCellRenderer getCellRenderer(int row, int column);
public javax.swing.table.TableColumn getColumn(Object identiﬁer);
public Class getColumnClass(int column);
public String getColumnName(int column);
public javax.swing.table.TableCellEditor getDefaultEditor(Class columnClass);
public javax.swing.table.TableCellRenderer getDefaultRenderer(Class columnClass);
public Object getValueAt(int row, int column);
public boolean isCellEditable(int row, int column);
public boolean isCellSelected(int row, int column);
public boolean isColumnSelected(int column);
public boolean isRowSelected(int row);
public void moveColumn(int column, int targetColumn);
public Component prepareEditor(javax.swing .table.TableCellEditor editor, int row, int column);
public Component prepareRenderer(javax.swing .table.TableCellRenderer renderer, int row, int column);
public void removeColumn(javax.swing .table.TableColumn aColumn);
public void removeColumnSelectionInter val(int index0, int index1);
public void removeEditor();
public void removeRowSelectionInter val(int index0, int index1);
public int rowAtPoint(java.awt.Point point);
public void selectAll();
public void setColumnSelectionInter val(int index0, int index1);
public void setDefaultEditor(Class columnClass, javax.swing .table.TableCellEditor editor);
public void setDefaultRenderer(Class columnClass, javax.swing .table.TableCellRenderer renderer);
public void setRowSelectionInter val(int index0, int index1);
public void setSelectionMode(int selectionMode);
javax.swing
javax.swing.JTable
Chapter 23 – The javax.swing Package
481

public void setShowGrid(boolean b);
public void setValueAt(Object aValue, int row, int column);
public void sizeColumnsToF it(int resizingColumn);
// Methods Implementing Accessible
default:AccessibleJTable
public AccessibleContext getAccessibleContext();
// Methods Implementing CellEditorListener
public void editingCanceled(javax.swing .event.ChangeEvent e);
public void editingStopped(javax.swing .event.ChangeEvent e);
// Methods Implementing ListSelectionListener
public void valueChanged(javax.swing .event.ListSelectionEvent e);
// Methods Implementing Scrollable
public java.awt.Dimension getPrefer redScrollableViewpor tSize();
public int getScrollableBlockIncrement(java.awt.Rectangle visibleRect, int orientation, int direction);
constant default:false
public boolean getScrollableTracksV iewportHeight();
default:true
public boolean getScrollableTracksV iewportW idth();
public int getScrollableUnitIncrement(java.awt.Rectangle visibleRect, int orientation, int direction);
// Methods Implementing TableColumnModelListener
public void columnAdded(javax.swing .event.TableColumnModelEvent e);
public void columnMarginChanged(javax.swing .event.ChangeEvent e);
public void columnMoved(javax.swing .event.TableColumnModelEvent e);
public void columnRemoved(javax.swing .event.TableColumnModelEvent e);
public void columnSelectionChanged(javax.swing .event.ListSelectionEvent e);
// Methods Implementing TableModelListener
public void tableChanged(javax.swing .event.TableModelEvent e);
// Public Methods Overriding JComponent
public void addNotify();
public String getToolT ipText(java.awt.e vent.MouseEvent event);
public void reshape(int x, int y, int width, int height);
public void updateUI();
// Protected Methods Overriding JComponent
protected String paramString();
// Protected Instance Methods
protected void conﬁgureEnclosingScrollPane();
protected javax.swing.table.TableColumnModel createDefaultColumnModel();
protected javax.swing.table.TableModel createDefaultDataModel();
protected void createDefaultEditors();
protected void createDefaultRenderers();
protected ListSelectionModel createDefaultSelectionModel();
protected javax.swing.table.JTableHeader createDefaultTableHeader();
protected void initializeLocalVars();
protected void resizeAndRepaint();
// Protected Instance Fields
protected boolean autoCreateColumnsFromModel;
protected int autoResizeMode;
protected transient javax.swing.table.TableCellEditor cellEditor;
protected boolean cellSelectionEnabled;
protected javax.swing.table.TableColumnModel columnModel;
protected javax.swing.table.TableModel dataModel;
protected transient java.util.Hashtable defaultEditorsByColumnClass;
protected transient java.util.Hashtable defaultRenderersByColumnClass;
protected transient int editingColumn;
protected transient int editingRow;
protected transient Component editorComp;
protected java.awt.Color gridColor;
protected java.awt.Dimension prefer redViewpor tSize;
protected int rowHeight;
protected int rowMargin;
protected boolean rowSelectionAllowed;
javax.swing.JTable
482 Chapter 23 – The javax.swing Package

protected java.awt.Color selectionBackground;
protected java.awt.Color selectionForeground;
protected ListSelectionModel selectionModel;
protected boolean showHorizontalLines;
protected boolean showVer ticalLines;
protected javax.swing.table.JTableHeader tableHeader;
// Deprecated Public Methods
# public static JScrollPane createScrollPaneForTable(JTable aTable);
# public void sizeColumnsToF it(boolean lastColumnOnly);
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→JComponent(Serializable)→JTable(Accessible,
javax.swing .event.CellEditorListener(java.util.EventListener),
javax.swing .event.ListSelectionListener(java.util.EventListener), Scrollable,
javax.swing .event.TableColumnModelListener(java.util.EventListener),
javax.swing .event.TableModelListener(java.util.EventListener))
Passed To: DefaultCellEditor.getTableCellEditorComponent(), JTable.createScrollPaneForTable(),
JTable.AccessibleJTable.AccessibleJTableCell.AccessibleJTableCell(),
javax.swing .table.DefaultTableCellRenderer.getTableCellRendererComponent(),
javax.swing .table.JTableHeader.setTable(),
javax.swing .table.JTableHeader.AccessibleJTableHeader.AccessibleJTableHeaderEntr y.AccessibleJTableHeaderEntr y(),
javax.swing .table.TableCellEditor.getTableCellEditorComponent(),
javax.swing .table.TableCellRenderer.getTableCellRendererComponent()
Retur ned By: javax.swing .table.JTableHeader.getTable()
Type Of: javax.swing .table.JTableHeader.table
JTextArea
Ja va 1.2
javax.swing
serializable accessible(text) swing component
JTextArea displays multiple lines of plain, unformatted text and allows the user to edit the
text. The JTextArea API is designed to be similar to the java.awt.TextArea API.
You can specify the text to be displayed by passing a String to the JTextArea constructor
or by using the setText() and getText() methods inherited from the superclass. Specify the
number of rows and columns to be displayed by the JTextArea by passing these values to
the constructor or by using the setRows() and setColumns() methods. The lineWrap pr op-
erty speciﬁes whether long lines should wrap. The wrapStyleWord pr operty speciﬁes
whether lines should wrap at word boundaries or at character boundaries. If you are
displaying more than a few lines of text, you probably want to place your JTextArea
within a JScrollPane to enable scrolling as needed.
JTextArea is a subclass of javax.swing .text.JTextComponent and inherits many features of that
power ful text editor. Many of the most commonly used JTextArea methods are actually
inherited from its superclass. They include the getText() and setText() methods already
mentioned, as well as setEditable(), getCaretPosition(), and setCaretPosition(). Like its super-
class, JTextArea uses a javax.swing .text.Document object as its model. Since a JTextArea dis-
plays only plain text, however, you can typically use a simple String object instead.
public class JTextArea extends javax.swing.text.JTextComponent {
// Public Constructors
public JTextArea();
public JTextArea(javax.swing .text.Document doc);
public JTextArea(String text);
public JTextArea(int rows, int columns);
javax.swing
javax.swing.JTextArea
Chapter 23 – The javax.swing Package
483

public JTextArea(String text, int rows, int columns);
public JTextArea(javax.swing .text.Document doc, String text, int rows, int columns);
// Inner Classes
protected class AccessibleJTextArea extends javax.swing.text.JTextComponent.AccessibleJTextComponent;
// Property Accessor Methods (by property name)
Overrides:JTextComponent default:AccessibleJTextArea
public AccessibleContext getAccessibleContext();
default:0
public int getColumns();
public void setColumns(int columns);
default:0
public int getLineCount();
default:false
public boolean getLineWrap();
bound preferred
public void setLineWrap(boolean wrap);
Overrides:JComponent constant default:true
public boolean isManagingFocus();
Overrides:JTextComponent
public java.awt.Dimension getPrefer redScrollableViewpor tSize();
Overrides:JComponent
public java.awt.Dimension getPrefer redSize();
default:0
public int getRows();
public void setRows(int rows);
Overrides:JTextComponent default:false
public boolean getScrollableTracksV iewportW idth();
default:8
public int getTabSize();
bound preferred
public void setTabSize(int size);
Overrides:JComponent default:"TextAreaUI"
public String getUIClassID();
default:false
public boolean getWrapStyleWord();
bound
public void setWrapStyleWord(boolean word);
// Public Instance Methods
public void append(String str);
public int getLineEndOffset(int line) throws javax.swing.text.BadLocationException;
public int getLineOfOffset(int offset) throws javax.swing.text.BadLocationException;
public int getLineStar tOffset(int line) throws javax.swing.text.BadLocationException;
public void inser t(String str, int pos);
public void replaceRange(String str, int star t, int end);
// Public Methods Overriding JTextComponent
public int getScrollableUnitIncrement(java.awt.Rectangle visibleRect, int orientation, int direction);
// Protected Methods Overriding JTextComponent
protected String paramString();
protected void processComponentKeyEvent(java.awt.e vent.Ke yEvent e);
// Public Methods Overriding JComponent
public void setFont(java.awt.Font f);
// Protected Instance Methods
protected javax.swing.text.Document createDefaultModel();
protected int getColumnW idth();
protected int getRowHeight();
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→JComponent(Serializable)→javax.swing .text.JTextComponent(Accessible, Scrollable)→
JTextArea
JTextF ield
Ja va 1.2
javax.swing
serializable accessible(text) swing component
JTextF ield allows the user to enter and edit a single line of plain text. JTextF ield is designed
to supersede java.awt.TextF ield, so it has a similar API. You can set and query the text with
the setText() and getText() methods inherited from the superclass. Use setFont() to specify
the font in which the text is displayed. Use setColumns() to set the number of characters
in the ﬁeld. Note that the speciﬁed number of columns is approximate unless you are
using a monospaced font. Note that JTextF ield inherits a number of useful properties
fr om its superclass. These include enabled, editable, caretPosition, and selectedText.
javax.swing.JTextArea
484 Chapter 23 – The javax.swing Package

JTextF ield ﬁr es an ActionEvent to any register ed ActionListener objects when the user types
Enter. You can specify the action command text sent with the ActionEvent by calling
setActionCommand().
public class JTextF ield extends javax.swing.text.JTextComponent implements SwingConstants {
// Public Constructors
public JTextF ield();
public JTextF ield(String text);
public JTextF ield(int columns);
public JTextF ield(String text, int columns);
public JTextF ield(javax.swing .text.Document doc, String text, int columns);
// Public Constants
="notify-ﬁeld-accept"
public static ﬁnal String notifyAction;
// Inner Classes
protected class AccessibleJTextF ield extends javax.swing.text.JTextComponent.AccessibleJTextComponent;
// Event Registration Methods (by event name)
synchronized
public void addActionListener(java.awt.e vent.ActionListener l);
synchronized
public void removeActionListener(java.awt.e vent.ActionListener l);
// Property Accessor Methods (by property name)
Overrides:JTextComponent default:AccessibleJTextF ield
public AccessibleContext getAccessibleContext();
Overrides:JTextComponent
public Action[ ] getActions();
default:0
public int getColumns();
public void setColumns(int columns);
default:2
public int getHorizontalAlignment();
bound preferred
public void setHorizontalAlignment(int alignment);
default:DefaultBoundedRangeModel
public BoundedRangeModel getHorizontalV isibility();
Overrides:JComponent
public java.awt.Dimension getPrefer redSize();
default:0
public int getScrollOffset();
public void setScrollOffset(int scrollOffset);
Overrides:JComponent default:"TextF ieldUI"
public String getUIClassID();
Overrides:JComponent constant default:true
public boolean isValidateRoot();
// Public Instance Methods
public void postActionEvent();
public void setActionCommand(String command);
// Protected Methods Overriding JTextComponent
protected String paramString();
// Public Methods Overriding JComponent
public void scrollRectToV isible(java.awt.Rectangle r);
public void setFont(java.awt.Font f);
// Protected Instance Methods
protected javax.swing.text.Document createDefaultModel();
protected void ﬁreActionPerfor med();
protected int getColumnW idth();
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→JComponent(Serializable)→javax.swing .text.JTextComponent(Accessible, Scrollable)→
JTextF ield(SwingConstants)
Subc lasses: JPasswordF ield, javax.swing .tree.DefaultTreeCellEditor.DefaultTextF ield
Passed To: DefaultCellEditor.DefaultCellEditor()
JTextPane
Ja va 1.2
javax.swing
serializable accessible(text) swing component
JTextPane is a component for displaying and editing multiline formatted text. When com-
bined with a GUI that allows the user to select fonts, colors, paragraph styles, and so
forth, it provides substantial word-processing functionality for any Java application.
JTextPane
works with documents that implement the
javax.swing .text.StyledDocument
javax.swing
javax.swing.JTextPane
Chapter 23 – The javax.swing Package
485

inter face, typically a DefaultStyledDocument. JTextPane also relies on javax.swing .text.StyledEdi-
torKit to provide auxiliary conﬁguration information.
JTextPane does not directly deﬁne methods for inserting styled text into the document.
You must work directly with the StyledDocument to do that. JTextPane allows the user to
edit text but does not provide any means for the user to specify or change the style of
that text. Your application must provide additional GUI components (e.g., a menu of
available styles or a dialog box for selecting a font) in order to allow the user to select
styles.
Call setCharacterAttributes() to specify attributes, such as font size and style, that apply to
individual characters. This method either sets the attributes of the currently selected
text, or, if ther e is no selection, speciﬁes attributes to be applied to text inserted in the
futur e. The boolean replace argument indicates whether these attributes should replace
the previous attributes or should augment them. setParagraphAttributes() is a similar
method, but it sets attributes, such as margins and justiﬁcation, that apply to entire
paragraphs of text.
In addition to displaying formatted text, JTextPane can also display images and arbitrary
components. JTextPane pr ovides the inser tComponent() and inser tIcon() methods to make it
easy to insert objects of these types without having to manipulate the StyledDocument
object.
public class JTextPane extends JEditorPane {
// Public Constructors
public JTextPane();
public JTextPane(javax.swing .text.StyledDocument doc);
// Property Accessor Methods (by property name)
default:LeafElement
public javax.swing.text.AttributeSet getCharacterAttributes();
Overrides:JTextComponent
public void setDocument(javax.swing .text.Document doc);
Overrides:JEditorPane
public ﬁnal void setEditorKit(javax.swing .text.EditorKit kit);
public javax.swing.text.MutableAttributeSet getInputAttributes();
default:NamedStyle
public javax.swing.text.Style getLogicalStyle();
public void setLogicalStyle(javax.swing .text.Style s);
default:BranchElement
public javax.swing.text.AttributeSet getParagraphAttributes();
Overrides:JEditorPane constant default:true
public boolean getScrollableTracksV iewportW idth();
default:DefaultStyledDocument
public javax.swing.text.StyledDocument getStyledDocument();
public void setStyledDocument(javax.swing .text.StyledDocument doc);
Overrides:JEditorPane default:"TextPaneUI"
public String getUIClassID();
// Public Instance Methods
public javax.swing.text.Style addStyle(String nm, javax.swing .text.Style parent);
public javax.swing.text.Style getStyle(String nm);
public void inser tComponent(Component c);
public void inser tIcon(Icon g);
public void removeStyle(String nm);
public void setCharacterAttributes(javax.swing .text.AttributeSet attr, boolean replace);
public void setParagraphAttributes(javax.swing .text.AttributeSet attr, boolean replace);
// Public Methods Overriding JEditorPane
public void replaceSelection(String content);
// Protected Methods Overriding JEditorPane
protected javax.swing.text.EditorKit createDefaultEditorKit();
protected String paramString();
// Protected Instance Methods
protected ﬁnal javax.swing.text.StyledEditorKit getStyledEditorKit();
}
javax.swing.JTextPane
486 Chapter 23 – The javax.swing Package

Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→JComponent(Serializable)→javax.swing .text.JTextComponent(Accessible, Scrollable)→
JEditorPane→JTextPane
JToggleButton
Ja va 1.2
javax.swing
serializable accessible(action,value) swing component
This class implements a toggle button: a button that can be selected or deselected. The
user can toggle between the selected and deselected states by clicking the button. Like
all Swing buttons, a JToggleButton can display text and an icon. The selection state is typ-
ically indicated by the button border and background color. You can also call setIcon()
and setSelectedIcon() to specify differ ent icons for the default and selected states. By
default, JToggleButton keeps track of its selection state with a JToggleButton.ToggleButtonModel
object. JToggleButton is less commonly used than its subclasses JCheckBox and JRadioButton.
public class JToggleButton extends AbstractButton implements Accessible {
// Public Constructors
public JToggleButton();
public JToggleButton(Icon icon);
public JToggleButton(String text);
public JToggleButton(String text, Icon icon);
public JToggleButton(Icon icon, boolean selected);
public JToggleButton(String text, boolean selected);
public JToggleButton(String text, Icon icon, boolean selected);
// Inner Classes
protected class AccessibleJToggleButton extends AbstractButton.AccessibleAbstractButton implements
java.awt.e vent.ItemListener;
public static class ToggleButtonModel extends DefaultButtonModel;
// Property Accessor Methods (by property name)
Implements:Accessible default:AccessibleJToggleButton expert
public AccessibleContext
getAccessibleContext();
Overrides:JComponent default:"ToggleButtonUI"
public String getUIClassID();
// Methods Implementing Accessible
default:AccessibleJToggleButton expert
public AccessibleContext getAccessibleContext();
// Public Methods Overriding AbstractButton
public void updateUI();
// Protected Methods Overriding AbstractButton
protected String paramString();
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→JComponent(Serializable)→AbstractButton(java.awt.ItemSelectable, SwingConstants)→
JToggleButton(Accessible)
Subc lasses: JCheckBox, JRadioButton
JToggleButton.ToggleButtonModel
Ja va 1.2
javax.swing
serializable model
This class is the ButtonModel used by default by JToggleButton, JCheckBox, and JRadioButton
components. It overrides several methods of DefaultButtonModel in order to delegate but-
ton selection state information to a ButtonGroup object. Applications typically never need
to instantiate this class.
public static class JToggleButton.ToggleButtonModel extends DefaultButtonModel {
// Public Constructors
public ToggleButtonModel();
javax.swing
javax.swing.JToggleButton.ToggleButtonModel
Chapter 23 – The javax.swing Package
487

// Public Methods Overriding DefaultButtonModel
default:false
public boolean isSelected();
public void setPressed(boolean b);
public void setSelected(boolean b);
}
JToolBar
Ja va 1.2
javax.swing
serializable accessible swing component
JToolBar is a container that displays a row or column of children, typically JButton chil-
dr en, that repr esent application tools or actions. JToolBar has two special features that
make it useful in applications. First, it has a special add() method that allows you to add
an Action object, rather than a Component, to it. When you do this, an appropriate JButton
is automatically created. This created button tracks the enabled state of the action, so if
the action is disabled, the button becomes disabled as well. The JMenu class has this
same ability to accept Action objects as children; the commonly used actions of an appli-
cation frequently appear in both JMenu and JToolBar components of the application. A
JToolBar can contain special separator components that serve to group related tools and
separate unrelated tools. You can add a separator to a JToolBar with the special addSepa-
rator() method.
The second special feature of JToolBar is that it is draggable. Unless this feature has been
disabled with setFloatable(), a JToolBar displays a special grip that the user can use to drag
the toolbar. If the user drags the toolbar out of the window in which it appears, it
becomes a ﬂoating palette in a window of its own. Additionally, if the JToolBar is posi-
tioned against one edge of a container that uses a java.awt.BorderLayout layout manager
and if there are no other components positioned against the edges, the user can drag
the JToolBar to any other edge of the container. The conventional orientation and posi-
tion for a JToolBar is a horizontal row of controls positioned just below the menubar at
the top of a window. By dragging the JToolBar, however, a user can automatically con-
vert it to a vertical toolbar positioned against the left edge of the window, for example.
JToolBar deﬁnes only a few interesting properties. As mentioned earlier, ﬂoatable speciﬁes
whether the user can drag the JToolBar. orientation speciﬁes whether the JToolBar arranges
its children into a horizontal or vertical bar. The value of this property should be one of
the SwingConstants constants HORIZONTAL or VERTICAL. The default is HORIZONTAL. Finally,
the margin pr operty speciﬁes the amount of space between the border of the toolbar
and its children.
public class JToolBar extends JComponent implements Accessible, SwingConstants {
// Public Constructors
public JToolBar();
public JToolBar(int orientation);
// Inner Classes
protected class AccessibleJToolBar extends JComponent.AccessibleJComponent;
public static class Separator extends JSeparator;
// Property Accessor Methods (by property name)
Implements:Accessible default:AccessibleJToolBar
public AccessibleContext getAccessibleContext();
default:true
public boolean isBorderPainted();
bound expert
public void setBorderPainted(boolean b);
default:true
public boolean isFloatable();
bound preferred
public void setFloatable(boolean b);
public java.awt.Insets getMargin();
bound expert
public void setMargin(java.awt.Insets m);
default:0
public int getOrientation();
bound preferred
public void setOrientation(int o);
javax.swing.JToggleButton.ToggleButtonModel
488 Chapter 23 – The javax.swing Package

public javax.swing.plaf.ToolBarUI getUI();
bound expert hidden
public void setUI(javax.swing .plaf.ToolBarUI ui);
Overrides:JComponent default:"ToolBarUI"
public String getUIClassID();
// Public Instance Methods
public JButton add(Action a);
public void addSeparator();
public void addSeparator(java.awt.Dimension size);
public Component getComponentAtIndex(int i);
public int getComponentIndex(Component c);
// Methods Implementing Accessible
default:AccessibleJToolBar
public AccessibleContext getAccessibleContext();
// Public Methods Overriding JComponent
public void updateUI();
// Protected Methods Overriding JComponent
protected void paintBorder(java.awt.Graphics g);
protected String paramString();
// Public Methods Overriding Container
public void remove(Component comp);
// Protected Methods Overriding Container
protected void addImpl(Component comp, Object constraints, int index);
// Protected Instance Methods
protected java.beans.PropertyChangeListener createActionChangeListener(JButton b);
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→JComponent(Serializable)→JToolBar(Accessible, SwingConstants)
JToolBar.Separator
Ja va 1.2
javax.swing
serializable accessible swing component
This subclass of JSeparator deﬁnes a visual separator component specially tuned for use
within a JToolBar. Practically speaking, this class is no differ ent than JSeparator. You
should rarely need to explicitly create or work with a JToolBar.Separator. Just call JTool-
Bar.addSeparator() as needed to create separators and add them to a JToolBar.
public static class JToolBar.Separator extends JSeparator {
// Public Constructors
public Separator();
public Separator(java.awt.Dimension size);
// Property Accessor Methods (by property name)
Overrides:JComponent
public java.awt.Dimension getMaximumSize();
Overrides:JComponent
public java.awt.Dimension getMinimumSize();
Overrides:JComponent
public java.awt.Dimension getPrefer redSize();
default:DimensionUIResource
public java.awt.Dimension getSeparatorSize();
public void setSeparatorSize(java.awt.Dimension size);
Overrides:JSeparator
public String getUIClassID();
}
JToolT ip
Ja va 1.2
javax.swing
serializable accessible swing component
JToolT ip is the component used to display tooltips in Swing applications. To display a
tooltip over a component, simply call setToolT ipText() over that component. You rarely or
never need to work with the JToolT ip class itself. If you want to customize the appear-
ance of the tooltip displayed by a component, you can override the createToolT ip()
method of that component, to retur n your own JToolT ip object.
javax.swing
javax.swing.JToolTip
Chapter 23 – The javax.swing Package
489

public class JToolT ip extends JComponent implements Accessible {
// Public Constructors
public JToolT ip();
// Inner Classes
protected class AccessibleJToolT ip extends JComponent.AccessibleJComponent;
// Property Accessor Methods (by property name)
Implements:Accessible default:AccessibleJToolTip
public AccessibleContext getAccessibleContext();
default:null
public JComponent getComponent();
public void setComponent(JComponent c);
default:null
public String getT ipText();
bound preferred
public void setT ipText(String tipText);
public javax.swing.plaf.ToolT ipUI getUI();
Overrides:JComponent default:"ToolTipUI"
public String getUIClassID();
// Methods Implementing Accessible
default:AccessibleJToolTip
public AccessibleContext getAccessibleContext();
// Public Methods Overriding JComponent
public void updateUI();
// Protected Methods Overriding JComponent
protected String paramString();
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→JComponent(Serializable)→JToolT ip(Accessible)
Retur ned By: JComponent.createToolT ip()
JTree
Ja va 1.2
javax.swing
serializable accessible(selection) swing component
JTree is a powerful Swing component for displaying hierarchical, tree-structur ed data in
outline form. The user can expand and collapse the outline to show or hide the chil-
dr en of any node in the tree. The user can also select and optionally edit the values
displayed in the tree.
JTree relies on the classes and interfaces in the javax.swing .tree package. Most importantly,
it uses a TreeModel object to encapsulate the tree data it displays. If your data already
has a hierarchical structure, you should implement a TreeModel class to serve as an inter-
mediary between your data structures and the JTree component. If your data is not
implicitly hierarchical, you can arrange it into a hierarchy by implementing the TreeNode
or MutableTreeNode inter face or by encapsulating your objects within DefaultMutableTreeN-
ode objects that implement these interfaces for you. Once you have done this, you can
rely on the default JTree model, DefaultTreeModel.
JTree also deﬁnes constructors that accept tree data in the form of an Object[], a Vector, or
a Hashtable. If your data is relatively simple and you can express it in one of these
for ms, it is easy to use one of these constructors to display your data. If you specify a
vector or object array, the elements of the vector or array become the nodes of the tree.
If any of those elements are a vector, array, or hashtable, the contents of that element
become the children of that node. If you specify a Hashtable, the keys of the hashtable
become the nodes of the tree and the values of the hashtable become the children of
those nodes. This is particularly useful, of course, if the hashtable values are arrays or
vectors.
By default, tree nodes are not editable. You can change this, however, with the setEd-
itable() method. The selection state and selection mode of a JTree is maintained by a
javax.swing .tree.TreeSelectionModel object. By default, JTree uses a DefaultTreeSelectionModel
object. You can set your own object with setSelectionModel(). Use the setSelectionMode()
javax.swing.JToolTip
490 Chapter 23 – The javax.swing Package

method of the TreeSelectionModel to specify the type of selection that is supported by the
JTree. To disable selection in a JTree altogether, pass null to setSelectionModel().
JTree deﬁnes a number of methods for setting and querying the current selection state of
the tree. It also deﬁnes methods for collapsing and expanding nodes and for querying
nodes to determine whether they are expanded. These methods use two differ ent tech-
niques for referring to a particular node in the tree. One technique is to specify the
integer row number at which the item appears. While this is a convenient way to refer
to an item that the user has selected, for example, it does not map naturally to an item
in the
TreeModel.
The other way to refer to an item in a
JTree
is with a
javax.swing .tree.TreePath object. A TreePath is essentially an array of objects that contains the
node itself and all of its ancestors up to the root of the tree. The ﬁrst element in the
array is the root, and the last element is the tree node that is being referr ed to. The
methods getPathForRow() and getRowForPath() allow you to convert from one node repr e-
sentation to another. Related methods convert between X, Y coordinates (such as the
coordinates contained in a MouseEvent) and the nearest TreePath or tree row.
JTree displays its nodes using a javax.swing .tree.TreeCellRenderer object. By default, it uses
DefaultTreeCellRenderer, which displays any object in the tree in text form by calling its
toString() method. If you want to display custom objects in a tree, you can implement
your own TreeCellRenderer and pass an instance to setCellRenderer(). JTree does not allow its
nodes to be edited by default, but when editing is enabled, it is done with a TreeCellEdi-
tor object. The DefaultTreeCellEditor allows editing of String and Boolean nodes. You can
implement your own TreeCellEditor if you want to allow the user to edit other node
types.
JTree deﬁnes quite a few methods for querying and setting the state of the tree. The pur-
pose of most of these methods is fairly obvious. One thing to note is that differ ent
methods use the word visible to mean differ ent things. The methods isV isible() and make-
Visible() use visible to refer to a node that is displayed under an expanded parent.
Under this deﬁnition, a node may be visible even if it is currently scrolled off the
scr een. All other methods, such as scrollPathToV isible(), use visible to mean that a node is
actually on the screen and currently visible to the user.
JTree implements the Scrollable inter face, and, unless you are displaying a very small,
ﬁxed-size tree, you should almost always place a JTree within a JScrollPane container. If
you are using JTree to view a large amount of data, if all the nodes are of the same type,
and if the TreeModel has an efﬁcient implementation, you may get better perfor mance by
passing tr ue to setLargeModel().
public class JTree extends JComponent implements Accessible, Scrollable {
// Public Constructors
public JTree();
public JTree(java.util.Vector value);
public JTree(javax.swing .tree.TreeNode root);
public JTree(java.util.Hashtable value);
public JTree(Object[ ] value);
public JTree(javax.swing .tree.TreeModel newModel);
public JTree(javax.swing .tree.TreeNode root, boolean asksAllowsChildren);
// Public Constants
="cellEditor"
public static ﬁnal String CELL_EDITOR_PROPERTY;
="cellRenderer"
public static ﬁnal String CELL_RENDERER_PROPERTY;
="editable"
public static ﬁnal String EDITABLE_PROPERTY;
="messagesStopCellEditing"
public static ﬁnal String INVOKES_STOP_CELL_EDITING_PROPERTY;
="largeModel"
public static ﬁnal String LARGE_MODEL_PROPERTY;
="rootVisible"
public static ﬁnal String ROOT_VISIBLE_PROPERTY;
="rowHeight"
public static ﬁnal String RO W_HEIGHT_PROPERTY;
="scrollsOnExpand"
public static ﬁnal String SCROLLS_ON_EXPAND_PROPERTY;
javax.swing
javax.swing.JTree
Chapter 23 – The javax.swing Package
491

="selectionModel"
public static ﬁnal String SELECTION_MODEL_PROPERTY;
="showsRootHandles"
public static ﬁnal String SHOWS_ROOT_HANDLES_PROPERTY;
="treeModel"
public static ﬁnal String TREE_MODEL_PROPERTY;
="visibleRowCount"
public static ﬁnal String VISIBLE_ROW_COUNT_PROPERTY;
// Inner Classes
protected class AccessibleJTree extends JComponent.AccessibleJComponent implements AccessibleSelection,
javax.swing .event.TreeExpansionListener, javax.swing .event.TreeModelListener,
javax.swing .event.TreeSelectionListener ;
public static class DynamicUtilTreeNode extends javax.swing.tree.DefaultMutableTreeNode;
protected static class EmptySelectionModel extends javax.swing.tree.DefaultTreeSelectionModel;
protected class TreeModelHandler implements javax.swing.e vent.TreeModelListener ;
protected class TreeSelectionRedirector implements Serializable, javax.swing .event.TreeSelectionListener ;
// Protected Class Methods
protected static javax.swing.tree.TreeModel createTreeModel(Object value);
protected static javax.swing.tree.TreeModel getDefaultTreeModel();
// Event Registration Methods (by event name)
public void addTreeExpansionListener(javax.swing .event.TreeExpansionListener tel);
public void removeTreeExpansionListener(javax.swing .event.TreeExpansionListener tel);
public void addTreeSelectionListener(javax.swing .event.TreeSelectionListener tsl);
public void removeTreeSelectionListener(javax.swing .event.TreeSelectionListener tsl);
public void addTreeW illExpandListener(javax.swing .event.TreeW illExpandListener tel);
public void removeTreeW illExpandListener(javax.swing .event.TreeW illExpandListener tel);
// Property Accessor Methods (by property name)
Implements:Accessible default:AccessibleJTree
public AccessibleContext getAccessibleContext();
default:null
public javax.swing.tree.TreeCellEditor getCellEditor();
bound
public void setCellEditor(javax.swing .tree.TreeCellEditor cellEditor);
default:DefaultTreeCellRenderer
public javax.swing.tree.TreeCellRenderer getCellRenderer();
bound
public void setCellRenderer(javax.swing .tree.TreeCellRenderer x);
default:false
public boolean isEditable();
bound
public void setEditable(boolean ﬂag);
default:false
public boolean isEditing();
default:null
public javax.swing.tree.TreePath getEditingPath();
default:false
public boolean isF ixedRowHeight();
default:false
public boolean getInvokesStopCellEditing();
bound
public void setInvokesStopCellEditing(boolean newValue);
default:false
public boolean isLargeModel();
bound
public void setLargeModel(boolean newValue);
default:null
public Object getLastSelectedPathComponent();
default:null
public javax.swing.tree.TreePath getLeadSelectionPath();
default:-1
public int getLeadSelectionRow();
default:-1
public int getMaxSelectionRow();
default:-1
public int getMinSelectionRow();
default:DefaultTreeModel
public javax.swing.tree.TreeModel getModel();
bound
public void setModel(javax.swing .tree.TreeModel newModel);
Implements:Scrollable
public java.awt.Dimension getPrefer redScrollableViewpor tSize();
default:true
public boolean isRootV isible();
bound
public void setRootV isible(boolean rootVisible);
default:4
public int getRowCount();
default:0
public int getRowHeight();
bound
public void setRowHeight(int rowHeight);
Implements:Scrollable default:false
public boolean getScrollableTracksV iewportHeight();
Implements:Scrollable default:false
public boolean getScrollableTracksV iewportW idth();
default:true
public boolean getScrollsOnExpand();
public void setScrollsOnExpand(boolean newValue);
default:0
public int getSelectionCount();
default:true
public boolean isSelectionEmpty();
default:DefaultTreeSelectionModel
public javax.swing.tree.TreeSelectionModel getSelectionModel();
bound
public void setSelectionModel(javax.swing .tree.TreeSelectionModel selectionModel);
javax.swing.JTree
492 Chapter 23 – The javax.swing Package

default:null
public javax.swing.tree.TreePath getSelectionPath();
public void setSelectionPath(javax.swing .tree.TreePath path);
default:null
public javax.swing.tree.TreePath[ ] getSelectionPaths();
public void setSelectionPaths(javax.swing .tree.TreePath[ ] paths);
default:null
public int[ ] getSelectionRows();
public void setSelectionRows(int[ ] rows);
default:false
public boolean getShowsRootHandles();
bound
public void setShowsRootHandles(boolean newValue);
public javax.swing.plaf.TreeUI getUI();
public void setUI(javax.swing .plaf.TreeUI ui);
Overrides:JComponent default:"TreeUI"
public String getUIClassID();
default:20
public int getV isibleRowCount();
bound
public void setV isibleRowCount(int newCount);
// Public Instance Methods
public void addSelectionInter val(int index0, int index1);
public void addSelectionPath(javax.swing .tree.TreePath path);
public void addSelectionPaths(javax.swing .tree.TreePath[ ] paths);
public void addSelectionRow(int row);
public void addSelectionRows(int[ ] rows);
public void cancelEditing();
public void clearSelection();
public void collapsePath(javax.swing .tree.TreePath path);
public void collapseRow(int row);
public String conver tValueToText(Object value, boolean selected, boolean expanded, boolean leaf, int row,
boolean hasFocus);
public void expandPath(javax.swing .tree.TreePath path);
public void expandRow(int row);
public void ﬁreTreeCollapsed(javax.swing .tree.TreePath path);
public void ﬁreTreeExpanded(javax.swing .tree.TreePath path);
public void ﬁreTreeW illCollapse(javax.swing .tree.TreePath path) throws javax.swing.tree.ExpandVetoException;
public void ﬁreTreeW illExpand(javax.swing .tree.TreePath path) throws javax.swing.tree.ExpandVetoException;
public javax.swing.tree.TreePath getClosestPathForLocation(int x, int y);
public int getClosestRowForLocation(int x, int y);
public java.util.Enumeration getExpandedDescendants(javax.swing .tree.TreePath parent);
public java.awt.Rectangle getPathBounds(javax.swing .tree.TreePath path);
public javax.swing.tree.TreePath getPathForLocation(int x, int y);
public javax.swing.tree.TreePath getPathForRow(int row);
public java.awt.Rectangle getRowBounds(int row);
public int getRowForLocation(int x, int y);
public int getRowForPath(javax.swing .tree.TreePath path);
public boolean hasBeenExpanded(javax.swing .tree.TreePath path);
public boolean isCollapsed(int row);
public boolean isCollapsed(javax.swing .tree.TreePath path);
public boolean isExpanded(int row);
public boolean isExpanded(javax.swing .tree.TreePath path);
public boolean isPathEditable(javax.swing .tree.TreePath path);
public boolean isPathSelected(javax.swing .tree.TreePath path);
public boolean isRowSelected(int row);
public boolean isV isible(javax.swing .tree.TreePath path);
public void makeV isible(javax.swing .tree.TreePath path);
public void removeSelectionInter val(int index0, int index1);
public void removeSelectionPath(javax.swing .tree.TreePath path);
public void removeSelectionPaths(javax.swing .tree.TreePath[ ] paths);
public void removeSelectionRow(int row);
public void removeSelectionRows(int[ ] rows);
public void scrollPathToV isible(javax.swing .tree.TreePath path);
public void scrollRowToV isible(int row);
public void setSelectionInter val(int index0, int index1);
javax.swing
javax.swing.JTree
Chapter 23 – The javax.swing Package
493

public void setSelectionRow(int row);
public void star tEditingAtPath(javax.swing .tree.TreePath path);
public boolean stopEditing();
public void treeDidChange();
// Methods Implementing Accessible
default:AccessibleJTree
public AccessibleContext getAccessibleContext();
// Methods Implementing Scrollable
public java.awt.Dimension getPrefer redScrollableViewpor tSize();
public int getScrollableBlockIncrement(java.awt.Rectangle visibleRect, int orientation, int direction);
default:false
public boolean getScrollableTracksV iewportHeight();
default:false
public boolean getScrollableTracksV iewportW idth();
public int getScrollableUnitIncrement(java.awt.Rectangle visibleRect, int orientation, int direction);
// Public Methods Overriding JComponent
public String getToolT ipText(java.awt.e vent.MouseEvent event);
public void updateUI();
// Protected Methods Overriding JComponent
protected String paramString();
// Protected Instance Methods
protected void clearToggledPaths();
protected javax.swing.e vent.TreeModelListener createTreeModelListener();
protected void ﬁreValueChanged(javax.swing .event.TreeSelectionEvent e);
protected java.util.Enumeration getDescendantToggledPaths(javax.swing .tree.TreePath parent);
protected javax.swing.tree.TreePath[ ] getPathBetweenRows(int index0, int index1);
protected void removeDescendantToggledPaths(java.util.Enumeration toRemove);
protected void setExpandedState(javax.swing .tree.TreePath path, boolean state);
// Protected Instance Fields
protected transient javax.swing.tree.TreeCellEditor cellEditor;
protected transient javax.swing.tree.TreeCellRenderer cellRenderer;
protected boolean editable;
protected boolean invokesStopCellEditing;
protected boolean largeModel;
protected boolean rootV isible;
protected int rowHeight;
protected boolean scrollsOnExpand;
protected transient javax.swing.tree.TreeSelectionModel selectionModel;
protected transient JTree.TreeSelectionRedirector selectionRedirector;
protected boolean showsRootHandles;
protected int toggleClickCount;
protected transient javax.swing.tree.TreeModel treeModel;
protected transient javax.swing.e vent.TreeModelListener treeModelListener;
protected int visibleRowCount;
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→JComponent(Serializable)→JTree(Accessible, Scrollable)
Passed To: Too many methods to list.
Type Of: javax.swing .tree.DefaultTreeCellEditor.tree
JTree.DynamicUtilTreeNode
Ja va 1.2
javax.swing
cloneable serializable
This subclass of javax.swing .tree.DefaultMutableTreeNode is used by the JTree constructors that
accept tree data in the form of a Vector, Hashtable, or Object[]. The static createChildren()
method is used to populate a node with the children contained in a speciﬁed Vector,
Hashtable, or array. DynamicUtilTreeNode is dynamic in the sense that it dynamically creates
childr en nodes when those nodes are requested for the ﬁrst time.
javax.swing.JTree
494 Chapter 23 – The javax.swing Package

public static class JTree.DynamicUtilTreeNode extends javax.swing.tree.DefaultMutableTreeNode {
// Public Constructors
public DynamicUtilTreeNode(Object value, Object children);
// Public Class Methods
public static void createChildren(javax.swing .tree.DefaultMutableTreeNode parent, Object children);
// Public Methods Overriding DefaultMutableTreeNode
public java.util.Enumeration children();
public javax.swing.tree.TreeNode getChildAt(int index);
public int getChildCount();
public boolean isLeaf();
// Protected Instance Methods
protected void loadChildren();
// Protected Instance Fields
protected Object childValue;
protected boolean hasChildren;
protected boolean loadedChildren;
}
JTree.EmptySelectionModel
Ja va 1.2
javax.swing
cloneable serializable model
This subclass of javax.swing .tree.DefaultTreeSelectionModel deﬁnes empty selection methods
and is used to disable selection in a JTree. You never need to instantiate this class
explicitly; simply pass null to the setSelectionModel() method of JTree.
protected static class JTree.EmptySelectionModel extends javax.swing.tree.DefaultTreeSelectionModel {
// Protected Constructors
protected EmptySelectionModel();
// Protected Constants
protected static ﬁnal JTree.EmptySelectionModel sharedInstance;
// Public Class Methods
public static JTree.EmptySelectionModel sharedInstance();
// Public Methods Overriding DefaultTreeSelectionModel
empty
public void addSelectionPaths(javax.swing .tree.TreePath[ ] paths);
empty
public void removeSelectionPaths(javax.swing .tree.TreePath[ ] paths);
empty
public void setSelectionPaths(javax.swing .tree.TreePath[ ] pPaths);
}
Retur ned By: JTree.EmptySelectionModel.sharedInstance()
Type Of: JTree.EmptySelectionModel.sharedInstance
JTree.TreeModelHandler
Ja va 1.2
javax.swing
This class is a javax.swing .event.TreeModelListener used internally by JTree to track changes
made to the tree data contained in the TreeModel. Applications never need to use this
class.
protected class JTree.TreeModelHandler implements javax.swing.e vent.TreeModelListener {
// Protected Constructors
protected TreeModelHandler();
// Methods Implementing TreeModelListener
empty
public void treeNodesChanged(javax.swing .event.TreeModelEvent e);
empty
public void treeNodesInser ted(javax.swing .event.TreeModelEvent e);
public void treeNodesRemoved(javax.swing .event.TreeModelEvent e);
public void treeStr uctureChanged(javax.swing .event.TreeModelEvent e);
}
javax.swing
javax.swing.JTree.TreeModelHandler
Chapter 23 – The javax.swing Package
495

JTree.TreeSelectionRedirector
Ja va 1.2
javax.swing
serializable
This javax.swing .event.TreeSelectionListener class is used internally by JTree to redir ect
javax.swing .tree.TreeSelectionEvent objects so that they appear to come from the JTree, rather
than the TreeSelectionModel object. Applications never need to use this class.
protected class JTree.TreeSelectionRedirector implements Serializable, javax.swing.e vent.TreeSelectionListener {
// Protected Constructors
protected TreeSelectionRedirector();
// Methods Implementing TreeSelectionListener
public void valueChanged(javax.swing .event.TreeSelectionEvent e);
}
Type Of: JTree.selectionRedirector
JV iewport
Ja va 1.2
javax.swing
serializable accessible swing component
This component displays a portion of the larger child component it contains. It deﬁnes
methods for efﬁciently scrolling the child component within the viewable area. Pass tr ue
to setBackingStoreEnabled() to use an off-scr een image to increase the efﬁciency of small
scr olls. JV iewpor t is used by JScrollPane, and most applications use JScrollPane instead of
using JV iewpor t dir ectly.
public class JV iewport extends JComponent implements Accessible {
// Public Constructors
public JV iewport();
// Inner Classes
protected class AccessibleJV iewport extends JComponent.AccessibleJComponent;
protected class ViewListener extends java.awt.event.ComponentAdapter implements Serializable;
// Event Registration Methods (by event name)
public void addChangeListener(javax.swing .event.ChangeListener l);
public void removeChangeListener(javax.swing .event.ChangeListener l);
// Property Accessor Methods (by property name)
Implements:Accessible default:AccessibleJViewport
public AccessibleContext getAccessibleContext();
default:false
public boolean isBackingStoreEnabled();
public void setBackingStoreEnabled(boolean x);
Overrides:JComponent
public ﬁnal void setBorder(javax.swing .border.Border border);
public java.awt.Dimension getExtentSize();
public void setExtentSize(java.awt.Dimension newExtent);
Overrides:JComponent
public ﬁnal java.awt.Insets getInsets();
Overrides:JComponent expert
public ﬁnal java.awt.Insets getInsets(java.awt.Insets insets);
Overrides:JComponent constant default:false
public boolean isOptimizedDrawingEnabled();
default:null
public Component getV iew();
public void setV iew(Component view);
public java.awt.Point getV iewPosition();
public void setV iewPosition(java.awt.Point p);
public java.awt.Rectangle getV iewRect();
public java.awt.Dimension getV iewSize();
public void setV iewSize(java.awt.Dimension newSize);
// Public Instance Methods
public java.awt.Dimension toV iewCoordinates(java.awt.Dimension size);
public java.awt.Point toV iewCoordinates(java.awt.Point p);
// Methods Implementing Accessible
default:AccessibleJViewpor t
public AccessibleContext getAccessibleContext();
// Public Methods Overriding JComponent
public void paint(java.awt.Graphics g);
public void repaint(long tm, int x, int y, int w, int h);
javax.swing.JTree.TreeSelectionRedirector
496 Chapter 23 – The javax.swing Package

public void reshape(int x, int y, int w, int h);
public void scrollRectToV isible(java.awt.Rectangle contentRect);
// Protected Methods Overriding JComponent
protected void ﬁreProper tyChange(String proper tyName, Object oldValue, Object newValue);
protected String paramString();
// Public Methods Overriding Container
public void remove(Component child);
// Protected Methods Overriding Container
protected void addImpl(Component child, Object constraints, int index);
// Protected Instance Methods
protected boolean computeBlit(int dx, int dy, java.awt.Point blitFrom, java.awt.Point blitTo,
java.awt.Dimension blitSize, java.awt.Rectangle blitPaint);
protected java.awt.LayoutManager createLayoutManager();
protected JVie wport.V ie wListener createV iewListener();
protected void ﬁreStateChanged();
// Protected Instance Fields
protected boolean backingStore;
protected transient java.awt.Image backingStoreImage;
protected boolean isV iewSizeSet;
protected java.awt.Point lastPaintPosition;
protected boolean scrollUnderway;
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→JComponent(Serializable)→JV iewpor t(Accessible)
Passed To: JScrollPane.{setColumnHeader(), setRowHeader(), setViewpor t()}
Retur ned By: JScrollPane.{createV iewpor t(), getColumnHeader(), getRowHeader(), getV iewpor t()},
ScrollPaneLayout.{getColumnHeader(), getRowHeader(), getV iewpor t()}
Type Of: JScrollPane.{columnHeader, rowHeader, viewpor t}, JScrollPane.AccessibleJScrollPane.viewPor t,
ScrollPaneLayout.{colHead, rowHead, viewpor t}
JV iewport.V iewListener
Ja va 1.2
javax.swing
serializable
This ComponentListener is used internally by JV iewpor t to detect changes to the child com-
ponent. Applications never use this class directly.
protected class JV iewport.V iewListener extends java.awt.event.ComponentAdapter implements Serializable {
// Protected Constructors
protected ViewListener();
// Public Methods Overriding ComponentAdapter
public void componentResized(java.awt.e vent.ComponentEvent e);
}
Retur ned By: JV iewpor t.createViewListener()
JW indow
Ja va 1.2
javax.swing
serializable accessible swing component bean container
This class is the Swing analog of the java.awt.W indow class. It is a basic heavyweight top-
level window with no titlebar or other frame decorations. Most applications use JFrame
and JDialog in prefer ence to JW indow. Like JFrame and JDialog, JW indow is a RootPaneCon-
tainer, which means that it has an automatically created JRootPane as its single child. You
ar e not allowed to add children or set a layout manager on the JW indow itself. Instead,
you must use the container retur ned by the getContentPane().
javax.swing
javax.swing.JWindow
Chapter 23 – The javax.swing Package
497

public class JW indow extends java.awt.Window implements Accessible, RootPaneContainer {
// Public Constructors
public JW indow();
public JW indow(java.awt.W indow owner);
public JW indow(java.awt.Frame owner);
// Inner Classes
protected class AccessibleJW indow extends AccessibleContext implements AccessibleComponent, Serializable;
// Property Accessor Methods (by property name)
Implements:Accessible default:AccessibleJWindow
public AccessibleContext getAccessibleContext();
Implements:RootPaneContainer default:JPanel
public Container getContentPane();
Implements:RootPaneContainer hidden
public void setContentPane(Container contentPane);
Implements:RootPaneContainer default:JPanel
public Component getGlassPane();
Implements:RootPaneContainer hidden
public void setGlassPane(Component glassPane);
Implements:RootPaneContainer
public JLayeredPane getLayeredPane();
Implements:RootPaneContainer hidden
public void setLayeredPane(JLayeredPane layeredPane);
Overrides:Container
public void setLayout(java.awt.LayoutManager manager);
Implements:RootPaneContainer
public JRootPane getRootPane();
// Methods Implementing Accessible
default:AccessibleJWindow
public AccessibleContext getAccessibleContext();
// Methods Implementing RootPaneContainer
default:JPanel
public Container getContentPane();
default:JPanel
public Component getGlassPane();
public JLayeredPane getLayeredPane();
public JRootPane getRootPane();
hidden
public void setContentPane(Container contentPane);
hidden
public void setGlassPane(Component glassPane);
hidden
public void setLayeredPane(JLayeredPane layeredPane);
// Public Methods Overriding Container
public void remove(Component comp);
// Protected Methods Overriding Container
protected void addImpl(Component comp, Object constraints, int index);
protected String paramString();
// Protected Instance Methods
protected JRootPane createRootPane();
protected boolean isRootPaneCheckingEnabled();
hidden
protected void setRootPane(JRootPane root);
hidden
protected void setRootPaneCheckingEnabled(boolean enabled);
protected void windowInit();
// Protected Instance Fields
protected AccessibleContext accessibleContext;
protected JRootPane rootPane;
protected boolean rootPaneCheckingEnabled;
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→java.awt.W indow→JW indow(Accessible, RootPaneContainer)
KeyStroke
Ja va 1.2
javax.swing
serializable
This class repr esents a single keystroke, speciﬁed either as a character or, mor e ﬂexibly,
as a keycode plus a set of keyboard modiﬁers. KeyStroke objects are immutable, and the
KeyStroke class maintains a cache of the objects. There is no public KeyStroke constructor.
Instead, call one of the static getKeyStroke() methods to obtain a refer ence to a KeyStroke
object that repr esents the desired keystroke. Note that some versions of getKeyStroke()
take a boolean argument that speciﬁes whether the KeyStroke repr esents a key release
event instead of a key press event. The keyCode argument to getKeyStroke() should be one
of the VK_ virtual key constants deﬁned by java.awt.event.KeyEvent. The modiﬁers argument
javax.swing.JWindow
498 Chapter 23 – The javax.swing Package

should be a bitmask composed of the ALT_MASK, CTRL_MASK, META_MASK, and SHIFT_MASK
constants deﬁned by java.awt.Event.
See also the registerKeyboardAction() method of JComponent, the setAccelerator() method of
JMenuItem, and javax.awt.swing .text.Keymap.
public class KeyStroke implements Serializable {
// No Constructor
// Public Class Methods
public static KeyStroke getKeyStroke(char keyChar);
public static KeyStroke getKeyStroke(String s);
public static KeyStroke getKeyStroke(int keyCode, int modiﬁers);
public static KeyStroke getKeyStroke(int keyCode, int modiﬁers, boolean onKeyRelease);
public static KeyStroke getKeyStrokeForEvent(java.awt.e vent.Ke yEvent anEvent);
// Property Accessor Methods (by property name)
public char getKeyChar();
public int getKeyCode();
public int getModiﬁers();
public boolean isOnKeyRelease();
// Public Methods Overriding Object
public boolean equals(Object anObject);
public int hashCode();
public String toString();
// Deprecated Public Methods
# public static KeyStroke getKeyStroke(char keyChar, boolean onKeyRelease);
}
Hierar chy: Object→KeyStroke(Serializable)
Passed To: JComponent.{getActionForKeyStroke(), getConditionForKeyStroke(), registerKeyboardAction(),
unregisterKeyboardAction()}, JMenu.setAccelerator(), JMenuItem.setAccelerator(),
javax.swing .text.JTextComponent.KeyBinding.KeyBinding(), javax.swing .text.Keymap.{addActionForKeyStroke(),
getAction(), isLocallyDefined(), removeKeyStrokeBinding()}
Retur ned By: JComponent.getRegisteredKeyStrokes(), JMenuItem.getAccelerator(),
KeyStroke.{getKeyStroke(), getKeyStrokeForEvent()}, javax.swing .text.Keymap.{getBoundKeyStrokes(),
getKeyStrokesForAction()}
Type Of: javax.swing .text.JTextComponent.KeyBinding.key
ListCellRenderer
Ja va 1.2
javax.swing
This interface deﬁnes the method that must be implemented by any object that wants
to be able to render items in a JList component. Most applications can rely on the
default behavior of JList (to use a DefaultListCellRenderer) and never need to implement or
use this interface. getListCellRendererComponent() is passed information about the list item
that is to be render ed; it should retur n a lightweight java.awt.Component capable of ren-
dering the list item. The JList object ﬁrst positions this component at the desired location
by calling its setBounds() method and then asks the component to draw itself by calling
paint(). Note, however, that the component is never actually added to the component
hierarchy.
public abstract interface ListCellRenderer {
// Public Instance Methods
public abstract Component getListCellRendererComponent(JList list, Object value, int index,
boolean isSelected, boolean cellHasFocus);
}
Implementations: DefaultListCellRenderer
javax.swing
javax.swing.ListCellRenderer
Chapter 23 – The javax.swing Package
499

Passed To: JComboBox.setRenderer(), JList.setCellRenderer()
Retur ned By: JComboBox.getRenderer(), JList.getCellRenderer()
Type Of: JComboBox.renderer
ListModel
Ja va 1.2
javax.swing
model
This interface deﬁnes the methods that must be implemented by any object that wants
to maintain a list of values for display in a JList or similar component. A ListModel must
be able to retur n the size of the list, retur n any numbered element of the list, and ﬁre a
ListDataEvent event to any register ed ListDataListener objects whenever the contents of the
list changes. ListModel implementations that repr esent immutable lists can provide
dummy no-op implementations of the event registration methods. Most applications do
not need to implement this interface; they can work with JList dir ectly or use the Default-
ListModel class.
public abstract interface ListModel {
// Event Registration Methods (by event name)
public abstract void addListDataListener(javax.swing .event.ListDataListener l);
public abstract void removeListDataListener(javax.swing .event.ListDataListener l);
// Public Instance Methods
public abstract Object getElementAt(int index);
public abstract int getSize();
}
Implementations: AbstractListModel, ComboBoxModel
Passed To: JList.{JList(), setModel()}
Retur ned By: JList.getModel()
ListSelectionModel
Ja va 1.2
javax.swing
model
This interface deﬁnes the methods that an object must implement if it wants to keep
track of the selection state for a JList, JTable, or similar component. Most applications use
DefaultListSelectionModel and never have to implement this interface.
public abstract interface ListSelectionModel {
// Public Constants
=2
public static ﬁnal int MULTIPLE_INTERVAL_SELECTION;
=1
public static ﬁnal int SINGLE_INTERVAL_SELECTION;
=0
public static ﬁnal int SINGLE_SELECTION;
// Event Registration Methods (by event name)
public abstract void addListSelectionListener(javax.swing .event.ListSelectionListener x);
public abstract void removeListSelectionListener(javax.swing .event.ListSelectionListener x);
// Property Accessor Methods (by property name)
public abstract int getAnchorSelectionIndex();
public abstract void setAnchorSelectionIndex(int index);
public abstract int getLeadSelectionIndex();
public abstract void setLeadSelectionIndex(int index);
public abstract int getMaxSelectionIndex();
public abstract int getMinSelectionIndex();
public abstract boolean isSelectionEmpty();
public abstract int getSelectionMode();
public abstract void setSelectionMode(int selectionMode);
public abstract boolean getValueIsAdjusting();
public abstract void setValueIsAdjusting(boolean valueIsAdjusting);
javax.swing.ListCellRenderer
500 Chapter 23 – The javax.swing Package

// Public Instance Methods
public abstract void addSelectionInter val(int index0, int index1);
public abstract void clearSelection();
public abstract void inser tIndexInterval(int index, int length, boolean before);
public abstract boolean isSelectedIndex(int index);
public abstract void removeIndexInter val(int index0, int index1);
public abstract void removeSelectionInter val(int index0, int index1);
public abstract void setSelectionInter val(int index0, int index1);
}
Implementations: DefaultListSelectionModel
Passed To: JList.setSelectionModel(), JTable.{JTable(), setSelectionModel()},
javax.swing .table.DefaultTableColumnModel.setSelectionModel(),
javax.swing .table.TableColumnModel.setSelectionModel()
Retur ned By: JList.{createSelectionModel(), getSelectionModel()}, JTable.{createDefaultSelectionModel(),
getSelectionModel()}, javax.swing .table.DefaultTableColumnModel.{createSelectionModel(),
getSelectionModel()}, javax.swing .table.TableColumnModel.getSelectionModel()
Type Of: JTable.selectionModel, javax.swing .table.DefaultTableColumnModel.selectionModel
LookAndFeel
Ja va 1.2
javax.swing
This abstract class deﬁnes the methods that a pluggable look-and-feel must implement.
It also deﬁnes some useful static convenience methods. Application programmers
should never have to use or subclass this class. If you are implementing a look-and-
feel, you have to subclass this class and deﬁne the abstract methods, of course. You
pr obably also want to override the default no-op initialize() and getDefaults() methods.
Finally, you have to provide implementations of all the abstract classes in javax.swing .plaf.
public abstract class LookAndFeel {
// Public Constructors
public LookAndFeel();
// Public Class Methods
public static void installBorder(JComponent c, String defaultBorderName);
public static void installColors(JComponent c, String defaultBgName, String defaultFgName);
public static void installColorsAndFont(JComponent c, String defaultBgName, String defaultFgName,
String defaultFontName);
public static Object makeIcon(Class baseClass, String gifF ile);
public static javax.swing.text.JTextComponent.Ke yBinding[ ] makeKeyBindings(Object[ ] keyBindingList);
public static void uninstallBorder(JComponent c);
// Property Accessor Methods (by property name)
constant
public UIDefaults getDefaults();
public abstract String getDescription();
public abstract String getID();
public abstract String getName();
public abstract boolean isNativeLookAndFeel();
public abstract boolean isSuppor tedLookAndFeel();
// Public Instance Methods
empty
public void initialize();
empty
public void uninitialize();
// Public Methods Overriding Object
public String toString();
}
javax.swing
javax.swing.LookAndFeel
Chapter 23 – The javax.swing Package
501

Passed To: UIManager.{addAuxiliar yLookAndFeel(), removeAuxiliar yLookAndFeel(), setLookAndFeel()}
Retur ned By: UIManager.{getAuxiliar yLookAndFeels(), getLookAndFeel()}
MenuElement
Ja va 1.2
javax.swing
This interface deﬁnes methods that all menu components must implement. The meth-
ods allow menu navigation and event handling to be perfor med in a standard way.
Application programmers should never have to implement this interface or use the
methods it deﬁnes, unless they want to place components other than JMenuItem and its
subclasses into menus. See also MenuSelectionManager.
public abstract interface MenuElement {
// Public Instance Methods
public abstract Component getComponent();
public abstract MenuElement[ ] getSubElements();
public abstract void menuSelectionChanged(boolean isIncluded);
public abstract void processKeyEvent(java.awt.e vent.Ke yEvent event, MenuElement[ ] path,
MenuSelectionManager manager);
public abstract void processMouseEvent(java.awt.e vent.MouseEvent event, MenuElement[ ] path,
MenuSelectionManager manager);
}
Implementations: JMenu, JMenuBar, JMenuItem, JPopupMenu
Passed To: JMenuBar.{processKeyEvent(), processMouseEvent()}, JMenuItem.{processKeyEvent(),
processMouseEvent()}, JPopupMenu.{processKeyEvent(), processMouseEvent()},
MenuElement.{processKeyEvent(), processMouseEvent()}, MenuSelectionManager.setSelectedPath(),
javax.swing .event.MenuDragMouseEvent.MenuDragMouseEvent(),
javax.swing .event.MenuKeyEvent.MenuKeyEvent()
Retur ned By: JMenu.getSubElements(), JMenuBar.getSubElements(), JMenuItem.getSubElements(),
JPopupMenu.getSubElements(), MenuElement.getSubElements(), MenuSelectionManager.getSelectedPath(),
javax.swing .event.MenuDragMouseEvent.getPath(), javax.swing .event.MenuKeyEvent.getPath()
MenuSelectionManager
Ja va 1.2
javax.swing
This class deﬁnes methods that manipulate hierarchies of menus. Application program-
mers do not need to use this class. There is only one instance of MenuSelectionManager,
retur ned by the static defaultManager() method. Menu items rely on MenuSelectionManager
for implementations of MenuElement methods, and MenuSelectionManager relies on the
methods of the MenuElement inter face to allow it to traverse menu hierarchies.
public class MenuSelectionManager {
// Public Constructors
public MenuSelectionManager();
// Public Class Methods
public static MenuSelectionManager defaultManager();
// Event Registration Methods (by event name)
public void addChangeListener(javax.swing .event.ChangeListener l);
public void removeChangeListener(javax.swing .event.ChangeListener l);
// Public Instance Methods
public void clearSelectedPath();
public Component componentForPoint(Component source, java.awt.Point sourcePoint);
public MenuElement[ ] getSelectedPath();
public boolean isComponentPar tOfCur rentMenu(Component c);
public void processKeyEvent(java.awt.e vent.Ke yEvent e);
javax.swing.LookAndFeel
502 Chapter 23 – The javax.swing Package

public void processMouseEvent(java.awt.e vent.MouseEvent event);
public void setSelectedPath(MenuElement[ ] path);
// Protected Instance Methods
protected void ﬁreStateChanged();
// Protected Instance Fields
protected transient javax.swing.e vent.ChangeEvent changeEvent;
protected javax.swing.e vent.EventListenerList listenerList;
}
Passed To: JMenuBar.{processKeyEvent(), processMouseEvent()}, JMenuItem.{processKeyEvent(),
processMouseEvent()}, JPopupMenu.{processKeyEvent(), processMouseEvent()},
MenuElement.{processKeyEvent(), processMouseEvent()},
javax.swing .event.MenuDragMouseEvent.MenuDragMouseEvent(),
javax.swing .event.MenuKeyEvent.MenuKeyEvent()
Retur ned By: MenuSelectionManager.defaultManager(),
javax.swing .event.MenuDragMouseEvent.getMenuSelectionManager(),
javax.swing .event.MenuKeyEvent.getMenuSelectionManager()
MutableComboBoxModel
Ja va 1.2
javax.swing
model
This interface extends ComboBoxModel to add support for adding and removing elements
fr om the list of choices displayed by a JComboBox. See also ComboBoxModel and Default-
ComboBoxModel.
public abstract interface MutableComboBoxModel extends ComboBoxModel {
// Public Instance Methods
public abstract void addElement(Object obj);
public abstract void inser tElementAt(Object obj, int index);
public abstract void removeElement(Object obj);
public abstract void removeElementAt(int index);
}
Hierar chy: (MutableComboBoxModel(ComboBoxModel(ListModel)))
Implementations: DefaultComboBoxModel
Over layLayout
Ja va 1.2
javax.swing
serializable layout manager
This layout manager arranges the children of the container it manages so that the align-
ment points (speciﬁed with the setAlignmentX() and setAlignmentY() methods of JComponent)
ar e on top of each other. This usually means that the children overlap. AbstractButton
relies on this layout manager, but applications rarely use it.
public class Over layLayout implements java.awt.LayoutManager2, Serializable {
// Public Constructors
public Over layLayout(Container target);
// Methods Implementing LayoutManager
empty
public void addLayoutComponent(String name, Component comp);
public void layoutContainer(Container target);
public java.awt.Dimension minimumLayoutSize(Container target);
public java.awt.Dimension prefer redLayoutSize(Container target);
empty
public void removeLayoutComponent(Component comp);
// Methods Implementing LayoutManager2
empty
public void addLayoutComponent(Component comp, Object constraints);
public ﬂoat getLayoutAlignmentX(Container target);
javax.swing
javax.swing.OverlayLayout
Chapter 23 – The javax.swing Package
503

public ﬂoat getLayoutAlignmentY(Container target);
public void invalidateLayout(Container target);
public java.awt.Dimension maximumLayoutSize(Container target);
}
Hierar chy: Object→Over layLayout(java.awt.LayoutManager2(java.awt.LayoutManager), Serializable)
ProgressMonitor
Ja va 1.2
javax.swing
This class implements a progr ess monitor. After creating a ProgressMonitor, a program
periodically calls setProgress() to indicate its progr ess toward the completion of a task.
Unless progr ess is quite rapid, the ProgressMonitor displays a dialog box that uses a JPro-
gressBar to display progr ess to the user. Call setNote() to set the text to display in the dia-
log box. You can also specify a permanent title or heading for the dialog box with the
second argument to the constructor. The ProgressMonitor dialog box automatically closes
when the progress pr operty reaches the value of the maximum pr operty. If you want to
close it before the task completes, call close().
ProgressMonitor suf fers fr om an important ﬂaw: if the user clicks the Cancel buttons in
the dialog box, the dialog is dismissed. Unfortunately, the dialog does not ﬁre any
event to indicate that this has happened, so your program must call isCancelled() each
time it calls setProgress(), to deter mine whether the user has requested that the operation
be cancelled. A related ﬂaw is that the dialog box contains an extraneous Okay button
that behaves just like the Cancel button.
public class ProgressMonitor {
// Public Constructors
public ProgressMonitor(Component parentComponent, Object message, String note, int min, int max);
// Property Accessor Methods (by property name)
public boolean isCanceled();
public int getMaximum();
public void setMaximum(int m);
public int getMillisToDecideToPopup();
public void setMillisToDecideToPopup(int millisToDecideToPopup);
public int getMillisToPopup();
public void setMillisToPopup(int millisToPopup);
public int getMinimum();
public void setMinimum(int m);
public String getNote();
public void setNote(String note);
// Public Instance Methods
public void close();
public void setProgress(int nv);
}
Retur ned By: ProgressMonitorInputStream.getProgressMonitor()
ProgressMonitorInputStream
Ja va 1.2
javax.swing
This class combines a java.io.InputStream with a ProgressMonitor to display a program’s
pr ogress in reading a stream. It is useful when reading a long ﬁle or when doing time-
consuming processing on data from a shorter ﬁle. If the user clicks the Cancel button in
the dialog, the next call to read data from the stream results in an Inter r uptedIOException.
A ProgressMonitorInputStream can only be wrapped around a stream whose available()
method retur ns the total remaining number of bytes in the stream, such as a
java.io.F ileInputStream. It does not work with java.io.PipedInputStream, for example.
javax.swing.OverlayLayout
504 Chapter 23 – The javax.swing Package

public class ProgressMonitorInputStream extends java.io.FilterInputStream {
// Public Constructors
public ProgressMonitorInputStream(Component parentComponent, Object message, java.io.InputStream in);
// Public Instance Methods
public ProgressMonitor getProgressMonitor();
// Public Methods Overriding FilterInputStream
public void close() throws java.io.IOException;
public int read() throws java.io.IOException;
public int read(byte[ ] b) throws java.io.IOException;
public int read(byte[ ] b, int off, int len) throws java.io.IOException;
synchronized
public void reset() throws java.io.IOException;
public long skip(long n) throws java.io.IOException;
}
Hierar chy: Object→java.io.InputStream→java.io.F ilterInputStream→ProgressMonitorInputStream
Renderer
Ja va 1.2
javax.swing
This interface deﬁnes the basic methods that must be implemented by any class that
wants to render a value of some speciﬁed type on behalf of a general-purpose compo-
nent, such as a JList. In practice, the setValue() method deﬁned by this interface is under-
constrained, and this interface is unused in the Swing API. Three interfaces, with more
specialized methods, are used in its place: ListCellRenderer, javax.swing .table.TableCellRenderer
and javax.swing .tree.TreeCellRenderer.
public abstract interface Renderer {
// Public Instance Methods
public abstract Component getComponent();
public abstract void setValue(Object aValue, boolean isSelected);
}
RepaintManager
Ja va 1.2
javax.swing
This class manages the repaint and relayout process for all Swing components in an
application. It also provides a shared off-scr een image for Swing components that per-
for m double-buf fering. RepaintManager is an integral part of the Swing GUI framework
and is used extensively by JComponent inter nals. Applications rarely need to use it
dir ectly. If yours does, you can obtain the current RepaintManager with the static cur rent-
Manager() method.
public class RepaintManager {
// Public Constructors
public RepaintManager();
// Public Class Methods
public static RepaintManager cur rentManager(JComponent c);
public static RepaintManager cur rentManager(Component c);
public static void setCur rentManager(RepaintManager aRepaintManager);
// Property Accessor Methods (by property name)
default:true
public boolean isDoubleBufferingEnabled();
public void setDoubleBufferingEnabled(boolean aFlag);
public java.awt.Dimension getDoubleBufferMaximumSize();
public void setDoubleBufferMaximumSize(java.awt.Dimension d);
// Public Instance Methods
synchronized
public void addDir tyRegion(JComponent c, int x, int y, int w, int h);
synchronized
public void addInvalidComponent(JComponent invalidComponent);
javax.swing
javax.swing.RepaintManager
Chapter 23 – The javax.swing Package
505

public java.awt.Rectangle getDir tyRegion(JComponent aComponent);
public java.awt.Image getOffscreenBuffer(Component c, int proposedWidth, int proposedHeight);
public boolean isCompletelyDir ty(JComponent aComponent);
public void markCompletelyClean(JComponent aComponent);
public void markCompletelyDir ty(JComponent aComponent);
public void paintDir tyRegions();
synchronized
public void removeInvalidComponent(JComponent component);
public void validateInvalidComponents();
// Public Methods Overriding Object
synchronized
public String toString();
}
Passed To: RepaintManager.setCur rentManager()
Retur ned By: RepaintManager.cur rentManager()
RootPaneContainer
Ja va 1.2
javax.swing
This interface is implemented by all Swing window and applet classes that have a JRoot-
Pane as their single child. It deﬁnes getRootPane() to retur n that JRootPane. It also deﬁnes
other methods to retur n the various children of the JRootPane. getContentPane() is the
most frequently used method of this interface: it retur ns the container to which children
ar e added.
public abstract interface RootPaneContainer {
// Property Accessor Methods (by property name)
public abstract Container getContentPane();
public abstract void setContentPane(Container contentPane);
public abstract Component getGlassPane();
public abstract void setGlassPane(Component glassPane);
public abstract JLayeredPane getLayeredPane();
public abstract void setLayeredPane(JLayeredPane layeredPane);
public abstract JRootPane getRootPane();
}
Implementations: JApplet, JDialog, JFrame, JInternalFrame, JWindow
Scrollable
Ja va 1.2
javax.swing
This interface deﬁnes methods that should be implemented by any component that is
likely to be placed within a JScrollPane or similar scrolling container. A JScrollPane can
pr ovide mor e intelligent scrolling services for a Scrollable component than for a non-
Scrollable component.
public abstract interface Scrollable {
// Public Instance Methods
public abstract java.awt.Dimension getPrefer redScrollableViewpor tSize();
public abstract int getScrollableBlockIncrement(java.awt.Rectangle visibleRect, int orientation, int direction);
public abstract boolean getScrollableTracksV iewportHeight();
public abstract boolean getScrollableTracksV iewportW idth();
public abstract int getScrollableUnitIncrement(java.awt.Rectangle visibleRect, int orientation, int direction);
}
Implementations: JList, JTable, JTree, javax.swing .text.JTextComponent
javax.swing.RepaintManager
506 Chapter 23 – The javax.swing Package

ScrollPaneConstants
Ja va 1.2
javax.swing
This interface deﬁnes constants used by JScrollPane and ScrollPaneLayout. The int constants
ar e the most interesting ones. They are the legal values for the setHorizontalScrollBarPolicy()
and setVer ticalScrollBarPolicy() methods of JScrollPane.
public abstract interface ScrollPaneConstants {
// Public Constants
="COLUMN_HEADER"
public static ﬁnal String COLUMN_HEADER;
="HORIZONTAL_SCROLLBAR"
public static ﬁnal String HORIZONTAL_SCROLLBAR;
=32
public static ﬁnal int HORIZONTAL_SCROLLBAR_ALWAYS;
=30
public static ﬁnal int HORIZONTAL_SCROLLBAR_AS_NEEDED;
=31
public static ﬁnal int HORIZONTAL_SCROLLBAR_NEVER;
="HORIZONTAL_SCROLLBAR_POLICY"
public static ﬁnal String HORIZONTAL_SCROLLBAR_POLICY;
="LOWER_LEFT_CORNER"
public static ﬁnal String LOWER_LEFT_CORNER;
="LOWER_RIGHT_CORNER"
public static ﬁnal String LOWER_RIGHT_CORNER;
="ROW_HEADER"
public static ﬁnal String RO W_HEADER;
="UPPER_LEFT_CORNER"
public static ﬁnal String UPPER_LEFT_CORNER;
="UPPER_RIGHT_CORNER"
public static ﬁnal String UPPER_RIGHT_CORNER;
="VERTICAL_SCROLLBAR"
public static ﬁnal String VERTICAL_SCROLLBAR;
=22
public static ﬁnal int VERTICAL_SCROLLBAR_ALWAYS;
=20
public static ﬁnal int VERTICAL_SCROLLBAR_AS_NEEDED;
=21
public static ﬁnal int VERTICAL_SCROLLBAR_NEVER;
="VERTICAL_SCROLLBAR_POLICY"
public static ﬁnal String VERTICAL_SCROLLBAR_POLICY;
="VIEWPORT"
public static ﬁnal String VIEWPORT;
}
Implementations: JScrollPane, ScrollPaneLayout
ScrollPaneLayout
Ja va 1.2
javax.swing
serializable layout manager
This class is the layout manager used by JScrollPane. It arranges up to nine components:
the JV iewpor t that contains the component being scrolled, the horizontal and vertical
scr ollbars, the column and row header components, and up to four small corner com-
ponents. Applications typically use JScrollPane dir ectly and do not have to use this class.
public class ScrollPaneLayout implements java.awt.LayoutManager, ScrollPaneConstants, Serializable {
// Public Constructors
public ScrollPaneLayout();
// Inner Classes
public static class UIResource extends ScrollPaneLayout implements javax.swing.plaf.UIResource;
// Property Accessor Methods (by property name)
default:null
public JVie wport getColumnHeader();
default:null
public JScrollBar getHorizontalScrollBar();
default:30
public int getHorizontalScrollBarPolicy();
public void setHorizontalScrollBarPolicy(int x);
default:null
public JVie wport getRowHeader();
default:null
public JScrollBar getVer ticalScrollBar();
default:20
public int getVer ticalScrollBarPolicy();
public void setVer ticalScrollBarPolicy(int x);
default:null
public JVie wport getV iewport();
// Public Instance Methods
public Component getCor ner(String key);
public void syncW ithScrollPane(JScrollPane sp);
// Methods Implementing LayoutManager
public void addLayoutComponent(String s, Component c);
public void layoutContainer(Container parent);
javax.swing
javax.swing.ScrollPaneLayout
Chapter 23 – The javax.swing Package
507

public java.awt.Dimension minimumLayoutSize(Container parent);
public java.awt.Dimension prefer redLayoutSize(Container parent);
public void removeLayoutComponent(Component c);
// Protected Instance Methods
protected Component addSingletonComponent(Component oldC, Component newC);
// Protected Instance Fields
protected JVie wport colHead;
protected JScrollBar hsb;
protected int hsbPolicy;
protected Component lowerLeft;
protected Component lowerRight;
protected JVie wport rowHead;
protected Component upperLeft;
protected Component upperRight;
protected JVie wport viewpor t;
protected JScrollBar vsb;
protected int vsbPolicy;
// Deprecated Public Methods
# public java.awt.Rectangle getV iewportBorderBounds(JScrollPane scrollpane);
}
Hierar chy: Object→ScrollPaneLayout(java.awt.LayoutManager, ScrollPaneConstants, Serializable)
Subc lasses: ScrollPaneLayout.UIResource
ScrollPaneLayout.UIResource
Ja va 1.2
javax.swing
serializable layout manager
This class is a trivial subclass of ScrollPaneLayout that implements the UIResource marker
inter face. It is used only by look-and-feel implementations.
public static class ScrollPaneLayout.UIResource extends ScrollPaneLayout
implements javax.swing.plaf.UIResource {
// Public Constructors
public UIResource();
}
SingleSelectionModel
Ja va 1.2
javax.swing
model
This interface deﬁnes the methods that must be implemented by a class that wants to
keep track of a single selected item for a JTabbedPane, JMenuBar, JPopupMenu, or similar
component. Applications do not often implement this interface. Instead, they rely on
the DefaultSingleSelectionModel class, which is the default model for components that
allow a single selected item.
public abstract interface SingleSelectionModel {
// Event Registration Methods (by event name)
public abstract void addChangeListener(javax.swing .event.ChangeListener listener);
public abstract void removeChangeListener(javax.swing .event.ChangeListener listener);
// Public Instance Methods
public abstract void clearSelection();
public abstract int getSelectedIndex();
public abstract boolean isSelected();
public abstract void setSelectedIndex(int index);
}
Implementations: DefaultSingleSelectionModel
javax.swing.ScrollPaneLayout
508 Chapter 23 – The javax.swing Package

Passed To: JMenuBar.setSelectionModel(), JPopupMenu.setSelectionModel(), JTabbedPane.setModel()
Retur ned By: JMenuBar.getSelectionModel(), JPopupMenu.getSelectionModel(), JTabbedPane.getModel()
Type Of: JTabbedPane.model
SizeRequirements
Ja va 1.2
javax.swing
serializable
This class exists for the convenience of layout managers. It is used internally by BoxLay-
out and Over layLayout. Application programmers should not need to use it. Component
developers writing custom layout managers may ﬁnd it useful.
public class SizeRequirements implements Serializable {
// Public Constructors
public SizeRequirements();
public SizeRequirements(int min, int pref, int max, ﬂoat a);
// Public Class Methods
public static int[ ] adjustSizes(int delta, SizeRequirements[ ] children);
public static void calculateAlignedPositions(int allocated, SizeRequirements total, SizeRequirements[ ] children,
int[ ] offsets, int[ ] spans);
public static void calculateT iledPositions(int allocated, SizeRequirements total, SizeRequirements[ ] children,
int[ ] offsets, int[ ] spans);
public static SizeRequirements getAlignedSizeRequirements(SizeRequirements[ ] children);
public static SizeRequirements getT iledSizeRequirements(SizeRequirements[ ] children);
// Public Methods Overriding Object
public String toString();
// Public Instance Fields
public ﬂoat alignment;
public int maximum;
public int minimum;
public int prefer red;
}
Hierar chy: Object→SizeRequirements(Serializable)
Passed To: Too many methods to list.
Retur ned By: SizeRequirements.{getAlignedSizeRequirements(), getT iledSizeRequirements()},
javax.swing .text.BoxView.{baselineRequirements(), calculateMajorAxisRequirements(),
calculateMinorAxisRequirements()}, javax.swing .text.ParagraphV iew.calculateMinorAxisRequirements(),
javax.swing .text.TableV iew.calculateMinorAxisRequirements(),
javax.swing .text.html.BlockView.{calculateMajorAxisRequirements(), calculateMinorAxisRequirements()},
javax.swing .text.html.ParagraphV iew.calculateMinorAxisRequirements()
SwingConstants
Ja va 1.2
javax.swing
This interface deﬁnes a number of constants used throughout the Swing API to specify
component positions and orientations.
public abstract interface SwingConstants {
// Public Constants
=3
public static ﬁnal int BOTTOM;
=0
public static ﬁnal int CENTER;
=3
public static ﬁnal int EAST;
=0
public static ﬁnal int HORIZONTAL;
=10
public static ﬁnal int LEADING;
=2
public static ﬁnal int LEFT;
=1
public static ﬁnal int NORTH;
javax.swing
javax.swing.SwingConstants
Chapter 23 – The javax.swing Package
509

=2
public static ﬁnal int NORTH_EAST;
=8
public static ﬁnal int NORTH_WEST;
=4
public static ﬁnal int RIGHT;
=5
public static ﬁnal int SOUTH;
=4
public static ﬁnal int SOUTH_EAST;
=6
public static ﬁnal int SOUTH_WEST;
=1
public static ﬁnal int TOP;
=11
public static ﬁnal int TRAILING;
=1
public static ﬁnal int VERTICAL;
=7
public static ﬁnal int WEST;
}
Implementations: AbstractButton, JCheckBoxMenuItem, JLabel, JProgressBar, JSeparator, JSlider,
JTabbedPane, JTextF ield, JToolBar, SwingUtilities, javax.swing .text.View
SwingUtilities
Ja va 1.2
javax.swing
This class deﬁnes a variety of static methods that are useful in Swing applications.
Highlights include:
invokeLater(), invokeAndWait()
Place the speciﬁed Runnable object on the event queue, so that its run() method is
invoked (later) from the event dispatch thread. invokeLater() retur ns immediately;
invokeAndWait() blocks until the run() method has run. Since Swing is not generally
thr ead safe, these methods are useful when you need to update the GUI from a
thr ead that is not the event dispatch thread.
isEventDispatchThread()
Deter mines whether the current thread is the event dispatch thread.
updateComponentTreeUI()
Traverses the entire component tree rooted at the speciﬁed component and asks
each component to update its UI delegate. This method is useful after you have
changed the pluggable look-and-feel of a running application.
isLeftMouseButton(), isMiddleMouseButton(), isRightMouseButton()
Deter mine whether a speciﬁed MouseEvent involves the left, middle, or right mouse
button. For portability reasons, this information is encoded in the modiﬁers pr operty
that the MouseEvent inherits. These methods simplify access to it.
getAncestorOfClass()
Given a component and a component class, this method searches the ancestors of
the component until it ﬁnds one of the speciﬁed class. getRoot(), getRootPane(), win-
dowForComponent(), and getAncestorNamed() ar e related methods.
public class SwingUtilities implements SwingConstants {
// No Constructor
// Public Class Methods
public static java.awt.Rectangle[ ] computeDifference(java.awt.Rectangle rectA, java.awt.Rectangle rectB);
public static java.awt.Rectangle computeIntersection(int x, int y, int width, int height, java.awt.Rectangle dest);
public static int computeStringW idth(java.awt.FontMetrics fm, String str);
public static java.awt.Rectangle computeUnion(int x, int y, int width, int height, java.awt.Rectangle dest);
public static java.awt.event.MouseEvent conver tMouseEvent(Component source,
java.awt.e vent.MouseEvent sourceEvent,
Component destination);
javax.swing.SwingConstants
510 Chapter 23 – The javax.swing Package

public static java.awt.Point conver tPoint(Component source, java.awt.Point aPoint, Component destination);
public static java.awt.Point conver tPoint(Component source, int x, int y, Component destination);
public static void conver tPointFromScreen(java.awt.Point p, Component c);
public static void conver tPointToScreen(java.awt.Point p, Component c);
public static java.awt.Rectangle conver tRectangle(Component source, java.awt.Rectangle aRectangle,
Component destination);
public static Component ﬁndFocusOwner(Component c);
public static Accessible getAccessibleAt(Component c, java.awt.Point p);
public static Accessible getAccessibleChild(Component c, int i);
public static int getAccessibleChildrenCount(Component c);
public static int getAccessibleIndexInParent(Component c);
public static AccessibleStateSet getAccessibleStateSet(Component c);
public static Container getAncestorNamed(String name, Component comp);
public static Container getAncestorOfClass(Class c, Component comp);
public static Component getDeepestComponentAt(Component parent, int x, int y);
public static java.awt.Rectangle getLocalBounds(Component aComponent);
public static Component getRoot(Component c);
public static JRootPane getRootPane(Component c);
public static void invokeAndWait(Runnable doRun) throws InterruptedException,
java.lang .reﬂect.InvocationTargetException;
public static void invokeLater(Runnable doRun);
public static boolean isDescendingFrom(Component a, Component b);
public static boolean isEventDispatchThread();
public static boolean isLeftMouseButton(java.awt.e vent.MouseEvent anEvent);
public static boolean isMiddleMouseButton(java.awt.e vent.MouseEvent anEvent);
public static ﬁnal boolean isRectangleContainingRectangle(java.awt.Rectangle a, java.awt.Rectangle b);
public static boolean isRightMouseButton(java.awt.e vent.MouseEvent anEvent);
public static String layoutCompoundLabel(java.awt.FontMetrics fm, String text, Icon icon, int ver ticalAlignment,
int horizontalAlignment, int ver ticalTextPosition,
int horizontalTextPosition, java.awt.Rectangle viewR,
java.awt.Rectangle iconR, java.awt.Rectangle textR, int textIconGap);
public static String layoutCompoundLabel(JComponent c, java.awt.FontMetrics fm, String text, Icon icon,
int ver ticalAlignment, int horizontalAlignment, int ver ticalTextPosition,
int horizontalTextPosition, java.awt.Rectangle viewR,
java.awt.Rectangle iconR, java.awt.Rectangle textR, int textIconGap);
public static void paintComponent(java.awt.Graphics g, Component c, Container p, java.awt.Rectangle r);
public static void paintComponent(java.awt.Graphics g, Component c, Container p, int x, int y, int w, int h);
public static void updateComponentTreeUI(Component c);
public static java.awt.Window windowForComponent(Component aComponent);
}
Hierar chy: Object→SwingUtilities(SwingConstants)
Timer
Ja va 1.2
javax.swing
serializable
This utility class ﬁres an ActionEvent to a list of register ed ActionListener objects after a
speciﬁed period of time has elapsed. Optionally, it may continue to ﬁre action events at
speciﬁed time intervals. This class is useful for triggering delayed or repeated actions,
such as animations. After creating a Timer object, adding one or more ActionListener
objects, and setting any necessary properties, call star t() to make the Timer object start
timing and ﬁring events. If you have conﬁgured the Timer to ﬁre events repeatedly, use
the stop() method when you want the events to stop.
The initialDelay pr operty speciﬁes the time in milliseconds between the invocation of the
star t() method and the ﬁring of the ﬁrst ActionEvent. The repeats pr operty speciﬁes
whether the Timer ﬁr es events repeatedly. If repeats is tr ue, the delay pr operty speciﬁes
the interval (in milliseconds) between repeated events. If the delay pr operty is set to a
javax.swing
javax.swing.Timer
Chapter 23 – The javax.swing Package
511

short interval or if the ActionEvent triggers a complex action, the Timer may sometimes get
behind and develop a backlog of events. Set the coalesce pr operty to tr ue if the Timer is
allowed to coalesce multiple pending events into a single ActionEvent in this situation.
The Timer constructor sets the repeats and coalesce pr operties to tr ue, so be sur e to
change these properties if you don’t want that behavior. The constructor also sets both
the delay and initialDelay pr operties to the speciﬁed interval. The static setLogT imers()
method is useful when debugging code that uses the Timer class. Passing tr ue to this
method causes Timer to print a debugging message to standard output each time it ﬁres
an event.
public class Timer implements Serializable {
// Public Constructors
public Timer(int delay, java.awt.e vent.ActionListener listener);
// Public Class Methods
public static boolean getLogT imers();
public static void setLogT imers(boolean ﬂag);
// Event Registration Methods (by event name)
public void addActionListener(java.awt.e vent.ActionListener listener);
public void removeActionListener(java.awt.e vent.ActionListener listener);
// Property Accessor Methods (by property name)
public boolean isCoalesce();
public void setCoalesce(boolean ﬂag);
public int getDelay();
public void setDelay(int delay);
public int getInitialDelay();
public void setInitialDelay(int initialDelay);
public boolean isRepeats();
public void setRepeats(boolean ﬂag);
public boolean isRunning();
// Public Instance Methods
public void restar t();
public void star t();
public void stop();
// Protected Instance Methods
protected void ﬁreActionPerfor med(java.awt.e vent.ActionEvent e);
// Protected Instance Fields
protected javax.swing.e vent.EventListenerList listenerList;
}
Hierar chy: Object→Timer(Serializable)
Type Of: javax.swing .tree.DefaultTreeCellEditor.timer
ToolT ipManager
Ja va 1.2
javax.swing
This class manages tooltips for a Swing application. There is only one ToolT ipManager per
application; you can obtain a refer ence to it with the static sharedInstance() method. Any
Swing component that has a tooltip set on it (with setToolT ipText()) is automatically regis-
ter ed with the ToolT ipManager, so applications do not usually have to work with this class
explicitly. If you want to explicitly register or unregister a component without setting its
tooltip text, you can do so with registerComponent() and unregisterComponent(), respectively.
To disable all tooltips in an application (at the request of an advanced user, for exam-
ple), set the enabled pr operty to false. The other ToolT ipManager pr operties ar e various
delays that affect the behavior of tooltips. These values are user prefer ences, and an
application should not modify them except in response to an explicit user request
made through some kind of prefer ences dialog or control panel.
javax.swing.Timer
512 Chapter 23 – The javax.swing Package

public class ToolT ipManager extends java.awt.event.MouseAdapter implements java.awt.event.MouseMotionListener {
// No Constructor
// Inner Classes
protected class insideT imerAction implements java.awt.event.ActionListener ;
protected class outsideT imerAction implements java.awt.event.ActionListener ;
protected class stillInsideT imerAction implements java.awt.event.ActionListener ;
// Public Class Methods
public static ToolT ipManager sharedInstance();
// Property Accessor Methods (by property name)
public int getDismissDelay();
public void setDismissDelay(int microSeconds);
public boolean isEnabled();
public void setEnabled(boolean ﬂag);
public int getInitialDelay();
public void setInitialDelay(int microSeconds);
public boolean isLightWeightPopupEnabled();
public int getReshowDelay();
public void setReshowDelay(int microSeconds);
// Public Instance Methods
public void registerComponent(JComponent component);
public void unregisterComponent(JComponent component);
// Methods Implementing MouseMotionListener
empty
public void mouseDragged(java.awt.e vent.MouseEvent event);
public void mouseMoved(java.awt.e vent.MouseEvent event);
// Public Methods Overriding MouseAdapter
public void mouseEntered(java.awt.e vent.MouseEvent event);
public void mouseExited(java.awt.e vent.MouseEvent event);
public void mousePressed(java.awt.e vent.MouseEvent event);
// Protected Instance Fields
protected boolean heavyWeightPopupEnabled;
protected boolean lightWeightPopupEnabled;
// Deprecated Public Methods
# public void setLightWeightPopupEnabled(boolean aFlag);
}
Hierar chy: Object→java.awt.event.MouseAdapter(java.awt.event.MouseListener(java.util.EventListener))→
ToolT ipManager(java.awt.event.MouseMotionListener(java.util.EventListener))
Retur ned By: ToolT ipManager.sharedInstance()
ToolT ipManager.insideT imerAction
Ja va 1.2
javax.swing
This protected inner class is used internally by ToolT ipManager. Applications never need
to use it, and it probably should not be part of the public API.
protected class ToolT ipManager.insideT imerAction implements java.awt.event.ActionListener {
// Protected Constructors
protected insideT imerAction();
// Methods Implementing ActionListener
public void actionPerfor med(java.awt.e vent.ActionEvent e);
}
ToolT ipManager.outsideT imerAction
Ja va 1.2
javax.swing
This protected inner class is used internally by ToolT ipManager. Applications never need
to use it, and it probably should not be part of the public API.
javax.swing
javax.swing.ToolTipManager.outsideTimerAction
Chapter 23 – The javax.swing Package
513

protected class ToolT ipManager.outsideT imerAction implements java.awt.event.ActionListener {
// Protected Constructors
protected outsideT imerAction();
// Methods Implementing ActionListener
public void actionPerfor med(java.awt.e vent.ActionEvent e);
}
ToolT ipManager.stillInsideT imerAction
Ja va 1.2
javax.swing
This protected inner class is used internally by ToolT ipManager. Applications never need
to use it, and it probably should not be part of the public API.
protected class ToolT ipManager.stillInsideT imerAction implements java.awt.event.ActionListener {
// Protected Constructors
protected stillInsideT imerAction();
// Methods Implementing ActionListener
public void actionPerfor med(java.awt.e vent.ActionEvent e);
}
UIDefaults
Ja va 1.2
javax.swing
cloneable serializable collection
UIDefaults is a Hashtable subclass used to maintain a table of named resources for use by
a look-and-feel implementation. Like any hashtable, UIDefaults deﬁnes a get() and a put()
method. In addition, it deﬁnes numerous more speciﬁc getXXX() methods that are used to look up
resources of speciﬁc types. Unless you are deﬁning a custom look-and-feel, you probably do not have to use this class
explicitly.
The generic get() method and all the more speciﬁc methods that use it have a special
behavior if the retur ned resource value implements either of the inner interfaces
deﬁned by UIDefaults. If the retur ned object is a UIDefaults.ActiveValue, the value retur ned
by the get() method is computed by calling the createValue() method of the ActiveValue
object. Similarly, if the retur ned value is a LazyValue, the ﬁnal retur n value of the get()
method is computed by calling the createValue() method of the LazyValue object. Once
this computation is done the ﬁrst time, however, the LazyValue is replaced in the UIDe-
faults table with the computed value it yielded. This is a useful technique for resources
such as icons that have to be read in from external ﬁles. It prevents them from being
cr eated unless they are actually needed.
public class UIDefaults extends java.util.Hashtable {
// Public Constructors
public UIDefaults();
public UIDefaults(Object[ ] keyValueList);
// Inner Classes
public abstract static interface ActiveValue;
public abstract static interface LazyValue;
// Event Registration Methods (by event name)
synchronized
public void addProper tyChangeListener(java.beans.Proper tyChangeListener listener);
synchronized
public void removeProper tyChangeListener(java.beans.Proper tyChangeListener listener);
// Public Instance Methods
public javax.swing.border.Border getBorder(Object key);
public java.awt.Color getColor(Object key);
public java.awt.Dimension getDimension(Object key);
public java.awt.Font getFont(Object key);
public Icon getIcon(Object key);
public java.awt.Insets getInsets(Object key);
javax.swing.ToolTipManager.outsideTimerAction
514 Chapter 23 – The javax.swing Package

public int getInt(Object key);
public String getString(Object key);
public javax.swing.plaf.ComponentUI getUI(JComponent target);
public Class getUIClass(String uiClassID);
public Class getUIClass(String uiClassID, ClassLoader uiClassLoader);
public void putDefaults(Object[ ] keyValueList);
// Public Methods Overriding Hashtable
public Object get(Object key);
public Object put(Object key, Object value);
// Protected Instance Methods
protected void ﬁreProper tyChange(String proper tyName, Object oldValue, Object newValue);
protected void getUIEr ror(String msg);
}
Hierar chy: Object→java.util.Dictionar y→java.util.Hashtable(Cloneable, java.util.Map, Serializable)→
UIDefaults
Passed To: UIDefaults.ActiveValue.createValue(), UIDefaults.LazyValue.createValue()
Retur ned By: LookAndFeel.getDefaults(), UIManager.{getDefaults(), getLookAndFeelDefaults()}
UIDefaults.ActiveValue
Ja va 1.2
javax.swing
This interface deﬁnes a special kind of resource that can be stored in a UIDefaults
hashtable. When the get() method of UIDefaults ﬁnds a ActiveValue in the table, it does not
retur n the ActiveValue object. Instead, it invokes its createValue() method and retur ns the
object retur ned by that method.
public abstract static interface UIDefaults.ActiveValue {
// Public Instance Methods
public abstract Object createValue(UIDefaults table);
}
UIDefaults.LazyValue
Ja va 1.2
javax.swing
This interface deﬁnes a special kind of resource that can be stored in a UIDefaults
hashtable. When the get() method of UIDefaults ﬁnds an LazyValue in the table, it does not
retur n the LazyValue object. Instead, it invokes its createValue() method. The object
retur ned by createValue() is used to replace the LazyValue in the UIDefaults table and is then
retur ned by the get() method.
public abstract static interface UIDefaults.LazyValue {
// Public Instance Methods
public abstract Object createValue(UIDefaults table);
}
UIManager
Ja va 1.2
javax.swing
serializable
The static methods of this class perfor m a number of look-and-feel related functions.
setLookAndFeel() is the most important. It takes a LookAndFeel object or the class name of
the desired look-and-feel and makes it the current look-and-feel. getLookAndFeel() retur ns
the LookAndFeel object that repr esents the current look-and-feel. getCrossPlatfor mLookAnd-
FeelClassName() and getSystemLookAndFeelClassName() retur n class names for the default
Java look-and-feel and for the look-and-feel that mimics the native platform look-and-
javax.swing
javax.swing.UIManager
Chapter 23 – The javax.swing Package
515

feel, if one exists. getInstalledLookAndFeels() retur ns infor mation about all look-and-feels
that are installed on the system.
The UIManager also manages user interface defaults speciﬁed both by the current look-
and-feel and by the application. The get() method looks up a value for the named key,
checking the table of application defaults ﬁrst and then checking the defaults speciﬁed
by the look-and-feel. The put() method inserts a new key/value binding into the appli-
cation defaults table; it does not modify the look-and-feel defaults. UIManager deﬁnes
various other type-speciﬁc getXXX() methods that can be used to look up default UI resources of various
types.
Although all the methods of UIManager ar e static, they are implemented in such a way
that each separate application context can independently set its own look-and-feel
defaults. This means, for example, that multiple applets running in the same Java VM
can install and use differ ent look-and-feel implementations.
public class UIManager implements Serializable {
// Public Constructors
public UIManager();
// Inner Classes
public static class LookAndFeelInfo;
// Public Class Methods
public static void addAuxiliar yLookAndFeel(LookAndFeel laf);
public static void addProper tyChangeListener(java.beans.Proper tyChangeListener listener);
public static Object get(Object key);
public static LookAndFeel[ ] getAuxiliar yLookAndFeels();
public static javax.swing.border.Border getBorder(Object key);
public static java.awt.Color getColor(Object key);
public static String getCrossPlatfor mLookAndFeelClassName();
public static UIDefaults getDefaults();
public static java.awt.Dimension getDimension(Object key);
public static java.awt.Font getFont(Object key);
public static Icon getIcon(Object key);
public static java.awt.Insets getInsets(Object key);
public static UIManager.LookAndFeelInfo[ ] getInstalledLookAndFeels();
public static int getInt(Object key);
public static LookAndFeel getLookAndFeel();
public static UIDefaults getLookAndFeelDefaults();
public static String getString(Object key);
public static String getSystemLookAndFeelClassName();
public static javax.swing.plaf.ComponentUI getUI(JComponent target);
public static void installLookAndFeel(UIManager.LookAndFeelInfo info);
public static void installLookAndFeel(String name, String className);
public static Object put(Object key, Object value);
public static boolean removeAuxiliar yLookAndFeel(LookAndFeel laf);
public static void removeProper tyChangeListener(java.beans.Proper tyChangeListener listener);
public static void setInstalledLookAndFeels(UIManager.LookAndFeelInfo[ ] infos) throws SecurityException;
public static void setLookAndFeel(LookAndFeel newLookAndFeel) throws UnsupportedLookAndFeelException;
public static void setLookAndFeel(String className) throws ClassNotFoundException, InstantiationException,
IllegalAccessException;
}
Hierar chy: Object→UIManager(Serializable)
UIManager.LookAndFeelInfo
Ja va 1.2
javax.swing
Instances of this class are retur ned by the getInstalledLookAndFeels() method of UIManager.
The getName() method of each LookAndFeelInfo pr ovides a simple human-presentable
javax.swing.UIManager
516 Chapter 23 – The javax.swing Package

name that can be displayed to the user in a list or menu that allows the user to choose
a look-and-feel.
public static class UIManager.LookAndFeelInfo {
// Public Constructors
public LookAndFeelInfo(String name, String className);
// Public Instance Methods
public String getClassName();
public String getName();
// Public Methods Overriding Object
public String toString();
}
Passed To: UIManager.{installLookAndFeel(), setInstalledLookAndFeels()}
Retur ned By: UIManager.getInstalledLookAndFeels()
Unsuppor tedLookAndFeelException
Ja va 1.2
javax.swing
serializable checked
Thr own by the setLookAndFeel() method of the UIManager class to indicate that the
requested look-and-feel is not installed, not supported, or not licensed on the current
system.
public class Unsuppor tedLookAndFeelException extends Exception {
// Public Constructors
public Unsuppor tedLookAndFeelException(String s);
}
Hierar chy: Object→Throwable(Serializable)→Exception→Unsuppor tedLookAndFeelException
Thrown By: UIManager.setLookAndFeel()
Viewpor tLayout
Ja va 1.2
javax.swing
serializable layout manager
This class is the default LayoutManager for the JV iewpor t component. Applications should
never need to use this class explicitly.
public class Viewpor tLayout implements java.awt.LayoutManager, Serializable {
// Public Constructors
public Viewpor tLayout();
// Methods Implementing LayoutManager
empty
public void addLayoutComponent(String name, Component c);
public void layoutContainer(Container parent);
public java.awt.Dimension minimumLayoutSize(Container parent);
public java.awt.Dimension prefer redLayoutSize(Container parent);
empty
public void removeLayoutComponent(Component c);
}
Hierar chy: Object→Viewpor tLayout(java.awt.LayoutManager, Serializable)
WindowConstants
Ja va 1.2
javax.swing
This interface deﬁnes three constants that describe possible actions that can be taken
when the user requests that a window be closed. These three constants are the legal
arguments to the setDefaultCloseOperation() methods of JFrame, JInter nalFrame, and JDialog.
Note that setDefaultCloseOperation() speciﬁes only the default action when the user tries to
close the window. An application that registers a WindowListener object can augment this
default operation with one of its own.
javax.swing
javax.swing.WindowConstants
Chapter 23 – The javax.swing Package
517

public abstract interface WindowConstants {
// Public Constants
=2
public static ﬁnal int DISPOSE_ON_CLOSE;
=0
public static ﬁnal int DO_NOTHING_ON_CLOSE;
=1
public static ﬁnal int HIDE_ON_CLOSE;
}
Implementations: JDialog, JFrame, JInternalFrame
javax.swing.WindowConstants
518 Chapter 23 – The javax.swing Package

CHAPTER 24
The javax.swing.border Package
The javax.swing .border package is a simple package that deﬁnes the Border inter face,
which speciﬁes how to draw a border around an arbitrary Swing component. The
various classes in this package implement commonly used border styles. Applica-
tions can easily deﬁne custom border styles by creating custom implementations of
Border. Figur e 24-1 shows the class hierarchy of this package.
extends
implements
KEY
CLASS
INTERFACE
ABSTRACT CLASS
AbstractBorder
BevelBorder
javax.swing.border
java.lang
Object
java.io
CompoundBorder
EmptyBorder
EtchedBorder
LineBorder
TitleBorder
MatteBorder
Border
SoftBevelBorder
Serializable
Figur e 24−1: The javax.swing.bor der package
AbstractBorder
Ja va 1.2
javax.swing .border
serializable
This abstract class implements a zero-width, nonopaque border. AbstractBorder imple-
ments the Border inter face. To create a custom border type, subclass AbstractBorder, reim-
plementing at least the getBorderInsets() and paintBorder() methods. getInteriorRectangle() in
javax.swing.
border
519

its static and nonstatic versions is a convenience method that retur ns a rectangle that
repr esents the region of the component inside the border.
AbstractBorder pr ovides a two-argument version of getBorderInsets(), in addition to the one-
argument version requir ed by Border. The two-argument version should place the insets
in the supplied Insets object. Doing so does not requir e a new Insets object to be cre-
ated, so it is more efﬁcient than the one-argument version. Swing components use this
mor e ef ﬁcient method whenever possible.
public abstract class AbstractBorder implements Border, Serializable {
// Public Constructors
public AbstractBorder();
// Public Class Methods
public static java.awt.Rectangle getInteriorRectangle(Component c, Border b, int x, int y, int width, int height);
// Public Instance Methods
public java.awt.Insets getBorderInsets(Component c, java.awt.Insets insets);
public java.awt.Rectangle getInteriorRectangle(Component c, int x, int y, int width, int height);
// Methods Implementing Border
public java.awt.Insets getBorderInsets(Component c);
constant
public boolean isBorderOpaque();
empty
public void paintBorder(Component c, java.awt.Graphics g, int x, int y, int width, int height);
}
Hierar chy: Object→AbstractBorder(Border, Serializable)
Subc lasses: BevelBorder, CompoundBorder, EmptyBorder, EtchedBorder, LineBorder, TitledBorder
BevelBorder
Ja va 1.2
javax.swing .border
serializable
This class displays a two-pixel-wide beveled edge around a Swing component, giving
the appearance of a raised or lowered surface. The RAISED and LOWERED constants spec-
ify the type of bevel. It usually is not necessary to specify bevel colors, as appropriate
defaults are derived from the component background color. See also the createBevelBor-
der(), createLoweredBevelBorder(), and createRaisedBevelBorder() methods of javax.swing .Border-
Factor y.
public class BevelBorder extends AbstractBorder {
// Public Constructors
public BevelBorder(int bevelType);
public BevelBorder(int bevelType, java.awt.Color highlight, java.awt.Color shadow);
public BevelBorder(int bevelType, java.awt.Color highlightOuter, java.awt.Color highlightInner,
java.awt.Color shadowOuter, java.awt.Color shadowInner);
// Public Constants
=1
public static ﬁnal int LOWERED;
=0
public static ﬁnal int RAISED;
// Public Instance Methods
public int getBevelType();
public java.awt.Color getHighlightInnerColor(Component c);
public java.awt.Color getHighlightOuterColor(Component c);
public java.awt.Color getShadowInnerColor(Component c);
public java.awt.Color getShadowOuterColor(Component c);
// Public Methods Overriding AbstractBorder
public java.awt.Insets getBorderInsets(Component c);
public java.awt.Insets getBorderInsets(Component c, java.awt.Insets insets);
constant
public boolean isBorderOpaque();
public void paintBorder(Component c, java.awt.Graphics g, int x, int y, int width, int height);
javax.swing.border.AbstractBorder
520 Chapter 24 – The javax.swing.border Package

// Protected Instance Methods
protected void paintLoweredBevel(Component c, java.awt.Graphics g, int x, int y, int width, int height);
protected void paintRaisedBevel(Component c, java.awt.Graphics g, int x, int y, int width, int height);
// Protected Instance Fields
protected int bevelType;
protected java.awt.Color highlightInner;
protected java.awt.Color highlightOuter;
protected java.awt.Color shadowInner;
protected java.awt.Color shadowOuter;
}
Hierar chy: Object→AbstractBorder(Border, Serializable)→BevelBorder
Subc lasses: SoftBevelBorder, javax.swing .plaf.BorderUIResource.BevelBorderUIResource
Border
Ja va 1.2
javax.swing .border
This simple interface deﬁnes the methods that must be implemented by any object that
wants to display a border around a Swing component. getBorderInsets() retur ns a
java.awt.Insets object that speciﬁes the size of each edge of the border. isBorderOpaque()
indicates either that the border is opaque or that it allows the container background to
show through. Opaque borders are requir ed to paint all pixels in the border region.
Finally, paintBorder() is the method that is responsible for drawing the border around the
speciﬁed component at the speciﬁed location, using the speciﬁed java.awt.Graphics
object.
The javax.swing .border package contains a number of Border implementations that are use-
ful with Swing classes. Note, however, that Border instances are intended to be shared
among components. This means that you typically should obtain refer ences to shared
Border objects by calling the static factory methods of javax.swing .BorderFactor y. To deﬁne
your own custom type of border, you can subclass AbstractBorder.
public abstract interface Border {
// Public Instance Methods
public abstract java.awt.Insets getBorderInsets(Component c);
public abstract boolean isBorderOpaque();
public abstract void paintBorder(Component c, java.awt.Graphics g, int x, int y, int width, int height);
}
Implementations: AbstractBorder, javax.swing .plaf.BorderUIResource
Passed To: Too many methods to list.
Retur ned By: Too many methods to list.
Type Of: DefaultListCellRenderer.noFocusBorder, CompoundBorder.{insideBorder, outsideBorder},
TitledBorder.border, javax.swing .table.DefaultTableCellRenderer.noFocusBorder,
javax.swing .tree.DefaultTreeCellEditor.DefaultTextF ield.border
CompoundBorder
Ja va 1.2
javax.swing .border
serializable
This class combines two borders and displays the result around a Swing component.
For example, you can use CompoundBorder to combine a beveled outer border and an
etched inner border. Or you can use CompoundBorder to combine a MatteBorder and an
EmptyBorder, to create an additional margin within the MatteBorder. See also the createCom-
poundBorder() method of javax.swing .BorderFactor y.
javax.swing.
border
javax.swing.border.CompoundBorder
Chapter 24 – The javax.swing.border Package
521

public class CompoundBorder extends AbstractBorder {
// Public Constructors
public CompoundBorder();
public CompoundBorder(Border outsideBorder, Border insideBorder);
// Property Accessor Methods (by property name)
Overrides:AbstractBorder default:false
public boolean isBorderOpaque();
default:null
public Border getInsideBorder();
default:null
public Border getOutsideBorder();
// Public Methods Overriding AbstractBorder
public java.awt.Insets getBorderInsets(Component c);
public java.awt.Insets getBorderInsets(Component c, java.awt.Insets insets);
public void paintBorder(Component c, java.awt.Graphics g, int x, int y, int width, int height);
// Protected Instance Fields
protected Border insideBorder;
protected Border outsideBorder;
}
Hierar chy: Object→AbstractBorder(Border, Serializable)→CompoundBorder
Subc lasses: javax.swing .plaf.BorderUIResource.CompoundBorderUIResource
Retur ned By: BorderFactor y.createCompoundBorder()
EmptyBorder
Ja va 1.2
javax.swing .border
serializable
This class implements a transparent, empty border. It is used to place a blank margin
ar ound a Swing component. The arguments to the constructor specify the number of
pixels of blank space to appear on each edge of the component. See also the createEmp-
tyBorder() method of javax.swing .BorderFactor y.
public class EmptyBorder extends AbstractBorder implements Serializable {
// Public Constructors
public EmptyBorder(java.awt.Insets insets);
public EmptyBorder(int top, int left, int bottom, int right);
// Public Methods Overriding AbstractBorder
public java.awt.Insets getBorderInsets(Component c);
public java.awt.Insets getBorderInsets(Component c, java.awt.Insets insets);
constant
public boolean isBorderOpaque();
empty
public void paintBorder(Component c, java.awt.Graphics g, int x, int y, int width, int height);
// Protected Instance Fields
protected int bottom;
protected int left;
protected int right;
protected int top;
}
Hierar chy: Object→AbstractBorder(Border, Serializable)→EmptyBorder(Serializable)
Subc lasses: MatteBorder, javax.swing .plaf.BorderUIResource.EmptyBorderUIResource
EtchedBorder
Ja va 1.2
javax.swing .border
serializable
This class displays an etched border around a Swing component. By default, the border
appears etched into the screen. You can create a border that appears etched out by
passing the RAISED constant to the EtchedBorder() constructor. It usually is not necessary
to specify colors for the border, since EtchedBorder automatically chooses correct defaults
based on the component’s background color. See also the createEtchedBorder() method of
javax.swing .BorderFactor y.
javax.swing.border.CompoundBorder
522 Chapter 24 – The javax.swing.border Package

public class EtchedBorder extends AbstractBorder {
// Public Constructors
public EtchedBorder();
public EtchedBorder(int etchType);
public EtchedBorder(java.awt.Color highlight, java.awt.Color shadow);
public EtchedBorder(int etchType, java.awt.Color highlight, java.awt.Color shadow);
// Public Constants
=1
public static ﬁnal int LOWERED;
=0
public static ﬁnal int RAISED;
// Public Instance Methods
default:1
public int getEtchType();
public java.awt.Color getHighlightColor(Component c);
public java.awt.Color getShadowColor(Component c);
// Public Methods Overriding AbstractBorder
public java.awt.Insets getBorderInsets(Component c);
public java.awt.Insets getBorderInsets(Component c, java.awt.Insets insets);
constant default:true
public boolean isBorderOpaque();
public void paintBorder(Component c, java.awt.Graphics g, int x, int y, int width, int height);
// Protected Instance Fields
protected int etchType;
protected java.awt.Color highlight;
protected java.awt.Color shadow;
}
Hierar chy: Object→AbstractBorder(Border, Serializable)→EtchedBorder
Subc lasses: javax.swing .plaf.BorderUIResource.EtchedBorderUIResource
LineBorder
Ja va 1.2
javax.swing .border
serializable
This class draws a solid line of the speciﬁed color and thickness around a Swing com-
ponent. The default thickness is one pixel. The two static methods retur n shar ed
LineBorder instances that draw black and gray lines that are one-pixel wide. See also the
createLineBorder() method of javax.swing .BorderFactor y.
public class LineBorder extends AbstractBorder {
// Public Constructors
public LineBorder(java.awt.Color color);
public LineBorder(java.awt.Color color, int thickness);
// Public Class Methods
public static Border createBlackLineBorder();
public static Border createGrayLineBorder();
// Public Instance Methods
public java.awt.Color getLineColor();
public int getThickness();
// Public Methods Overriding AbstractBorder
public java.awt.Insets getBorderInsets(Component c);
public java.awt.Insets getBorderInsets(Component c, java.awt.Insets insets);
constant
public boolean isBorderOpaque();
public void paintBorder(Component c, java.awt.Graphics g, int x, int y, int width, int height);
// Protected Instance Fields
protected java.awt.Color lineColor;
protected boolean roundedCor ners;
protected int thickness;
}
javax.swing.
border
javax.swing.border.LineBorder
Chapter 24 – The javax.swing.border Package
523

Hierar chy: Object→AbstractBorder(Border, Serializable)→LineBorder
Subc lasses: javax.swing .plaf.BorderUIResource.LineBorderUIResource
MatteBorder
Ja va 1.2
javax.swing .border
serializable
This class uses a solid color or tiled icon to paint a border around a Swing component.
The sizes of each edge of the border can be independently speciﬁed. If an icon is spec-
iﬁed and border sizes are not, the top and bottom insets of the border equal the icon
height, and the left and right insets equal the icon width. See also the createMatteBorder()
method of javax.swing .BorderFactor y.
public class MatteBorder extends EmptyBorder {
// Public Constructors
public MatteBorder(Icon tileIcon);
public MatteBorder(int top, int left, int bottom, int right, Icon tileIcon);
public MatteBorder(int top, int left, int bottom, int right, java.awt.Color color);
// Public Methods Overriding EmptyBorder
public java.awt.Insets getBorderInsets(Component c);
public java.awt.Insets getBorderInsets(Component c, java.awt.Insets insets);
public boolean isBorderOpaque();
public void paintBorder(Component c, java.awt.Graphics g, int x, int y, int width, int height);
// Protected Instance Fields
protected java.awt.Color color;
protected Icon tileIcon;
}
Hierar chy: Object→AbstractBorder(Border, Serializable)→EmptyBorder(Serializable)→MatteBorder
Subc lasses: javax.swing .plaf.BorderUIResource.MatteBorderUIResource
Retur ned By: BorderFactor y.createMatteBorder()
SoftBevelBorder
Ja va 1.2
javax.swing .border
serializable
This class displays a two-pixel-wide raised or lowered beveled border around a Swing
component. SoftBevelBorder dif fers fr om its superclass BevelBorder in that it draws a softer
bevel (i.e., a bevel whose corners do not appear as sharp). Unlike the other border
types, shared SoftBevelBorder instances cannot be created through the javax.swing .BorderFac-
tor y class.
public class SoftBevelBorder extends BevelBorder {
// Public Constructors
public SoftBevelBorder(int bevelType);
public SoftBevelBorder(int bevelType, java.awt.Color highlight, java.awt.Color shadow);
public SoftBevelBorder(int bevelType, java.awt.Color highlightOuter, java.awt.Color highlightInner,
java.awt.Color shadowOuter, java.awt.Color shadowInner);
// Public Methods Overriding BevelBorder
public java.awt.Insets getBorderInsets(Component c);
constant
public boolean isBorderOpaque();
public void paintBorder(Component c, java.awt.Graphics g, int x, int y, int width, int height);
}
Hierar chy: Object→AbstractBorder(Border, Serializable)→BevelBorder→SoftBevelBorder
javax.swing.border.LineBorder
524 Chapter 24 – The javax.swing.border Package

TitledBorder
Ja va 1.2
javax.swing .border
serializable
This class combines a textual title with another border. This can be a useful effect
when, for example, you want to group and title several components, such as a group
of JRadioButton objects. By default, TitledBorder draws an EtchedBorder and displays the title
left justiﬁed on the top edge of that border. Arguments to the constructor and property-
setting methods allow you to specify the Border to be drawn, the position of the title rel-
ative to the top or bottom of that border, the justiﬁcation of the title, the title font, and
the title color. The title can be positioned above, on top of, or below the top or bottom
edge of the border, and it can be left, center, or right justiﬁed. The positioning is speci-
ﬁed by the titlePosition and titleJustiﬁcation pr operties. TitledBorder constants deﬁne the legal
values of these properties.
TitledBorder instances are not typically shared among components because differ ent com-
ponents do not typically have the same title. Since the TitledBorder instances are not
shar ed, they need not be immutable. TitledBorder is unique among the classes in
javax.swing .border in that it has properties that can be set after the instance is created. You
can still use the createT itledBorder() method of javax.swing .BorderFactor y to create TitledBorder
instances, but since they are unlikely to be shared, this is typically not very useful.
public class TitledBorder extends AbstractBorder {
// Public Constructors
public TitledBorder(Border border);
public TitledBorder(String title);
public TitledBorder(Border border, String title);
public TitledBorder(Border border, String title, int titleJustiﬁcation, int titlePosition);
public TitledBorder(Border border, String title, int titleJustiﬁcation, int titlePosition, java.awt.Font titleFont);
public TitledBorder(Border border, String title, int titleJustiﬁcation, int titlePosition, java.awt.Font titleFont,
java.awt.Color titleColor);
// Public Constants
=4
public static ﬁnal int ABOVE_BOTTOM;
=1
public static ﬁnal int ABOVE_TOP;
=6
public static ﬁnal int BELOW_BOTTOM;
=3
public static ﬁnal int BELOW_TOP;
=5
public static ﬁnal int BOTTOM;
=2
public static ﬁnal int CENTER;
=0
public static ﬁnal int DEFAULT_JUSTIFICATION;
=0
public static ﬁnal int DEFAULT_POSITION;
=1
public static ﬁnal int LEFT;
=3
public static ﬁnal int RIGHT;
=2
public static ﬁnal int TOP;
// Protected Constants
=2
protected static ﬁnal int EDGE_SPACING;
=5
protected static ﬁnal int TEXT_INSET_H;
=2
protected static ﬁnal int TEXT_SPACING;
// Property Accessor Methods (by property name)
public Border getBorder();
public void setBorder(Border border);
Overrides:AbstractBorder constant
public boolean isBorderOpaque();
public String getT itle();
public void setT itle(String title);
public java.awt.Color getT itleColor();
public void setT itleColor(java.awt.Color titleColor);
public java.awt.Font getT itleFont();
public void setT itleFont(java.awt.Font titleFont);
public int getT itleJustiﬁcation();
public void setT itleJustiﬁcation(int titleJustiﬁcation);
javax.swing.
border
javax.swing.border.TitledBorder
Chapter 24 – The javax.swing.border Package
525

public int getT itlePosition();
public void setT itlePosition(int titlePosition);
// Public Instance Methods
public java.awt.Dimension getMinimumSize(Component c);
// Public Methods Overriding AbstractBorder
public java.awt.Insets getBorderInsets(Component c);
public java.awt.Insets getBorderInsets(Component c, java.awt.Insets insets);
public void paintBorder(Component c, java.awt.Graphics g, int x, int y, int width, int height);
// Protected Instance Methods
protected java.awt.Font getFont(Component c);
// Protected Instance Fields
protected Border border;
protected String title;
protected java.awt.Color titleColor;
protected java.awt.Font titleFont;
protected int titleJustiﬁcation;
protected int titlePosition;
}
Hierar chy: Object→AbstractBorder(Border, Serializable)→TitledBorder
Subc lasses: javax.swing .plaf.BorderUIResource.TitledBorderUIResource
Retur ned By: BorderFactor y.createTitledBorder()
javax.swing.border.TitledBorder
526 Chapter 24 – The javax.swing.border Package

CHAPTER 25
The javax.swing.color chooser Package
The classes and interfaces of the javax.swing .colorchooser package support the JColor-
Chooser component of the javax.swing package and allow customization of that com-
ponent. Figure 25-1 shows the class hierarchy of this package.
extends
implements
KEY
CLASS
INTERFACE
ABSTRACT CLASS
ColorChooserComponentFactory
javax.swing.colorchooser
java.lang
Serializable
Object
java.io
DefaultColorSelectionModel
ColorSelectionModel
AbstractColorChooserPanel
javax.swing
JPanel
Figur e 25−1: The javax.swing.color chooser package
AbstractColorChooserPanel
Ja va 1.2
javax.swing .colorchooser
serializable accessible swing component
This abstract subclass of JPanel pr ovides the basic framework for creating new color
selection panels for the JColorChooser component. The default color selection panels pro-
vided by the JColorChooser ar e adequate for most applications. If you want to add a cus-
tom panel, you must subclass this class and provide implementations for the abstract
methods. The buildChooser() method should create the GUI components that your color
javax.swing.
colorchooser
527

selection panel uses. getDisplayName(), getLargeDisplayIcon(), and getSmallDisplayIcon() should
retur n a name and icons for your custom panel, respectively. These are displayed in the
JTabbedPane tab for your color selection panel.
The most important task for your AbstractColorChooserPanel, however, is communicating
with the ColorSelectionModel object of the JColorChooser. Call the getColorSelectionModel()
method to obtain the model. When the user selects a color in your panel, you must
change the selected color in the model, so that the JColorChooser knows of your selec-
tion. Conversely, if the user selects a color in some other panel, the abstract update-
Chooser() method is called to notify your panel of the change. Your panel should update
itself to reﬂect the new color selection.
public abstract class AbstractColorChooserPanel extends JPanel {
// Public Constructors
public AbstractColorChooserPanel();
// Property Accessor Methods (by property name)
public ColorSelectionModel getColorSelectionModel();
public abstract String getDisplayName();
public abstract Icon getLargeDisplayIcon();
public abstract Icon getSmallDisplayIcon();
// Public Instance Methods
public void installChooserPanel(JColorChooser enclosingChooser);
public void uninstallChooserPanel(JColorChooser enclosingChooser);
public abstract void updateChooser();
// Public Methods Overriding JComponent
public void paint(java.awt.Graphics g);
// Protected Instance Methods
protected abstract void buildChooser();
protected java.awt.Color getColorFromModel();
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→JComponent(Serializable)→JPanel(Accessible)→AbstractColorChooserPanel
Passed To: JColorChooser.{addChooserPanel(), removeChooserPanel(), setChooserPanels()}
Retur ned By: JColorChooser.{getChooserPanels(), removeChooserPanel()},
ColorChooserComponentFactor y.getDefaultChooserPanels()
ColorChooserComponentFactor y
Ja va 1.2
javax.swing .colorchooser
This class consists of static methods that retur n the individual color selection and color
pr eview components that are used to create a default JColorChooser component. This
class is used by the JColorChooser UI delegate object and normally is not used by appli-
cations. However, you may ﬁnd it useful if you want to arrange standard color chooser
components in a custom custom dialog box of your own.
public class ColorChooserComponentFactor y {
// No Constructor
// Public Class Methods
public static AbstractColorChooserPanel[ ] getDefaultChooserPanels();
public static JComponent getPreviewPanel();
}
ColorSelectionModel
Ja va 1.2
javax.swing .colorchooser
model
This interface deﬁnes the methods that must be implemented by an object that wants to
keep track of a selected color for a JColorChooser. The interface is a simple one,
javax.swing.color chooser.AbstractColorChooserPanel
528 Chapter 25 – The javax.swing.color chooser Package

consisting only of a pair of property accessor methods for the selected color and a pair
of event registration methods for listeners that are inter ested in knowing when the
selection changes. DefaultColorSelectionModel pr ovides a simple implementation of this
inter face.
public abstract interface ColorSelectionModel {
// Event Registration Methods (by event name)
public abstract void addChangeListener(javax.swing .event.ChangeListener listener);
public abstract void removeChangeListener(javax.swing .event.ChangeListener listener);
// Public Instance Methods
public abstract java.awt.Color getSelectedColor();
public abstract void setSelectedColor(java.awt.Color color);
}
Implementations: DefaultColorSelectionModel
Passed To: JColorChooser.{JColorChooser(), setSelectionModel()}
Retur ned By: JColorChooser.getSelectionModel(), AbstractColorChooserPanel.getColorSelectionModel()
DefaultColorSelectionModel
Ja va 1.2
javax.swing .colorchooser
serializable model
This class is a simple default implementation of the ColorSelectionModel inter face.
public class DefaultColorSelectionModel implements ColorSelectionModel, Serializable {
// Public Constructors
public DefaultColorSelectionModel();
public DefaultColorSelectionModel(java.awt.Color color);
// Event Registration Methods (by event name)
Implements:ColorSelectionModel
public void addChangeListener(javax.swing .event.ChangeListener l);
Implements:ColorSelectionModel
public void removeChangeListener(javax.swing .event.ChangeListener l);
// Methods Implementing ColorSelectionModel
public void addChangeListener(javax.swing .event.ChangeListener l);
public java.awt.Color getSelectedColor();
public void removeChangeListener(javax.swing .event.ChangeListener l);
public void setSelectedColor(java.awt.Color color);
// Protected Instance Methods
protected void ﬁreStateChanged();
// Protected Instance Fields
protected transient javax.swing.e vent.ChangeEvent changeEvent;
protected javax.swing.e vent.EventListenerList listenerList;
}
Hierar chy: Object→DefaultColorSelectionModel(ColorSelectionModel, Serializable)
javax.swing.
colorchooser
javax.swing.color chooser.DefaultColorSelectionModel
Chapter 25 – The javax.swing.color chooser Package
529

CHAPTER 26
The javax.swing.event Package
The javax.swing .event package augments the java.awt.event package and deﬁnes event
objects, listeners, and adapters that are speciﬁc to Swing components. Classes with
names ending in “Event” deﬁne event types; their ﬁelds and methods provide
details about the event that occurred. Interfaces with names ending in “Listener”
ar e event listeners. The methods of these interfaces are invoked to notify inter-
ested objects when speciﬁc events occur. Classes with names ending in “Adapter”
ar e convenient no-op implementations of listener interfaces. Typically, it is easier
to subclass an adapter class than implement the corresponding listener interface
fr om scratch. Figure 26-1 shows the event classes of this package, while Figure
26-2 shows the event listeners.
AncestorEvent
Ja va 1.2
javax.swing .event
serializable event
An event of this type is generated by a JComponent when it is moved, becomes visible,
or becomes invisible. Often, the event is generated when one of the component’s
ancestors is moved, becomes visible, or becomes invisible. The inherited getID() method
retur ns the type of the event, which is one of the constants deﬁned by the class. ANCES-
TOR_ADDED is used when the component becomes visible, and ANCESTOR_REMOVED is
used when the component becomes invisible. getAncestor() retur ns the ancestor compo-
nent that was modiﬁed, and, as a convenience, getAncestorParent() retur ns the parent of
that ancestor. getComponent() is a synonym for the inherited getSource() method, except
that it casts its retur n value to a JComponent.
public class AncestorEvent extends java.awt.AWTEvent {
// Public Constructors
public AncestorEvent(JComponent source, int id, Container ancestor, Container ancestorParent);
// Public Constants
=1
public static ﬁnal int ANCESTOR_ADDED;
=3
public static ﬁnal int ANCESTOR_MOVED;
=2
public static ﬁnal int ANCESTOR_REMOVED;
530

extends
implements
KEY
CLASS
ABSTRACT CLASS
FINAL CLASS
INTERFACE
java.lang
Object
java.awt
javax.swing.event
Serializable
EventListenerList
java.io
java.util
TreeExpansionEvent
ListDataEvent
EventListenerList
ChangeEvent
MenuEvent
HyperlinkEvent
PopupMenuEvent
java.awt.event
java.beans
PropertyChangeSupport
SwingPropertyChangeSupport
AWTEvent
EventObject
CaretEvent
TableColumnModelEvent
TableModelEvent
MenuEvent
KeyEvent
InternalFrameAdaptor
MouseInputAdaptor
AncestorEvent
InternalFrameEvent
MenuDragMouseEvent
MenuKeyEvent
Figur e 26−1: The events of the javax.swing.event package
// Public Instance Methods
public Container getAncestor();
public Container getAncestorParent();
public JComponent getComponent();
}
Hierar chy: Object→java.util.EventObject(Serializable)→java.awt.AWTEvent→AncestorEvent
Passed To: AncestorListener.{ancestorAdded(), ancestorMoved(), ancestorRemoved()}
javax.swing.
event
javax.swing.event.AncestorEvent
Chapter 26 – The javax.swing.event Package
531

INTERFACE
KEY
javax.swing.event
java.util
AncestorEvent
EventListener
ChangeListener
InternalFrameListener
MenuDragMouseListener
MouseInputListener
TableModelListener
TreeSelectionListener
UndoableEditListener
CellEditorListener
HyperlinkListener
ListSelectionListener
MenuListener
TableColumnModelListener
TreeModelListener
CaretListener
DocumentListener
ListDataListener
MenuKeyListener
PopupMenuListener
TreeExpansionListener
TreeWillExpandListener
extends
Figur e 26−2: The event listeners of the javax.swing.event package
AncestorListener
Ja va 1.2
javax.swing .event
event listener
This interface deﬁnes the methods that must be implemented by an object that wants to
receive notiﬁcation when a JComponent is moved (with ancestorMoved()), made visible
(ancestorAdded()),or made invisible (ancestorRemoved()).
public abstract interface AncestorListener extends java.util.EventListener {
// Public Instance Methods
public abstract void ancestorAdded(AncestorEvent event);
public abstract void ancestorMoved(AncestorEvent event);
public abstract void ancestorRemoved(AncestorEvent event);
}
Hierar chy: (AncestorListener(java.util.EventListener))
Passed To: JComponent.{addAncestorListener(), removeAncestorListener()}
CaretEvent
Ja va 1.2
javax.swing .event
serializable event
This event is generated by JTextComponent and its subclasses JTextF ield, JTextArea, JTextPane,
and JEditorPane when the caret position changes. The text caret maintains both the cur-
rent insertion position (the dot) and a marker position (the mark). A CaretEvent is gener-
ated when either position changes. The changed values can be obtained with getDot()
and getMark(), respectively. The text component that contains the caret can be queried
with the inherited getSource() method.
javax.swing.event.AncestorEvent
532 Chapter 26 – The javax.swing.event Package

public abstract class CaretEvent extends java.util.EventObject {
// Public Constructors
public CaretEvent(Object source);
// Public Instance Methods
public abstract int getDot();
public abstract int getMark();
}
Hierar chy: Object→java.util.EventObject(Serializable)→CaretEvent
Passed To: CaretListener.caretUpdate(), javax.swing .text.JTextComponent.fireCaretUpdate(),
javax.swing .text.JTextComponent.AccessibleJTextComponent.caretUpdate()
CaretListener
Ja va 1.2
javax.swing .event
event listener
This interface deﬁnes a method that an object must implement if it wants to receive
notiﬁcation when the caret position changes in a JTextComponent or one of its subclasses.
public abstract interface CaretListener extends java.util.EventListener {
// Public Instance Methods
public abstract void caretUpdate(CaretEvent e);
}
Hierar chy: (CaretListener(java.util.EventListener))
Implementations: javax.swing .text.JTextComponent.AccessibleJTextComponent
Passed To: javax.swing .text.JTextComponent.{addCaretListener(), removeCaretListener()}
CellEditorListener
Ja va 1.2
javax.swing .event
event listener
This interface deﬁnes the methods that must be implemented by an object that wants to
receive notiﬁcation of state changes in a javax.swing .CellEditor. Note that these methods
ar e passed a ChangeEvent; ther e is no special CellEditorEvent type.
public abstract interface CellEditorListener extends java.util.EventListener {
// Public Instance Methods
public abstract void editingCanceled(ChangeEvent e);
public abstract void editingStopped(ChangeEvent e);
}
Hierar chy: (CellEditorListener(java.util.EventListener))
Implementations: JTable, JTable.AccessibleJTable
Passed To: CellEditor.{addCellEditorListener(), removeCellEditorListener()},
DefaultCellEditor.{addCellEditorListener(), removeCellEditorListener()},
javax.swing .tree.DefaultTreeCellEditor.{addCellEditorListener(), removeCellEditorListener()}
ChangeEvent
Ja va 1.2
javax.swing .event
serializable event
This class is a generic event type that is generated by many Swing components to indi-
cate that something has changed within the component. ChangeEvent does not contain
any ﬁelds to indicate the type of the change; the type of state change should be implicit
in the event listener to which the ChangeEvent object is passed. The only state main-
tained by ChangeEvent is the component that generated the event (retur ned by the inher-
ited getSource() method). Because ChangeEvent is immutable and effectively stateless,
javax.swing.
event
javax.swing.event.ChangeEvent
Chapter 26 – The javax.swing.event Package
533

Swing components can reuse a single shared ChangeEvent object for all their state
changes, instead of allocating an event object for every change.
public class ChangeEvent extends java.util.EventObject {
// Public Constructors
public ChangeEvent(Object source);
}
Hierar chy: Object→java.util.EventObject(Serializable)→ChangeEvent
Passed To: Too many methods to list.
Type Of: AbstractButton.changeEvent, DefaultBoundedRangeModel.changeEvent,
DefaultButtonModel.changeEvent, DefaultCellEditor.changeEvent, DefaultSingleSelectionModel.changeEvent,
JProgressBar.changeEvent, JSlider.changeEvent, JTabbedPane.changeEvent,
MenuSelectionManager.changeEvent, javax.swing .colorchooser.DefaultColorSelectionModel.changeEvent,
javax.swing .table.DefaultTableColumnModel.changeEvent, javax.swing .text.DefaultCaret.changeEvent,
javax.swing .text.StyleContext.NamedStyle.changeEvent
ChangeListener
Ja va 1.2
javax.swing .event
event listener
This interface deﬁnes the method that an object must implement to receive notiﬁcations
of state change events in Swing components.
public abstract interface ChangeListener extends java.util.EventListener {
// Public Instance Methods
public abstract void stateChanged(ChangeEvent e);
}
Hierar chy: (ChangeListener(java.util.EventListener))
Implementations: AbstractButton.ButtonChangeListener, JMenuItem.AccessibleJMenuItem,
JScrollPane.AccessibleJScrollPane, JTabbedPane.AccessibleJTabbedPane, JTabbedPane.ModelListener
Passed To: Too many methods to list.
Retur ned By: AbstractButton.createChangeListener(), JProgressBar.createChangeListener(),
JSlider.createChangeListener(), JTabbedPane.createChangeListener()
Type Of: AbstractButton.changeListener, JProgressBar.changeListener, JSlider.changeListener,
JTabbedPane.changeListener
DocumentEvent
Ja va 1.2
javax.swing .event
Events of this type are generated by a javax.swing .text.Document object when the docu-
ment it repr esents changes. getDocument() retur ns the Document that was modiﬁed. get-
Type() retur ns the type of the changes; its retur n value is one of the three constants
deﬁned by the DocumentEvent.EventType inner class. getOffset() retur ns the document coor-
dinate of the start of the change, and getLength() retur ns the length of the change.
getChange() retur ns a DocumentEvent.ElementChange object that describes the change in
ter ms of its effect on the speciﬁed javax.swing .text.Element of the document.
public abstract interface DocumentEvent {
// Inner Classes
public abstract static interface ElementChange;
public static ﬁnal class EventType;
// Property Accessor Methods (by property name)
public abstract javax.swing.text.Document getDocument();
public abstract int getLength();
javax.swing.event.ChangeEvent
534 Chapter 26 – The javax.swing.event Package

public abstract int getOffset();
public abstract DocumentEvent.EventType getType();
// Public Instance Methods
public abstract DocumentEvent.ElementChange getChange(javax.swing .text.Element elem);
}
Implementations: javax.swing .text.AbstractDocument.DefaultDocumentEvent
Passed To: Too many methods to list.
DocumentEvent.ElementChange
Ja va 1.2
javax.swing .event
This interface deﬁnes methods that provide information about changes to an
javax.swing .text.Element object within a javax.swing .text.Document.
public abstract static interface DocumentEvent.ElementChange {
// Property Accessor Methods (by property name)
public abstract javax.swing.text.Element[ ] getChildrenAdded();
public abstract javax.swing.text.Element[ ] getChildrenRemoved();
public abstract javax.swing.text.Element getElement();
public abstract int getIndex();
}
Implementations: javax.swing .text.AbstractDocument.ElementEdit
Retur ned By: DocumentEvent.getChange(),
javax.swing .text.AbstractDocument.DefaultDocumentEvent.getChange()
DocumentEvent.EventType
Ja va 1.2
javax.swing .event
This class deﬁnes three type-safe object constants that are used to specify the type of a
DocumentEvent.
public static ﬁnal class DocumentEvent.EventType {
// No Constructor
// Public Constants
public static ﬁnal DocumentEvent.EventType CHANGE;
public static ﬁnal DocumentEvent.EventType INSERT;
public static ﬁnal DocumentEvent.EventType REMOVE;
// Public Methods Overriding Object
public String toString();
}
Passed To: javax.swing .text.AbstractDocument.DefaultDocumentEvent.DefaultDocumentEvent()
Retur ned By: DocumentEvent.getType(),
javax.swing .text.AbstractDocument.DefaultDocumentEvent.getType()
Type Of: DocumentEvent.EventType.{CHANGE, INSERT, REMOVE}
DocumentListener
Ja va 1.2
javax.swing .event
event listener
This interface deﬁnes the method that an object must implement in order to register for
notiﬁcations of changes to a javax.swing .text.Document object.
public abstract interface DocumentListener extends java.util.EventListener {
// Public Instance Methods
javax.swing.
event
javax.swing.event.DocumentListener
Chapter 26 – The javax.swing.event Package
535

public abstract void changedUpdate(DocumentEvent e);
public abstract void inser tUpdate(DocumentEvent e);
public abstract void removeUpdate(DocumentEvent e);
}
Hierar chy: (DocumentListener(java.util.EventListener))
Implementations: javax.swing .text.JTextComponent.AccessibleJTextComponent
Passed To: javax.swing .text.AbstractDocument.{addDocumentListener(), removeDocumentListener()},
javax.swing .text.DefaultStyledDocument.{addDocumentListener(), removeDocumentListener()},
javax.swing .text.Document.{addDocumentListener(), removeDocumentListener()}
EventListenerList
Ja va 1.2
javax.swing .event
serializable
This utility class is used by many Swing classes to maintain lists of event listeners. An
EventListenerList maintains a list of event listener objects, possibly of several differ ent
types. In order to allow the type of each listener to be determined efﬁciently, EventLis-
tenerList also maintains the java.lang .Class object for each EventListener.
The add() and remove() methods add and remove an event listener and its Class object to
and from the list. When a component needs to send an event to all register ed listeners
of a given type, it calls getListenerList(). This method retur ns an array of objects, where
the elements of this array are grouped in pairs. Each even-numbered element is a Class
object that speciﬁes the type of the event listener stored in the following odd-numbered
element. Thus, you can quickly loop through the list of event listeners, comparing Class
objects to ﬁnd any register ed listeners of the desired type. Objects that make use of
EventListenerList must be careful not to modify the contents of the array retur ned by
getListenerList().
public class EventListenerList implements Serializable {
// Public Constructors
public EventListenerList();
// Property Accessor Methods (by property name)
default:0
public int getListenerCount();
public int getListenerCount(Class t);
public Object[ ] getListenerList();
// Public Instance Methods
synchronized
public void add(Class t, java.util.EventListener l);
synchronized
public void remove(Class t, java.util.EventListener l);
// Public Methods Overriding Object
public String toString();
// Protected Instance Fields
protected transient Object[ ] listenerList;
}
Hierar chy: Object→EventListenerList(Serializable)
Type Of: Too many fields to list.
Hyper linkEvent
Ja va 1.2
javax.swing .event
serializable event
An event of this type is generated by JEditorPane when the user moves the mouse over,
clicks on, or moves the mouse off a hypertext link. getURL() retur ns the URL of the
hyperlink. getEventType() retur ns an object constant indicating what was done to the
hyperlink. The inherited getSource() method retur ns the JEditorPane that contains the
hyperlink.
javax.swing.event.DocumentListener
536 Chapter 26 – The javax.swing.event Package

public class Hyper linkEvent extends java.util.EventObject {
// Public Constructors
public Hyper linkEvent(Object source, HyperlinkEvent.EventType type, java.net.URL u);
public Hyper linkEvent(Object source, HyperlinkEvent.EventType type, java.net.URL u, String desc);
// Inner Classes
public static ﬁnal class EventType;
// Public Instance Methods
public String getDescription();
public HyperlinkEvent.EventType getEventType();
public java.net.URL getURL();
}
Hierar chy: Object→java.util.EventObject(Serializable)→Hyper linkEvent
Subc lasses: javax.swing .text.html.HTMLFrameHyperlinkEvent
Passed To: JEditorPane.fireHyper linkUpdate(), Hyper linkListener.hyper linkUpdate()
Hyper linkEvent.EventType
Ja va 1.2
javax.swing .event
This class deﬁnes three type-safe object constants that are used to specify the type of a
Hyper linkEvent.
public static ﬁnal class Hyper linkEvent.EventType {
// No Constructor
// Public Constants
public static ﬁnal HyperlinkEvent.EventType ACTIVATED;
public static ﬁnal HyperlinkEvent.EventType ENTERED;
public static ﬁnal HyperlinkEvent.EventType EXITED;
// Public Methods Overriding Object
public String toString();
}
Passed To: Hyper linkEvent.Hyper linkEvent(),
javax.swing .text.html.HTMLFrameHyperlinkEvent.HTMLFrameHyper linkEvent()
Retur ned By: Hyper linkEvent.getEventType()
Type Of: Hyper linkEvent.EventType.{ACTIVATED, ENTERED, EXITED}
Hyper linkListener
Ja va 1.2
javax.swing .event
event listener
This interface deﬁnes the method that an object must implement in order to register for
notiﬁcations about hyperlink activity in a JEditorPane component.
public abstract interface Hyper linkListener extends java.util.EventListener {
// Public Instance Methods
public abstract void hyper linkUpdate(HyperlinkEvent e);
}
Hierar chy: (Hyper linkListener(java.util.EventListener))
Passed To: JEditorPane.{addHyper linkListener(), removeHyper linkListener()}
Inter nalFrameAdapter
Ja va 1.2
javax.swing .event
event adapter
This class is an empty implementation of Inter nalFrameListener. It is usually easier to
extend this class than it is to implement Inter nalFrameListener fr om scratch.
javax.swing.
event
javax.swing.event.Inter nalFrameAdapter
Chapter 26 – The javax.swing.event Package
537

public abstract class Inter nalFrameAdapter implements InternalFrameListener {
// Public Constructors
public Inter nalFrameAdapter();
// Methods Implementing InternalFrameListener
empty
public void inter nalFrameActivated(InternalFrameEvent e);
empty
public void inter nalFrameClosed(InternalFrameEvent e);
empty
public void inter nalFrameClosing(InternalFrameEvent e);
empty
public void inter nalFrameDeactivated(InternalFrameEvent e);
empty
public void inter nalFrameDeiconiﬁed(InternalFrameEvent e);
empty
public void inter nalFrameIconiﬁed(InternalFrameEvent e);
empty
public void inter nalFrameOpened(InternalFrameEvent e);
}
Hierar chy: Object→Inter nalFrameAdapter(Inter nalFrameListener(java.util.EventListener))
Inter nalFrameEvent
Ja va 1.2
javax.swing .event
serializable event
Events of this type are generated when a JInter nalFrame component changes state. An
Inter nalFrameEvent is very similar to the java.awt.event.W indowEvent generated when a native
window (such as a JFrame or JDialog) changes state. The inherited getSource() method
retur ns the JInter nalFrame object that generated the event. The inherited getID() method
retur ns the type of the event; this retur n value is one of the constants deﬁned by this
class. The meanings of these constants are mostly straightforward. Note the distinction
between INTERNAL_FRAME_CLOSING and INTERNAL_FRAME_CLOSED, however. The ﬁrst type
of event is generated when the user requests that the JInter nalFrame be closed. The pro-
gram may respond by hiding or destroying the window (it is poor style to ignore this
type of event). The second type of event is generated only after the internal frame is
actually hidden or destroyed.
public class Inter nalFrameEvent extends java.awt.AWTEvent {
// Public Constructors
public Inter nalFrameEvent(JInternalFrame source, int id);
// Public Constants
=25554
public static ﬁnal int INTERNAL_FRAME_ACTIVATED;
=25551
public static ﬁnal int INTERNAL_FRAME_CLOSED;
=25550
public static ﬁnal int INTERNAL_FRAME_CLOSING;
=25555
public static ﬁnal int INTERNAL_FRAME_DEACTIVATED;
=25553
public static ﬁnal int INTERNAL_FRAME_DEICONIFIED;
=25549
public static ﬁnal int INTERNAL_FRAME_FIRST;
=25552
public static ﬁnal int INTERNAL_FRAME_ICONIFIED;
=25555
public static ﬁnal int INTERNAL_FRAME_LAST;
=25549
public static ﬁnal int INTERNAL_FRAME_OPENED;
// Public Methods Overriding AWTEvent
public String paramString();
}
Hierar chy: Object→java.util.EventObject(Serializable)→java.awt.AWTEvent→Inter nalFrameEvent
Passed To: Inter nalFrameAdapter.{inter nalFrameActivated(), internalFrameClosed(), internalFrameClosing(),
inter nalFrameDeactivated(), internalFrameDeiconified(), internalFrameIconified(), internalFrameOpened()},
Inter nalFrameListener.{inter nalFrameActivated(), internalFrameClosed(), internalFrameClosing(),
inter nalFrameDeactivated(), internalFrameDeiconified(), internalFrameIconified(), internalFrameOpened()}
javax.swing.event.Inter nalFrameAdapter
538 Chapter 26 – The javax.swing.event Package

Inter nalFrameListener
Ja va 1.2
javax.swing .event
event listener
This class deﬁnes the methods that an object must implement to receive notiﬁcations
about state changes in a JInter nalFrame. See Inter nalFrameEvent for a discussion of the dif-
fer ence between inter nalFrameClosed() and inter nalFrameClosing(). It is usually easier to sub-
class Inter nalFrameAdapter than to implement this interface from scratch.
public abstract interface Inter nalFrameListener extends java.util.EventListener {
// Public Instance Methods
public abstract void inter nalFrameActivated(InternalFrameEvent e);
public abstract void inter nalFrameClosed(InternalFrameEvent e);
public abstract void inter nalFrameClosing(InternalFrameEvent e);
public abstract void inter nalFrameDeactivated(InternalFrameEvent e);
public abstract void inter nalFrameDeiconiﬁed(InternalFrameEvent e);
public abstract void inter nalFrameIconiﬁed(InternalFrameEvent e);
public abstract void inter nalFrameOpened(InternalFrameEvent e);
}
Hierar chy: (Inter nalFrameListener(java.util.EventListener))
Implementations: Inter nalFrameAdapter
Passed To: JInter nalFrame.{addInter nalFrameListener(), removeInter nalFrameListener()}
ListDataEvent
Ja va 1.2
javax.swing .event
serializable event
An event of this type is generated by a javax.swing .ListModel when the contents of the
model changes. getType() retur ns one of the three constants deﬁned by the class, to indi-
cate the type of change that occurred. The inherited getSource() method retur ns the List-
Model object that changed. getIndex0() and getIndex1() retur n the end points of the
modiﬁed interval.
public class ListDataEvent extends java.util.EventObject {
// Public Constructors
public ListDataEvent(Object source, int type, int index0, int index1);
// Public Constants
=0
public static ﬁnal int CONTENTS_CHANGED;
=1
public static ﬁnal int INTERVAL_ADDED;
=2
public static ﬁnal int INTERVAL_REMOVED;
// Public Instance Methods
public int getIndex0();
public int getIndex1();
public int getType();
}
Hierar chy: Object→java.util.EventObject(Serializable)→ListDataEvent
Passed To: JComboBox.{contentsChanged(), intervalAdded(), intervalRemoved()},
JList.AccessibleJList.{contentsChanged(), intervalAdded(), intervalRemoved()},
ListDataListener.{contentsChanged(), intervalAdded(), intervalRemoved()}
ListDataListener
Ja va 1.2
javax.swing .event
event listener
This interface deﬁnes the methods that must be implemented by an object to receive
notiﬁcations of changes to the contents of a javax.swing .ListModel.
javax.swing.
event
javax.swing.event.ListDataListener
Chapter 26 – The javax.swing.event Package
539

public abstract interface ListDataListener extends java.util.EventListener {
// Public Instance Methods
public abstract void contentsChanged(ListDataEvent e);
public abstract void inter valAdded(ListDataEvent e);
public abstract void inter valRemoved(ListDataEvent e);
}
Hierar chy: (ListDataListener(java.util.EventListener))
Implementations: JComboBox, JList.AccessibleJList
Passed To: AbstractListModel.{addListDataListener(), removeListDataListener()},
ListModel.{addListDataListener(), removeListDataListener()}
ListSelectionEvent
Ja va 1.2
javax.swing .event
serializable event
An event of this type is generated by a JList component or its underlying ListSelection-
Model object to indicate a change in the current list selection. getF irstIndex() and getLastIn-
dex() retur n the ﬁrst and last elements in the list that may have had their selection state
changed. The ListSelectionEvent does not contain the new selection state; you must query
the JList or ListSelectionModel for that information. (Use the inherited getSource() method to
obtain the source of the event). getValueIsAdjusting() retur ns tr ue if the event is one in a
series of rapid-ﬁre events, such as those that are generated when the user drags the
mouse through a JList. Some programs may choose to ignore these rapid-ﬁre events and
wait for an event for which getValueIsAdjusting() retur ns false.
public class ListSelectionEvent extends java.util.EventObject {
// Public Constructors
public ListSelectionEvent(Object source, int ﬁrstIndex, int lastIndex, boolean isAdjusting);
// Public Instance Methods
public int getF irstIndex();
public int getLastIndex();
public boolean getValueIsAdjusting();
// Public Methods Overriding EventObject
public String toString();
}
Hierar chy: Object→java.util.EventObject(Serializable)→ListSelectionEvent
Passed To: JList.AccessibleJList.valueChanged(), JTable.{columnSelectionChanged(), valueChanged()},
JTable.AccessibleJTable.{columnSelectionChanged(), valueChanged()}, ListSelectionListener.valueChanged(),
TableColumnModelListener.columnSelectionChanged(),
javax.swing .table.DefaultTableColumnModel.{fireColumnSelectionChanged(), valueChanged()},
javax.swing .table.JTableHeader.columnSelectionChanged()
ListSelectionListener
Ja va 1.2
javax.swing .event
event listener
This interface deﬁnes the method that an object must implement in order to receive
notiﬁcations of changes in the selection state of a JList or ListSelectionModel.
public abstract interface ListSelectionListener extends java.util.EventListener {
// Public Instance Methods
public abstract void valueChanged(ListSelectionEvent e);
}
Hierar chy: (ListSelectionListener(java.util.EventListener))
javax.swing.event.ListDataListener
540 Chapter 26 – The javax.swing.event Package

Implementations: JList.AccessibleJList, JTable, JTable.AccessibleJTable,
javax.swing .table.DefaultTableColumnModel
Passed To: DefaultListSelectionModel.{addListSelectionListener(), removeListSelectionListener()},
JList.{addListSelectionListener(), removeListSelectionListener()},
ListSelectionModel.{addListSelectionListener(), removeListSelectionListener()}
MenuDragMouseEvent
Ja va 1.2
javax.swing .event
serializable event
JMenuItem sends events of this type to register ed MenuDragMouseListener objects to signal
that the mouse has entered or exited the menu item, that it is moving over the menu
item, or that the user has released the mouse button over the menu item.
public class MenuDragMouseEvent extends java.awt.event.MouseEvent {
// Public Constructors
public MenuDragMouseEvent(Component source, int id, long when, int modiﬁers, int x, int y, int clickCount,
boolean popupTrigger, MenuElement[ ] p, MenuSelectionManager m);
// Public Instance Methods
public MenuSelectionManager getMenuSelectionManager();
public MenuElement[ ] getPath();
}
Hierar chy: Object→java.util.EventObject(Serializable)→java.awt.AWTEvent→
java.awt.event.ComponentEvent→java.awt.event.InputEvent→java.awt.event.MouseEvent→
MenuDragMouseEvent
Passed To: JMenuItem.{fireMenuDragMouseDragged(), fireMenuDragMouseEntered(),
fireMenuDragMouseExited(), fireMenuDragMouseReleased(), processMenuDragMouseEvent()},
MenuDragMouseListener.{menuDragMouseDragged(), menuDragMouseEntered(), menuDragMouseExited(),
menuDragMouseReleased()}
MenuDragMouseListener
Ja va 1.2
javax.swing .event
event listener
This interface deﬁnes the methods that JMenuItem invokes on register ed objects when
the user drags the mouse into, over, or out of the menu item or releases the mouse but-
ton over the item.
public abstract interface MenuDragMouseListener extends java.util.EventListener {
// Public Instance Methods
public abstract void menuDragMouseDragged(MenuDragMouseEvent e);
public abstract void menuDragMouseEntered(MenuDragMouseEvent e);
public abstract void menuDragMouseExited(MenuDragMouseEvent e);
public abstract void menuDragMouseReleased(MenuDragMouseEvent e);
}
Hierar chy: (MenuDragMouseListener(java.util.EventListener))
Passed To: JMenuItem.{addMenuDragMouseListener(), removeMenuDragMouseListener()}
MenuEvent
Ja va 1.2
javax.swing .event
serializable event
Events of this type are generated by a JMenu component to indicate that the menu but-
ton has been selected or deselected. (When the menu attached to that button actually
pops up or down, the JPopupMenu component generates a PopupMenuEvent.) The inher-
ited getSource() method retur ns the JMenu object that generated the event. The type of
the MenuEvent depends on which MenuListener method it is passed to.
javax.swing.
event
javax.swing.event.MenuEvent
Chapter 26 – The javax.swing.event Package
541

public class MenuEvent extends java.util.EventObject {
// Public Constructors
public MenuEvent(Object source);
}
Hierar chy: Object→java.util.EventObject(Serializable)→MenuEvent
Passed To: MenuListener.{menuCanceled(), menuDeselected(), menuSelected()}
MenuKeyEvent
Ja va 1.2
javax.swing .event
serializable event
JMenuItem sends events of this type to register ed MenuKeyListener objects when the user
types a key over the menu item.
public class MenuKeyEvent extends java.awt.event.Ke yEvent {
// Public Constructors
public MenuKeyEvent(Component source, int id, long when, int modiﬁers, int keyCode, char keyChar,
MenuElement[ ] p, MenuSelectionManager m);
// Public Instance Methods
public MenuSelectionManager getMenuSelectionManager();
public MenuElement[ ] getPath();
}
Hierar chy: Object→java.util.EventObject(Serializable)→java.awt.AWTEvent→
java.awt.event.ComponentEvent→java.awt.event.InputEvent→java.awt.event.KeyEvent→MenuKeyEvent
Passed To: JMenuItem.{fireMenuKeyPressed(), fireMenuKeyReleased(), fireMenuKeyTyped(),
processMenuKeyEvent()}, MenuKeyListener.{menuKeyPressed(), menuKeyReleased(), menuKeyTyped()}
MenuKeyListener
Ja va 1.2
javax.swing .event
event listener
This interface deﬁnes the method that a JMenuItem invokes on register ed listeners when
the user types a key in the menu item.
public abstract interface MenuKeyListener extends java.util.EventListener {
// Public Instance Methods
public abstract void menuKeyPressed(MenuKe yEvent e);
public abstract void menuKeyReleased(MenuKe yEvent e);
public abstract void menuKeyTyped(MenuKe yEvent e);
}
Hierar chy: (MenuKeyListener(java.util.EventListener))
Passed To: JMenuItem.{addMenuKeyListener(), removeMenuKeyListener()}
MenuListener
Ja va 1.2
javax.swing .event
event listener
This interface deﬁnes the methods that an object must implement in order to be noti-
ﬁed when a JMenu button is selected or deselected or when a menu selection is can-
celed.
public abstract interface MenuListener extends java.util.EventListener {
// Public Instance Methods
public abstract void menuCanceled(MenuEvent e);
public abstract void menuDeselected(MenuEvent e);
public abstract void menuSelected(MenuEvent e);
}
javax.swing.event.MenuEvent
542 Chapter 26 – The javax.swing.event Package

Hierar chy: (MenuListener(java.util.EventListener))
Passed To: JMenu.{addMenuListener(), removeMenuListener()}
MouseInputAdapter
Ja va 1.2
javax.swing .event
event adapter
This class is an empty implementation of MouseInputListener. It often is easier to subclass
this class, overriding only the methods you are inter ested in, than it is to implement all
the methods of java.awt.event.MouseMotionListener fr om scratch.
public abstract class MouseInputAdapter implements MouseInputListener {
// Public Constructors
public MouseInputAdapter();
// Methods Implementing MouseListener
empty
public void mouseClicked(java.awt.e vent.MouseEvent e);
empty
public void mouseEntered(java.awt.e vent.MouseEvent e);
empty
public void mouseExited(java.awt.e vent.MouseEvent e);
empty
public void mousePressed(java.awt.e vent.MouseEvent e);
empty
public void mouseReleased(java.awt.e vent.MouseEvent e);
// Methods Implementing MouseMotionListener
empty
public void mouseDragged(java.awt.e vent.MouseEvent e);
empty
public void mouseMoved(java.awt.e vent.MouseEvent e);
}
Hierar chy: Object→
MouseInputAdapter(MouseInputListener(java.awt.event.MouseListener(java.util.EventListener),
java.awt.event.MouseMotionListener(java.util.EventListener)))
MouseInputListener
Ja va 1.2
javax.swing .event
event listener
MouseInputListener combines into a single interface the methods of the closely related
MouseListener and MouseMotionListener inter faces of the java.awt.event package. This inter-
face is a simple utility that makes it easier to implement both MouseEvent listener inter-
faces at once.
public abstract interface MouseInputListener extends java.awt.event.MouseListener,
java.awt.e vent.MouseMotionListener {
}
Hierar chy: (MouseInputListener(java.awt.event.MouseListener(java.util.EventListener),
java.awt.event.MouseMotionListener(java.util.EventListener)))
Implementations: MouseInputAdapter
PopupMenuEvent
Ja va 1.2
javax.swing .event
serializable event
An event of this type is generated just before a JPopupMenu is popped up or popped
down or when a JPopupMenu is canceled (i.e., when it is popped down without the user
making a selection). The inherited getSource() method retur ns the JPopupMenu, but Popup-
MenuEvent contains no other state. The type of the event is determined by the Popup-
MenuListener method to which it is passed.
public class PopupMenuEvent extends java.util.EventObject {
// Public Constructors
public PopupMenuEvent(Object source);
}
javax.swing.
event
javax.swing.event.PopupMenuEvent
Chapter 26 – The javax.swing.event Package
543

Hierar chy: Object→java.util.EventObject(Serializable)→PopupMenuEvent
Passed To: PopupMenuListener.{popupMenuCanceled(), popupMenuWillBecomeInvisible(),
popupMenuW illBecomeVisible()}
PopupMenuListener
Ja va 1.2
javax.swing .event
event listener
This interface deﬁnes the methods that an object must implement to receive notiﬁca-
tions that a JPopupMenu is about to pop up or pop down or that a JPopupMenu was can-
celed without a user selection.
public abstract interface PopupMenuListener extends java.util.EventListener {
// Public Instance Methods
public abstract void popupMenuCanceled(PopupMenuEvent e);
public abstract void popupMenuW illBecomeInvisible(PopupMenuEvent e);
public abstract void popupMenuW illBecomeVisible(PopupMenuEvent e);
}
Hierar chy: (PopupMenuListener(java.util.EventListener))
Passed To: JPopupMenu.{addPopupMenuListener(), removePopupMenuListener()}
SwingProper tyChangeSuppor t
Ja va 1.2
javax.swing .event
serializable
This utility class is useful when you are deﬁning a Swing component that has bound
pr operties and must ﬁre java.beans.Proper tyChangeEvent events when the value of various
pr operties change. This class is a subclass of java.beans.Proper tyChangeSuppor t and pro-
vides the same features as that class. This Swing-speciﬁc version is somewhat more
memory efﬁcient than the JavaBeans version and does not use synchronized methods.
public ﬁnal class SwingProper tyChangeSuppor t extends java.beans.PropertyChangeSuppor t {
// Public Constructors
public SwingProper tyChangeSuppor t(Object sourceBean);
// Event Registration Methods (by event name)
Overrides:Proper tyChangeSuppor t synchronized
public void addProper tyChangeListener(
java.beans.Proper tyChangeListener listener);
Overrides:Proper tyChangeSuppor t synchronized
public void removeProper tyChangeListener(
java.beans.Proper tyChangeListener listener);
// Public Methods Overriding PropertyChangeSuppor t
synchronized
public void addProper tyChangeListener(String proper tyName,
java.beans.Proper tyChangeListener listener);
public void ﬁreProper tyChange(java.beans.Proper tyChangeEvent evt);
public void ﬁreProper tyChange(String proper tyName, Object oldValue, Object newValue);
synchronized
public boolean hasListeners(String proper tyName);
synchronized
public void removeProper tyChangeListener(String proper tyName,
java.beans.Proper tyChangeListener listener);
}
Hierar chy: Object→java.beans.Proper tyChangeSuppor t(Serializable)→SwingProper tyChangeSuppor t
Type Of: AbstractAction.changeSuppor t, javax.swing .tree.DefaultTreeSelectionModel.changeSuppor t
TableColumnModelEvent
Ja va 1.2
javax.swing .event
serializable event
An event of this type is generated when a column is added, deleted, or moved from a
javax.swing .table.TableColumnModel. The inherited getSource() method retur ns the TableColumn-
Model object that was changed. When a column is added, getToIndex() speciﬁes the index
javax.swing.event.PopupMenuEvent
544 Chapter 26 – The javax.swing.event Package

of the column. When a column is removed, getFromIndex() speciﬁes the index that it
used to occupy. When a column is moved, getFromIndex() retur ns the column’s old posi-
tion and getToIndex() retur ns the column’s new position.
public class TableColumnModelEvent extends java.util.EventObject {
// Public Constructors
public TableColumnModelEvent(javax.swing .table.TableColumnModel source, int from, int to);
// Public Instance Methods
public int getFromIndex();
public int getToIndex();
// Protected Instance Fields
protected int fromIndex;
protected int toIndex;
}
Hierar chy: Object→java.util.EventObject(Serializable)→TableColumnModelEvent
Passed To: JTable.{columnAdded(), columnMoved(), columnRemoved()},
JTable.AccessibleJTable.{columnAdded(), columnMoved(), columnRemoved()},
TableColumnModelListener.{columnAdded(), columnMoved(), columnRemoved()},
javax.swing .table.DefaultTableColumnModel.{fireColumnAdded(), fireColumnMoved(), fireColumnRemoved()},
javax.swing .table.JTableHeader.{columnAdded(), columnMoved(), columnRemoved()}
TableColumnModelListener
Ja va 1.2
javax.swing .event
event listener
This interface deﬁnes the methods that an object must implement to receive notiﬁca-
tions of changes in a javax.swing .table.TableColumnModel. Note that unlike most event listen-
ers, the methods of this object are passed differ ent types of event objects.
public abstract interface TableColumnModelListener extends java.util.EventListener {
// Public Instance Methods
public abstract void columnAdded(TableColumnModelEvent e);
public abstract void columnMarginChanged(ChangeEvent e);
public abstract void columnMoved(TableColumnModelEvent e);
public abstract void columnRemoved(TableColumnModelEvent e);
public abstract void columnSelectionChanged(ListSelectionEvent e);
}
Hierar chy: (TableColumnModelListener(java.util.EventListener))
Implementations: JTable, JTable.AccessibleJTable, javax.swing .table.JTableHeader
Passed To: javax.swing .table.DefaultTableColumnModel.{addColumnModelListener(),
removeColumnModelListener()}, javax.swing .table.TableColumnModel.{addColumnModelListener(),
removeColumnModelListener()}
TableModelEvent
Ja va 1.2
javax.swing .event
serializable event
An event of this type is generated by a javax.swing .table.TableModel when the data it con-
tains changes. getColumn() indicates the column that changed; it may retur n the constant
ALL_COLUMNS. getF irstRow() and getLastRow() get the range of modiﬁed rows. If either
retur ns the constant HEADER_ROW, that indicates that the entire structur e of the table has
changed along with the table data. getType() speciﬁes the type of the change; it retur ns
one of the constants DELETE, INSERT, or UPDATE. The inherited getSource() method retur ns
the modiﬁed TableModel object.
public class TableModelEvent extends java.util.EventObject {
// Public Constructors
javax.swing.
event
javax.swing.event.TableModelEvent
Chapter 26 – The javax.swing.event Package
545

public TableModelEvent(javax.swing .table.TableModel source);
public TableModelEvent(javax.swing .table.TableModel source, int row);
public TableModelEvent(javax.swing .table.TableModel source, int ﬁrstRow, int lastRow);
public TableModelEvent(javax.swing .table.TableModel source, int ﬁrstRow, int lastRow, int column);
public TableModelEvent(javax.swing .table.TableModel source, int ﬁrstRow, int lastRow, int column, int type);
// Public Constants
=-1
public static ﬁnal int ALL_COLUMNS;
=-1
public static ﬁnal int DELETE;
=-1
public static ﬁnal int HEADER_ROW;
=1
public static ﬁnal int INSERT;
=0
public static ﬁnal int UPDATE;
// Property Accessor Methods (by property name)
public int getColumn();
public int getF irstRow();
public int getLastRow();
public int getType();
// Protected Instance Fields
protected int column;
protected int ﬁrstRow;
protected int lastRow;
protected int type;
}
Hierar chy: Object→java.util.EventObject(Serializable)→TableModelEvent
Passed To: JTable.tableChanged(), JTable.AccessibleJTable.{tableChanged(), tableRowsDeleted(),
tableRowsInser ted()}, TableModelListener.tableChanged(),
javax.swing .table.AbstractTableModel.fireTableChanged(),
javax.swing .table.DefaultTableModel.{newDataAvailable(), newRowsAdded(), rowsRemoved()}
TableModelListener
Ja va 1.2
javax.swing .event
event listener
This interface deﬁnes the method that an object must implement to receive notiﬁcations
about changes to the state of a javax.swing .table.TableModel.
public abstract interface TableModelListener extends java.util.EventListener {
// Public Instance Methods
public abstract void tableChanged(TableModelEvent e);
}
Hierar chy: (TableModelListener(java.util.EventListener))
Implementations: JTable, JTable.AccessibleJTable
Passed To: javax.swing .table.AbstractTableModel.{addTableModelListener(), removeTableModelListener()},
javax.swing .table.TableModel.{addTableModelListener(), removeTableModelListener()}
TreeExpansionEvent
Ja va 1.2
javax.swing .event
serializable event
An event of this type is generated by a JTree component when a node in the tree is
expanded or collapsed. The inherited getSource() method retur ns the JTree component,
and getPath() retur ns a TreePath that speciﬁes which node was expanded or collapsed.
public class TreeExpansionEvent extends java.util.EventObject {
// Public Constructors
public TreeExpansionEvent(Object source, javax.swing .tree.TreePath path);
// Public Instance Methods
javax.swing.event.TableModelEvent
546 Chapter 26 – The javax.swing.event Package

public javax.swing.tree.TreePath getPath();
// Protected Instance Fields
protected javax.swing.tree.TreePath path;
}
Hierar chy: Object→java.util.EventObject(Serializable)→TreeExpansionEvent
Passed To: JTree.AccessibleJTree.{treeCollapsed(), treeExpanded()}, TreeExpansionListener.{treeCollapsed(),
treeExpanded()}, TreeW illExpandListener.{treeW illCollapse(), treeW illExpand()},
javax.swing .tree.ExpandVetoException.ExpandVetoException()
Type Of: javax.swing .tree.ExpandVetoException.event
TreeExpansionListener
Ja va 1.2
javax.swing .event
event listener
This interface deﬁnes the methods that an object must implement to be notiﬁed when a
JTree component expands or collapses a node.
public abstract interface TreeExpansionListener extends java.util.EventListener {
// Public Instance Methods
public abstract void treeCollapsed(T reeExpansionEvent event);
public abstract void treeExpanded(T reeExpansionEvent event);
}
Hierar chy: (TreeExpansionListener(java.util.EventListener))
Implementations: JTree.AccessibleJTree
Passed To: JTree.{addTreeExpansionListener(), removeTreeExpansionListener()}
TreeModelEvent
Ja va 1.2
javax.swing .event
serializable event
An event of this type is generated when the contents of a java.awt.event.tree.TreeModel
change. The inherited getSource() method retur ns the TreeModel object that was changed.
getPath() and getTreePath() specify the path to the parent of the changed nodes.
getChildIndices() retur ns an array of integers that speciﬁes which children of that parent
node have changed. Alternatively, getChildren() retur ns the modiﬁed children directly.
TreeModelEvent does not directly indicate what type of change has occurred; that is deter-
mined by the TreeModelListener method to which the TreeModelEvent is passed.
public class TreeModelEvent extends java.util.EventObject {
// Public Constructors
public TreeModelEvent(Object source, Object[ ] path);
public TreeModelEvent(Object source, javax.swing .tree.TreePath path);
public TreeModelEvent(Object source, javax.swing .tree.TreePath path, int[ ] childIndices, Object[ ] children);
public TreeModelEvent(Object source, Object[ ] path, int[ ] childIndices, Object[ ] children);
// Property Accessor Methods (by property name)
public int[ ] getChildIndices();
public Object[ ] getChildren();
public Object[ ] getPath();
public javax.swing.tree.TreePath getTreePath();
// Public Methods Overriding EventObject
public String toString();
// Protected Instance Fields
protected int[ ] childIndices;
protected Object[ ] children;
javax.swing.
event
javax.swing.event.TreeModelEvent
Chapter 26 – The javax.swing.event Package
547

protected javax.swing.tree.TreePath path;
}
Hierar chy: Object→java.util.EventObject(Serializable)→TreeModelEvent
Passed To: Too many methods to list.
TreeModelListener
Ja va 1.2
javax.swing .event
event listener
This interface deﬁnes the methods that an object must implement to receive notiﬁca-
tions of changes to a javax.swing .tree.TreeModel.
public abstract interface TreeModelListener extends java.util.EventListener {
// Public Instance Methods
public abstract void treeNodesChanged(T reeModelEvent e);
public abstract void treeNodesInser ted(T reeModelEvent e);
public abstract void treeNodesRemoved(T reeModelEvent e);
public abstract void treeStr uctureChanged(T reeModelEvent e);
}
Hierar chy: (TreeModelListener(java.util.EventListener))
Implementations: JTree.AccessibleJTree, JTree.TreeModelHandler
Passed To: javax.swing .tree.DefaultTreeModel.{addTreeModelListener(), removeTreeModelListener()},
javax.swing .tree.TreeModel.{addTreeModelListener(), removeTreeModelListener()}
Retur ned By: JTree.createTreeModelListener()
Type Of: JTree.treeModelListener
TreeSelectionEvent
Ja va 1.2
javax.swing .event
serializable event
An event of this type is generated by a javax.swing .tree.TreeSelectionModel or by the JTree
component that uses that model when the selection state of the tree changes. getPaths()
retur ns the array of javax.swing .tree.TreePath objects that were added to or removed from
the selection. getPath() retur ns the ﬁrst element of this array. The one-argument version
of isAddedPath() tests whether a speciﬁed TreePath (it must be one of the ones retur ned
by getPaths()) was added to the selection (tr ue) or removed from it (false). The no-argu-
ment version of this method tests whether the value retur ned by getPath() was selected
or deselected.
public class TreeSelectionEvent extends java.util.EventObject {
// Public Constructors
public TreeSelectionEvent(Object source, javax.swing .tree.TreePath[ ] paths, boolean[ ] areNew,
javax.swing .tree.TreePath oldLeadSelectionPath,
javax.swing .tree.TreePath newLeadSelectionPath);
public TreeSelectionEvent(Object source, javax.swing .tree.TreePath path, boolean isNew,
javax.swing .tree.TreePath oldLeadSelectionPath,
javax.swing .tree.TreePath newLeadSelectionPath);
// Property Accessor Methods (by property name)
public boolean isAddedPath();
public boolean isAddedPath(javax.swing .tree.TreePath path);
public javax.swing.tree.TreePath getNewLeadSelectionPath();
public javax.swing.tree.TreePath getOldLeadSelectionPath();
public javax.swing.tree.TreePath getPath();
public javax.swing.tree.TreePath[ ] getPaths();
// Public Instance Methods
javax.swing.event.TreeModelEvent
548 Chapter 26 – The javax.swing.event Package

public Object cloneW ithSource(Object newSource);
// Protected Instance Fields
protected boolean[ ] areNew;
protected javax.swing.tree.TreePath newLeadSelectionPath;
protected javax.swing.tree.TreePath oldLeadSelectionPath;
protected javax.swing.tree.TreePath[ ] paths;
}
Hierar chy: Object→java.util.EventObject(Serializable)→TreeSelectionEvent
Passed To: JTree.fireValueChanged(), JTree.AccessibleJTree.valueChanged(),
JTree.TreeSelectionRedirector.valueChanged(), TreeSelectionListener.valueChanged(),
javax.swing .tree.DefaultTreeCellEditor.valueChanged(),
javax.swing .tree.DefaultTreeSelectionModel.fireValueChanged()
TreeSelectionListener
Ja va 1.2
javax.swing .event
event listener
This interface deﬁnes the method that an object must implement to receive notiﬁcations
about changes to the selection state of a javax.swing .tree.TreeSelectionModel object or JTree
component.
public abstract interface TreeSelectionListener extends java.util.EventListener {
// Public Instance Methods
public abstract void valueChanged(T reeSelectionEvent e);
}
Hierar chy: (TreeSelectionListener(java.util.EventListener))
Implementations: JTree.AccessibleJTree, JTree.TreeSelectionRedirector,
javax.swing .tree.DefaultTreeCellEditor
Passed To: JTree.{addTreeSelectionListener(), removeTreeSelectionListener()},
javax.swing .tree.DefaultTreeSelectionModel.{addTreeSelectionListener(), removeTreeSelectionListener()},
javax.swing .tree.TreeSelectionModel.{addTreeSelectionListener(), removeTreeSelectionListener()}
TreeW illExpandListener
Ja va 1.2
javax.swing .event
event listener
This interface deﬁnes the methods that JTree invokes on register ed listeners immediately
befor e it expands or collapses a node. Do not confuse this interface with TreeExpansion-
Listener, which is notiﬁed immediately after a node is expanded or collapsed. Both lis-
teners share the same TreeExpansionEvent event type, however. Note that the methods of
this interface can throw an ExpandVetoException to veto the proposed expansion or col-
lapse of the node.
public abstract interface TreeW illExpandListener extends java.util.EventListener {
// Public Instance Methods
public abstract void treeW illCollapse(T reeExpansionEvent event) throws javax.swing.tree.ExpandVetoException;
public abstract void treeW illExpand(T reeExpansionEvent event) throws javax.swing.tree.ExpandVetoException;
}
Hierar chy: (TreeW illExpandListener(java.util.EventListener))
Passed To: JTree.{addTreeW illExpandListener(), removeTreeW illExpandListener()}
javax.swing.
event
javax.swing.event.TreeWillExpandListener
Chapter 26 – The javax.swing.event Package
549

UndoableEditEvent
Ja va 1.2
javax.swing .event
serializable event
An event of this type is generated by a javax.swing .text.Document when an undoable edit
has occurred. The inherited getSource() method retur ns the Document object on which the
edit occurred, and getEdit() retur ns a description of the edit itself.
public class UndoableEditEvent extends java.util.EventObject {
// Public Constructors
public UndoableEditEvent(Object source, javax.swing .undo.UndoableEdit edit);
// Public Instance Methods
public javax.swing.undo.UndoableEdit getEdit();
}
Hierar chy: Object→java.util.EventObject(Serializable)→UndoableEditEvent
Passed To: UndoableEditListener.undoableEditHappened(),
javax.swing .text.AbstractDocument.fireUndoableEditUpdate(),
javax.swing .text.html.HTMLDocument.fireUndoableEditUpdate(),
javax.swing .undo.UndoManager.undoableEditHappened()
UndoableEditListener
Ja va 1.2
javax.swing .event
event listener
This interface deﬁnes the method that an object must implement in order to receive
notiﬁcations when an undoable edit occurs in a javax.swing .text.Document.
public abstract interface UndoableEditListener extends java.util.EventListener {
// Public Instance Methods
public abstract void undoableEditHappened(UndoableEditEvent e);
}
Hierar chy: (UndoableEditListener(java.util.EventListener))
Implementations: javax.swing .undo.UndoManager
Passed To: javax.swing .text.AbstractDocument.{addUndoableEditListener(), removeUndoableEditListener()},
javax.swing .text.Document.{addUndoableEditListener(), removeUndoableEditListener()},
javax.swing .undo.UndoableEditSupport.{addUndoableEditListener(), removeUndoableEditListener()}
javax.swing.event.UndoableEditEvent
550 Chapter 26 – The javax.swing.event Package

CHAPTER 27
The javax.swing.ﬁlechooser Package
The javax.swing .ﬁlechooser package deﬁnes auxiliary classes used by the javax.-
swing .JFileChooser component. You can customize the behavior of a JF ileChooser by
deﬁning concrete subclasses of these abstract classes. Deﬁne a FileF ilter to specify
what ﬁles should be displayed by the JF ileChooser. Deﬁne a FileV iew to specify how
it should display those classes. And deﬁne a FileSystemV iew to specify how it should
traverse the ﬁle system. Figure 27-1 shows the class hierarchy of this package.
ABSTRACT CLASS
extends
KEY
CLASS
javax.swing.filechooser
java.lang
Object
FileFilter
FileSystemView
FileView
Figur e 27−1: The javax.swing.ﬁlechooser package
FileF ilter
Ja va 1.2
javax.swing .filechooser
This abstract class deﬁnes the methods used by the JF ileChooser component to select a
subset of ﬁles for display. When the accept() method is passed a File object, it should
retur n tr ue if that ﬁle should be displayed by the JF ileChooser and false otherwise. accept()
often makes its determination based on the ﬁlename extension, but it can also take
other factors into account, such as the readability and writability of the ﬁle. The getDe-
scription() method must retur n a human-r eadable description (preferably localized for
the current locale) of the ﬁltering operation perfor med by the ﬁlter. For example, if a
javax.swing.
filechooser
551

FileF ilter accepts ﬁles that end with extensions .gif, .jpg, and .png, the getDescription()
method might retur n the string Image ﬁles.
Once you have created a FileF ilter, you can tell a JF ileChooser to use it by passing the ﬁl-
ter to the setF ileF ilter() method. If you want to allow the user to choose among a set of
ﬁle ﬁlters, pass the FileF ilter objects to the addChooseableF ileF ilter() method of JF ileChooser.
Do not confuse javax.swing .ﬁlechooser.F ileF ilter with its less-powerful relative, java.io.F ile-
nameF ilter.
public abstract class FileF ilter {
// Public Constructors
public FileF ilter();
// Public Instance Methods
public abstract boolean accept(java.io.F ile f);
public abstract String getDescription();
}
Passed To: JF ileChooser.{addChoosableF ileF ilter(), removeChoosableF ileF ilter(), setF ileF ilter()}
Retur ned By: JF ileChooser.{getAcceptAllF ileF ilter(), getChoosableF ileF ilters(), getF ileF ilter()},
javax.swing .plaf.FileChooserUI.getAcceptAllF ileF ilter()
FileSystemV iew
Ja va 1.2
javax.swing .filechooser
FileSystemV iew abstracts the system dependencies of the native ﬁlesystem and provides a
platfor m-independent view of the ﬁlesystem for the JF ileChooser component. As of Java
1.2, the features of FileSystemV iew ar e pr ovided dir ectly by the java.io.F ile class, so this
class exists for portability to Java 1.1 systems.
You can obtain the FileSystemV iew object for the current platform by calling the static get-
FileSystemV iew() method. The getRoots() method retur ns a list of root directories for the
system. For Unix systems, there is only one, the / dir ectory. On Windows systems, how-
ever, ther e is a root directory for each active drive letter. Use getHomeDirector y() to obtain
a user’s home directory on systems that have such a concept. Use isHiddenF ile() to deter-
mine if a ﬁle is a hidden ﬁle according to the conventions of the native platform. Use
getF iles() to list the contents of a directory, optionally omitting hidden ﬁles.
public abstract class FileSystemV iew {
// Public Constructors
public FileSystemV iew();
// Public Class Methods
public static FileSystemV ie w getF ileSystemV iew();
// Property Accessor Methods (by property name)
public java.io.File getHomeDirector y();
public abstract java.io.File[ ] getRoots();
// Public Instance Methods
public java.io.File createF ileObject(String path);
public java.io.File createF ileObject(java.io.F ile dir, String ﬁlename);
public abstract java.io.File createNewFolder(java.io.F ile containingDir) throws java.io.IOException;
public java.io.File[ ] getF iles(java.io.F ile dir, boolean useF ileHiding);
public java.io.File getParentDirector y(java.io.F ile dir);
public abstract boolean isHiddenF ile(java.io.F ile f);
public abstract boolean isRoot(java.io.F ile f);
}
Passed To: JF ileChooser.{JF ileChooser(), setF ileSystemV iew(), setup()}
Retur ned By: JF ileChooser.getF ileSystemV iew(), FileSystemV iew.getF ileSystemV iew()
javax.swing.filechooser.FileFilter
552 Chapter 27 – The javax.swing.filechooser Package

FileV iew
Ja va 1.2
javax.swing .filechooser
This abstract class deﬁnes methods that the JF ileChooser component uses to obtain infor-
mation about how it should display a ﬁle. JF ileChooser uses a FileV iew object provided by
the current look-and-feel implementation to provide such things as the default icons for
ﬁles and directories. You can implement your own FileV iew object to override some or
all of the default behavior of the FileV iew pr ovided by a look-and-feel. To do so, pass
your FileV iew to the setF ileV iew() method of the JF ileChooser. The JF ileChooser always
queries your FileV iew object ﬁrst, but when any of your methods retur n null, it calls the
corr esponding method of the look-and-feel FileV iew. By far, the most common reason to
cr eate a custom FileV iew class is to implement the getIcon() method to retur n custom
icons for speciﬁc types of ﬁles. The other methods of FileV iew ar e not so commonly
used.
public abstract class FileV iew {
// Public Constructors
public FileV iew();
// Public Instance Methods
public abstract String getDescription(java.io.F ile f);
public abstract Icon getIcon(java.io.F ile f);
public abstract String getName(java.io.F ile f);
public abstract String getTypeDescription(java.io.F ile f);
public abstract Boolean isTraversable(java.io.F ile f);
}
Passed To: JF ileChooser.setF ileV iew()
Retur ned By: JF ileChooser.getF ileV iew(), javax.swing .plaf.FileChooserUI.getF ileV iew()
javax.swing.
filechooser
javax.swing.filechooser.FileView
Chapter 27 – The javax.swing.filechooser Package
553

CHAPTER 28
The javax.swing.plaf Package
This package contains classes and interfaces used in the deﬁnition of a pluggable
look-and-feel (hence the acronym “plaf”). It deﬁnes abstract UI delegate classes for
Swing components. Typically, only look-and-feel developers and advanced com-
ponent developers need to use this package. Figure 28-1 shows the class hierarchy
of this package. See Chapter 3, Swing Programming Topics, for further discussion
of Swing’s pluggable look-and-feel architectur e.
The javax.swing .plaf.basic package contains classes that extend the UI delegate
classes of this package to create a basic pluggable look-and-feel UI framework.
The classes in javax.swing .plaf.metal extend the classes of javax.swing .plaf.basic to
implement the default Java look-and-feel. The classes in javax.swing .plaf.multi also
extend the abstract classes of javax.swing .plaf to produce a multiplexing look-and-
feel that combines a primary look-and-feel with one or more auxiliary look-and-
feel implementations. These various subpackages of javax.swing .plaf ar e not docu-
mented in this book because they are very infrequently used and because they are
straightforward implementations of the classes in this package that do not deﬁne
any new public APIs.
BorderUIResource
Ja va 1.2
javax.swing .plaf
serializable
This class implements the UIResource marker interface and serves as a wrapper around
an existing javax.swing .border.Border object. It differs from other UIResource implementa-
tions in this package, in that it does not subclass an existing resource type. In addition,
this class includes inner classes that provide UIResource versions of the standard Swing
border classes. Several static methods exist for obtaining shared instances of commonly
used UIResource borders.
public class BorderUIResource implements javax.swing.border.Border, Serializable, UIResource {
// Public Constructors
public BorderUIResource(javax.swing .border.Border delegate);
// Inner Classes
public static class BevelBorderUIResource extends javax.swing.border.Be velBorder implements UIResource;
554

CLASS
INTERFACE
ABSTRACT CLASS
KEY
extends
implements
javax.swing.plaf
java.lang
Object
javax.swing
java.awt
ComponentUI
ButtonUI
MenuItemUI
BorderUIResource
IconUIResource
ColorUIResource
DimensionUIResource
FontUIResource
InsetsUIResource
UIResource
ColorChooserUI
ComboBoxUI
DesktopIconUI
FileChooserUI
InternalFrameUI
LabelUI
ListUI
MenuBarIU
OptionPaneUI
PanelUI
PopupMenuUI
ProgressBarUI
ScrollBarUI
ScrollPaneUI
SeparatorUI
SliderUI
SplitPaneUI
TabbedPaneUI
TableHeaderUI
TableUI
TextUI
ToolBarUI
ToolTipUI
TreeUI
ViewportUI
javax.swing.border
java.io
Serializable
Border
Icon
Color
Dimension
Font
Insets
Figur e 28−1: The javax.swing.plaf package
public static class CompoundBorderUIResource extends javax.swing.border.CompoundBorder
implements UIResource;
public static class EmptyBorderUIResource extends javax.swing.border.EmptyBorder implements UIResource;
public static class EtchedBorderUIResource extends javax.swing.border.EtchedBorder implements UIResource;
public static class LineBorderUIResource extends javax.swing.border.LineBorder implements UIResource;
public static class MatteBorderUIResource extends javax.swing.border.MatteBorder implements UIResource;
public static class TitledBorderUIResource extends javax.swing.border.T itledBorder implements UIResource;
// Public Class Methods
public static javax.swing.border.Border getBlackLineBorderUIResource();
public static javax.swing.border.Border getEtchedBorderUIResource();
javax.swing.
plaf
javax.swing.plaf.BorderUIResour ce
Chapter 28 – The javax.swing.plaf Package
555

public static javax.swing.border.Border getLoweredBevelBorderUIResource();
public static javax.swing.border.Border getRaisedBevelBorderUIResource();
// Methods Implementing Border
public java.awt.Insets getBorderInsets(Component c);
public boolean isBorderOpaque();
public void paintBorder(Component c, java.awt.Graphics g, int x, int y, int width, int height);
}
BorderUIResource.BevelBorderUIResource
Ja va 1.2
javax.swing .plaf
serializable
A trivial subclass of BevelBorder that implements the UIResource marker interface.
public static class BorderUIResource.BevelBorderUIResource extends javax.swing.border.Be velBorder
implements UIResource {
// Public Constructors
public BevelBorderUIResource(int bevelType);
public BevelBorderUIResource(int bevelType, java.awt.Color highlight, java.awt.Color shadow);
public BevelBorderUIResource(int bevelType, java.awt.Color highlightOuter, java.awt.Color highlightInner,
java.awt.Color shadowOuter, java.awt.Color shadowInner);
}
BorderUIResource.CompoundBorderUIResource
Ja va 1.2
javax.swing .plaf
serializable
A trivial subclass of CompoundBorder that implements the UIResource marker interface.
public static class BorderUIResource.CompoundBorderUIResource extends
javax.swing .border.CompoundBorder implements UIResource {
// Public Constructors
public CompoundBorderUIResource(javax.swing .border.Border outsideBorder,
javax.swing .border.Border insideBorder);
}
BorderUIResource.EmptyBorderUIResource
Ja va 1.2
javax.swing .plaf
serializable
A trivial subclass of EmptyBorder that implements the UIResource marker interface.
public static class BorderUIResource.EmptyBorderUIResource extends javax.swing.border.EmptyBorder
implements UIResource {
// Public Constructors
public EmptyBorderUIResource(java.awt.Insets insets);
public EmptyBorderUIResource(int top, int left, int bottom, int right);
}
BorderUIResource.EtchedBorderUIResource
Ja va 1.2
javax.swing .plaf
serializable
A trivial subclass of EtchedBorder that implements the UIResource marker interface.
public static class BorderUIResource.EtchedBorderUIResource extends javax.swing.border.EtchedBorder
implements UIResource {
// Public Constructors
public EtchedBorderUIResource();
public EtchedBorderUIResource(int etchType);
public EtchedBorderUIResource(java.awt.Color highlight, java.awt.Color shadow);
javax.swing.plaf.BorderUIResour ce
556 Chapter 28 – The javax.swing.plaf Package

public EtchedBorderUIResource(int etchType, java.awt.Color highlight, java.awt.Color shadow);
}
BorderUIResource.LineBorderUIResource
Ja va 1.2
javax.swing .plaf
serializable
A trivial subclass of LineBorder that implements the UIResource marker interface.
public static class BorderUIResource.LineBorderUIResource extends javax.swing.border.LineBorder
implements UIResource {
// Public Constructors
public LineBorderUIResource(java.awt.Color color);
public LineBorderUIResource(java.awt.Color color, int thickness);
}
BorderUIResource.MatteBorderUIResource
Ja va 1.2
javax.swing .plaf
serializable
A trivial subclass of MatteBorder that implements the UIResource marker interface.
public static class BorderUIResource.MatteBorderUIResource extends javax.swing.border.MatteBorder
implements UIResource {
// Public Constructors
public MatteBorderUIResource(Icon tileIcon);
public MatteBorderUIResource(int top, int left, int bottom, int right, Icon tileIcon);
public MatteBorderUIResource(int top, int left, int bottom, int right, java.awt.Color color);
}
BorderUIResource.T itledBorderUIResource
Ja va 1.2
javax.swing .plaf
serializable
A trivial subclass of TitledBorder that implements the UIResource marker interface.
public static class BorderUIResource.T itledBorderUIResource extends javax.swing.border.T itledBorder
implements UIResource {
// Public Constructors
public TitledBorderUIResource(javax.swing .border.Border border);
public TitledBorderUIResource(String title);
public TitledBorderUIResource(javax.swing .border.Border border, String title);
public TitledBorderUIResource(javax.swing .border.Border border, String title, int titleJustiﬁcation,
int titlePosition);
public TitledBorderUIResource(javax.swing .border.Border border, String title, int titleJustiﬁcation,
int titlePosition, java.awt.Font titleFont);
public TitledBorderUIResource(javax.swing .border.Border border, String title, int titleJustiﬁcation,
int titlePosition, java.awt.Font titleFont, java.awt.Color titleColor);
}
ButtonUI
Ja va 1.2
javax.swing .plaf
This abstract class deﬁnes the methods that must be implemented by a pluggable look-
and-feel delegate for JButton.
public abstract class ButtonUI extends ComponentUI {
// Public Constructors
public ButtonUI();
}
javax.swing.
plaf
javax.swing.plaf.ButtonUI
Chapter 28 – The javax.swing.plaf Package
557

Subc lasses: MenuItemUI
Passed To: AbstractButton.setUI()
Retur ned By: AbstractButton.getUI()
ColorChooserUI
Ja va 1.2
javax.swing .plaf
This abstract class deﬁnes the methods that must be implemented by a pluggable look-
and-feel delegate for JColorChooser.
public abstract class ColorChooserUI extends ComponentUI {
// Public Constructors
public ColorChooserUI();
}
Passed To: JColorChooser.setUI()
Retur ned By: JColorChooser.getUI()
ColorUIResource
Ja va 1.2
javax.swing .plaf
serializable
A trivial subclass of java.awt.Color that implements the UIResource marker interface.
public class ColorUIResource extends java.awt.Color implements UIResource {
// Public Constructors
public ColorUIResource(java.awt.Color c);
public ColorUIResource(int rgb);
public ColorUIResource(ﬂoat r, ﬂoat g, ﬂoat b);
public ColorUIResource(int r, int g, int b);
}
ComboBoxUI
Ja va 1.2
javax.swing .plaf
This abstract class deﬁnes the methods that must be implemented by a pluggable look-
and-feel delegate for JComboBox.
public abstract class ComboBoxUI extends ComponentUI {
// Public Constructors
public ComboBoxUI();
// Public Instance Methods
public abstract boolean isFocusTraversable(JComboBox c);
public abstract boolean isPopupV isible(JComboBox c);
public abstract void setPopupV isible(JComboBox c, boolean v);
}
Passed To: JComboBox.setUI()
Retur ned By: JComboBox.getUI()
ComponentUI
Ja va 1.2
javax.swing .plaf
This abstract class deﬁnes the methods that must be implemented by a pluggable look-
and-feel delegate for JComponent.
javax.swing.plaf.ButtonUI
558 Chapter 28 – The javax.swing.plaf Package

public abstract class ComponentUI {
// Public Constructors
public ComponentUI();
// Public Class Methods
public static ComponentUI createUI(JComponent c);
// Public Instance Methods
public boolean contains(JComponent c, int x, int y);
public Accessible getAccessibleChild(JComponent c, int i);
public int getAccessibleChildrenCount(JComponent c);
public java.awt.Dimension getMaximumSize(JComponent c);
public java.awt.Dimension getMinimumSize(JComponent c);
constant
public java.awt.Dimension getPrefer redSize(JComponent c);
empty
public void installUI(JComponent c);
empty
public void paint(java.awt.Graphics g, JComponent c);
empty
public void uninstallUI(JComponent c);
public void update(java.awt.Graphics g, JComponent c);
}
Subc lasses: Too many classes to list.
Passed To: JComponent.setUI()
Retur ned By: UIDefaults.getUI(), UIManager.getUI(), ComponentUI.createUI()
Type Of: JComponent.ui
DesktopIconUI
Ja va 1.2
javax.swing .plaf
This abstract class deﬁnes the methods that must be implemented by a pluggable look-
and-feel delegate for JDesktopIcon.
public abstract class DesktopIconUI extends ComponentUI {
// Public Constructors
public DesktopIconUI();
}
Passed To: JInter nalFrame.JDesktopIcon.setUI()
Retur ned By: JInter nalFrame.JDesktopIcon.getUI()
DesktopPaneUI
Ja va 1.2
javax.swing .plaf
This abstract class deﬁnes the methods that must be implemented by a pluggable look-
and-feel delegate for JDesktopPane.
public abstract class DesktopPaneUI extends ComponentUI {
// Public Constructors
public DesktopPaneUI();
}
Passed To: JDesktopPane.setUI()
Retur ned By: JDesktopPane.getUI()
DimensionUIResource
Ja va 1.2
javax.swing .plaf
cloneable serializable
A trivial subclass of java.awt.Dimension that implements the UIResource marker interface.
javax.swing.
plaf
javax.swing.plaf.DimensionUIResour ce
Chapter 28 – The javax.swing.plaf Package
559

public class DimensionUIResource extends java.awt.Dimension implements UIResource {
// Public Constructors
public DimensionUIResource(int width, int height);
}
FileChooserUI
Ja va 1.2
javax.swing .plaf
This abstract class deﬁnes the methods that must be implemented by a pluggable look-
and-feel delegate for JF ileChooser.
public abstract class FileChooserUI extends ComponentUI {
// Public Constructors
public FileChooserUI();
// Public Instance Methods
public abstract void ensureF ileIsV isible(JFileChooser fc, java.io.F ile f);
public abstract javax.swing.ﬁlechooser.F ileF ilter getAcceptAllF ileF ilter(JFileChooser fc);
public abstract String getApproveButtonText(JFileChooser fc);
public abstract String getDialogT itle(JFileChooser fc);
public abstract javax.swing.ﬁlechooser.F ileV ie w getF ileV iew(JFileChooser fc);
public abstract void rescanCur rentDirectory(JFileChooser fc);
}
Retur ned By: JF ileChooser.getUI()
FontUIResource
Ja va 1.2
javax.swing .plaf
serializable
A trivial subclass of java.awt.Font that implements the UIResource marker interface.
public class FontUIResource extends java.awt.Font implements UIResource {
// Public Constructors
public FontUIResource(java.awt.Font font);
public FontUIResource(String name, int style, int size);
}
IconUIResource
Ja va 1.2
javax.swing .plaf
serializable
A trivial subclass of javax.swing .Icon that implements the UIResource marker interface.
public class IconUIResource implements Icon, Serializable, UIResource {
// Public Constructors
public IconUIResource(Icon delegate);
// Methods Implementing Icon
public int getIconHeight();
public int getIconW idth();
public void paintIcon(Component c, java.awt.Graphics g, int x, int y);
}
InsetsUIResource
Ja va 1.2
javax.swing .plaf
cloneable serializable
A trivial subclass of java.awt.Insets that implements the UIResource marker interface.
javax.swing.plaf.DimensionUIResour ce
560 Chapter 28 – The javax.swing.plaf Package

public class InsetsUIResource extends java.awt.Insets implements UIResource {
// Public Constructors
public InsetsUIResource(int top, int left, int bottom, int right);
}
Inter nalFrameUI
Ja va 1.2
javax.swing .plaf
This abstract class deﬁnes the methods that must be implemented by a pluggable look-
and-feel delegate for JInter nalFrame.
public abstract class Inter nalFrameUI extends ComponentUI {
// Public Constructors
public Inter nalFrameUI();
}
Passed To: JInter nalFrame.setUI()
Retur ned By: JInter nalFrame.getUI()
LabelUI
Ja va 1.2
javax.swing .plaf
This abstract class deﬁnes the methods that must be implemented by a pluggable look-
and-feel delegate for JLabel.
public abstract class LabelUI extends ComponentUI {
// Public Constructors
public LabelUI();
}
Passed To: JLabel.setUI()
Retur ned By: JLabel.getUI()
ListUI
Ja va 1.2
javax.swing .plaf
This abstract class deﬁnes the methods that must be implemented by a pluggable look-
and-feel delegate for JList.
public abstract class ListUI extends ComponentUI {
// Public Constructors
public ListUI();
// Public Instance Methods
public abstract java.awt.Rectangle getCellBounds(JList list, int index1, int index2);
public abstract java.awt.Point indexToLocation(JList list, int index);
public abstract int locationToIndex(JList list, java.awt.Point location);
}
Passed To: JList.setUI()
Retur ned By: JList.getUI()
MenuBarUI
Ja va 1.2
javax.swing .plaf
This abstract class deﬁnes the methods that must be implemented by a pluggable look-
and-feel delegate for JMenuBar.
javax.swing.
plaf
javax.swing.plaf.MenuBarUI
Chapter 28 – The javax.swing.plaf Package
561

public abstract class MenuBarUI extends ComponentUI {
// Public Constructors
public MenuBarUI();
}
Passed To: JMenuBar.setUI()
Retur ned By: JMenuBar.getUI()
MenuItemUI
Ja va 1.2
javax.swing .plaf
This abstract class deﬁnes the methods that must be implemented by a pluggable look-
and-feel delegate for JMenuItem.
public abstract class MenuItemUI extends ButtonUI {
// Public Constructors
public MenuItemUI();
}
Passed To: JMenuItem.setUI()
OptionPaneUI
Ja va 1.2
javax.swing .plaf
This abstract class deﬁnes the methods that must be implemented by a pluggable look-
and-feel delegate for JOptionPane.
public abstract class OptionPaneUI extends ComponentUI {
// Public Constructors
public OptionPaneUI();
// Public Instance Methods
public abstract boolean containsCustomComponents(JOptionPane op);
public abstract void selectInitialValue(JOptionPane op);
}
Passed To: JOptionPane.setUI()
Retur ned By: JOptionPane.getUI()
PanelUI
Ja va 1.2
javax.swing .plaf
This abstract class deﬁnes the methods that must be implemented by a pluggable look-
and-feel delegate for JPanel.
public abstract class PanelUI extends ComponentUI {
// Public Constructors
public PanelUI();
}
PopupMenuUI
Ja va 1.2
javax.swing .plaf
This abstract class deﬁnes the methods that must be implemented by a pluggable look-
and-feel delegate for JPopupMenu.
javax.swing.plaf.MenuBarUI
562 Chapter 28 – The javax.swing.plaf Package

public abstract class PopupMenuUI extends ComponentUI {
// Public Constructors
public PopupMenuUI();
}
Passed To: JPopupMenu.setUI()
Retur ned By: JPopupMenu.getUI()
ProgressBarUI
Ja va 1.2
javax.swing .plaf
This abstract class deﬁnes the methods that must be implemented by a pluggable look-
and-feel delegate for JProgressBar.
public abstract class ProgressBarUI extends ComponentUI {
// Public Constructors
public ProgressBarUI();
}
Passed To: JProgressBar.setUI()
Retur ned By: JProgressBar.getUI()
ScrollBarUI
Ja va 1.2
javax.swing .plaf
This abstract class deﬁnes the methods that must be implemented by a pluggable look-
and-feel delegate for JScrollBar.
public abstract class ScrollBarUI extends ComponentUI {
// Public Constructors
public ScrollBarUI();
}
Retur ned By: JScrollBar.getUI()
ScrollPaneUI
Ja va 1.2
javax.swing .plaf
This abstract class deﬁnes the methods that must be implemented by a pluggable look-
and-feel delegate for JScrollPane.
public abstract class ScrollPaneUI extends ComponentUI {
// Public Constructors
public ScrollPaneUI();
}
Passed To: JScrollPane.setUI()
Retur ned By: JScrollPane.getUI()
SeparatorUI
Ja va 1.2
javax.swing .plaf
This abstract class deﬁnes the methods that must be implemented by a pluggable look-
and-feel delegate for JSeparator.
javax.swing.
plaf
javax.swing.plaf.SeparatorUI
Chapter 28 – The javax.swing.plaf Package
563

public abstract class SeparatorUI extends ComponentUI {
// Public Constructors
public SeparatorUI();
}
Passed To: JSeparator.setUI()
Retur ned By: JSeparator.getUI()
SliderUI
Ja va 1.2
javax.swing .plaf
This abstract class deﬁnes the methods that must be implemented by a pluggable look-
and-feel delegate for JSlider.
public abstract class SliderUI extends ComponentUI {
// Public Constructors
public SliderUI();
}
Passed To: JSlider.setUI()
Retur ned By: JSlider.getUI()
SplitPaneUI
Ja va 1.2
javax.swing .plaf
This abstract class deﬁnes the methods that must be implemented by a pluggable look-
and-feel delegate for JSplitPane.
public abstract class SplitPaneUI extends ComponentUI {
// Public Constructors
public SplitPaneUI();
// Public Instance Methods
public abstract void ﬁnishedPaintingChildren(JSplitPane jc, java.awt.Graphics g);
public abstract int getDividerLocation(JSplitPane jc);
public abstract int getMaximumDividerLocation(JSplitPane jc);
public abstract int getMinimumDividerLocation(JSplitPane jc);
public abstract void resetToPrefer redSizes(JSplitPane jc);
public abstract void setDividerLocation(JSplitPane jc, int location);
}
Passed To: JSplitPane.setUI()
Retur ned By: JSplitPane.getUI()
TabbedPaneUI
Ja va 1.2
javax.swing .plaf
This abstract class deﬁnes the methods that must be implemented by a pluggable look-
and-feel delegate for JTabbedPane.
public abstract class TabbedPaneUI extends ComponentUI {
// Public Constructors
public TabbedPaneUI();
// Public Instance Methods
public abstract java.awt.Rectangle getTabBounds(JTabbedPane pane, int index);
public abstract int getTabRunCount(JTabbedPane pane);
public abstract int tabForCoordinate(JTabbedPane pane, int x, int y);
}
javax.swing.plaf.SeparatorUI
564 Chapter 28 – The javax.swing.plaf Package

Passed To: JTabbedPane.setUI()
Retur ned By: JTabbedPane.getUI()
TableHeaderUI
Ja va 1.2
javax.swing .plaf
This abstract class deﬁnes the methods that must be implemented by a pluggable look-
and-feel delegate for JTableHeader.
public abstract class TableHeaderUI extends ComponentUI {
// Public Constructors
public TableHeaderUI();
}
Passed To: javax.swing .table.JTableHeader.setUI()
Retur ned By: javax.swing .table.JTableHeader.getUI()
TableUI
Ja va 1.2
javax.swing .plaf
This abstract class deﬁnes the methods that must be implemented by a pluggable look-
and-feel delegate for JTable.
public abstract class TableUI extends ComponentUI {
// Public Constructors
public TableUI();
}
Passed To: JTable.setUI()
Retur ned By: JTable.getUI()
TextUI
Ja va 1.2
javax.swing .plaf
This abstract class deﬁnes the methods that must be implemented by a pluggable look-
and-feel delegate for JTextComponent.
public abstract class TextUI extends ComponentUI {
// Public Constructors
public TextUI();
// Public Instance Methods
public abstract void damageRange(javax.swing .text.JTextComponent t, int p0, int p1);
public abstract void damageRange(javax.swing .text.JTextComponent t, int p0, int p1,
javax.swing .text.Position.Bias ﬁrstBias,
javax.swing .text.Position.Bias secondBias);
public abstract javax.swing.text.EditorKit getEditorKit(javax.swing .text.JTextComponent t);
public abstract int getNextV isualPositionFrom(javax.swing .text.JTextComponent t, int pos,
javax.swing .text.Position.Bias b, int direction,
javax.swing .text.Position.Bias[ ] biasRet)
throws javax.swing.text.BadLocationException;
public abstract javax.swing.text.V ie w getRootV iew(javax.swing .text.JTextComponent t);
public abstract java.awt.Rectangle modelToV iew(javax.swing .text.JTextComponent t, int pos)
throws javax.swing.text.BadLocationException;
public abstract java.awt.Rectangle modelToV iew(javax.swing .text.JTextComponent t, int pos,
javax.swing .text.Position.Bias bias)
throws javax.swing.text.BadLocationException;
public abstract int viewToModel(javax.swing .text.JTextComponent t, java.awt.Point pt);
javax.swing.
plaf
javax.swing.plaf.TextUI
Chapter 28 – The javax.swing.plaf Package
565

public abstract int viewToModel(javax.swing .text.JTextComponent t, java.awt.Point pt,
javax.swing .text.Position.Bias[ ] biasReturn);
}
Passed To: javax.swing .text.JTextComponent.setUI()
Retur ned By: javax.swing .text.JTextComponent.getUI()
ToolBarUI
Ja va 1.2
javax.swing .plaf
This abstract class deﬁnes the methods that must be implemented by a pluggable look-
and-feel delegate for JToolBar.
public abstract class ToolBarUI extends ComponentUI {
// Public Constructors
public ToolBarUI();
}
Passed To: JToolBar.setUI()
Retur ned By: JToolBar.getUI()
ToolT ipUI
Ja va 1.2
javax.swing .plaf
This abstract class deﬁnes the methods that must be implemented by a pluggable look-
and-feel delegate for JToolT ip.
public abstract class ToolT ipUI extends ComponentUI {
// Public Constructors
public ToolT ipUI();
}
Retur ned By: JToolT ip.getUI()
TreeUI
Ja va 1.2
javax.swing .plaf
This abstract class deﬁnes the methods that must be implemented by a pluggable look-
and-feel delegate for JTree.
public abstract class TreeUI extends ComponentUI {
// Public Constructors
public TreeUI();
// Public Instance Methods
public abstract void cancelEditing(JTree tree);
public abstract javax.swing.tree.TreePath getClosestPathForLocation(JTree tree, int x, int y);
public abstract javax.swing.tree.TreePath getEditingPath(JTree tree);
public abstract java.awt.Rectangle getPathBounds(JTree tree, javax.swing .tree.TreePath path);
public abstract javax.swing.tree.TreePath getPathForRow(JTree tree, int row);
public abstract int getRowCount(JTree tree);
public abstract int getRowForPath(JTree tree, javax.swing .tree.TreePath path);
public abstract boolean isEditing(JTree tree);
public abstract void star tEditingAtPath(JTree tree, javax.swing .tree.TreePath path);
public abstract boolean stopEditing(JTree tree);
}
javax.swing.plaf.TextUI
566 Chapter 28 – The javax.swing.plaf Package

Passed To: JTree.setUI()
Retur ned By: JTree.getUI()
UIResource
Ja va 1.2
javax.swing .plaf
This marker interface deﬁnes no methods; it is used to distinguish user-inter face pr op-
erty values speciﬁed by a UI delegate from property values speciﬁed explicitly by an
application. Only programmers writing custom look-and-feels or custom UI delegate
objects need to use this interface. Application-level code never uses it.
Any component properties set by the installUI() method of a UI delegate object should
be set to objects that implement the UIResource inter face. This allows the uninstallUI()
method to determine which properties were explicitly set by the application and leave
these properties unchanged.
The requir ement for property values that implement UIResource means that the
javax.swing .plaf package contains a number of trivial wrapper classes that extend com-
mon resource types such as java.awt.Color, java.awt.Font, and so on. These wrapper classes
add no new functionality but exist simply to implement UIResource.
public abstract interface UIResource {
}
Implementations: DefaultListCellRenderer.UIResource, JScrollPane.ScrollBar,
ScrollPaneLayout.UIResource, BorderUIResource, BorderUIResource.BevelBorderUIResource,
BorderUIResource.CompoundBorderUIResource, BorderUIResource.EmptyBorderUIResource,
BorderUIResource.EtchedBorderUIResource, BorderUIResource.LineBorderUIResource,
BorderUIResource.MatteBorderUIResource, BorderUIResource.TitledBorderUIResource, ColorUIResource,
DimensionUIResource, FontUIResource, IconUIResource, InsetsUIResource,
javax.swing .table.DefaultTableCellRenderer.UIResource
Viewpor tUI
Ja va 1.2
javax.swing .plaf
This abstract class deﬁnes the methods that must be implemented by a pluggable look-
and-feel delegate for JV iewpor t.
public abstract class Viewpor tUI extends ComponentUI {
// Public Constructors
public Viewpor tUI();
}
javax.swing.
plaf
javax.swing.plaf.Viewpor tUI
Chapter 28 – The javax.swing.plaf Package
567

CHAPTER 29
The javax.swing.table Package
The javax.swing .table package contains classes and interfaces that are used with the
power ful JTable component of the javax.swing package. TableModel is the central inter-
face in this package; it provides access to the data to be displayed in the table.
TableColumn repr esents the attributes of a column in the table. TableColumnModel rep-
resents a set of columns in the table. JTableHeader is a component that displays the
resizable and draggable column headers of a table. The TableCellRenderer inter face
deﬁnes how individual cells are drawn using a GUI component as a template. Fig-
ur e 29-1 shows the class hierarchy of this package. See Chapter 3, Swing Program-
ming Topics, for a discussion of and example using JTable and the javax.swing .table
package.
AbstractTableModel
Ja va 1.2
javax.swing .table
serializable model
This abstract class is a convenient partial implementation of the TableModel inter face. An
application that needs a noneditable TableModel needs only to provide implementations
for the abstract methods getColumnCount(), getRowCount(), and getValueAt(). An application
that wants to allow the table data to be edited must additionally override the default
implementations of isCellEditable() and setValueAt(). AbstractTableModel pr ovides default
implementations of the event listener registration methods. Additionally, it deﬁnes a
number of methods for sending various types of TableModelEvent objects to the register ed
TableModelListener objects. This is useful because of the fairly complex way that TableMod-
elEvent is used to describe differ ent types of changes to the table data. If the data under-
lying the table model ever changes, the application can call one of these methods to
notify the JTable, and any other interested listeners, of the change.
public abstract class AbstractTableModel implements Serializable, TableModel {
// Public Constructors
public AbstractTableModel();
// Event Registration Methods (by event name)
Implements:TableModel
public void addTableModelListener(javax.swing .event.TableModelListener l);
Implements:TableModel
568

CLASS
INTERFACE
ABSTRACT CLASS
KEY
extends
implements
java.lang
Object
AbstractTableModel
DefaultTableColumnModel
TableColumn
DefaultTableModel
java.io
Serializable
TableModel
TableColumnModel
javax.swing
JLabel
JComponent
CellEditor
DefaultTableCellRenderer
JTableHeader
TableCellEditor
TableCellRenderer
javax.swing.table
java.beans
PropertyChangeListener
javax.accessibility
javax.swing.event
ListSelectionListener
TableColumnModelListener
Accessible
Figur e 29−1: The javax.swing.table package
public void removeTableModelListener(javax.swing .event.TableModelListener l);
// Public Instance Methods
public int ﬁndColumn(String columnName);
public void ﬁreTableCellUpdated(int row, int column);
public void ﬁreTableChanged(javax.swing .event.TableModelEvent e);
public void ﬁreTableDataChanged();
public void ﬁreTableRowsDeleted(int ﬁrstRow, int lastRow);
public void ﬁreTableRowsInser ted(int ﬁrstRow, int lastRow);
public void ﬁreTableRowsUpdated(int ﬁrstRow, int lastRow);
public void ﬁreTableStr uctureChanged();
// Methods Implementing TableModel
public void addTableModelListener(javax.swing .event.TableModelListener l);
public Class getColumnClass(int columnIndex);
public abstract int getColumnCount();
public String getColumnName(int column);
public abstract int getRowCount();
public abstract Object getValueAt(int rowIndex, int columnIndex);
constant
public boolean isCellEditable(int rowIndex, int columnIndex);
public void removeTableModelListener(javax.swing .event.TableModelListener l);
empty
public void setValueAt(Object aValue, int rowIndex, int columnIndex);
// Protected Instance Fields
protected javax.swing.e vent.EventListenerList listenerList;
}
javax.swing.
table
javax.swing.table.AbstractTableModel
Chapter 29 – The javax.swing.table Package
569

Hierar chy: Object→AbstractTableModel(Serializable, TableModel)
Subc lasses: DefaultTableModel
DefaultTableCellRenderer
Ja va 1.2
javax.swing .table
serializable accessible swing component
This class is a simple implementation of the TableCellRenderer inter face. It uses a JLabel to
display the textual value (determined by calling the toString() method) of any object.
DefaultTableCellRenderer takes care to use the colors and fonts of the JTable, so that it inter-
faces seamlessly with the table.
public class DefaultTableCellRenderer extends JLabel implements Serializable, TableCellRenderer {
// Public Constructors
public DefaultTableCellRenderer();
// Inner Classes
public static class UIResource extends DefaultTableCellRenderer implements javax.swing.plaf.UIResource;
// Methods Implementing TableCellRenderer
public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected,
boolean hasFocus, int row, int column);
// Public Methods Overriding JLabel
public void updateUI();
// Public Methods Overriding JComponent
public void setBackground(java.awt.Color c);
public void setForeground(java.awt.Color c);
// Protected Instance Methods
protected void setValue(Object value);
// Protected Class Fields
protected static javax.swing.border.Border noFocusBorder;
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→JComponent(Serializable)→JLabel(Accessible, SwingConstants)→
DefaultTableCellRenderer(Serializable, TableCellRenderer)
Subc lasses: DefaultTableCellRenderer.UIResource
DefaultTableCellRenderer.UIResource
Ja va 1.2
javax.swing .table
serializable accessible swing component
This class is a trivial subclass of DefaultTableCellRenderer that exists only to implement the
javax.swing .plaf.UIResource marker interface.
public static class DefaultTableCellRenderer.UIResource extends DefaultTableCellRenderer
implements javax.swing.plaf.UIResource {
// Public Constructors
public UIResource();
}
DefaultTableColumnModel
Ja va 1.2
javax.swing .table
serializable model
This class implements the TableColumnModel and keeps track of the number, order, size,
and selection state of the columns in a JTable component. The JTable uses this class by
default; few applications have any reason to use anything else.
javax.swing.table.AbstractTableModel
570 Chapter 29 – The javax.swing.table Package

public class DefaultTableColumnModel implements javax.swing.e vent.ListSelectionListener,
java.beans.Proper tyChangeListener, Serializable, TableColumnModel {
// Public Constructors
public DefaultTableColumnModel();
// Methods Implementing ListSelectionListener
public void valueChanged(javax.swing .event.ListSelectionEvent e);
// Methods Implementing PropertyChangeListener
public void proper tyChange(java.beans.Proper tyChangeEvent evt);
// Methods Implementing TableColumnModel
public void addColumn(TableColumn aColumn);
public void addColumnModelListener(javax.swing .event.TableColumnModelListener x);
public TableColumn getColumn(int columnIndex);
default:0
public int getColumnCount();
public int getColumnIndex(Object identiﬁer);
public int getColumnIndexAtX(int xPosition);
default:1
public int getColumnMargin();
public java.util.Enumeration getColumns();
default:false
public boolean getColumnSelectionAllowed();
default:0
public int getSelectedColumnCount();
public int[ ] getSelectedColumns();
default:DefaultListSelectionModel
public ListSelectionModel getSelectionModel();
default:0
public int getTotalColumnW idth();
public void moveColumn(int columnIndex, int newIndex);
public void removeColumn(TableColumn column);
public void removeColumnModelListener(javax.swing .event.TableColumnModelListener x);
public void setColumnMargin(int newMargin);
public void setColumnSelectionAllowed(boolean ﬂag);
public void setSelectionModel(ListSelectionModel newModel);
// Protected Instance Methods
protected ListSelectionModel createSelectionModel();
protected void ﬁreColumnAdded(javax.swing .event.TableColumnModelEvent e);
protected void ﬁreColumnMarginChanged();
protected void ﬁreColumnMoved(javax.swing .event.TableColumnModelEvent e);
protected void ﬁreColumnRemoved(javax.swing .event.TableColumnModelEvent e);
protected void ﬁreColumnSelectionChanged(javax.swing .event.ListSelectionEvent e);
protected void recalcW idthCache();
// Protected Instance Fields
protected transient javax.swing.e vent.ChangeEvent changeEvent;
protected int columnMargin;
protected boolean columnSelectionAllowed;
protected javax.swing.e vent.EventListenerList listenerList;
protected ListSelectionModel selectionModel;
protected java.util.Vector tableColumns;
protected int totalColumnW idth;
}
Hierar chy: Object→
DefaultTableColumnModel(javax.swing .event.ListSelectionListener(java.util.EventListener),
java.beans.Proper tyChangeListener(java.util.EventListener), Serializable, TableColumnModel)
DefaultTableModel
Ja va 1.2
javax.swing .table
serializable model
This class is a relatively simple implementation of TableModel that works with table data
that is expressed either as an array of rows, where each row is an array of objects, or as
a vector of rows, where each row is a vector of objects. In addition to the table cell
data, DefaultTableModel also allows you to specify the column header values in an array
or vector. DefaultTableModel is the only concrete TableModel implementation in Swing.
javax.swing.
table
javax.swing.table.DefaultTableModel
Chapter 29 – The javax.swing.table Package
571

Several of the JTable constructors initialize and use a DefaultTableModel object as the com-
ponent’s model. In addition to its TableModel methods, DefaultTableModel also deﬁnes
methods for changing the table data, adding and removing columns, and so on.
public class DefaultTableModel extends AbstractTableModel implements Serializable {
// Public Constructors
public DefaultTableModel();
public DefaultTableModel(Object[ ] columnNames, int numRows);
public DefaultTableModel(java.util.Vector data, java.util.Vector columnNames);
public DefaultTableModel(Object[ ][ ] data, Object[ ] columnNames);
public DefaultTableModel(int numRows, int numColumns);
public DefaultTableModel(java.util.Vector columnNames, int numRows);
// Protected Class Methods
protected static java.util.Vector conver tToVector(Object[ ][ ] anArray);
protected static java.util.Vector conver tToVector(Object[ ] anArray);
// Property Accessor Methods (by property name)
Overrides:AbstractTableModel default:0
public int getColumnCount();
public java.util.Vector getDataVector();
Overrides:AbstractTableModel default:0
public int getRowCount();
// Public Instance Methods
public void addColumn(Object columnName);
public void addColumn(Object columnName, java.util.Vector columnData);
public void addColumn(Object columnName, Object[ ] columnData);
public void addRow(Object[ ] rowData);
public void addRow(java.util.Vector rowData);
public void inser tRow(int row, Object[ ] rowData);
public void inser tRow(int row, java.util.Vector rowData);
public void moveRow(int star tIndex, int endIndex, int toIndex);
public void newDataAvailable(javax.swing .event.TableModelEvent event);
public void newRowsAdded(javax.swing .event.TableModelEvent event);
public void removeRow(int row);
public void rowsRemoved(javax.swing .event.TableModelEvent event);
public void setColumnIdentiﬁers(Object[ ] newIdentiﬁers);
public void setColumnIdentiﬁers(java.util.Vector newIdentiﬁers);
public void setDataVector(Object[ ][ ] newData, Object[ ] columnNames);
public void setDataVector(java.util.Vector newData, java.util.Vector columnNames);
public void setNumRows(int newSize);
// Public Methods Overriding AbstractTableModel
public String getColumnName(int column);
public Object getValueAt(int row, int column);
constant
public boolean isCellEditable(int row, int column);
public void setValueAt(Object aValue, int row, int column);
// Protected Instance Fields
protected java.util.Vector columnIdentiﬁers;
protected java.util.Vector dataVector;
}
Hierar chy: Object→AbstractTableModel(Serializable, TableModel)→DefaultTableModel(Serializable)
JTableHeader
Ja va 1.2
javax.swing .table
serializable accessible swing component
This class is a Swing component that displays the header of a JTable. This header com-
ponent displays the name of each column and, optionally, allows the user to resize and
reorder the columns by dragging them. JTableHeader uses the TableColumnModel of its JTable
to obtain information about the column headers it must display.
A JTable component automatically creates a suitable JTableHeader component; an applica-
tion should not have to create one of its own. Nevertheless, JTableHeader does deﬁne
some interesting methods that applications may want to use. Obtain the JTableHeader of
javax.swing.table.DefaultTableModel
572 Chapter 29 – The javax.swing.table Package

a JTable with the getTableHeader() method of JTable. Once you have the JTableHeader object,
use its resizingAllowed and reorderingAllowed pr operties to specify how the user is allowed
to manipulate the columns. Also, set the updateTableInRealT ime pr operty to specify if the
entir e JTable should be updated as the user drags a column or if the update should be
postponed until the user completes the drag.
public class JTableHeader extends JComponent implements Accessible, javax.swing.e vent.TableColumnModelListener {
// Public Constructors
public JTableHeader();
public JTableHeader(TableColumnModel cm);
// Inner Classes
protected class AccessibleJTableHeader extends JComponent.AccessibleJComponent;
// Property Accessor Methods (by property name)
Implements:Accessible default:AccessibleJTableHeader
public AccessibleContext getAccessibleContext();
default:DefaultTableColumnModel
public TableColumnModel getColumnModel();
public void setColumnModel(TableColumnModel newModel);
default:null
public TableColumn getDraggedColumn();
public void setDraggedColumn(TableColumn aColumn);
default:0
public int getDraggedDistance();
public void setDraggedDistance(int distance);
default:true
public boolean getReorderingAllowed();
public void setReorderingAllowed(boolean b);
default:true
public boolean getResizingAllowed();
public void setResizingAllowed(boolean b);
default:null
public TableColumn getResizingColumn();
public void setResizingColumn(TableColumn aColumn);
default:null
public JTable getTable();
public void setTable(JTable aTable);
public javax.swing.plaf.TableHeaderUI getUI();
public void setUI(javax.swing .plaf.TableHeaderUI ui);
Overrides:JComponent default:"TableHeaderUI"
public String getUIClassID();
default:true
public boolean getUpdateTableInRealT ime();
public void setUpdateTableInRealT ime(boolean ﬂag);
// Public Instance Methods
public int columnAtPoint(java.awt.Point point);
public java.awt.Rectangle getHeaderRect(int columnIndex);
public void resizeAndRepaint();
// Methods Implementing Accessible
default:AccessibleJTableHeader
public AccessibleContext getAccessibleContext();
// Methods Implementing TableColumnModelListener
public void columnAdded(javax.swing .event.TableColumnModelEvent e);
public void columnMarginChanged(javax.swing .event.ChangeEvent e);
public void columnMoved(javax.swing .event.TableColumnModelEvent e);
public void columnRemoved(javax.swing .event.TableColumnModelEvent e);
empty
public void columnSelectionChanged(javax.swing .event.ListSelectionEvent e);
// Public Methods Overriding JComponent
public String getToolT ipText(java.awt.e vent.MouseEvent event);
public void updateUI();
// Protected Methods Overriding JComponent
protected String paramString();
// Protected Instance Methods
protected TableColumnModel createDefaultColumnModel();
protected void initializeLocalVars();
// Protected Instance Fields
protected TableColumnModel columnModel;
protected transient TableColumn draggedColumn;
protected transient int draggedDistance;
protected boolean reorderingAllowed;
protected boolean resizingAllowed;
javax.swing.
table
javax.swing.table.JTableHeader
Chapter 29 – The javax.swing.table Package
573

protected transient TableColumn resizingColumn;
protected JTable table;
protected boolean updateTableInRealT ime;
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→JComponent(Serializable)→JTableHeader(Accessible,
javax.swing .event.TableColumnModelListener(java.util.EventListener))
Passed To: JTable.setTableHeader(),
JTableHeader.AccessibleJTableHeader.AccessibleJTableHeaderEntr y.AccessibleJTableHeaderEntr y()
Retur ned By: JTable.{createDefaultTableHeader(), getTableHeader()}
Type Of: JTable.tableHeader
TableCellEditor
Ja va 1.2
javax.swing .table
This interface extends CellEditor and adds an additional method that must be imple-
mented by classes that want to serve as editors for table cells displayed by a JTable.
Most applications can rely on the default set of table-cell-editing capabilities of javax.-
swing .DefaultCellEditor and do not have to implement this interface. If you do need to
implement this interface, see javax.swing .CellEditor and javax.swing .tree.TreeCellEditor for fur-
ther details.
public abstract interface TableCellEditor extends CellEditor {
// Public Instance Methods
public abstract Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected,
int row, int column);
}
Hierar chy: (TableCellEditor(CellEditor))
Implementations: DefaultCellEditor
Passed To: JTable.{prepareEditor(), setCellEditor(), setDefaultEditor()}, TableColumn.{setCellEditor(),
TableColumn()}
Retur ned By: JTable.{getCellEditor(), getDefaultEditor()}, TableColumn.getCellEditor()
Type Of: JTable.cellEditor, TableColumn.cellEditor
TableCellRenderer
Ja va 1.2
javax.swing .table
This interface deﬁnes the method that must be implemented by any class wishing to
display data within a JTable component. getTableCellRendererComponent() is passed the
value that appears in a speciﬁed table cell; it must retur n a Component object capable of
displaying that value in some fashion. Other arguments to the method specify whether
the cell is selected and whether it has the keyboard focus. A render er should take these
factors into account when deciding how to display the value. The JTable is responsible
for positioning the retur ned Component pr operly and causing it to draw itself. The Table-
CellRenderer simply has to conﬁgure the appearance and content of the component
befor e retur ning it. Most applications can rely on the DefaultTableCellRenderer class to dis-
play a textual repr esentation of any object and do not have to implement this interface
themselves.
javax.swing.table.JTableHeader
574 Chapter 29 – The javax.swing.table Package

public abstract interface TableCellRenderer {
// Public Instance Methods
public abstract Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected,
boolean hasFocus, int row, int column);
}
Implementations: DefaultTableCellRenderer
Passed To: JTable.{prepareRenderer(), setDefaultRenderer()}, TableColumn.{setCellRenderer(),
setHeaderRenderer(), TableColumn()}
Retur ned By: JTable.{getCellRenderer(), getDefaultRenderer()},
TableColumn.{createDefaultHeaderRenderer(), getCellRenderer(), getHeaderRenderer()}
Type Of: TableColumn.{cellRenderer, headerRenderer}
TableColumn
Ja va 1.2
javax.swing .table
serializable
This class contains information about a single column displayed within a JTable. The
JTable component creates TableColumn objects automatically, and applications rarely need
to create their own. To obtain the TableColumn objects automatically created by a JTable,
ﬁrst obtain the TableColumnModel of the table and then use its methods to query the indi-
vidual columns.
TableColumn exposes a number of useful properties. width, prefer redW idth, minW idth, and
maxW idth specify the current, preferr ed, minimum, and maximum sizes for the column.
The resizable pr operty speciﬁes whether the user is allowed to resize the column. The
identiﬁer pr operty allows you to attach a name to a column, which can sometimes be
useful when working with columns that may be reorder ed. The identiﬁer is never dis-
played. On the other hand, the headerValue pr operty speciﬁes the object (usually a String)
that is displayed in the column header. The headerValue is displayed by the TableCellRen-
derer speciﬁed with the headerRenderer pr operty. Do not confuse the headerRenderer with
the cellRenderer and cellEditor pr operties. If these properties are not null, they specify a
custom render er object and a custom editor object to be used for the cells in this col-
umn. Finally, the modelIndex pr operty speciﬁes the column number to be used when
extracting data for this column from the TableModel. Since JTable allows its columns to be
rearranged by the user, ther e ar e two differ ent coordinate systems for referring to
columns. The ﬁrst is the index of the TableColumn object within the TableColumnModel.
This is the visual order of columns as displayed by the JTable. The other coordinate sys-
tem is the more fundamental index of the column data within the underlying TableModel.
The modelIndex pr operty uses the latter coordinate system and speciﬁes where to obtain
data for the column.
public class TableColumn implements Serializable {
// Public Constructors
public TableColumn();
public TableColumn(int modelIndex);
public TableColumn(int modelIndex, int width);
public TableColumn(int modelIndex, int width, TableCellRenderer cellRenderer, TableCellEditor cellEditor);
// Public Constants
="cellRenderer"
public static ﬁnal String CELL_RENDERER_PROPERTY;
="columWidth"
public static ﬁnal String COLUMN_WIDTH_PROPERTY;
="headerRenderer"
public static ﬁnal String HEADER_RENDERER_PROPERTY;
="headerValue"
public static ﬁnal String HEADER_VALUE_PROPERTY;
// Event Registration Methods (by event name)
synchronized
public void addProper tyChangeListener(java.beans.Proper tyChangeListener listener);
synchronized
public void removeProper tyChangeListener(java.beans.Proper tyChangeListener listener);
javax.swing.
table
javax.swing.table.TableColumn
Chapter 29 – The javax.swing.table Package
575

// Property Accessor Methods (by property name)
default:null
public TableCellEditor getCellEditor();
public void setCellEditor(TableCellEditor anEditor);
default:null
public TableCellRenderer getCellRenderer();
public void setCellRenderer(TableCellRenderer aRenderer);
public TableCellRenderer getHeaderRenderer();
public void setHeaderRenderer(TableCellRenderer aRenderer);
default:null
public Object getHeaderValue();
public void setHeaderValue(Object aValue);
default:null
public Object getIdentiﬁer();
public void setIdentiﬁer(Object anIdentiﬁer);
default:2147483647
public int getMaxW idth();
public void setMaxW idth(int maxWidth);
default:15
public int getMinW idth();
public void setMinW idth(int minWidth);
default:0
public int getModelIndex();
public void setModelIndex(int anIndex);
default:75
public int getPrefer redW idth();
public void setPrefer redW idth(int preferredWidth);
default:true
public boolean getResizable();
public void setResizable(boolean ﬂag);
default:75
public int getW idth();
public void setW idth(int width);
// Public Instance Methods
public void disableResizedPosting();
public void enableResizedPosting();
public void sizeW idthToF it();
// Protected Instance Methods
protected TableCellRenderer createDefaultHeaderRenderer();
// Protected Instance Fields
protected TableCellEditor cellEditor;
protected TableCellRenderer cellRenderer;
protected TableCellRenderer headerRenderer;
protected Object headerValue;
protected Object identiﬁer;
protected boolean isResizable;
protected int maxW idth;
protected int minW idth;
protected int modelIndex;
protected transient int resizedPostingDisableCount;
protected int width;
}
Hierar chy: Object→TableColumn(Serializable)
Passed To: JTable.{addColumn(), removeColumn()}, DefaultTableColumnModel.{addColumn(),
removeColumn()}, JTableHeader.{setDraggedColumn(), setResizingColumn()},
TableColumnModel.{addColumn(), removeColumn()}
Retur ned By: JTable.getColumn(), DefaultTableColumnModel.getColumn(),
JTableHeader.{getDraggedColumn(), getResizingColumn()}, TableColumnModel.getColumn()
Type Of: JTableHeader.{draggedColumn, resizingColumn}
TableColumnModel
Ja va 1.2
javax.swing .table
model
A JTable component uses a TableColumnModel object to keep track of the columns it dis-
plays, the order they are in, and their selection state. In essence, a TableColumnModel
maintains a list of TableColumn objects and remembers which are selected. Most
javax.swing.table.TableColumn
576 Chapter 29 – The javax.swing.table Package

applications rely on the DefaultTableColumnModel implementation and rarely need to
implement this interface themselves.
public abstract interface TableColumnModel {
// Property Accessor Methods (by property name)
public abstract int getColumnCount();
public abstract int getColumnMargin();
public abstract void setColumnMargin(int newMargin);
public abstract java.util.Enumeration getColumns();
public abstract boolean getColumnSelectionAllowed();
public abstract void setColumnSelectionAllowed(boolean ﬂag);
public abstract int getSelectedColumnCount();
public abstract int[ ] getSelectedColumns();
public abstract ListSelectionModel getSelectionModel();
public abstract void setSelectionModel(ListSelectionModel newModel);
public abstract int getTotalColumnW idth();
// Public Instance Methods
public abstract void addColumn(TableColumn aColumn);
public abstract void addColumnModelListener(javax.swing .event.TableColumnModelListener x);
public abstract TableColumn getColumn(int columnIndex);
public abstract int getColumnIndex(Object columnIdentiﬁer);
public abstract int getColumnIndexAtX(int xPosition);
public abstract void moveColumn(int columnIndex, int newIndex);
public abstract void removeColumn(TableColumn column);
public abstract void removeColumnModelListener(javax.swing .event.TableColumnModelListener x);
}
Implementations: DefaultTableColumnModel
Passed To: JTable.{JTable(), setColumnModel()},
javax.swing .event.TableColumnModelEvent.TableColumnModelEvent(), JTableHeader.{JTableHeader(),
setColumnModel()}
Retur ned By: JTable.{createDefaultColumnModel(), getColumnModel()},
JTableHeader.{createDefaultColumnModel(), getColumnModel()}
Type Of: JTable.columnModel, JTableHeader.columnModel
TableModel
Ja va 1.2
javax.swing .table
model
This interface is the intermediary between a JTable component and the data it displays.
Every JTable uses a TableModel to encapsulate its data. getColumnCount() and getRowCount()
retur n the size of the table. getColumnName() retur ns the header text for a given column
number. getColumnClass() retur ns the Class object for a numbered column. (If you want
to display differ ent types of objects in a column, this method should retur n values of
type Object.) The most important method of the interface, however, is getValueAt(),
which, given a column number and a row number, retur ns the cell value. The JTable
class can be conﬁgured to allow the user to reorder columns by dragging them. Note
that this visual reordering does not change the underlying column numbers used to
access data from the TableModel.
If you are allowing users to edit data in your TableModel, you must also provide mean-
ingful implementations of isCellEditable() and setValueAt(). If the model can be edited or if
the data it contains can otherwise change (e.g., if rows are added), you must also
implement addTableModelListener() and removeTableModelListener() and send a TableModelEvent
when the contents of the table change.
Applications with simple table display needs can rely on the DefaultTableModel. Because
tabular data can come from an wide variety of sources, in a wide variety of formats,
javax.swing.
table
javax.swing.table.TableModel
Chapter 29 – The javax.swing.table Package
577

however, many applications need a custom TableModel implementation. Most applica-
tions ﬁnd it easer to subclass AbstractTableModel than to implement TableModel fr om
scratch.
public abstract interface TableModel {
// Event Registration Methods (by event name)
public abstract void addTableModelListener(javax.swing .event.TableModelListener l);
public abstract void removeTableModelListener(javax.swing .event.TableModelListener l);
// Public Instance Methods
public abstract Class getColumnClass(int columnIndex);
public abstract int getColumnCount();
public abstract String getColumnName(int columnIndex);
public abstract int getRowCount();
public abstract Object getValueAt(int rowIndex, int columnIndex);
public abstract boolean isCellEditable(int rowIndex, int columnIndex);
public abstract void setValueAt(Object aValue, int rowIndex, int columnIndex);
}
Implementations: AbstractTableModel
Passed To: JTable.{JTable(), setModel()}, javax.swing .event.TableModelEvent.TableModelEvent()
Retur ned By: JTable.{createDefaultDataModel(), getModel()}
Type Of: JTable.dataModel
javax.swing.table.TableModel
578 Chapter 29 – The javax.swing.table Package

CHAPTER 30
The javax.swing.text Package
This large and complex package contains the powerful JTextComponent text editor
and all of its supporting infrastructure. The JTextF ield, JTextArea, JEditorPane, and other
text input components of the javax.swing package all subclass JTextComponent and
rely on the other classes and interfaces of this package.
The Document inter face deﬁnes the data model for the JTextComponent. It is the basic
abstraction for documents that can be displayed and edited. The AbstractDocument
class implements this interface and provides a number of useful features and
extensions. StyledDocument extends Document to deﬁne support for documents that
have styles associated with their content. DefaultStyledDocument is a concrete imple-
mentation based on AbstractDocument. Other important classes and interfaces in this
package include: EditorKit, Element, View, AbstractDocument.Content, Caret, and High-
lighter. Figur e 30-1 shows the class hierarchy of this package.
AbstractDocument
Ja va 1.2
javax.swing .text
serializable
This class is a partial, abstract implementation of the Document inter face, which also
deﬁnes several important inner classes and interfaces. Typical applications do not have
to use or subclass this class. Instead, they can rely on predeﬁned concrete implementa-
tions such as PlainDocument, DefaultStyledDocument, and javax.swing .text.html.HTMLDocument.
public abstract class AbstractDocument implements Document, Serializable {
// Protected Constructors
protected AbstractDocument(AbstractDocument.Content data);
protected AbstractDocument(AbstractDocument.Content data, AbstractDocument.AttributeContext context);
// Public Constants
="bidi level"
public static ﬁnal String BidiElementName;
="content"
public static ﬁnal String ContentElementName;
="$ename"
public static ﬁnal String ElementNameAttribute;
="paragraph"
public static ﬁnal String ParagraphElementName;
="section"
public static ﬁnal String SectionElementName;
javax.swing.
text
579

extends
implements
KEY
CLASS
ABSTRACT CLASS
INTERFACE
FINAL CLASS
Object
java.lang
AbstractDocument
AbstractWriter
EditorKit
ElementIterator
GapContent
LayeredHighlighter
Segment
SimpleAttributeSet
StringContent
StyleConstants
StyleContext
TabSet
TabStop
Utilities
View
BadLocationException
Cloneable
Exception
java.io
Serializable
IOException
javax.swing
JComponent
AbstractAction
SwingConstants
Scrollable
java.awt
Rectangle
ChangedCharSetException
JTextComponent
TextAction
DefaultStyledDocument
Document
StyledDocument
Element
PlainDocument
DefaultEditorKit
StyledEditorKit
Keymap
ViewFactory
Highlighter
DefaultLayeredHighlighter
AttributeSet
MutableAttributeSet
Style
Postition
TabableView
TabExpander
ComponentView
CompositeView
IconView
LabelView
PlainView
BoxView
ParagraphView
FieldView
PasswordView
TableView
WrappedPlainView
Caret
javax.accessibility
Accessible
java.awt.event
FocusListener
MouseListener
MouseMotionListener
javax.swing.text
DefaultCaret
Figur e 30−1: The javax.swing.text package
javax.swing.text.AbstractDocument
580 Chapter 30 – The javax.swing.text Package

// Protected Constants
="document location failure"
protected static ﬁnal String BAD_LOCATION;
// Inner Classes
public abstract class AbstractElement implements javax.swing.text.Element, MutableAttributeSet, Serializable,
javax.swing .tree.TreeNode;
public abstract static interface AttributeContext;
public class BranchElement extends AbstractDocument.AbstractElement;
public abstract static interface Content;
public class DefaultDocumentEvent extends javax.swing.undo.CompoundEdit
implements javax.swing.e vent.DocumentEvent;
public static class ElementEdit extends javax.swing.undo.AbstractUndoableEdit
implements javax.swing.e vent.DocumentEvent.ElementChange;
public class LeafElement extends AbstractDocument.AbstractElement;
// Event Registration Methods (by event name)
Implements:Document
public void addDocumentListener(javax.swing .event.DocumentListener listener);
Implements:Document
public void removeDocumentListener(javax.swing .event.DocumentListener listener);
Implements:Document
public void addUndoableEditListener(javax.swing .event.UndoableEditListener listener);
Implements:Document
public void removeUndoableEditListener(
javax.swing .event.UndoableEditListener listener);
// Public Instance Methods
public void dump(java.io.PrintStream out);
public int getAsynchronousLoadPriority();
public javax.swing.text.Element getBidiRootElement();
public java.util.Dictionary getDocumentProper ties();
public abstract javax.swing.text.Element getParagraphElement(int pos);
synchronized
public ﬁnal void readLock();
synchronized
public ﬁnal void readUnlock();
public void setAsynchronousLoadPriority(int p);
public void setDocumentProper ties(java.util.Dictionary x);
// Methods Implementing Document
public void addDocumentListener(javax.swing .event.DocumentListener listener);
public void addUndoableEditListener(javax.swing .event.UndoableEditListener listener);
synchronized
public Position createPosition(int offs) throws BadLocationException;
public abstract javax.swing.text.Element getDefaultRootElement();
public ﬁnal Position getEndPosition();
public int getLength();
public ﬁnal Object getProper ty(Object key);
public javax.swing.text.Element[ ] getRootElements();
public ﬁnal Position getStar tPosition();
public String getText(int offset, int length) throws BadLocationException;
public void getText(int offset, int length, Segment txt) throws BadLocationException;
public void inser tString(int offs, String str, AttributeSet a) throws BadLocationException;
public ﬁnal void putProper ty(Object key, Object value);
public void remove(int offs, int len) throws BadLocationException;
public void removeDocumentListener(javax.swing .event.DocumentListener listener);
public void removeUndoableEditListener(javax.swing .event.UndoableEditListener listener);
public void render(Runnable r);
// Protected Instance Methods
protected javax.swing.text.Element createBranchElement(javax.swing .text.Element parent, AttributeSet a);
protected javax.swing.text.Element createLeafElement(javax.swing .text.Element parent, AttributeSet a, int p0,
int p1);
protected void ﬁreChangedUpdate(javax.swing .event.DocumentEvent e);
protected void ﬁreInser tUpdate(javax.swing .event.DocumentEvent e);
protected void ﬁreRemoveUpdate(javax.swing .event.DocumentEvent e);
protected void ﬁreUndoableEditUpdate(javax.swing .event.UndoableEditEvent e);
protected ﬁnal AbstractDocument.AttributeContext getAttributeContext();
protected ﬁnal AbstractDocument.Content getContent();
synchronized
protected ﬁnal Thread getCur rentWriter();
javax.swing.
text
javax.swing.text.AbstractDocument
Chapter 30 – The javax.swing.text Package
581

protected void inser tUpdate(AbstractDocument.DefaultDocumentEvent chng, AttributeSet attr);
protected void postRemoveUpdate(AbstractDocument.DefaultDocumentEvent chng);
empty
protected void removeUpdate(AbstractDocument.DefaultDocumentEvent chng);
synchronized
protected ﬁnal void writeLock();
synchronized
protected ﬁnal void writeUnlock();
// Protected Instance Fields
protected javax.swing.e vent.EventListenerList listenerList;
}
Hierar chy: Object→AbstractDocument(Document, Serializable)
Subc lasses: DefaultStyledDocument, PlainDocument
AbstractDocument.AbstractElement
Ja va 1.2
javax.swing .text
serializable
This abstract class is a partial implementation of the Element inter face. Document objects
derived from AbstractDocument ar e composed of Element objects derived from AbstractDoc-
ument.AbstractElement. In addition to implementing Element, this class also implements the
MutableAttributeSet inter face, so it can serve as its own attribute set. And it implements
the TreeNode inter face, which can make it easy to display the element structure of an
AbstractDocument using the JTree component (a useful debugging technique). Applications
typically do not use or subclass this class. See also the BranchElement and LeafElement
subclasses, both of which are also inner classes of AbstractDocument.
public abstract class AbstractDocument.AbstractElement implements javax.swing.text.Element,
MutableAttributeSet, Serializable, javax.swing .tree.TreeNode {
// Public Constructors
public AbstractElement(javax.swing .text.Element parent, AttributeSet a);
// Public Instance Methods
public void dump(java.io.PrintStream psOut, int indentAmount);
// Methods Implementing AttributeSet
public boolean containsAttribute(Object name, Object value);
public boolean containsAttributes(AttributeSet attrs);
public AttributeSet copyAttributes();
public Object getAttribute(Object attrName);
public int getAttributeCount();
public java.util.Enumeration getAttributeNames();
public AttributeSet getResolveParent();
public boolean isDeﬁned(Object attrName);
public boolean isEqual(AttributeSet attr);
// Methods Implementing Element
public AttributeSet getAttributes();
public Document getDocument();
public abstract javax.swing.text.Element getElement(int index);
public abstract int getElementCount();
public abstract int getElementIndex(int offset);
public abstract int getEndOffset();
public String getName();
public javax.swing.text.Element getParentElement();
public abstract int getStar tOffset();
public abstract boolean isLeaf();
// Methods Implementing MutableAttributeSet
public void addAttribute(Object name, Object value);
public void addAttributes(AttributeSet attr);
public void removeAttribute(Object name);
public void removeAttributes(AttributeSet attrs);
public void removeAttributes(java.util.Enumeration names);
javax.swing.text.AbstractDocument
582 Chapter 30 – The javax.swing.text Package

public void setResolveParent(AttributeSet parent);
// Methods Implementing TreeNode
public abstract java.util.Enumeration children();
public abstract boolean getAllowsChildren();
public javax.swing.tree.TreeNode getChildAt(int childIndex);
public int getChildCount();
public int getIndex(javax.swing .tree.TreeNode node);
public javax.swing.tree.TreeNode getParent();
// Protected Methods Overriding Object
protected void ﬁnalize() throws Throwable;
}
Subc lasses: AbstractDocument.BranchElement, AbstractDocument.LeafElement
Retur ned By: DefaultStyledDocument.createDefaultRoot(), PlainDocument.createDefaultRoot(),
javax.swing .text.html.HTMLDocument.createDefaultRoot()
AbstractDocument.AttributeContext
Ja va 1.2
javax.swing .text
This interface deﬁnes methods that accept an immutable AttributeSet argument and
retur n another immutable AttributeSet object. These methods can be used to implement
the MutableAttributeSet inter face entir ely in terms of immutable AttributeSet objects. Most
documents frequently reuse a small set of common attribute sets. The use of immutable
AttributeSet objects is desirable because they may be cached and shared, resulting in
substantial memory savings. JTextComponent uses the attribute set caching technique by
default, and typical applications never need to use or implement this interface. See
StyleContext for a concrete implementation of this interface.
public abstract static interface AbstractDocument.AttributeContext {
// Public Instance Methods
public abstract AttributeSet addAttribute(AttributeSet old, Object name, Object value);
public abstract AttributeSet addAttributes(AttributeSet old, AttributeSet attr);
public abstract AttributeSet getEmptySet();
public abstract void reclaim(AttributeSet a);
public abstract AttributeSet removeAttribute(AttributeSet old, Object name);
public abstract AttributeSet removeAttributes(AttributeSet old, AttributeSet attrs);
public abstract AttributeSet removeAttributes(AttributeSet old, java.util.Enumeration names);
}
Implementations: StyleContext
Passed To: AbstractDocument.AbstractDocument()
Retur ned By: AbstractDocument.getAttributeContext()
AbstractDocument.BranchElement
Ja va 1.2
javax.swing .text
serializable
This class is an Element implementation suitable for Document elements that contain other
elements (e.g., paragraph elements).
public class AbstractDocument.BranchElement extends AbstractDocument.AbstractElement {
// Public Constructors
public BranchElement(javax.swing .text.Element parent, AttributeSet a);
// Public Instance Methods
public javax.swing.text.Element positionToElement(int pos);
public void replace(int offset, int length, javax.swing .text.Element[ ] elems);
javax.swing.
text
javax.swing.text.AbstractDocument.BranchElement
Chapter 30 – The javax.swing.text Package
583

// Public Methods Overriding AbstractDocument.AbstractElement
public java.util.Enumeration children();
constant
public boolean getAllowsChildren();
public javax.swing.text.Element getElement(int index);
public int getElementCount();
public int getElementIndex(int offset);
public int getEndOffset();
public String getName();
public int getStar tOffset();
constant
public boolean isLeaf();
// Public Methods Overriding Object
public String toString();
}
Subc lasses: DefaultStyledDocument.SectionElement, javax.swing .text.html.HTMLDocument.BlockElement
AbstractDocument.Content
Ja va 1.2
javax.swing .text
This interface deﬁnes an abstract repr esentation of an editable piece of text. An Abstract-
Document.Content object is used to repr esent the contents of any Document derived from
AbstractDocument. A Content implementation must be able to retur n arbitrary text seg-
ments, insert and delete text, and retur n Position objects that mark positions within the
content. If the Content implementation allows undo operations, the inser tString() method
should retur n an UndoableEdit object; otherwise it should retur n null. Applications typi-
cally do not use or implement this interface. See StringContent and GapContent for two
implementations.
public abstract static interface AbstractDocument.Content {
// Public Instance Methods
public abstract Position createPosition(int offset) throws BadLocationException;
public abstract void getChars(int where, int len, Segment txt) throws BadLocationException;
public abstract String getString(int where, int len) throws BadLocationException;
public abstract javax.swing.undo.UndoableEdit inser tString(int where, String str) throws BadLocationException;
public abstract int length();
public abstract javax.swing.undo.UndoableEdit remove(int where, int nitems) throws BadLocationException;
}
Implementations: GapContent, StringContent
Passed To: AbstractDocument.AbstractDocument(), DefaultStyledDocument.DefaultStyledDocument(),
PlainDocument.PlainDocument(), javax.swing .text.html.HTMLDocument.HTMLDocument()
Retur ned By: AbstractDocument.getContent()
AbstractDocument.DefaultDocumentEvent
Ja va 1.2
javax.swing .text
serializable
This class is the javax.swing .event.DocumentEvent implementation used by documents
derived from AbstractDocument. It is also an UndoableEdit and therefor e can be used with
the undo architectur e of javax.swing .undo.
public class AbstractDocument.DefaultDocumentEvent extends javax.swing.undo.CompoundEdit
implements javax.swing.e vent.DocumentEvent {
// Public Constructors
public DefaultDocumentEvent(int offs, int len, javax.swing .event.DocumentEvent.EventType type);
// Methods Implementing DocumentEvent
public javax.swing.e vent.DocumentEvent.ElementChange getChange(javax.swing .text.Element elem);
javax.swing.text.AbstractDocument.BranchElement
584 Chapter 30 – The javax.swing.text Package

public Document getDocument();
public int getLength();
public int getOffset();
public javax.swing.e vent.DocumentEvent.EventType getType();
// Public Methods Overriding CompoundEdit
public boolean addEdit(javax.swing .undo.UndoableEdit anEdit);
public String getPresentationName();
public String getRedoPresentationName();
public String getUndoPresentationName();
constant
public boolean isSigniﬁcant();
public void redo() throws javax.swing.undo.CannotRedoException;
public String toString();
public void undo() throws javax.swing.undo.CannotUndoException;
}
Passed To: AbstractDocument.{inser tUpdate(), postRemoveUpdate(), removeUpdate()},
DefaultStyledDocument.{inser tUpdate(), removeUpdate()}, DefaultStyledDocument.ElementBuffer.{change(),
inser t(), remove()}, PlainDocument.{insertUpdate(), removeUpdate()},
javax.swing .text.html.HTMLDocument.insertUpdate()
AbstractDocument.ElementEdit
Ja va 1.2
javax.swing .text
serializable
This class is the implementation of DocumentEvent.ElementEdit used by AbstractDocument.
public static class AbstractDocument.ElementEdit extends javax.swing.undo.AbstractUndoableEdit
implements javax.swing.e vent.DocumentEvent.ElementChange {
// Public Constructors
public ElementEdit(javax.swing .text.Element e, int index, javax.swing .text.Element[ ] removed,
javax.swing .text.Element[ ] added);
// Methods Implementing DocumentEvent.ElementChange
public javax.swing.text.Element[ ] getChildrenAdded();
public javax.swing.text.Element[ ] getChildrenRemoved();
public javax.swing.text.Element getElement();
public int getIndex();
// Public Methods Overriding AbstractUndoableEdit
public void redo() throws javax.swing.undo.CannotRedoException;
public void undo() throws javax.swing.undo.CannotUndoException;
}
AbstractDocument.LeafElement
Ja va 1.2
javax.swing .text
serializable
This class is an Element implementation suitable for Document elements that do not con-
tain children elements (e.g., runs of styled text).
public class AbstractDocument.LeafElement extends AbstractDocument.AbstractElement {
// Public Constructors
public LeafElement(javax.swing .text.Element parent, AttributeSet a, int offs0, int offs1);
// Public Methods Overriding AbstractDocument.AbstractElement
constant
public java.util.Enumeration children();
constant
public boolean getAllowsChildren();
constant
public javax.swing.text.Element getElement(int index);
constant
public int getElementCount();
constant
public int getElementIndex(int pos);
public int getEndOffset();
public String getName();
public int getStar tOffset();
javax.swing.
text
javax.swing.text.AbstractDocument.LeafElement
Chapter 30 – The javax.swing.text Package
585

constant
public boolean isLeaf();
// Public Methods Overriding Object
public String toString();
}
Subc lasses: javax.swing .text.html.HTMLDocument.RunElement
AbstractWriter
Ja va 1.2
javax.swing .text
This abstract class provides a simple but convenient starting place for applications that
want to write a textual repr esentation of a Document or Element tr ee. The abstract write()
method must be implemented by a subclass. This method must iterate over the Docu-
ment or Element tr ee (using the ElementIterator pr ovided by getElementIterator()) and write
out a textual description of the Element objects using the other methods of the class.
Applications do not typically use or subclass this class.
public abstract class AbstractWriter {
// Protected Constructors
protected AbstractWriter(java.io.Writer w, javax.swing .text.Element root);
protected AbstractWriter(java.io.Writer w, Document doc);
protected AbstractWriter(java.io.Writer w, javax.swing .text.Element root, int pos, int len);
protected AbstractWriter(java.io.Writer w, Document doc, int pos, int len);
// Protected Constants
=’\12’
protected static ﬁnal char NEWLINE;
// Protected Instance Methods
protected void decrIndent();
protected Document getDocument();
protected ElementIterator getElementIterator();
protected String getText(javax.swing .text.Element elem) throws BadLocationException;
protected void incrIndent();
protected void indent() throws java.io.IOException;
protected boolean inRange(javax.swing .text.Element next);
protected void setIndentSpace(int space);
protected void setLineLength(int l);
protected void text(javax.swing .text.Element elem) throws BadLocationException, java.io.IOException;
protected abstract void write() throws java.io.IOException, BadLocationException;
protected void write(String str) throws java.io.IOException;
protected void write(char ch) throws java.io.IOException;
protected void writeAttributes(AttributeSet attr) throws java.io.IOException;
}
Subc lasses: javax.swing .text.html.HTMLWriter, javax.swing .text.html.MinimalHTMLWriter
AttributeSet
Ja va 1.2
javax.swing .text
This interface deﬁnes the basic methods requir ed for a set of attributes. It deﬁnes a
mapping from attribute names, or keys, to attribute values. Both keys and values can
be arbitrary objects. The StyleConstants class deﬁnes a number of commonly used
attribute keys. The AttributeSet inter face deﬁnes four inner interfaces. These empty inter-
faces serve as marker interfaces and should be implemented by an attribute key object
to specify the general category of the key.
An AttributeSet can have another AttributeSet as its parent. When you look up a value
with getAttribute(), the local mappings are searched ﬁrst. If no matching attribute is found
locally, however, the search continues (recursively) on the parent AttributeSet. The
par ent attribute set is itself stored as an attribute, using the key deﬁned by the
javax.swing.text.AbstractDocument.LeafElement
586 Chapter 30 – The javax.swing.text Package

ResolveAttribute constant. Call getResolveParent() to query the parent AttributeSet. The isDe-
ﬁned() and getAttributeNames() methods operate only on the local attribute mappings and
do not use the parent AttributeSet.
See also MutableAttributeSet, SimpleAttributeSet, Style, and StyleConstants.
public abstract interface AttributeSet {
// Public Constants
public static ﬁnal Object NameAttribute;
public static ﬁnal Object ResolveAttribute;
// Inner Classes
public abstract static interface CharacterAttribute;
public abstract static interface ColorAttribute;
public abstract static interface FontAttribute;
public abstract static interface ParagraphAttribute;
// Public Instance Methods
public abstract boolean containsAttribute(Object name, Object value);
public abstract boolean containsAttributes(AttributeSet attributes);
public abstract AttributeSet copyAttributes();
public abstract Object getAttribute(Object key);
public abstract int getAttributeCount();
public abstract java.util.Enumeration getAttributeNames();
public abstract AttributeSet getResolveParent();
public abstract boolean isDeﬁned(Object attrName);
public abstract boolean isEqual(AttributeSet attr);
}
Implementations: MutableAttributeSet, StyleContext.SmallAttributeSet
Passed To: Too many methods to list.
Retur ned By: Too many methods to list.
Type Of: DefaultStyledDocument.AttributeUndoableEdit.{copy, newAttributes}, SimpleAttributeSet.EMPTY
AttributeSet.CharacterAttribute
Ja va 1.2
javax.swing .text
This marker interface should be implemented by any object that serves as the key for a
character attribute.
public abstract static interface AttributeSet.CharacterAttribute {
}
Implementations: StyleConstants.CharacterConstants, StyleConstants.ColorConstants,
StyleConstants.FontConstants
AttributeSet.ColorAttribute
Ja va 1.2
javax.swing .text
This marker interface should be implemented by any object that serves as the key for a
color attribute.
public abstract static interface AttributeSet.ColorAttribute {
}
Implementations: StyleConstants.ColorConstants
javax.swing.
text
javax.swing.text.Attr ibuteSet.ColorAttr ibute
Chapter 30 – The javax.swing.text Package
587

AttributeSet.FontAttribute
Ja va 1.2
javax.swing .text
This marker interface should be implemented by any object that serves as the key for a
font attribute.
public abstract static interface AttributeSet.FontAttribute {
}
Implementations: StyleConstants.FontConstants
AttributeSet.ParagraphAttribute
Ja va 1.2
javax.swing .text
This marker interface should be implemented by any object that serves as the key for a
paragraph attribute.
public abstract static interface AttributeSet.ParagraphAttribute {
}
Implementations: StyleConstants.ParagraphConstants
BadLocationException
Ja va 1.2
javax.swing .text
serializable checked
Thr own by methods throughout javax.swing .text when they are passed a document posi-
tion that does not exist.
public class BadLocationException extends Exception {
// Public Constructors
public BadLocationException(String s, int offs);
// Public Instance Methods
public int offsetRequested();
}
Hierar chy: Object→Throwable(Serializable)→Exception→BadLocationException
Thrown By: Too many methods to list.
BoxV iew
Ja va 1.2
javax.swing .text
This class is a CompositeV iew that arranges its children into a row or a column.
public class BoxV iew extends CompositeVie w {
// Public Constructors
public BoxV iew(javax.swing .text.Element elem, int axis);
// Public Instance Methods
public ﬁnal int getHeight();
public ﬁnal int getW idth();
// Public Methods Overriding CompositeView
public java.awt.Shape getChildAllocation(int index, java.awt.Shape a);
public java.awt.Shape modelToV iew(int pos, java.awt.Shape a, Position.Bias b) throws BadLocationException;
public void replace(int offset, int length, Vie w[ ] elems);
public int viewToModel(ﬂoat x, ﬂoat y, java.awt.Shape a, Position.Bias[ ] bias);
// Protected Methods Overriding CompositeView
protected void childAllocation(int index, java.awt.Rectangle alloc);
protected boolean ﬂipEastAndWestAtEnds(int position, Position.Bias bias);
protected Vie w getV iewAtPoint(int x, int y, java.awt.Rectangle alloc);
protected boolean isAfter(int x, int y, java.awt.Rectangle innerAlloc);
javax.swing.text.Attr ibuteSet.FontAttr ibute
588 Chapter 30 – The javax.swing.text Package

protected boolean isBefore(int x, int y, java.awt.Rectangle innerAlloc);
// Public Methods Overriding View
public ﬂoat getAlignment(int axis);
public ﬂoat getMaximumSpan(int axis);
public ﬂoat getMinimumSpan(int axis);
public ﬂoat getPrefer redSpan(int axis);
public int getResizeWeight(int axis);
public void paint(java.awt.Graphics g, java.awt.Shape allocation);
public void preferenceChanged(V iew child, boolean width, boolean height);
public void setSize(ﬂoat width, ﬂoat height);
// Protected Instance Methods
protected void baselineLayout(int targetSpan, int axis, int[ ] offsets, int[ ] spans);
protected SizeRequirements baselineRequirements(int axis, SizeRequirements r);
protected SizeRequirements calculateMajorAxisRequirements(int axis, SizeRequirements r);
protected SizeRequirements calculateMinorAxisRequirements(int axis, SizeRequirements r);
protected ﬁnal int getOffset(int axis, int childIndex);
protected ﬁnal int getSpan(int axis, int childIndex);
protected boolean isAllocationValid();
protected void layout(int width, int height);
protected void layoutMajorAxis(int targetSpan, int axis, int[ ] offsets, int[ ] spans);
protected void layoutMinorAxis(int targetSpan, int axis, int[ ] offsets, int[ ] spans);
protected void paintChild(java.awt.Graphics g, java.awt.Rectangle alloc, int index);
}
Hierar chy: Object→View(SwingConstants)→CompositeV iew→BoxV iew
Subc lasses: javax.swing .text.ParagraphV iew, TableV iew, TableV iew.TableCell, TableV iew.TableRow,
WrappedPlainV iew, javax.swing .text.html.BlockView
Caret
Ja va 1.2
javax.swing .text
This interface deﬁnes the methods that must be implemented by a class that wants to
keep track of the insertion cursor position and draw the insertion cursor for a JTextCom-
ponent. In the nomenclature of text editing, the dot is the current insertion position, and
the mark is some other position in the text. The text between the dot and the mark is
implicitly selected, and certain editing commands operate on this text. The setDot()
method sets the position of both the dot and the mark, while moveDot() sets the position
of the dot, leaving the mark where it is. The paint() method is called when the insertion
cursor needs to be drawn or redrawn. setBlinkRate() speciﬁes how often the cursor
should blink. If the cursor does blink, Caret is responsible for causing this blinking;
paint() is not automatically called to implement blinking. The Caret should notify any
register ed ChangeListener objects when the position of the cursor changes.
Although the Caret inter face allows the appearance and behavior of the JTextComponent
cursor to be customized, it is uncommon to do this. Most applications are per fectly
content to use DefaultCaret, which is the Caret implementation installed by all the stan-
dard look-and-feels.
public abstract interface Caret {
// Event Registration Methods (by event name)
public abstract void addChangeListener(javax.swing .event.ChangeListener l);
public abstract void removeChangeListener(javax.swing .event.ChangeListener l);
// Property Accessor Methods (by property name)
public abstract int getBlinkRate();
public abstract void setBlinkRate(int rate);
public abstract int getDot();
public abstract void setDot(int dot);
javax.swing.
text
javax.swing.text.Caret
Chapter 30 – The javax.swing.text Package
589

public abstract java.awt.Point getMagicCaretPosition();
public abstract void setMagicCaretPosition(java.awt.Point p);
public abstract int getMark();
public abstract boolean isSelectionV isible();
public abstract void setSelectionV isible(boolean v);
public abstract boolean isV isible();
public abstract void setV isible(boolean v);
// Public Instance Methods
public abstract void deinstall(JTextComponent c);
public abstract void install(JTextComponent c);
public abstract void moveDot(int dot);
public abstract void paint(java.awt.Graphics g);
}
Implementations: DefaultCaret
Passed To: JTextComponent.setCaret()
Retur ned By: DefaultEditorKit.createCaret(), EditorKit.createCaret(), JTextComponent.getCaret()
ChangedCharSetException
Ja va 1.2
javax.swing .text
serializable checked
This subclass of IOException is thrown by the read() method of an EditorKit when it reads a
document that it expects to be encoded in a given character set and ﬁnds that the doc-
ument speciﬁes that it is encoded using some other character set. Typically, this hap-
pens when reading HTML documents that specify their encoding using a <META> tag.
public class ChangedCharSetException extends java.io.IOException {
// Public Constructors
public ChangedCharSetException(String charSetSpec, boolean charSetKey);
// Public Instance Methods
public String getCharSetSpec();
public boolean keyEqualsCharSet();
}
Hierar chy: Object→Throwable(Serializable)→Exception→java.io.IOException→
ChangedCharSetException
Thrown By: javax.swing .text.html.parser.DocumentParser.handleEmptyTag(),
javax.swing .text.html.parser.Parser.{handleEmptyTag(), startTag()}
ComponentV iew
Ja va 1.2
javax.swing .text
This class is a View that encapsulates a Component and allows it to be displayed within a
Document.
public class ComponentV iew extends Vie w {
// Public Constructors
public ComponentV iew(javax.swing .text.Element elem);
// Public Instance Methods
public ﬁnal Component getComponent();
// Public Methods Overriding View
public ﬂoat getAlignment(int axis);
public ﬂoat getMaximumSpan(int axis);
public ﬂoat getMinimumSpan(int axis);
public ﬂoat getPrefer redSpan(int axis);
public java.awt.Shape modelToV iew(int pos, java.awt.Shape a, Position.Bias b) throws BadLocationException;
javax.swing.text.Caret
590 Chapter 30 – The javax.swing.text Package

public void paint(java.awt.Graphics g, java.awt.Shape a);
public void setParent(V iew p);
public void setSize(ﬂoat width, ﬂoat height);
public int viewToModel(ﬂoat x, ﬂoat y, java.awt.Shape a, Position.Bias[ ] bias);
// Protected Instance Methods
protected Component createComponent();
}
Hierar chy: Object→View(SwingConstants)→ComponentV iew
Subc lasses: javax.swing .text.html.FormV iew, javax.swing .text.html.ObjectView
CompositeV iew
Ja va 1.2
javax.swing .text
This abstract class is a View that can have children.
public abstract class CompositeV iew extends Vie w {
// Public Constructors
public CompositeV iew(javax.swing .text.Element elem);
// Public Instance Methods
public void append(V iew v);
public void inser t(int offs, Vie w v);
public void removeAll();
public void replace(int offset, int length, Vie w[ ] views);
// Public Methods Overriding View
public void changedUpdate(javax.swing .event.DocumentEvent e, java.awt.Shape a, Vie wFactory f);
public java.awt.Shape getChildAllocation(int index, java.awt.Shape a);
public int getNextV isualPositionFrom(int pos, Position.Bias b, java.awt.Shape a, int direction,
Position.Bias[ ] biasRet) throws BadLocationException;
public Vie w getV iew(int n);
public int getV iewCount();
public void inser tUpdate(javax.swing .event.DocumentEvent e, java.awt.Shape a, Vie wFactory f);
public java.awt.Shape modelToV iew(int pos, java.awt.Shape a, Position.Bias b) throws BadLocationException;
public java.awt.Shape modelToV iew(int p0, Position.Bias b0, int p1, Position.Bias b1, java.awt.Shape a)
throws BadLocationException;
public void removeUpdate(javax.swing .event.DocumentEvent e, java.awt.Shape a, Vie wFactory f);
public void setParent(V iew parent);
public int viewToModel(ﬂoat x, ﬂoat y, java.awt.Shape a, Position.Bias[ ] bias);
// Protected Instance Methods
protected abstract void childAllocation(int index, java.awt.Rectangle a);
constant
protected boolean ﬂipEastAndWestAtEnds(int position, Position.Bias bias);
protected ﬁnal short getBottomInset();
protected java.awt.Rectangle getInsideAllocation(java.awt.Shape a);
protected ﬁnal short getLeftInset();
protected int getNextEastWestV isualPositionFrom(int pos, Position.Bias b, java.awt.Shape a, int direction,
Position.Bias[ ] biasRet) throws BadLocationException;
protected int getNextNor thSouthVisualPositionFrom(int pos, Position.Bias b, java.awt.Shape a, int direction,
Position.Bias[ ] biasRet) throws BadLocationException;
protected ﬁnal short getRightInset();
protected ﬁnal short getTopInset();
protected abstract Vie w getV iewAtPoint(int x, int y, java.awt.Rectangle alloc);
protected Vie w getV iewAtPosition(int pos, java.awt.Rectangle a);
protected int getV iewIndexAtPosition(int pos);
protected abstract boolean isAfter(int x, int y, java.awt.Rectangle alloc);
protected abstract boolean isBefore(int x, int y, java.awt.Rectangle alloc);
protected void loadChildren(V iewFactory f);
protected ﬁnal void setInsets(shor t top, shor t left, shor t bottom, shor t right);
javax.swing.
text
javax.swing.text.CompositeView
Chapter 30 – The javax.swing.text Package
591

protected ﬁnal void setParagraphInsets(AttributeSet attr);
}
Hierar chy: Object→View(SwingConstants)→CompositeV iew
Subc lasses: BoxV iew
DefaultCaret
Ja va 1.2
javax.swing .text
cloneable serializable shape
This is the default Caret implementation installed on all JTextComponent components by all
of the standard look-and-feel implementations. It displays the caret as a thin vertical
line between characters. Most applications do not have to use this class directly and
can simply rely on its automatic use by JTextComponent.
public class DefaultCaret extends java.awt.Rectangle implements Caret, java.awt.e vent.FocusListener,
java.awt.e vent.MouseListener, java.awt.e vent.MouseMotionListener {
// Public Constructors
public DefaultCaret();
// Event Registration Methods (by event name)
Implements:Caret
public void addChangeListener(javax.swing .event.ChangeListener l);
Implements:Caret
public void removeChangeListener(javax.swing .event.ChangeListener l);
// Methods Implementing Caret
public void addChangeListener(javax.swing .event.ChangeListener l);
public void deinstall(JTextComponent c);
default:0
public int getBlinkRate();
default:0
public int getDot();
default:null
public java.awt.Point getMagicCaretPosition();
default:0
public int getMark();
public void install(JTextComponent c);
default:false
public boolean isSelectionV isible();
default:false
public boolean isV isible();
public void moveDot(int dot);
public void paint(java.awt.Graphics g);
public void removeChangeListener(javax.swing .event.ChangeListener l);
public void setBlinkRate(int rate);
public void setDot(int dot);
public void setMagicCaretPosition(java.awt.Point p);
public void setSelectionV isible(boolean vis);
public void setV isible(boolean e);
// Methods Implementing FocusListener
public void focusGained(java.awt.e vent.FocusEvent e);
public void focusLost(java.awt.e vent.FocusEvent e);
// Methods Implementing MouseListener
public void mouseClicked(java.awt.e vent.MouseEvent e);
empty
public void mouseEntered(java.awt.e vent.MouseEvent e);
empty
public void mouseExited(java.awt.e vent.MouseEvent e);
public void mousePressed(java.awt.e vent.MouseEvent e);
empty
public void mouseReleased(java.awt.e vent.MouseEvent e);
// Methods Implementing MouseMotionListener
public void mouseDragged(java.awt.e vent.MouseEvent e);
empty
public void mouseMoved(java.awt.e vent.MouseEvent e);
// Public Methods Overriding Rectangle
public boolean equals(Object obj);
public String toString();
// Protected Instance Methods
protected void adjustV isibility(java.awt.Rectangle nloc);
synchronized
protected void damage(java.awt.Rectangle r);
javax.swing.text.CompositeView
592 Chapter 30 – The javax.swing.text Package

protected void ﬁreStateChanged();
protected ﬁnal JTextComponent getComponent();
protected Highlighter.HighlightPainter getSelectionPainter();
protected void moveCaret(java.awt.e vent.MouseEvent e);
protected void positionCaret(java.awt.e vent.MouseEvent e);
synchronized
protected ﬁnal void repaint();
// Protected Instance Fields
protected transient javax.swing.e vent.ChangeEvent changeEvent;
protected javax.swing.e vent.EventListenerList listenerList;
}
Hierar chy: Object→java.awt.geom.RectangularShape(Cloneable, java.awt.Shape)→
java.awt.geom.Rectangle2D→java.awt.Rectangle(Serializable, java.awt.Shape)→DefaultCaret(Caret,
java.awt.event.FocusListener(java.util.EventListener), java.awt.event.MouseListener(java.util.EventListener),
java.awt.event.MouseMotionListener(java.util.EventListener))
DefaultEditorKit
Ja va 1.2
javax.swing .text
cloneable serializable
This class is an EditorKit for plain text. You can conﬁgure a JEditorPane to display plain,
unfor matted text using an instance of this class. The actions deﬁned by this class are
used by default by JTextComponent. DefaultEditorKit deﬁnes a number of String constants,
which it uses as the names of the various Action objects it retur ns fr om its getActions()
method.
public class DefaultEditorKit extends EditorKit {
// Public Constructors
public DefaultEditorKit();
// Public Constants
="caret-backward"
public static ﬁnal String backwardAction;
="beep"
public static ﬁnal String beepAction;
="caret-begin"
public static ﬁnal String beginAction;
="caret-begin-line"
public static ﬁnal String beginLineAction;
="caret-begin-paragraph"
public static ﬁnal String beginParagraphAction;
="caret-begin-word"
public static ﬁnal String beginWordAction;
="copy-to-clipboard"
public static ﬁnal String copyAction;
="cut-to-clipboard"
public static ﬁnal String cutAction;
="default-typed"
public static ﬁnal String defaultKeyTypedAction;
="delete-next"
public static ﬁnal String deleteNextCharAction;
="delete-previous"
public static ﬁnal String deletePrevCharAction;
="caret-down"
public static ﬁnal String downAction;
="caret-end"
public static ﬁnal String endAction;
="caret-end-line"
public static ﬁnal String endLineAction;
="__EndOfLine__"
public static ﬁnal String EndOfLineStringProper ty;
="caret-end-paragraph"
public static ﬁnal String endParagraphAction;
="caret-end-word"
public static ﬁnal String endWordAction;
="caret-forward"
public static ﬁnal String forwardAction;
="inser t-break"
public static ﬁnal String inser tBreakAction;
="inser t-content"
public static ﬁnal String inser tContentAction;
="inser t-tab"
public static ﬁnal String inser tTabAction;
="caret-next-word"
public static ﬁnal String nextWordAction;
="page-down"
public static ﬁnal String pageDownAction;
="page-up"
public static ﬁnal String pageUpAction;
="paste-from-clipboard"
public static ﬁnal String pasteAction;
="caret-previous-word"
public static ﬁnal String previousWordAction;
="set-read-only"
public static ﬁnal String readOnlyAction;
="select-all"
public static ﬁnal String selectAllAction;
="selection-backward"
public static ﬁnal String selectionBackwardAction;
javax.swing.
text
javax.swing.text.DefaultEditorKit
Chapter 30 – The javax.swing.text Package
593

="selection-begin"
public static ﬁnal String selectionBeginAction;
="selection-begin-line"
public static ﬁnal String selectionBeginLineAction;
="selection-begin-paragraph"
public static ﬁnal String selectionBeginParagraphAction;
="selection-begin-word"
public static ﬁnal String selectionBeginWordAction;
="selection-down"
public static ﬁnal String selectionDownAction;
="selection-end"
public static ﬁnal String selectionEndAction;
="selection-end-line"
public static ﬁnal String selectionEndLineAction;
="selection-end-paragraph"
public static ﬁnal String selectionEndParagraphAction;
="selection-end-word"
public static ﬁnal String selectionEndWordAction;
="selection-forward"
public static ﬁnal String selectionForwardAction;
="selection-next-word"
public static ﬁnal String selectionNextWordAction;
="selection-previous-word"
public static ﬁnal String selectionPreviousWordAction;
="selection-up"
public static ﬁnal String selectionUpAction;
="select-line"
public static ﬁnal String selectLineAction;
="select-paragraph"
public static ﬁnal String selectParagraphAction;
="select-word"
public static ﬁnal String selectWordAction;
="caret-up"
public static ﬁnal String upAction;
="set-writable"
public static ﬁnal String writableAction;
// Inner Classes
public static class BeepAction extends TextAction;
public static class CopyAction extends TextAction;
public static class CutAction extends TextAction;
public static class DefaultKeyTypedAction extends TextAction;
public static class Inser tBreakAction extends TextAction;
public static class Inser tContentAction extends TextAction;
public static class Inser tTabAction extends TextAction;
public static class PasteAction extends TextAction;
// Public Methods Overriding EditorKit
public Object clone();
constant
public Caret createCaret();
public Document createDefaultDocument();
public Action[ ] getActions();
default:"text/plain"
public String getContentType();
constant default:null
public Vie wFactory getV iewFactor y();
public void read(java.io.Reader in, Document doc, int pos) throws java.io.IOException, BadLocationException;
public void read(java.io.InputStream in, Document doc, int pos) throws java.io.IOException, BadLocationException;
public void write(java.io.Writer out, Document doc, int pos, int len) throws java.io.IOException,
BadLocationException;
public void write(java.io.OutputStream out, Document doc, int pos, int len) throws java.io.IOException,
BadLocationException;
}
Hierar chy: Object→EditorKit(Cloneable, Serializable)→DefaultEditorKit
Subc lasses: StyledEditorKit
DefaultEditorKit.BeepAction
Ja va 1.2
javax.swing .text
cloneable serializable
This Action causes a beep.
public static class DefaultEditorKit.BeepAction extends TextAction {
// Public Constructors
public BeepAction();
// Public Methods Overriding AbstractAction
public void actionPerfor med(java.awt.e vent.ActionEvent e);
}
javax.swing.text.DefaultEditorKit
594 Chapter 30 – The javax.swing.text Package

DefaultEditorKit.CopyAction
Ja va 1.2
javax.swing .text
cloneable serializable
This action causes the selected region of the JTextComponent to be placed on the system
clipboard and made available for pasting.
public static class DefaultEditorKit.CopyAction extends TextAction {
// Public Constructors
public CopyAction();
// Public Methods Overriding AbstractAction
public void actionPerfor med(java.awt.e vent.ActionEvent e);
}
DefaultEditorKit.CutAction
Ja va 1.2
javax.swing .text
cloneable serializable
This Action deletes the selected region of the JTextComponent and makes its contents avail-
able for pasting on the system clipboard.
public static class DefaultEditorKit.CutAction extends TextAction {
// Public Constructors
public CutAction();
// Public Methods Overriding AbstractAction
public void actionPerfor med(java.awt.e vent.ActionEvent e);
}
DefaultEditorKit.DefaultKeyTypedAction
Ja va 1.2
javax.swing .text
cloneable serializable
This Action is invoked when no other action is register ed for a keystroke. It inserts the
action command string (which is usually the key that triggered the action) at the current
cursor position. Or, if ther e is currently a selection, it replaces the selected text with this
text. This is the most commonly used action in a JTextComponent, since it is used to insert
all characters the user types.
public static class DefaultEditorKit.DefaultKeyTypedAction extends TextAction {
// Public Constructors
public DefaultKeyTypedAction();
// Public Methods Overriding AbstractAction
public void actionPerfor med(java.awt.e vent.ActionEvent e);
}
DefaultEditorKit.Inser tBreakAction
Ja va 1.2
javax.swing .text
cloneable serializable
This Action inserts a new line break into the document and deletes any currently
selected text.
public static class DefaultEditorKit.Inser tBreakAction extends TextAction {
// Public Constructors
public Inser tBreakAction();
// Public Methods Overriding AbstractAction
public void actionPerfor med(java.awt.e vent.ActionEvent e);
}
javax.swing.
text
javax.swing.text.DefaultEditorKit.Inser tBreakAction
Chapter 30 – The javax.swing.text Package
595

DefaultEditorKit.Inser tContentAction
Ja va 1.2
javax.swing .text
cloneable serializable
This Action inserts the ActionEvent command string into the document at the current posi-
tion, deleting any current selection in the process.
public static class DefaultEditorKit.Inser tContentAction extends TextAction {
// Public Constructors
public Inser tContentAction();
// Public Methods Overriding AbstractAction
public void actionPerfor med(java.awt.e vent.ActionEvent e);
}
DefaultEditorKit.Inser tTabAction
Ja va 1.2
javax.swing .text
cloneable serializable
This Action inserts a horizontal tab into the document, replacing the selected text, if any.
public static class DefaultEditorKit.Inser tTabAction extends TextAction {
// Public Constructors
public Inser tTabAction();
// Public Methods Overriding AbstractAction
public void actionPerfor med(java.awt.e vent.ActionEvent e);
}
DefaultEditorKit.PasteAction
Ja va 1.2
javax.swing .text
cloneable serializable
This Action gets the current text selection from the system clipboard and pastes it into
the current document at the current insertion position, replacing any selected text.
public static class DefaultEditorKit.PasteAction extends TextAction {
// Public Constructors
public PasteAction();
// Public Methods Overriding AbstractAction
public void actionPerfor med(java.awt.e vent.ActionEvent e);
}
DefaultHighlighter
Ja va 1.2
javax.swing .text
This class is the default highlighter object used by JTextComponent to keep track of high-
lighted regions within the Document.
public class DefaultHighlighter extends LayeredHighlighter {
// Public Constructors
public DefaultHighlighter();
// Inner Classes
public static class DefaultHighlightPainter extends LayeredHighlighter.LayerPainter ;
// Public Instance Methods
default:true
public boolean getDrawsLayeredHighlights();
public void setDrawsLayeredHighlights(boolean newValue);
// Public Methods Overriding LayeredHighlighter
public Object addHighlight(int p0, int p1, Highlighter.HighlightPainter p) throws BadLocationException;
public void changeHighlight(Object tag, int p0, int p1) throws BadLocationException;
public void deinstall(JTextComponent c);
public Highlighter.Highlight[ ] getHighlights();
public void install(JTextComponent c);
javax.swing.text.DefaultEditorKit.Inser tContentAction
596 Chapter 30 – The javax.swing.text Package

public void paint(java.awt.Graphics g);
public void paintLayeredHighlights(java.awt.Graphics g, int p0, int p1, java.awt.Shape viewBounds,
JTextComponent editor, Vie w view);
public void removeAllHighlights();
public void removeHighlight(Object tag);
// Public Class Fields
public static LayeredHighlighter.LayerPainter DefaultPainter;
}
Hierar chy: Object→LayeredHighlighter(Highlighter)→DefaultHighlighter
DefaultHighlighter.DefaultHighlightPainter
Ja va 1.2
javax.swing .text
This class is the default highlight painter object used by JTextComponent to draw its high-
lighted regions. It ﬁlls the highlighted area with a solid color. By default, the color is
obtained with the getSelectionColor() method of the associated JTextComponent.
public static class DefaultHighlighter.DefaultHighlightPainter extends LayeredHighlighter.LayerPainter {
// Public Constructors
public DefaultHighlightPainter(java.awt.Color c);
// Public Instance Methods
public java.awt.Color getColor();
// Public Methods Overriding LayeredHighlighter.LayerPainter
public void paint(java.awt.Graphics g, int offs0, int offs1, java.awt.Shape bounds, JTextComponent c);
public java.awt.Shape paintLayer(java.awt.Graphics g, int offs0, int offs1, java.awt.Shape bounds,
JTextComponent c, Vie w view);
}
DefaultStyledDocument
Ja va 1.2
javax.swing .text
serializable
This class extends AbstractDocument and implements StyledDocument. It repr esents for mat-
ted text annotated with character and paragraph attributes. To insert text into a Default-
StyledDocument, use the inherited inser tString() method, specifying a document position,
the string to insert, and the AttributeSet of attributes that should be applied to the
inserted string. You can display the contents of a DefaultStyledDocument using a JTextPane
component.
public class DefaultStyledDocument extends AbstractDocument implements StyledDocument {
// Public Constructors
public DefaultStyledDocument();
public DefaultStyledDocument(StyleContext styles);
public DefaultStyledDocument(AbstractDocument.Content c, StyleContext styles);
// Public Constants
=4096
public static ﬁnal int BUFFER_SIZE_DEFAULT;
// Inner Classes
public static class AttributeUndoableEdit extends javax.swing.undo.AbstractUndoableEdit;
public class ElementBuffer implements Serializable;
public static class ElementSpec;
protected class SectionElement extends AbstractDocument.BranchElement;
// Event Registration Methods (by event name)
Implements:Document
public void addDocumentListener(javax.swing .event.DocumentListener listener);
Implements:Document
public void removeDocumentListener(javax.swing .event.DocumentListener listener);
// Public Instance Methods
public java.util.Enumeration getStyleNames();
javax.swing.
text
javax.swing.text.DefaultStyledDocument
Chapter 30 – The javax.swing.text Package
597

// Methods Implementing Document
public void addDocumentListener(javax.swing .event.DocumentListener listener);
default:SectionElement
public javax.swing.text.Element getDefaultRootElement();
public void removeDocumentListener(javax.swing .event.DocumentListener listener);
// Methods Implementing StyledDocument
public Style addStyle(String nm, Style parent);
public java.awt.Color getBackground(AttributeSet attr);
public javax.swing.text.Element getCharacterElement(int pos);
public java.awt.Font getFont(AttributeSet attr);
public java.awt.Color getForeground(AttributeSet attr);
public Style getLogicalStyle(int p);
public javax.swing.text.Element getParagraphElement(int pos);
public Style getStyle(String nm);
public void removeStyle(String nm);
public void setCharacterAttributes(int offset, int length, AttributeSet s, boolean replace);
public void setLogicalStyle(int pos, Style s);
public void setParagraphAttributes(int offset, int length, AttributeSet s, boolean replace);
// Protected Methods Overriding AbstractDocument
protected void inser tUpdate(AbstractDocument.DefaultDocumentEvent chng, AttributeSet attr);
protected void removeUpdate(AbstractDocument.DefaultDocumentEvent chng);
// Protected Instance Methods
protected void create(DefaultStyledDocument.ElementSpec[ ] data);
protected AbstractDocument.AbstractElement createDefaultRoot();
protected void inser t(int offset, DefaultStyledDocument.ElementSpec[ ] data) throws BadLocationException;
protected void styleChanged(Style style);
// Protected Instance Fields
protected DefaultStyledDocument.ElementBuffer buffer;
}
Hierar chy: Object→AbstractDocument(Document, Serializable)→
DefaultStyledDocument(StyledDocument(Document))
Subc lasses: javax.swing .text.html.HTMLDocument
DefaultStyledDocument.AttributeUndoableEdit
Ja va 1.2
javax.swing .text
serializable
This UndoableEdit implementation is used internally by DefaultStyledDocument to remember
(and undo) changes to the AttributeSet of an Element.
public static class DefaultStyledDocument.AttributeUndoableEdit extends
javax.swing .undo.AbstractUndoableEdit {
// Public Constructors
public AttributeUndoableEdit(javax.swing .text.Element element, AttributeSet newAttributes,
boolean isReplacing);
// Public Methods Overriding AbstractUndoableEdit
public void redo() throws javax.swing.undo.CannotRedoException;
public void undo() throws javax.swing.undo.CannotUndoException;
// Protected Instance Fields
protected AttributeSet copy;
protected javax.swing.text.Element element;
protected boolean isReplacing;
protected AttributeSet newAttributes;
}
javax.swing.text.DefaultStyledDocument
598 Chapter 30 – The javax.swing.text Package

DefaultStyledDocument.ElementBuffer
Ja va 1.2
javax.swing .text
serializable
This class allows insertions into an Element tr ee in the form of an array of DefaultStyled-
Document.ElementSpec objects. This is useful because a linear array of ElementSpec objects
is often easier to work with than a tree of Element objects.
public class DefaultStyledDocument.ElementBuffer implements Serializable {
// Public Constructors
public ElementBuffer(javax.swing .text.Element root);
// Public Instance Methods
public void change(int offset, int length, AbstractDocument.DefaultDocumentEvent de);
public javax.swing.text.Element clone(javax.swing .text.Element parent, javax.swing .text.Element clonee);
public javax.swing.text.Element getRootElement();
public void inser t(int offset, int length, DefaultStyledDocument.ElementSpec[ ] data,
AbstractDocument.DefaultDocumentEvent de);
public void remove(int offset, int length, AbstractDocument.DefaultDocumentEvent de);
// Protected Instance Methods
protected void changeUpdate();
protected void inser tUpdate(DefaultStyledDocument.ElementSpec[ ] data);
protected void removeUpdate();
}
Type Of: DefaultStyledDocument.buffer
DefaultStyledDocument.ElementSpec
Ja va 1.2
javax.swing .text
This class is used to repr esent the elements of a document in a ﬂat structure, instead of
a tree. An ElementSpec object repr esent a start tag, an end tag, or document content.
Arrays of ElementSpec objects can be used to repr esent a document or a portion of a
document, and these ElementSpec objects can later be converted into a tree of Element
objects. This class can be useful because it is often easier to work with an array of Ele-
mentSpec objects than with a tree of Element objects.
public static class DefaultStyledDocument.ElementSpec {
// Public Constructors
public ElementSpec(AttributeSet a, shor t type);
public ElementSpec(AttributeSet a, shor t type, int len);
public ElementSpec(AttributeSet a, shor t type, char[ ] txt, int offs, int len);
// Public Constants
=3
public static ﬁnal short ContentType;
=2
public static ﬁnal short EndTagType;
=7
public static ﬁnal short JoinFractureDirection;
=5
public static ﬁnal short JoinNextDirection;
=4
public static ﬁnal short JoinPreviousDirection;
=6
public static ﬁnal short OriginateDirection;
=1
public static ﬁnal short Star tTagType;
// Property Accessor Methods (by property name)
public char[ ] getAr ray();
public AttributeSet getAttributes();
public short getDirection();
public void setDirection(shor t direction);
public int getLength();
public int getOffset();
public short getType();
public void setType(shor t type);
javax.swing.
text
javax.swing.text.DefaultStyledDocument.ElementSpec
Chapter 30 – The javax.swing.text Package
599

// Public Methods Overriding Object
public String toString();
}
Passed To: DefaultStyledDocument.{create(), insert()}, DefaultStyledDocument.ElementBuffer.{insert(),
inser tUpdate()}, javax.swing .text.html.HTMLDocument.{create(), inser t()}
DefaultStyledDocument.SectionElement
Ja va 1.2
javax.swing .text
serializable
This protected inner class is the default root element used by DefaultStyledDocument.
Applications do not need to use or subclass this class.
protected class DefaultStyledDocument.SectionElement extends AbstractDocument.BranchElement {
// Public Constructors
public SectionElement();
// Public Methods Overriding AbstractDocument.BranchElement
public String getName();
}
DefaultTextUI
Ja va 1.2; Deprecated in Java 1.2
javax.swing .text
This class is deprecated and should not be used. As a text component UI delegate
class, it never should have been part of this package.
public abstract class DefaultTextUI extends javax.swing.plaf.basic.BasicTextUI {
// Public Constructors
public DefaultTextUI();
}
Hierar chy: javax.swing .plaf.basic.BasicTextUI→DefaultTextUI
Document
Ja va 1.2
javax.swing .text
This interface deﬁnes the fundamental methods requir ed in a class that stores document
text to be displayed and edited by a JTextComponent. The methods of this interface
requir e that a Document object be able to repr esent document content both as a linear
sequence of characters and as a tree of hierarchical Element objects. Element objects
model the document structure and are used to repr esent things like paragraphs, lines,
and runs of styled text. When a JTree component displays a Document, the Element tr ee is
used to create a tree of View objects that display the individual elements.
The getText() methods retur n text from the document, either as a String or in a supplied
Segment object. inser tString() inserts a run of text associated with the speciﬁed attributes.
remove() deletes text from the Document. The Document object must ﬁre appr opriate Docu-
mentEvent and UndoableEditEvent events when edits like these are per formed. createPosi-
tion() retur ns a Position object that repr esents a relative position in the document. The
Position refer ence remains valid even if text is inserted or deleted from the document.
The putProper ty() and getProper ty() methods allow arbitrary key/value pairs to be associ-
ated with a Document. These properties can be used to hold metainformation, such as
the author and title of the document. The TitleProper ty and StreamDescriptionProper ty con-
stants are two predeﬁned property keys. Finally, the render() method must run the speci-
ﬁed Runnable object while guaranteeing that there will not be any changes to the
document. This method is used to perfor m the potentially time-consuming document-
rendering process in a thread-safe way.
javax.swing.text.DefaultStyledDocument.ElementSpec
600 Chapter 30 – The javax.swing.text Package

See also Element, AttributeSet, Position, and Segment.
public abstract interface Document {
// Public Constants
="stream"
public static ﬁnal String StreamDescriptionProper ty;
="title"
public static ﬁnal String TitleProper ty;
// Event Registration Methods (by event name)
public abstract void addDocumentListener(javax.swing .event.DocumentListener listener);
public abstract void removeDocumentListener(javax.swing .event.DocumentListener listener);
public abstract void addUndoableEditListener(javax.swing .event.UndoableEditListener listener);
public abstract void removeUndoableEditListener(javax.swing .event.UndoableEditListener listener);
// Property Accessor Methods (by property name)
public abstract javax.swing.text.Element getDefaultRootElement();
public abstract Position getEndPosition();
public abstract int getLength();
public abstract javax.swing.text.Element[ ] getRootElements();
public abstract Position getStar tPosition();
// Public Instance Methods
public abstract Position createPosition(int offs) throws BadLocationException;
public abstract Object getProper ty(Object key);
public abstract String getText(int offset, int length) throws BadLocationException;
public abstract void getText(int offset, int length, Segment txt) throws BadLocationException;
public abstract void inser tString(int offset, String str, AttributeSet a) throws BadLocationException;
public abstract void putProper ty(Object key, Object value);
public abstract void remove(int offs, int len) throws BadLocationException;
public abstract void render(Runnable r);
}
Implementations: AbstractDocument, StyledDocument
Passed To: Too many methods to list.
Retur ned By: JTextArea.createDefaultModel(), JTextF ield.createDefaultModel(),
javax.swing .event.DocumentEvent.getDocument(), AbstractDocument.AbstractElement.getDocument(),
AbstractDocument.DefaultDocumentEvent.getDocument(), AbstractWriter.getDocument(),
DefaultEditorKit.createDefaultDocument(), EditorKit.createDefaultDocument(),
javax.swing .text.Element.getDocument(), JTextComponent.getDocument(),
StyledEditorKit.createDefaultDocument(), View.getDocument(),
javax.swing .text.html.HTMLEditorKit.createDefaultDocument()
EditorKit
Ja va 1.2
javax.swing .text
cloneable serializable
This abstract class deﬁnes the methods that are used to conﬁgure a JEditorPane to display
and edit a particular type of document. Swing contains concrete subclasses for plain
text, as well as HTML and RTF documents. To conﬁgur e a JEditorPane, instantiate an Edi-
torKit object and pass it to the setEditorKit() method of your JEditorPane.
The getContentType() method of an EditorKit retur ns the MIME type supported by the kit.
createDefaultDocument() cr eates an appropriate type of empty Document object to hold the
document. The read() and write() methods read and write document content from and to
str eams. getV iewFactor y() retur ns a ViewFactor y object for this document type. The ViewFac-
tor y is used to convert the Element objects of the document into View objects that display
the document on the screen. createCaret() retur ns a Caret object that the JEditorPane can
use to navigate the document, and getActions() retur ns an array of Action objects that the
JEditorPane can bind to keystrokes. EditorKit implementations typically deﬁne a number of
Action implementations as inner classes.
javax.swing.
text
javax.swing.text.EditorKit
Chapter 30 – The javax.swing.text Package
601

public abstract class EditorKit implements Cloneable, Serializable {
// Public Constructors
public EditorKit();
// Property Accessor Methods (by property name)
public abstract Action[ ] getActions();
public abstract String getContentType();
public abstract Vie wFactory getV iewFactor y();
// Public Instance Methods
public abstract Caret createCaret();
public abstract Document createDefaultDocument();
empty
public void deinstall(JEditorPane c);
empty
public void install(JEditorPane c);
public abstract void read(java.io.Reader in, Document doc, int pos) throws java.io.IOException,
BadLocationException;
public abstract void read(java.io.InputStream in, Document doc, int pos) throws java.io.IOException,
BadLocationException;
public abstract void write(java.io.Writer out, Document doc, int pos, int len) throws java.io.IOException,
BadLocationException;
public abstract void write(java.io.OutputStream out, Document doc, int pos, int len) throws java.io.IOException,
BadLocationException;
// Public Methods Overriding Object
public abstract Object clone();
}
Hierar chy: Object→EditorKit(Cloneable, Serializable)
Subc lasses: DefaultEditorKit
Passed To: JEditorPane.{setEditorKit(), setEditorKitForContentType()}, JTextPane.setEditorKit()
Retur ned By: JEditorPane.{createDefaultEditorKit(), createEditorKitForContentType(), getEditorKit(),
getEditorKitForContentType()}, JTextPane.createDefaultEditorKit(), javax.swing .plaf.TextUI.getEditorKit()
Element
Ja va 1.2
javax.swing .text
This interface deﬁnes the methods requir ed for objects that want to be part of a Docu-
ment object’s element tree. An Element object must keep track of its parent and its chil-
dr en. It must also know its position and the position of its children within the linear
sequence of characters that comprise the Document. Finally, an Element must be able to
retur n the set of attributes that have been applied to it. getParentElement() retur ns the par-
ent. getElementCount() and getElement() retur n the number of child elements and the speci-
ﬁed child element, respectively. getStar tOffset() and getEndOffset() retur n the start and end
positions of this element. getElementIndex() retur ns the index of the child element that
contains the speciﬁed position. getAttributes() retur ns the AttributeSet for this element.
public abstract interface Element {
// Property Accessor Methods (by property name)
public abstract AttributeSet getAttributes();
public abstract Document getDocument();
public abstract int getElementCount();
public abstract int getEndOffset();
public abstract boolean isLeaf();
public abstract String getName();
public abstract javax.swing.text.Element getParentElement();
public abstract int getStar tOffset();
javax.swing.text.EditorKit
602 Chapter 30 – The javax.swing.text Package

// Public Instance Methods
public abstract javax.swing.text.Element getElement(int index);
public abstract int getElementIndex(int offset);
}
Implementations: AbstractDocument.AbstractElement
Passed To: Too many methods to list.
Retur ned By: Too many methods to list.
Type Of: DefaultStyledDocument.AttributeUndoableEdit.element
ElementIterator
Ja va 1.2
javax.swing .text
cloneable
This class is used to perfor m a depth-ﬁrst traversal, or iteration, through a tree of Ele-
ment objects. The Element tr ee structur e should not be changed while the iteration is in
pr ogress. Note that despite its name, this class does not implement java.util.Iterator.
public class ElementIterator implements Cloneable {
// Public Constructors
public ElementIterator(javax.swing .text.Element root);
public ElementIterator(Document document);
// Public Instance Methods
public javax.swing.text.Element cur rent();
public int depth();
public javax.swing.text.Element ﬁrst();
public javax.swing.text.Element next();
public javax.swing.text.Element previous();
// Public Methods Overriding Object
synchronized
public Object clone();
}
Hierar chy: Object→ElementIterator(Cloneable)
Retur ned By: AbstractWriter.getElementIterator()
FieldV iew
Ja va 1.2
javax.swing .text
This View class displays a single line of plain text. It is used, for example, by JTextF ield.
public class FieldV iew extends PlainVie w {
// Public Constructors
public FieldV iew(javax.swing .text.Element elem);
// Public Methods Overriding PlainView
public ﬂoat getPrefer redSpan(int axis);
public void inser tUpdate(javax.swing .event.DocumentEvent changes, java.awt.Shape a, Vie wFactory f);
public java.awt.Shape modelToV iew(int pos, java.awt.Shape a, Position.Bias b) throws BadLocationException;
public void paint(java.awt.Graphics g, java.awt.Shape a);
public void removeUpdate(javax.swing .event.DocumentEvent changes, java.awt.Shape a, Vie wFactory f);
public int viewToModel(ﬂoat fx, ﬂoat fy, java.awt.Shape a, Position.Bias[ ] bias);
// Public Methods Overriding View
public int getResizeWeight(int axis);
// Protected Instance Methods
protected java.awt.Shape adjustAllocation(java.awt.Shape a);
javax.swing.
text
javax.swing.text.FieldView
Chapter 30 – The javax.swing.text Package
603

protected java.awt.FontMetrics getFontMetrics();
}
Hierar chy: Object→View(SwingConstants)→PlainV iew(TabExpander)→FieldV iew
Subc lasses: PasswordV iew
GapContent
Ja va 1.2
javax.swing .text
serializable
This class is an implementation of the AbstractDocument.Content inter face that uses an
array of characters with a gap of unused characters in it. This gap is positioned near the
curr ent insertion position so that subsequent insertions requir e fewer characters to be
shifted in the array. This implementation is more complicated than StringContent, but it
works efﬁciently with documents of any size. This is the default Content implementation
for all documents derived from AbstractDocument. This class inherits from a private super-
class, GapVector, which is not covered in this book because it is private.
public class GapContent extends GapVector implements AbstractDocument.Content, Serializable {
// Public Constructors
public GapContent();
public GapContent(int initialLength);
// Methods Implementing AbstractDocument.Content
public Position createPosition(int offset) throws BadLocationException;
public void getChars(int where, int len, Segment chars) throws BadLocationException;
public String getString(int where, int len) throws BadLocationException;
public javax.swing.undo.UndoableEdit inser tString(int where, String str) throws BadLocationException;
public int length();
public javax.swing.undo.UndoableEdit remove(int where, int nitems) throws BadLocationException;
// Protected Instance Methods
protected Object allocateAr ray(int len);
protected int getAr rayLength();
protected java.util.Vector getPositionsInRange(java.util.Vector v, int offset, int length);
protected void resetMarksAtZero();
protected void shiftEnd(int newSize);
protected void shiftGap(int newGapStar t);
protected void shiftGapEndUp(int newGapEnd);
protected void shiftGapStar tDown(int newGapStar t);
protected void updateUndoPositions(java.util.Vector positions, int offset, int length);
}
Hierar chy: Object→GapVector(Serializable)→GapContent(AbstractDocument.Content, Serializable)
Highlighter
Ja va 1.2
javax.swing .text
This interface deﬁnes the methods that must be implemented by an object that wants to
maintain and draw the list of selected regions within a JTextComponent. The methods of
Highlighter allow selected regions to be added, changed, and removed for the set of
highlighted regions. Each region is speciﬁed as a start and end position within the Docu-
ment and a Highlighter.HighlightPainter object that is used to draw the highlight. The getHigh-
lights() method retur ns an array of Highlighter.Highlight objects that describe the individual
highlighted regions and their painter objects. Most applications can rely on the DefaultH-
ighlighter class that is used by default by JTextComponent and never have to implement this
inter face.
javax.swing.text.FieldView
604 Chapter 30 – The javax.swing.text Package

public abstract interface Highlighter {
// Inner Classes
public abstract static interface Highlight;
public abstract static interface HighlightPainter;
// Public Instance Methods
public abstract Object addHighlight(int p0, int p1, Highlighter.HighlightPainter p) throws BadLocationException;
public abstract void changeHighlight(Object tag, int p0, int p1) throws BadLocationException;
public abstract void deinstall(JTextComponent c);
public abstract Highlighter.Highlight[ ] getHighlights();
public abstract void install(JTextComponent c);
public abstract void paint(java.awt.Graphics g);
public abstract void removeAllHighlights();
public abstract void removeHighlight(Object tag);
}
Implementations: LayeredHighlighter
Passed To: JTextComponent.setHighlighter()
Retur ned By: JTextComponent.getHighlighter()
Highlighter.Highlight
Ja va 1.2
javax.swing .text
The methods of this interface describe a highlighted region in a Document by specifying
the start and end positions of the region and the Highlighter.HighlightPainter object that is
used to draw the highlighted region.
public abstract static interface Highlighter.Highlight {
// Public Instance Methods
public abstract int getEndOffset();
public abstract Highlighter.HighlightPainter getPainter();
public abstract int getStar tOffset();
}
Retur ned By: DefaultHighlighter.getHighlights(), Highlighter.getHighlights(),
LayeredHighlighter.getHighlights()
Highlighter.HighlightPainter
Ja va 1.2
javax.swing .text
This interface deﬁnes the paint() method used to draw a highlighted region.
public abstract static interface Highlighter.HighlightPainter {
// Public Instance Methods
public abstract void paint(java.awt.Graphics g, int p0, int p1, java.awt.Shape bounds, JTextComponent c);
}
Implementations: LayeredHighlighter.LayerPainter
Passed To: DefaultHighlighter.addHighlight(), Highlighter.addHighlight(), LayeredHighlighter.addHighlight()
Retur ned By: DefaultCaret.getSelectionPainter(), Highlighter.Highlight.getPainter()
IconV iew
Ja va 1.2
javax.swing .text
This View class encapsulates a javax.swing .Icon and allows icons and images to be dis-
played within a Document.
javax.swing.
text
javax.swing.text.IconView
Chapter 30 – The javax.swing.text Package
605

public class IconV iew extends Vie w {
// Public Constructors
public IconV iew(javax.swing .text.Element elem);
// Public Methods Overriding View
public ﬂoat getAlignment(int axis);
public ﬂoat getPrefer redSpan(int axis);
public java.awt.Shape modelToV iew(int pos, java.awt.Shape a, Position.Bias b) throws BadLocationException;
public void paint(java.awt.Graphics g, java.awt.Shape a);
empty
public void setSize(ﬂoat width, ﬂoat height);
public int viewToModel(ﬂoat x, ﬂoat y, java.awt.Shape a, Position.Bias[ ] bias);
}
Hierar chy: Object→View(SwingConstants)→IconV iew
JTextComponent
Ja va 1.2
javax.swing .text
serializable accessible(text) swing component
This is the base class for all Swing text-editing components. Applications do not use
this class directly, but instead use one of its subclasses in the javax.swing package:
JTextF ield, JTextArea, JPasswordF ield, JEditorPane, or JTextPane. A JTextComponent displays the text
contained in its model object, an object of type Document. Other important classes and
inter faces used by JTextComponent ar e Caret, Highlighter, Keymap, Style, EditorKit, TextAction,
and View.
public abstract class JTextComponent extends JComponent implements Accessible, Scrollable {
// Public Constructors
public JTextComponent();
// Public Constants
="default"
public static ﬁnal String DEFAULT_KEYMAP;
="focusAcceleratorKey"
public static ﬁnal String FOCUS_ACCELERATOR_KEY;
// Inner Classes
public class AccessibleJTextComponent extends JComponent.AccessibleJComponent implements AccessibleText,
javax.swing .event.CaretListener, javax.swing .event.DocumentListener ;
public static class KeyBinding;
// Public Class Methods
public static Keymap addKeymap(String nm, Keymap parent);
public static Keymap getKeymap(String nm);
public static void loadKeymap(Keymap map, JTextComponent.Ke yBinding[ ] bindings, Action[ ] actions);
public static Keymap removeKeymap(String nm);
// Event Registration Methods (by event name)
public void addCaretListener(javax.swing .event.CaretListener listener);
public void removeCaretListener(javax.swing .event.CaretListener listener);
Overrides:Component
public void addInputMethodListener(java.awt.e vent.InputMethodListener l);
// Property Accessor Methods (by property name)
Implements:Accessible
public AccessibleContext getAccessibleContext();
public Action[ ] getActions();
public Caret getCaret();
bound expert
public void setCaret(Caret c);
public java.awt.Color getCaretColor();
bound preferred
public void setCaretColor(java.awt.Color c);
public int getCaretPosition();
public void setCaretPosition(int position);
public java.awt.Color getDisabledTextColor();
bound preferred
public void setDisabledTextColor(java.awt.Color c);
public Document getDocument();
bound expert
public void setDocument(Document doc);
public boolean isEditable();
public void setEditable(boolean b);
javax.swing.text.IconView
606 Chapter 30 – The javax.swing.text Package

public char getFocusAccelerator();
bound
public void setFocusAccelerator(char aKey);
Overrides:JComponent
public boolean isFocusTraversable();
public Highlighter getHighlighter();
bound expert
public void setHighlighter(Highlighter h);
Overrides:Component
public java.awt.im.InputMethodRequests getInputMethodRequests();
public Keymap getKeymap();
bound
public void setKeymap(Keymap map);
public java.awt.Insets getMargin();
bound
public void setMargin(java.awt.Insets m);
Overrides:JComponent
public boolean isOpaque();
Overrides:JComponent
public void setOpaque(boolean o);
Implements:Scrollable
public java.awt.Dimension getPrefer redScrollableViewpor tSize();
Implements:Scrollable
public boolean getScrollableTracksV iewportHeight();
Implements:Scrollable
public boolean getScrollableTracksV iewportW idth();
public String getSelectedText();
public java.awt.Color getSelectedTextColor();
bound preferred
public void setSelectedTextColor(java.awt.Color c);
public java.awt.Color getSelectionColor();
bound preferred
public void setSelectionColor(java.awt.Color c);
public int getSelectionEnd();
public void setSelectionEnd(int selectionEnd);
public int getSelectionStar t();
public void setSelectionStar t(int selectionStar t);
public String getText();
public String getText(int offs, int len) throws BadLocationException;
public void setText(String t);
public javax.swing.plaf.TextUI getUI();
public void setUI(javax.swing .plaf.TextUI ui);
// Public Instance Methods
public void copy();
public void cut();
public java.awt.Rectangle modelToV iew(int pos) throws BadLocationException;
public void moveCaretPosition(int pos);
public void paste();
public void read(java.io.Reader in, Object desc) throws java.io.IOException;
public void replaceSelection(String content);
public void select(int selectionStar t, int selectionEnd);
public void selectAll();
public int viewToModel(java.awt.Point pt);
public void write(java.io.Writer out) throws java.io.IOException;
// Methods Implementing Accessible
public AccessibleContext getAccessibleContext();
// Methods Implementing Scrollable
public java.awt.Dimension getPrefer redScrollableViewpor tSize();
public int getScrollableBlockIncrement(java.awt.Rectangle visibleRect, int orientation, int direction);
public boolean getScrollableTracksV iewportHeight();
public boolean getScrollableTracksV iewportW idth();
public int getScrollableUnitIncrement(java.awt.Rectangle visibleRect, int orientation, int direction);
// Public Methods Overriding JComponent
public void removeNotify();
public void setEnabled(boolean b);
public void updateUI();
// Protected Methods Overriding JComponent
protected String paramString();
protected void processComponentKeyEvent(java.awt.e vent.Ke yEvent e);
// Protected Methods Overriding Component
protected void processInputMethodEvent(java.awt.e vent.InputMethodEvent e);
javax.swing.
text
javax.swing.text.JTextComponent
Chapter 30 – The javax.swing.text Package
607

// Protected Instance Methods
protected void ﬁreCaretUpdate(javax.swing .event.CaretEvent e);
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→JComponent(Serializable)→JTextComponent(Accessible, Scrollable)
Subc lasses: JEditorPane, JTextArea, JTextF ield
Passed To: Too many methods to list.
Retur ned By: DefaultCaret.getComponent(), TextAction.{getFocusedComponent(), getTextComponent()}
JTextComponent.KeyBinding
Ja va 1.2
javax.swing .text
This class encapsulates a KeyStroke and the name of an Action object. The JTextCompo-
nent.KeyBinding class is used primarily for communication between the JTextComponent and
its UI delegate object.
public static class JTextComponent.KeyBinding {
// Public Constructors
public KeyBinding(KeyStroke key, String actionName);
// Public Instance Fields
public String actionName;
public KeyStroke key;
}
Passed To: JTextComponent.loadKeymap()
Retur ned By: LookAndFeel.makeKeyBindings()
Keymap
Ja va 1.2
javax.swing .text
This interface deﬁnes the methods of an object that can map javax.swing .KeyStroke objects
to javax.swing .Action objects. A Keymap object is used to maintain the set of key bindings
for a JTextComponent. Key-to-action bindings are added to a Keymap with addAction-
ForKeyStroke(). The action bound to a given keystroke is queried with getAction(). Every
Keymap can refer to another Keymap as its parent. If getAction() cannot ﬁnd a speciﬁed
KeyStroke mapping locally, it searches (recursively) in the parent Keymap.
Ther e ar e no public implementations of the Keymap inter face, so you cannot create a
Keymap simply by calling a constructor. JTextComponent relies on a private implementation
of Keymap, however, and you can obtain an instance by calling the static addKeymap()
method of that class. Once you have initialized this Keymap with any desired bindings,
you can pass it to the setKeymap() method of any JTextComponent instance.
public abstract interface Keymap {
// Property Accessor Methods (by property name)
public abstract Action[ ] getBoundActions();
public abstract KeyStroke[ ] getBoundKeyStrokes();
public abstract Action getDefaultAction();
public abstract void setDefaultAction(Action a);
public abstract String getName();
public abstract Keymap getResolveParent();
public abstract void setResolveParent(Keymap parent);
// Public Instance Methods
public abstract void addActionForKeyStroke(KeyStroke key, Action a);
public abstract Action getAction(KeyStroke key);
javax.swing.text.JTextComponent
608 Chapter 30 – The javax.swing.text Package

public abstract KeyStroke[ ] getKeyStrokesForAction(Action a);
public abstract boolean isLocallyDeﬁned(KeyStroke key);
public abstract void removeBindings();
public abstract void removeKeyStrokeBinding(KeyStroke keys);
}
Passed To: JTextComponent.{addKeymap(), loadKeymap(), setKeymap()}, Keymap.setResolveParent()
Retur ned By: JTextComponent.{addKeymap(), getKeymap(), removeKeymap()}, Keymap.getResolveParent()
LabelV iew
Ja va 1.2
javax.swing .text
This View class displays a run of text that has a single set of character attributes, such as
colors and fonts, associated with it. It supports line breaking and tab expansion.
public class LabelV iew extends Vie w {
// Public Constructors
public LabelV iew(javax.swing .text.Element elem);
// Public Methods Overriding View
public Vie w breakV iew(int axis, int p0, ﬂoat pos, ﬂoat len);
public void changedUpdate(javax.swing .event.DocumentEvent e, java.awt.Shape a, Vie wFactory f);
public Vie w createFragment(int p0, int p1);
public ﬂoat getAlignment(int axis);
public int getBreakWeight(int axis, ﬂoat pos, ﬂoat len);
public int getNextV isualPositionFrom(int pos, Position.Bias b, java.awt.Shape a, int direction,
Position.Bias[ ] biasRet) throws BadLocationException;
public ﬂoat getPrefer redSpan(int axis);
public void inser tUpdate(javax.swing .event.DocumentEvent e, java.awt.Shape a, Vie wFactory f);
public java.awt.Shape modelToV iew(int pos, java.awt.Shape a, Position.Bias b) throws BadLocationException;
public void paint(java.awt.Graphics g, java.awt.Shape a);
public void removeUpdate(javax.swing .event.DocumentEvent changes, java.awt.Shape a, Vie wFactory f);
public int viewToModel(ﬂoat x, ﬂoat y, java.awt.Shape a, Position.Bias[ ] biasReturn);
// Public Methods Overriding Object
public String toString();
// Protected Instance Methods
protected java.awt.Font getFont();
protected java.awt.FontMetrics getFontMetrics();
protected void setProper tiesFromAttributes();
protected void setStrikeThrough(boolean s);
protected void setSubscript(boolean s);
protected void setSuperscript(boolean s);
protected void setUnder line(boolean u);
}
Hierar chy: Object→View(SwingConstants)→LabelV iew
Subc lasses: javax.swing .text.html.InlineView
LayeredHighlighter
Ja va 1.2
javax.swing .text
This abstract class is a Highlighter. Instead of implementing the abstract methods of the
Highlighter inter face, however, it adds another abstract method of its own. This new
method, paintLayeredHighlights(), is called to draw a portion of the highlight that appears
within the region deﬁned by a single View object. Typical applications can rely on the
DefaultHighlighter class that is automatically used by JTextComponent and never have to use
or implement this class.
javax.swing.
text
javax.swing.text.LayeredHighlighter
Chapter 30 – The javax.swing.text Package
609

public abstract class LayeredHighlighter implements Highlighter {
// Public Constructors
public LayeredHighlighter();
// Inner Classes
public abstract static class LayerPainter implements Highlighter.HighlightPainter ;
// Public Instance Methods
public abstract void paintLayeredHighlights(java.awt.Graphics g, int p0, int p1, java.awt.Shape viewBounds,
JTextComponent editor, Vie w view);
// Methods Implementing Highlighter
public abstract Object addHighlight(int p0, int p1, Highlighter.HighlightPainter p) throws BadLocationException;
public abstract void changeHighlight(Object tag, int p0, int p1) throws BadLocationException;
public abstract void deinstall(JTextComponent c);
public abstract Highlighter.Highlight[ ] getHighlights();
public abstract void install(JTextComponent c);
public abstract void paint(java.awt.Graphics g);
public abstract void removeAllHighlights();
public abstract void removeHighlight(Object tag);
}
Hierar chy: Object→LayeredHighlighter(Highlighter)
Subc lasses: DefaultHighlighter
LayeredHighlighter.LayerPainter
Ja va 1.2
javax.swing .text
This abstract inner class implements Highlighter.HighlightPainter and adds another abstract
method. Typical applications do not need to use or implement this class and can rely
on the DefaultHighlighter.DefaultHighlightPainter implementation.
public abstract static class LayeredHighlighter.LayerPainter implements Highlighter.HighlightPainter {
// Public Constructors
public LayerPainter();
// Public Instance Methods
public abstract java.awt.Shape paintLayer(java.awt.Graphics g, int p0, int p1, java.awt.Shape viewBounds,
JTextComponent editor, Vie w view);
// Methods Implementing Highlighter.HighlightPainter
public abstract void paint(java.awt.Graphics g, int p0, int p1, java.awt.Shape bounds, JTextComponent c);
}
Subc lasses: DefaultHighlighter.DefaultHighlightPainter
Type Of: DefaultHighlighter.DefaultPainter
MutableAttributeSet
Ja va 1.2
javax.swing .text
This interface extends AttributeSet to add methods that allow the set of attributes and
par ent attributes to be modiﬁed. See also AttributeSet and Style.
public abstract interface MutableAttributeSet extends AttributeSet {
// Public Instance Methods
public abstract void addAttribute(Object name, Object value);
public abstract void addAttributes(AttributeSet attributes);
public abstract void removeAttribute(Object name);
public abstract void removeAttributes(AttributeSet attributes);
public abstract void removeAttributes(java.util.Enumeration names);
public abstract void setResolveParent(AttributeSet parent);
}
javax.swing.text.LayeredHighlighter
610 Chapter 30 – The javax.swing.text Package

Hierar chy: (MutableAttributeSet(AttributeSet))
Implementations: AbstractDocument.AbstractElement, SimpleAttributeSet, Style
Passed To: Too many methods to list.
Retur ned By: JTextPane.getInputAttributes(), StyleContext.createLargeAttributeSet(),
StyledEditorKit.getInputAttributes(), javax.swing .text.html.HTMLEditorKit.getInputAttributes(),
javax.swing .text.html.StyleSheet.createLargeAttributeSet()
Type Of: javax.swing .text.html.HTMLDocument.HTMLReader.charAttr
ParagraphV iew
Ja va 1.2
javax.swing .text
This BoxV iew subclass displays a column of subviews, one for each row or line in the
paragraph. These rows are implemented by a private internal BoxV iew class. ParagraphV iew
handles word wrapping by breaking its views as necessary to ﬁt them into the row
views it creates. ParagraphV iew supports various paragraph-level attributes such as mar-
gins, line spacing, and ﬁrst-line indent.
public class ParagraphV iew extends BoxVie w implements TabExpander {
// Public Constructors
public ParagraphV iew(javax.swing .text.Element elem);
// Public Instance Methods
public Vie w breakV iew(int axis, ﬂoat len, java.awt.Shape a);
public int getBreakWeight(int axis, ﬂoat len);
// Methods Implementing TabExpander
public ﬂoat nextTabStop(ﬂoat x, int tabOffset);
// Public Methods Overriding BoxView
public ﬂoat getAlignment(int axis);
public void paint(java.awt.Graphics g, java.awt.Shape a);
// Protected Methods Overriding BoxView
protected SizeRequirements calculateMinorAxisRequirements(int axis, SizeRequirements r);
protected boolean ﬂipEastAndWestAtEnds(int position, Position.Bias bias);
protected void layout(int width, int height);
// Public Methods Overriding CompositeView
public void changedUpdate(javax.swing .event.DocumentEvent changes, java.awt.Shape a, Vie wFactory f);
public void inser tUpdate(javax.swing .event.DocumentEvent changes, java.awt.Shape a, Vie wFactory f);
public void removeUpdate(javax.swing .event.DocumentEvent changes, java.awt.Shape a, Vie wFactory f);
// Protected Methods Overriding CompositeView
protected int getNextNor thSouthVisualPositionFrom(int pos, Position.Bias b, java.awt.Shape a, int direction,
Position.Bias[ ] biasRet) throws BadLocationException;
protected Vie w getV iewAtPosition(int pos, java.awt.Rectangle a);
protected int getV iewIndexAtPosition(int pos);
protected void loadChildren(V iewFactory f);
// Protected Instance Methods
protected void adjustRow(ParagraphV ie w.Row r, int desiredSpan, int x);
protected int ﬁndOffsetToCharactersInString(char[ ] string, int star t);
protected int getClosestPositionTo(int pos, Position.Bias b, java.awt.Shape a, int direction,
Position.Bias[ ] biasRet, int rowIndex, int x) throws BadLocationException;
protected Vie w getLayoutV iew(int index);
protected int getLayoutV iewCount();
protected ﬂoat getPar tialSize(int star tOffset, int endOffset);
protected ﬂoat getTabBase();
protected TabSet getTabSet();
protected void setF irstLineIndent(ﬂoat ﬁ);
protected void setJustiﬁcation(int j);
protected void setLineSpacing(ﬂoat ls);
protected void setProper tiesFromAttributes();
javax.swing.
text
javax.swing.text.Parag raphView
Chapter 30 – The javax.swing.text Package
611

// Protected Instance Fields
protected int ﬁrstLineIndent;
}
Hierar chy: Object→View(SwingConstants)→CompositeV iew→BoxV iew→
javax.swing .text.ParagraphV iew(TabExpander)
Subc lasses: javax.swing .text.html.ParagraphV iew
PasswordV iew
Ja va 1.2
javax.swing .text
This view displays a single line of text in a way that is suitable for the JPasswordF ield
component.
public class PasswordV iew extends FieldV ie w {
// Public Constructors
public PasswordV iew(javax.swing .text.Element elem);
// Public Methods Overriding FieldView
public java.awt.Shape modelToV iew(int pos, java.awt.Shape a, Position.Bias b) throws BadLocationException;
public int viewToModel(ﬂoat fx, ﬂoat fy, java.awt.Shape a, Position.Bias[ ] bias);
// Protected Methods Overriding PlainView
protected int drawSelectedText(java.awt.Graphics g, int x, int y, int p0, int p1) throws BadLocationException;
protected int drawUnselectedText(java.awt.Graphics g, int x, int y, int p0, int p1) throws BadLocationException;
// Protected Instance Methods
protected int drawEchoCharacter(java.awt.Graphics g, int x, int y, char c);
}
Hierar chy: Object→View(SwingConstants)→PlainV iew(TabExpander)→FieldV iew→PasswordV iew
PlainDocument
Ja va 1.2
javax.swing .text
serializable
This concrete AbstractDocument subclass deﬁnes a plain-text document with no character
attributes. The root element of the document has one child element for each line in the
document. By default, PlainDocument uses a GapContent object to hold its textual content.
Applications rarely need to work with a PlainDocument class directly. Typically, they can
simply use the JTextArea or JTextF ield components for displaying and editing text.
public class PlainDocument extends AbstractDocument {
// Public Constructors
public PlainDocument();
// Protected Constructors
protected PlainDocument(AbstractDocument.Content c);
// Public Constants
="lineLimit"
public static ﬁnal String lineLimitAttribute;
="tabSize"
public static ﬁnal String tabSizeAttribute;
// Public Methods Overriding AbstractDocument
default:BranchElement
public javax.swing.text.Element getDefaultRootElement();
public javax.swing.text.Element getParagraphElement(int pos);
// Protected Methods Overriding AbstractDocument
protected void inser tUpdate(AbstractDocument.DefaultDocumentEvent chng, AttributeSet attr);
protected void removeUpdate(AbstractDocument.DefaultDocumentEvent chng);
// Protected Instance Methods
protected AbstractDocument.AbstractElement createDefaultRoot();
}
Hierar chy: Object→AbstractDocument(Document, Serializable)→PlainDocument
javax.swing.text.Parag raphView
612 Chapter 30 – The javax.swing.text Package

PlainV iew
Ja va 1.2
javax.swing .text
This View class is used to display multiple lines of plain text. It can perfor m tab expan-
sion, but it does not perfor m line wrapping. See also WrappedPlainV iew.
public class PlainV iew extends Vie w implements TabExpander {
// Public Constructors
public PlainV iew(javax.swing .text.Element elem);
// Methods Implementing TabExpander
public ﬂoat nextTabStop(ﬂoat x, int tabOffset);
// Public Methods Overriding View
public void changedUpdate(javax.swing .event.DocumentEvent changes, java.awt.Shape a, Vie wFactory f);
public ﬂoat getPrefer redSpan(int axis);
public void inser tUpdate(javax.swing .event.DocumentEvent changes, java.awt.Shape a, Vie wFactory f);
public java.awt.Shape modelToV iew(int pos, java.awt.Shape a, Position.Bias b) throws BadLocationException;
public void paint(java.awt.Graphics g, java.awt.Shape a);
public void preferenceChanged(V iew child, boolean width, boolean height);
public void removeUpdate(javax.swing .event.DocumentEvent changes, java.awt.Shape a, Vie wFactory f);
public int viewToModel(ﬂoat fx, ﬂoat fy, java.awt.Shape a, Position.Bias[ ] bias);
// Protected Instance Methods
protected void drawLine(int lineIndex, java.awt.Graphics g, int x, int y);
protected int drawSelectedText(java.awt.Graphics g, int x, int y, int p0, int p1) throws BadLocationException;
protected int drawUnselectedText(java.awt.Graphics g, int x, int y, int p0, int p1) throws BadLocationException;
protected ﬁnal Segment getLineBuffer();
protected int getTabSize();
// Protected Instance Fields
protected java.awt.FontMetrics metrics;
}
Hierar chy: Object→View(SwingConstants)→PlainV iew(TabExpander)
Subc lasses: FieldV iew
Position
Ja va 1.2
javax.swing .text
This interface describes a position within a Document in a way that is insensitive to
insertions and deletions within the document. The getOffset() method retur ns the charac-
ter offset of that position. For editable documents, a Position object must keep track of
edits and adjust the character offset as necessary.
public abstract interface Position {
// Inner Classes
public static ﬁnal class Bias;
// Public Instance Methods
public abstract int getOffset();
}
Retur ned By: AbstractDocument.{createPosition(), getEndPosition(), getStar tPosition()},
AbstractDocument.Content.createPosition(), Document.{createPosition(), getEndPosition(), getStar tPosition()},
GapContent.createPosition(), StringContent.createPosition()
Position.Bias
Ja va 1.2
javax.swing .text
The Document inter face describes positions within the document using integer offsets.
These numbers refer not to the actual characters of the document, but to the spaces
between the characters. This means that, in some cases, a simple integer position might
refer to either the character before it or the character after it. In ambiguous cases,
javax.swing.
text
javax.swing.text.Position.Bias
Chapter 30 – The javax.swing.text Package
613

ther efor e, the position must be augmented with a bias value. This inner class deﬁnes
the two legal bias values: Position.Bias.Backward and Position.Bias.Forward. A number of
methods in the javax.swing .text package requir e one or the other of these constants as an
argument.
public static ﬁnal class Position.Bias {
// No Constructor
// Public Constants
public static ﬁnal Position.Bias Backward;
public static ﬁnal Position.Bias Forward;
// Public Methods Overriding Object
public String toString();
}
Passed To: Too many methods to list.
Type Of: Position.Bias.{Backward, Forward}
Segment
Ja va 1.2
javax.swing .text
The Segment class repr esents a segment of text through three public ﬁelds. These are a
refer ence to a character array, the array offset of the ﬁrst character in the array, and the
number of characters in the segment. This is an efﬁcient way to pass refer ences to text
segments, since it does not requir e new String objects to be created. However, it is dan-
ger ous because it exposes the character array directly and makes it vulnerable to
changes. Users of a Segment object must treat the text segment as if it were immutable,
using it for read-only access to the text.
public class Segment {
// Public Constructors
public Segment();
public Segment(char[ ] array, int offset, int count);
// Public Methods Overriding Object
public String toString();
// Public Instance Fields
public char[ ] ar ray;
public int count;
public int offset;
}
Passed To: AbstractDocument.getText(), AbstractDocument.Content.getChars(), Document.getText(),
GapContent.getChars(), StringContent.getChars(), Utilities.{drawTabbedText(), getBreakLocation(),
getTabbedTextOffset(), getTabbedTextW idth()}
Retur ned By: PlainV iew.getLineBuffer(), WrappedPlainView.getLineBuffer()
SimpleAttributeSet
Ja va 1.2
javax.swing .text
cloneable serializable
This class is a simple implementation of the MutableAttributeSet inter face that uses an
inter nal hashtable. See AttributeSet and MutableAttributeSet for details. When working with
many attribute sets, it may be more efﬁcient to deﬁne styles using a StyleContext object.
public class SimpleAttributeSet implements Cloneable, MutableAttributeSet, Serializable {
// Public Constructors
public SimpleAttributeSet();
public SimpleAttributeSet(AttributeSet source);
// Public Constants
public static ﬁnal AttributeSet EMPTY;
javax.swing.text.Position.Bias
614 Chapter 30 – The javax.swing.text Package

// Public Instance Methods
default:true
public boolean isEmpty();
// Methods Implementing AttributeSet
public boolean containsAttribute(Object name, Object value);
public boolean containsAttributes(AttributeSet attributes);
public AttributeSet copyAttributes();
public Object getAttribute(Object name);
default:0
public int getAttributeCount();
public java.util.Enumeration getAttributeNames();
default:null
public AttributeSet getResolveParent();
public boolean isDeﬁned(Object attrName);
public boolean isEqual(AttributeSet attr);
// Methods Implementing MutableAttributeSet
public void addAttribute(Object name, Object value);
public void addAttributes(AttributeSet attributes);
public void removeAttribute(Object name);
public void removeAttributes(java.util.Enumeration names);
public void removeAttributes(AttributeSet attributes);
public void setResolveParent(AttributeSet parent);
// Public Methods Overriding Object
public Object clone();
public boolean equals(Object obj);
public int hashCode();
public String toString();
}
Hierar chy: Object→SimpleAttributeSet(Cloneable, MutableAttributeSet(AttributeSet), Serializable)
Retur ned By: javax.swing .text.html.parser.Parser.getAttributes()
StringContent
Ja va 1.2
javax.swing .text
serializable
This class is a simple implementation of the AbstractDocument.Content inter face based on
simple String manipulation. It is suitable only for short documents. By default, all docu-
ments derived from AbstractDocument use the GapContent implementation instead of String-
Content.
public ﬁnal class StringContent implements AbstractDocument.Content, Serializable {
// Public Constructors
public StringContent();
public StringContent(int initialLength);
// Methods Implementing AbstractDocument.Content
public Position createPosition(int offset) throws BadLocationException;
public void getChars(int where, int len, Segment chars) throws BadLocationException;
public String getString(int where, int len) throws BadLocationException;
public javax.swing.undo.UndoableEdit inser tString(int where, String str) throws BadLocationException;
public int length();
public javax.swing.undo.UndoableEdit remove(int where, int nitems) throws BadLocationException;
// Protected Instance Methods
protected java.util.Vector getPositionsInRange(java.util.Vector v, int offset, int length);
protected void updateUndoPositions(java.util.Vector positions);
}
Hierar chy: Object→StringContent(AbstractDocument.Content, Serializable)
javax.swing.
text
javax.swing.text.Str ingContent
Chapter 30 – The javax.swing.text Package
615

Style
Ja va 1.2
javax.swing .text
This interface extends MutableAttributeSet by adding both a convenience method for
retrieving the name of the attribute set and ChangeListener registration methods. A Style
object is typically used to repr esent a named set of attributes. The style name is usually
stor ed as an attribute. Because a Style is a kind of MutableAttributeSet, objects that use the
style may want to know when the attributes of the Style change. Interested listeners can
register with the addChangeListener() method. They are notiﬁed with a ChangeEvent when
attributes are added to or removed from the Style.
public abstract interface Style extends MutableAttributeSet {
// Event Registration Methods (by event name)
public abstract void addChangeListener(javax.swing .event.ChangeListener l);
public abstract void removeChangeListener(javax.swing .event.ChangeListener l);
// Public Instance Methods
public abstract String getName();
}
Hierar chy: (Style(MutableAttributeSet(AttributeSet)))
Implementations: StyleContext.NamedStyle
Passed To: JTextPane.{addStyle(), setLogicalStyle()}, DefaultStyledDocument.{addStyle(), setLogicalStyle(),
styleChanged()}, StyleContext.addStyle(), StyleContext.NamedStyle.NamedStyle(),
StyledDocument.{addStyle(), setLogicalStyle()}
Retur ned By: JTextPane.{addStyle(), getLogicalStyle(), getStyle()}, DefaultStyledDocument.{addStyle(),
getLogicalStyle(), getStyle()}, StyleContext.{addStyle(), getStyle()}, StyledDocument.{addStyle(),
getLogicalStyle(), getStyle()}, javax.swing .text.html.StyleSheet.getRule()
StyleConstants
Ja va 1.2
javax.swing .text
This class deﬁnes a number of standard attribute keys for commonly used character
and paragraph attributes. It also deﬁnes a number of static convenience methods that
use these attributes to query the value of an attribute from an AttributeSet or to set the
value of an attribute in a MutableAttributeSet.
Usually, the type of the value to be associated with an attribute key is obvious from the
context. The method signatures for the static get and set methods make the value
explicit. The value associated with the Alignment key should be one of the four ALIGN_
constants deﬁned by the class. Any length values associated with attributes such as Left-
Indent and LineSpacing should be ﬂoat values expressed in printer’s points (there are 72
printer’s points in one inch).
StyleConstants deﬁnes four inner subclasses, each of which implements a differ ent
marker interface that serves to group attribute keys into broad categories. These inner
classes deﬁne attribute key constants as well, but these constants are also available
dir ectly fr om the StyleConstants class.
public class StyleConstants {
// No Constructor
// Public Constants
=1
public static ﬁnal int ALIGN_CENTER;
=3
public static ﬁnal int ALIGN_JUSTIFIED;
=0
public static ﬁnal int ALIGN_LEFT;
=2
public static ﬁnal int ALIGN_RIGHT;
public static ﬁnal Object Alignment;
public static ﬁnal Object Background;
javax.swing.text.Style
616 Chapter 30 – The javax.swing.text Package

public static ﬁnal Object BidiLevel;
public static ﬁnal Object Bold;
public static ﬁnal Object ComponentAttribute;
="component"
public static ﬁnal String ComponentElementName;
public static ﬁnal Object ComposedTextAttribute;
public static ﬁnal Object FirstLineIndent;
public static ﬁnal Object FontFamily;
public static ﬁnal Object FontSize;
public static ﬁnal Object Foreground;
public static ﬁnal Object IconAttribute;
="icon"
public static ﬁnal String IconElementName;
public static ﬁnal Object Italic;
public static ﬁnal Object LeftIndent;
public static ﬁnal Object LineSpacing;
public static ﬁnal Object ModelAttribute;
public static ﬁnal Object NameAttribute;
public static ﬁnal Object Orientation;
public static ﬁnal Object ResolveAttribute;
public static ﬁnal Object RightIndent;
public static ﬁnal Object SpaceAbove;
public static ﬁnal Object SpaceBelow;
public static ﬁnal Object StrikeThrough;
public static ﬁnal Object Subscript;
public static ﬁnal Object Superscript;
public static ﬁnal Object TabSet;
public static ﬁnal Object Under line;
// Inner Classes
public static class CharacterConstants extends StyleConstants implements AttributeSet.CharacterAttribute;
public static class ColorConstants extends StyleConstants implements AttributeSet.CharacterAttribute,
AttributeSet.ColorAttribute;
public static class FontConstants extends StyleConstants implements AttributeSet.CharacterAttribute,
AttributeSet.FontAttribute;
public static class ParagraphConstants extends StyleConstants implements AttributeSet.ParagraphAttribute;
// Public Class Methods
public static int getAlignment(AttributeSet a);
public static java.awt.Color getBackground(AttributeSet a);
public static int getBidiLevel(AttributeSet a);
public static Component getComponent(AttributeSet a);
public static ﬂoat getF irstLineIndent(AttributeSet a);
public static String getFontFamily(AttributeSet a);
public static int getFontSize(AttributeSet a);
public static java.awt.Color getForeground(AttributeSet a);
public static Icon getIcon(AttributeSet a);
public static ﬂoat getLeftIndent(AttributeSet a);
public static ﬂoat getLineSpacing(AttributeSet a);
public static ﬂoat getRightIndent(AttributeSet a);
public static ﬂoat getSpaceAbove(AttributeSet a);
public static ﬂoat getSpaceBelow(AttributeSet a);
public static TabSet getTabSet(AttributeSet a);
public static boolean isBold(AttributeSet a);
public static boolean isItalic(AttributeSet a);
public static boolean isStrikeThrough(AttributeSet a);
public static boolean isSubscript(AttributeSet a);
public static boolean isSuperscript(AttributeSet a);
public static boolean isUnder line(AttributeSet a);
public static void setAlignment(MutableAttributeSet a, int align);
public static void setBackground(MutableAttributeSet a, java.awt.Color fg);
public static void setBidiLevel(MutableAttributeSet a, int o);
javax.swing.
text
javax.swing.text.StyleConstants
Chapter 30 – The javax.swing.text Package
617

public static void setBold(MutableAttributeSet a, boolean b);
public static void setComponent(MutableAttributeSet a, Component c);
public static void setF irstLineIndent(MutableAttributeSet a, ﬂoat i);
public static void setFontFamily(MutableAttributeSet a, String fam);
public static void setFontSize(MutableAttributeSet a, int s);
public static void setForeground(MutableAttributeSet a, java.awt.Color fg);
public static void setIcon(MutableAttributeSet a, Icon c);
public static void setItalic(MutableAttributeSet a, boolean b);
public static void setLeftIndent(MutableAttributeSet a, ﬂoat i);
public static void setLineSpacing(MutableAttributeSet a, ﬂoat i);
public static void setRightIndent(MutableAttributeSet a, ﬂoat i);
public static void setSpaceAbove(MutableAttributeSet a, ﬂoat i);
public static void setSpaceBelow(MutableAttributeSet a, ﬂoat i);
public static void setStrikeThrough(MutableAttributeSet a, boolean b);
public static void setSubscript(MutableAttributeSet a, boolean b);
public static void setSuperscript(MutableAttributeSet a, boolean b);
public static void setTabSet(MutableAttributeSet a, TabSet tabs);
public static void setUnder line(MutableAttributeSet a, boolean b);
// Public Methods Overriding Object
public String toString();
}
Subc lasses: StyleConstants.CharacterConstants, StyleConstants.ColorConstants,
StyleConstants.FontConstants, StyleConstants.ParagraphConstants
StyleConstants.CharacterConstants
Ja va 1.2
javax.swing .text
This inner subclass of StyleConstants implements the AttributeSet.CharacterAttribute marker
inter face and deﬁnes various standard attribute key constants for character attributes.
Copies of these constants are also deﬁned by StyleConstants itself.
public static class StyleConstants.CharacterConstants extends StyleConstants
implements AttributeSet.CharacterAttribute {
// No Constructor
// Public Constants
public static ﬁnal Object Background;
public static ﬁnal Object BidiLevel;
public static ﬁnal Object Bold;
public static ﬁnal Object ComponentAttribute;
public static ﬁnal Object Family;
public static ﬁnal Object Foreground;
public static ﬁnal Object IconAttribute;
public static ﬁnal Object Italic;
public static ﬁnal Object Size;
public static ﬁnal Object StrikeThrough;
public static ﬁnal Object Subscript;
public static ﬁnal Object Superscript;
public static ﬁnal Object Under line;
}
StyleConstants.ColorConstants
Ja va 1.2
javax.swing .text
This inner subclass of StyleConstants implements the AttributeSet.FontAttribute and Attribute-
Set.CharacterAttribute marker interfaces and deﬁnes standard attribute key constants for
color attributes. Copies of these constants are also deﬁned by StyleConstants itself.
javax.swing.text.StyleConstants
618 Chapter 30 – The javax.swing.text Package

public static class StyleConstants.ColorConstants extends StyleConstants
implements AttributeSet.CharacterAttribute, AttributeSet.ColorAttribute {
// No Constructor
// Public Constants
public static ﬁnal Object Background;
public static ﬁnal Object Foreground;
}
StyleConstants.FontConstants
Ja va 1.2
javax.swing .text
This inner subclass of StyleConstants implements the AttributeSet.FontAttribute and Attribute-
Set.CharacterAttribute marker interfaces and deﬁnes standard attribute key constants for
font attributes. Copies of these constants are also deﬁned by StyleConstants itself.
public static class StyleConstants.FontConstants extends StyleConstants
implements AttributeSet.CharacterAttribute, AttributeSet.FontAttribute {
// No Constructor
// Public Constants
public static ﬁnal Object Bold;
public static ﬁnal Object Family;
public static ﬁnal Object Italic;
public static ﬁnal Object Size;
}
StyleConstants.ParagraphConstants
Ja va 1.2
javax.swing .text
This inner subclass of StyleConstants implements the AttributeSet.ParagraphAttribute marker
inter face and deﬁnes various standard attribute key constants for paragraph attributes.
Copies of these constants are also deﬁned by StyleConstants itself.
public static class StyleConstants.ParagraphConstants extends StyleConstants
implements AttributeSet.ParagraphAttribute {
// No Constructor
// Public Constants
public static ﬁnal Object Alignment;
public static ﬁnal Object FirstLineIndent;
public static ﬁnal Object LeftIndent;
public static ﬁnal Object LineSpacing;
public static ﬁnal Object Orientation;
public static ﬁnal Object RightIndent;
public static ﬁnal Object SpaceAbove;
public static ﬁnal Object SpaceBelow;
public static ﬁnal Object TabSet;
}
StyleContext
Ja va 1.2
javax.swing .text
serializable
This class is a collection of and a factory for Style objects. It is implemented in a way
that allows caching and reuse of common attribute sets. Use addStyle() to create a new
Style object and add it to the collection. Use the methods of the retur ned Style object to
specify the attributes of the Style. Use getStyle() to look up a Style by name and
removeStyle() to delete a Style fr om the collection. The static getDefaultStyleContext() method
retur ns a default StyleContext object suitable for shared use by multiple documents. Style-
javax.swing.
text
javax.swing.text.StyleContext
Chapter 30 – The javax.swing.text Package
619

Context also includes a simple Font cache. You can access shared Font instances with the
getFont() method.
StyleContext also implements the AbstractDocument.AttributeContext inter face, which means
that it implements various methods for creating new AttributeSet objects by copying
existing AttributeSet objects and adding or removing individual attributes. These methods
make it possible to implement the MutableAttributeSet or Style inter faces in terms of
immutable AttributeSet objects that can be cached and shared. The Style objects retur ned
by addStyle() ar e instances of StyleContext.NamedStyle, which is implemented in this way.
Styles that contain only a small number of attributes are implemented as immutable
StyleContext.SmallAttributeSet objects that are cached and reused, resulting in signiﬁcant
memory savings.
public class StyleContext implements AbstractDocument.AttributeContext, Serializable {
// Public Constructors
public StyleContext();
// Public Constants
="default"
public static ﬁnal String DEFAULT_STYLE;
// Inner Classes
public class NamedStyle implements Serializable, Style;
public class SmallAttributeSet implements AttributeSet;
// Public Class Methods
public static ﬁnal StyleContext getDefaultStyleContext();
public static Object getStaticAttribute(Object key);
public static Object getStaticAttributeKey(Object key);
public static void readAttributeSet(java.io.ObjectInputStream in, MutableAttributeSet a)
throws ClassNotFoundException, java.io.IOException;
public static void registerStaticAttributeKey(Object key);
public static void writeAttributeSet(java.io.ObjectOutputStream out, AttributeSet a) throws java.io.IOException;
// Event Registration Methods (by event name)
public void addChangeListener(javax.swing .event.ChangeListener l);
public void removeChangeListener(javax.swing .event.ChangeListener l);
// Public Instance Methods
public Style addStyle(String nm, Style parent);
public java.awt.Color getBackground(AttributeSet attr);
public java.awt.Font getFont(AttributeSet attr);
public java.awt.Font getFont(String family, int style, int size);
public java.awt.FontMetrics getFontMetrics(java.awt.Font f);
public java.awt.Color getForeground(AttributeSet attr);
public Style getStyle(String nm);
public java.util.Enumeration getStyleNames();
public void readAttributes(java.io.ObjectInputStream in, MutableAttributeSet a) throws ClassNotFoundException,
java.io.IOException;
public void removeStyle(String nm);
public void writeAttributes(java.io.ObjectOutputStream out, AttributeSet a) throws java.io.IOException;
// Methods Implementing AbstractDocument.AttributeContext
synchronized
public AttributeSet addAttribute(AttributeSet old, Object name, Object value);
synchronized
public AttributeSet addAttributes(AttributeSet old, AttributeSet attr);
public AttributeSet getEmptySet();
public void reclaim(AttributeSet a);
synchronized
public AttributeSet removeAttribute(AttributeSet old, Object name);
synchronized
public AttributeSet removeAttributes(AttributeSet old, AttributeSet attrs);
synchronized
public AttributeSet removeAttributes(AttributeSet old, java.util.Enumeration names);
// Public Methods Overriding Object
public String toString();
// Protected Instance Methods
protected MutableAttributeSet createLargeAttributeSet(AttributeSet a);
protected StyleContext.SmallAttributeSet createSmallAttributeSet(AttributeSet a);
javax.swing.text.StyleContext
620 Chapter 30 – The javax.swing.text Package

protected int getCompressionThreshold();
}
Hierar chy: Object→StyleContext(AbstractDocument.AttributeContext, Serializable)
Subc lasses: javax.swing .text.html.StyleSheet
Passed To: DefaultStyledDocument.DefaultStyledDocument()
Retur ned By: StyleContext.getDefaultStyleContext()
StyleContext.NamedStyle
Ja va 1.2
javax.swing .text
serializable
This class is a Style implementation that uses the StyleContext to implement its MutableAt-
tributeSet methods in terms of immutable, possibly shared, AttributeSet objects.
public class StyleContext.NamedStyle implements Serializable, Style {
// Public Constructors
public NamedStyle();
public NamedStyle(Style parent);
public NamedStyle(String name, Style parent);
// Event Registration Methods (by event name)
Implements:Style
public void addChangeListener(javax.swing .event.ChangeListener l);
Implements:Style
public void removeChangeListener(javax.swing .event.ChangeListener l);
// Public Instance Methods
public void setName(String name);
// Methods Implementing AttributeSet
public boolean containsAttribute(Object name, Object value);
public boolean containsAttributes(AttributeSet attrs);
public AttributeSet copyAttributes();
public Object getAttribute(Object attrName);
public int getAttributeCount();
public java.util.Enumeration getAttributeNames();
public AttributeSet getResolveParent();
public boolean isDeﬁned(Object attrName);
public boolean isEqual(AttributeSet attr);
// Methods Implementing MutableAttributeSet
public void addAttribute(Object name, Object value);
public void addAttributes(AttributeSet attr);
public void removeAttribute(Object name);
public void removeAttributes(AttributeSet attrs);
public void removeAttributes(java.util.Enumeration names);
public void setResolveParent(AttributeSet parent);
// Methods Implementing Style
public void addChangeListener(javax.swing .event.ChangeListener l);
public String getName();
public void removeChangeListener(javax.swing .event.ChangeListener l);
// Public Methods Overriding Object
public String toString();
// Protected Instance Methods
protected void ﬁreStateChanged();
// Protected Instance Fields
protected transient javax.swing.e vent.ChangeEvent changeEvent;
protected javax.swing.e vent.EventListenerList listenerList;
}
javax.swing.
text
javax.swing.text.StyleContext.NamedStyle
Chapter 30 – The javax.swing.text Package
621

StyleContext.SmallAttributeSet
Ja va 1.2
javax.swing .text
This immutable class implements the AttributeSet inter face using a simple Object array,
rather than a hashtable. This implementation is memory efﬁcient and time efﬁcient for
small attribute sets.
public class StyleContext.SmallAttributeSet implements AttributeSet {
// Public Constructors
public SmallAttributeSet(Object[ ] attributes);
public SmallAttributeSet(AttributeSet attrs);
// Methods Implementing AttributeSet
public boolean containsAttribute(Object name, Object value);
public boolean containsAttributes(AttributeSet attrs);
public AttributeSet copyAttributes();
public Object getAttribute(Object key);
public int getAttributeCount();
public java.util.Enumeration getAttributeNames();
public AttributeSet getResolveParent();
public boolean isDeﬁned(Object key);
public boolean isEqual(AttributeSet attr);
// Public Methods Overriding Object
public Object clone();
public boolean equals(Object obj);
public int hashCode();
public String toString();
}
Retur ned By: StyleContext.createSmallAttributeSet(),
javax.swing .text.html.StyleSheet.createSmallAttributeSet()
StyledDocument
Ja va 1.2
javax.swing .text
This interface extends Document with the methods requir ed for styled documents. A
styled document allows attributes such as colors and font sizes to be applied to charac-
ters and runs of characters in the document. It also allows attributes such as margin
sizes and line spacings to be applied to paragraphs. setCharacterAttributes() and setPara-
graphAttributes() apply a speciﬁed set of attributes to the speciﬁed region of the docu-
ment. They can be used to augment or replace the existing attributes of that region.
getCharacterElement() and getParagraphElement() retur n the Element object that most directly
repr esents or contains the character or paragraph at the speciﬁed position.
The StyledDocument inter face also deﬁnes methods for managing styles. A Style object is a
named set of attributes, with an optional parent attribute set that is used to look up
attributes that are not speciﬁed directly in the Style object. addStyle() cr eates a new Style
object and registers it by name with the StyledDocument. getStyle() looks up a Style object
by name. The intent of Style objects is to repr esent named paragraph types such as
“heading,” “blockquote,” and so forth. The setLogicalStyle() method applies one of these
named paragraph styles to the paragraph at the speciﬁed position. This is the default
style for that paragraph, unless it is overridden by attributes speciﬁed with setCharacterAt-
tributes() or setParagraphAttributes().
See also DefaultStyledDocument, Element, Style, and AttributeSet.
public abstract interface StyledDocument extends Document {
// Public Instance Methods
public abstract Style addStyle(String nm, Style parent);
public abstract java.awt.Color getBackground(AttributeSet attr);
javax.swing.text.StyleContext.SmallAttr ibuteSet
622 Chapter 30 – The javax.swing.text Package

public abstract javax.swing.text.Element getCharacterElement(int pos);
public abstract java.awt.Font getFont(AttributeSet attr);
public abstract java.awt.Color getForeground(AttributeSet attr);
public abstract Style getLogicalStyle(int p);
public abstract javax.swing.text.Element getParagraphElement(int pos);
public abstract Style getStyle(String nm);
public abstract void removeStyle(String nm);
public abstract void setCharacterAttributes(int offset, int length, AttributeSet s, boolean replace);
public abstract void setLogicalStyle(int pos, Style s);
public abstract void setParagraphAttributes(int offset, int length, AttributeSet s, boolean replace);
}
Hierar chy: (StyledDocument(Document))
Implementations: DefaultStyledDocument
Passed To: JTextPane.{JTextPane(), setStyledDocument()},
javax.swing .text.html.MinimalHTMLWriter.MinimalHTMLWriter()
Retur ned By: JTextPane.getStyledDocument(), StyledEditorKit.StyledTextAction.getStyledDocument()
StyledEditorKit
Ja va 1.2
javax.swing .text
cloneable serializable
This class is an EditorKit for generic styled text. It is the default EditorKit used to conﬁgure
the JTextPane component. In addition to the standard EditorKit methods, StyledEditorKit
deﬁnes getInputAttributes() and getCharacterAttributeRun() as conveniences for the various
Action implementations it deﬁnes.
public class StyledEditorKit extends DefaultEditorKit {
// Public Constructors
public StyledEditorKit();
// Inner Classes
public static class AlignmentAction extends StyledEditorKit.StyledTextAction;
public static class BoldAction extends StyledEditorKit.StyledTextAction;
public static class FontFamilyAction extends StyledEditorKit.StyledTextAction;
public static class FontSizeAction extends StyledEditorKit.StyledTextAction;
public static class ForegroundAction extends StyledEditorKit.StyledTextAction;
public static class ItalicAction extends StyledEditorKit.StyledTextAction;
public abstract static class StyledTextAction extends TextAction;
public static class Under lineAction extends StyledEditorKit.StyledTextAction;
// Property Accessor Methods (by property name)
Overrides:DefaultEditorKit
public Action[ ] getActions();
default:null
public javax.swing.text.Element getCharacterAttributeRun();
public MutableAttributeSet getInputAttributes();
Overrides:DefaultEditorKit
public Vie wFactory getV iewFactor y();
// Public Methods Overriding DefaultEditorKit
public Object clone();
public Document createDefaultDocument();
// Public Methods Overriding EditorKit
public void deinstall(JEditorPane c);
public void install(JEditorPane c);
// Protected Instance Methods
protected void createInputAttributes(javax.swing .text.Element element, MutableAttributeSet set);
}
Hierar chy: Object→EditorKit(Cloneable, Serializable)→DefaultEditorKit→StyledEditorKit
javax.swing.
text
javax.swing.text.StyledEditorKit
Chapter 30 – The javax.swing.text Package
623

Subc lasses: javax.swing .text.html.HTMLEditorKit, javax.swing .text.rtf.RTFEditorKit
Retur ned By: JTextPane.getStyledEditorKit(), StyledEditorKit.StyledTextAction.getStyledEditorKit()
StyledEditorKit.AlignmentAction
Ja va 1.2
javax.swing .text
cloneable serializable
This action class sets the alignment paragraph attribute for the currently selected text in
a JEditorPane. StyledEditorKit cr eates thr ee distinct instances of AlignmentAction to handle left,
right, and center alignment. If the command string is set in the ActionEvent, it is inter-
pr eted as the integer value to use for the alignment attribute.
public static class StyledEditorKit.AlignmentAction extends StyledEditorKit.StyledTextAction {
// Public Constructors
public AlignmentAction(String nm, int a);
// Public Methods Overriding AbstractAction
public void actionPerfor med(java.awt.e vent.ActionEvent e);
}
StyledEditorKit.BoldAction
Ja va 1.2
javax.swing .text
cloneable serializable
This action toggles the bold text character attribute, either on the selected text or, if
ther e is no selection, on the current set of attributes used for inserted text.
public static class StyledEditorKit.BoldAction extends StyledEditorKit.StyledTextAction {
// Public Constructors
public BoldAction();
// Public Methods Overriding AbstractAction
public void actionPerfor med(java.awt.e vent.ActionEvent e);
}
StyledEditorKit.FontFamilyAction
Ja va 1.2
javax.swing .text
cloneable serializable
This action sets the font family for the selected text or, if no text is selected, sets the
font family that is used for newly inserted text. StyledEditorKit cr eates several instances of
this class, each of which is conﬁgured to use a differ ent font family.
public static class StyledEditorKit.FontFamilyAction extends StyledEditorKit.StyledTextAction {
// Public Constructors
public FontFamilyAction(String nm, String family);
// Public Methods Overriding AbstractAction
public void actionPerfor med(java.awt.e vent.ActionEvent e);
}
StyledEditorKit.FontSizeAction
Ja va 1.2
javax.swing .text
cloneable serializable
This action sets the font size for the selected text or, if no text is selected, sets the font
size that is used for newly inserted text. StyledEditorKit cr eates several instances of this
class, each of which is conﬁgured to use a differ ent font size.
public static class StyledEditorKit.FontSizeAction extends StyledEditorKit.StyledTextAction {
// Public Constructors
public FontSizeAction(String nm, int size);
javax.swing.text.StyledEditorKit
624 Chapter 30 – The javax.swing.text Package

// Public Methods Overriding AbstractAction
public void actionPerfor med(java.awt.e vent.ActionEvent e);
}
StyledEditorKit.ForegroundAction
Ja va 1.2
javax.swing .text
cloneable serializable
This action sets the color of the selected text or, if no text is selected, sets the color that
is used for newly inserted text. The color to be used is speciﬁed when the ForegroundAc-
tion constructor is called. Or the color may be speciﬁed by the command string of the
ActionEvent. In this case, the color string should be in a format that can be interpreted by
the decode() method of java.awt.Color. StyledEditorKit does not include any objects of this
type in the array of actions retur ned by its getAction() method.
public static class StyledEditorKit.ForegroundAction extends StyledEditorKit.StyledTextAction {
// Public Constructors
public ForegroundAction(String nm, java.awt.Color fg);
// Public Methods Overriding AbstractAction
public void actionPerfor med(java.awt.e vent.ActionEvent e);
}
StyledEditorKit.ItalicAction
Ja va 1.2
javax.swing .text
cloneable serializable
This action toggles the italic text character attribute, either on the selected text or, if
ther e is no selection, on the current set of attributes used for inserted text.
public static class StyledEditorKit.ItalicAction extends StyledEditorKit.StyledTextAction {
// Public Constructors
public ItalicAction();
// Public Methods Overriding AbstractAction
public void actionPerfor med(java.awt.e vent.ActionEvent e);
}
StyledEditorKit.StyledTextAction
Ja va 1.2
javax.swing .text
cloneable serializable
This class is the abstract superclass for Action objects that operate on a JEditorPane conﬁg-
ur ed with a StyledEditorKit. This class deﬁnes convenience methods that are used by the
other inner Action classes deﬁned by StyledEditorKit.
public abstract static class StyledEditorKit.StyledTextAction extends TextAction {
// Public Constructors
public StyledTextAction(String nm);
// Protected Instance Methods
protected ﬁnal JEditorPane getEditor(java.awt.e vent.ActionEvent e);
protected ﬁnal StyledDocument getStyledDocument(JEditorPane e);
protected ﬁnal StyledEditorKit getStyledEditorKit(JEditorPane e);
protected ﬁnal void setCharacterAttributes(JEditorPane editor, AttributeSet attr, boolean replace);
protected ﬁnal void setParagraphAttributes(JEditorPane editor, AttributeSet attr, boolean replace);
}
Subc lasses: StyledEditorKit.AlignmentAction, StyledEditorKit.BoldAction, StyledEditorKit.FontFamilyAction,
StyledEditorKit.FontSizeAction, StyledEditorKit.ForegroundAction, StyledEditorKit.ItalicAction,
StyledEditorKit.Under lineAction, javax.swing .text.html.HTMLEditorKit.HTMLTextAction
javax.swing.
text
javax.swing.text.StyledEditorKit.StyledTextAction
Chapter 30 – The javax.swing.text Package
625

StyledEditorKit.Under lineAction
Ja va 1.2
javax.swing .text
cloneable serializable
This action toggles the underline character attribute, either on the selected text or, if
ther e is no selection, on the set of attributes used for newly inserted text.
public static class StyledEditorKit.Under lineAction extends StyledEditorKit.StyledTextAction {
// Public Constructors
public Under lineAction();
// Public Methods Overriding AbstractAction
public void actionPerfor med(java.awt.e vent.ActionEvent e);
}
TabableV iew
Ja va 1.2
javax.swing .text
This interface is implemented by View objects whose width may be dependent on the
expansion of Ta b characters. getTabbedSpan() is passed a horizontal position and a TabEx-
pander object and should retur n the appropriate width for the View. The getPrefer redSpan()
method of the View object should retur n the same width. Applications do not need to
use or implement this interface.
public abstract interface TabableV iew {
// Public Instance Methods
public abstract ﬂoat getPar tialSpan(int p0, int p1);
public abstract ﬂoat getTabbedSpan(ﬂoat x, TabExpander e);
}
TabExpander
Ja va 1.2
javax.swing .text
This interface speciﬁes how horizontal Ta b characters in a Document ar e expanded.
Given the position in the document and on the screen of the Ta b character, it retur ns
the horizontal position that the Ta b character should tab to. Applications do not typi-
cally need to use or implement this interface themselves.
public abstract interface TabExpander {
// Public Instance Methods
public abstract ﬂoat nextTabStop(ﬂoat x, int tabOffset);
}
Implementations: javax.swing .text.ParagraphV iew, PlainView, WrappedPlainView
Passed To: TabableV iew.getTabbedSpan(), Utilities.{drawTabbedText(), getBreakLocation(),
getTabbedTextOffset(), getTabbedTextW idth()}
TableV iew
Ja va 1.2
javax.swing .text
This BoxV iew class displays a table composed of TableV iew.TableRow and TableV iew.TableCell
subviews.
public abstract class TableV iew extends BoxVie w {
// Public Constructors
public TableV iew(javax.swing .text.Element elem);
// Inner Classes
public class TableCell extends BoxVie w;
public class TableRow extends BoxVie w;
javax.swing.text.StyledEditorKit.UnderlineAction
626 Chapter 30 – The javax.swing.text Package

// Public Methods Overriding BoxView
public void replace(int offset, int length, Vie w[ ] views);
// Protected Methods Overriding BoxView
protected SizeRequirements calculateMinorAxisRequirements(int axis, SizeRequirements r);
protected void layoutMinorAxis(int targetSpan, int axis, int[ ] offsets, int[ ] spans);
// Protected Methods Overriding CompositeView
protected Vie w getV iewAtPosition(int pos, java.awt.Rectangle a);
// Protected Instance Methods
protected TableV ie w.TableCell createTableCell(javax.swing .text.Element elem);
protected TableV ie w.TableRow createTableRow(javax.swing .text.Element elem);
protected void layoutColumns(int targetSpan, int[ ] offsets, int[ ] spans, SizeRequirements[ ] reqs);
}
Hierar chy: Object→View(SwingConstants)→CompositeV iew→BoxV iew→TableV iew
TableV iew.TableCell
Ja va 1.2
javax.swing .text
This BoxV iew class displays the contents of a table cell. It may contain any type of child
views.
public class TableV iew.TableCell extends BoxVie w {
// Public Constructors
public TableCell(javax.swing .text.Element elem);
// Property Accessor Methods (by property name)
constant
public int getColumnCount();
public int getGridColumn();
public int getGridRow();
constant
public int getRowCount();
// Public Instance Methods
public void setGridLocation(int row, int col);
}
Retur ned By: TableV iew.createTableCell()
TableV iew.TableRow
Ja va 1.2
javax.swing .text
This BoxV iew displays one row in a table. It should contain TableV iew.TableCell childr en.
public class TableV iew.TableRow extends BoxVie w {
// Public Constructors
public TableRow(javax.swing .text.Element elem);
// Public Methods Overriding BoxView
constant
public int getResizeWeight(int axis);
public void replace(int offset, int length, Vie w[ ] views);
// Protected Methods Overriding BoxView
protected void layoutMajorAxis(int targetSpan, int axis, int[ ] offsets, int[ ] spans);
protected void layoutMinorAxis(int targetSpan, int axis, int[ ] offsets, int[ ] spans);
// Protected Methods Overriding CompositeView
protected Vie w getV iewAtPosition(int pos, java.awt.Rectangle a);
}
Retur ned By: TableV iew.createTableRow()
javax.swing.
text
javax.swing.text.TableView.Ta bleRow
Chapter 30 – The javax.swing.text Package
627

TabSet
Ja va 1.2
javax.swing .text
serializable
This class repr esents a set of TabStop objects and provides several methods for querying
that set of tab stops.
public class TabSet implements Serializable {
// Public Constructors
public TabSet(TabStop[ ] tabs);
// Public Instance Methods
public TabStop getTab(int index);
public TabStop getTabAfter(ﬂoat location);
public int getTabCount();
public int getTabIndex(TabStop tab);
public int getTabIndexAfter(ﬂoat location);
// Public Methods Overriding Object
public String toString();
}
Hierar chy: Object→TabSet(Serializable)
Passed To: StyleConstants.setTabSet()
Retur ned By: javax.swing .text.ParagraphV iew.getTabSet(), StyleConstants.getTabSet()
TabStop
Ja va 1.2
javax.swing .text
serializable
This class repr esents a tab stop in a document. Each tab stop has a horizontal position
(measur ed in points), an alignment, and a leader character that is used to ﬁll in the
space between the previous character and the tab stop. The various constants deﬁned
by this class repr esent the legal alignment and leader values. See also TabSet.
public class TabStop implements Serializable {
// Public Constructors
public TabStop(ﬂoat pos);
public TabStop(ﬂoat pos, int align, int leader);
// Public Constants
=5
public static ﬁnal int ALIGN_BAR;
=2
public static ﬁnal int ALIGN_CENTER;
=4
public static ﬁnal int ALIGN_DECIMAL;
=0
public static ﬁnal int ALIGN_LEFT;
=1
public static ﬁnal int ALIGN_RIGHT;
=1
public static ﬁnal int LEAD_DOTS;
=5
public static ﬁnal int LEAD_EQUALS;
=2
public static ﬁnal int LEAD_HYPHENS;
=0
public static ﬁnal int LEAD_NONE;
=4
public static ﬁnal int LEAD_THICKLINE;
=3
public static ﬁnal int LEAD_UNDERLINE;
// Public Instance Methods
public int getAlignment();
public int getLeader();
public ﬂoat getPosition();
// Public Methods Overriding Object
public boolean equals(Object other);
public int hashCode();
public String toString();
}
Hierar chy: Object→TabStop(Serializable)
javax.swing.text.TabSet
628 Chapter 30 – The javax.swing.text Package

Passed To: TabSet.{getTabIndex(), TabSet()}
Retur ned By: TabSet.{getTab(), getTabAfter()}
TextAction
Ja va 1.2
javax.swing .text
cloneable serializable
This abstract class is an Action that extends AbstractAction. It does not implement any of
the abstract methods of AbstractAction but merely adds new protected methods that sub-
classes can use to ﬁgure out on what JTextComponent they are supposed to operate.
These methods allow subclasses to deﬁne generic actions that are not speciﬁc to a par-
ticular JTextComponent but that can be used on any text component. Applications may
subclass this interface to deﬁne custom actions, but they do not often need to do so.
DefaultEditorKit and StyledEditorKit deﬁne a number of inner classes that subclass TextAction.
public abstract class TextAction extends AbstractAction {
// Public Constructors
public TextAction(String name);
// Public Class Methods
public static ﬁnal Action[ ] augmentList(Action[ ] list1, Action[ ] list2);
// Protected Instance Methods
protected ﬁnal JTextComponent getFocusedComponent();
protected ﬁnal JTextComponent getTextComponent(java.awt.e vent.ActionEvent e);
}
Hierar chy: Object→AbstractAction(Action(java.awt.event.ActionListener(java.util.EventListener)),
Cloneable, Serializable)→TextAction
Subc lasses: DefaultEditorKit.BeepAction, DefaultEditorKit.CopyAction, DefaultEditorKit.CutAction,
DefaultEditorKit.DefaultKeyTypedAction, DefaultEditorKit.InsertBreakAction,
DefaultEditorKit.Inser tContentAction, DefaultEditorKit.Inser tTabAction, DefaultEditorKit.PasteAction,
StyledEditorKit.StyledTextAction
Utilities
Ja va 1.2
javax.swing .text
This class deﬁnes various static utility methods that are used internally by the
javax.swing .text package. Although applications may occasionally ﬁnd some of these
methods useful, they are intended primarily for internal use and for use by program-
mers who are subclassing or heavily customizing javax.swing .text classes.
public class Utilities {
// Public Constructors
public Utilities();
// Public Class Methods
public static ﬁnal int drawTabbedText(Segment s, int x, int y, java.awt.Graphics g, TabExpander e, int star tOffset);
public static ﬁnal int getBreakLocation(Segment s, java.awt.FontMetrics metrics, int x0, int x, TabExpander e,
int star tOffset);
public static ﬁnal int getNextWord(JTextComponent c, int offs) throws BadLocationException;
public static ﬁnal javax.swing.text.Element getParagraphElement(JTextComponent c, int offs);
public static ﬁnal int getPositionAbove(JTextComponent c, int offs, int x) throws BadLocationException;
public static ﬁnal int getPositionBelow(JTextComponent c, int offs, int x) throws BadLocationException;
public static ﬁnal int getPreviousWord(JTextComponent c, int offs) throws BadLocationException;
public static ﬁnal int getRowEnd(JTextComponent c, int offs) throws BadLocationException;
public static ﬁnal int getRowStar t(JTextComponent c, int offs) throws BadLocationException;
public static ﬁnal int getTabbedTextOffset(Segment s, java.awt.FontMetrics metrics, int x0, int x, TabExpander e,
int star tOffset);
public static ﬁnal int getTabbedTextOffset(Segment s, java.awt.FontMetrics metrics, int x0, int x, TabExpander e,
int star tOffset, boolean round);
javax.swing.
text
javax.swing.text.Utilities
Chapter 30 – The javax.swing.text Package
629

public static ﬁnal int getTabbedTextW idth(Segment s, java.awt.FontMetrics metrics, int x, TabExpander e,
int star tOffset);
public static ﬁnal int getWordEnd(JTextComponent c, int offs) throws BadLocationException;
public static ﬁnal int getWordStar t(JTextComponent c, int offs) throws BadLocationException;
}
View
Ja va 1.2
javax.swing .text
This class is the abstract superclass of a hierarchy of classes used to display various
parts of a text document. Just as java.awt.Component is the root of the component hierar-
chy and has many subclasses in java.awt and javax.swing, View is the root of the view hier-
archy and has many subclasses in javax.swing .text and javax.swing .text.html. Just as the
various Component classes are used to display differ ent GUI elements, the various View
classes are used to display differ ent types of document elements.
Each type of Document has a ViewFactor y object that is used to create an appropriate View
object for a given Element of a document. Because a Document consists of a tree of Ele-
ment objects, the document is displayed using a tree of View objects. Just like GUI com-
ponents, View objects are nested into a containment hierarchy. Thus, a BoxV iew might
contain a TableV iew and several ParagraphV iew objects, each of which contains a number
of PlainV iew objects interspersed with IconV iew objects.
Like a component, a View implementation must be able to paint itself, retur n its chil-
dr en, report its preferr ed size, and so on. In fact, you can think of a View as a kind of
extr emely lightweight component, with a number of methods analogous to Component
methods. These include paint(), getV iew(), getV iewCount(), getParent(), getPrefer redSpan(), get-
MinimumSpan(), getMaximumSpan(), and isV isible().
A View implementation must also be able to convert between the document coordinate
system — an integer position within the document—and the on-screen coordinate sys-
tem in which things like mouse clicks and drags are measur ed. The viewToModel() and
modelToV iew() methods are called to perfor m these conversions.
View objects are unlike components in one important aspect, however. They may be
subject to word-wrapping and line breaking. The getBreakWeight() method retur ns an
integer that speciﬁes whether a given position is a reasonable place at which to insert a
line break. If a View supports line breaking, its breakV iew() method should break the view
into two and retur n the newly created View.
Pr ogrammers deﬁning custom document types or custom document content types may
need to create custom View implementations. Applications typically do not need to use
or subclass this class directly.
public abstract class View implements SwingConstants {
// Public Constructors
public View(javax.swing .text.Element elem);
// Public Constants
=0
public static ﬁnal int BadBreakWeight;
=2000
public static ﬁnal int ExcellentBreakWeight;
=3000
public static ﬁnal int ForcedBreakWeight;
=1000
public static ﬁnal int GoodBreakWeight;
=0
public static ﬁnal int X_AXIS;
=1
public static ﬁnal int Y_AXIS;
// Property Accessor Methods (by property name)
public AttributeSet getAttributes();
public Container getContainer();
public Document getDocument();
javax.swing.text.Utilities
630 Chapter 30 – The javax.swing.text Package

public javax.swing.text.Element getElement();
public int getEndOffset();
public Vie w getParent();
public void setParent(V iew parent);
public int getStar tOffset();
constant
public int getV iewCount();
public Vie wFactory getV iewFactor y();
constant
public boolean isV isible();
// Public Instance Methods
public Vie w breakV iew(int axis, int offset, ﬂoat pos, ﬂoat len);
empty
public void changedUpdate(javax.swing .event.DocumentEvent e, java.awt.Shape a, Vie wFactory f);
public Vie w createFragment(int p0, int p1);
public ﬂoat getAlignment(int axis);
public int getBreakWeight(int axis, ﬂoat pos, ﬂoat len);
constant
public java.awt.Shape getChildAllocation(int index, java.awt.Shape a);
public ﬂoat getMaximumSpan(int axis);
public ﬂoat getMinimumSpan(int axis);
public int getNextV isualPositionFrom(int pos, Position.Bias b, java.awt.Shape a, int direction,
Position.Bias[ ] biasRet) throws BadLocationException;
public abstract ﬂoat getPrefer redSpan(int axis);
constant
public int getResizeWeight(int axis);
constant
public Vie w getV iew(int n);
empty
public void inser tUpdate(javax.swing .event.DocumentEvent e, java.awt.Shape a, Vie wFactory f);
public abstract java.awt.Shape modelToV iew(int pos, java.awt.Shape a, Position.Bias b)
throws BadLocationException;
public java.awt.Shape modelToV iew(int p0, Position.Bias b0, int p1, Position.Bias b1, java.awt.Shape a)
throws BadLocationException;
public abstract void paint(java.awt.Graphics g, java.awt.Shape allocation);
public void preferenceChanged(V iew child, boolean width, boolean height);
empty
public void removeUpdate(javax.swing .event.DocumentEvent e, java.awt.Shape a, Vie wFactory f);
empty
public void setSize(ﬂoat width, ﬂoat height);
public abstract int viewToModel(ﬂoat x, ﬂoat y, java.awt.Shape a, Position.Bias[ ] biasReturn);
// Deprecated Public Methods
# public java.awt.Shape modelToV iew(int pos, java.awt.Shape a) throws BadLocationException;
# public int viewToModel(ﬂoat x, ﬂoat y, java.awt.Shape a);
}
Hierar chy: Object→View(SwingConstants)
Subc lasses: ComponentV iew, CompositeView, IconView, LabelView, PlainView
Passed To: Too many methods to list.
Retur ned By: Too many methods to list.
ViewFactor y
Ja va 1.2
javax.swing .text
The ViewFactor y inter face deﬁnes a basic create() method that creates View objects from
the individual Element nodes of a Document. Dif ferent types of documents use differ ent
ViewFactor y implementations to implement a custom Element to View mapping. The get-
ViewFactor y() method of EditorKit retur ns a ViewFactor y for a particular document type.
public abstract interface ViewFactor y {
// Public Instance Methods
public abstract Vie w create(javax.swing .text.Element elem);
}
Implementations: javax.swing .text.html.HTMLEditorKit.HTMLFactor y
javax.swing.
text
javax.swing.text.ViewFactor y
Chapter 30 – The javax.swing.text Package
631

Passed To: Too many methods to list.
Retur ned By: DefaultEditorKit.getV iewFactor y(), EditorKit.getV iewFactor y(), StyledEditorKit.getV iewFactor y(),
View.getV iewFactor y(), javax.swing .text.html.HTMLEditorKit.getV iewFactor y()
WrappedPlainV iew
Ja va 1.2
javax.swing .text
This class displays multiple lines of plain text. It can perfor m tab expansion and line
wrapping. See also PlainV iew.
public class WrappedPlainV iew extends BoxVie w implements TabExpander {
// Public Constructors
public WrappedPlainV iew(javax.swing .text.Element elem);
public WrappedPlainV iew(javax.swing .text.Element elem, boolean wordWrap);
// Methods Implementing TabExpander
public ﬂoat nextTabStop(ﬂoat x, int tabOffset);
// Public Methods Overriding BoxView
public ﬂoat getMaximumSpan(int axis);
public ﬂoat getMinimumSpan(int axis);
public ﬂoat getPrefer redSpan(int axis);
public void paint(java.awt.Graphics g, java.awt.Shape a);
public void setSize(ﬂoat width, ﬂoat height);
// Public Methods Overriding CompositeView
public void changedUpdate(javax.swing .event.DocumentEvent e, java.awt.Shape a, Vie wFactory f);
public void inser tUpdate(javax.swing .event.DocumentEvent e, java.awt.Shape a, Vie wFactory f);
public void removeUpdate(javax.swing .event.DocumentEvent e, java.awt.Shape a, Vie wFactory f);
// Protected Methods Overriding CompositeView
protected void loadChildren(V iewFactory f);
// Protected Instance Methods
protected int calculateBreakPosition(int p0, int p1);
protected void drawLine(int p0, int p1, java.awt.Graphics g, int x, int y);
protected int drawSelectedText(java.awt.Graphics g, int x, int y, int p0, int p1) throws BadLocationException;
protected int drawUnselectedText(java.awt.Graphics g, int x, int y, int p0, int p1) throws BadLocationException;
protected ﬁnal Segment getLineBuffer();
protected int getTabSize();
}
Hierar chy: Object→View(SwingConstants)→CompositeV iew→BoxV iew→
WrappedPlainV iew(TabExpander)
javax.swing.text.ViewFactor y
632 Chapter 30 – The javax.swing.text Package

CHAPTER 31
The javax.swing.text.html Package
The javax.swing .text.html package deﬁnes classes to support the display and editing
of HTML documents. The key class is HTMLEditorKit, which is used to customize a
javax.swing .JEditorPane component to work with HTML. Figure 31-1 shows the class
hierarchy of this package. See Chapter 3, Swing Programming Topics, for a discus-
sion and example of using the HTMLEditorKit.
BlockV iew
Ja va 1.2
javax.swing .text.html
This View implementation displays HTML block elements and can handle CSS attributes
for those elements.
public class BlockV iew extends BoxVie w {
// Public Constructors
public BlockV iew(javax.swing .text.Element elem, int axis);
// Public Methods Overriding BoxView
public ﬂoat getAlignment(int axis);
public int getResizeWeight(int axis);
public void paint(java.awt.Graphics g, java.awt.Shape allocation);
// Protected Methods Overriding BoxView
protected SizeRequirements calculateMajorAxisRequirements(int axis, SizeRequirements r);
protected SizeRequirements calculateMinorAxisRequirements(int axis, SizeRequirements r);
// Public Methods Overriding CompositeView
public void changedUpdate(javax.swing .event.DocumentEvent changes, java.awt.Shape a, Vie wFactory f);
// Public Methods Overriding View
public AttributeSet getAttributes();
// Protected Instance Methods
protected StyleSheet getStyleSheet();
protected void setProper tiesFromAttributes();
}
javax.swing.
text.html
633

CLASS
INTERFACE
ABSTRACT CLASS
KEY
extends
implements
java.lang
Object
javax.swing.text.html
java.awt.event
CSS
BlockView
FormView
ObjectView
InlineView
ParagraphView
HTMLDocument
HTMLEditorKit
HTMLWriter
MinimalHTMLWriter
StyleSheet
HTML
Option
javax.swing.text
BoxView
ComponentView
DefaultStyledDocument
StyledEditorKit
AbstractWriter
StyleContext
ParagraphView
LabelView
ListView
javax.swing.event
HyperlinkEvent
HTMLFrameHyperlinkEvent
ActionListener
Figur e 31−1: The javax.swing.text.html package
Hierar chy: Object→View(SwingConstants)→CompositeV iew→BoxV iew→BlockV iew
Subc lasses: ListV iew
CSS
Ja va 1.2
javax.swing .text.html
This class deﬁnes an inner class that is used to repr esent Cascading Style Sheet (CSS)
attributes in an AttributeSet. It also deﬁnes static methods that retur n all deﬁned CSS
attribute objects and allow you to look up a CSS attribute object by name.
public class CSS {
// Public Constructors
public CSS();
javax.swing.text.html.BlockView
634 Chapter 31 – The javax.swing.text.html Package

// Inner Classes
public static ﬁnal class Attribute;
// Public Class Methods
public static CSS.Attribute[ ] getAllAttributeKeys();
public static ﬁnal CSS.Attribute getAttribute(String name);
}
CSS.Attribute
Ja va 1.2
javax.swing .text.html
Instances of this class are used as key values in an AttributeSet to repr esent CSS
attributes. Each CSS.Attribute object supports getDefaultValue() and isInherited() methods that
retur n mor e infor mation about the attribute. In addition, the toString() method retur ns
the name of the attribute. The CSS.Attribute class is ﬁnal and does not have a public con-
structor, so it cannot be instantiated or subclassed. However, it deﬁnes constant object
values for each of the CSS attributes speciﬁed by the CSS speciﬁcation.
public static ﬁnal class CSS.Attribute {
// No Constructor
// Public Constants
public static ﬁnal CSS.Attribute BACKGROUND;
public static ﬁnal CSS.Attribute BACKGROUND_ATTACHMENT;
public static ﬁnal CSS.Attribute BACKGROUND_COLOR;
public static ﬁnal CSS.Attribute BACKGROUND_IMAGE;
public static ﬁnal CSS.Attribute BACKGROUND_POSITION;
public static ﬁnal CSS.Attribute BACKGROUND_REPEAT;
public static ﬁnal CSS.Attribute BORDER;
public static ﬁnal CSS.Attribute BORDER_BOTTOM;
public static ﬁnal CSS.Attribute BORDER_BOTTOM_WIDTH;
public static ﬁnal CSS.Attribute BORDER_COLOR;
public static ﬁnal CSS.Attribute BORDER_LEFT;
public static ﬁnal CSS.Attribute BORDER_LEFT_WIDTH;
public static ﬁnal CSS.Attribute BORDER_RIGHT;
public static ﬁnal CSS.Attribute BORDER_RIGHT_WIDTH;
public static ﬁnal CSS.Attribute BORDER_STYLE;
public static ﬁnal CSS.Attribute BORDER_TOP;
public static ﬁnal CSS.Attribute BORDER_TOP_WIDTH;
public static ﬁnal CSS.Attribute BORDER_WIDTH;
public static ﬁnal CSS.Attribute CLEAR;
public static ﬁnal CSS.Attribute COLOR;
public static ﬁnal CSS.Attribute DISPLAY;
public static ﬁnal CSS.Attribute FLOAT;
public static ﬁnal CSS.Attribute FONT;
public static ﬁnal CSS.Attribute FONT_FAMILY;
public static ﬁnal CSS.Attribute FONT_SIZE;
public static ﬁnal CSS.Attribute FONT_STYLE;
public static ﬁnal CSS.Attribute FONT_VARIANT;
public static ﬁnal CSS.Attribute FONT_WEIGHT;
public static ﬁnal CSS.Attribute HEIGHT;
public static ﬁnal CSS.Attribute LETTER_SPACING;
public static ﬁnal CSS.Attribute LINE_HEIGHT;
public static ﬁnal CSS.Attribute LIST_STYLE;
public static ﬁnal CSS.Attribute LIST_STYLE_IMAGE;
public static ﬁnal CSS.Attribute LIST_STYLE_POSITION;
public static ﬁnal CSS.Attribute LIST_STYLE_TYPE;
public static ﬁnal CSS.Attribute MARGIN;
public static ﬁnal CSS.Attribute MARGIN_BOTTOM;
javax.swing.
text.html
javax.swing.text.html.CSS.Attr ibute
Chapter 31 – The javax.swing.text.html Package
635

public static ﬁnal CSS.Attribute MARGIN_LEFT;
public static ﬁnal CSS.Attribute MARGIN_RIGHT;
public static ﬁnal CSS.Attribute MARGIN_TOP;
public static ﬁnal CSS.Attribute PADDING;
public static ﬁnal CSS.Attribute PADDING_BOTTOM;
public static ﬁnal CSS.Attribute PADDING_LEFT;
public static ﬁnal CSS.Attribute PADDING_RIGHT;
public static ﬁnal CSS.Attribute PADDING_TOP;
public static ﬁnal CSS.Attribute TEXT_ALIGN;
public static ﬁnal CSS.Attribute TEXT_DECORATION;
public static ﬁnal CSS.Attribute TEXT_INDENT;
public static ﬁnal CSS.Attribute TEXT_TRANSFORM;
public static ﬁnal CSS.Attribute VERTICAL_ALIGN;
public static ﬁnal CSS.Attribute WHITE_SPACE;
public static ﬁnal CSS.Attribute WIDTH;
public static ﬁnal CSS.Attribute WORD_SPACING;
// Public Instance Methods
public String getDefaultValue();
public boolean isInherited();
// Public Methods Overriding Object
public String toString();
}
Retur ned By: CSS.{getAllAttributeKeys(), getAttribute()}
Type Of: Too many fields to list.
FormView
Ja va 1.2
javax.swing .text.html
This View displays <INPUT>, <SELECT>, and <TEXTAREA> elements within an HTML <FORM>.
public class FormView extends ComponentVie w implements java.awt.event.ActionListener {
// Public Constructors
public FormView(javax.swing .text.Element elem);
// Public Constants
public static ﬁnal String RESET;
public static ﬁnal String SUBMIT;
// Inner Classes
protected class MouseEventListener extends java.awt.event.MouseAdapter ;
// Methods Implementing ActionListener
public void actionPerfor med(java.awt.e vent.ActionEvent evt);
// Protected Methods Overriding ComponentView
protected Component createComponent();
// Protected Instance Methods
protected void imageSubmit(String imageData);
protected void submitData(String data);
}
Hierar chy: Object→View(SwingConstants)→ComponentV iew→
For mView(java.awt.event.ActionListener(java.util.EventListener))
FormView.MouseEventListener
Ja va 1.2
javax.swing .text.html
This class is used internally by For mView to handle clicks on HTML <INPUT> tags that
have the TYPE=image attribute speciﬁed.
javax.swing.text.html.CSS.Attr ibute
636 Chapter 31 – The javax.swing.text.html Package

protected class FormView.MouseEventListener extends java.awt.event.MouseAdapter {
// Protected Constructors
protected MouseEventListener();
// Public Methods Overriding MouseAdapter
public void mouseReleased(java.awt.e vent.MouseEvent evt);
}
HTML
Ja va 1.2
javax.swing .text.html
This class deﬁnes inner classes that are used to repr esent HTML tags and attributes. It
also deﬁnes several static convenience methods that are used with the inner classes. In
particular, getAttributeKey() and getTag() look up HTML.Attribute and HTML.Tag values by name.
public class HTML {
// Public Constructors
public HTML();
// Public Constants
="#DEFAULT"
public static ﬁnal String NULL_ATTRIBUTE_VALUE;
// Inner Classes
public static ﬁnal class Attribute;
public static class Tag;
public static class UnknownTag extends HTML.Tag implements Serializable;
// Public Class Methods
public static HTML.Attribute[ ] getAllAttributeKeys();
public static HTML.Tag[ ] getAllTags();
public static HTML.Attribute getAttributeKey(String attName);
public static int getIntegerAttributeValue(AttributeSet attr, HTML.Attribute key, int def);
public static HTML.Tag getTag(String tagName);
}
HTML.Attribute
Ja va 1.2
javax.swing .text.html
This class deﬁnes a number of constant instances of itself to repr esent HTML attributes.
The class has no public constructor and is ﬁnal, so new attribute objects cannot be cre-
ated by instantiation or subclassing.
public static ﬁnal class HTML.Attribute {
// No Constructor
// Public Constants
public static ﬁnal HTML.Attribute ACTION;
public static ﬁnal HTML.Attribute ALIGN;
public static ﬁnal HTML.Attribute ALINK;
public static ﬁnal HTML.Attribute ALT;
public static ﬁnal HTML.Attribute ARCHIVE;
public static ﬁnal HTML.Attribute BACKGROUND;
public static ﬁnal HTML.Attribute BGCOLOR;
public static ﬁnal HTML.Attribute BORDER;
public static ﬁnal HTML.Attribute CELLPADDING;
public static ﬁnal HTML.Attribute CELLSPACING;
public static ﬁnal HTML.Attribute CHECKED;
public static ﬁnal HTML.Attribute CLASS;
public static ﬁnal HTML.Attribute CLASSID;
public static ﬁnal HTML.Attribute CLEAR;
public static ﬁnal HTML.Attribute CODE;
public static ﬁnal HTML.Attribute CODEBASE;
javax.swing.
text.html
javax.swing.text.html.HTML.Attr ibute
Chapter 31 – The javax.swing.text.html Package
637

public static ﬁnal HTML.Attribute CODETYPE;
public static ﬁnal HTML.Attribute COLOR;
public static ﬁnal HTML.Attribute COLS;
public static ﬁnal HTML.Attribute COLSPAN;
public static ﬁnal HTML.Attribute COMMENT;
public static ﬁnal HTML.Attribute COMPACT;
public static ﬁnal HTML.Attribute CONTENT;
public static ﬁnal HTML.Attribute COORDS;
public static ﬁnal HTML.Attribute DATA;
public static ﬁnal HTML.Attribute DECLARE;
public static ﬁnal HTML.Attribute DIR;
public static ﬁnal HTML.Attribute DUMMY;
public static ﬁnal HTML.Attribute ENCTYPE;
public static ﬁnal HTML.Attribute ENDTAG;
public static ﬁnal HTML.Attribute FA CE;
public static ﬁnal HTML.Attribute FRAMEBORDER;
public static ﬁnal HTML.Attribute HALIGN;
public static ﬁnal HTML.Attribute HEIGHT;
public static ﬁnal HTML.Attribute HREF;
public static ﬁnal HTML.Attribute HSPACE;
public static ﬁnal HTML.Attribute HTTPEQUIV;
public static ﬁnal HTML.Attribute ID;
public static ﬁnal HTML.Attribute ISMAP;
public static ﬁnal HTML.Attribute LANG;
public static ﬁnal HTML.Attribute LANGUAGE;
public static ﬁnal HTML.Attribute LINK;
public static ﬁnal HTML.Attribute LOWSRC;
public static ﬁnal HTML.Attribute MARGINHEIGHT;
public static ﬁnal HTML.Attribute MARGINWIDTH;
public static ﬁnal HTML.Attribute MAXLENGTH;
public static ﬁnal HTML.Attribute METHOD;
public static ﬁnal HTML.Attribute MULTIPLE;
public static ﬁnal HTML.Attribute N;
public static ﬁnal HTML.Attribute NAME;
public static ﬁnal HTML.Attribute NOHREF;
public static ﬁnal HTML.Attribute NORESIZE;
public static ﬁnal HTML.Attribute NOSHADE;
public static ﬁnal HTML.Attribute NOWRAP;
public static ﬁnal HTML.Attribute PROMPT;
public static ﬁnal HTML.Attribute REL;
public static ﬁnal HTML.Attribute REV;
public static ﬁnal HTML.Attribute RO WS;
public static ﬁnal HTML.Attribute RO WSPAN;
public static ﬁnal HTML.Attribute SCROLLING;
public static ﬁnal HTML.Attribute SELECTED;
public static ﬁnal HTML.Attribute SHAPE;
public static ﬁnal HTML.Attribute SHAPES;
public static ﬁnal HTML.Attribute SIZE;
public static ﬁnal HTML.Attribute SRC;
public static ﬁnal HTML.Attribute STANDBY;
public static ﬁnal HTML.Attribute START;
public static ﬁnal HTML.Attribute STYLE;
public static ﬁnal HTML.Attribute TARGET;
public static ﬁnal HTML.Attribute TEXT;
public static ﬁnal HTML.Attribute TITLE;
public static ﬁnal HTML.Attribute TYPE;
public static ﬁnal HTML.Attribute USEMAP;
public static ﬁnal HTML.Attribute VALIGN;
javax.swing.text.html.HTML.Attr ibute
638 Chapter 31 – The javax.swing.text.html Package

public static ﬁnal HTML.Attribute VALUE;
public static ﬁnal HTML.Attribute VALUETYPE;
public static ﬁnal HTML.Attribute VERSION;
public static ﬁnal HTML.Attribute VLINK;
public static ﬁnal HTML.Attribute VSPACE;
public static ﬁnal HTML.Attribute WIDTH;
// Public Methods Overriding Object
public String toString();
}
Passed To: HTML.getIntegerAttributeValue()
Retur ned By: HTML.{getAllAttributeKeys(), getAttributeKey()}
Type Of: Too many fields to list.
HTML.Tag
Ja va 1.2
javax.swing .text.html
This class deﬁnes constant instances of itself that repr esent HTML tags. The breaksFlow(),
isBlock(), and isPrefor matted() methods retur n additional information about the basic be-
hav-iorbehavior of each tag. HTML.Tag deﬁnes constants for all of the standard HTML
tags. It can be subclassed to add support for custom tags used with a customized HTML
parser.
public static class HTML.Tag {
// Protected Constructors
protected Tag(String id);
protected Tag(String id, boolean causesBreak, boolean isBlock);
// Public Constants
public static ﬁnal HTML.Tag A;
public static ﬁnal HTML.Tag ADDRESS;
public static ﬁnal HTML.Tag APPLET;
public static ﬁnal HTML.Tag AREA;
public static ﬁnal HTML.Tag B;
public static ﬁnal HTML.Tag BASE;
public static ﬁnal HTML.Tag BASEFONT;
public static ﬁnal HTML.Tag BIG;
public static ﬁnal HTML.Tag BLOCKQUOTE;
public static ﬁnal HTML.Tag BODY;
public static ﬁnal HTML.Tag BR;
public static ﬁnal HTML.Tag CAPTION;
public static ﬁnal HTML.Tag CENTER;
public static ﬁnal HTML.Tag CITE;
public static ﬁnal HTML.Tag CODE;
public static ﬁnal HTML.Tag COMMENT;
public static ﬁnal HTML.Tag CONTENT;
public static ﬁnal HTML.Tag DD;
public static ﬁnal HTML.Tag DFN;
public static ﬁnal HTML.Tag DIR;
public static ﬁnal HTML.Tag DIV;
public static ﬁnal HTML.Tag DL;
public static ﬁnal HTML.Tag DT;
public static ﬁnal HTML.Tag EM;
public static ﬁnal HTML.Tag FONT;
public static ﬁnal HTML.Tag FORM;
public static ﬁnal HTML.Tag FRAME;
public static ﬁnal HTML.Tag FRAMESET;
public static ﬁnal HTML.Tag H1;
javax.swing.
text.html
javax.swing.text.html.HTML.Tag
Chapter 31 – The javax.swing.text.html Package
639

public static ﬁnal HTML.Tag H2;
public static ﬁnal HTML.Tag H3;
public static ﬁnal HTML.Tag H4;
public static ﬁnal HTML.Tag H5;
public static ﬁnal HTML.Tag H6;
public static ﬁnal HTML.Tag HEAD;
public static ﬁnal HTML.Tag HR;
public static ﬁnal HTML.Tag HTML;
public static ﬁnal HTML.Tag I;
public static ﬁnal HTML.Tag IMG;
public static ﬁnal HTML.Tag IMPLIED;
public static ﬁnal HTML.Tag INPUT;
public static ﬁnal HTML.Tag ISINDEX;
public static ﬁnal HTML.Tag KBD;
public static ﬁnal HTML.Tag LI;
public static ﬁnal HTML.Tag LINK;
public static ﬁnal HTML.Tag MAP;
public static ﬁnal HTML.Tag MENU;
public static ﬁnal HTML.Tag META;
public static ﬁnal HTML.Tag NOFRAMES;
public static ﬁnal HTML.Tag OBJECT;
public static ﬁnal HTML.Tag OL;
public static ﬁnal HTML.Tag OPTION;
public static ﬁnal HTML.Tag P;
public static ﬁnal HTML.Tag PARAM;
public static ﬁnal HTML.Tag PRE;
public static ﬁnal HTML.Tag S;
public static ﬁnal HTML.Tag SAMP;
public static ﬁnal HTML.Tag SCRIPT;
public static ﬁnal HTML.Tag SELECT;
public static ﬁnal HTML.Tag SMALL;
public static ﬁnal HTML.Tag STRIKE;
public static ﬁnal HTML.Tag STRONG;
public static ﬁnal HTML.Tag STYLE;
public static ﬁnal HTML.Tag SUB;
public static ﬁnal HTML.Tag SUP;
public static ﬁnal HTML.Tag TABLE;
public static ﬁnal HTML.Tag TD;
public static ﬁnal HTML.Tag TEXTAREA;
public static ﬁnal HTML.Tag TH;
public static ﬁnal HTML.Tag TITLE;
public static ﬁnal HTML.Tag TR;
public static ﬁnal HTML.Tag TT;
public static ﬁnal HTML.Tag U;
public static ﬁnal HTML.Tag UL;
public static ﬁnal HTML.Tag VAR;
// Public Instance Methods
public boolean breaksFlow();
public boolean isBlock();
public boolean isPrefor matted();
// Public Methods Overriding Object
public String toString();
}
Subc lasses: HTML.UnknownTag
Passed To: Too many methods to list.
javax.swing.text.html.HTML.Tag
640 Chapter 31 – The javax.swing.text.html Package

Retur ned By: HTML.{getAllTags(), getTag()}, HTMLDocument.Iterator.getTag(),
javax.swing .text.html.parser.TagElement.getHTMLTag()
Type Of: Too many fields to list.
HTML.UnknownTag
Ja va 1.2
javax.swing .text.html
serializable
This HTML.Tag subclass is used to repr esent nonstandard tags that the HTML parser does
not recognize.
public static class HTML.UnknownTag extends HTML.Tag implements Serializable {
// Public Constructors
public UnknownTag(String id);
// Public Methods Overriding Object
public boolean equals(Object obj);
public int hashCode();
}
HTMLDocument
Ja va 1.2
javax.swing .text.html
serializable
This class repr esents an HTML document, optionally augmented with CSS style sheets.
The document is composed of a tree of BlockElement and RunElement objects, each of
which has an HTML.Tag object speciﬁed as the value of its StyleContext.NameAttribute
attribute. setBase() speciﬁes a base URL relative to which hyperlinks in the document
ar e interpr eted. setTokenThreshold() speciﬁes how many parsed tokens should be parsed
befor e they are inserted into the document. setPreser vesUnknownTags() speciﬁes whether
unknown tags in a document should be saved in the document structure or discarded.
If you are not writing the document back out, they usually can be discarded. getStyle-
Sheet() retur ns a StyleSheet object that repr esents any CSS style sheet that appeared in
the document itself. getIterator() retur ns an HTMLDocument.Iterator object that can be used
to ﬁnd all tags of a given type in the document. The getReader() methods retur n an HTML-
Document.HTMLReader object that converts method calls from the HTML parser into docu-
ment elements. Subclasses that want to perfor m customized HTML parsing should
override these methods to retur n an appropriately customized subclass of HTMLReader.
public class HTMLDocument extends DefaultStyledDocument {
// Public Constructors
public HTMLDocument();
public HTMLDocument(StyleSheet styles);
public HTMLDocument(AbstractDocument.Content c, StyleSheet styles);
// Public Constants
="AdditionalComments"
public static ﬁnal String AdditionalComments;
// Inner Classes
public class BlockElement extends AbstractDocument.BranchElement;
public class HTMLReader extends HTMLEditorKit.ParserCallback;
public abstract static class Iterator;
public class RunElement extends AbstractDocument.LeafElement;
// Property Accessor Methods (by property name)
default:null
public java.net.URL getBase();
public void setBase(java.net.URL u);
default:true
public boolean getPreser vesUnknownTags();
public void setPreser vesUnknownTags(boolean preser vesTags);
public StyleSheet getStyleSheet();
default:2147483647
public int getTokenThreshold();
public void setTokenThreshold(int n);
javax.swing.
text.html
javax.swing.text.html.HTMLDocument
Chapter 31 – The javax.swing.text.html Package
641

// Public Instance Methods
public HTMLDocument.Iterator getIterator(HTML.Tag t);
public HTMLEditorKit.ParserCallback getReader(int pos);
public HTMLEditorKit.ParserCallback getReader(int pos, int popDepth, int pushDepth, HTML.Tag inser tTag);
public void processHTMLFrameHyper linkEvent(HTMLFrameHyperlinkEvent e);
// Public Methods Overriding DefaultStyledDocument
public void setParagraphAttributes(int offset, int length, AttributeSet s, boolean replace);
// Protected Methods Overriding DefaultStyledDocument
protected void create(DefaultStyledDocument.ElementSpec[ ] data);
protected AbstractDocument.AbstractElement createDefaultRoot();
protected void inser t(int offset, DefaultStyledDocument.ElementSpec[ ] data) throws BadLocationException;
protected void inser tUpdate(AbstractDocument.DefaultDocumentEvent chng, AttributeSet attr);
// Protected Methods Overriding AbstractDocument
protected javax.swing.text.Element createBranchElement(javax.swing .text.Element parent, AttributeSet a);
protected javax.swing.text.Element createLeafElement(javax.swing .text.Element parent, AttributeSet a, int p0,
int p1);
protected void ﬁreChangedUpdate(javax.swing .event.DocumentEvent e);
protected void ﬁreUndoableEditUpdate(javax.swing .event.UndoableEditEvent e);
}
Hierar chy: Object→AbstractDocument(Document, Serializable)→
DefaultStyledDocument(StyledDocument(Document))→HTMLDocument
Passed To: HTMLEditorKit.inser tHTML(), HTMLEditorKit.HTMLTextAction.{elementCountToTag(),
findElementMatchingTag(), getElementsAt()}, HTMLEditorKit.InsertHTMLTextAction.{inser tAtBoundry(),
inser tHTML()}, HTMLWriter.HTMLWriter()
Retur ned By: HTMLEditorKit.HTMLTextAction.getHTMLDocument()
HTMLDocument.BlockElement
Ja va 1.2
javax.swing .text.html
serializable
This class is used to repr esent block elements (i.e., elements that contain other ele-
ments) of an HTML document.
public class HTMLDocument.BlockElement extends AbstractDocument.BranchElement {
// Public Constructors
public BlockElement(javax.swing .text.Element parent, AttributeSet a);
// Public Methods Overriding AbstractDocument.BranchElement
public String getName();
// Public Methods Overriding AbstractDocument.AbstractElement
constant
public AttributeSet getResolveParent();
}
HTMLDocument.HTMLReader
Ja va 1.2
javax.swing .text.html
This class implements the HTMLEditorKit.ParserCallback inter face and serves as an adapter
between the HTML parser of the javax.swing .text.html.parser package and the HTMLDocument
class. The parser invokes methods of the HTMLReader object, and the HTMLReader is
responsible for converting those methods into content in the HTMLDocument. This class
deﬁnes a number of inner classes of type HTMLDocument.HTMLReader.TagAction. These
classes deﬁne special code to be executed when the parser encounters particular start
and end tags. HTMLDocument.HTMLReader subclasses can perfor m customized HTML pars-
ing by deﬁning new TagAction subclasses and associating them with speciﬁc HTML tags
by calling registerTag().
javax.swing.text.html.HTMLDocument
642 Chapter 31 – The javax.swing.text.html Package

public class HTMLDocument.HTMLReader extends HTMLEditorKit.ParserCallback {
// Public Constructors
public HTMLReader(int offset);
public HTMLReader(int offset, int popDepth, int pushDepth, HTML.Tag inser tTag);
// Inner Classes
public class BlockAction extends HTMLDocument.HTMLReader.TagAction;
public class CharacterAction extends HTMLDocument.HTMLReader.TagAction;
public class FormAction extends HTMLDocument.HTMLReader.SpecialAction;
public class HiddenAction extends HTMLDocument.HTMLReader.TagAction;
public class IsindexAction extends HTMLDocument.HTMLReader.TagAction;
public class ParagraphAction extends HTMLDocument.HTMLReader.BlockAction;
public class PreAction extends HTMLDocument.HTMLReader.BlockAction;
public class SpecialAction extends HTMLDocument.HTMLReader.TagAction;
public class TagAction;
// Public Methods Overriding HTMLEditorKit.ParserCallback
public void ﬂush() throws BadLocationException;
public void handleComment(char[ ] data, int pos);
public void handleEndTag(HTML.Tag t, int pos);
public void handleSimpleTag(HTML.Tag t, MutableAttributeSet a, int pos);
public void handleStar tTag(HTML.Tag t, MutableAttributeSet a, int pos);
public void handleText(char[ ] data, int pos);
// Protected Instance Methods
protected void addContent(char[ ] data, int offs, int length);
protected void addContent(char[ ] data, int offs, int length, boolean generateImpliedPIfNecessary);
protected void addSpecialElement(HTML.Tag t, MutableAttributeSet a);
protected void blockClose(HTML.Tag t);
protected void blockOpen(HTML.Tag t, MutableAttributeSet attr);
protected void popCharacterStyle();
protected void preContent(char[ ] data);
protected void pushCharacterStyle();
protected void registerTag(HTML.Tag t, HTMLDocument.HTMLReader.TagAction a);
protected void textAreaContent(char[ ] data);
// Protected Instance Fields
protected MutableAttributeSet charAttr;
protected java.util.Vector parseBuffer;
}
HTMLDocument.HTMLReader.BlockAction
Ja va 1.2
javax.swing .text.html
This TagAction handles blocks, such as <TD> and <DIV> tags.
public class HTMLDocument.HTMLReader.BlockAction extends HTMLDocument.HTMLReader.TagAction {
// Public Constructors
public BlockAction();
// Public Methods Overriding HTMLDocument.HTMLReader.TagAction
public void end(HTML.Tag t);
public void star t(HTML.Tag t, MutableAttributeSet attr);
}
Subc lasses: HTMLDocument.HTMLReader.ParagraphAction, HTMLDocument.HTMLReader.PreAction
HTMLDocument.HTMLReader.CharacterAction
Ja va 1.2
javax.swing .text.html
This TagAction handles character elements, such as <B> and <FONT> tags.
javax.swing.
text.html
javax.swing.text.html.HTMLDocument.HTMLReader.CharacterAction
Chapter 31 – The javax.swing.text.html Package
643

public class HTMLDocument.HTMLReader.CharacterAction extends HTMLDocument.HTMLReader.TagAction {
// Public Constructors
public CharacterAction();
// Public Methods Overriding HTMLDocument.HTMLReader.TagAction
public void end(HTML.Tag t);
public void star t(HTML.Tag t, MutableAttributeSet attr);
}
HTMLDocument.HTMLReader.For mAction
Ja va 1.2
javax.swing .text.html
This TagAction handles form elements, such as <INPUT> and <SELECT> tags.
public class HTMLDocument.HTMLReader.For mAction extends HTMLDocument.HTMLReader.SpecialAction {
// Public Constructors
public FormAction();
// Public Methods Overriding HTMLDocument.HTMLReader.SpecialAction
public void star t(HTML.Tag t, MutableAttributeSet attr);
// Public Methods Overriding HTMLDocument.HTMLReader.TagAction
public void end(HTML.Tag t);
}
HTMLDocument.HTMLReader.HiddenAction
Ja va 1.2
javax.swing .text.html
This TagAction handles elements that have no visual appearance, such as <LINK> and
<MAP> tags.
public class HTMLDocument.HTMLReader.HiddenAction extends HTMLDocument.HTMLReader.TagAction {
// Public Constructors
public HiddenAction();
// Public Methods Overriding HTMLDocument.HTMLReader.TagAction
public void end(HTML.Tag t);
public void star t(HTML.Tag t, MutableAttributeSet a);
}
HTMLDocument.HTMLReader.IsindexAction
Ja va 1.2
javax.swing .text.html
This TagAction handles the <ISINDEX> tag.
public class HTMLDocument.HTMLReader.IsindexAction extends HTMLDocument.HTMLReader.TagAction {
// Public Constructors
public IsindexAction();
// Public Methods Overriding HTMLDocument.HTMLReader.TagAction
public void star t(HTML.Tag t, MutableAttributeSet a);
}
HTMLDocument.HTMLReader.ParagraphAction
Ja va 1.2
javax.swing .text.html
This TagAction handles paragraph elements, such as <P> and <H1> tags.
public class HTMLDocument.HTMLReader.ParagraphAction extends HTMLDocument.HTMLReader.BlockAction {
// Public Constructors
public ParagraphAction();
javax.swing.text.html.HTMLDocument.HTMLReader.CharacterAction
644 Chapter 31 – The javax.swing.text.html Package

// Public Methods Overriding HTMLDocument.HTMLReader.BlockAction
public void end(HTML.Tag t);
public void star t(HTML.Tag t, MutableAttributeSet a);
}
HTMLDocument.HTMLReader.PreAction
Ja va 1.2
javax.swing .text.html
This TagAction handles the <PRE> tag.
public class HTMLDocument.HTMLReader.PreAction extends HTMLDocument.HTMLReader.BlockAction {
// Public Constructors
public PreAction();
// Public Methods Overriding HTMLDocument.HTMLReader.BlockAction
public void end(HTML.Tag t);
public void star t(HTML.Tag t, MutableAttributeSet attr);
}
HTMLDocument.HTMLReader.SpecialAction
Ja va 1.2
javax.swing .text.html
This TagAction handles elements that requir e special handling, such as <OBJECT> and
<FRAME> tags.
public class HTMLDocument.HTMLReader.SpecialAction extends HTMLDocument.HTMLReader.TagAction {
// Public Constructors
public SpecialAction();
// Public Methods Overriding HTMLDocument.HTMLReader.TagAction
public void star t(HTML.Tag t, MutableAttributeSet a);
}
Subc lasses: HTMLDocument.HTMLReader.For mAction
HTMLDocument.HTMLReader.TagAction
Ja va 1.2
javax.swing .text.html
This class deﬁnes methods that are called when the HTML parser encounters start and
end tags of a particular type. To customize HTML parsing, implement a subclass of Tag-
Action, create an instance, and register it with an HTMLReader subclass by calling regis-
terTag().
public class HTMLDocument.HTMLReader.TagAction {
// Public Constructors
public TagAction();
// Public Instance Methods
empty
public void end(HTML.Tag t);
empty
public void star t(HTML.Tag t, MutableAttributeSet a);
}
Subc lasses: HTMLDocument.HTMLReader.BlockAction, HTMLDocument.HTMLReader.CharacterAction,
HTMLDocument.HTMLReader.HiddenAction, HTMLDocument.HTMLReader.IsindexAction,
HTMLDocument.HTMLReader.SpecialAction
Passed To: HTMLDocument.HTMLReader.registerTag()
javax.swing.
text.html
javax.swing.text.html.HTMLDocument.HTMLReader.TagAction
Chapter 31 – The javax.swing.text.html Package
645

HTMLDocument.Iterator
Ja va 1.2
javax.swing .text.html
This class is used to iterate through an HTMLDocument, retur ning only tags of a speciﬁed
type. This class is abstract and cannot be instantiated. Call the getIterator() method of
HTMLDocument to obtain an instance that retur ns all instances of a speciﬁed HTML.Tag.
getAttributes(), getStar tOffset(), and getEndOffset() retur n infor mation about the current tag.
next() moves the iterator to the next tag, and isValid() retur ns tr ue if there is a curr ent tag
or false if there are no mor e tags.
public abstract static class HTMLDocument.Iterator {
// Public Constructors
public Iterator();
// Property Accessor Methods (by property name)
public abstract AttributeSet getAttributes();
public abstract int getEndOffset();
public abstract int getStar tOffset();
public abstract HTML.Tag getTag();
public abstract boolean isValid();
// Public Instance Methods
public abstract void next();
}
Retur ned By: HTMLDocument.getIterator()
HTMLDocument.RunElement
Ja va 1.2
javax.swing .text.html
serializable
This class is used to repr esent content elements of an HTML document.
public class HTMLDocument.RunElement extends AbstractDocument.LeafElement {
// Public Constructors
public RunElement(javax.swing .text.Element parent, AttributeSet a, int offs0, int offs1);
// Public Methods Overriding AbstractDocument.LeafElement
public String getName();
// Public Methods Overriding AbstractDocument.AbstractElement
constant
public AttributeSet getResolveParent();
}
HTMLEditorKit
Ja va 1.2
javax.swing .text.html
cloneable serializable
This class is used to customize a JEditorPane component to display and edit HTML docu-
ments. Most applications need do nothing more than instantiate an HTMLEditorKit and
pass it to the setEditorKit() method of a JEditorPane. The write() method converts the con-
tents of an HTMLDocument into HTML text and writes it to the speciﬁed stream. The read()
method parses HTML text from a stream and creates a corresponding element structure
in the speciﬁed HTMLDocument. inser tHTML() parses HTML text from a string and inserts it
into the speciﬁed HTMLDocument.
You can customize the appearance of HTML text displayed using an HTMLEditorKit by
passing a StyleSheet object to setStyleSheet(). Other customizations requir e you to sub-
class HTMLEditorKit and override some of its methods. Override getV iewFactor y() if you
want to use customized View subclasses to display certain HTML document elements.
Override createDefaultDocument() if you want to change the properties of the default
HTMLDocument or if you want to retur n a subclass of HTMLDocument. Override getParser() if
you want to use a custom HTML parser implementation, instead of the default parser
implemented in javax.swing .text.html.parser.
javax.swing.text.html.HTMLDocument.Iterator
646 Chapter 31 – The javax.swing.text.html Package

public class HTMLEditorKit extends StyledEditorKit {
// Public Constructors
public HTMLEditorKit();
// Public Constants
="html-bold-action"
public static ﬁnal String BOLD_ACTION;
="html-color-action"
public static ﬁnal String COLOR_ACTION;
="default.css"
public static ﬁnal String DEFAULT_CSS;
="html-font-bigger"
public static ﬁnal String FONT_CHANGE_BIGGER;
="html-font-smaller"
public static ﬁnal String FONT_CHANGE_SMALLER;
="html-image-align-bottom"
public static ﬁnal String IMG_ALIGN_BOTTOM;
="html-image-align-middle"
public static ﬁnal String IMG_ALIGN_MIDDLE;
="html-image-align-top"
public static ﬁnal String IMG_ALIGN_TOP;
="html-image-border"
public static ﬁnal String IMG_BORDER;
="html-italic-action"
public static ﬁnal String ITALIC_ACTION;
="html-logical-style-action"
public static ﬁnal String LOGICAL_STYLE_ACTION;
="html-para-indent-left"
public static ﬁnal String PARA_INDENT_LEFT;
="html-para-indent-right"
public static ﬁnal String PARA_INDENT_RIGHT;
// Inner Classes
public static class HTMLFactor y implements Vie wFactory;
public abstract static class HTMLTextAction extends StyledEditorKit.StyledTextAction;
public static class Inser tHTMLTextAction extends HTMLEditorKit.HTMLTextAction;
public static class LinkController extends java.awt.event.MouseAdapter implements Serializable;
public abstract static class Parser;
public static class ParserCallback;
// Public Instance Methods
public StyleSheet getStyleSheet();
public void inser tHTML(HTMLDocument doc, int offset, String html, int popDepth, int pushDepth,
HTML.Tag inser tTag) throws BadLocationException, java.io.IOException;
public void setStyleSheet(StyleSheet s);
// Public Methods Overriding StyledEditorKit
public Object clone();
public Document createDefaultDocument();
public void deinstall(JEditorPane c);
public Action[ ] getActions();
default:NamedStyle
public MutableAttributeSet getInputAttributes();
default:HTMLFactory
public Vie wFactory getV iewFactor y();
public void install(JEditorPane c);
// Protected Methods Overriding StyledEditorKit
protected void createInputAttributes(javax.swing .text.Element element, MutableAttributeSet set);
// Public Methods Overriding DefaultEditorKit
default:"text/html"
public String getContentType();
public void read(java.io.Reader in, Document doc, int pos) throws java.io.IOException, BadLocationException;
public void write(java.io.Writer out, Document doc, int pos, int len) throws java.io.IOException,
BadLocationException;
// Protected Instance Methods
protected HTMLEditorKit.Parser getParser();
}
Hierar chy: Object→EditorKit(Cloneable, Serializable)→DefaultEditorKit→StyledEditorKit→
HTMLEditorKit
Retur ned By: HTMLEditorKit.HTMLTextAction.getHTMLEditorKit()
HTMLEditorKit.HTMLFactor y
Ja va 1.2
javax.swing .text.html
This class is a ViewFactor y for HTML documents. Its create() method retur ns a View object
that is appropriate for the display of a given Element object. The View object is an
instance of one of the View subclasses deﬁned in this package.
javax.swing.
text.html
javax.swing.text.html.HTMLEditorKit.HTMLFactor y
Chapter 31 – The javax.swing.text.html Package
647

public static class HTMLEditorKit.HTMLFactor y implements Vie wFactory {
// Public Constructors
public HTMLFactor y();
// Methods Implementing ViewFactory
public Vie w create(javax.swing .text.Element elem);
}
HTMLEditorKit.HTMLTextAction
Ja va 1.2
javax.swing .text.html
cloneable serializable
This class is an abstract Action implementation that provides protected convenience
methods that may be helpful to Action implementations that manipulate or edit an HTML-
Document.
public abstract static class HTMLEditorKit.HTMLTextAction extends StyledEditorKit.StyledTextAction {
// Public Constructors
public HTMLTextAction(String name);
// Protected Instance Methods
protected int elementCountToTag(HTMLDocument doc, int offset, HTML.Tag tag);
protected javax.swing.text.Element ﬁndElementMatchingTag(HTMLDocument doc, int offset, HTML.Tag tag);
protected javax.swing.text.Element[ ] getElementsAt(HTMLDocument doc, int offset);
protected HTMLDocument getHTMLDocument(JEditorPane e);
protected HTMLEditorKit getHTMLEditorKit(JEditorPane e);
}
Subc lasses: HTMLEditorKit.Inser tHTMLTextAction
HTMLEditorKit.Inser tHTMLTextAction
Ja va 1.2
javax.swing .text.html
cloneable serializable
This Action implementation can be used to insert HTML text into an HTML document at
the current location. You can create custom instances of this class and bind them to
KeyStroke objects to provide custom editing actions for your users. When you create an
Inser tHTMLTextAction instance, you must specify the string of HTML text to be inserted and
two HTML.Tag objects. The ﬁrst HTML.Tag speciﬁes the parent tag of the inserted text. For
example, if the text you are inserting belongs in a paragraph element, you specify
HTML.Tag .P. If the text you are inserting is a <DIV> or a <TABLE>, you specify HTML.Tag .BODY.
The second HTML.Tag you must specify is the ﬁrst tag of the parsed HTML string that is
actually being inserted. For example, you may want to insert only a <TD> tag but may
have to specify an HTML string that contains <TABLE> and <TR> tags so that the parser
can correctly parse the HTML text. In this case, your second HTML.Tag argument is
HTML.Tag .TD.
public static class HTMLEditorKit.Inser tHTMLTextAction extends HTMLEditorKit.HTMLTextAction {
// Public Constructors
public Inser tHTMLTextAction(String name, String html, HTML.Tag parentTag, HTML.Tag addTag);
public Inser tHTMLTextAction(String name, String html, HTML.Tag parentTag, HTML.Tag addTag,
HTML.Tag alternateParentTag, HTML.Tag alternateAddTag);
// Public Methods Overriding AbstractAction
public void actionPerfor med(java.awt.e vent.ActionEvent ae);
// Protected Instance Methods
protected void inser tAtBoundry(JEditorPane editor, HTMLDocument doc, int offset,
javax.swing .text.Element inser tElement, String html, HTML.Tag parentTag,
HTML.Tag addTag);
protected void inser tHTML(JEditorPane editor, HTMLDocument doc, int offset, String html, int popDepth,
int pushDepth, HTML.Tag addTag);
javax.swing.text.html.HTMLEditorKit.HTMLFactor y
648 Chapter 31 – The javax.swing.text.html Package

// Protected Instance Fields
protected HTML.Tag addTag;
protected HTML.Tag alter nateAddTag;
protected HTML.Tag alter nateParentTag;
protected String html;
protected HTML.Tag parentTag;
}
HTMLEditorKit.LinkController
Ja va 1.2
javax.swing .text.html
serializable
This class is a MouseAdapter that listens for mouse clicks and responds when the user
clicks the mouse on a hyperlink. An instance of this class is installed on a JEditorPane by
the install() method of the HTMLEditorKit.
public static class HTMLEditorKit.LinkController extends java.awt.event.MouseAdapter implements Serializable {
// Public Constructors
public LinkController();
// Public Methods Overriding MouseAdapter
public void mouseClicked(java.awt.e vent.MouseEvent e);
// Protected Instance Methods
protected void activateLink(int pos, JEditorPane editor);
}
HTMLEditorKit.Parser
Ja va 1.2
javax.swing .text.html
This is the abstract superclass of any class that wants to serve as an HTML parser for an
HTMLEditorKit. The parse() method must read HTML text from the speciﬁed stream and
convert the structure of the HTML text into a sequence of calls to the appropriate meth-
ods of the speciﬁed HTMLEditorKit.ParserCallback object. It is the responsibility of the Parser-
Callback object to initialize the HTMLDocument as appropriate in response to those method
calls. If the ignoreCharSet argument is tr ue, the parser ignores any HTML <META> tags that
specify the document encoding. If this argument is false and the parser encounters such
a tag, it should compare the document-speciﬁed encoding to the encoding used by the
Reader str eam fr om which it is reading. If the encodings do not match, it should throw a
javax.swing .text.ChangedCharSetException.
Most applications can rely on the full-featured HTML parser provided by the
javax.swing .text.html.parser package and do not need to subclass this class. The default
parser is DTD-driven and can also be customized by providing a custom DTD. If you
implement your own Parser subclass or customize the default parser, you must subclass
HTMLEditorKit and override the getParser() method.
public abstract static class HTMLEditorKit.Parser {
// Public Constructors
public Parser();
// Public Instance Methods
public abstract void parse(java.io.Reader r, HTMLEditorKit.ParserCallback cb, boolean ignoreCharSet)
throws java.io.IOException;
}
Subc lasses: javax.swing .text.html.parser.ParserDelegator
Retur ned By: HTMLEditorKit.getParser()
javax.swing.
text.html
javax.swing.text.html.HTMLEditorKit.Par ser
Chapter 31 – The javax.swing.text.html Package
649

HTMLEditorKit.ParserCallback
Ja va 1.2
javax.swing .text.html
This class deﬁnes the methods that are invoked by an HTMLEditorKit.Parser to describe the
structur e of an HTML document. The methods should be implemented to add appropri-
ate content to an HTMLDocument. HTMLEditorKit uses an HTMLDocument.HTMLReader object as
its default implementation of ParserCallback.
public static class HTMLEditorKit.ParserCallback {
// Public Constructors
public ParserCallback();
// Public Instance Methods
empty
public void ﬂush() throws BadLocationException;
empty
public void handleComment(char[ ] data, int pos);
empty
public void handleEndTag(HTML.Tag t, int pos);
empty
public void handleEr ror(String errorMsg, int pos);
empty
public void handleSimpleTag(HTML.Tag t, MutableAttributeSet a, int pos);
empty
public void handleStar tTag(HTML.Tag t, MutableAttributeSet a, int pos);
empty
public void handleText(char[ ] data, int pos);
}
Subc lasses: HTMLDocument.HTMLReader
Passed To: HTMLEditorKit.Parser.parse(), javax.swing .text.html.parser.DocumentParser.parse(),
javax.swing .text.html.parser.ParserDelegator.parse()
Retur ned By: HTMLDocument.getReader()
HTMLFrameHyper linkEvent
Ja va 1.2
javax.swing .text.html
serializable event
This class is an extension of Hyper linkEvent that is used when a hyperlink in one frame
refers to another frame with an HTML TARGET attribute. getSourceElement() retur ns the Ele-
ment object in the HTMLDocument that corresponds to the <FRAME> tag of the source
frame. getTarget() retur ns a string that speciﬁes the target frame. This may be a frame
name or one of the standard special target names, “_self”, “_parent”, or “_top”. The pro-
cessHTMLFrameHyper linkEvent() method of HTMLDocument can handle events of this type.
public class HTMLFrameHyper linkEvent extends javax.swing.e vent.HyperlinkEvent {
// Public Constructors
public HTMLFrameHyper linkEvent(Object source, javax.swing .event.HyperlinkEvent.EventType type,
java.net.URL targetURL, String targetFrame);
public HTMLFrameHyper linkEvent(Object source, javax.swing .event.HyperlinkEvent.EventType type,
java.net.URL targetURL, javax.swing .text.Element sourceElement,
String targetFrame);
public HTMLFrameHyper linkEvent(Object source, javax.swing .event.HyperlinkEvent.EventType type,
java.net.URL targetURL, String desc, String targetFrame);
public HTMLFrameHyper linkEvent(Object source, javax.swing .event.HyperlinkEvent.EventType type,
java.net.URL targetURL, String desc, javax.swing .text.Element sourceElement,
String targetFrame);
// Public Instance Methods
public javax.swing.text.Element getSourceElement();
public String getTarget();
}
Hierar chy: Object→java.util.EventObject(Serializable)→javax.swing .event.Hyper linkEvent→
HTMLFrameHyper linkEvent
Passed To: HTMLDocument.processHTMLFrameHyper linkEvent()
javax.swing.text.html.HTMLEditorKit.Par serCallback
650 Chapter 31 – The javax.swing.text.html Package

HTMLWriter
Ja va 1.2
javax.swing .text.html
This class knows how to convert an HTMLDocument to textual form and write it to a spec-
iﬁed stream. To use an HTMLWriter, simply pass an HTMLDocument and a Writer str eam to
the constructor, then call the public write() method. The various protected methods are
used internally to output the document and can be overridden in a subclass to cus-
tomize the HTML output process.
public class HTMLWriter extends AbstractWriter {
// Public Constructors
public HTMLWriter(java.io.Writer w, HTMLDocument doc);
public HTMLWriter(java.io.Writer w, HTMLDocument doc, int pos, int len);
// Public Methods Overriding AbstractWriter
public void write() throws java.io.IOException, BadLocationException;
// Protected Methods Overriding AbstractWriter
protected void decrIndent();
protected void incrIndent();
protected void indent() throws java.io.IOException;
protected void setIndentSpace(int space);
protected void setLineLength(int l);
protected void text(javax.swing .text.Element elem) throws BadLocationException, java.io.IOException;
protected void write(String content) throws java.io.IOException;
protected void write(char ch) throws java.io.IOException;
protected void writeAttributes(AttributeSet attr) throws java.io.IOException;
// Protected Instance Methods
protected void closeOutUnwantedEmbeddedTags(AttributeSet attr) throws java.io.IOException;
protected void comment(javax.swing .text.Element elem) throws BadLocationException, java.io.IOException;
protected void emptyTag(javax.swing .text.Element elem) throws BadLocationException, java.io.IOException;
protected void endTag(javax.swing .text.Element elem) throws java.io.IOException;
protected boolean isBlockTag(AttributeSet attr);
protected boolean matchNameAttribute(AttributeSet attr, HTML.Tag tag);
protected void selectContent(AttributeSet attr) throws java.io.IOException;
protected void star tTag(javax.swing .text.Element elem) throws java.io.IOException, BadLocationException;
protected boolean synthesizedElement(javax.swing .text.Element elem);
protected void textAreaContent(AttributeSet attr) throws BadLocationException, java.io.IOException;
protected void writeEmbeddedTags(AttributeSet attr) throws java.io.IOException;
protected void writeOption(Option option) throws java.io.IOException;
}
Hierar chy: Object→AbstractWriter→HTMLWriter
InlineV iew
Ja va 1.2
javax.swing .text.html
This View class displays styled text that appears in an HTML document. It extends
javax.swing .text.LabelView to add support for CSS attributes.
public class InlineV iew extends LabelVie w {
// Public Constructors
public InlineV iew(javax.swing .text.Element elem);
// Public Methods Overriding LabelView
public void changedUpdate(javax.swing .event.DocumentEvent e, java.awt.Shape a, Vie wFactory f);
// Protected Methods Overriding LabelView
protected void setProper tiesFromAttributes();
// Public Methods Overriding View
public AttributeSet getAttributes();
javax.swing.
text.html
javax.swing.text.html.InlineView
Chapter 31 – The javax.swing.text.html Package
651

// Protected Instance Methods
protected StyleSheet getStyleSheet();
}
Hierar chy: Object→View(SwingConstants)→LabelV iew→InlineV iew
ListV iew
Ja va 1.2
javax.swing .text.html
This View class displays HTML list elements.
public class ListV iew extends BlockVie w {
// Public Constructors
public ListV iew(javax.swing .text.Element elem);
// Public Methods Overriding BlockView
public ﬂoat getAlignment(int axis);
public void paint(java.awt.Graphics g, java.awt.Shape allocation);
// Protected Methods Overriding BlockView
protected void setProper tiesFromAttributes();
// Protected Methods Overriding BoxView
protected void paintChild(java.awt.Graphics g, java.awt.Rectangle alloc, int index);
}
Hierar chy: Object→View(SwingConstants)→CompositeV iew→BoxV iew→BlockV iew→ListV iew
MinimalHTMLWriter
Ja va 1.2
javax.swing .text.html
This class knows how to convert an arbitrary StyledDocument to simple HTML text. Its use
is similar to the use of HTMLWriter. Because there is not an exact mapping between the
character and paragraph attributes supported by StyledDocument objects and those
deﬁned by standard HTML tags and attributes, MinimalHTMLWriter relies heavily on CSS
attributes in the HTML text it outputs.
public class MinimalHTMLWriter extends AbstractWriter {
// Public Constructors
public MinimalHTMLWriter(java.io.Writer w, StyledDocument doc);
public MinimalHTMLWriter(java.io.Writer w, StyledDocument doc, int pos, int len);
// Public Methods Overriding AbstractWriter
public void write() throws java.io.IOException, BadLocationException;
// Protected Methods Overriding AbstractWriter
protected void text(javax.swing .text.Element elem) throws java.io.IOException, BadLocationException;
protected void writeAttributes(AttributeSet attr) throws java.io.IOException;
// Protected Instance Methods
protected void endFontTag() throws java.io.IOException;
protected boolean inFontTag();
protected boolean isText(javax.swing .text.Element elem);
protected void star tFontTag(String style) throws java.io.IOException;
protected void writeBody() throws java.io.IOException, BadLocationException;
empty
protected void writeComponent(javax.swing .text.Element elem) throws java.io.IOException;
protected void writeContent(javax.swing .text.Element elem, boolean needsIndenting) throws java.io.IOException,
BadLocationException;
protected void writeEndParagraph() throws java.io.IOException;
protected void writeEndTag(String endTag) throws java.io.IOException;
protected void writeHeader() throws java.io.IOException;
protected void writeHTMLTags(AttributeSet attr) throws java.io.IOException;
empty
protected void writeImage(javax.swing .text.Element elem) throws java.io.IOException;
protected void writeLeaf(javax.swing .text.Element elem) throws java.io.IOException;
javax.swing.text.html.InlineView
652 Chapter 31 – The javax.swing.text.html Package

protected void writeNonHTMLAttributes(AttributeSet attr) throws java.io.IOException;
protected void writeStar tParagraph(javax.swing .text.Element elem) throws java.io.IOException;
protected void writeStar tTag(String tag) throws java.io.IOException;
protected void writeStyles() throws java.io.IOException;
}
Hierar chy: Object→AbstractWriter→MinimalHTMLWriter
ObjectV iew
Ja va 1.2
javax.swing .text.html
This View subclass dynamically loads, instantiates, and displays an arbitrary java.awt.Com-
ponent object speciﬁed by the CLASSID attribute of an HTML <OBJECT> tag.
public class ObjectV iew extends ComponentVie w {
// Public Constructors
public ObjectV iew(javax.swing .text.Element elem);
// Protected Methods Overriding ComponentView
protected Component createComponent();
}
Hierar chy: Object→View(SwingConstants)→ComponentV iew→ObjectV iew
Option
Ja va 1.2
javax.swing .text.html
This class is used internally by HTMLDocument to repr esent <OPTION> tags within a
<SELECT> tag.
public class Option {
// Public Constructors
public Option(AttributeSet attr);
// Property Accessor Methods (by property name)
public AttributeSet getAttributes();
public String getLabel();
public void setLabel(String label);
public boolean isSelected();
public String getValue();
// Public Methods Overriding Object
public String toString();
// Protected Instance Methods
protected void setSelection(boolean state);
}
Passed To: HTMLWriter.writeOption()
ParagraphV iew
Ja va 1.2
javax.swing .text.html
This class displays HTML paragraph elements. It extends the javax.swing .text.ParagraphV iew
class to add support for CSS attributes.
public class ParagraphV iew extends javax.swing.text.ParagraphV ie w {
// Public Constructors
public ParagraphV iew(javax.swing .text.Element elem);
// Public Methods Overriding ParagraphView
public void changedUpdate(javax.swing .event.DocumentEvent e, java.awt.Shape a, Vie wFactory f);
public void paint(java.awt.Graphics g, java.awt.Shape a);
javax.swing.
text.html
javax.swing.text.html.Parag raphView
Chapter 31 – The javax.swing.text.html Package
653

// Protected Methods Overriding ParagraphView
protected SizeRequirements calculateMinorAxisRequirements(int axis, SizeRequirements r);
protected void setProper tiesFromAttributes();
// Public Methods Overriding BoxView
public ﬂoat getMaximumSpan(int axis);
public ﬂoat getMinimumSpan(int axis);
public ﬂoat getPrefer redSpan(int axis);
// Public Methods Overriding CompositeView
public void setParent(V iew parent);
// Public Methods Overriding View
public AttributeSet getAttributes();
public boolean isV isible();
// Protected Instance Methods
protected StyleSheet getStyleSheet();
}
Hierar chy: Object→View(SwingConstants)→CompositeV iew→BoxV iew→
javax.swing .text.ParagraphV iew(TabExpander)→javax.swing .text.html.ParagraphV iew
StyleSheet
Ja va 1.2
javax.swing .text.html
serializable
This class is a StyleContext subclass that repr esents a CSS style sheet. In Java 1.2, it is
only partially implemented. However, it can parse CSS style sheets with the loadRules()
method. View objects are the primary user of this class. A View object calls getV iewAt-
tributes() to obtain an appropriate AttributeSet that takes all cascading styles into account
to use when displaying itself.
StyleSheet also deﬁnes two inner classes that perfor m certain common drawing tasks for
HTML View classes. The getBoxPainter() and getListPainter() methods retur n immutable (pos-
sibly shared and cached) instances of these inner classes that are suitable for drawing
text boxes and list items for a given AttributeSet. Various View implementations use this
cache for efﬁciency.
public class StyleSheet extends StyleContext {
// Public Constructors
public StyleSheet();
// Inner Classes
public static class BoxPainter implements Serializable;
public static class ListPainter implements Serializable;
// Public Class Methods
public static int getIndexOfSize(ﬂoat pt);
// Public Instance Methods
public void addRule(String rule);
public StyleSheet.BoxPainter getBoxPainter(AttributeSet a);
public AttributeSet getDeclaration(String decl);
public StyleSheet.ListPainter getListPainter(AttributeSet a);
public ﬂoat getPointSize(String size);
public ﬂoat getPointSize(int index);
public Style getRule(String selector);
public Style getRule(HTML.Tag t, javax.swing .text.Element e);
public AttributeSet getV iewAttributes(V iew v);
public void loadRules(java.io.Reader in, java.net.URL ref) throws java.io.IOException;
public void setBaseFontSize(String size);
public void setBaseFontSize(int sz);
public java.awt.Color stringToColor(String string);
public AttributeSet translateHTMLToCSS(AttributeSet htmlAttrSet);
javax.swing.text.html.Parag raphView
654 Chapter 31 – The javax.swing.text.html Package

// Public Methods Overriding StyleContext
public AttributeSet addAttribute(AttributeSet old, Object key, Object value);
public AttributeSet addAttributes(AttributeSet old, AttributeSet attr);
public java.awt.Color getBackground(AttributeSet a);
public java.awt.Font getFont(AttributeSet a);
public java.awt.Color getForeground(AttributeSet a);
public AttributeSet removeAttribute(AttributeSet old, Object key);
public AttributeSet removeAttributes(AttributeSet old, AttributeSet attrs);
public AttributeSet removeAttributes(AttributeSet old, java.util.Enumeration names);
public void removeStyle(String nm);
// Protected Methods Overriding StyleContext
protected MutableAttributeSet createLargeAttributeSet(AttributeSet a);
protected StyleContext.SmallAttributeSet createSmallAttributeSet(AttributeSet a);
}
Hierar chy: Object→StyleContext(AbstractDocument.AttributeContext, Serializable)→StyleSheet
Passed To: HTMLDocument.HTMLDocument(), HTMLEditorKit.setStyleSheet()
Retur ned By: BlockV iew.getStyleSheet(), HTMLDocument.getStyleSheet(), HTMLEditorKit.getStyleSheet(),
InlineV iew.getStyleSheet(), javax.swing .text.html.ParagraphV iew.getStyleSheet()
StyleSheet.BoxPainter
Ja va 1.2
javax.swing .text.html
serializable
This class knows how to display the CSS border and background box attributes of an
HTML element. Various HTML View objects use this object to perfor m this drawing.
public static class StyleSheet.BoxPainter implements Serializable {
// No Constructor
// Public Instance Methods
public ﬂoat getInset(int side, Vie w v);
public void paint(java.awt.Graphics g, ﬂoat x, ﬂoat y, ﬂoat w, ﬂoat h, Vie w v);
}
Retur ned By: StyleSheet.getBoxPainter()
StyleSheet.ListPainter
Ja va 1.2
javax.swing .text.html
serializable
This class knows how to display list bullets and numbers as speciﬁed by the various
list-r elated CSS attributes. View objects responsible for displaying HTML lists delegate to
this class to perfor m this drawing.
public static class StyleSheet.ListPainter implements Serializable {
// No Constructor
// Public Instance Methods
public void paint(java.awt.Graphics g, ﬂoat x, ﬂoat y, ﬂoat w, ﬂoat h, Vie w v, int item);
}
Retur ned By: StyleSheet.getListPainter()
javax.swing.
text.html
javax.swing.text.html.StyleSheet.ListPainter
Chapter 31 – The javax.swing.text.html Package
655

CHAPTER 32
The javax.swing.text.html.par ser Package
This package includes classes and interfaces for parsing HTML text. The parser is
conﬁgur ed by a DTD (document type deﬁnition) and is therefor e customizable.
The parser conforms to the HTMLEditorKit.Parser and HTMLEditorKit.ParserCallback inter-
faces deﬁned in the javax.swing .text.html package. Most applications can ignore this
package and simply use javax.swing .JEditorPane and javax.swing .text.html.HTMLEditorKit to
handle their HTML parsing and display needs. Figure 32-1 shows the class hierar-
chy of this package.
AttributeList
Ja va 1.2
javax.swing .text.html.par ser
serializable
This class is an element in a linked list of attribute speciﬁcations. The complete list of
attribute speciﬁcations repr esents an ATTLIST element of a DTD. Each AttributeList object
repr esents the name, type, and values of a single attribute. Use the getNext() method to
obtain the next AttributeList object in the linked list.
public ﬁnal class AttributeList implements DTDConstants, Serializable {
// Public Constructors
public AttributeList(String name);
public AttributeList(String name, int type, int modiﬁer, String value, java.util.Vector values, AttributeList next);
// Public Class Methods
public static int name2type(String nm);
public static String type2name(int tp);
// Property Accessor Methods (by property name)
public int getModiﬁer();
public String getName();
public AttributeList getNext();
public int getType();
public String getValue();
public java.util.Enumeration getValues();
// Public Methods Overriding Object
public String toString();
656

FINAL CLASS
extends
implements
KEY
CLASS
INTERFACE
java.lang
Object
java.io
Serializable
javax.swing.text.html
AttributeList
ContentModel
DTD
Element
Entity
Parser
TagElement
DocumentParser
javax.swing.text.html.parser
HTMLEditorKit.Parser
ParserDelegate
DTDConstants
Figur e 32−1: The javax.swing.text.html.parser package
// Public Instance Fields
public int modiﬁer;
public String name;
public AttributeList next;
public int type;
public String value;
public java.util.Vector values;
}
Hierar chy: Object→AttributeList(DTDConstants, Serializable)
Passed To: AttributeList.AttributeList(), DTD.{defAttributeList(), defElement(), defineAttributes(),
defineElement()}
Retur ned By: AttributeList.getNext(), DTD.defAttributeList(),
javax.swing .text.html.parser.Element.{getAttribute(), getAttributeByValue(), getAttributes()}
Type Of: AttributeList.next, javax.swing .text.html.parser.Element.atts
ContentModel
Ja va 1.2
javax.swing .text.html.par ser
serializable model
This class repr esents a content model of an element in a DTD.
public ﬁnal class ContentModel implements Serializable {
// Public Constructors
public ContentModel();
public ContentModel(javax.swing .text.html.parser.Element content);
public ContentModel(int type, ContentModel content);
public ContentModel(int type, Object content, ContentModel next);
// Public Instance Methods
public boolean empty();
public javax.swing.text.html.parser.Element ﬁrst();
swing.text.
html.parser
javax.swing.text.html.par ser.ContentModel
Chapter 32 – The javax.swing.text.html.par ser Package
657

public boolean ﬁrst(Object token);
public void getElements(java.util.Vector elemVec);
// Public Methods Overriding Object
public String toString();
// Public Instance Fields
public Object content;
public ContentModel next;
public int type;
}
Hierar chy: Object→ContentModel(Serializable)
Passed To: ContentModel.ContentModel(), DTD.{defContentModel(), defElement(), defineElement()}
Retur ned By: DTD.defContentModel(), javax.swing .text.html.parser.Element.getContent()
Type Of: ContentModel.next, javax.swing .text.html.parser.Element.content
DocumentParser
Ja va 1.2
javax.swing .text.html.par ser
This Parser subclass is the delegate of the ParserDelegator class. The parse() method reads
a document from the speciﬁed Reader str eam, parses it using the DTD speciﬁed when
the DocumentParser was created, and notiﬁes the speciﬁed HTMLEditorKit.ParserCallback
object of the document structure by calling its various methods.
public class DocumentParser extends Parser {
// Public Constructors
public DocumentParser(DTD dtd);
// Public Instance Methods
public void parse(java.io.Reader in, HTMLEditorKit.ParserCallback callback, boolean ignoreCharSet)
throws java.io.IOException;
// Protected Methods Overriding Parser
protected void handleComment(char[ ] text);
protected void handleEmptyTag(TagElement tag) throws ChangedCharSetException;
protected void handleEndTag(TagElement tag);
protected void handleEr ror(int ln, String errorMsg);
protected void handleStar tTag(TagElement tag);
protected void handleText(char[ ] data);
}
Hierar chy: Object→Parser(DTDConstants)→DocumentParser
DTD
Ja va 1.2
javax.swing .text.html.par ser
This class repr esents a document type deﬁnition (DTD). A DTD speciﬁes the grammar
of the document to be parsed. The methods of this class allow you to deﬁne the ele-
ments and entities of the grammar and look those elements and entities up by name. It
also deﬁnes a read() method that can read a DTD stored in a binary format. ParserDelega-
tor reads the default HTML 3.2 DTD from the ﬁle html32.bdtd, which is stored in the
same directory or ZIP archive as the DTD.class class ﬁle.
public class DTD implements DTDConstants {
// Protected Constructors
protected DTD(String name);
// Public Class Methods
public static DTD getDTD(String name) throws java.io.IOException;
public static void putDTDHash(String name, DTD dtd);
javax.swing.text.html.par ser.ContentModel
658 Chapter 32 – The javax.swing.text.html.par ser Package

// Public Instance Methods
public Entity defEntity(String name, int type, int ch);
public void deﬁneAttributes(String name, AttributeList atts);
public javax.swing.text.html.parser.Element deﬁneElement(String name, int type, boolean omitStar t,
boolean omitEnd, ContentModel content,
java.util.BitSet exclusions, java.util.BitSet inclusions,
AttributeList atts);
public Entity deﬁneEntity(String name, int type, char[ ] data);
public javax.swing.text.html.parser.Element getElement(String name);
public javax.swing.text.html.parser.Element getElement(int index);
public Entity getEntity(String name);
public Entity getEntity(int ch);
public String getName();
public void read(java.io.DataInputStream in) throws java.io.IOException;
// Public Methods Overriding Object
public String toString();
// Protected Instance Methods
protected AttributeList defAttributeList(String name, int type, int modiﬁer, String value, String values,
AttributeList atts);
protected ContentModel defContentModel(int type, Object obj, ContentModel next);
protected javax.swing.text.html.parser.Element defElement(String name, int type, boolean omitStar t,
boolean omitEnd, ContentModel content,
String[ ] exclusions, String[ ] inclusions,
AttributeList atts);
protected Entity defEntity(String name, int type, String str);
// Public Class Fields
public static int FILE_VERSION;
// Public Instance Fields
public ﬁnal javax.swing.text.html.parser.Element applet;
public ﬁnal javax.swing.text.html.parser.Element base;
public ﬁnal javax.swing.text.html.parser.Element body;
public java.util.Hashtable elementHash;
public java.util.Vector elements;
public java.util.Hashtable entityHash;
public ﬁnal javax.swing.text.html.parser.Element head;
public ﬁnal javax.swing.text.html.parser.Element html;
public ﬁnal javax.swing.text.html.parser.Element isindex;
public ﬁnal javax.swing.text.html.parser.Element meta;
public String name;
public ﬁnal javax.swing.text.html.parser.Element p;
public ﬁnal javax.swing.text.html.parser.Element param;
public ﬁnal javax.swing.text.html.parser.Element pcdata;
public ﬁnal javax.swing.text.html.parser.Element title;
}
Hierar chy: Object→DTD(DTDConstants)
Passed To: DocumentParser.DocumentParser(), DTD.putDTDHash(), Parser.Parser(),
ParserDelegator.createDTD()
Retur ned By: DTD.getDTD(), ParserDelegator.createDTD()
Type Of: Parser.dtd
DTDConstants
Ja va 1.2
javax.swing .text.html.par ser
This interface deﬁnes various integer constants used in a DTD.
swing.text.
html.parser
javax.swing.text.html.par ser.DTDConstants
Chapter 32 – The javax.swing.text.html.par ser Package
659

public abstract interface DTDConstants {
// Public Constants
=19
public static ﬁnal int ANY;
=1
public static ﬁnal int CDATA;
=4
public static ﬁnal int CONREF;
=3
public static ﬁnal int CURRENT;
=131072
public static ﬁnal int DEFAULT;
=17
public static ﬁnal int EMPTY;
=14
public static ﬁnal int ENDTAG;
=3
public static ﬁnal int ENTITIES;
=2
public static ﬁnal int ENTITY;
=1
public static ﬁnal int FIXED;
=65536
public static ﬁnal int GENERAL;
=4
public static ﬁnal int ID;
=5
public static ﬁnal int IDREF;
=6
public static ﬁnal int IDREFS;
=5
public static ﬁnal int IMPLIED;
=16
public static ﬁnal int MD;
=18
public static ﬁnal int MODEL;
=15
public static ﬁnal int MS;
=7
public static ﬁnal int NAME;
=8
public static ﬁnal int NAMES;
=9
public static ﬁnal int NMTOKEN;
=10
public static ﬁnal int NMTOKENS;
=11
public static ﬁnal int NOTATION;
=12
public static ﬁnal int NUMBER;
=13
public static ﬁnal int NUMBERS;
=14
public static ﬁnal int NUTOKEN;
=15
public static ﬁnal int NUTOKENS;
=262144
public static ﬁnal int PARAMETER;
=12
public static ﬁnal int PI;
=10
public static ﬁnal int PUBLIC;
=16
public static ﬁnal int RCDATA;
=2
public static ﬁnal int REQUIRED;
=11
public static ﬁnal int SDATA;
=13
public static ﬁnal int STARTTAG;
=17
public static ﬁnal int SYSTEM;
}
Implementations: AttributeList, DTD, javax.swing .text.html.parser.Element, Entity, Parser
Element
Ja va 1.2
javax.swing .text.html.par ser
serializable
This class encapsulates all of the details of a single ELEMENT of a DTD. It describes the
type of a tag, its allowed attributes and their types, and the content model of the tag.
public ﬁnal class Element implements DTDConstants, Serializable {
// No Constructor
// Public Class Methods
public static int name2type(String nm);
// Property Accessor Methods (by property name)
public AttributeList getAttributes();
public ContentModel getContent();
public boolean isEmpty();
public int getIndex();
public String getName();
public int getType();
javax.swing.text.html.par ser.DTDConstants
660 Chapter 32 – The javax.swing.text.html.par ser Package

// Public Instance Methods
public AttributeList getAttribute(String name);
public AttributeList getAttributeByValue(String name);
public boolean omitEnd();
public boolean omitStar t();
// Public Methods Overriding Object
public String toString();
// Public Instance Fields
public AttributeList atts;
public ContentModel content;
public Object data;
public java.util.BitSet exclusions;
public java.util.BitSet inclusions;
public int index;
public String name;
public boolean oEnd;
public boolean oStar t;
public int type;
}
Hierar chy: Object→javax.swing .text.html.parser.Element(DTDConstants, Serializable)
Passed To: ContentModel.ContentModel(), Parser.{makeTag(), markFirstT ime()}, TagElement.TagElement()
Retur ned By: ContentModel.first(), DTD.{defElement(), defineElement(), getElement()},
TagElement.getElement()
Type Of: DTD.{applet, base, body, head, html, isindex, meta, p, param, pcdata, title}
Entity
Ja va 1.2
javax.swing .text.html.par ser
This class repr esents an ENTITY speciﬁcation in a DTD. It speciﬁes the name, type, and
value of the entity.
public ﬁnal class Entity implements DTDConstants {
// Public Constructors
public Entity(String name, int type, char[ ] data);
// Public Class Methods
public static int name2type(String nm);
// Property Accessor Methods (by property name)
public char[ ] getData();
public boolean isGeneral();
public String getName();
public boolean isParameter();
public String getString();
public int getType();
// Public Instance Fields
public char[ ] data;
public String name;
public int type;
}
Hierar chy: Object→Entity(DTDConstants)
Retur ned By: DTD.{defEntity(), defineEntity(), getEntity()}
swing.text.
html.parser
javax.swing.text.html.par ser.Entity
Chapter 32 – The javax.swing.text.html.par ser Package
661

Parser
Ja va 1.2
javax.swing .text.html.par ser
This class is an HTML parser that uses a DTD object to specify the speciﬁc HTML gram-
mar it should parse. The parse() method reads HTML text from a stream and parses it.
Parser calls its various protected methods at appropriate points during the parsing pro-
cess. In order to do anything useful, a subclass must provide non-empty implementa-
tions for these methods. See also DocumentParser.
public class Parser implements DTDConstants {
// Public Constructors
public Parser(DTD dtd);
// Public Instance Methods
synchronized
public void parse(java.io.Reader in) throws java.io.IOException;
public String parseDTDMarkup() throws java.io.IOException;
// Protected Instance Methods
protected void endTag(boolean omitted);
protected void er ror(String err);
protected void er ror(String err, String arg1);
protected void er ror(String err, String arg1, String arg2);
protected void er ror(String err, String arg1, String arg2, String arg3);
protected void ﬂushAttributes();
protected SimpleAttributeSet getAttributes();
protected int getCur rentLine();
protected int getCur rentPos();
empty
protected void handleComment(char[ ] text);
empty
protected void handleEmptyTag(TagElement tag) throws ChangedCharSetException;
empty
protected void handleEndTag(TagElement tag);
protected void handleEOFInComment();
protected void handleEr ror(int ln, String msg);
empty
protected void handleStar tTag(TagElement tag);
empty
protected void handleText(char[ ] text);
protected void handleT itle(char[ ] text);
protected TagElement makeTag(javax.swing .text.html.parser.Element elem);
protected TagElement makeTag(javax.swing .text.html.parser.Element elem, boolean ﬁctional);
protected void markF irstT ime(javax.swing .text.html.parser.Element elem);
protected boolean parseMarkupDeclarations(StringBuffer strBuff) throws java.io.IOException;
protected void star tTag(TagElement tag) throws ChangedCharSetException;
// Protected Instance Fields
protected DTD dtd;
protected boolean strict;
}
Hierar chy: Object→Parser(DTDConstants)
Subc lasses: DocumentParser
ParserDelegator
Ja va 1.2
javax.swing .text.html.par ser
This class extends the HTMLEditorKit.Parser class and provides a deﬁnition of the parse()
method, which reads HTML text from a stream and parses it into a sequence of calls to
the methods of the speciﬁed HTMLEditorKit.ParserCallback object. Each time parse() is called,
the ParserDelegator class creates a new instance of DocumentParser to perfor m the parsing
and maintain state for the parsing process.
public class ParserDelegator extends HTMLEditorKit.Parser {
// Public Constructors
public ParserDelegator();
javax.swing.text.html.par ser.Par ser
662 Chapter 32 – The javax.swing.text.html.par ser Package

// Protected Class Methods
protected static DTD createDTD(DTD dtd, String name);
protected static void setDefaultDTD();
// Public Methods Overriding HTMLEditorKit.Parser
public void parse(java.io.Reader r, HTMLEditorKit.ParserCallback cb, boolean ignoreCharSet)
throws java.io.IOException;
}
Hierar chy: Object→HTMLEditorKit.Parser→ParserDelegator
TagElement
Ja va 1.2
javax.swing .text.html.par ser
This class is used internally by DocumentParser and its superclass Parser to describe the
type and behavior of an HTML tag that has been parsed.
public class TagElement {
// Public Constructors
public TagElement(javax.swing .text.html.parser.Element elem);
public TagElement(javax.swing .text.html.parser.Element elem, boolean ﬁctional);
// Public Instance Methods
public boolean breaksFlow();
public boolean ﬁctional();
public javax.swing.text.html.parser.Element getElement();
public HTML.Tag getHTMLTag();
public boolean isPrefor matted();
}
Passed To: DocumentParser.{handleEmptyTag(), handleEndTag(), handleStartTag()},
Parser.{handleEmptyTag(), handleEndTag(), handleStartTag(), startTag()}
Retur ned By: Parser.makeTag()
swing.text.
html.parser
javax.swing.text.html.par ser.TagElement
Chapter 32 – The javax.swing.text.html.par ser Package
663

CHAPTER 33
The javax.swing.text.r tf Package
This simple package deﬁnes an RTFEditorKit that enables the javax.swing .JEditorPane
component to display and edit Rich Text Format (RTF) documents. Figure 33-1
shows the class hierarchy of this package.
extends
implements
INTERFACE
Object
javax.swing.text
EditorKit
java.lang
DefaultEditorKit
StyledEditorKit
javax.swing.text.rtf
RTFEditorKit
Cloneable
java.io
Serializable
KEY
CLASS
Figur e 33−1: The javax.swing.text.rtf package
RTFEditorKit
Ja va 1.2
javax.swing .text.rtf
cloneable serializable
This EditorKit subclass provides support to a JEditorPane component for displaying and
editing text stored in Microsoft’s Rich Text Format (RTF). The getContentType() method
retur ns “text/rtf”. The read() and write() methods know how to translate between the RTF
ﬁle format and the Element tr ee structur e of a DefaultStyledDocument.
public class RTFEditorKit extends StyledEditorKit {
// Public Constructors
public RTFEditorKit();
664

// Public Methods Overriding StyledEditorKit
public Object clone();
// Public Methods Overriding DefaultEditorKit
default:"text/r tf"
public String getContentType();
public void read(java.io.Reader in, Document doc, int pos) throws java.io.IOException, BadLocationException;
public void read(java.io.InputStream in, Document doc, int pos) throws java.io.IOException, BadLocationException;
public void write(java.io.Writer out, Document doc, int pos, int len) throws java.io.IOException,
BadLocationException;
public void write(java.io.OutputStream out, Document doc, int pos, int len) throws java.io.IOException,
BadLocationException;
}
Hierar chy: Object→EditorKit(Cloneable, Serializable)→DefaultEditorKit→StyledEditorKit→RTFEditorKit
javax.swing.
text.rtf
javax.swing.text.r tf.RTFEditorKit
Chapter 33 – The javax.swing.text.r tf Package
665

CHAPTER 34
The javax.swing.tree Package
The
javax.swing .tree
package deﬁnes classes and interfaces used with the
javax.swing .JTree component. The TreeModel inter face deﬁnes the data to be displayed
by a JTree component. DefaultTreeModel pr ovides a commonly used implementation
of this interface; it is implemented in terms of the TreeNode and MutableTreeNode
inter faces. The TreeCellRenderer and TreeCellEditor inter faces ar e implemented by
objects that can display or edit cells in the tree, using a Swing component as a
template. Figure 34-1 shows the class hierarchy of this package. See Chapter 3,
Swing Programming Topics, for a discussion of and example using JTree and the
javax.swing .tree package.
AbstractLayoutCache
Ja va 1.2
javax.swing .tree
This abstract class deﬁnes the methods that must be implemented by a class that wants
to cache a JTree layout. This class is used by the JTree UI delegate. Applications never
need to use or subclass this class.
public abstract class AbstractLayoutCache implements RowMapper {
// Public Constructors
public AbstractLayoutCache();
// Inner Classes
public abstract static class NodeDimensions;
// Property Accessor Methods (by property name)
public TreeModel getModel();
public void setModel(T reeModel newModel);
public AbstractLayoutCache.NodeDimensions getNodeDimensions();
public void setNodeDimensions(AbstractLayoutCache.NodeDimensions nd);
public int getPrefer redHeight();
public boolean isRootV isible();
bound
public void setRootV isible(boolean rootVisible);
public abstract int getRowCount();
public int getRowHeight();
666

CLASS
INTERFACE
ABSTRACT CLASS
KEY
extends
implements
java.lang
Object
Cloneable
Exception
AbstractLayoutCache
javax.swing.tree
DefaultMutableTreeNode
DefaultTreeCellEditor
DefaultTreeModel
DefaultTreeSelectionModel
TreePath
ExpandVetoException
FixedHeightLayoutCache
RowMapper
VariableHeightLayoutCache
TreeNode
MutableTreeNode
TreeModel
TreeSelectionModel
java.io
Serializable
javax.swing
CellEditor
JLabel
DefaultTreeCellRenderer
java.awt.event
javax.swing.event
TreeSelectionListener
TreeCellRenderer
TreeCellEditor
ActionListener
Figur e 34−1: The javax.swing.tr ee package
bound
public void setRowHeight(int rowHeight);
public TreeSelectionModel getSelectionModel();
public void setSelectionModel(T reeSelectionModel newLSM);
// Public Instance Methods
public abstract java.awt.Rectangle getBounds(T reePath path, java.awt.Rectangle placeIn);
public abstract boolean getExpandedState(T reePath path);
public abstract TreePath getPathClosestTo(int x, int y);
public abstract TreePath getPathForRow(int row);
public int getPrefer redW idth(java.awt.Rectangle bounds);
public abstract int getRowForPath(T reePath path);
public abstract int getV isibleChildCount(T reePath path);
public abstract java.util.Enumeration getV isiblePathsFrom(T reePath path);
public abstract void invalidatePathBounds(T reePath path);
public abstract void invalidateSizes();
public abstract boolean isExpanded(T reePath path);
public abstract void setExpandedState(T reePath path, boolean isExpanded);
javax.swing.
tree
javax.swing.tree.AbstractLayoutCache
Chapter 34 – The javax.swing.tree Package
667

public abstract void treeNodesChanged(javax.swing .event.TreeModelEvent e);
public abstract void treeNodesInser ted(javax.swing .event.TreeModelEvent e);
public abstract void treeNodesRemoved(javax.swing .event.TreeModelEvent e);
public abstract void treeStr uctureChanged(javax.swing .event.TreeModelEvent e);
// Methods Implementing RowMapper
public int[ ] getRowsForPaths(T reePath[ ] paths);
// Protected Instance Methods
protected java.awt.Rectangle getNodeDimensions(Object value, int row, int depth, boolean expanded,
java.awt.Rectangle placeIn);
protected boolean isF ixedRowHeight();
// Protected Instance Fields
protected AbstractLayoutCache.NodeDimensions nodeDimensions;
protected boolean rootV isible;
protected int rowHeight;
protected TreeModel treeModel;
protected TreeSelectionModel treeSelectionModel;
}
Hierar chy: Object→AbstractLayoutCache(RowMapper)
Subc lasses: FixedHeightLayoutCache, VariableHeightLayoutCache
AbstractLayoutCache.NodeDimensions
Ja va 1.2
javax.swing .tree
This class deﬁnes a method that can compute the dimensions of a node in a JTree. It is
used internally by AbstractLayoutCache and its subclasses and by the JTree UI delegate.
Applications never need to use it.
public abstract static class AbstractLayoutCache.NodeDimensions {
// Public Constructors
public NodeDimensions();
// Public Instance Methods
public abstract java.awt.Rectangle getNodeDimensions(Object value, int row, int depth, boolean expanded,
java.awt.Rectangle bounds);
}
Passed To: AbstractLayoutCache.setNodeDimensions(), VariableHeightLayoutCache.setNodeDimensions()
Retur ned By: AbstractLayoutCache.getNodeDimensions()
Type Of: AbstractLayoutCache.nodeDimensions
DefaultMutableTreeNode
Ja va 1.2
javax.swing .tree
cloneable serializable
This class implements the MutableTreeNode inter face and adds a number of useful tree-
manipulation methods. When you create a DefaultMutableTreeNode, you can optionally
specify a user object—the data associated with the node—and a boolean value that
speciﬁes whether the node is allowed to have children. DefaultMutableTreeNode imple-
ments the MutableTreeNode methods that allow the parent and children of the node to be
set and the TreeNode methods that allow the parent and children to be queried. In addi-
tion to these basic methods, DefaultMutableTreeNode includes a number of useful tree-
manipulation methods, such as breadthF irstEnumeration() and depthF irstEnumeration(), which
recursively enumerate the children of a node in breadth-ﬁrst or depth-ﬁrst order,
respectively. See also DefaultTreeModel, the class with which DefaultMutableTreeNode is
designed to work.
javax.swing.tree.AbstractLayoutCache
668 Chapter 34 – The javax.swing.tree Package

public class DefaultMutableTreeNode implements Cloneable, MutableTreeNode, Serializable {
// Public Constructors
public DefaultMutableTreeNode();
public DefaultMutableTreeNode(Object userObject);
public DefaultMutableTreeNode(Object userObject, boolean allowsChildren);
// Public Constants
public static ﬁnal java.util.Enumeration EMPTY_ENUMERATION;
// Property Accessor Methods (by property name)
Implements:TreeNode default:true
public boolean getAllowsChildren();
public void setAllowsChildren(boolean allows);
Implements:TreeNode default:0
public int getChildCount();
default:0
public int getDepth();
public TreeNode getF irstChild();
public DefaultMutableTreeNode getF irstLeaf();
public TreeNode getLastChild();
public DefaultMutableTreeNode getLastLeaf();
Implements:TreeNode default:true
public boolean isLeaf();
default:1
public int getLeafCount();
default:0
public int getLevel();
default:null
public DefaultMutableTreeNode getNextLeaf();
default:null
public DefaultMutableTreeNode getNextNode();
default:null
public DefaultMutableTreeNode getNextSibling();
Implements:TreeNode default:null
public TreeNode getParent();
Implements:MutableTreeNode
public void setParent(MutableTreeNode newParent);
public TreeNode[ ] getPath();
default:null
public DefaultMutableTreeNode getPreviousLeaf();
default:null
public DefaultMutableTreeNode getPreviousNode();
default:null
public DefaultMutableTreeNode getPreviousSibling();
default:DefaultMutableTreeNode
public TreeNode getRoot();
default:true
public boolean isRoot();
default:1
public int getSiblingCount();
default:null
public Object getUserObject();
Implements:MutableTreeNode
public void setUserObject(Object userObject);
public Object[ ] getUserObjectPath();
// Public Instance Methods
public void add(MutableTreeNode newChild);
public java.util.Enumeration breadthF irstEnumeration();
public java.util.Enumeration depthF irstEnumeration();
public TreeNode getChildAfter(T reeNode aChild);
public TreeNode getChildBefore(T reeNode aChild);
public TreeNode getSharedAncestor(DefaultMutableTreeNode aNode);
public boolean isNodeAncestor(T reeNode anotherNode);
public boolean isNodeChild(T reeNode aNode);
public boolean isNodeDescendant(DefaultMutableTreeNode anotherNode);
public boolean isNodeRelated(DefaultMutableTreeNode aNode);
public boolean isNodeSibling(T reeNode anotherNode);
public java.util.Enumeration pathFromAncestorEnumeration(T reeNode ancestor);
public java.util.Enumeration postorderEnumeration();
public java.util.Enumeration preorderEnumeration();
public void removeAllChildren();
// Methods Implementing MutableTreeNode
public void inser t(MutableTreeNode newChild, int childIndex);
public void remove(MutableTreeNode aChild);
public void remove(int childIndex);
public void removeFromParent();
public void setParent(MutableTreeNode newParent);
public void setUserObject(Object userObject);
javax.swing.
tree
javax.swing.tree.DefaultMutableTreeNode
Chapter 34 – The javax.swing.tree Package
669

// Methods Implementing TreeNode
public java.util.Enumeration children();
default:true
public boolean getAllowsChildren();
public TreeNode getChildAt(int index);
default:0
public int getChildCount();
public int getIndex(T reeNode aChild);
default:null
public TreeNode getParent();
default:true
public boolean isLeaf();
// Public Methods Overriding Object
public Object clone();
public String toString();
// Protected Instance Methods
protected TreeNode[ ] getPathToRoot(T reeNode aNode, int depth);
// Protected Instance Fields
protected boolean allowsChildren;
protected java.util.Vector children;
protected MutableTreeNode parent;
protected transient Object userObject;
}
Hierar chy: Object→DefaultMutableTreeNode(Cloneable, MutableTreeNode(TreeNode), Serializable)
Subc lasses: JTree.DynamicUtilTreeNode
Passed To: JTree.DynamicUtilTreeNode.createChildren(), DefaultMutableTreeNode.{getSharedAncestor(),
isNodeDescendant(), isNodeRelated()}
Retur ned By: DefaultMutableTreeNode.{getF irstLeaf(), getLastLeaf(), getNextLeaf(), getNextNode(),
getNextSibling(), getPreviousLeaf(), getPreviousNode(), getPreviousSibling()}
DefaultTreeCellEditor
Ja va 1.2
javax.swing .tree
This TreeCellEditor implementation is the default editor for editing simple tree node val-
ues. By default, it displays the standard icons for the tree node and allows the user to
edit the node using a JTextF ield. When you create a DefaultTreeCellEditor, you supply a
DefaultTreeCellRenderer and a TreeCellEditor. The DefaultTreeCellEditor combines the icon dis-
play capability of the render er with the editing capability of the TreeCellEditor into a sin-
gle functional TreeCellEditor. Often, you can use a javax.swing .DefaultCellEditor as the internal
TreeCellEditor. Or, if you do not specify a TreeCellEditor, a default one that allows the user
to edit text values is used. DefaultTreeCellEditor allows the user to edit a cell by triple-
clicking on the node. You can change this behavior by subclassing and overriding the
canEditImmediately() method.
public class DefaultTreeCellEditor implements java.awt.event.ActionListener, TreeCellEditor,
javax.swing .event.TreeSelectionListener {
// Public Constructors
public DefaultTreeCellEditor(JTree tree, DefaultTreeCellRenderer renderer);
public DefaultTreeCellEditor(JTree tree, DefaultTreeCellRenderer renderer, TreeCellEditor editor);
// Inner Classes
public class DefaultTextF ield extends JTextF ield;
public class EditorContainer extends Container;
// Event Registration Methods (by event name)
Implements:CellEditor
public void addCellEditorListener(javax.swing .event.CellEditorListener l);
Implements:CellEditor
public void removeCellEditorListener(javax.swing .event.CellEditorListener l);
// Public Instance Methods
public java.awt.Color getBorderSelectionColor();
public java.awt.Font getFont();
javax.swing.tree.DefaultMutableTreeNode
670 Chapter 34 – The javax.swing.tree Package

public void setBorderSelectionColor(java.awt.Color newColor);
public void setFont(java.awt.Font font);
// Methods Implementing ActionListener
public void actionPerfor med(java.awt.e vent.ActionEvent e);
// Methods Implementing CellEditor
public void addCellEditorListener(javax.swing .event.CellEditorListener l);
public void cancelCellEditing();
public Object getCellEditorValue();
public boolean isCellEditable(java.util.EventObject event);
public void removeCellEditorListener(javax.swing .event.CellEditorListener l);
public boolean shouldSelectCell(java.util.EventObject event);
public boolean stopCellEditing();
// Methods Implementing TreeCellEditor
public Component getTreeCellEditorComponent(JTree tree, Object value, boolean isSelected,
boolean expanded, boolean leaf, int row);
// Methods Implementing TreeSelectionListener
public void valueChanged(javax.swing .event.TreeSelectionEvent e);
// Protected Instance Methods
protected boolean canEditImmediately(java.util.EventObject event);
protected Container createContainer();
protected TreeCellEditor createTreeCellEditor();
protected void deter mineOffset(JTree tree, Object value, boolean isSelected, boolean expanded, boolean leaf,
int row);
protected boolean inHitRegion(int x, int y);
protected void prepareForEditing();
protected void setTree(JTree newTree);
protected boolean shouldStar tEditingTimer(java.util.EventObject event);
protected void star tEditingTimer();
// Protected Instance Fields
protected java.awt.Color borderSelectionColor;
protected boolean canEdit;
protected transient Component editingComponent;
protected Container editingContainer;
protected transient Icon editingIcon;
protected java.awt.Font font;
protected transient TreePath lastPath;
protected transient int lastRow;
protected transient int offset;
protected TreeCellEditor realEditor;
protected DefaultTreeCellRenderer renderer;
protected transient Timer timer;
protected transient JTree tree;
}
Hierar chy: Object→DefaultTreeCellEditor(java.awt.event.ActionListener(java.util.EventListener),
TreeCellEditor(CellEditor), javax.swing .event.TreeSelectionListener(java.util.EventListener))
DefaultTreeCellEditor.DefaultTextF ield
Ja va 1.2
javax.swing .tree
serializable accessible(text) swing component
This class is a customized version of JTextF ield used by DefaultTreeCellEditor if no custom
TreeCellEditor is supplied. Applications never need to use it.
public class DefaultTreeCellEditor.DefaultTextF ield extends JTextF ield {
// Public Constructors
public DefaultTextF ield(javax.swing .border.Border border);
// Property Accessor Methods (by property name)
Overrides:JComponent
public javax.swing.border.Border getBorder();
javax.swing.
tree
javax.swing.tree.DefaultTreeCellEditor.DefaultTextField
Chapter 34 – The javax.swing.tree Package
671

Overrides:Component
public java.awt.Font getFont();
Overrides:JTextF ield
public java.awt.Dimension getPrefer redSize();
// Protected Instance Fields
protected javax.swing.border.Border border;
}
DefaultTreeCellEditor.EditorContainer
Ja va 1.2
javax.swing .tree
serializable swing component
This simple container implementation is used internally by DefaultTreeCellEditor to com-
bine the icons of its DefaultTreeCellRenderer with the editing component of the supplied
TreeCellRenderer or the default text ﬁeld. Applications never need to use this class.
public class DefaultTreeCellEditor.EditorContainer extends Container {
// Public Constructors
public EditorContainer();
// Property Accessor Methods (by property name)
Overrides:Container
public java.awt.Dimension getPrefer redSize();
// Public Instance Methods
public void EditorContainer();
// Public Methods Overriding Container
public void doLayout();
public void paint(java.awt.Graphics g);
}
DefaultTreeCellRenderer
Ja va 1.2
javax.swing .tree
serializable accessible swing component
This JLabel subclass implements the TreeCellRenderer methods and is the default cell ren-
der er used by JTree. It displays an icon for the node and the string that results from call-
ing the toString() method of the node value. The various properties of this class exist
primarily to allow customization of node colors and icons.
public class DefaultTreeCellRenderer extends JLabel implements TreeCellRenderer {
// Public Constructors
public DefaultTreeCellRenderer();
// Property Accessor Methods (by property name)
default:ColorUIResource
public java.awt.Color getBackgroundNonSelectionColor();
public void setBackgroundNonSelectionColor(java.awt.Color newColor);
default:ColorUIResource
public java.awt.Color getBackgroundSelectionColor();
public void setBackgroundSelectionColor(java.awt.Color newColor);
default:ColorUIResource
public java.awt.Color getBorderSelectionColor();
public void setBorderSelectionColor(java.awt.Color newColor);
public Icon getClosedIcon();
public void setClosedIcon(Icon newIcon);
public Icon getDefaultClosedIcon();
public Icon getDefaultLeafIcon();
public Icon getDefaultOpenIcon();
public Icon getLeafIcon();
public void setLeafIcon(Icon newIcon);
public Icon getOpenIcon();
public void setOpenIcon(Icon newIcon);
Overrides:JComponent
public java.awt.Dimension getPrefer redSize();
default:ColorUIResource
public java.awt.Color getTextNonSelectionColor();
public void setTextNonSelectionColor(java.awt.Color newColor);
default:ColorUIResource
public java.awt.Color getTextSelectionColor();
public void setTextSelectionColor(java.awt.Color newColor);
javax.swing.tree.DefaultTreeCellEditor.DefaultTextField
672 Chapter 34 – The javax.swing.tree Package

// Methods Implementing TreeCellRenderer
public Component getTreeCellRendererComponent(JTree tree, Object value, boolean sel, boolean expanded,
boolean leaf, int row, boolean hasFocus);
// Public Methods Overriding JComponent
public void paint(java.awt.Graphics g);
public void setBackground(java.awt.Color color);
public void setFont(java.awt.Font font);
// Protected Instance Fields
protected java.awt.Color backgroundNonSelectionColor;
protected java.awt.Color backgroundSelectionColor;
protected java.awt.Color borderSelectionColor;
protected transient Icon closedIcon;
protected transient Icon leafIcon;
protected transient Icon openIcon;
protected boolean selected;
protected java.awt.Color textNonSelectionColor;
protected java.awt.Color textSelectionColor;
}
Hierar chy: Object→Component(java.awt.image.ImageObser ver, java.awt.MenuContainer, Serializable)→
Container→JComponent(Serializable)→JLabel(Accessible, SwingConstants)→
DefaultTreeCellRenderer(TreeCellRenderer)
Passed To: DefaultTreeCellEditor.DefaultTreeCellEditor()
Type Of: DefaultTreeCellEditor.renderer
DefaultTreeModel
Ja va 1.2
javax.swing .tree
serializable model
This class implements the TreeModel inter face for TreeNode or MutableTreeNode objects.
When you create a DefaultTreeModel, you specify the TreeNode at the root of the tree. You
also can specify how the tree distinguishes leaf nodes from nonleaf nodes. Usually,
DefaultTreeModel calls the isLeaf() method of a TreeNode to determine whether it is a leaf.
For the commonly used DefaultMutableTreeNode class, isLeaf() retur ns tr ue if the node has
no children. On the other hand, if the asksAllowsChildren pr operty is set to tr ue, Default-
TreeModel calls the getAllowsChildren() method of a TreeNode instead.
The TreeModel inter face allows registration of javax.swing .event.TreeModelListener objects that
ar e notiﬁed when the tree data or structure is changed. DefaultTreeModel pr ovides a num-
ber of methods that make this notiﬁcation simple. If you modify any of the TreeNode
objects contained within a DefaultTreeModel after that model is in use, call one of the
methods beginning with node or nodes. These methods send out the appropriate
javax.swing .event.TreeModelEvent notiﬁcations. If your modiﬁcations consist solely of insert-
ing and removing nodes, you can use
inser tNodeInto() and removeNodeFromParent(). These
methods make the appropriate modiﬁcations to the speciﬁed MutableTreeNode objects
and also send out notiﬁcation events.
public class DefaultTreeModel implements Serializable, TreeModel {
// Public Constructors
public DefaultTreeModel(T reeNode root);
public DefaultTreeModel(T reeNode root, boolean asksAllowsChildren);
// Event Registration Methods (by event name)
Implements:TreeModel
public void addTreeModelListener(javax.swing .event.TreeModelListener l);
Implements:TreeModel
public void removeTreeModelListener(javax.swing .event.TreeModelListener l);
// Public Instance Methods
public boolean asksAllowsChildren();
public TreeNode[ ] getPathToRoot(T reeNode aNode);
javax.swing.
tree
javax.swing.tree.DefaultTreeModel
Chapter 34 – The javax.swing.tree Package
673

public void inser tNodeInto(MutableTreeNode newChild, MutableTreeNode parent, int index);
public void nodeChanged(T reeNode node);
public void nodesChanged(T reeNode node, int[ ] childIndices);
public void nodeStr uctureChanged(T reeNode node);
public void nodesWereInser ted(T reeNode node, int[ ] childIndices);
public void nodesWereRemoved(T reeNode node, int[ ] childIndices, Object[ ] removedChildren);
public void reload();
public void reload(T reeNode node);
public void removeNodeFromParent(MutableTreeNode node);
public void setAsksAllowsChildren(boolean newValue);
public void setRoot(T reeNode root);
// Methods Implementing TreeModel
public void addTreeModelListener(javax.swing .event.TreeModelListener l);
public Object getChild(Object parent, int index);
public int getChildCount(Object parent);
public int getIndexOfChild(Object parent, Object child);
public Object getRoot();
public boolean isLeaf(Object node);
public void removeTreeModelListener(javax.swing .event.TreeModelListener l);
public void valueForPathChanged(T reePath path, Object newValue);
// Protected Instance Methods
protected void ﬁreTreeNodesChanged(Object source, Object[ ] path, int[ ] childIndices, Object[ ] children);
protected void ﬁreTreeNodesInser ted(Object source, Object[ ] path, int[ ] childIndices, Object[ ] children);
protected void ﬁreTreeNodesRemoved(Object source, Object[ ] path, int[ ] childIndices, Object[ ] children);
protected void ﬁreTreeStr uctureChanged(Object source, Object[ ] path, int[ ] childIndices, Object[ ] children);
protected TreeNode[ ] getPathToRoot(T reeNode aNode, int depth);
// Protected Instance Fields
protected boolean asksAllowsChildren;
protected javax.swing.e vent.EventListenerList listenerList;
protected TreeNode root;
}
Hierar chy: Object→DefaultTreeModel(Serializable, TreeModel)
DefaultTreeSelectionModel
Ja va 1.2
javax.swing .tree
cloneable serializable model
This class is used by default to maintain the selection state for the JTree component.
Methods such as addSelectionPaths(), removeSelectionPaths(), setSelectionPaths(), getSelection-
Paths(), clearSelection(), isPathSelected(), and isSelectionEmpty() can be used to manipulate
and query the selection state. However, application programmers generally call simi-
larly named methods of JTree, rather than interacting with the DefaultTreeSelectionModel
dir ectly. setSelectionMode() is an important method that does not have a JTree analog. Its
argument should be one of the three constants deﬁned by the TreeSelectionModel inter-
face. These three constants allow a single item to be selected, a single contiguous range
of items to be selected, or any number of possibly discontiguous items to be selected.
DefaultTreeSelectionModel has methods for setting and querying the selection in terms of
rows. These methods are intended for internal use by JTree and its UI delegate object.
They typically are not useful to application programmers.
public class DefaultTreeSelectionModel implements Cloneable, Serializable, TreeSelectionModel {
// Public Constructors
public DefaultTreeSelectionModel();
// Public Constants
="selectionMode"
public static ﬁnal String SELECTION_MODE_PROPERTY;
// Event Registration Methods (by event name)
Implements:TreeSelectionModel synchronized
public void addProper tyChangeListener(
java.beans.Proper tyChangeListener listener);
javax.swing.tree.DefaultTreeModel
674 Chapter 34 – The javax.swing.tree Package

Implements:TreeSelectionModel synchronized
public void removeProper tyChangeListener(
java.beans.Proper tyChangeListener listener);
Implements:TreeSelectionModel
public void addTreeSelectionListener(
javax.swing .event.TreeSelectionListener x);
Implements:TreeSelectionModel
public void removeTreeSelectionListener(
javax.swing .event.TreeSelectionListener x);
// Methods Implementing TreeSelectionModel
synchronized
public void addProper tyChangeListener(java.beans.Proper tyChangeListener listener);
public void addSelectionPath(T reePath path);
public void addSelectionPaths(T reePath[ ] paths);
public void addTreeSelectionListener(javax.swing .event.TreeSelectionListener x);
public void clearSelection();
default:null
public TreePath getLeadSelectionPath();
default:-1
public int getLeadSelectionRow();
default:-1
public int getMaxSelectionRow();
default:-1
public int getMinSelectionRow();
default:null
public RowMapper getRowMapper();
default:0
public int getSelectionCount();
default:4
public int getSelectionMode();
default:null
public TreePath getSelectionPath();
default:null
public TreePath[ ] getSelectionPaths();
default:null
public int[ ] getSelectionRows();
public boolean isPathSelected(T reePath path);
public boolean isRowSelected(int row);
default:true
public boolean isSelectionEmpty();
synchronized
public void removeProper tyChangeListener(java.beans.Proper tyChangeListener listener);
public void removeSelectionPath(T reePath path);
public void removeSelectionPaths(T reePath[ ] paths);
public void removeTreeSelectionListener(javax.swing .event.TreeSelectionListener x);
public void resetRowSelection();
public void setRowMapper(RowMapper newMapper);
public void setSelectionMode(int mode);
public void setSelectionPath(T reePath path);
public void setSelectionPaths(T reePath[ ] pPaths);
// Public Methods Overriding Object
public Object clone() throws CloneNotSupportedException;
public String toString();
// Protected Instance Methods
protected boolean arePathsContiguous(T reePath[ ] paths);
protected boolean canPathsBeAdded(T reePath[ ] paths);
protected boolean canPathsBeRemoved(T reePath[ ] paths);
protected void ﬁreValueChanged(javax.swing .event.TreeSelectionEvent e);
protected void insureRowContinuity();
protected void insureUniqueness();
protected void notifyPathChange(java.util.Vector changedPaths, TreePath oldLeadSelection);
protected void updateLeadIndex();
// Protected Instance Fields
protected javax.swing.e vent.SwingPropertyChangeSuppor t changeSuppor t;
protected int leadIndex;
protected TreePath leadPath;
protected int leadRow;
protected javax.swing.e vent.EventListenerList listenerList;
protected DefaultListSelectionModel listSelectionModel;
protected transient RowMapper rowMapper;
protected TreePath[ ] selection;
protected int selectionMode;
}
javax.swing.
tree
javax.swing.tree.DefaultTreeSelectionModel
Chapter 34 – The javax.swing.tree Package
675

Hierar chy: Object→DefaultTreeSelectionModel(Cloneable, Serializable, TreeSelectionModel)
Subc lasses: JTree.EmptySelectionModel
ExpandVetoException
Ja va 1.2
javax.swing .tree
serializable checked
Thr own by one of the methods of a TreeW illExpandListener object to veto a proposed
expansion or collapse of a node.
public class ExpandVetoException extends Exception {
// Public Constructors
public ExpandVetoException(javax.swing .event.TreeExpansionEvent event);
public ExpandVetoException(javax.swing .event.TreeExpansionEvent event, String message);
// Protected Instance Fields
protected javax.swing.e vent.TreeExpansionEvent event;
}
Hierar chy: Object→Throwable(Serializable)→Exception→ExpandVetoException
Thrown By: JTree.{fireTreeW illCollapse(), fireTreeW illExpand()},
javax.swing .event.TreeW illExpandListener.{treeW illCollapse(), treeW illExpand()}
FixedHeightLayoutCache
Ja va 1.2
javax.swing .tree
This class caches the layout of nodes in a JTree. It makes the simplifying assumption that
all nodes in the tree have the same height. This class is used by the JTree UI delegate;
applications never need to use it.
public class FixedHeightLayoutCache extends AbstractLayoutCache {
// Public Constructors
public FixedHeightLayoutCache();
// Public Methods Overriding AbstractLayoutCache
public java.awt.Rectangle getBounds(T reePath path, java.awt.Rectangle placeIn);
public boolean getExpandedState(T reePath path);
default:0
public int getRowCount();
public TreePath getPathClosestTo(int x, int y);
public TreePath getPathForRow(int row);
public int getRowForPath(T reePath path);
public int getV isibleChildCount(T reePath path);
public java.util.Enumeration getV isiblePathsFrom(T reePath path);
empty
public void invalidatePathBounds(T reePath path);
public void invalidateSizes();
public boolean isExpanded(T reePath path);
public void setExpandedState(T reePath path, boolean isExpanded);
public void setModel(T reeModel newModel);
public void setRootV isible(boolean rootVisible);
public void setRowHeight(int rowHeight);
public void treeNodesChanged(javax.swing .event.TreeModelEvent e);
public void treeNodesInser ted(javax.swing .event.TreeModelEvent e);
public void treeNodesRemoved(javax.swing .event.TreeModelEvent e);
public void treeStr uctureChanged(javax.swing .event.TreeModelEvent e);
}
Hierar chy: Object→AbstractLayoutCache(RowMapper)→FixedHeightLayoutCache
javax.swing.tree.DefaultTreeSelectionModel
676 Chapter 34 – The javax.swing.tree Package

MutableTreeNode
Ja va 1.2
javax.swing .tree
This interface extends TreeNode and adds methods for inserting and removing children
of a node and for setting the parent of a node. Additionally, it deﬁnes a method for
associating an arbitrary object with a node. This user object is the data associated with
the node, data that is displayed in some way by the JTree component.
public abstract interface MutableTreeNode extends TreeNode {
// Public Instance Methods
public abstract void inser t(MutableTreeNode child, int index);
public abstract void remove(MutableTreeNode node);
public abstract void remove(int index);
public abstract void removeFromParent();
public abstract void setParent(MutableTreeNode newParent);
public abstract void setUserObject(Object object);
}
Hierar chy: (MutableTreeNode(TreeNode))
Implementations: DefaultMutableTreeNode
Passed To: DefaultMutableTreeNode.{add(), insert(), remove(), setParent()},
DefaultTreeModel.{inser tNodeInto(), removeNodeFromParent()}, MutableTreeNode.{inser t(), remove(),
setParent()}
Type Of: DefaultMutableTreeNode.parent
RowMapper
Ja va 1.2
javax.swing .tree
This interface deﬁnes a method that maps from TreePath nodes in a JTree to numerical
rows in the tree presentation. Because the arrangement of items in a tree is speciﬁc to
the look-and-feel, RowMapper implementations are private to the look-and-feel. Applica-
tion programmers never have to use or implement this interface.
public abstract interface RowMapper {
// Public Instance Methods
public abstract int[ ] getRowsForPaths(T reePath[ ] path);
}
Implementations: AbstractLayoutCache
Passed To: DefaultTreeSelectionModel.setRowMapper(), TreeSelectionModel.setRowMapper()
Retur ned By: DefaultTreeSelectionModel.getRowMapper(), TreeSelectionModel.getRowMapper()
Type Of: DefaultTreeSelectionModel.rowMapper
TreeCellEditor
Ja va 1.2
javax.swing .tree
This interface extends the javax.swing .CellEditor inter face to make it speciﬁc to the JTree
component. getTreeCellEditorComponent() should initialize and retur n a shar ed component
or container (typically a JComponent) that is to be used for editing the value of a tree
node. The second argument to getTreeCellEditorComponent() is the tree node that is to be
edited. If you use the DefaultTreeModel, this argument is a TreeNode. Note that this argu-
ment is the node itself, not the user object associated with the TreeNode. The additional
arguments passed to getTreeCellEditorComponent() can be used to further conﬁgure the cell
editor component, as desired. A TreeCellEditor must also implement all the methods
deﬁned by CellEditor, and it must correctly implement the protocol for communication
javax.swing.
tree
javax.swing.tree.TreeCellEditor
Chapter 34 – The javax.swing.tree Package
677

between a JComponent and its cell editor. Most importantly, it must generate a
javax.swing .event.ChangeEvent when editing is done.
public abstract interface TreeCellEditor extends CellEditor {
// Public Instance Methods
public abstract Component getTreeCellEditorComponent(JTree tree, Object value, boolean isSelected,
boolean expanded, boolean leaf, int row);
}
Hierar chy: (TreeCellEditor(CellEditor))
Implementations: DefaultCellEditor, DefaultTreeCellEditor
Passed To: JTree.setCellEditor(), DefaultTreeCellEditor.DefaultTreeCellEditor()
Retur ned By: JTree.getCellEditor(), DefaultTreeCellEditor.createTreeCellEditor()
Type Of: JTree.cellEditor, DefaultTreeCellEditor.realEditor
TreeCellRenderer
Ja va 1.2
javax.swing .tree
This interface deﬁnes the getTreeCellRendererComponent() method, which is responsible for
retur ning a component (typically a JComponent) that is fully conﬁgured to render a node
of a JTree. JTree uses a default TreeCellRenderer that is suitable in most situations. If you
want custom rendering of tree nodes, however, you must implement this interface. The
second argument to getTreeCellRendererComponent() is the node to be render ed. If you use
the DefaultTreeModel, this argument is a TreeNode object. Note that it is not the user object
associated with a TreeNode. The remaining arguments specify other information about
the node. The render er may choose to use this information in its rendering of the cell
or not. The render er is responsible for highlighting any selected nodes and for drawing
any icons or other desired graphics that distinguish leaf nodes from branch nodes.
public abstract interface TreeCellRenderer {
// Public Instance Methods
public abstract Component getTreeCellRendererComponent(JTree tree, Object value, boolean selected,
boolean expanded, boolean leaf, int row,
boolean hasFocus);
}
Implementations: DefaultTreeCellRenderer
Passed To: JTree.setCellRenderer()
Retur ned By: JTree.getCellRenderer()
Type Of: JTree.cellRenderer
TreeModel
Ja va 1.2
javax.swing .tree
model
This interface deﬁnes the methods necessary to repr esent a tree of objects for display in
a JTree component. getRoot() retur ns the object at the root of the tree. getChildCount()
retur ns the number of children a tree node has. getChild() retur ns a speciﬁed child of a
node. The poorly named valueForPathChanged() method sets the data value associated
with a node identiﬁed by a TreePath object. When this method is called, a TreeModel
should 
generate 
a
javax.swing .event.TreeModelEvent
and 
notify 
all 
register ed
javax.swing .event.TreeModelListener objects by invoking their treeNodesChanged() methods.
When working with objects that have an implicit tree hierarchy, such as java.io.F ile
objects, you can directly implement TreeModel to encapsulate the details of that tree hier-
javax.swing.tree.TreeCellEditor
678 Chapter 34 – The javax.swing.tree Package

archy. In other cases, it is usually easier to use the DefaultTreeModel class, which imple-
ments the TreeModel inter face for TreeNode objects.
public abstract interface TreeModel {
// Event Registration Methods (by event name)
public abstract void addTreeModelListener(javax.swing .event.TreeModelListener l);
public abstract void removeTreeModelListener(javax.swing .event.TreeModelListener l);
// Public Instance Methods
public abstract Object getChild(Object parent, int index);
public abstract int getChildCount(Object parent);
public abstract int getIndexOfChild(Object parent, Object child);
public abstract Object getRoot();
public abstract boolean isLeaf(Object node);
public abstract void valueForPathChanged(T reePath path, Object newValue);
}
Implementations: DefaultTreeModel
Passed To: JTree.{JTree(), setModel()}, AbstractLayoutCache.setModel(), FixedHeightLayoutCache.setModel(),
VariableHeightLayoutCache.setModel()
Retur ned By: JTree.{createTreeModel(), getDefaultTreeModel(), getModel()},
AbstractLayoutCache.getModel()
Type Of: JTree.treeModel, AbstractLayoutCache.treeModel
TreeNode
Ja va 1.2
javax.swing .tree
This interface is used by DefaultTreeModel to repr esent one node in a tree. Implementa-
tions must be able both to retur n the parent and the children, if any, of a node, and to
distinguish between leaf nodes and branch nodes in the tree. Any useful implementa-
tion must also associate some kind of data with each node. Note that the TreeNode inter-
face is used by DefaultTreeModel, not by TreeModel or by the JTree component. If you write
your own implementation of TreeModel, you do not have to use the TreeNode inter face.
See also MutableTreeNode and DefaultMutableTreeNode.
public abstract interface TreeNode {
// Property Accessor Methods (by property name)
public abstract boolean getAllowsChildren();
public abstract int getChildCount();
public abstract boolean isLeaf();
public abstract TreeNode getParent();
// Public Instance Methods
public abstract java.util.Enumeration children();
public abstract TreeNode getChildAt(int childIndex);
public abstract int getIndex(T reeNode node);
}
Implementations: javax.swing .text.AbstractDocument.AbstractElement, MutableTreeNode
Passed To: Too many methods to list.
Retur ned By: Too many methods to list.
Type Of: DefaultTreeModel.root
TreePath
Ja va 1.2
javax.swing .tree
serializable
This class repr esents a node in a tree and the path of nodes between that node and the
root of the tree. The TreeModel inter face does not contain methods for querying the
javax.swing.
tree
javax.swing.tree.TreePath
Chapter 34 – The javax.swing.tree Package
679

par ent of a given node. Therefor e, the JTree component and its related classes rely on
TreePath to encapsulate the list of ancestors of a node. getLastPathComponent() retur ns the
node repr esented by the path. getPath() retur ns an array of objects that repr esents the
complete path. The ﬁrst element in the array is the root of the tree, and the last element
is the node retur ned by getLastPathComponent(). isDescendant() tests whether a TreePath is a
descendant of this one.
public class TreePath implements Serializable {
// Public Constructors
public TreePath(Object singlePath);
public TreePath(Object[ ] path);
// Protected Constructors
protected TreePath();
protected TreePath(Object[ ] path, int length);
protected TreePath(T reePath parent, Object lastElement);
// Property Accessor Methods (by property name)
public Object getLastPathComponent();
public TreePath getParentPath();
public Object[ ] getPath();
public int getPathCount();
// Public Instance Methods
public Object getPathComponent(int element);
public boolean isDescendant(T reePath aTreePath);
public TreePath pathByAddingChild(Object child);
// Public Methods Overriding Object
public boolean equals(Object o);
public int hashCode();
public String toString();
}
Hierar chy: Object→TreePath(Serializable)
Passed To: Too many methods to list.
Retur ned By: Too many methods to list.
Type Of: javax.swing .event.TreeExpansionEvent.path, javax.swing .event.TreeModelEvent.path,
javax.swing .event.TreeSelectionEvent.{newLeadSelectionPath, oldLeadSelectionPath, paths},
DefaultTreeCellEditor.lastPath, DefaultTreeSelectionModel.{leadPath, selection}
TreeSelectionModel
Ja va 1.2
javax.swing .tree
model
This interface deﬁnes the methods that must be implemented for an object to maintain
the selection state of a JTree component. See the DefaultTreeSelectionModel implementation
for details.
public abstract interface TreeSelectionModel {
// Public Constants
=2
public static ﬁnal int CONTIGUOUS_TREE_SELECTION;
=4
public static ﬁnal int DISCONTIGUOUS_TREE_SELECTION;
=1
public static ﬁnal int SINGLE_TREE_SELECTION;
// Event Registration Methods (by event name)
public abstract void addProper tyChangeListener(java.beans.Proper tyChangeListener listener);
public abstract void removeProper tyChangeListener(java.beans.Proper tyChangeListener listener);
public abstract void addTreeSelectionListener(javax.swing .event.TreeSelectionListener x);
public abstract void removeTreeSelectionListener(javax.swing .event.TreeSelectionListener x);
// Property Accessor Methods (by property name)
public abstract TreePath getLeadSelectionPath();
public abstract int getLeadSelectionRow();
javax.swing.tree.TreePath
680 Chapter 34 – The javax.swing.tree Package

public abstract int getMaxSelectionRow();
public abstract int getMinSelectionRow();
public abstract RowMapper getRowMapper();
public abstract void setRowMapper(RowMapper newMapper);
public abstract int getSelectionCount();
public abstract boolean isSelectionEmpty();
public abstract int getSelectionMode();
public abstract void setSelectionMode(int mode);
public abstract TreePath getSelectionPath();
public abstract void setSelectionPath(T reePath path);
public abstract TreePath[ ] getSelectionPaths();
public abstract void setSelectionPaths(T reePath[ ] paths);
public abstract int[ ] getSelectionRows();
// Public Instance Methods
public abstract void addSelectionPath(T reePath path);
public abstract void addSelectionPaths(T reePath[ ] paths);
public abstract void clearSelection();
public abstract boolean isPathSelected(T reePath path);
public abstract boolean isRowSelected(int row);
public abstract void removeSelectionPath(T reePath path);
public abstract void removeSelectionPaths(T reePath[ ] paths);
public abstract void resetRowSelection();
}
Implementations: DefaultTreeSelectionModel
Passed To: JTree.setSelectionModel(), AbstractLayoutCache.setSelectionModel()
Retur ned By: JTree.getSelectionModel(), AbstractLayoutCache.getSelectionModel()
Type Of: JTree.selectionModel, AbstractLayoutCache.treeSelectionModel
VariableHeightLayoutCache
Ja va 1.2
javax.swing .tree
This class caches the layout of nodes in a JTree. It allows tree nodes to have variable
heights. This class is used by the JTree UI delegate; applications never need to use it.
public class VariableHeightLayoutCache extends AbstractLayoutCache {
// Public Constructors
public VariableHeightLayoutCache();
// Public Methods Overriding AbstractLayoutCache
public java.awt.Rectangle getBounds(T reePath path, java.awt.Rectangle placeIn);
public boolean getExpandedState(T reePath path);
public TreePath getPathClosestTo(int x, int y);
public TreePath getPathForRow(int row);
public int getPrefer redW idth(java.awt.Rectangle bounds);
default:0
public int getRowCount();
public int getRowForPath(T reePath path);
public int getV isibleChildCount(T reePath path);
public java.util.Enumeration getV isiblePathsFrom(T reePath path);
public void invalidatePathBounds(T reePath path);
public void invalidateSizes();
public boolean isExpanded(T reePath path);
public void setExpandedState(T reePath path, boolean isExpanded);
bound
public void setModel(T reeModel newModel);
public void setNodeDimensions(AbstractLayoutCache.NodeDimensions nd);
bound
public void setRootV isible(boolean rootVisible);
bound
public void setRowHeight(int rowHeight);
public void treeNodesChanged(javax.swing .event.TreeModelEvent e);
javax.swing.
tree
javax.swing.tree.Var iableHeightLayoutCache
Chapter 34 – The javax.swing.tree Package
681

public void treeNodesInser ted(javax.swing .event.TreeModelEvent e);
public void treeNodesRemoved(javax.swing .event.TreeModelEvent e);
public void treeStr uctureChanged(javax.swing .event.TreeModelEvent e);
}
Hierar chy: Object→AbstractLayoutCache(RowMapper)→VariableHeightLayoutCache
javax.swing.tree.Var iableHeightLayoutCache
682 Chapter 34 – The javax.swing.tree Package

CHAPTER 35
The javax.swing.undo Package
The classes and interfaces in this package form the undo framework for Swing
applications. The UndoManager manages a list of UndoableEdit objects, each of which
can be individually undone or redone. Any Swing application that wants to pro-
vide an undo capability will ﬁnd this package useful. Figure 35-1 shows the class
hierarchy of this package.
extends
implements
INTERFACE
KEY
CLASS
java.io
Object
RuntimeException
javax.swing.undo
AbstractUndoableEdit
CompoundEdit
UndoManager
StateEdit
UndoableEditSupport
StateEditable
UndoableEdit
CannotRedoException
CannotUndoException
Serializable
javax.swing.event
UndoableEditListener
java.lang
Figur e 35−1: The javax.swing.undo package
AbstractUndoableEdit
Ja va 1.2
javax.swing .undo
serializable
This class is a simple implementation of UndoableEdit. It enforces the restriction that an
edit cannot be undone twice or redone without ﬁrst being undone. Although the undo()
and redo() methods do not actually undo or redo anything, subclasses should still call
javax.swing.
undo
683

super.undo() and super.redo() in order to retain these restrictions. addEdit() and replaceEdit()
retur n false; this implementation makes no attempt to merge events. getUndoPresentation-
Name() and getRedoPresentationName() retur n the strings “Undo” and “Redo”, followed by
the string retur ned fr om getPresentationName(). Ther efor e, typical subclasses only need to
override getPresentationName().
public class AbstractUndoableEdit implements Serializable, UndoableEdit {
// Public Constructors
public AbstractUndoableEdit();
// Protected Constants
="Redo"
protected static ﬁnal String RedoName;
="Undo"
protected static ﬁnal String UndoName;
// Methods Implementing UndoableEdit
constant
public boolean addEdit(UndoableEdit anEdit);
public boolean canRedo();
public boolean canUndo();
public void die();
default:""
public String getPresentationName();
default:"Redo"
public String getRedoPresentationName();
default:"Undo"
public String getUndoPresentationName();
constant default:true
public boolean isSigniﬁcant();
public void redo() throws CannotRedoException;
constant
public boolean replaceEdit(UndoableEdit anEdit);
public void undo() throws CannotUndoException;
// Public Methods Overriding Object
public String toString();
}
Hierar chy: Object→AbstractUndoableEdit(Serializable, UndoableEdit)
Subc lasses: javax.swing .text.AbstractDocument.ElementEdit,
javax.swing .text.DefaultStyledDocument.AttributeUndoableEdit, CompoundEdit, StateEdit
CannotRedoException
Ja va 1.2
javax.swing .undo
serializable unchecked
Signals that an UndoableEdit cannot be redone, perhaps because it has not been undone
yet or because it has already been redone.
public class CannotRedoException extends RuntimeException {
// Public Constructors
public CannotRedoException();
}
Hierar chy: Object→Throwable(Serializable)→Exception→RuntimeException→CannotRedoException
Thrown By: javax.swing .text.AbstractDocument.DefaultDocumentEvent.redo(),
javax.swing .text.AbstractDocument.ElementEdit.redo(),
javax.swing .text.DefaultStyledDocument.AttributeUndoableEdit.redo(), AbstractUndoableEdit.redo(),
CompoundEdit.redo(), UndoableEdit.redo(), UndoManager.{redo(), redoTo(), undoOrRedo()}
CannotUndoException
Ja va 1.2
javax.swing .undo
serializable unchecked
Signals that an UndoableEdit cannot be undone, perhaps because it has already been
undone.
javax.swing.undo.AbstractUndoableEdit
684 Chapter 35 – The javax.swing.undo Package

public class CannotUndoException extends RuntimeException {
// Public Constructors
public CannotUndoException();
}
Hierar chy: Object→Throwable(Serializable)→Exception→RuntimeException→CannotUndoException
Thrown By: javax.swing .text.AbstractDocument.DefaultDocumentEvent.undo(),
javax.swing .text.AbstractDocument.ElementEdit.undo(),
javax.swing .text.DefaultStyledDocument.AttributeUndoableEdit.undo(), AbstractUndoableEdit.undo(),
CompoundEdit.undo(), UndoableEdit.undo(), UndoManager.{undo(), undoOrRedo(), undoTo()}
CompoundEdit
Ja va 1.2
javax.swing .undo
serializable
This class is a compound UndoableEdit that collects a group of UndoableEdit objects into a
single object and allows them to be undone and redone as a group. After creating a
CompoundEdit object, you use addEdit() to add UndoableEdit objects to it. When you are
done adding edits, call end(). Once end() has been called, you can freely use the undo()
and redo() methods. The isInProgress() method retur ns tr ue if end() has not been called yet
and edits are still being added. While CompoundEdit maintains a list of UndoableEdit
objects to undo and redo, the addEdit() method does not simply add edits to this list.
When a new edit is added, CompoundEdit ﬁrst attempts to merge it with the previously
added edit by calling the addEdit() and replaceEdit() methods of the individual UndoableEdit
objects. If these methods fail to merge the two edits into one, the new edit is added to
the list of edits. The isSigniﬁcant() method retur ns tr ue if any of the edits on the list of
edits is signiﬁcant and retur ns false otherwise. getPresentationName() retur ns the name of
the last edit on the list, if it has one.
public class CompoundEdit extends AbstractUndoableEdit {
// Public Constructors
public CompoundEdit();
// Public Instance Methods
public void end();
default:true
public boolean isInProgress();
// Public Methods Overriding AbstractUndoableEdit
public boolean addEdit(UndoableEdit anEdit);
public boolean canRedo();
public boolean canUndo();
public void die();
default:""
public String getPresentationName();
default:"Redo"
public String getRedoPresentationName();
default:"Undo"
public String getUndoPresentationName();
default:false
public boolean isSigniﬁcant();
public void redo() throws CannotRedoException;
public String toString();
public void undo() throws CannotUndoException;
// Protected Instance Methods
protected UndoableEdit lastEdit();
// Protected Instance Fields
protected java.util.Vector edits;
}
Hierar chy: Object→AbstractUndoableEdit(Serializable, UndoableEdit)→CompoundEdit
Subc lasses: javax.swing .text.AbstractDocument.DefaultDocumentEvent, UndoManager
javax.swing.
undo
javax.swing.undo.CompoundEdit
Chapter 35 – The javax.swing.undo Package
685

Retur ned By: UndoableEditSuppor t.createCompoundEdit()
Type Of: UndoableEditSuppor t.compoundEdit
StateEdit
Ja va 1.2
javax.swing .undo
serializable
This class is an UndoableEdit implementation that works with StateEditable objects. First,
cr eate a StateEdit object, passing the StateEditable object to be edited to the constructor
(and optionally specifying a presentation name for the StateEdit). The constructor
queries the initial state of the StateEditable object and saves it. Next, make your edits to
the StateEditable object and then call the end() method on your StateEdit object. This
method queries the edited state of the object and saves that state. StateEdit implements
the undo() method by restoring the saved preedit state and implements the redo()
method by restoring the saved postedit state. For efﬁciency, StateEdit removes duplicate
state entries from the preedit and postedit hashtables, so only the state that changes is
saved.
public class StateEdit extends AbstractUndoableEdit {
// Public Constructors
public StateEdit(StateEditable anObject);
public StateEdit(StateEditable anObject, String name);
// Protected Constants
protected static ﬁnal String RCSID;
// Public Instance Methods
public void end();
// Public Methods Overriding AbstractUndoableEdit
public String getPresentationName();
public void redo();
public void undo();
// Protected Instance Methods
protected void init(StateEditable anObject, String name);
protected void removeRedundantState();
// Protected Instance Fields
protected StateEditable object;
protected java.util.Hashtable postState;
protected java.util.Hashtable preState;
protected String undoRedoName;
}
Hierar chy: Object→AbstractUndoableEdit(Serializable, UndoableEdit)→StateEdit
StateEditable
Ja va 1.2
javax.swing .undo
This interface deﬁnes methods that allow an object to save and restor e its state to and
fr om a java.util.Hashtable. Objects that are able to implement this interface can easily sup-
port undo management with the StateEdit class.
public abstract interface StateEditable {
// Public Constants
public static ﬁnal String RCSID;
// Public Instance Methods
public abstract void restoreState(java.util.Hashtable state);
public abstract void storeState(java.util.Hashtable state);
}
javax.swing.undo.CompoundEdit
686 Chapter 35 – The javax.swing.undo Package

Passed To: StateEdit.{init(), StateEdit()}
Type Of: StateEdit.object
UndoableEdit
Ja va 1.2
javax.swing .undo
This interface deﬁnes methods that encapsulate an undoable and redoable change to
the state of an application or component. The undo() and redo() methods are the most
important: they must actually undo and redo the edit. They throw exceptions if an edit
is undone twice or redone twice or if for some other reason an edit cannot be undone
or redone. canUndo() and canRedo() specify whether an UndoableEdit can currently be
undone or redone. die() tells an edit that it is no longer needed, so it can release any
resources it is holding. Neither undo() nor redo() should be called once die() has been
called.
getPresentationName() retur ns a human-r eadable description of the edit. getUndoPresenta-
tionName() and getRedoPresentationName() retur n human-r eadable descriptions of undoing
and redoing the edit. These two methods are usually implemented in terms of getPresen-
tationName() and might retur n strings like Undo typing or Redo deletion. isSigniﬁcant()
speciﬁes whether the edit is a signiﬁcant one. Typically, signiﬁcant edits are presented
to the user in a user interface, while insigniﬁcant edits are simply undone and redone
in conjunction with adjacent signiﬁcant edits. The UndoManager class treats insigniﬁcant
edits in this way, for example.
addEdit() and replaceEdit() ar e used for merging two UndoableEdit objects into one. addEdit()
is called to see if an existing UndoableEdit is willing to merge or absorb another edit into
itself. For example, if the user strikes the Backspace key twice in a row, the UndoableEdit
object generated by the ﬁrst keystroke might absorb the UndoableEdit object generated
by the second keystroke, changing itself from a backspace 1 edit to a backspace 2 edit.
addEdit() should retur n tr ue if it adds the edit and false otherwise. replaceEdit() has a simi-
lar purpose but operates in the other direction. It gives a new UndoableEdit object the
opportunity to absorb and replace an existing UndoableEdit. For example, if the user of a
text editor selects a paragraph of text and then deletes that paragraph, the delete-para-
graph edit might simply subsume and replace the select-paragraph edit. replaceEdit()
should retur n tr ue if it replaces the speciﬁed UndoableEdit object.
public abstract interface UndoableEdit {
// Property Accessor Methods (by property name)
public abstract String getPresentationName();
public abstract String getRedoPresentationName();
public abstract boolean isSigniﬁcant();
public abstract String getUndoPresentationName();
// Public Instance Methods
public abstract boolean addEdit(UndoableEdit anEdit);
public abstract boolean canRedo();
public abstract boolean canUndo();
public abstract void die();
public abstract void redo() throws CannotRedoException;
public abstract boolean replaceEdit(UndoableEdit anEdit);
public abstract void undo() throws CannotUndoException;
}
Implementations: AbstractUndoableEdit
Passed To: javax.swing .event.UndoableEditEvent.UndoableEditEvent(),
javax.swing .text.AbstractDocument.DefaultDocumentEvent.addEdit(), AbstractUndoableEdit.{addEdit(),
replaceEdit()}, CompoundEdit.addEdit(), UndoableEdit.{addEdit(), replaceEdit()},
UndoableEditSuppor t.{_postEdit(), postEdit()}, UndoManager.{addEdit(), redoTo(), undoTo()}
javax.swing.
undo
javax.swing.undo.UndoableEdit
Chapter 35 – The javax.swing.undo Package
687

Retur ned By: javax.swing .event.UndoableEditEvent.getEdit(),
javax.swing .text.AbstractDocument.Content.{insertString(), remove()},
javax.swing .text.GapContent.{insertString(), remove()}, javax.swing .text.StringContent.{insertString(), remove()},
CompoundEdit.lastEdit(), UndoManager.{editToBeRedone(), editToBeUndone()}
UndoableEditSuppor t
Ja va 1.2
javax.swing .undo
This utility class is useful for classes that support undoable edits and send
javax.swing .event.UndoableEditEvent events to javax.swing .event.UndoableEditListener objects. An
object that generates undoable events must allow the registration and deregistration of
event listeners for those events. Such an object can simply create an UndoableEditSuppor t
object and delegate to its addUndoableEditListener() and removeUndoableEditListener() meth-
ods.
UndoableEditSuppor t nor mally sends an UndoableEditEvent to all register ed listeners when
the postEdit() method is invoked. It also allows batching of edits into a CompoundEdit,
however. If beginUpdate() is called, all UndoableEdit objects passed to postEdit() ar e batched
into a CompoundEdit until endUpdate() is called. In this case, the UndoableEditEvent that con-
tains the CompoundEdit is not sent to the register ed UndoableEditListener objects until endUp-
date() is invoked. If beginUpdate() is called more than once, endUpdate() must be called a
matching number of times.
public class UndoableEditSuppor t {
// Public Constructors
public UndoableEditSuppor t();
public UndoableEditSuppor t(Object r);
// Event Registration Methods (by event name)
synchronized
public void addUndoableEditListener(javax.swing .event.UndoableEditListener l);
synchronized
public void removeUndoableEditListener(javax.swing .event.UndoableEditListener l);
// Public Instance Methods
synchronized
public void beginUpdate();
synchronized
public void endUpdate();
default:0
public int getUpdateLevel();
synchronized
public void postEdit(UndoableEdit e);
// Public Methods Overriding Object
public String toString();
// Protected Instance Methods
protected void _postEdit(UndoableEdit e);
protected CompoundEdit createCompoundEdit();
// Protected Instance Fields
protected CompoundEdit compoundEdit;
protected java.util.Vector listeners;
protected Object realSource;
protected int updateLevel;
}
UndoManager
Ja va 1.2
javax.swing .undo
serializable
This class maintains a list of UndoableEdit objects and allows them to be undone and
redone one signiﬁcant edit at a time. Edits can be added explicitly by calling addEdit().
UndoManager implements the javax.swing .event.UndoableEditListener inter face and automati-
cally calls addEdit() to add an edit to its list when it receives a javax.swing .event.UndoableEd-
itEvent. The addEdit() method works like the addEdit() method of CompoundEdit: it ﬁrst
attempts to merge the new edit with the last edit on the list by calling the addEdit() and
replaceEdit() methods of those edits. The edit is added as a separate edit only if it could
not be merged.
javax.swing.undo.UndoableEdit
688 Chapter 35 – The javax.swing.undo Package

After an edit is made and added to the UndoManager, the undo() method undoes it. After
it is undone, the redo() method redoes it. However, if a new edit is made after the ﬁrst
is undone, that ﬁrst undone edit is removed from the list and is no longer redoable.
This is the normal and expected behavior for an undo system. UndoManager distin-
guishes between signiﬁcant and insigniﬁcant edits. When you call undo(), it undoes all
edits up to the last signiﬁcant edit that occurred. When you call redo(), it redoes the
next signiﬁcant edit and all insigniﬁcant edits that follow it. A signiﬁcant UndoableEdit is
one whose isSigniﬁcant() method retur ns tr ue. getUndoPresentationName() retur ns the undo
pr esentation name of the signiﬁcant UndoableEdit that is undone by undo(). getRedoPresen-
tationName() retur ns the redo presentation name of the signiﬁcant UndoableEdit that is
per formed by the redo() action. setLimit() and getLimit() set and query the maximum num-
ber of UndoableEdit objects that the UndoManager tracks. The default is 100.
UndoManager is a subclass of CompoundEdit. If you call the end() method on an UndoMan-
ager, its behavior becomes that of a CompoundEdit and the list of edits is undone and
redone all at once. This can occasionally be useful when doing nested edits.
public class UndoManager extends CompoundEdit implements javax.swing.e vent.UndoableEditListener {
// Public Constructors
public UndoManager();
// Property Accessor Methods (by property name)
synchronized default:100
public int getLimit();
synchronized
public void setLimit(int l);
Overrides:CompoundEdit synchronized default:"Redo"
public String getRedoPresentationName();
synchronized default:"Undo"
public String getUndoOrRedoPresentationName();
Overrides:CompoundEdit synchronized default:"Undo"
public String getUndoPresentationName();
// Public Instance Methods
synchronized
public boolean canUndoOrRedo();
synchronized
public void discardAllEdits();
synchronized
public void undoOrRedo() throws CannotRedoException, CannotUndoException;
// Methods Implementing UndoableEditListener
public void undoableEditHappened(javax.swing .event.UndoableEditEvent e);
// Public Methods Overriding CompoundEdit
synchronized
public boolean addEdit(UndoableEdit anEdit);
synchronized
public boolean canRedo();
synchronized
public boolean canUndo();
synchronized
public void end();
synchronized
public void redo() throws CannotRedoException;
public String toString();
synchronized
public void undo() throws CannotUndoException;
// Protected Instance Methods
protected UndoableEdit editToBeRedone();
protected UndoableEdit editToBeUndone();
protected void redoTo(UndoableEdit edit) throws CannotRedoException;
protected void trimEdits(int from, int to);
protected void trimForLimit();
protected void undoTo(UndoableEdit edit) throws CannotUndoException;
}
Hierar chy: Object→AbstractUndoableEdit(Serializable, UndoableEdit)→CompoundEdit→
UndoManager(javax.swing .event.UndoableEditListener(java.util.EventListener))
javax.swing.
undo
javax.swing.undo.UndoManager
Chapter 35 – The javax.swing.undo Package
689

CHAPTER 36
Class Index
The following index allows you to look up a class of interface and ﬁnd what pack-
age it is deﬁned in. Use it when you want to look up a class but don’t know its
package.
A
AbstractAction: javax.swing
AbstractBorder : javax.swing .border
AbstractButton: javax.swing
AbstractButton.AccessibleAbstractButton:
javax.swing
AbstractButton.ButtonChangeListener : javax.swing
AbstractColorChooserPanel: javax.swing .colorchooser
AbstractDocument: javax.swing .text
AbstractDocument.AbstractElement: javax.swing .text
AbstractDocument.AttributeContext: javax.swing .text
AbstractDocument.BranchElement: javax.swing .text
AbstractDocument.Content: javax.swing .text
AbstractDocument.DefaultDocumentEvent:
javax.swing .text
AbstractDocument.ElementEdit: javax.swing .text
AbstractDocument.LeafElement: javax.swing .text
AbstractElement: javax.swing .text.AbstractDocument
AbstractLayoutCache: javax.swing .tree
AbstractLayoutCache.NodeDimensions:
javax.swing .tree
AbstractListModel: javax.swing
AbstractTableModel: javax.swing .table
AbstractUndoableEdit: javax.swing .undo
AbstractWriter : javax.swing .text
Accessible: javax.accessibility
AccessibleAbstractButton: javax.swing .AbstractBut-
ton
AccessibleAction: javax.accessibility
AccessibleBox: javax.swing .Box
AccessibleBoxF iller: javax.swing .Box.Filler
AccessibleBundle: javax.accessibility
AccessibleCellRendererPane: javax.swing .CellRender-
erPane
AccessibleComponent: javax.accessibility
AccessibleContainerHandler : javax.swing .JCompo-
nent.AccessibleJComponent
AccessibleContext: javax.accessibility
AccessibleHyperlink: javax.accessibility
AccessibleHyper text: javax.accessibility
AccessibleJApplet: javax.swing .JApplet
AccessibleJButton: javax.swing .JButton
AccessibleJCheckBox: javax.swing .JCheckBox
AccessibleJCheckBoxMenuItem: javax.swing .JCheck-
BoxMenuItem
AccessibleJColorChooser : javax.swing .JColorChooser
AccessibleJComboBox: javax.swing .JComboBox
AccessibleJComponent: javax.swing .JComponent
AccessibleJDesktopIcon: javax.swing .JInternal-
Frame.JDesktopIcon
AccessibleJDesktopPane: javax.swing .JDesktopPane
AccessibleJDialog: javax.swing .JDialog
690

AccessibleJEditorPane: javax.swing .JEditorPane
AccessibleJEditorPaneHTML: javax.swing .JEditorPane
AccessibleJF ileChooser: javax.swing .JFileChooser
AccessibleJFrame: javax.swing .JFrame
AccessibleJInternalFrame: javax.swing .JInternalFrame
AccessibleJLabel: javax.swing .JLabel
AccessibleJLayeredPane: javax.swing .JLayeredPane
AccessibleJList: javax.swing .JList
AccessibleJListChild: javax.swing .JList.AccessibleJList
AccessibleJMenu: javax.swing .JMenu
AccessibleJMenuBar : javax.swing .JMenuBar
AccessibleJMenuItem: javax.swing .JMenuItem
AccessibleJOptionPane: javax.swing .JOptionPane
AccessibleJPanel: javax.swing .JPanel
AccessibleJPasswordF ield: javax.swing .JPassword-
Field
AccessibleJPopupMenu: javax.swing .JPopupMenu
AccessibleJProgressBar : javax.swing .JProgressBar
AccessibleJRadioButton: javax.swing .JRadioButton
AccessibleJRadioButtonMenuItem: javax.swing .JRa-
dioButtonMenuItem
AccessibleJRootPane: javax.swing .JRootPane
AccessibleJScrollBar : javax.swing .JScrollBar
AccessibleJScrollPane: javax.swing .JScrollPane
AccessibleJSeparator : javax.swing .JSeparator
AccessibleJSlider : javax.swing .JSlider
AccessibleJSplitPane: javax.swing .JSplitPane
AccessibleJTabbedPane: javax.swing .JTabbedPane
AccessibleJTable: javax.swing .JTable
AccessibleJTableCell: javax.swing .JTable.Accessible-
JTable
AccessibleJTableHeader : javax.swing .table.JTable-
Header
AccessibleJTableHeaderEntry:
javax.swing .table.JTableHeader.AccessibleJTable-
Header
AccessibleJTextArea: javax.swing .JTextArea
AccessibleJTextComponent:
javax.swing .text.JTextComponent
AccessibleJTextF ield: javax.swing .JTextF ield
AccessibleJToggleButton: javax.swing .JToggleButton
AccessibleJToolBar : javax.swing .JToolBar
AccessibleJToolT ip: javax.swing .JToolT ip
AccessibleJTree: javax.swing .JTree
AccessibleJTreeNode: javax.swing .JTree.Accessible-
JTree
AccessibleJV ie wport: javax.swing .JVie wport
AccessibleJW indow: javax.swing .JWindow
AccessibleResourceBundle: javax.accessibility
AccessibleRole: javax.accessibility
AccessibleSelection: javax.accessibility
AccessibleState: javax.accessibility
AccessibleStateSet: javax.accessibility
AccessibleText: javax.accessibility
AccessibleValue: javax.accessibility
AccessibleW indowPopup: javax.swing .JPopup-
Menu.W indowPopup
Action: javax.swing
ActionEvent: java.awt.e vent
ActionListener : java.awt.e vent
ActiveEvent: java.awt
ActiveValue: javax.swing .UIDefaults
Adjustable: java.awt
AdjustmentEvent: java.awt.e vent
AdjustmentListener : java.awt.e vent
AfﬁneTransform: java.awt.geom
AfﬁneTransformOp: java.awt.image
AlignmentAction: javax.swing .text.StyledEditorKit
AlphaComposite: java.awt
AncestorEvent: javax.swing .event
AncestorListener : javax.swing .event
Applet: java.applet
AppletContext: java.applet
AppletStub: java.applet
Arc2D: java.awt.geom
Arc2D.Double: java.awt.geom
Arc2D.Float: java.awt.geom
Area: java.awt.geom
AreaAveragingScaleF ilter: java.awt.image
Attribute: javax.swing .text.html.CSS,
javax.swing .text.html.HTML
AttributeContext: javax.swing .text.AbstractDocument
AttributeList: javax.swing .text.html.parser
AttributeSet: javax.swing .text
AttributeSet.CharacterAttribute: javax.swing .text
AttributeSet.ColorAttribute: javax.swing .text
AttributeSet.FontAttribute: javax.swing .text
AttributeSet.ParagraphAttribute: javax.swing .text
AttributeUndoableEdit: javax.swing .text.DefaultStyled-
Document
AudioClip: java.applet
Autoscroll: java.awt.dnd
AWTError : java.awt
AWTEvent: java.awt
AWTEventListener : java.awt.e vent
AWTEventMulticaster : java.awt
AWTException: java.awt
AWTPermission: java.awt
Class
Index
Chapter 36 – Class Index
691

B
BadLocationException: javax.swing .text
BandCombineOp: java.awt.image
BandedSampleModel: java.awt.image
BasicStroke: java.awt
BeepAction: javax.swing .text.DefaultEditorKit
Be velBorder: javax.swing .border
Be velBorderUIResource: javax.swing .plaf.BorderUIRe-
source
Bias: javax.swing .text.Position
BlockAction: javax.swing .text.html.HTMLDocu-
ment.HTMLReader
BlockElement: javax.swing .text.html.HTMLDocument
BlockV ie w: javax.swing .text.html
BoldAction: javax.swing .text.StyledEditorKit
Book: java.awt.print
Border : javax.swing .border
BorderFactory: javax.swing
BorderLayout: java.awt
BorderUIResource: javax.swing .plaf
BorderUIResource.Be velBorderUIResource:
javax.swing .plaf
BorderUIResource.CompoundBorderUIResource:
javax.swing .plaf
BorderUIResource.EmptyBorderUIResource:
javax.swing .plaf
BorderUIResource.EtchedBorderUIResource:
javax.swing .plaf
BorderUIResource.LineBorderUIResource:
javax.swing .plaf
BorderUIResource.MatteBorderUIResource:
javax.swing .plaf
BorderUIResource.T itledBorderUIResource:
javax.swing .plaf
BoundedRangeModel: javax.swing
Box: javax.swing
Box.AccessibleBox: javax.swing
Box.F iller: javax.swing
Box.F iller.AccessibleBoxF iller: javax.swing
BoxLayout: javax.swing
BoxPainter : javax.swing .text.html.StyleSheet
BoxV ie w: javax.swing .text
BranchElement: javax.swing .text.AbstractDocument
BufferedImage: java.awt.image
BufferedImageF ilter: java.awt.image
BufferedImageOp: java.awt.image
Button: java.awt
ButtonChangeListener : javax.swing .AbstractButton
ButtonGroup: javax.swing
ButtonModel: javax.swing
ButtonPeer : java.awt.peer
ButtonUI: javax.swing .plaf
ByteLookupTable: java.awt.image
C
CannotRedoException: javax.swing .undo
CannotUndoException: javax.swing .undo
Canvas: java.awt
CanvasPeer : java.awt.peer
CardLayout: java.awt
Caret: javax.swing .text
CaretEvent: javax.swing .event
CaretListener : javax.swing .event
CaretPolicy: java.awt.font.TextLayout
CellEditor : javax.swing
CellEditorListener : javax.swing .event
CellRendererPane: javax.swing
CellRendererPane.AccessibleCellRendererPane:
javax.swing
ChangedCharSetException: javax.swing .text
ChangeEvent: javax.swing .event
ChangeListener : javax.swing .event
CharacterAction: javax.swing .text.html.HTMLDocu-
ment.HTMLReader
CharacterAttribute: javax.swing .text.AttributeSet
CharacterConstants: javax.swing .text.StyleConstants
Checkbox: java.awt
CheckboxGroup: java.awt
CheckboxMenuItem: java.awt
CheckboxMenuItemPeer : java.awt.peer
CheckboxPeer : java.awt.peer
Choice: java.awt
ChoicePeer : java.awt.peer
Clipboard: java.awt.datatransfer
ClipboardOwner : java.awt.datatransfer
CMMException: java.awt.color
Color : java.awt
ColorAttribute: javax.swing .text.AttributeSet
ColorChooserComponentFactory: javax.swing .color-
chooser
ColorChooserUI: javax.swing .plaf
ColorConstants: javax.swing .text.StyleConstants
ColorConver tOp: java.awt.image
ColorModel: java.awt.image
ColorSelectionModel: javax.swing .colorchooser
ColorSpace: java.awt.color
ColorUIResource: javax.swing .plaf
ComboBoxEditor : javax.swing
692 Chapter 36 – Class Index

ComboBoxModel: javax.swing
ComboBoxUI: javax.swing .plaf
Component: java.awt
ComponentAdapter : java.awt.e vent
ComponentColorModel: java.awt.image
ComponentEvent: java.awt.e vent
ComponentListener : java.awt.e vent
ComponentOrientation: java.awt
ComponentPeer : java.awt.peer
ComponentSampleModel: java.awt.image
ComponentUI: javax.swing .plaf
ComponentV ie w: javax.swing .text
Composite: java.awt
CompositeContext: java.awt
CompositeV ie w: javax.swing .text
CompoundBorder : javax.swing .border
CompoundBorderUIResource: javax.swing .plaf.Bor-
derUIResource
CompoundEdit: javax.swing .undo
Container : java.awt
ContainerAdapter : java.awt.e vent
ContainerEvent: java.awt.e vent
ContainerListener : java.awt.e vent
ContainerPeer : java.awt.peer
Content: javax.swing .text.AbstractDocument
ContentModel: javax.swing .text.html.parser
ContextualRenderedImageFactory:
java.awt.image.renderable
ConvolveOp: java.awt.image
CopyAction: javax.swing .text.DefaultEditorKit
CropImageF ilter: java.awt.image
CSS: javax.swing .text.html
CSS.Attribute: javax.swing .text.html
CubicCurve2D: java.awt.geom
CubicCurve2D.Double: java.awt.geom
CubicCurve2D.Float: java.awt.geom
Cursor : java.awt
CutAction: javax.swing .text.DefaultEditorKit
D
DataBuffer : java.awt.image
DataBufferByte: java.awt.image
DataBufferInt: java.awt.image
DataBufferShor t: java.awt.image
DataBufferUShor t: java.awt.image
DataFlavor : java.awt.datatransfer
DebugGraphics: javax.swing
DefaultBoundedRangeModel: javax.swing
DefaultButtonModel: javax.swing
DefaultCaret: javax.swing .text
DefaultCellEditor : javax.swing
DefaultCellEditor.EditorDelegate: javax.swing
DefaultColorSelectionModel: javax.swing .color-
chooser
DefaultComboBoxModel: javax.swing
DefaultDesktopManager : javax.swing
DefaultDocumentEvent: javax.swing .text.AbstractDoc-
ument
DefaultEditorKit: javax.swing .text
DefaultEditorKit.BeepAction: javax.swing .text
DefaultEditorKit.CopyAction: javax.swing .text
DefaultEditorKit.CutAction: javax.swing .text
DefaultEditorKit.DefaultKe yTypedAction:
javax.swing .text
DefaultEditorKit.Inser tBreakAction: javax.swing .text
DefaultEditorKit.Inser tContentAction:
javax.swing .text
DefaultEditorKit.Inser tTabAction: javax.swing .text
DefaultEditorKit.PasteAction: javax.swing .text
DefaultFocusManager : javax.swing
DefaultHighlighter : javax.swing .text
DefaultHighlighter.DefaultHighlightPainter :
javax.swing .text
DefaultHighlightPainter : javax.swing .text.DefaultH-
ighlighter
DefaultKe yTypedAction: javax.swing .text.DefaultEdi-
torKit
DefaultListCellRenderer : javax.swing
DefaultListCellRenderer.UIResource: javax.swing
DefaultListModel: javax.swing
DefaultListSelectionModel: javax.swing
DefaultMutableTreeNode: javax.swing .tree
DefaultSingleSelectionModel: javax.swing
DefaultStyledDocument: javax.swing .text
DefaultStyledDocument.AttributeUndoableEdit:
javax.swing .text
DefaultStyledDocument.ElementBuffer :
javax.swing .text
DefaultStyledDocument.ElementSpec:
javax.swing .text
DefaultStyledDocument.SectionElement:
javax.swing .text
DefaultTableCellRenderer : javax.swing .table
DefaultTableCellRenderer.UIResource:
javax.swing .table
DefaultTableColumnModel: javax.swing .table
DefaultTableModel: javax.swing .table
DefaultTextF ield: javax.swing .tree.DefaultTreeCellEdi-
tor
Class
Index
Chapter 36 – Class Index
693

DefaultTextUI: javax.swing .text
DefaultTreeCellEditor : javax.swing .tree
DefaultTreeCellEditor.DefaultTextF ield:
javax.swing .tree
DefaultTreeCellEditor.EditorContainer :
javax.swing .tree
DefaultTreeCellRenderer : javax.swing .tree
DefaultTreeModel: javax.swing .tree
DefaultTreeSelectionModel: javax.swing .tree
DesktopIconUI: javax.swing .plaf
DesktopManager : javax.swing
DesktopPaneUI: javax.swing .plaf
Dialog: java.awt
DialogPeer : java.awt.peer
Dimension: java.awt
Dimension2D: java.awt.geom
DimensionUIResource: javax.swing .plaf
DirectColorModel: java.awt.image
DnDConstants: java.awt.dnd
Document: javax.swing .text
DocumentEvent: javax.swing .event
DocumentEvent.ElementChange: javax.swing .event
DocumentEvent.EventType: javax.swing .event
DocumentListener : javax.swing .event
DocumentParser : javax.swing .text.html.parser
Double: java.awt.geom.Arc2D, java.awt.geom.Cubic-
Curve2D, java.awt.geom.Ellipse2D,
java.awt.geom.Line2D, java.awt.geom.Point2D,
java.awt.geom.QuadCurve2D, java.awt.geom.Rect-
angle2D, java.awt.geom.RoundRectangle2D
DragGestureEvent: java.awt.dnd
DragGestureListener : java.awt.dnd
DragGestureRecognizer : java.awt.dnd
DragSource: java.awt.dnd
DragSourceContext: java.awt.dnd
DragSourceContextPeer : java.awt.dnd.peer
DragSourceDragEvent: java.awt.dnd
DragSourceDropEvent: java.awt.dnd
DragSourceEvent: java.awt.dnd
DragSourceListener : java.awt.dnd
DropTarget: java.awt.dnd
DropTarget.DropTargetAutoScroller : java.awt.dnd
DropTargetAutoScroller : java.awt.dnd.DropTarget
DropTargetContext: java.awt.dnd
DropTargetContext.TransferableProxy: java.awt.dnd
DropTargetContextPeer : java.awt.dnd.peer
DropTargetDragEvent: java.awt.dnd
DropTargetDropEvent: java.awt.dnd
DropTargetEvent: java.awt.dnd
DropTargetListener : java.awt.dnd
DropTargetPeer : java.awt.dnd.peer
DTD: javax.swing .text.html.parser
DTDConstants: javax.swing .text.html.parser
DynamicUtilTreeNode: javax.swing .JTree
E
EditorContainer : javax.swing .tree.DefaultTreeCellEdi-
tor
EditorDelegate: javax.swing .DefaultCellEditor
EditorKit: javax.swing .text
Element: javax.swing .text, javax.swing .text.html.parser
ElementBuffer : javax.swing .text.DefaultStyledDocu-
ment
ElementChange: javax.swing .event.DocumentEvent
ElementEdit: javax.swing .text.AbstractDocument
ElementIterator : javax.swing .text
ElementSpec: javax.swing .text.DefaultStyledDocument
Ellipse2D: java.awt.geom
Ellipse2D.Double: java.awt.geom
Ellipse2D.Float: java.awt.geom
EmptyBorder : javax.swing .border
EmptyBorderUIResource: javax.swing .plaf.Bor-
derUIResource
EmptySelectionModel: javax.swing .JTree
Entity: javax.swing .text.html.parser
EtchedBorder : javax.swing .border
EtchedBorderUIResource: javax.swing .plaf.Bor-
derUIResource
Event: java.awt
EventListenerList: javax.swing .event
EventQueue: java.awt
EventType: javax.swing .event.DocumentEvent,
javax.swing .event.HyperlinkEvent
ExpandVetoException: javax.swing .tree
F
FieldV ie w: javax.swing .text
FileChooserUI: javax.swing .plaf
FileDialog: java.awt
FileDialogPeer : java.awt.peer
FileF ilter: javax.swing .ﬁlechooser
FileSystemV ie w: javax.swing .ﬁlechooser
FileV ie w: javax.swing .ﬁlechooser
Filler : javax.swing .Box
FilteredImageSource: java.awt.image
FixedHeightLayoutCache: javax.swing .tree
FlatteningPathIterator : java.awt.geom
FlavorMap: java.awt.datatransfer
694 Chapter 36 – Class Index

Float: java.awt.geom.Arc2D, java.awt.geom.Cubic-
Curve2D, java.awt.geom.Ellipse2D,
java.awt.geom.Line2D, java.awt.geom.Point2D,
java.awt.geom.QuadCurve2D, java.awt.geom.Rect-
angle2D, java.awt.geom.RoundRectangle2D
FlowLayout: java.awt
FocusAdapter : java.awt.e vent
FocusEvent: java.awt.e vent
FocusListener : java.awt.e vent
FocusManager : javax.swing
Font: java.awt
FontAttribute: javax.swing .text.AttributeSet
FontConstants: javax.swing .text.StyleConstants
FontFamilyAction: javax.swing .text.StyledEditorKit
FontMetrics: java.awt
FontPeer : java.awt.peer
FontRenderContext: java.awt.font
FontSizeAction: javax.swing .text.StyledEditorKit
FontUIResource: javax.swing .plaf
ForegroundAction: javax.swing .text.StyledEditorKit
FormAction: javax.swing .text.html.HTMLDocu-
ment.HTMLReader
FormV ie w: javax.swing .text.html
FormV ie w.MouseEventListener: javax.swing .text.html
Frame: java.awt
FramePeer : java.awt.peer
G
GapContent: javax.swing .text
GeneralPath: java.awt.geom
GlyphJustiﬁcationInfo: java.awt.font
GlyphMetrics: java.awt.font
GlyphVector : java.awt.font
GradientPaint: java.awt
GraphicAttribute: java.awt.font
Graphics: java.awt
Graphics2D: java.awt
GraphicsConﬁgTemplate: java.awt
GraphicsConﬁguration: java.awt
GraphicsDe vice: java.awt
GraphicsEnvironment: java.awt
GrayF ilter: javax.swing
GridBagConstraints: java.awt
GridBagLayout: java.awt
GridLayout: java.awt
H
HiddenAction: javax.swing .text.html.HTMLDocu-
ment.HTMLReader
Highlight: javax.swing .text.Highlighter
Highlighter : javax.swing .text
Highlighter.Highlight: javax.swing .text
Highlighter.HighlightPainter : javax.swing .text
HighlightPainter : javax.swing .text.Highlighter
HTML: javax.swing .text.html
HTML.Attribute: javax.swing .text.html
HTML.Tag: javax.swing .text.html
HTML.UnknownTag: javax.swing .text.html
HTMLDocument: javax.swing .text.html
HTMLDocument.BlockElement: javax.swing .text.html
HTMLDocument.HTMLReader : javax.swing .text.html
HTMLDocument.HTMLReader.BlockAction:
javax.swing .text.html
HTMLDocument.HTMLReader.CharacterAction:
javax.swing .text.html
HTMLDocument.HTMLReader.FormAction:
javax.swing .text.html
HTMLDocument.HTMLReader.HiddenAction:
javax.swing .text.html
HTMLDocument.HTMLReader.IsindexAction:
javax.swing .text.html
HTMLDocument.HTMLReader.ParagraphAction:
javax.swing .text.html
HTMLDocument.HTMLReader.PreAction:
javax.swing .text.html
HTMLDocument.HTMLReader.SpecialAction:
javax.swing .text.html
HTMLDocument.HTMLReader.TagAction:
javax.swing .text.html
HTMLDocument.Iterator : javax.swing .text.html
HTMLDocument.RunElement: javax.swing .text.html
HTMLEditorKit: javax.swing .text.html
HTMLEditorKit.HTMLFactory: javax.swing .text.html
HTMLEditorKit.HTMLTextAction: javax.swing .text.html
HTMLEditorKit.Inser tHTMLTextAction:
javax.swing .text.html
HTMLEditorKit.LinkController : javax.swing .text.html
HTMLEditorKit.Parser : javax.swing .text.html
HTMLEditorKit.ParserCallback: javax.swing .text.html
HTMLFactory: javax.swing .text.html.HTMLEditorKit
HTMLFrameHyperlinkEvent: javax.swing .text.html
HTMLLink: javax.swing .JEditorPane.JEditorPaneAcces-
sibleHyper textSuppor t
HTMLReader : javax.swing .text.html.HTMLDocument
HTMLTextAction: javax.swing .text.html.HTMLEditorKit
Class
Index
Chapter 36 – Class Index
695

HTMLWriter : javax.swing .text.html
HyperlinkEvent: javax.swing .event
HyperlinkEvent.EventType: javax.swing .event
HyperlinkListener : javax.swing .event
I
ICC_ColorSpace: java.awt.color
ICC_Proﬁle: java.awt.color
ICC_ProﬁleGray: java.awt.color
ICC_ProﬁleRGB: java.awt.color
Icon: javax.swing
IconUIResource: javax.swing .plaf
IconV ie w: javax.swing .text
IllegalComponentStateException: java.awt
IllegalPathStateException: java.awt.geom
Image: java.awt
ImageConsumer : java.awt.image
ImageF ilter: java.awt.image
ImageGraphicAttribute: java.awt.font
ImageIcon: javax.swing
ImageObserver : java.awt.image
ImageProducer : java.awt.image
ImagingOpException: java.awt.image
IndexColorModel: java.awt.image
InlineV ie w: javax.swing .text.html
InputContext: java.awt.im
InputEvent: java.awt.e vent
InputMethodEvent: java.awt.e vent
InputMethodHighlight: java.awt.im
InputMethodListener : java.awt.e vent
InputMethodRequests: java.awt.im
InputSubset: java.awt.im
Inser tBreakAction: javax.swing .text.DefaultEditorKit
Inser tContentAction: javax.swing .text.DefaultEditorKit
Inser tHTMLTextAction: javax.swing .text.html.HTMLEd-
itorKit
Inser tTabAction: javax.swing .text.DefaultEditorKit
Insets: java.awt
InsetsUIResource: javax.swing .plaf
insideT imerAction: javax.swing .ToolT ipManager
InternalFrameAdapter : javax.swing .event
InternalFrameEvent: javax.swing .event
InternalFrameListener : javax.swing .event
InternalFrameUI: javax.swing .plaf
InvalidDnDOperationException: java.awt.dnd
InvocationEvent: java.awt.e vent
IsindexAction: javax.swing .text.html.HTMLDocu-
ment.HTMLReader
ItalicAction: javax.swing .text.StyledEditorKit
ItemEvent: java.awt.e vent
ItemListener : java.awt.e vent
ItemSelectable: java.awt
Iterator : javax.swing .text.html.HTMLDocument
J
JApplet: javax.swing
JApplet.AccessibleJApplet: javax.swing
JButton: javax.swing
JButton.AccessibleJButton: javax.swing
JCheckBox: javax.swing
JCheckBox.AccessibleJCheckBox: javax.swing
JCheckBoxMenuItem: javax.swing
JCheckBoxMenuItem.AccessibleJCheckBoxMenu-
Item: javax.swing
JColorChooser : javax.swing
JColorChooser.AccessibleJColorChooser : javax.swing
JComboBox: javax.swing
JComboBox.AccessibleJComboBox: javax.swing
JComboBox.Ke ySelectionManager: javax.swing
JComponent: javax.swing
JComponent.AccessibleJComponent: javax.swing
JComponent.AccessibleJComponent.AccessibleCon-
tainerHandler : javax.swing
JDesktopIcon: javax.swing .JInternalFrame
JDesktopPane: javax.swing
JDesktopPane.AccessibleJDesktopPane: javax.swing
JDialog: javax.swing
JDialog .AccessibleJDialog: javax.swing
JEditorPane: javax.swing
JEditorPane.AccessibleJEditorPane: javax.swing
JEditorPane.AccessibleJEditorPaneHTML: javax.swing
JEditorPane.JEditorPaneAccessibleHyper textSup-
por t: javax.swing
JEditorPane.JEditorPaneAccessibleHyper textSup-
por t.HTMLLink: javax.swing
JEditorPaneAccessibleHyper textSuppor t:
javax.swing .JEditorPane
JF ileChooser: javax.swing
JF ileChooser.AccessibleJF ileChooser: javax.swing
JFrame: javax.swing
JFrame.AccessibleJFrame: javax.swing
JInternalFrame: javax.swing
JInternalFrame.AccessibleJInternalFrame:
javax.swing
JInternalFrame.JDesktopIcon: javax.swing
JInternalFrame.JDesktopIcon.AccessibleJDesktopI-
con: javax.swing
JLabel: javax.swing
696 Chapter 36 – Class Index

JLabel.AccessibleJLabel: javax.swing
JLayeredPane: javax.swing
JLayeredPane.AccessibleJLayeredPane: javax.swing
JList: javax.swing
JList.AccessibleJList: javax.swing
JList.AccessibleJList.AccessibleJListChild:
javax.swing
JMenu: javax.swing
JMenu.AccessibleJMenu: javax.swing
JMenu.W inListener: javax.swing
JMenuBar : javax.swing
JMenuBar.AccessibleJMenuBar : javax.swing
JMenuItem: javax.swing
JMenuItem.AccessibleJMenuItem: javax.swing
JOptionPane: javax.swing
JOptionPane.AccessibleJOptionPane: javax.swing
JPanel: javax.swing
JPanel.AccessibleJPanel: javax.swing
JPasswordF ield: javax.swing
JPasswordF ield.AccessibleJPasswordF ield:
javax.swing
JPopupMenu: javax.swing
JPopupMenu.AccessibleJPopupMenu: javax.swing
JPopupMenu.Separator : javax.swing
JPopupMenu.W indowPopup.AccessibleW indow-
Popup: javax.swing
JProgressBar : javax.swing
JProgressBar.AccessibleJProgressBar : javax.swing
JRadioButton: javax.swing
JRadioButton.AccessibleJRadioButton: javax.swing
JRadioButtonMenuItem: javax.swing
JRadioButtonMenuItem.AccessibleJRadioButton-
MenuItem: javax.swing
JRootPane: javax.swing
JRootPane.AccessibleJRootPane: javax.swing
JRootPane.RootLayout: javax.swing
JScrollBar : javax.swing
JScrollBar.AccessibleJScrollBar : javax.swing
JScrollPane: javax.swing
JScrollPane.AccessibleJScrollPane: javax.swing
JScrollPane.ScrollBar : javax.swing
JSeparator : javax.swing
JSeparator.AccessibleJSeparator : javax.swing
JSlider : javax.swing
JSlider.AccessibleJSlider : javax.swing
JSplitPane: javax.swing
JSplitPane.AccessibleJSplitPane: javax.swing
JTabbedPane: javax.swing
JTabbedPane.AccessibleJTabbedPane: javax.swing
JTabbedPane.ModelListener : javax.swing
JTable: javax.swing
JTable.AccessibleJTable: javax.swing
JTable.AccessibleJTable.AccessibleJTableCell:
javax.swing
JTableHeader : javax.swing .table
JTableHeader.AccessibleJTableHeader :
javax.swing .table
JTableHeader.AccessibleJTableHeader.Accessible-
JTableHeaderEntry: javax.swing .table
JTextArea: javax.swing
JTextArea.AccessibleJTextArea: javax.swing
JTextComponent: javax.swing .text
JTextComponent.AccessibleJTextComponent:
javax.swing .text
JTextComponent.Ke yBinding: javax.swing .text
JTextF ield: javax.swing
JTextF ield.AccessibleJTextF ield: javax.swing
JTextPane: javax.swing
JToggleButton: javax.swing
JToggleButton.AccessibleJToggleButton: javax.swing
JToggleButton.ToggleButtonModel: javax.swing
JToolBar : javax.swing
JToolBar.AccessibleJToolBar : javax.swing
JToolBar.Separator : javax.swing
JToolT ip: javax.swing
JToolT ip.AccessibleJToolT ip: javax.swing
JTree: javax.swing
JTree.AccessibleJTree: javax.swing
JTree.AccessibleJTree.AccessibleJTreeNode:
javax.swing
JTree.DynamicUtilTreeNode: javax.swing
JTree.EmptySelectionModel: javax.swing
JTree.TreeModelHandler : javax.swing
JTree.TreeSelectionRedirector : javax.swing
JV ie wport: javax.swing
JV ie wport.AccessibleJV ie wport: javax.swing
JV ie wport.V ie wListener: javax.swing
JW indow: javax.swing
JW indow.AccessibleJW indow: javax.swing
K
Kernel: java.awt.image
Ke y: java.awt.RenderingHints
Ke yAdapter: java.awt.e vent
Ke yBinding: javax.swing .text.JTextComponent
Ke yEvent: java.awt.e vent
Ke yListener: java.awt.e vent
Ke ymap: javax.swing .text
Class
Index
Chapter 36 – Class Index
697

Ke ySelectionManager: javax.swing .JComboBox
Ke yStroke: javax.swing
L
Label: java.awt
LabelPeer : java.awt.peer
LabelUI: javax.swing .plaf
LabelV ie w: javax.swing .text
LayeredHighlighter : javax.swing .text
LayeredHighlighter.LayerPainter : javax.swing .text
LayerPainter : javax.swing .text.LayeredHighlighter
LayoutManager : java.awt
LayoutManager2: java.awt
LazyValue: javax.swing .UIDefaults
LeafElement: javax.swing .text.AbstractDocument
LightweightPeer : java.awt.peer
Line2D: java.awt.geom
Line2D.Double: java.awt.geom
Line2D.Float: java.awt.geom
LineBorder : javax.swing .border
LineBorderUIResource: javax.swing .plaf.BorderUIRe-
source
LineBreakMeasurer : java.awt.font
LineMetrics: java.awt.font
LinkController : javax.swing .text.html.HTMLEditorKit
List: java.awt
ListCellRenderer : javax.swing
ListDataEvent: javax.swing .event
ListDataListener : javax.swing .event
ListModel: javax.swing
ListPainter : javax.swing .text.html.StyleSheet
ListPeer : java.awt.peer
ListSelectionEvent: javax.swing .event
ListSelectionListener : javax.swing .event
ListSelectionModel: javax.swing
ListUI: javax.swing .plaf
ListV ie w: javax.swing .text.html
LookAndFeel: javax.swing
LookAndFeelInfo: javax.swing .UIManager
LookupOp: java.awt.image
LookupTable: java.awt.image
M
MatteBorder : javax.swing .border
MatteBorderUIResource: javax.swing .plaf.Bor-
derUIResource
MediaTracker : java.awt
MemoryImageSource: java.awt.image
Menu: java.awt
MenuBar : java.awt
MenuBarPeer : java.awt.peer
MenuBarUI: javax.swing .plaf
MenuComponent: java.awt
MenuComponentPeer : java.awt.peer
MenuContainer : java.awt
MenuDragMouseEvent: javax.swing .event
MenuDragMouseListener : javax.swing .event
MenuElement: javax.swing
MenuEvent: javax.swing .event
MenuItem: java.awt
MenuItemPeer : java.awt.peer
MenuItemUI: javax.swing .plaf
MenuKe yEvent: javax.swing .event
MenuKe yListener: javax.swing .event
MenuListener : javax.swing .event
MenuPeer : java.awt.peer
MenuSelectionManager : javax.swing
MenuShor tcut: java.awt
MinimalHTMLWriter : javax.swing .text.html
ModelListener : javax.swing .JTabbedPane
MouseAdapter : java.awt.e vent
MouseDragGestureRecognizer : java.awt.dnd
MouseEvent: java.awt.e vent
MouseEventListener : javax.swing .text.html.FormVie w
MouseInputAdapter : javax.swing .event
MouseInputListener : javax.swing .event
MouseListener : java.awt.e vent
MouseMotionAdapter : java.awt.e vent
MouseMotionListener : java.awt.e vent
MultiPixelPackedSampleModel: java.awt.image
MultipleMaster : java.awt.font
MutableAttributeSet: javax.swing .text
MutableComboBoxModel: javax.swing
MutableTreeNode: javax.swing .tree
N
NamedStyle: javax.swing .text.StyleContext
NodeDimensions: javax.swing .tree.AbstractLayout-
Cache
Noninver tibleTransformException: java.awt.geom
O
ObjectV ie w: javax.swing .text.html
OpenType: java.awt.font
Option: javax.swing .text.html
OptionPaneUI: javax.swing .plaf
698 Chapter 36 – Class Index

outsideT imerAction: javax.swing .ToolT ipManager
OverlayLayout: javax.swing
P
PackedColorModel: java.awt.image
Pageable: java.awt.print
PageFormat: java.awt.print
Paint: java.awt
PaintContext: java.awt
PaintEvent: java.awt.e vent
Panel: java.awt
PanelPeer : java.awt.peer
PanelUI: javax.swing .plaf
Paper : java.awt.print
ParagraphAction: javax.swing .text.html.HTMLDocu-
ment.HTMLReader
ParagraphAttribute: javax.swing .text.AttributeSet
ParagraphConstants: javax.swing .text.StyleConstants
ParagraphV ie w: javax.swing .text, javax.swing .text.html
ParameterBlock: java.awt.image.renderable
Parser : javax.swing .text.html.HTMLEditorKit,
javax.swing .text.html.parser
ParserCallback: javax.swing .text.html.HTMLEditorKit
ParserDelegator : javax.swing .text.html.parser
PasswordV ie w: javax.swing .text
PasteAction: javax.swing .text.DefaultEditorKit
PathIterator : java.awt.geom
PixelGrabber : java.awt.image
PixelInterleavedSampleModel: java.awt.image
PlainDocument: javax.swing .text
PlainV ie w: javax.swing .text
Point: java.awt
Point2D: java.awt.geom
Point2D.Double: java.awt.geom
Point2D.Float: java.awt.geom
Polygon: java.awt
PopupMenu: java.awt
PopupMenuEvent: javax.swing .event
PopupMenuListener : javax.swing .event
PopupMenuPeer : java.awt.peer
PopupMenuUI: javax.swing .plaf
Position: javax.swing .text
Position.Bias: javax.swing .text
PreAction: javax.swing .text.html.HTMLDocu-
ment.HTMLReader
Printable: java.awt.print
PrinterAbor tException: java.awt.print
PrinterException: java.awt.print
PrinterGraphics: java.awt.print
PrinterIOException: java.awt.print
PrinterJob: java.awt.print
PrintGraphics: java.awt
PrintJob: java.awt
ProﬁleDataException: java.awt.color
ProgressBarUI: javax.swing .plaf
ProgressMonitor : javax.swing
ProgressMonitorInputStream: javax.swing
Q
QuadCurve2D: java.awt.geom
QuadCurve2D.Double: java.awt.geom
QuadCurve2D.Float: java.awt.geom
R
Raster : java.awt.image
RasterFormatException: java.awt.image
RasterOp: java.awt.image
Rectangle: java.awt
Rectangle2D: java.awt.geom
Rectangle2D.Double: java.awt.geom
Rectangle2D.Float: java.awt.geom
RectangularShape: java.awt.geom
RenderableImage: java.awt.image.renderable
RenderableImageOp: java.awt.image.renderable
RenderableImageProducer : java.awt.image.render-
able
RenderContext: java.awt.image.renderable
RenderedImage: java.awt.image
RenderedImageFactory: java.awt.image.renderable
Renderer : javax.swing
RenderingHints: java.awt
RenderingHints.Ke y: java.awt
RepaintManager : javax.swing
ReplicateScaleF ilter: java.awt.image
RescaleOp: java.awt.image
RGBImageF ilter: java.awt.image
RootLayout: javax.swing .JRootPane
RootPaneContainer : javax.swing
RoundRectangle2D: java.awt.geom
RoundRectangle2D.Double: java.awt.geom
RoundRectangle2D.Float: java.awt.geom
RowMapper : javax.swing .tree
RTFEditorKit: javax.swing .text.rtf
RunElement: javax.swing .text.html.HTMLDocument
Class
Index
Chapter 36 – Class Index
699

S
SampleModel: java.awt.image
Scrollable: javax.swing
ScrollBar : javax.swing .JScrollPane
Scrollbar : java.awt
ScrollbarPeer : java.awt.peer
ScrollBarUI: javax.swing .plaf
ScrollPane: java.awt
ScrollPaneConstants: javax.swing
ScrollPaneLayout: javax.swing
ScrollPaneLayout.UIResource: javax.swing
ScrollPanePeer : java.awt.peer
ScrollPaneUI: javax.swing .plaf
SectionElement: javax.swing .text.DefaultStyledDocu-
ment
Segment: javax.swing .text
Separator : javax.swing .JPopupMenu,
javax.swing .JToolBar
SeparatorUI: javax.swing .plaf
Shape: java.awt
ShapeGraphicAttribute: java.awt.font
Shor tLookupTable: java.awt.image
SimpleAttributeSet: javax.swing .text
SinglePixelPackedSampleModel: java.awt.image
SingleSelectionModel: javax.swing
SizeRequirements: javax.swing
SliderUI: javax.swing .plaf
SmallAttributeSet: javax.swing .text.StyleContext
SoftBe velBorder: javax.swing .border
SpecialAction: javax.swing .text.html.HTMLDocu-
ment.HTMLReader
SplitPaneUI: javax.swing .plaf
StateEdit: javax.swing .undo
StateEditable: javax.swing .undo
stillInsideT imerAction: javax.swing .ToolT ipManager
StringContent: javax.swing .text
StringSelection: java.awt.datatransfer
Stroke: java.awt
Style: javax.swing .text
StyleConstants: javax.swing .text
StyleConstants.CharacterConstants: javax.swing .text
StyleConstants.ColorConstants: javax.swing .text
StyleConstants.FontConstants: javax.swing .text
StyleConstants.ParagraphConstants: javax.swing .text
StyleContext: javax.swing .text
StyleContext.NamedStyle: javax.swing .text
StyleContext.SmallAttributeSet: javax.swing .text
StyledDocument: javax.swing .text
StyledEditorKit: javax.swing .text
StyledEditorKit.AlignmentAction: javax.swing .text
StyledEditorKit.BoldAction: javax.swing .text
StyledEditorKit.FontFamilyAction: javax.swing .text
StyledEditorKit.FontSizeAction: javax.swing .text
StyledEditorKit.ForegroundAction: javax.swing .text
StyledEditorKit.ItalicAction: javax.swing .text
StyledEditorKit.StyledTextAction: javax.swing .text
StyledEditorKit.UnderlineAction: javax.swing .text
StyledTextAction: javax.swing .text.StyledEditorKit
StyleSheet: javax.swing .text.html
StyleSheet.BoxPainter : javax.swing .text.html
StyleSheet.ListPainter : javax.swing .text.html
SwingConstants: javax.swing
SwingProper tyChangeSuppor t: javax.swing .event
SwingUtilities: javax.swing
SystemColor : java.awt
SystemFlavorMap: java.awt.datatransfer
T
TabableV ie w: javax.swing .text
TabbedPaneUI: javax.swing .plaf
TabExpander : javax.swing .text
TableCell: javax.swing .text.TableV ie w
TableCellEditor : javax.swing .table
TableCellRenderer : javax.swing .table
TableColumn: javax.swing .table
TableColumnModel: javax.swing .table
TableColumnModelEvent: javax.swing .event
TableColumnModelListener : javax.swing .event
TableHeaderUI: javax.swing .plaf
TableModel: javax.swing .table
TableModelEvent: javax.swing .event
TableModelListener : javax.swing .event
TableRow: javax.swing .text.TableV ie w
TableUI: javax.swing .plaf
TableV ie w: javax.swing .text
TableV ie w.TableCell: javax.swing .text
TableV ie w.TableRow: javax.swing .text
TabSet: javax.swing .text
TabStop: javax.swing .text
Tag: javax.swing .text.html.HTML
TagAction: javax.swing .text.html.HTMLDocu-
ment.HTMLReader
TagElement: javax.swing .text.html.parser
TextAction: javax.swing .text
TextArea: java.awt
TextAreaPeer : java.awt.peer
TextAttribute: java.awt.font
TextComponent: java.awt
700 Chapter 36 – Class Index

TextComponentPeer : java.awt.peer
TextEvent: java.awt.e vent
TextF ield: java.awt
TextF ieldPeer: java.awt.peer
TextHitInfo: java.awt.font
TextLayout: java.awt.font
TextLayout.CaretPolicy: java.awt.font
TextLine.TextLineMetrics: java.awt.font
TextLineMetrics: java.awt.font.TextLine
TextListener : java.awt.e vent
TextUI: javax.swing .plaf
TexturePaint: java.awt
TileObserver : java.awt.image
Timer : javax.swing
TitledBorder : javax.swing .border
TitledBorderUIResource: javax.swing .plaf.BorderUIRe-
source
ToggleButtonModel: javax.swing .JToggleButton
ToolBarUI: javax.swing .plaf
Toolkit: java.awt
ToolT ipManager: javax.swing
ToolT ipManager.insideT imerAction: javax.swing
ToolT ipManager.outsideT imerAction: javax.swing
ToolT ipManager.stillInsideT imerAction: javax.swing
ToolT ipUI: javax.swing .plaf
Transferable: java.awt.datatransfer
TransferableProxy: java.awt.dnd.DropTargetContext
TransformAttribute: java.awt.font
Transparency: java.awt
TreeCellEditor : javax.swing .tree
TreeCellRenderer : javax.swing .tree
TreeExpansionEvent: javax.swing .event
TreeExpansionListener : javax.swing .event
TreeModel: javax.swing .tree
TreeModelEvent: javax.swing .event
TreeModelHandler : javax.swing .JTree
TreeModelListener : javax.swing .event
TreeNode: javax.swing .tree
TreePath: javax.swing .tree
TreeSelectionEvent: javax.swing .event
TreeSelectionListener : javax.swing .event
TreeSelectionModel: javax.swing .tree
TreeSelectionRedirector : javax.swing .JTree
TreeUI: javax.swing .plaf
TreeW illExpandListener: javax.swing .event
U
UIDefaults: javax.swing
UIDefaults.ActiveValue: javax.swing
UIDefaults.LazyValue: javax.swing
UIManager : javax.swing
UIManager.LookAndFeelInfo: javax.swing
UIResource: javax.swing .DefaultListCellRenderer,
javax.swing .plaf, javax.swing .ScrollPaneLayout,
javax.swing .table.DefaultTableCellRenderer
UnderlineAction: javax.swing .text.StyledEditorKit
UndoableEdit: javax.swing .undo
UndoableEditEvent: javax.swing .event
UndoableEditListener : javax.swing .event
UndoableEditSuppor t: javax.swing .undo
UndoManager : javax.swing .undo
UnknownTag: javax.swing .text.html.HTML
Unsuppor tedFlavorException: java.awt.datatransfer
Unsuppor tedLookAndFeelException: javax.swing
Utilities: javax.swing .text
V
VariableHeightLayoutCache: javax.swing .tree
View: javax.swing .text
ViewFactory: javax.swing .text
ViewListener : javax.swing .JVie wport
Viewpor tLayout: javax.swing
Viewpor tUI: javax.swing .plaf
W
Window: java.awt
WindowAdapter : java.awt.e vent
WindowConstants: javax.swing
WindowEvent: java.awt.e vent
WindowListener : java.awt.e vent
WindowPeer : java.awt.peer
WinListener : javax.swing .JMenu
WrappedPlainV ie w: javax.swing .text
WritableRaster : java.awt.image
WritableRenderedImage: java.awt.image
Class
Index
Chapter 36 – Class Index
701


Index
A
Abstract Windowing Toolkit (see
AWT)
AbstractAction class, 27, 401
AbstractBorder class, 519
AbstractButton class, 29, 31, 403
AbstractColorChooserPanel class, 527
AbstractDocument class, 579
AbstractElement class, 582
AbstractLayoutCache class, 666
AbstractListModel class, 406
AbstractTableModel class, 568
AbstractUndoableEdit class, 683
AbstractWriter class, 586
acceptDr op( ), 116-117
Dr opTargetContext class, 256
accept( ) (FileFilter), 43, 551
accessibility, 388-398
Swing, 58-59, 62
Accessible interface, 58, 62, 388
AccessibleAction interface, 389
AccessibleBundle class, 390
AccessibleComponent interface, 390
AccessibleContext class, 391
AccessibleHyperlink class, 392
AccessibleHypertext interface, 393
AccessibleJComponent class, 436
AccessibleResourceBundle class, 393
AccessibleRole class, 394
AccessibleSelection interface, 395
AccessibleState class, 396
AccessibleStateSet class, 396
AccessibleText class, 397
AccessibleValue interface, 398
Action interface, 26-27, 406-407
ActionEvent class, 18, 265
ActionListener interface, 21, 26, 32,
266
actionPer formed( ), 401
Action interface, 407
ActionEvent class, 18
ActionListener interface, 18, 21, 26,
32
ActiveEvent interface, 154
adapters
ComponentAdapter interface, 268
ContainerAdapter class, 269
event, 19
FocusAdapter class, 271
KeyAdapter class, 276
MouseAdapter class, 281
WindowAdapter class, 285
addActionForKeyStr oke( ) (Keymap),
608
addActionListener( ) (T imer), 27
addAuxiliaryLookAndFeel( ), 57
addChangeListener( ) (Style), 616
addChooseableFileFilter( ) (FileFilter),
552
703

addChooserPanel( ), 45
addConsumer( ), 351
addEdit( )
AbstractUndoableEdit class, 684
CompoundEdit class, 685
UndoableEdit interface, 687
UndoManager class, 688
addImage( ), 68
MediaTracker class, 207
addItemListener( ) (ItemSelectable),
203
addItem( )
Choice class, 170
JComboBox class, 431
addKeymap( ), 33
Keymap interface, 608
addLayoutComponent( ) (LayoutMan-
ager), 204
addPoint( ) (Polygon), 214
addPr opertyChangeListener( ), 44
addRenderingHints( ), 70
RenderingHints class, 218
addSelectionPaths(), (DefaultTreeSe-
lectionModel), 674
addSeparator( )
JMenu class, 453
JPopupMenu class, 462
JToolBar class, 488
Menu class, 208
addStyle( )
StyleContext class, 619
StyledDocument interface, 622
addTableModelListener( ) (Table-
Model), 577
addTab( ) methods (JTabbedPane),
477
addUndoableEditListener( )
(UndoableEditSupport), 688
add( ), 14, 17, 449
AWTEventMulticaster class, 161
BorderLayout, 15
Container class, 178
Dialog class, 181
EventListenerList class, 536
GridBagLayout class, 200
JMenu class, 453
JMenuBar class, 455
JPopupMenu class, 462
JToolBar class, 488
Menu class, 208
MenuBar class, 208
PopupMenu class, 215
Adjustable interface, 157
AdjustmentEvent class, 267
AdjustmentListener interface, 21, 267
adjustmentValueChanged( ) (Adjust-
mentListener), 21
Af ﬁneTransfor m class, 73, 97-98,
302-304
mathematics of, 98-100
Af ﬁneTransfor mOp class, 95, 332
ALIGN attribute, <APPLET> tag
(HTML), 131
AlignmentAction class, 624
alpha channel, 80-81
AlphaComposite interface, 70, 80-81,
158, 177
ALT attribute, <APPLET> tag (HTML),
131
ancestorAdded( ) (AncestorListener),
22, 532
AncestorEvent class, 530
AncestorListener interface, 22, 532
ancestorMoved( ) (AncestorListener),
22, 532
ancestorRemoved( ) (AncestorLis-
tener), 22, 532
antialiasing, Java 2D, 88
appendText( ) (TextAr ea), 224
append( )
Book class, 382
GeneralPath class, 314
Applet class, 12, 123-125, 150-151
AppletContext interface, 152
applets, 3-4, 123
Applet class, 12, 123-125, 150-151
<APPLET> tag (HTML), 123,
129-131
AppletContext interface, 152
AppletStub interface, 152
<EMBED> tag (HTML), 132
example, 125-126
images, loading from URLs, 68
JAR ﬁles and, 131-132
Java Plug-in, 5, 132-133
<OBJECT> tag (HTML), 132
<PARAM> tag (HTML), 131
printing, 103
security restrictions, 134-136
signed, 136
704 Index

applets (cont’d)
Swing, 13
writing, 123-125
AppletStub interface, 152
applyResourceBundle( ) (Componen-
tOrientation), 177
Arc2D class, 305
architectur es
pluggable look-and-feel, 24, 55-58
Swing, 23-24
ARCHIVE attribute, <APPLET> tag
(HTML), 130-132
arcs, Java 2D, 74
Ar ea class, 74, 308
Ar eaAveragingScaleFilter class, 334
ascent, 89
assistive technologies (see accessibil-
ity)
Attribute class, 635, 637
AttributeContext interface, 583
AttributeList class, 656
AttributeSet interface, 586
AttributeUndoableEdit class, 598
audio ﬁles, 151-152
AudioClip interface, 152
Autoscr oll inter face, 246
autoscr oll( ), 246
auxiliary look-and-feel, 57
AWT, 3, 5
components, 7-8
containers, 12-13
event listeners, 21-22
events, 17-23
graphics capabilities, 64-68
layout managers, 15
AWTErr or, 160
AWTEvent class, 17, 160
AWTEventListener interface, 268
AWTEventMulticaster class, 161
AWTException, 163
AWTPer mission class, 164
B
BadLocationException class, 588
BandCombineOp class, 334-335
BandedSampleModel class, 335
BasicStr oke class, 78, 164
beginUpdate( ) (UndoableEditSup-
port), 688
BevelBorder class, 34, 520
BevelBorderUIResource class, 556
Bias class, 613
BlockAction class, 643
BlockElement class, 642
Book class, 382
Border interface, 521
BorderFactory class, 407
BorderLayout class, 15, 165
borders, 15
AWT, 165
Swing, 29, 34, 519-526
BorderUIResources class, 554
BoundedRangeModel interface,
408-409
bounding boxes, Java 2D, 75
Box class, 13, 37-40, 409
BoxLayout class, 13, 16, 37, 410
BoxPainter class, 655
BoxView class, 588
BranchElement class, 583
br eadthFirstEnumeration( ) (Default-
MutableTreeNode), 668
br eaksFlow( ) (Tag), 639
brighter( ) (Color), 171
buf fered images, Java 2D, 92-97
Buf feredImage class, 92, 94, 332, 336
Buf feredImageFilter class, 338
Buf feredImageOp interface, 96, 332,
338
buildChooser( ) (AbstractColor-
ChooserPanel), 528
Button class, 8, 167
ButtonModel interface, 411
ButtonPeer class, 373
buttons, 41
Button class, 167
Swing, 403, 411, 466, 487
(see also by button name, such as
push buttons)
ButtonUI class, 557
ByteLookupTable class, 339
Index 705

C
cancelCellEditing( ) (CellEditor), 412
canDisplayUpTo( ), 187
canDisplay( ), 187
canEditImmediately( ), 670
canFilterIndexColorModel, 363
CannotRedoException class, 684
CannotUndoException class, 684
canRedo( ) (UndoableEdit), 687
canUndo( ) (UndoableEdit), 687
Canvas class, 8, 167
CanvasPeer class, 373
CardLayout class, 15, 168
Car et inter face, 589
Car etEvent class, 532
Car etListener inter face, 22
Car etPolicy class, 300
car etPositionChanged( ) (InputMethod-
Listener), 274
car etUpdate( ) (Car etListener), 22
Cascading Style Sheet (CSS), 634
CellEditor interface, 412
CellEditorListener interface, 22, 533
CellRender erPane class, 413
ChangedCharSetException class, 590
ChangeEvent class, 60, 533
ChangeListener interface, 22, 534
CharacterAction class, 643
CharacterAttribute interface, 587
CharacterConstants class, 618
charWidth( ), 67
Checkbox class, 8, 168
checkboxes
AWT, 8, 168-169
Swing, 9, 428
CheckboxGr oup class, 169
CheckboxMenuItem class, 8, 169
CheckboxMenuItemPeer class, 373
CheckboxPeer class, 374
Choice class, 8, 170
ChoicePeer class, 374
circles, Java 2D, 74, 78
classes, 95
inner, 19
(see also individual classes)
clearSelection(), (DefaultTreeSelection-
Model), 674
Clipboard class, 114, 239
ClipboardOwner interface, 114,
239-240
clipping region
AWT, 65
Java 2D, 69
clip( ), 69
Graphics2D class, 73
closePath( ) (GeneralPath), 314
CODE attribute, <APPLET> tag
(HTML), 130, 132
CODEBASE attribute, <APPLET> tag
(HTML), 130
color, 171, 192, 233-235, 237, 339
AWT, 65-66, 158
Java 2D, 69, 81-85, 95-96, 194
composite, 177
converting to grayscale, 96
inverting, 96
translucent, 81
Transpar ency inter face, 229
transpar ent, 80-81
Paint interface, 212
RGBImageFilter class, 362
Swing, 429, 527-529
choosing, 9, 44-45
converting to grayscale, 425
SystemColor class, 223
transferring, 117-122
Color class, 66, 79, 100-101, 154, 171
color spaces, Java 2D, 100-101
ColorChooserComponentFactory class,
528
ColorChooserUI class, 558
ColorConstants class, 618
ColorConvertOp class, 95, 339
ColorModel class, 340-341
ColorSelectionModel interface, 528
ColorSink class, 119
ColorSource class, 117
ColorSpace class, 100-101, 232-233
ColorUIResource class, 57, 558
combination boxes, Swing, 9, 431
ComboBoxEditor interface, 413
ComboBoxModel interface, 414
ComboBoxUI class, 558
Component class, 8, 12, 92, 154, 173
applets, 124, 127
event-pr ocessing methods of, 127
ComponentAdapter interface, 268
706 Index

componentAdded( ) (ContainerLis-
tener), 21
ComponentColorModel class, 342
ComponentEvent class, 268
componentHidden( ) (ComponentLis-
tener), 21
ComponentListener interface, 21, 269
componentMoved( ) (ComponentLis-
tener), 21
ComponentOrientation class, 177
ComponentPeer class, 375
componentRemoved( ) (ContainerLis-
tener), 21
componentResized( ) (ComponentLis-
tener), 21
components
AWT, 7-8
ComponentAdapter interface, 268
ComponentEvent class, 268
ComponentListener interface, 269
heavyweight/lightweight, 5
pr operties (see properties)
Swing, 8-11, 23-24
custom, 59-63
sizes of, 38
ComponentSampleModel class, 343
componentShown( ) (ComponentLis-
tener), 21
ComponentUI class, 558
ComponentView class, 590
compose( ), 178
Composite interface, 69, 154, 177
CompositeContext interface, 178
CompositeView class, 591
compositing, 177
AWT, 158-159
Java 2D, 69, 80-85, 178
CompoundBorder class, 34, 521
CompoundBorderUIResource class,
556
CompoundEdit class, 685
constructors, 60
consume( )
InputEvent class, 272
KeyEvent class, 277
Container class, 12, 154, 178
AWT, 12
ContainerAdapter class, 269
ContainerEvent class, 270
ContainerListener interface, 21, 270
ContainerPeer class, 375
containers, 12
AWT, 12-13
ContainerAdapter class, 269
ContainerEvent class, 270
ContainerListener interface, 270
Swing, 13-14, 30
contains( ), 309, 321
Content interface, 584
ContentModel class, 657
contentsChanged( ) (ListDataListener),
22
ContextualRender edImageFactory
inter face, 369
contr olDown( ), 128
contr ols (see components)
ConvolveOp class, 95, 97, 344
coordinate system, Java 2D, 71-73
copy( ) (ColorSource), 117
cr eateCar et( ) (EditorKit), 601
cr eateCompatibleImage( ) (Graphic-
sConﬁguration), 197
cr eateContext( ), 178
Composite interface, 177
cr eateCustomCursor( ) (Toolkit), 36
cr eateDefaultDragGestur eRecognizer( ),
251
cr eateDialog( ), 45
JColorChooser class, 429
JOptionPane class, 458
cr eateDisabledImage( )
GrayFilter class, 425
ImageIcon class, 35
cr eateGraphics( ) (Buf feredImage), 92
cr eateHorizontalBox( ), 37
cr eateHorizontalGlue( ), 37
Box class, 409
cr eateHorizontalStrut( ), 37
Box class, 409
cr eateImage( ) (Component), 68, 92,
173, 197
cr eateInternalFrame( ) (JOptionPane),
458
cr eatePosition( ) (Document), 600
cr eateStrokedShape( ) (Str oke), 78
cr eateToolT ip( ) (JToolT ip), 489
cr eateTransfor medShape( ) (Af ﬁne-
Transfor m), 98, 304
cr eateValue( ) (UIDefaults), 514
cr eateVerticalBox( ), 37
Index 707

cr eateVerticalGlue( ), 37
Box class, 409
cr eateVerticalStrut( ), 37
Box class, 409
cr eate( )
Graphics class, 192
HTMLFactory class, 647
ViewFactory interface, 631
Cr opImageFilter class, 345
CSS (Cascading Style Sheet), 634
CSS class, 634
CubicCurve2D class, 309
curr entDir ectory, 43
curr entSegment( ) (PathIterator),
318-319
Cursor class, 35-36, 180
cursors, 180
Swing, 35-36
curves, 313
Java 2D, 73-75
curve( ) (GeneralPath), 75
cut-and-paste, 4, 111, 114-115, 239-245
D
darker( ) (Color), 171
dashes, Java 2D, 77-78
data sink, 112, 119-122
data source, 112, 117-119
data transfer, 4
cut-and-paste, 239-245
drag-and-dr op, 246-263
data types, 111
DataBuf fer class, 345
DataBuf ferByte class, 346
DataBuf ferInt class, 347
DataBuf ferShort class, 347
DataBuf ferUShort class, 348
DataFlavor class, 111-112, 239, 241
DebugGraphics class, 414
decode( ), 625
DefaultBoundedRangeModel class, 416
DefaultButtonModel class, 416
DefaultCar et class, 592
DefaultCellEditor class, 417-418
DefaultColorSelectionModel class, 529
DefaultComboBoxModel class, 419
DefaultDocumentEvent class, 584
DefaultEditorKit class, 593
DefaultFocusManager class, 420
DefaultHighlighter class, 596
DefaultHighlightPainter class, 597
DefaultKeyT ypedAction class, 595
DefaultListCellRender er class, 420
DefaultListModel class, 421
DefaultListSelectionModel class, 422
DefaultMetalTheme class, 56
DefaultMutableTreeNode class, 668
defaultPage( ) (PrinterJob), 387
DefaultSingleSelectionModel class, 423
DefaultStyledDocument class, 597
DefaultTableCellRender er class, 570
DefaultTableColumnModel class, 570
DefaultTableModel class, 571
DefaultTextField class, 671
DefaultTreeCellEditor class, 670
DefaultTreeCellRender er class, 672
DefaultTreeModel class, 47, 673
DefaultTreeSelectionModel class, 674
deltaTransfor m( ) (Af ﬁneTransfor m),
98, 304
depthFirstEnumeration( ) (Default-
MutableTreeNode), 668
deriveFont( )
Font class, 88
GraphicsEnvir onment class, 198
descent, 89
DesktopIconUI class, 559
DesktopManager interface, 423
DesktopPanelUI class, 559
desktops, Swing, 13
destr oy( ) (Applet), 124, 150
device space, 72
dialog boxes, 185
AWT, 12
Dialog class, 181
Swing, 10, 13, 40-42, 438, 457
Dialog class, 12, 181
DialogPeer class, 376
die( ) (UndoableEdit), 687
Dimension class, 182
Dimension2D class, 311
DimensionalUIResource class, 559
Dir ectColorModel class, 348
disableSwingFocusManager( ) (Focus-
Manager), 424
708 Index

disable( )
Component class, 173
MenuItem class, 210
dispose( ), 103
Dialog class, 181
Frame class, 190
Graphics class, 192
PrintJob class, 216
WindowEvent class, 286
DnDConstants interface, 247-248
Document interface, 579, 600
document type deﬁnition (DTD), 658
DocumentEvent class, 534
DocumentParser class, 658
double buffering, 9, 68
PrintableComponent class, 106
Swing, 37
Double class, 306, 310, 312, 317, 320,
322, 324, 327
doubleBuf fered, 37
dragActionChanged( ) (DragSourceLis-
tener), 253
drag-and-dr op, 4, 111, 115-117,
246-263
dragDr opEnd( ), 116
DragSourceListener class, 254
dragEnter( ), 116, 119
DragSourceListener class, 254
Dr opTargetListener class, 259
dragExit( ), 116, 119
DragSourceListener class, 253-254
Dr opTargetListener class, 259
DragGestur eEvent class, 115, 248
DragGestur eListener class, 249
dragGestur eRecognized( ), 115
DragGestur eEvent class, 248
TransferableColor class, 117
DragGestur eRecognizer class, 249
dragOver( ), 116
DragSourceListener class, 253-254
Dr opTargetListener class, 260
DragSource class, 250
DragSourceContext package, 252
DragSourceContextPeer interface, 262
DragSourceDragEvent class, 253
DragSourceDr opEvent class, 253
DragSourceEvent class, 253
DragSourceListener class, 115, 254
drawGlyphVector( ), 71, 90
drawImage() methods, 71
Graphics, 67
Graphics2D, 93-94
Graphics2D class, 195
drawPolygon( ) (Polygon), 214
drawRenderableImage( ), 71
drawRender edImage( ), 71
Graphics2D class, 94
drawString( ), 71, 107
Graphics2D class, 90, 195
draw( ), 70, 78, 292
Graphics2D class, 73, 92, 195
TextLayout class, 91, 298
dr opActionChanged( )
DragSourceListener class, 254
Dr opTargetListener class, 260
dr opComplete( ) (Dr opTargetEvent),
117
dr op-down lists, 8-9, 170
Dr opTarget class, 255
Dr opTargetAutoScr oller class, 256
Dr opTargetContext class, 256
Dr opTargetContextPeer interface, 263
Dr opTargetDragEvent class, 257
Dr opTargetDr opEvent class, 258
Dr opTargetEvent class, 116, 259
Dr opTargetListener interface, 116,
259-260
Dr opTargetPeer interface, 263
dr op( ), 116, 119
Dr opTargetListener class, 258, 260
DTD class, 658
DTD (document type deﬁnition), 656,
658
DTDConstants class, 659
DynamicUtilTreeNode class, 494
E
echoing text, 226
editingCanceled( ), 22
editingStopped( ), 22
editor panes, Swing, 9
EditorContainer class, 672
EditorKit class, 601
Element interface, 602, 660
ElementBuf fer class, 599
ElementChange interface, 535
Index 709

ElementEdit class, 585
ElementIterator class, 603
ElementSpec class, 599
Ellipse2D class, 312
ellipses, Java 2D, 74
EmptyBorder, 34
EmptyBorder class, 522
EmptyBorderUIResource class, 556
EmptySelectionModel class, 495
enableEvents( ), 20, 61
AWTEvent class, 160
enable( )
Component class, 173
MenuItem class, 210
end caps, Java 2D, 76
endUpdate( ) (UndoableEditSupport),
688
end( ), 103
CompoundEdit class, 685
PrintJob class, 216
StateEdit class, 686
UndoManager class, 689
Entity class, 661
EtchedBorder class, 34, 522
EtchedBorderUIResource class, 556
event adapters, 19
Event class, 127-128, 182
event dispatch thread, 28
event handling, 17-18
applets, 127-129
AWT, 264-287
with inner classes, 19
input events, 19-20
Swing, 264-287
custom components and, 61
with inner classes, 19
input events, 19-20
event listeners, 18
ActionListener interface, 266
AWT, 21-22, 264
ComponentListener interface, 269
ItemListener interface, 276
KeyListener interface, 281
MouseListener interface, 283
MouseMotionListener interface, 283
registering, 61
Swing, 22-23, 27-28, 264, 536, 545
TextListener interface, 285
WindowListener, 287
event model
Java 1.0, 127-129
Java 1.1, 20
event sources, 18
EventListenerList class, 536
EventObject class, 17
EventQueue class, 184
events
ActionEvent class, 265
AdjustmentEvent class, 267
AWTEvent class, 160
AWTEventMulticaster class, 161
ComponentEvent class, 268
ContainerEvent class, 270
custom components and, 60
Event class, 127, 182
EventQueue class, 184
FocusEvent class, 271
InputEvent class, 272
InputMethodEvent class, 273
ItemEvent class, 275
keyboard, 226, 276
MouseEvent class, 281
naming conventions, 20
PaintEvent class, 284
Swing, 530-550
target, 127
TextEvent class, 284
WindowEvent class, 286
EventT ype class, 535, 537
examples in this book, available from,
xi
F
factory methods, 81
ﬁle chooser class, 9
FileChooserUI class, 560
FileDialog class, 8, 185
FileDialogPeer class, 376
FileFilter class, 43, 551
ﬁles, FileDialog class, 185
ﬁleSelectionMode, 43
ﬁlesystem, 43
br owsing
AWT, 8
Swing, 42-44
displaying, Swing, 47, 552
FileSystemView class, 43, 552
FileView class, 43, 553
710 Index

ﬁll style, Java 2D, 69
Filler class, 37, 410
ﬁllPolygon( ) (Polygon), 214
ﬁlls, Java 2D, 79-80
ﬁll( ), 70, 78
Graphics2D class, 73, 195
Filter edImageSource class, 349
ﬁlterRGB( ), 362
ﬁlter( )
Af ﬁneTransfor mOp class, 332
Buf feredImageOp interface, 96, 338
ColorConvertOp class, 340
ConvolveOp class, 344
LookupOp class, 354
ﬁrst( ) (CardLayout), 168
FixedHeightLayoutCache class, 676
FlatteningPathIterator class, 313
FlavorMap interface, 243
Float class, 307, 311, 313, 317, 321,
323, 328
FlowLayout class, 15, 186
focus management, 420, 424
custom components and, 63
Swing, 29-31
FocusAdapter class, 271
FocusEvent class, 271
focusGained( ), 21
FocusListener interface, 21, 272
focusLost( ), 21
FocusManager class, 424
Font class, 66, 87-89, 154, 187-189
font glyphs, Java 2D, 91
font metrics, AWT, 67
FontConstants class, 619
FontFamilyAction class, 624
FontMetrics class, 189
FontPeer class, 376
FontRenderContext class, 288
fonts, 187-189, 198, 209, 288-301
AWT, 65-67
Java 2D, 69, 87-90
FontSizeAction class, 624
FontUIResource class, 57, 560
For egroundAction class, 625
For mAction class, 644
For mView class, 636
Frame class, 12, 190
FramePeer class, 376
G
GapContent class, 604
GeneralPath class, 75, 314
getAcceptAllFileFilter( ) (JFileChooser),
441
getAccessibleAction( ) (AccessibleAc-
tion), 389
getAccessibleComponent( ) (Accessi-
bleComponent), 390
getAccessibleContext( ) (Accessible),
58, 62, 388
getAccessibleRole( ) (AccessibleRole),
394
getAccessibleSelection( ), 395
getAccessibleValue( ), 58
getActionCommand( ) (ActionEvent),
32, 266
getActions( ), 593
EditorKit class, 601
getAction( )
Keymap interface, 608
StyledEditorKit class, 625
getAdjustable( ), 267
getAdjustmentT ype( ), 267
getAdvance( ) (GlyphMetrics), 290
getAlignment( ), 292
getAllFonts( ), 87
GraphicsEnvir onment class, 198
getAllowsChildr en( ) (Default-
Tr eeModel), 673
getAlpha( )
Color class, 171
ColorModel class, 340
getAncestorOfClass( ) (SwingUtilities),
510
getAncestorPar ent( ) (AncestorEvent),
530
getAncestor( ) (AncestorEvent), 530
getAppletContext( ), 152
Applet class, 125, 151
getAppletInfo( ), 151
Applet class, 124
getApplets( ), 152
getApplet( ), 152
getAscent( ), 67
LineMetrics class, 293
getAttributeKey( ) (HTML), 637
Index 711

getAttributeNames( ) (AttributeSet),
587
getAttributes( )
Element interface, 602
Iterator class, 646
getAudioClip( ), 152
Applet class, 125, 151
AppletContext interface, 152
getAvailableFontFamilyNames( ), 87
GraphicsEnvir onment class, 198
getBestCursorSize( ), 36
getBlue( )
Color class, 171
ColorModel class, 340
getBorderInsets( )
AbstractBorder class, 520
Border interface, 521
getBoundingBox( ) (Polygon), 214
getBounds2D( ), 75
GlyphMetrics class, 290
Shape interface, 222
getBounds( ), 75
Shape interface, 222
getBoxPainter( ) (StyleSheet), 654
getCar etPosition( ) (JTextAr ea), 483
getCar etShapes( ) (TextLayout), 299
getCar etShape( ) (TextLayout), 298
getCellEditorValue( ) (CellEditor), 412
getChange( ) (DocumentEvent), 534
getCharacterAttributeRun( ) (StyledEdi-
torKit), 623
getCharacterElement( ) (StyledDocu-
ment), 622
getCharIndex( ) (TextHitInfo), 297
getChildCount( ) (TreeModel), 678
getChildIndices( ) (TreeModelEvent),
547
getChildr en( ) (Tr eeModelEvent), 547
getChild( ), 270
Tr eeModel class, 678
getClickCount( ), 282
MouseEvent class, 17
getClientPr operty( )
JComponent class, 28, 433
getCodeBase( ) (Applet), 125, 151
getColorComponents( ) (Color), 172
getColorModel( ) (GraphicsConﬁgura-
tion), 197
getColorSelectionModel( ) (Abstract-
ColorChooserPanel), 528
getColumnClass( ) (TableModel), 577
getColumnCount( )
AbstractTableModel class, 568
TableModel interface, 577
getColumnName( ) (TableModel), 577
getColumn( ) (TableModelEvent), 545
getCommittedCharacterCount( ), 273
getComponents( )
Color class, 171
Container class, 178
getComponent( )
AncestorEvent class, 530
ComponentEvent class, 268
FocusEvent class, 271
InputEvent class, 272
KeyEvent class, 277
MouseEvent class, 282
getContainer( ) (ContainerEvent), 270
getContentPane( ), 14
JApplet class, 426
JDialog class, 438
JFrame class, 443
JInter nalFrame class, 445
JRootPane class, 467
RootPaneContainer interface, 506
getContents( ), 115, 239
getContentT ype( )
EditorKit class, 601
RTFEditorKit class, 664
getCr ossPlatformLookAndFeelClassName( )
(UIManager), 516
getCurr entDataFlavors( ), 258
getCurr entFocusManager( ), 31
getData( ) (Buf feredImage), 95
getDefaultCursor( ) (Cursor), 180
getDefaultDragsource( ), 250
getDefaultFlavorMap( ), 243
getDefaultScr eenDevice( )
GraphicsDevice class, 197
GraphicsEnvir onment class, 198
getDefaultStyleContext( ) (StyleCon-
text), 619
getDefaultToolkit( ) (Toolkit), 227
getDefaultTransfor m( ) (GraphicsCon-
ﬁguration), 196
getDefaultValue( ) (Attribute), 635
712 Index

getDescent( ) (LineMetrics), 293
getDescription( ) (FileFilter), 43, 552
getDeviceConﬁguration( ) (Graphics-
Device), 197
getDevice( ) (GraphicsDevice), 197
getDisplayName( ) (AbstractColor-
ChooserPanel), 528
getDocumentBase( ) (Applet), 125, 151
getDocument( ) (DocumentEvent), 534
getDr opAction( ), 116, 253, 258
getDr opSuccess( ), 116
getEdit( ) (UndoableEditEvent), 550
getElementCount( ), 602
getElementIndex( ), 602
getElementIterator( ) (AbstractWriter),
586
getElement( ), 602
getElem( ) (DataBuf ferShort), 347
getEndOf fset( ), 602
Iterator class, 646
getEventT ype( ) (HyperlinkEvent), 536
getFileSystemView( ) (FileSys-
temView), 552
getFiles( ) (FileSystemView), 552
getFile( ) (FileDialog), 185
getFirstIndex( ) (ListSelectionEvent),
540
getFirstRow( ) (TableModelEvent), 545
getFlavorsForNatives( ) (FlavorMap),
243
getFondRenderContext( ) (Graph-
ics2D), 187
getFontList( ) (Toolkit), 227
getFontMetrics( )
Font class, 187
FontMetrics class, 189
Graphics class, 67
getFr omIndex( ) (TableColumnMod-
elEvent), 545
getGestur eModiﬁers( ), 253
getGlyphMetrics( ), 91
getGlyphOutline( ), 91
GlyphVector class, 90-91
getGraphics( ), 68, 103
Graphics class, 192
Image class, 202
PrintJob class, 102, 215
getGr een( ) (ColorModel), 340
getHAdjustable( ) (Scr ollPane), 221
getHeight( ), 67, 89
LineMetrics class, 294
getHomeDir ectory( ) (FileSystemView),
552
getHScr ollbarHeight( ) (Scr ollPane),
221
getIcon( ) (FileView), 553
getIDString( ) (GraphicsDevice), 197
getID( )
ActionEvent class, 265
AdjustmentEvent class, 267
AncestorEvent class, 530
AWTEvent class, 17, 160
ComponentEvent class, 269
ContainerEvent class, 270
Inter nalFrameEvent class, 538
ItemEvent class, 275
KeyEvent class, 276
MouseEvent class, 281-282
TextEvent class, 285
WindowEvent class, 286
getImageableHeight( ), 104
getImageableWidth( ), 104
getImageableX( ), 104
getImageableY( ), 104
getImage( )
Applet class, 92, 125, 151
AppletContext interface, 152
ImageIcon class, 92
Toolkit class, 68, 92
getIndex0( ), 539
getIndex1( ), 539
getInputAttributes( ) (StyledEditorKit),
623
getInstalledLookAndFeels( ), 56
UIManager class, 516
getInstance( ), 158
AlphaComposite interface, 81
ColorSpace class, 233
getInteriorRectangle( ) (AbstractBor-
der), 520
getItemSelectable( ) (ItemEvent), 275
getItem( ) (ItemEvent), 275
getIterator( ) (HTMLDocument), 641,
646
getJMenuBar( ) (JApplet), 426
getKeyChar( ), 277
getKeyCode( ), 276
getKeymap( ), 33
Index 713

getKeyModiﬁersText( ), 277
getKeyStr oke( ), 32
KeyStr oke class, 498
getKeyText( ), 277
getLargeDisplayIcon( ) (AbstractColor-
ChooserPanel), 528
getLastIndex( ) (ListSelectionEvent),
540
getLastPathComponent( ) (TreePath),
679
getLastRow( ) (TableModelEvent), 545
getLeading( ) (LineMetrics), 293
getLength( ) (DocumentEvent), 534
getLimit( ) (UndoManager), 689
getLineMetrics( )
Font class, 89-90
LineMetrics class, 293
getLink( ) (AccessibleHypertext), 393
getListCellRender erComponent( ) (List-
CellRender er), 499
getListenerList( ) (EventListenerList),
536
getListPainter( ) (StyleSheet), 654
getLocalGraphicsEnvir onment( ), 87
GraphicsEnvir onment class, 198
getLogicalHighlightShape( ) (TextLay-
out), 299
getLookAndFeel( ) (UIManager), 516
getLSB( ) (GlyphMetrics), 290
getMaximumSize( ), 62
getMaximumSpan( ) (View), 630
getMenuShortcutKeyMask( ), 211
getMinimumSize( ), 62
getMinimumSpan( ) (View), 630
getModiﬁers( )
ActionEvent class, 266
InputEvent class, 272
MouseEvent class, 17, 282
getName( ) (Clipboard), 239
getNextEvent( ) (EventQueue), 184
getNext( ) (AttributeList), 656
getNumberOfPages( ) (Pageable), 107
getOf fset( ) (DocumentEvent), 534
getOrientation( ) (ComponentOrienta-
tion), 177
getOutline( ) (GlyphVector), 90-91
getPageDimension( ) (PrintJob), 216
getPageResolution( ) (PrintJob), 216
getParagraphElement( ) (StyledDocu-
ment), 622
getParameterInfo( ), 151
Applet class, 124
getParameter( ) (Applet), 125, 151
getPar entElement( ) (Element), 602
getPar ent( )
Component class, 173
View class, 630
getParser( ) (HTMLEditorKit), 646
getPassword( ) (JPasswordField), 462
getPathForRow( ) (JTree), 491
getPathIterator() methods, 75
getPaths( ) (TreeSelectionEvent), 548
getPath( )
Tr eeExpansionEvent class, 546
Tr eeModelEvent class, 547
Tr eePath class, 679
Tr eeSelectionEvent class, 548
getPoint( ) (MouseEvent), 282
getPr edeﬁnedCursor( ), 35
Cursor class, 180
getPr eferr edSize( ), 62
getPr eferr edSpan( )
TabableView interface, 626
View class, 630
getPr esentationName( )
AbstractUndoableEdit class, 684
CompoundEdit class, 685
UndoableEdit interface, 687
getPrintable( ) (Pageable), 382
getPrinterJob( ), 103
PrinterJob class, 387
getPrintJob( )
PrintGraphics interface, 215
PrintJob class, 215
Toolkit class, 102
getPr operty( ) (Document), 600
getReader( ) (HTMLDocument), 641
getRedoPr esentationName( )
AbstractUndoableEdit class, 684
UndoManager class, 688
getRed( )
Color class, 171
ColorModel class, 340
getRepr esentationClass( ), 112
getResolvePar ent( ) (AttributeSet), 587
getRGBColorComponents( ) (Color),
172
714 Index

getRGBDefault( ) (ColorModel), 340
getRGB( ), 94
Color class, 171
ColorModel class, 340
SystemColor class, 223
getRootPane( ) (RootPaneContainer),
506
getRoots( ) (FileSystemView), 552
getRoot( ) (TreeModel), 678
getRowCount( )
AbstractTableModel class, 568
TableModel interface, 577
getRowForPath( ) (JTree), 491
getRSB( ) (GlyphMetrics), 290
getScaledInstance( ), 334
ReplicateScaleFilter class, 361
getScaleInstance( ) (Af ﬁneTransfor m),
97
getScr eenResolution( ) (Toolkit), 227
getScr eenSize( ) (Toolkit), 227
getSelectedIndex( ) (Choice), 170
getSelectedItem( )
Choice class, 170
JComboBox class, 431
getSelectedObjects( ) (ItemSelectable),
203
getSelectedText( ) (TextComponent),
225
getSelectionColor( ), 597
getSelectionPaths(), (DefaultTreeSelec-
tionModel), 674
getSmallDisplayIcon( ) (AbstractColor-
ChooserPanel), 528
getSource( ), 202
AncestorEvent class, 530
AWTEvent class, 160
ChangeEvent class, 533
EventObject class, 17
HyperlinkEvent class, 536
Inter nalFrameEvent class, 538
ItemEvent class, 275
ListDataEvent class, 539
ListSelectionEvent class, 540
MenuEvent class, 541
PopupMenuEvent class, 543
TableColumnModelEvent class, 544
TableModelEvent class, 545
TextEvent class, 285
Tr eeExpansionEvent class, 546
Tr eeModelEvent class, 547
UndoableEditEvent class, 550
getStartOf fset( ), 602
Iterator class, 646
getStateChange( ) (ItemEvent), 275
getStyleSheet( ) (HTMLDocument), 641
getStyle( )
StyleContext class, 619
StyledDocument interface, 622
getSystemClipboard( ), 240
Toolkit class, 114
getSystemCustomCursor( ), 36
Cursor class, 36
getSystemEventQueue( ) (Even-
tQueue), 184
getSystemLookAndFeelClassName( )
(UIManager), 516
getTabbedSpan( ) (TabableView), 626
getTableCellRender erComponent( )
(TableCellRender er), 574
getTableHeader( ) (JTableHeader), 572
getTag( ) (HTML), 637
getTargetActions( ), 253
getTarget( ) (HTMLFrameHyper-
linkEvent), 650
getText( ), 273
Document class, 600
JTextAr ea class, 483
JTextField class, 484
TextComponent class, 225
getToIndex( ) (TableColumnMod-
elEvent), 545
getTransferable( ) (Dr opTargetEvent),
116
getTransferDataFlavors( ), 112, 115,
244
getTransferData( ), 244
DataFlavor class, 112
Transferable class, 117
getTransfor m( ), 73
getTreeCellEditorComponent( ) (Tree-
CellEditor), 677
getTreeCellRender erComponent( )
(TreeCellRender er), 678
getTreePath( ) (TreeModelEvent), 547
getT ype( )
Af ﬁneTransfor m class, 304
Cursor class, 180
DocumentEvent class, 534
GlyphMetrics class, 290
Index 715

getT ype( ) (cont’d)
GraphicsDevice class, 197
ListDataEvent class, 539
TableModelEvent class, 545
getUnderlineOf fset( ) (LineMetrics),
294
getUnderlineThickness( ) (LineMet-
rics), 294
getUndoPr esentationName( )
AbstractUndoableEdit class, 684
UndoableEdit interface, 687
UndoManager class, 688
getURL( ) (HyperlinkEvent), 536
getUserAction( ), 253
getVAdjustable( ) (Scr ollPane), 221
getValueAt( )
AbstractTableModel class, 568
TableModel interface, 577
getValueIsAdjusting( ) (ListSelection-
Event), 540
getValue( )
Action interface, 407
AdjustmentEvent class, 267
getViewAttributes( ) (StyleSheet), 654
getViewCount( ) (View), 630
getViewFactory( )
EditorKit class, 601
ViewFactory interface, 631
getView( ) (View), 630
getVisualHighlightShape( ) (TextLay-
out), 299
getVScr ollbarHeight( ) (Scr ollPane),
221
getWhen( )
InputEvent class, 272
MouseEvent class, 17
getWindingRule( ) (PathIterator), 318
getWindow( ) (WindowEvent), 286
getX( ) (MouseEvent), 17, 282
getY( ) (MouseEvent), 17, 282
get( ) (UIDefaults), 514
GIF images, 151
GlyphJustiﬁcationInfo class, 289
GlyphMetrics class, 290
GlyphVector class, 90-91, 291
grabPixels( ), 357
GradientPaint class, 69, 79-80, 192
graphical user interfaces, building, 14
GraphicAttribute class, 291
Graphics class, 64, 154, 192
attributes, 64-65
operations of, 65-66
Graphics2D class, 68-73, 94, 154,
194-195
printing and, 107
GraphicsConﬁgTemplate class, 196
GraphicsConﬁguration class, 196
GraphicsEnvir onment class, 198
GrapicsDevice class, 197
GrayFilter class, 425
GridBagConstraints class, 199
GridBagLayout class, 15, 200
GridLayout class, 201
GUIs (graphical user interfaces), build-
ing, 14
H
handleEvent( ) (Component), 127
HEIGHT attribute, <APPLET> tag
(HTML), 130
Help menus, 208
HiddenAction class, 644
hide( )
Component class, 173
FileDialog class, 185
Window class, 190
WindowEvent class, 286
Highlight interface, 605
Highlighter interface, 604
HighlightPainter interface, 605
hitTextChar( ) (TextLayout), 298
hit( ), 70
Graphics2D class, 73
HSBtoRGB( ) (Color), 171
HSPACE attribute, <APPLET> tag
(HTML), 131
HTML
AccessibleHyperlink class, 392
AccessibleHypertext interface, 393
ﬁles, applets in, 129-131
printing, 106
Swing, 26, 52-55, 633-663
HTML class, 637
HTMLDocument class, 641
HTMLEditorKit class, 646
HTMLFactory class, 647
716 Index

HTMLFrameHyperlinkEvent class, 650
HTMLReader class, 642
HTMLTextAction class, 648
HTML.UnknownTag class, 641
HTMLWriter class, 651
HyperlinkEvent class, 536
HyperlinkListener interface, 22, 537
hyperlinkUpdate( ) (HyperlinkLis-
tener), 22
I
ICC_ColorSpace class, 234
ICC (International Color Consortium),
235
ICC_Pr oﬁle class, 235
ICC_Pr oﬁleGray class, 237
ICC_Pr oﬁleRGB class, 237
Icon interface, 425
icons, Swing, 34, 425
IconUIResource class, 560
IconView class, 605
IllegalComponentStateException class,
202
IllegalPathStateException class, 315
Image class, 67, 154, 202
image processing, Java 2D, 95-96
imageComplete( ), 350
ImageConsumer interface, 350
ImageConsumer( ) methods (AreaAver-
agingScaleFilter), 334
ImageFilter class, 350
ImageGraphicAttribute class, 292
ImageIcon class, 35, 92, 425
ImageObserver class, 351
ImagePr oducer inter face, 351
images, 92, 195, 332-367
AWT, 66-68
Cr opImageFilter class, 345
Filter edImageSource class, 349
GIF, 151
Graphics class, 192
Image class, 202
ImageConsumer interface, 350
ImageFilter class, 350
ImagePr oducer inter face, 351
Java 2D, 71, 96-97
JPEG, 93, 151
MediaTracker class, 207
MemoryImageSource class, 355
(see also buffer ed images)
imageUpdate( ), 351
IndexColorModel class, 352
inherited properties, 11
initialDelay, 27
init( ) (Applet), 124, 150
InlineView class, 651
Input Context class, 329
InputEvent class, 272
InputMethodEvent class, 273
InputMethodHighlight class, 330
InputMethodListener interface, 274
InputMethodRequest class, 330
inputMethodTextChanged( ) (Input-
MethodListener), 274
InputSubset class, 331
InsertBr eakAction class, 595
insertComponent( ) (JTextPane), 486
InsertContentAction class, 596
InsertHTMLTextAction class, 648
insertHTML( ) (HTMLEditorKit), 646
insertIcon( ) (JTextPane), 486
insertNodeInto( ) (DefaultTreeModel),
673
insertSeparator( ) (JMenu), 453
insertString( )
Content interface, 584
DefaultStyledDocument class, 597
InsertTabAction class, 596
insertText( ) (TextAr ea), 224
insert( ) (JMenu), 453
Insets class, 203
InsetsUIResource class, 560
insideT imerAction class, 513
inside( ) (Polygon), 214
installUI( ) (UIResource), 567
inter faces
AdjustmentListener interface, 267
Swing, separators, 10
inter nalFrameActivated( ) (Inter nal-
FrameListener), 22
Inter nalFrameAdapter class, 537
inter nalFrameClosed( ) (Inter nal-
FrameListener), 22
inter nalFrameClosing( ) (Inter nal-
FrameListener), 22
Index 717

inter nalFrameDeactivated( ) (Inter nal-
FrameListener), 22
inter nalFrameDeiconiﬁed( ) (Inter nal-
FrameListener), 22
Inter nalFrameEvent class, 538
inter nalFrameIconiﬁed( ) (Inter nal-
FrameListener), 22
Inter nalFrameListener inter face, 22,
539
inter nalFrameOpened( ) (Inter nal-
FrameListener), 22
Inter nalFrameUI class, 561
Inter national Color Consortium (ICC),
235
Inter net Explor er
digital signatures and, 136
Java Plug-in, 132
intervalAdded( ) (ListDataListener), 22
intervalRemoved( ) (ListDataListener),
22
InvalidDnDOperationException class,
260
inverseTransfor m( ) (Af ﬁneTransfor m),
98, 304
InvocationEvent class, 274
invokeAndWait( ), 28
EventQueue class, 154
SwingUtilities class, 510
invokeLater( ), 28
EventQueue class, 154
SwingUtilities class, 510
isActionKey( ), 277
isAddedPath( ) (TreeSelectionEvent),
548
isBlock( ) (Tag), 639
isBorderOpaque( ) (Border), 521
isCancelled( ), 504
isCellEditable( )
AbstractTableModel class, 568
CellEditor interface, 412
JTable class, 479
isConsumed( ) (ItemEvent), 272
isDataFlavorSupported( ), 112, 115,
244
isDefaultButton( ) (JButton), 427
isDeﬁned( ) (AttributeSet), 587
isDescendant( ) (TreePath), 679
isDone( ) (PathIterator), 318
isDragImageSupported( ), 115
isErr orAny( ) (MediaTracker), 207
isErr orID( ) (MediaTracker), 207
isEventDispatchThr ead( ) (SwingUtili-
ties), 510
isFilled, 29
isFocusCycleRoot( ), 30
JComponent class, 63
isFocusTraversable( ) (JComponent),
62
isFr eeStanding, 29
isHiddenFile( ) (FileSystemView), 552
isHorizontal( ) (ComponentOrienta-
tion), 177
isIdentity( ) (Af ﬁneTransfor m), 304
isInherited( ) (Attribute), 635
isInPr ogress( ) (CompoundEdit), 685
isLeadingEdge( ) (TextHitInfo), 298
isLeaf( ) (DefaultTreeModel), 673
isLeftMouseButton( ) (SwingUtilities),
510
isLeftToRight( ) (ComponentOrienta-
tion), 177
isLocalDr opTarget( ) (DragSourceLis-
tener), 253
isManagingFocus( ) (JComponent), 63
isMiddleMouseButton( ) (SwingUtili-
ties), 510
isOpaque( ) (JComponent), 62
isOptimizedDrawingEnabled( ) (JCom-
ponent), 62
isPalette, 29
isPathSelected(), (DefaultTreeSelec-
tionModel), 674
isPopupTrigger( )
JPopupMenu class, 463
MouseEvent class, 215, 282
isPr eformatted( ) (Tag), 639
isRightMouseButton( ) (SwingUtilities),
510
isRollover, 29
isSelected( )
JCheckBox class, 428
JCheckBoxMenuItem class, 429
JRadioButton class, 466
isSelectionEmpty(), (DefaultTreeSelec-
tionModel), 674
isSigniﬁcant( )
CompoundEdit class, 685
UndoableEdit interface, 687
UndoManager class, 688
isTemporary( ) (FocusEvent), 271
718 Index

isValid( ) (Iterator), 646
isVisible( )
JTree class, 491
View class, 630
ItalicAction class, 625
ItemEvent class, 275
ItemListener interface, 21, 276
ItemSelectable interface, 203
itemStateChanged( ), 276
ItemListener interface, 21
Iterator class, 646
J
JAI (Java Advanced Imaging), 368
JApplet class, 13, 426
Swing, 14
JAR ﬁles, 131-132
jarsigner program, 136
Java 1.0, 3, 5, 64
cursors, 35
event model, 127-129
font names in, 66-67
fonts, 87
Java 1.1, 3, 5, 25, 64
cursors, 35
DataFlavor class, 241
event model, 17, 20
font names in, 66-67
printing, 4, 102-103
signed applets, 136
Swing and, 4
web browsers and, 132
Java 1.2, 3-4, 25, 185
cursors, 36, 180
DataFlavor class, 241
drag-and-dr op, 115
fonts, 87
printing, 103-106
graphics, 109
multipage documents, 106-109
signed applets, 136
web browsers and, 132
Java 2 platform, 3-5, 25, 64
Java 2D, 4, 68
attributes, 68-70
coordinate system, 71-73
printing, 71
Java Advanced Imaging (JAI), 368
Java Archive ﬁles (see JAR ﬁles)
Java online resources, xi
Java Plug-in, 5, 132-133
Java Virtual Machines (JVMs), transfer-
ring data between, 112
java.applet package, 150-153
java.awt package, 154-231
java.awt.color package, 232-238
java.awt.datatransfer package, 239
java.awt.dnd package, 246-261
java.awt.dnd.peerx package, 262-263
java.awt.event package, 265
java.awt.font package, 288-301
java.awt.geom package, 302-328
java.awt.im package, 329-331
java.awt.image package, 332-367
java.awt.image.r enderable package,
368-372
java.awt.peer package, 373-380
java.awt.print package, 381-387
java.beans package, 264-287
javadoc, web site, xi
javakey program, 136
javax.accessibility package, 388-398
javax.swing package, 399-518
javax.swing.border package, 519-526
javax.swing.colorchooser package,
527-529
javax.swing.event package, 530-550
javax.swing.ﬁlechooser package,
551-553
javax.swing.plaf package, 554-567
javax.swing.table package, 568-578
javax.swing.text package, 579-632
javax.swing.text.html package, 633-655
javax.swing.text.html.parser package,
656-663
javax.swing.text.rtf package, 664-665
javax.swing.tr ee package, 666-682
javax.swing.undo package, 683-689
JButton class, 9, 26, 427, 557
event handling and, 19
key events, 29
sizes, 38
JCheckBox class, 9, 428
JCheckBoxMenuItem class, 9, 429
JColorChooser class, 9, 44-45, 429, 558
JComboBox class, 9, 431, 558
Index 719

JComponent class, 9, 12, 27-28, 43, 62,
433, 558
serialization, 33
JDesktopIcon class, 447, 559
JDesktopPane class, 13, 423, 559
JDialog class, 13-14, 438
JEditorPane class, 9, 439
displaying HTML, 52-55
JFileChooser class, 9, 42-44, 440, 560
JFrame class, 13-14, 443
JInter nalFrame class, 13-14, 444, 561
isPalette, 29
JLabel class, 9, 26, 59, 448, 561
JLayer edPane class, 13, 449
JList class, 10, 406, 420-421, 451, 561
JMenu class, 10, 26, 453
JMenuBar class, 10, 12, 455, 561
JMenuItem class, 10, 26, 29, 456, 562
join styles, Java 2D, 76
JOptionPane class, 10, 40, 457, 562
JPanel class, 13-14, 461, 562
JPasswordField class, 10, 52, 462
JPEG images, 93, 151
JPopupMenu class, 10, 12, 462, 562
JPopupMenu.Separator class, 464
JPr ogressBar class, 10, 464, 563
JRadioButton class, 10, 466
JRadioButtonMenuItem class, 10, 466
JRootPane class, 13-15, 467
JScr ollBar class, 10, 469, 563
JScr ollPane class, 13, 38, 471, 563
isFr eeStanding, 29
JScr ollPane( ), 471
JSeparator class, 10, 473, 563
JSlider class, 10, 473, 564
isFilled, 29
JSplitPane class, 13, 475, 564
JTabbedPane class, 13, 26, 477, 564
JTable class, 10, 24, 50-52, 479, 565
JTableHeader class, 565, 572
JTextAr ea class, 10, 52, 483
cut-and-paste support, 113
JTextComponent class, 10, 52-55, 565,
606
JTextField class, 10, 52, 484
cut-and-paste support, 113
JTextPane class, 11, 485
JToggleButton class, 11, 487
JToolBar class, 11, 26, 488, 566
isRollover, 29
JToolT ip class, 11, 26, 489, 566
JTree class, 11, 24, 47-49, 490, 566
lineStyle, 29
JViewport class, 14, 496, 567
JViewportLayout class, 16
JVMs (Java Virtual Machines), transfer-
ring data between, 112
JWindow class, 14, 497
K
ker nel, 97
Ker nel class, 353
KeyAdapter class, 276
KeyBinding class, 608
keyboard
KeyAdapter class, 276
KeyEvent class, 276
KeyListener interface, 281
modiﬁers, 272, 277
keyboard shortcuts, Swing, 29-33
KeyEvent class, 276
KeyListener interface, 21, 281
Keymap interface, 33, 608
keymappings, Swing, 33
keyPr essed( ), 21
keyReleased( ), 21
KeySelectionManager class, 433
KeyStr oke class, 498
keyT yped( ), 21
L
Label class, 8, 204
LabelPeer class, 376
labels, 8
Swing, 9
LabelUI class, 561
LabelView class, 609
lastPageFirst( ), 216
last( ) (CardLayout), 168
layer ed panes, Swing, 13
Layer edHighlighter class, 609
LayerPainter class, 610
layout management, 12-13, 15, 17
Swing, 13, 15-16, 37-40
layout managers
BorderLayout class, 165
CardLayout class, 168
FlowLayout class, 186
720 Index

layout managers (cont’d)
GridBagLayout class, 200
GridLayout class, 201
LayoutManager interface, 204
LayoutManager2 class, 205
Swing, 410, 503, 509
layoutContainer( ) (LayoutManager),
204
LayoutManager interface, 15, 154, 204
LayoutManager2 class, 205
layouts, AWT, 12
leading space, 89
LeafElement class, 585
LightweightPeer class, 377
Line2D class, 316
LineBorder class, 34, 523
LineBorderUIResource class, 557
LineBr eakMeasur er class, 293
LineMetrics class, 293
lines, 66
AWT, 65, 164-165
Java 2D, 69, 72, 74, 76-79, 316
lineStyle, 29
lineTo( ) (GeneralPath), 75
LinkContr oller class, 649
List class, 8, 205
listboxes, AWT, 8
ListCellRender er inter face, 499
ListDataEvent class, 539
ListDataListener interface, 22, 539
listeners
ContainerListener interface, 270
FocusListener interface, 272
ListModel interface, 500
ListPainter class, 655
ListPeer class, 377
lists, Swing, 10
ListSelectionEvent class, 540
ListSelectionListener interface, 22, 540
ListSelectionModel interface, 422, 500
ListUI class, 561
list( ) (Container), 178
loadRules( ) (StyleSheet), 654
locate(), (Container), 178
look-and-feel, 24, 55, 57, 421, 501, 516
defaults, 57
(see also pluggable look-and-feel)
LookAndFeel class, 501
LookAndFeelInfo class, 516
LookupOp class, 95, 354
LookupOp( ), 339
LookupTable class, 354
lostOwnership( ), 115, 240
M
main( ) (ColorSink), 119
makeVisible( ) (JTree), 491
margins, 203
MatteBorder class, 34, 524
MatteBorderUIResource class, 557
MDI (multiple document interface),
Swing, 13
MediaTracker class, 207
MemoryImageSource class, 355
menu accelerators, Swing, 31
menu bars, 8, 10
Menu class, 8, 208
menu mnemonics, Swing, 31
menu panes, AWT, 8
MenuBar class, 8
MenuBarPeer class, 377
MenuBarUI class, 561
menuCanceled( ) (MenuListener), 23
MenuComponent class, 8, 209
MenuComponentPeer class, 377
MenuContainer class, 210
menuDeselected( ) (MenuListener), 23
menuDragMouseDragged( )
(MenuDragMouseListener),
23
menuDragMouseEnter ed( )
(MenuDragMouseListener),
23
MenuDragMouseEvent class, 541
menuDragMouseExited( ) (MenuDrag-
MouseListener), 23
MenuDragMouseListener interface, 23,
541
menuDragMouseReleased( )
(MenuDragMouseListener),
23
MenuElement interface, 502
MenuEvent class, 541
MenuItem class, 8, 210
MenuItemPeer class, 378
MenuItemUI class, 562
MenuKeyListener interface, 23, 542
Index 721

menuKeyPr essed( ) (MenuKeyLis-
tener), 23
menuKeyReleased( ) (MenuKeyLis-
tener), 23
menuKeyT yped( ) (MenuKeyListener),
23
MenuListener interface, 23, 542
MenuPeer class, 378
menus, 210
AWT, 8
CheckboxMenuItem class, 169
Choice class, 170
Menu class, 208
MenuBar class, 208
MenuShortcut class, 211
PopupMenu class, 214
separators, 208
Swing, 10, 45-47, 453, 455-456, 462,
502, 541
menuSelected( ) (MenuListener), 23
MenuSelectionManager class, 502
MenuShortcut class, 211
metaDown( ), 128
Metal look-and-feel, 55-57
MetalTheme class, 56
MIME types, 111
MinimalHTMLWriter class, 652
minimumLayoutSize( ) (LayoutMan-
ager), 204
model objects, 23-24
ModelListener class, 479
modelToView( ) (View), 630
Motif look-and-feel, 55
mouse, 281-283
MouseAdapter class, 281
mouseClicked( ) (MouseListener), 21
mouseDragged( ) (MouseMotionLis-
tener), 21
mouseEnter ed( ) (MouseListener), 21
MouseEvent class, 17, 281
MouseEventListener class, 636
mouseExited( ) (MouseListener), 21
MouseInputAdapter class, 543
MouseInputListener class, 543
MouseListener interface, 18, 21, 283
MouseMotionListener interface, 21,
283
mouseMoved( ) (MouseMotionLis-
tener), 21
mousePr essed( ) (MouseListener), 21
mouseReleased( ) (MouseListener), 21
moveDot( ) (Car et), 589
moveToBack( ) (JLayer edPane), 449
moveToFr ont( ) (JLayer edPane), 449
moveTo( ) (GeneralPath), 75, 314
move( ) (Point), 213
multipage documents, printing,
106-109
MultiPixelPackedSampleModel class,
355
multiple document interface (MDI), 13
MultipleMaster interface, 294
multiplexing look-and-feel, 57
MutableAttributeSet interface, 610
MutableComboBoxModel interface,
503
MutableTreeNode interface, 677
N
NAME attribute, <APPLET> tag
(HTML), 131
NAME attribute, <PARAM> tag
(HTML), 131
NamedStyle class, 621
Netscape Internet Foundation Classes,
3
Netscape Navigator
digital signatures and, 136
Java Plug-in, 132
nextFocusableComponent, 30
nextLayout( ) (LineBr eakMeasur er),
293
next( )
CardLayout class, 168
Iterator class, 646
NodeDimensions class, 668
NoninvertibleTransfor mException
class, 318
O
OBJECT attribute, <APPLET> tag
(HTML), 130
ObjectInputStr eam class, 33
ObjectOutputStr eam class, 33
ObjectView class, 653
OpenT ype inter face, 294
Option class, 653
722 Index

OptionPaneUI class, 562
origin, 65, 71
OverlayLayout, 503
P
packages
java.applet package, 150-153
java.awt, 154-231
java.awt.color, 232-238
java.awt.datatransfer, 239
java.awt.dnd, 246-261
java.awt.dnd.peerx, 262-263
java.awt.event, 265
java.awt.font, 288-301
java.awt.geom, 302-328
java.awt.im, 329-331
java.awt.image, 332-367
java.awt.image.r enderable, 368-372
java.awt.peer, 373-380
java.awt.print, 381-387
java.beans, 264-287
javax.accessibility, 388-398
javax.swing, 399-518
javax.swing.border, 519-526
javax.swing.colorchooser, 527-529
javax.swing.event, 530-550
javax.swing.ﬁlechooser, 551-553
javax.swing.plag, 554-567
javax.swing.table, 568-578
javax.swing.text, 579-632
javax.swing.text.html, 633-655
javax.swing.text.html.parser,
656-663
javax.swing.text.rtf, 664-665
javax.swing.tr ee, 666-682
javax.swing.undo, 683-689
PackedColorModel class, 356
pack( )
Dialog class, 181
Window class, 190, 230
Pageable interface, 103, 382-383
pageDialog( ) (PrinterJob), 387
PageFor mat class, 103, 383
Paint interface, 79-80, 154, 212
paintBorder( )
AbstractBorder class, 520
Border interface, 521
paintComponent( ), 61
PaintEvent class, 284
paintIcon( ) (Icon), 35
paintLayer edHighlights( ) (Layer ed-
Highlighter), 609
paint( ), 60, 103
Applet class, 125, 151
Car et inter face, 589
Component class, 124
HighlightPainter interface, 605
PaintEvent class, 284
View class, 630
Panel class, 212
AWT, 12
PanelPeer class, 378
PanelUI class, 562
panes
editor, 9
layer ed, 13
menu, 8
Swing, 439, 457, 475, 485
tabbed, 13
Paper class, 384
ParagraphConstants class, 619
ParagraphView class, 611, 653
Parser class, 649, 662
ParserDelegator class, 662
parse( )
DocumentParser class, 658
HTMLEditorKit.Parser class, 649
Parser class, 662
passwords
Swing, 10, 52, 462
tur ning of f echo for, 226
PasteAction class, 596
pastecolor( ) (ColorSink), 119
PathIterator interface, 318
paths (see shapes, Java 2D)
peekEvent( ) (EventQueue), 184
per missions, AWT, 164
PixelGrabber class, 357
PixelInterleavedSampleModel class,
357
PlainDocument class, 612
PlainView class, 613
pluggable look-and-feel, 24, 55-58,
423
custom components and, 61
Swing, 554-567
Point class, 213
Point2D class, 319
Polygon class, 214
Index 723

polygons, Java 2D, 74
pop-up menus, 215
AWT, 8
Swing, 10, 456, 462, 543
cr eating, 45
PopUpMenu class, 8, 214
popupMenuCanceled( ) (Popup-
MenuListener), 23
PopupMenuEvent class, 543
PopupMenuListener interface, 23, 544
PopupMenuPeer class, 378
PopupMenuUI class, 562
popupMenuWillBecomeInvisible( )
(PopupMenuListener), 23
popupMenuWillBecomeVisible( )
(PopupMenuListener), 23
Position interface, 613
postEdit( ) (UndoableEditSupport), 688
postEvent( ), 185
pr eferr edLayoutSize( ) (LayoutMan-
ager), 204
pr evious( ) (CardLayout), 168
Printable interface, 103, 107, 384-385
PrintableComponent class, 105
printDialog( ) (PrinterJob), 104, 387
PrinterException class, 386
PrinterIOException class, 386
PrinterJob class, 103, 386-387
PrintGraphics interface, 102, 215
printing, 4, 196
Java 1.1, 102-103
Java 1.2, 103-106, 381-387
graphics, 109
multipage documents, 106-109
Java 2D, 71
PrintGraphics interface, 215
PrintJob class, 215
PrintJob class, 215
print( )
Component class, 124
Printable interface, 107
PrintableComponent class, 105
PrinterJob class, 104-105, 387
pr ocess . . . Event() methods, 20
pr ogress bars, Swing, 10, 464, 504
Pr ogressBarUI class, 563
Pr ogressMonitor class, 504
Pr ogressMonitorInputStr eam class, 504
pr operties, 11-12
client, 28-29
of custom components, 59-60
Pr opertyChangeEvent class, 60
Pr opertyChangeListener inter face, 23
pr opertyChange( ) (Pr opertyChange-
Listener), 23
pull-down menus
AWT, 8
Menu class, 208
Swing, 10, 45, 456
push buttons
AWT, 8
Swing, 9, 38, 427
putClientPr operty( ) (JComponent), 28,
433
putPr operty( ) (Document), 600
putValue( ) (Action), 407
put( )
RenderingHints class, 218
UIDefaults class, 514
Q
QuadCurve2D class, 321
quadTo( ) (GeneralPath), 75
R
radio buttons, 169
AWT, 8
Swing, 10, 466
Raster class, 358
RasterOp class, 360
read( )
ChangedCharSetException class,
590
DTD class, 658
EditorKit class, 601
HTMLEditorKit class, 646
JEditorPane class, 52
RTFEditorKit class, 664
Rectangle class, 216
Rectangle2D class, 323
rectangles, Java 2D, 74
RectangularShape class, 326
redo( )
AbstractUndoableEdit class, 684
CompoundEdit class, 685
724 Index

redo( ) (cont’d)
UndoableEdit interface, 687
UndoManager class, 688
registerComponent( ) (ToolT ipMan-
ager), 512
registerEditorKitForContentT ype( )
(JEditorPane), 439
registerKeyboardAction( ), 32
JComponent class, 499
registerTag( )
HTMLReader class, 642
TagAction class, 645
rejectDr op( ), 117
removeItemListener( ) (ItemSe-
lectable), 203
removeLayoutComponent( ) (Layout-
Manager), 204
removeNodeFr omParent( ) (Default-
Tr eeModel), 673
removeSelectionPaths(), (Default-
Tr eeSelectionModel), 674
removeStyle( ) (StyleContext), 619
removeTableModelListener( ) (Table-
Model), 577
removeUndoableEditListener( )
(UndoableEditSupport), 688
remove( )
AWTEventMulticaster class, 161
Container class, 178
Document interface, 600
EventListenerList class, 536
JMenuBar class, 455
RenderableImage interface, 370
RenderableImageOp class, 371
RenderableImagePr oducer class, 371
RenderContext class, 372
Render edImage class, 360
Render edImageFactory inter face, 372
Render er inter face, 505
rendering hints, 194
Java 2D, 70, 86, 218
text, 88-89
RenderingHints class, 86, 88, 218
RepaintManager class, 505
replaceEdit( )
CompoundEdit class, 685
UndoableEdit interface, 687
UndoManager class, 688
replaceText( ) (TextAr ea), 224
replace( ) (AbstractUndoableEdit), 684
ReplicateScaleFilter class, 361
requestFocusEnabled, 30
requestFocus( ), 30
RescaleOp class, 96, 362
RGBImageFilter class, 362
RGBtoHSB( ) (Color), 171
Rich Text Format (RTF), 52-55,
664-665
RootLayout class, 469
RootPaneContainer interface, 14, 506
rotate( )
Af ﬁneTransfor m class, 70, 97
Graphics2D class, 72
RoundRectangle2D class, 327
RowMapper interface, 677
RTF (Rich Text Format), 52-55,
664-665
RTFEditorKit class, 664
RunElement class, 646
run( ), 28
S
SampleModel class, 363
scale( )
Af ﬁneTransfor m class, 70, 97
Graphics2D class, 72
Scr ollable inter face, 506
Scr ollBar class, 8, 219, 472
Scr ollbarPeer class, 378
Scr ollBarUI class, 563
scr olling
AWT, 8, 12
drag-and-dr op, 246
Scr ollBar class, 219
Scr ollPane class, 220
Swing, 10, 13, 469, 471, 506
Scr ollPane class, 12, 220
Scr ollPaneConstants inter face, 507
Scr ollPaneLayout class, 16, 507
Scr ollPanePeer class, 379
Scr ollPaneUI class, 563
scr ollPathToVisible( ) (JTree), 491
SectionElement class, 600
security
applets, 134-136
Swing, 10, 52, 462
Segment class, 614
Index 725

selectionForKey( ) (KeySelectionMan-
ager), 433
Separator class, 489
SeparatorUI class, 563
serialization
applets and, 130
Swing, 33
setAccelerator( ), 32
JMenuItem class, 499
setAccessory( ) (JComponent), 43
setActionCommand( )
AbstractButton class, 29
ActionEvent class, 266
Button class, 167
JTextField class, 484
MenuItem class, 210
setAlignmentX( ), 16, 503
setAlignmentY( ), 16, 503
setAlignment( ) (Label), 204
setBackgr ound( )
Component class, 173
Graphics2D class, 194
setBase( ) (HTMLDocument), 641
setBlinkRate( ) (Car et), 589
setCar etPosition( ) (JTextAr ea), 483
setCellRender er( )
JList class, 451
JTree class, 491
setCharacterAttributes( )
JTextPane class, 486
StyledDocument interface, 622
setCheckboxGr oup( ) (Checkbox-
Gr oup), 169
setChoosableFileFilters( ), 43
setChooserPanels( ) (JColorChooser),
430
setClip( ) (Graphics2D), 194
setColumnHeaderView( ) (JScr oll-
Pane), 471
setColumns( )
JTextAr ea class, 483
JTextField class, 484
setComposite( )
Graphics2D, 158
Graphics2D class, 194
setConstraints( ) (GridBagLayout), 200
setContents( ), 114, 239, 243
setContentT ype( ) (JEditorPane), 439
setCor ner( ) (JScr ollPane), 471
setCurr entFocusManager( ), 31
setCurr entManager( ) (FocusManager),
424
setCurr entTheme( ), 57
setCursor( )
Frame class, 190
JFrame class, 443
setDefaultButton( ) (JButton), 427
setDefaultCloseOperation( )
JDialog class, 438
JFrame class, 443
WindowConstants interface, 517
setDefaultEditor( ) (JTable), 479
setDefaultLightWeightPopupEnabled( )
(JPopupMenu), 463
setDefaultRender er( ) (JTable), 479
setDesktopIcon( ) (JInter nalFrame),
445
setDisabledIconAt( ) methods
(JTabbedPane), 477
setDot( ) (Car et), 589
setDoubleBuf fered( ), 37
setEchoCharacter( ) (TextField), 226
setEchoChar( ) (JPasswordField), 462
setEditable( )
JTextAr ea class, 483
JTree class, 490
TextComponent class, 225
setEditorKit( ) (JEditorPane), 439
setElem( ) (DataBuf ferShort), 347
setEnabledAt( ) (JTabbedPane), 477
setEnabled( ) (Action), 407
setFileFilter( ), 43
FileFilter class, 552
JFileChooser class, 441
setFileView( ), 553
setFloatable( ) (JToolBar), 488
setFont( )
Component class, 173
Graphics2D class, 194
JTextField class, 484
MenuComponent class, 209
setFor eground( ) (Component), 173
setFrameFr omCenter( ), 312
setFrameIcon( ) (JInter nalFrame), 445
setGlyphPosition( ), 91
setGlyphTransfor m( ), 91
setHelpMenu( ), 208
JMenuBar class, 455
setHints( ), 350
726 Index

setIconiﬁable( ) (JInter nalFrame), 445
setIconImage( ) (Frame), 190
setIcon( ) (JToggleButton), 487
setJMenuBar( ), 15
JApplet class, 426
JDialog class, 438
JFrame class, 443
JMenuBar class, 455
JRootPane class, 467
setJobName( ) (PrinterJob), 387
setKeymap( ), 33
setLabelFor( ) (JLabel), 59
setLargeModel( ) (JTree), 491
setLayer( ) (JLayer edPane), 449
setLayout( )
Container class, 178
Dialog class, 181
JPanel class, 461
setLeftComponent( ) (JSplitPane), 475
setLightWeightPopupEnabled( ) (JPop-
upMenu), 463
setLimit( ) (UndoManager), 689
setLocation( ) (Point), 213
setLookAndFeel( ) (UIManager), 55-56
setMaximizable( ) (JInter nalFrame),
445
setMaximumSize( ), 38
setMaximum( ) (JInter nalFrame), 445
setMenuBar( ) (Frame), 190
setMinimumSize( ), 38
setMnemonic( ) (AbstractButton), 31
setModel( ) (JTree), 47
setNote( ) (Pr ogressMonitor), 504
setOpaque( ) (JComponent), 62
setPageable( ), 104
PrinterJob class, 387
setPage( )
Book class, 382
JEditorPane class, 52, 439
setPaint( ), 69
Graphics2D class, 79, 194
setParagraphAttributes( )
JTextPane class, 486
StyledDocument interface, 622
setPosition( ) (JLayer edPane), 449
setPr eferr edSize( ), 38
setPr eservesUnknownTags( ) (HTML-
Document), 641
setPr eviewPanel( ), 45
JColorChooser class, 430
setPrintable( ), 104
PrinterJob class, 387
setPr ogress( ) (Pr ogressMonitor), 504
setRenderingHints( ), 70
Graphics2D class, 194
RenderingHints class, 218
setRenderingHint( ), 70
setResizable( )
JFrame class, 443
JInter nalFrame class, 445
setRGB( ), 94
setRightComponent( ) (JSplitPane), 475
setRowHeaderView( ) (JScr ollPane),
471
setRows( ) (JTextAr ea), 483
setScr ollPosition( ) (Scr ollPane), 221
setSelectedComponent( ) methods
(JTabbedPane), 477
setSelectedIcon( ) (JToggleButton), 487
setSelectedIndex( )
JComboBox class, 431
JTabbedPane class, 477
setSelectedItem( ) (JComboBox), 431
setSelected( )
JCheckBox class, 428
JCheckBoxMenuItem class, 429
setSelectionModel( )
JList class, 451
JTree class, 490
setSelectionMode( )
DefaultTreeSelectionModel class,
674
JTree class, 490
setSelectionPaths(), (DefaultTreeSelec-
tionModel), 674
setShortcut( ) (MenuShortcut), 211
setSize( ) (Scr ollPane), 221
setStr oke( ), 69
Graphics2D class, 164, 194, 222
setStyleSheet( ) (HTMLEditorKit), 646
setText( )
JEditorPane class, 52
JTextAr ea class, 483
JTextField class, 484
setT itle( )
Frame class, 190
JFrame class, 443
JInter nalFrame class, 445
Index 727

setTokenThr eshold( ) (HTMLDocu-
ment), 641
setToolT ipText( ), 27
JToolT ip class, 489
ToolT ipManager class, 512
setToRotation( ) (Af ﬁneTransfor m), 98
setToScale( ) (Af ﬁneTransfor m), 98
setToShear( ) (Af ﬁneTransfor m), 98
setTransfor m( ), 73
Af ﬁneTransfor m class, 70
Graphics2D class, 194
setValueAt( )
AbstractTableModel class, 568
TableModel interface, 577
setValues( ) (Scr ollbar), 219
setValue( )
JOptionPane class, 458
Render er inter face, 505
setVisible( ) (JInter nalFrame), 445
Shape interface, 73, 154, 221
ShapeGraphicAttribute class, 296
shapes, 194, 222
AWT, 65
Java 2D, 70, 73-76, 302-328
shear( )
Af ﬁneTransfor m class, 70, 97
Graphics2D class, 72-73
shiftDown( ), 128
ShortLookupTable class, 364
shouldSelectCell( ) (CellEditor), 412
showConﬁr mDialog( ), 40-41
JOptionPane class, 458
showDialog( ), 44
JColorChooser class, 429
showDocument( ), 125, 152
showInputDialog( ), 40, 42
JOptionPane class, 458
showInter nalConﬁrmDialog( ), 41
JOptionPane class, 458
showInter nalDialog( ), 40
showInter nalInputDialog( ), 42
JOptionPane class, 458
showInter nalMessageDialog( ) (JOp-
tionPane), 457
showInter nalOptionDialog( ), 41
JOptionPane class, 458
showMessageDialog( ), 40
JOptionPane class, 457-458
showOpenDialog( ), 42
FileSelectionMode, 43
JFileChooser class, 440
showOptionDialog( ), 41
JOptionPane class, 458
showSaveDialog( ), 42
curr entDir ectory, 43
JFileChooser class, 440
showStatus( ), 152
Applet class, 125, 151
show( )
CardLayout class, 168
Component class, 173
Dialog class, 181
FileDialog class, 185
JPopupMenu class, 462
PopupMenu class, 214
Window class, 190, 230
SimpleAttributeSet class, 614
SinglePixelPackedSampleModel class,
365
SingleSelectionModel interface, 423,
508
SizeRequir ements class, 509
slider controls, Swing, 10
SliderUI class, 564
SmallAttributeSet class, 622
SoftBevelBorder, 34
Solaris platform, Java support for, 132
SplitPaneUI class, 564
startDrag( ), 115
DragGestur eEvent class, 248-249
start( ) (Applet), 124, 151
stateChanged( ) (ChangeListener), 22
StateEdit class, 686
StateEditable interface, 686
statusAll( ) (MediaTracker), 207
statusID( ) (MediaTracker), 207
status( ) (PixelGrabber), 357
stopCellEditing( ) (CellEditor), 412
stop( ) (Applet), 124, 151
StringContent class, 615
StringSelection class, 112, 239, 243-244
stringWidth( ), 67
Str oke inter face, 76, 78, 154, 222
str okes, Java 2D, 78-79
Style interface, 616
728 Index

StyleConstants class, 616
StyleContext class, 619
StyledDocument interface, 579, 622
StyledEditorKit class, 623
StyledTextAction class, 625
StyleSheet class, 654
Swing, 3, 5, 399-518
accessibility, 58-59, 62
borders, 29, 34
components, 8-11, 23-24
custom, 59-63
sizes of, 38
containers, 13-14
focus, 30
cursors, 35-36
dialog boxes, 40-42
double buffering, 37
event handling, 61
event listeners, 22-23, 27, 61
events, 17-23
example, creating and displaying a
GUI, 6-7
HTML-for matted text in, 26, 52
icons, 34
keyboard shortcuts, 29-33
keymappings, 33
layout managers, 15-16
menu accelerators, 31
menu mnemonics, 31
pr operties
client, 28-29
serialization, 33
thr eads, 28
versions, 25-26
SwingPr opertyChangeSupport class,
544
SwingUtilities class, 510
sync( ) (Toolkit), 227
SystemColor class, 66, 171, 223
SystemFlavorMap class, 243
T
TabableView interface, 626
tabbed panes, Swing, 13
TabbedPaneUI class, 564
TabExpander interface, 626
TableCell class, 627
TableCellEditor interface, 574
TableCellRender er inter face, 574
TableColumn class, 575
TableColumnModel class, 576
TableColumnModelEvent class, 544
TableColumnModelListener interface,
545
TableHeaderUI class, 565
TableModel interface, 50-52, 577
JTable component, 24
TableModelEvent class, 545
TableModelListener interface, 546
TableRow class, 627
tables
displaying, 50-52
Swing, 10, 479, 568-578
TableUI class, 565
TableView class, 626
TabSet class, 628
TabStop class, 628
Tag class, 639
TagAction class, 645
TagElement class, 663
target event, 127
text, 225
AWT, 66
highlighting, 330
Java 2D, 71
rendering hints, 88-91
Label class, 204
Swing, 483-484, 606
displaying, 10
editing, 33
HTML, 633-663
HTML-for matted, 26, 52
RTF, 664-665
TextAr ea class, 224
TextComponent class, 225
TextEvent class, 284
TextField class, 226
TextLayout class, 298
TextListener interface, 285
text art with font glyphs, Java 2D, 91
TextAction class, 629
TextAr ea class, 8
TextAr eaPeer class, 379
TextAttribute class, 296
TextComponent class, 8, 225
TextComponentPeer class, 379
TextEvent class, 284
TextField class, 8, 226
TextFieldPeer class, 379
Index 729

TextHitInfo class, 297
TextLayout class, 91, 298
TextLayout( ) (LineBr eakMeasur er),
293
TextLineMetrics class, 300
TextListener interface, 21, 285
TextUI class, 565
Textur ePaint class, 69, 79, 227
textValueChanged( ) (TextListener), 21
thr eads, event dispatch, 28
TileObserver interface, 365
Timer class, 27, 511
timers, Swing, 27
TitledBorder class, 34, 525
TitledBorderUIResource class, 557
toBack( )
JInter nalFrame class, 445
Window class, 230
toDisplayString( )
Accessibility class, 396
AccessibleBundle class, 390
toFr ont( )
JInter nalFrame class, 445
Window class, 230
toggle buttons
AWT, 8
Swing, 10-11, 487
ToggleButtonModel class, 487
toolbars, Swing, 11
ToolBarUI class, 566
Toolkit class, 36, 227
ToolT ipManager class, 27, 512
tooltips
Swing, 11, 27, 489, 512
accessibility and, 59
toolT ipText property (JComponent),
27
ToolT ipUI class, 566
tostring( )
DefaultTableCellRender er class, 570
toString( )
Attribute class, 635
Transferable interface, 112-114, 239,
244
TransferableColor class, 117
TransferablePr oxy class, 257
transferring data, 112-114
(see also cut-and-paste and drag-
and-dr op)
transfor mations
Java 2D, 70, 72, 95, 97-100, 302-304
Transfor mAttribute class, 301
transfor m( )
Af ﬁneTransfor m class, 98
Graphics2D class, 73
translate( )
Af ﬁneTransfor m class, 70, 97
Graphics2D class, 72
Point class, 213
Transpar ency inter face, 229
tr ee structur es, Swing, 11
Tr eeCellEditor interface, 677
Tr eeCellRender er inter face, 678
tr eeCollapsed( ) (Tr eeExpansionLis-
tener), 23
tr eeExpanded( ) (Tr eeExpansionLis-
tener), 23
Tr eeExpansionEvent class, 546
Tr eeExpansionListener interface, 23,
547, 549
Tr eeModel interface, 47-49, 678
JTree component, 24
Tr eeModelEvent class, 547
Tr eeModelHandler class, 495
Tr eeModelListener interface, 548
Tr eeNode interface, 679
Tr eePath class, 679
Tr eeSelectionEvent class, 548
Tr eeSelectionListener interface, 23, 549
Tr eeSelectionModel interface, 680
Tr eeSelectionRedir ector class, 496
Tr eeUI class, 566
tr eeWillCollapse( ), 23
Tr eeWillExpandListener interface, 23,
549
tr eeWillExpand( ), 23
U
UI delegate objects, 23
custom components and, 61
UIDefaults class, 514
UIDefaults.LazyValue interface, 515
UIManager class, 55, 515
UIResource interface, 57, 421, 508,
567, 570
UnderlineAction class, 626
UndoableEdit interface, 687
730 Index

UndoableEditEvent class, 550
UndoableEditListener interface, 550
UndoableEditSupport class, 688
UndoManager class, 688
undo( )
AbstractUndoableEdit class, 684
CompoundEdit class, 685
StateEdit class, 686
UndoableEdit interface, 687
UndoManager class, 688
uninstallUI( ) (UIResource), 567
unr egisterComponent( ) (ToolT ipMan-
ager), 512
UnsupportedFlavorException class,
244
UnsupportedLookAndFeelException
class, 517
updateChooser( ) (AbstractColor-
ChooserPanel), 528
updateComponentTreeUI( )
(SwingUtilities), 510
update( ) (PaintEvent), 284
URLs, loading images from, 68
user space, 72
Utilities class, 629
V
validatePage( ) (PrinterJob), 387
VALUE attribute, <PARAM> tag
(HTML), 131
valueChanged( ) (TreeSelectionLis-
tener), 23
valueForPathChanged( ) (TreeModel),
678
VariableHeightLayoutCache class, 681
VetoableChangeListener interface, 23
vetoableChange( ), 23
View class, 630
ViewFactory interface, 631
ViewListener class, 497
ViewportUI class, 567
viewToModel( ) (View), 630
VSPACE attribute, <APPLET> tag
(HTML), 131
W
waitForAll( ), 68
waitForID( ) (MediaTracker), 207
web browsers, writing applets for, 3
web sites
examples in this book, xi
ICC Proﬁle Format Speciﬁcation,
235
Java information, xi
Java Plug-in, 133
widgets (see components)
WIDTH attribute, <APPLET> tag
(HTML), 130
Window class, 190, 230
AWT, 13
windowActivated( ), 21
WindowAdapter class, 285
windowClosed( ), 21
windowClosing( ), 21
WindowConstants interface, 517
windowDeactivated( ), 21
windowDeiconiﬁed( ), 21
WindowEvent class, 286
windowIconiﬁed( ), 21
WindowListener interface, 21, 287
windowOpened( ), 21
WindowPeer class, 380
windows, 190, 230, 285-287
AWT, 12-13
Swing, 13-14, 443, 445, 497, 517
Windows look-and-feel, 55
Windows platform
Java support for, 132
StringSelection class and, 113
WrappedPlainView class, 632
WritableRaster class, 366
WritableRender edImage class, 366
write( ), 586, 601, 646, 664
Index 731


About the Author
David Flanagan is the author of the bestselling Java in a Nutshell. When
David isn’t busy writing about Java, he is a consulting computer program-
mer, user interface designer, and trainer. His other books with O’Reilly
include JavaScript: The Definitive Guide, Netscape IFC in a Nutshell, X
Toolkit Intrinsics Reference Manual, and Motif Tools: Streamlined GUI
Design and Programming with the Xmt Library. David has a degree in
computer science and engineering from the Massachusetts Institute of
Technology.
Colophon
Our look is the result of reader comments, our own experimentation, and
feedback from distribution channels. Distinctive covers complement our dis-
tinctive approach to technical topics, breathing personality and life into
potentially dry subjects.
The animal appearing on the cover of Java Foundation Classes in a Nutshell
is a Florida panther (Felis concolor coryi ), one of the rarest mammals on the
globe.
These large cats feature a long slender tail, and are anywhere from pale to
dark brown on the top of their bodies, and white to tan on the underside.
Their ears, nose, and tip of their tail are almost black. Males range from 100–
150 pounds and are seven feet long, while females range from 50–100
pounds and are six feet long. A female can produce one to four kittens every
two years, and they become fertile just over the age of two.
Florida panthers used to be found in several southeastern states in the U.S.,
but urbanization and agriculture have caused their habitat to drastically
shrink to the point where these animals can now be found only in Florida.
They require some forestation and underbrush, for hunting and nesting,
though they can be found in swamplands, as well. They prey primarily on
deer, wild hogs, raccoons, and birds.
Florida panthers are highly endangered, with reports of only fifty remaining
in the world. The biggest threat is loss of habitat. A few organizations are
working to keep this animal from becoming extinct. There is a Florida Pan-
ther National Wildlife Refuge in the Big Cypress Watershed on which some
female panthers have given birth to and raised their kittens.
Nicole Arigo was the production editor for Java Foundation Classes in a
Nutshell. Nancy Crumpton provided production services and wrote the
index. Nicole Arigo and Jane Ellin provided quality control.

Edie Freedman designed the cover of this book, using an original drawing
by Lorrie LeJeune. Kathleen Wilson produced the cover layout with Quark
XPress 3.3 using Adobe’s ITC Garamond font.
Alicia Cech designed the interior layout based on a series design by Nancy
Priest. The text was written in DocBook SGML with extensions developed
by Chris Maden and David Flanagan for Java code; the design was imple-
mented in gtroff by Lenny Muellner. Interior fonts are Adobe ITC Garamond
and Adobe ITC Franklin Gothic. The illustrations that appear in the book
were produced by Robert Romano and Rhon Porter using Macromedia Free-
Hand 8 and Adobe Photoshop 5. This colophon was written by Nicole
Arigo.

To order: 800-998-9938 • order@oreilly.com • www.oreilly.com
Online editions of most O’Reilly titles are available by subscription at safari.oreilly.com
Also available at most retail and online bookstores.
Other Titles Available from O’Reilly
Java in a Nutshell,4th Edition
By David Flanagan
4th Edition March 2002
992 pages, ISBN 0-596-00283-1
This bestselling quick reference
contains an accelerated introduc-
tion to the Java programming
language and its key APIs, so sea-
soned programmers can start
writing Java code right away. The fourth edition of
Java in a Nutshell covers the new Java 1.4 beta edi-
tion, which contains significant changes from the
1.3 version.
JXTA in a Nutshell 
By Scott Oaks, Bernard Traversat 
& Li Gong
1st Edition September 2002
416 pages, ISBN 0-596-00236-X
O’Reilly’s pioneering reference is
the first and last word on this
powerful distributed computing
technology. JXTA in a Nutshell
delivers all the information you
need to get started, including an overview of P2P
distributed computing, an explanation of the JXTA
Project’s new platform, and ways that developers
can become a part of the development effort. JXTA
in a Nutshell introduces major concepts in a hands-
on way by explaining them in context to the shell,
and contains a complete reference to the JXTA
application bindings. Also included is the full JXTA
protocol specification. The book covers important
topics such as security, and how the JXTA technolo-
gy fits into the standard Java classes.
Java In a Nutshell Quick References
Java Enterprise in a Nutshell,
2nd Edition
By David Flanagan, Jim Farley &
William Crawford
2nd Edition April 2002
992 pages, ISBN 0-596-00152-5
Completely revised and updated
to cover the new 2.0 version of
Sun Microsystems Java Enter-
prise Edition software, Java Enterprise in a Nutshell
2nd edition covers the RMI, Java IDL, JDBC, JNDI,
Java Servlet, and Enterprise JavaBeans APIs, with a
fast-paced tutorial and compact reference material
on each technology.
J2ME in a Nutshell
By Kim Topley
1st Edition, March 2002
468 pages, ISBN 0-596-00253-X
O’Reilly’s J2ME in a Nutshell is
as definitive a reference to the
heart of the J2ME platform as
the classic Java in a Nutshell is
for the Standard Java platform.
Its solid introduction to J2ME covers the essential
APIs for different types of devices and deployments;
the profiles (specifications of the minimum sets of
APIs useful for a set-top box, wireless phone, PDA,
or other device); and the Java virtual machine
functions that support those APIs. The meat of the
book is its classic O’Reilly-style quick reference to
all the core Micro Edition classes.
Java Examples in a Nutshell,
2nd Edition
By David Flanagan
2nd Edition September 2000
584 pages, ISBN 0-596-00039-1
In Java Examples in a Nutshell,
the author of Java in a Nutshell
has created an entire book of
example programs that not only
serve as great learning tools, but can also be modi-
fied for individual use. The second edition of this
best-selling book covers Java 1.3, and includes new
chapters on JSP and servlets, XML, Swing, and Java
2D. This is the book for those who learn best “by
example.”

To order: 800-998-9938 • order@oreilly.com • www.oreilly.com
Online editions of most O’Reilly titles are available by subscription at safari.oreilly.com
Also available at most retail and online bookstores.
Java
Java Servlet Programming,
2nd Edition
By Jason Hunter with 
William Crawford
2nd Edition April 2001
780 pages, ISBN 0-596-00040-5
The second edition of this popu-
lar book has been completely
updated to add the new features of the Java Servlet
API Version 2.2, and new chapters on servlet secu-
rity and advanced communication. In addition to
complete coverage of the 2.2 specification, we have
included bonus material on the new 2.3 version of
the specification.
Java & XML,2nd Edition
By Brett McLaughlin
2nd Edition September 2001
528 pages, ISBN 0-596-000197-5
New chapters on Advanced SAX,
Advanced DOM, SOAP, and data
binding, as well as new examples
throughout, bring the second
edition of Java & XML thoroughly up to date.
Except for a concise introduction to XML basics,
the book focuses entirely on using XML from Java
applications. It’s a worthy companion for Java
developers working with XML or involved in mes-
saging, web services, or the new peer-to-peer move-
ment.
JavaServer Pages,2nd Edition
By Hans Bergsten
2nd Edition August 2002
712 pages, ISBN 0-596-00317-X
Filled with useful examples and
the depth, clarity, and attention
to detail that made the first edi-
tion so popular with web devel-
opers, JavaServer Pages, 2nd Edition is completely
revised and updated to cover the substantial
changes in the 1.2 version of the JSP specifications,
and includes coverage of the new JSTL Tag
libraries—an eagerly anticipated standard set of
JSP elements for the tasks needed in most JSP
applications, as well as thorough coverage of Cus-
tom Tag Libraries.
Enterprise JavaBeans,3rd Edition
By Richard Monson-Haefel
3rd Edition September 2001
592 pages, ISBN 0-596-00226-2
Enterprise JavaBeans has been
thoroughly updated for the new
EJB Specification. Important
changes in Version 2.0 include a
completely new CMP (container-managed persis-
tence) model that allows for much more complex
business function modeling; local interfaces that
will significantly improve performance of EJB
applications; and the “message driven bean,” an
entirely new kind of Java bean based on asynchro-
nous messaging and the Java Message Service.
Java and XSLT 
By Eric M. Burke
1st Edition September 2001
528 pages, ISBN 0-596-00143-6
Learn how to use XSL transfor-
mations in Java programs rang-
ing from stand-alone applications
to servlets. Java and XSLT intro-
duces XSLT and then shows you how to apply
transformations in real-world situations, such as
developing a discussion forum, transforming docu-
ments from one form to another, and generating
content for wireless devices.
Java Message Service
By Richard Monson-Haefel & 
David Chappell
1st Edition December 2000
238 pages, ISBN 0-596-00068-5
This book is a thorough intro-
duction to Java Message Service
(JMS) from Sun Microsystems. It
shows how to build applications using the point-
to-point and publish-and-subscribe models; use
features like transactions and durable subscriptions
to make applications reliable; and use messaging
within Enterprise JavaBeans. It also introduces a
new EJB type, the MessageDrivenBean, that is part
of EJB 2.0, and discusses integration of messaging
into J2EE.

To order: 800-998-9938 • order@oreilly.com • www.oreilly.com
Online editions of most O’Reilly titles are available by subscription at safari.oreilly.com
Also available at most retail and online bookstores.
Java
Java Performance Tuning,2nd Edition
By Jack Shirazi
2nd Edition January 2003 (est.)
600 pages (est.), ISBN 0-596-00015-4
Significantly revised and expand-
ed, this second edition not only
covers Java 1.4, but adds new cov-
erage of JDBC, NIO, Servlets,
EJB and JavaServer Pages. The book remains a
valuable resource for teaching developers how to
create a tuning strategy, how to use profiling tools
to understand a program’s behavior, and how to
avoid performance penalties from inefficient code,
making them more efficient and effective. The
result is code that’s robust, maintainable and fast!
Java Security,2nd Edition
By Scott Oaks
2nd Edition May 2001
618 pages, ISBN 0-596-00157-6
The second edition focuses on
the platform features of Java that
provide security—the class
loader, bytecode verifier, and
security manager—and recent additions to Java
that enhance this security model: digital signa-
tures, security providers, and the access controller.
The book covers in depth the security model of
Java 2, version 1.3, including the two new security
APIs: JAAS and JSSE.
Database Programming with JDBC
and Java,2nd Edition
By George Reese
2nd Edition August 2000
352 pages, ISBN 1-56592-616-1
This book describes the standard
Java interfaces that make portable
object-oriented access to relational
databases possible, and offers a robust model for
writing applications that are easy to maintain. The
second edition has been completely updated for
JDBC 2.0, and includes reference listings for JDBC
and the most important RMI classes. The book
begins with a quick overview of SQL for developers
who may be asked to handle a database for the
first time, and goes on to explain how to issue data-
base queries and updates through SQL and JDBC.
Java Network Programming,
2nd Edition
By Elliotte Rusty Harold
2nd Edition August 2000
760 pages, ISBN 1-56592-870-9
Java Network Programming, 2nd
Edition, is a complete introduc-
tion to developing network pro-
grams (both applets and applications) using Java,
covering everything from networking fundamentals
to remote method invocation (RMI). It includes
chapters on TCP and UDP sockets, multicasting
protocol and content handlers, and servlets. This
second edition also includes coverage of Java 1.1,1.2
and 1.3. New chapters cover multithreaded network
programming, I/O, HTML parsing and display, the
Java Mail API, the Java Secure Sockets Extension,
and more.
Java Swing,2nd Edition
By Marc Loy, Robert Eckstein,
David Wood, James Elliott &
Brian Cole
2nd Edition November 2002 (est.)
1296 pages (est.), ISBN 0-596-00408-7
This second edition of Java
Swing thoroughly covers all the
features available in Java 2 SDK 1.3 and 1.4. More
than simply a reference, this new edition takes a
practical approach. It is a book by developers for
developers, with hundreds of useful examples, from
beginning level to advanced, covering every com-
ponent available in Swing. Whether you’re a sea-
soned Java developer or just trying to find out
what Java can do, you’ll find Java Swing, 2nd edi-
tion an indispensable guide.
Java Pragramming with Oracle JDBC
By Donald K. Bales
1st Edition December 2001
496 pages, ISBN 0-596-00088-X
Here is the professional’s guide
to leveraging Java’s JDBC in an
Oracle environment. Readers
learn the all-important mysteries
of establishing database corrections; issuing SQL
queries and getting results back; and advanced
topics such as streaming large objects, calling
PL/SQL procedures, and working with Oracle9i’s
object-oriented features.

To order: 800-998-9938 • order@oreilly.com • www.oreilly.com
Online editions of most O’Reilly titles are available by subscription at safari.oreilly.com
Also available at most retail and online bookstores.
1. Visit our award-winning web site
http://www.oreilly.com/
★ “Top 100 Sites on the Web”—PC Magazine
★ CIO Magazine’s Web Business 50 Awards
Our web site contains a library of comprehen-
sive product information (including book
excerpts and tables of contents), downloadable
software, background articles, interviews with
technology leaders, links to relevant sites, book
cover art, and more. File us in your bookmarks
or favorites!
2. Join our email mailing lists
Sign up to get email announcements of new
books and conferences, special offers, and
O’Reilly Network technology newsletters at:
http://elists.oreilly.com 
It’s easy to customize your free elists subscription
so you’ll get exactly the O’Reilly news you want.
3. Get examples from our books 
To find example files for a book, go to:
http://www.oreilly.com/catalog
select the book, and follow the “Examples” link.
4. Work with us
Check out our web site for current 
employment opportunites: 
http://jobs.oreilly.com/
5. Register your book
Register your book at:
http://register.oreilly.com
6. Contact us
O’Reilly & Associates,Inc.
1005 Gravenstein Hwy North
Sebastopol, CA 95472  USA
TEL: 707-827-7000 or 800-998-9938 
(6am to 5pm PST)
FAX: 707-829-0104
order@oreilly.com 
For answers to problems regarding your order
or our products. To place a book order online
visit:
http://www.oreilly.com/order_new/
catalog@oreilly.com
To request a copy of our latest catalog.
booktech@oreilly.com
For book content technical questions or 
corrections.
corporate@oreilly.com
For educational, library, government, and 
corporate sales.
proposals@oreilly.com 
To submit new book proposals to our editors
and product managers.
international@oreilly.com 
For information about our international dis-
tributors or translation queries. For a list of
our distributors outside of North America
check out: 
http://international.oreilly.com/distributors.html 
adoption@oreilly.com
For information about academic use of
O’Reilly books, visit:
http://academic.oreilly.com
How to stay in touch with O’Reilly

