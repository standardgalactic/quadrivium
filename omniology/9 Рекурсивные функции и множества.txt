Рекурсивные функции
и множества
© Учебный Центр безопасности информационных технологий Microsoft 
Московского инженерно-физического института (государственного университета), 2003 
 
 
 
Комментарий к слайду  
 
В данной лекции будут рассмотрены вопросы, относящиеся к понятийному аппарату,  
истории 
развития, 
существующим 
подходам 
и 
выразительным 
возможностям 
рекурсивного представления функций и множеств в формальных теориях и языках 
программирования.  
 

Современные языки программирования и .NET: I семестр
Лекция 9: Рекурсивные функции и множества
© Учебный Центр безопасности информационных технологий Microsoft 
Московского инженерно-физического института (государственного университета), 2003 
Содержание лекции
1.
Рекурсия в математике и программировании
2.
Рекурсивное определение типов данных и функций
3.
Коррекция понятия «множество» для формализации 
рекурсии: домены
4.
Неподвижная точка функции. Теорема о неподвижной 
точке
5.
Комбинатор Y как модель рекурсивной функции
6.
Примеры простейших рекурсивных функций на SML
7.
Библиография
 
 
 
Комментарий к слайду  
 
В ходе лекции будут рассмотрены важнейшие научные исследования, относящиеся к 
эволюции подходов к математическому моделированию рекурсивного представления 
типов, функций и множеств в формальных теориях и языках программирования. При этом 
будет предпринята попытка классификации существующих видов рекурсии.   
 
Далее будет представлено неформальное введение в наиболее адекватный целям данного 
курса и достаточно широко распространенный на сегодня подход к моделированию 
рекурсии, а именно, теорию неподвижных точек функций, формализованную с помощью 
комбинаторной логики.  
 
Теоретические 
рассуждения 
о 
рекурсии 
в 
формальных 
теориях 
(на 
примере 
комбинаторной логики и теории вычислений Д. Скотта) будут проиллюстрированы 
представлением 
основополагающих 
рекурсивных 
типов 
и 
функций 
языка 
программирования 
SML, 
включая 
функцию, 
неявно 
реализующую 
комбинатор 
неподвижной точки.  
 
При этом существенное внимание будет также уделено анализу границ практической 
применимости 
рекурсивного 
подхода 
к 
вычислениям, 
а 
также 
возможностей 
использования инструментальных средств .NET для реализации рекурсивных функций. 
 
Лекция завершится обзором литературы для более глубокого исследования материала. 
 
 
 

Современные языки программирования и .NET: I семестр
Лекция 9: Рекурсивные функции и множества
© Учебный Центр безопасности информационных технологий Microsoft 
Московского инженерно-физического института (государственного университета), 2003 
Важнейшие работы в области рекурсии
1936 – С. Клини (S.C. Kleene) доказал реализуемость 
рекурсии средствами ламбда-исчисления
1950-е – Х. Карри (Haskell .B. Curry) разработал 
комбинаторную логику как формальную систему с 
возможностью моделирования рекурсии
1960 – Дж. Maккарти (John McCarthy) исследовал 
практическую применимость рекурсивных вычислений 
для символьной обработки в ходе создания языка LISP
1969 – Д. Скотт (Dana S. Scott) предложил использовать 
домены (особый вид множеств) для формализации 
рекурсивно определенных функций и множеств
 
 
 
Комментарий к слайду  
 
Кратко остановимся на наиболее значительных (с точки зрения данного курса) этапах 
эволюции теории и практики рекурсивных вычислений в формальных теориях и языках 
программирования. 
 
Принципиальная реализуемость рекурсии средствами математической теории была 
доказана С. Клини (S.C. Kleene) еще в 30-х г.г. При этом фундаментом рассуждений 
служило ламбда-исчисление. 
 
Значительно позже, уже в 50-х г.г., Х. Карри (Haskell B. Curry) была разработана 
комбинаторная логика как более приближенная к практике программирования 
формальная система с возможностью моделирования рекурсии. 
 
Вскоре, в 60-х г.г., Джоном Маккарти (John McCarthy) в ходе создания языка 
функционального программирования LISP, основанного на упомянутых выше теориях, 
была исследована практическая применимость рекурсивных вычислений для символьной 
обработки и доказана возможность реализации рекурсии в программировании. 
 
В конце 60-х г.г. Д. Скоттом (Dana S. Scott) было предложено использовать модель, 
основанную на доменах (которые можно понимать как особый вид множеств) для 
формализации рекурсивно определенных функций и множеств в рамках созданной 
исследователем теории вычислений. 
 
 

Современные языки программирования и .NET: I семестр
Лекция 9: Рекурсивные функции и множества
© Учебный Центр безопасности информационных технологий Microsoft 
Московского инженерно-физического института (государственного университета), 2003 
Определение рекурсии
Рекурсивное определение объекта (в математике и 
программировании) - это определение, которое содержит 
внутри себя ссылку на определяемый объект. 
Рекурсивно определенный объект (функция, множество 
или тип) называется рекурсивным. 
Для формализации рекурсивных функций и множеств 
используются комбинаторная логика и теории на основе 
доменов.
 
 
 
Комментарий к слайду  
 
После краткого введения в историю исследуемой области знаний, перейдем к 
неформальному обсуждению понятия рекурсии. 
 
Под рекурсивным определением объекта (как в абстрактном теоретическом смысле, так и 
в аспекте практического программирования) будем понимать такое определение, которое 
содержит внутри себя ссылку на определяемый объект.  
 
 
 
Основными видами объектов, которые будут использоваться в дальнейшем при  
рекурсивных вычислениях, будут следующие: 
1) функция; 
2) множество; 
3) тип. 
 
Заметим, что рекурсивно определенный (т.е. построенный посредством рекурсии) объект, 
в свою очередь, носит название рекурсивного. 
 
Заметим также, что определение рекурсивных объектов в математике происходит по 
индукции. При этом сначала формулируется базис индукции, как рекурсивное 
определение исключительных случаев при построении типа или множества (или 
вычисления функции), а затем шаг индукции, как рекурсивное правило построения того 
же объекта. 
 
Для формализации рекурсивных функций и множеств в дальнейшем будут использоваться 
комбинаторная логика и теория вычислений Д. Скотта, основанная на понятии домена 
(последнее будет уточнено в ходе лекции). 
 
 

Современные языки программирования и .NET: I семестр
Лекция 9: Рекурсивные функции и множества
© Учебный Центр безопасности информационных технологий Microsoft 
Московского инженерно-физического института (государственного университета), 2003 
Примеры рекурсивных функций
•
факториал:
fun fact n = if (n<2) 1 else n*fact(n-1)
•
длина списка :
fun length lst = if (lst==[]) 0 
else 1 + length(tl(lst))
•
суммирование натуральных чисел от 1 до n:
fun sumpos n = if (n<2) 1 
else n + sumpos (n-1)
 
 
 
Комментарий к слайду  
 
В качестве практической и наглядной иллюстрации определения понятия рекурсии, 
рассмотрим ряд показательных примеров рекурсивных функций, описанных на языке 
программирования SML. 
 
Начнем с описания известной нам функции факториала на языке SML: 
 
fun fact n = if (n<2) 1 else n*fact(n-1) 
 
Как следует из описания, значением функции является 1, если значение аргумента не 
превышает 1, и произведение чисел натурального ряда от 1 до заданного в противном 
случае. Заметим, что идентификатор функции fact явно присутствует как в левой, так и 
в правой части описания. Отметим также, что настоящий пример, по сути, представляет 
собой линейный вариант записи математического определения функции факториала по 
индукции. Наконец, еще одной особенностью рекурсии является многократность вызова 
одной и той же функции с различными значениями аргумента. 
  
Далее рассмотрим описание функции, которая вычисляет длину списка: 
fun length lst = if (lst==[]) 0  
 
 
 
 
else 1 + length(tl(lst)) 
 
Заметим, что функция length использует встроенную функцию tl (получение 
«хвоста» списка) в ходе вычислений. Заметим также, что реализация рекурсивной 
обработки списка (который, кстати, является встроенным рекурсивным типом языка SML) 
выглядит лаконично и является весьма наглядной. 
 
Наконец, рассмотрим рекурсивное определение функции sumpos, суммирующей первые 
n чисел натурального ряда (и повторяющей отмеченные особенности функции fact): 
fun sumpos n = if (n<2) 1  
 
 
 
 
else n + sumpos (n-1) 
 

Современные языки программирования и .NET: I семестр
Лекция 9: Рекурсивные функции и множества
© Учебный Центр безопасности информационных технологий Microsoft 
Московского инженерно-физического института (государственного университета), 2003 
Примеры рекурсивных определений типов (1)
Список из элементов типа t либо пуст, либо состоит из 
головы и хвоста, где голова – элемент типа t, а хвост –
список из элементов типа t.
Бинарное дерево из элементов типа t либо пусто, либо 
состоит из корня и двух поддеревьев, где корень –
элемент типа t, а каждое из поддеревьев является 
деревом.
Замечание. Рекурсивные функции (подсчет количества элементов 
списка, обход дерева и т.д.) целесообразно использовать для 
рекурсивно определенных объектов.
Упражнение. Построить математическое описание рекурсивной 
функции (факториала) и сравнить его с SML-кодом данной функции.
 
 
 
Комментарий к слайду  
 
В 
ходе 
обсуждения 
примеров 
рекурсивного 
определения 
функций 
на 
языке 
программирования SML было упомянуто понятие рекурсивного типа для списков.  
 
Рассмотрим достаточно формальные определения важнейших рекурсивных типов, а 
именно, списка и дерева, выраженные в словесном виде.  
 
Прежде всего, приведем определение списка. Список из элементов типа t либо пуст, либо 
состоит из головы и хвоста, где голова – элемент типа t, а хвост – список из элементов 
типа t.  
 
 
Приведем определение дерева (для частного случая бинарного дерева). Бинарное дерево 
из элементов типа t либо пусто, либо состоит из корня и двух поддеревьев, где корень – 
элемент типа t, а каждое из поддеревьев является деревом. 
 
Подчеркнем, 
что 
оба 
приведенных 
определения 
являются 
рекурсивными 
(т.е. 
определяемые понятия определяются c использованием самих этих понятий). 
 
Отметим, что и список, и дерево имеют абстрактный (параметрический) тип аргументов, 
т.е. это, вообще говоря, полиморфные объекты. Именно таким образом список и дерево 
трактуются в языке программирования SML.  
 
Заметим также, что для манипулирования рекурсивно определенными объектами (в 
частности, списками и деревьями) целесообразно использовать рекурсивно определенные 
функции (например, подсчет количества элементов списка, обход дерева и т.д.). 
 
В качестве упражнения предлагается построить математическое описание по индукции 
для рекурсивной функции (скажем, факториала) и сравнить его с программой на языке 
SML, содержащей описание данной функции. 
 

Современные языки программирования и .NET: I семестр
Лекция 9: Рекурсивные функции и множества
© Учебный Центр безопасности информационных технологий Microsoft 
Московского инженерно-физического института (государственного университета), 2003 
Примеры рекурсивных определений типов (2)
Для задания рекурсивных типов в SML используются 
определения типов datatype следующего вида:
<определение типа>:: = 
datatype <имя типа> = <описание типа>; 
где
<описание типа>:: = 
<выражение> |
(здесь “|” - символ SML)
<имя элемента типа> of <конструктор>
<конструктор> = <тип> * … * <тип>
 
 
 
Комментарий к слайду  
 
Изучив порядок определения рекурсивных функций в языке программирования SML, 
перейдем к определению рекурсивных типов. 
 
Для задания рекурсивных типов в SML используются определения типов datatype 
следующего вида: 
 
 
 <определение типа>:: = 
  
 
 
datatype <имя типа> = <описание типа>; 
где 
  
 
<описание типа>:: = 
 
  
 
<выражение> | 
 
 
 
 
 
<имя элемента типа> of <конструктор> 
 
причем под конструктором понимается запись вида 
 
 
 
<конструктор> = <тип> * … * <тип> 
 
Заметим, что фигурирующий в описании рекурсивного типа символ “|” является частью 
алфавита языка программирования SML. 
 
Кроме того, обратим внимание на рекурсивный характер определения, который 
выражается в том, что типы в конструкторе могут совпадать с определяемым типом. 
 
Наконец, отметим, что значок «*», используемый в конструкторе типов SML, 
семантически аналогичен конструктору «×» для декартова произведения доменов. 

Современные языки программирования и .NET: I семестр
Лекция 9: Рекурсивные функции и множества
© Учебный Центр безопасности информационных технологий Microsoft 
Московского инженерно-физического института (государственного университета), 2003 
Примеры рекурсивных определений типов (3)
Примеры определения рекурсивных типов в SML:
1) список из целочисленных элементов:
datatype intlist =
nil | element of int * intlist; 
2) бинарное дерево из целочисленных элементов:
datatype inttree =
empty | node of int * inttree * inttree;
Замечание. Операция “|” конструирования типов в SML соответствует 
конструктору дизъюнктной суммы, а “*” – прямого произведения доменов.
 
 
 
Комментарий к слайду  
 
Проиллюстрируем сказанное о рекурсивных определениях типов содержательными 
примерами на языке программирования SML. 
 
В 
частности 
(поскольку 
достаточно 
сложное 
понятие 
полиморфизма 
будет 
рассматриваться существенно позднее), рассмотрим описания списка и бинарного дерева 
с целочисленными элементами. 
 
Приведем описание списка из целочисленных элементов на языке SML: 
 
 
datatype intlist = 
 
 
 
 
 
nil |  
element of int * intlist;  
 
Приведем описание бинарного дерева из целочисленных элементов на языке SML: 
 
 
datatype inttree = 
 
 
 
 
 
empty |  
node of int * inttree * inttree;  
 
Заметим, что операция “|”, применяемая для конструирования типов в SML, соответствует 
конструктору дизъюнктной суммы «+», а операция “*”, как уже отмечалось – прямого 
произведения доменов «×». 
 

Современные языки программирования и .NET: I семестр
Лекция 9: Рекурсивные функции и множества
© Учебный Центр безопасности информационных технологий Microsoft 
Московского инженерно-физического института (государственного университета), 2003 
Определение комбинатора
Переменная x называется свободной в терме λx.A, если 
она не имеет вхождений в терм A; в противном случае 
переменная x называется связанной
Для составных термов связанность переменных 
определяется индукцией по построению.
Терм, не содержащий свободных переменных, 
называется комбинатором. 
 
 
 
Комментарий к слайду  
 
Как уже отмечалось, для формализации рекурсивных вычислений будет использоваться 
система комбинаторной логики. 
 
Напомним, что важнейшим понятием для любой формы комбинаторной логики является 
понятие комбинатора. 
 
Для того, чтобы формально определить комбинатор, необходимо ввести понятие 
свободной и связанной переменной в ламбда-выражении. 
 
Переменная x называется свободной в ламбда-выражении (терме) вида λx.A, если она не 
имеет вхождений в терм A; в противном случае переменная x называется связанной.  
 
 
Для составных ламбда-выражений понятие связанной и свободной переменной 
определяется индукцией по построению с учетом возможных способов комбинирования, а 
именно, операций аппликации и абстракции. 
 
Теперь становится возможным дать лаконичное определение комбинатора. 
 
 
Ламбда-выражение 
(терм), 
не 
содержащее 
свободных 
переменных, 
называется 
комбинатором.  
 
 

Современные языки программирования и .NET: I семестр
Лекция 9: Рекурсивные функции и множества
© Учебный Центр безопасности информационных технологий Microsoft 
Московского инженерно-физического института (государственного университета), 2003 
Комбинатор неподвижной точки
Ни один из базисных комбинаторов K и S не может 
моделировать рекурсию. 
Предположим существование комбинатора Y, который 
при аппликации к любому комбинаторному терму (т.е. 
функции) E остается неизменным:
Y E = E (Y E).
Оказывается, что объект Y с такой характеристикой 
действительно существует, и его принято называть 
комбинатором неподвижной точки.
 
 
 
Комментарий к слайду  
 
Попытаемся исследовать известные нам комбинаторы на предмет применимости для 
моделирования рекурсивных вычислений. 
 
Предположим существование комбинатора Y, который при аппликации к любому 
комбинаторному терму (т.е. функции) E остается неизменным: 
 
 
 
 
 
Y E = E (Y E). 
 
К сожалению, выясняется, что ни один из ранее рассмотренных нами комбинаторов 
 
(I) 
I a = a;  
(K) 
К ab = a; 
(S) 
S abc = ac(bc);  
(B) 
B abc = a(bc);  
(C) 
C abc = acb; 
(W) 
W xy = xyy 
 
не обеспечивает требуемой возможности. 
 
Тем не менее, оказывается, что объект Y с указанной выше характеристикой 
действительно существует и известен в литературе под названием комбинатора 
неподвижной точки. 
 
 

Современные языки программирования и .NET: I семестр
Лекция 9: Рекурсивные функции и множества
© Учебный Центр безопасности информационных технологий Microsoft 
Московского инженерно-физического института (государственного университета), 2003 
Теорема о неподвижной точке
Для любой функции f, представимой в ламбда-
исчислении существует  ламбда-терм Y, такой что он 
является неподвижной точкой функции f, т.е. 
выполняется соотношение
Yf = f(Yf).
При этом объект Y имеет конечный вид:
Y = λf. (λx. f (x x)) (λx. f (x x)), 
или, в форме комбинаторной характеристики:
Y = WS(BWB), где
W=CSI, C=S(BBS)(KK), B=S(KS)K.
 
 
 
Комментарий к слайду  
 
Для получения характеристического соотношения, задающего комбинатор неподвижной 
точки, необходимо сформулировать (и доказать, что, впрочем, выходит за рамки данного 
курса) следующую теорему. 
 
Сформулируем теорему о неподвижной точке функции. 
 
Для любой функции f, представимой в ламбда-исчислении, существует  ламбда-терм Y, 
такой что он является неподвижной точкой функции f, т.е. выполняется соотношение 
 
 
Yf = f(Yf). 
 
При этом объект Y имеет конечный вид: 
 
 
Y = λf. (λx. f (x x)) (λx. f (x x)),  
 
или, в форме комбинаторной характеристики: 
 
 
Y = WS (BWB),  
 
где 
 
 
W = CSI,  
C = S (BBS) (KK),  
B = S (KS) K. 
 
Таким образом, любая функция имеет «неподвижную точку» в форме комбинатора Y, 
характеристику которого можно явно представить в базисе комбинаторов {K, S}. 
 
 

Современные языки программирования и .NET: I семестр
Лекция 9: Рекурсивные функции и множества
© Учебный Центр безопасности информационных технологий Microsoft 
Московского инженерно-физического института (государственного университета), 2003 
Неявная реализация комбинатора Y на SML
Определим тип данных:
datatype ‘a t = T of ‘a t -> ‘a; 
Определим функцию:
val Y = fn f => (fn (T x) => 
(f (fn a => x (T x) a)))
(T (fn (T x) => (f (fn a => x (T x) a))));
Реализация комбинатора Y посредством явной рекурсии 
(например, с помощью конструкций fun или let
rec) является тривиальной задачей.
 
 
 
Комментарий к слайду  
 
Исследуем возможность описания комбинатора неподвижной точки Y на языке 
программирования SML. 
 
Очевидно, что явным образом этот комбинатор реализован посредством рекурсивных 
определений функций с помощью рассмотренного нами варианта конструкции fun (или 
рекурсивного варианта подстановки let – конструкции let rec). Следовательно, 
реализация комбинатора Y посредством явной рекурсии  является тривиальной задачей. 
 
Для решения поставленной задачи возьмем за основу приведенное на предыдущем слайде 
ламбда-выражение для комбинатора Y. 
 
Далее, определим следующий тип данных: 
 
 
 
datatype ‘a t = T of ‘a t -> ‘a;   
 
 
 
Теперь определим функцию: 
 
 
 
val Y = fn f => (fn (T x) =>  
 
 
 
(f (fn a => x (T x) a))) 
(T (fn (T x) => (f (fn a => x (T x) a)))); 
 
Можно практически убедиться в том, что построенная таким образом (в полном 
соответствии с теорией) функция для комбинатора неподвижной точки Y действительно 
решает поставленную задачу. 
 
 

 
 
Современные языки программирования и .NET: I семестр
Лекция 9: Рекурсивные функции и множества
© Учебный Центр безопасности информационных технологий Microsoft 
Московского инженерно-физического института (государственного университета), 2003 
Использование доменов для формализации 
семантики рекурсивных функций и множеств
Денотационная семантика описывается уравнениями, 
задающими абстрактные функции на состояниях; 
переменные метаязыка пробегают по доменам. 
Домены требуют выполнения следующих дополнительных 
ограничений по сравнению с обычными множествами:
1)
все рекурсивные определения разрешимы;
2)
все домены имеют неопределенные элементы;
3)
производные домены сохраняют структуру базовых ;
4)
допустимы рекурсивные равенства между доменами.
 
Комментарий к слайду  
 
Рассмотрим связь ставшего концептуально ясным и практически апробированным 
понятия рекурсии с теорией вычислений.  
 
Ранее уже упоминалось о том обстоятельстве, что домены в теории вычислений Д. Скотта 
используются для формализации семантики рекурсивно определенных функций и 
множеств. 
 
Напомним, что в исследованиях Д. Скотта речь идет о денотационной семантике языков 
программирования. Последняя описывается уравнениями, задающими абстрактные 
функции на состояниях. При этом вводится специализированный метаязык, в котором 
переменные пробегают по доменам. 
  
Ранее, говоря о доменах, мы ограничивались констатацией того утверждения, что домены 
представляют собой до некоторой степени аналог множеств в теоретико-математическом 
смысле. Кроме того, отмечалось то обстоятельство, что домены требуют выполнения 
определенных дополнительных ограничений по сравнению с обычными множествами. На 
данном этапе представляется возможным конкретизировать форму упомянутых 
ограничений. 
 
Итак, существуют следующие ограничения, которые отличают домены от множеств: 
1) все рекурсивные определения являются разрешимыми; 
2) все домены имеют неопределенные элементы, необходимые для «обработки 
исключительных 
ситуаций», 
как, 
например 
в 
случае 
с 
элементом 
unbound, 
характеризующим невозможность связывания переменной со значением, или элемента 
error, характеризующего общую ошибку; 
3) производные  (т.е. построенные с помощью ранее исследованных в курсе 
конструкторов) домены сохраняют структуру базовых; 
4) между доменами допускаются не только непосредственные, но и  рекурсивные 
равенства. 

 
 
Современные языки программирования и .NET: I семестр
Лекция 9: Рекурсивные функции и множества
© Учебный Центр безопасности информационных технологий Microsoft 
Московского инженерно-физического института (государственного университета), 2003 
Виды рекурсии
Различают несколько видов рекурсии, основные из 
которых сводятся к следующим: 
1)
прямая рекурсия (простейший тип рекурсии, 
рассмотренный ранее);
2)
взаимная рекурсия (функция f определяется через
функцию g и наоборот);
3)
частичная рекурсия (рекурсивная функция является
частично определенной).
Все перечисленные виды рекурсии адекватно
формализуются теорией вычислений Д.Скотта, 
ламбда-исчислением и комбинаторной логикой.
 
 
 
Комментарий к слайду  
 
В настоящей лекции мы ограничились рассмотрением простейшего вида рекурсии.  
 
Однако, существует еще несколько видов рекурсивных определений объектов (в 
частности, функций),  рассмотрение которых может представить теоретический интерес и 
практическую важность. 
 
Кратко перечислим основные виды рекурсии. 
 
Во-первых, отметим, что тот простейший тип рекурсии, который рассматривался ранее, 
носит название прямой рекурсии. 
 
Более сложным видом рекурсивных определений является так называемая взаимная 
рекурсия. В таком случае, скажем, при формулировке рекурсивного определения 
функции, функция f определяется через функцию g и наоборот. 
 
Еще одним важным типом рекурсии является рекурсия, известная под названием  
частичной. В случае задания описания, скажем, функции, с помощью частичной рекурсии, 
вновь вводимая функция является частично определенной. 
 
Заметим в заключение, что все перечисленные выше виды рекурсии адекватно  
формализуются посредством теории вычислений Д. Скотта, а также формализаций, 
основанных на ламбда-исчислении и комбинаторной логике. 
 
 
 

Современные языки программирования и .NET: I семестр
Лекция 9: Рекурсивные функции и множества
© Учебный Центр безопасности информационных технологий Microsoft 
Московского инженерно-физического института (государственного университета), 2003 
Преимущества .NET для реализации рекурсии
1)
интегрированная среда гетерогенных языков
программирования позволяет сократить сроки
реализации сложных (требующих рекурсивных и
нерекурсивных функций) проектов;
2)
широкий спектр унифицированных предопределенных
структур данных (списки, деревья, очереди и т.д.) 
позволяет увеличить эффективность реализации и
повторно использовать код;
3)
рекурсия лучше соответствует ориентированным на
обработку рекурсивных структур данных языкам
функционального программирования (SML, Haskell, 
Scheme и др.).
 
 
 
Комментарий к слайду  
 
Подводя итоги обсуждения рекурсивного определения функций, типов и множеств, 
выделим наиболее значимые результаты. 
 
Во-первых, рекурсия относится к достаточно хорошо изученным областям computer 
science и имеет целый ряд вполне адекватных формализаций, наиболее важными из 
которых являются комбинаторная логика и теория вычислений Д. Скотта. 
 
Во-вторых, рекурсивные вычисления концептуально ясно и интуитивно прозрачно 
реализуемы посредством функционального подхода к программированию. 
 
В-третьих, платой за лаконичность и прозрачность (с математической точки зрения) 
реализации рекурсий является необходимость (многократного) повторного вычисления 
функций. 
 
Поскольку наше исследование языков программирования базируется на технологическом 
фундаменте .NET, перечислим основные результаты влияния данной платформы на 
реализацию рекурсии:  
1) интегрированная среда гетерогенных языков программирования позволяет 
сократить сроки реализации сложных (требующих рекурсивных и нерекурсивных 
функций) проектов; 
2) широкий спектр унифицированных предопределенных структур данных (списки, 
деревья, очереди и т.д.) позволяет увеличить эффективность реализации и 
повторно использовать код; 
3) рекурсия лучше соответствует ориентированным на обработку рекурсивных 
структур данных языкам функционального программирования (SML, Haskell, 
Scheme и др.). 
 

Современные языки программирования и .NET: I семестр
Лекция 9: Рекурсивные функции и множества
© Учебный Центр безопасности информационных технологий Microsoft 
Московского инженерно-физического института (государственного университета), 2003 
Библиография (1)
1.
Kleene S.C. λ-definability and recursiveness. Duke Math. J., 
pp. 340-353, 1936 
2.
McCarthy J. Recursive functions of symbolic expressions and 
their computation by machine, Part I. Com. ACM, April 1960
3.
Curry H.B., Feys R. Combinatory logic, vol.I, North Holland, 
Amsterdam, 1958
4.
Scott D.S. Domains for denotational semantics. ICALP 1982, 
577-613
 
 
 
Комментарий к слайду  
 
К сожалению, в рамках времени, отведенных на одну лекцию, можно лишь в общих 
чертах охарактеризовать рекурсивные вычисления. Для более детального ознакомления с 
особенностями, достижениями и проблемами в области исследований рекурсии 
рекомендуется следующий список литературы: 
 
1. Kleene S.C. λ-definability and recursiveness. Duke Math. J., pp. 340-353, 1936  
 
2. McCarthy J. Recursive functions of symbolic expressions and their computation by machine, 
Part I. Com. ACM, April 1960 
 
3. Curry H.B., Feys R. Combinatory logic, vol.I, North Holland, Amsterdam, 1958 
 
4. Scott D.S. Domains for denotational semantics. ICALP 1982, 577-613 
 
Кратко остановимся на источниках. Работа [1] является новаторской в области 
моделирования рекурсии посредством ламбда-исчисления. В работе [2] рассматриваются 
вопросы, связанные с практической реализацией рекурсии в языках функционального 
программирования. Работа [3] содержит описание системы комбинаторной логики, 
основной формализации неподвижных точек функций. В работе [4] представлена теория 
семантических  доменов, одного из способов формализации рекурсивно определенных 
множеств.  

Современные языки программирования и .NET: I семестр
Лекция 9: Рекурсивные функции и множества
© Учебный Центр безопасности информационных технологий Microsoft 
Московского инженерно-физического института (государственного университета), 2003 
Библиография (2)
5.
Hindley J.R., Seldin J.P. Introduction to combinators and λ-
calculus. London Mathematical Society Student Texts, 1, 
Cambridge University Press, 1986
6.
Turner D.A. A new implementation technique for applicative 
languages. Software – Practice and Experience, 9:21-49, 1979
 
 
 
Комментарий к слайду  
 
Продолжим обсуждение работ, посвященных исследованию рекурсии.  
 
5. Hindley J.R., Seldin J.P. Introduction to combinators and l-calculus. London Mathematical 
Society Student Texts, 1, Cambridge University Press, 1986 
 
6. Turner D.A. A new implementation technique for applicative languages. Software – Practice 
and Experience, 9:21-49, 1979 
 
В работе [5] излагается взаимосвязь фундаментальных теорий, формализующих 
рекурсивные вычисления. В работе [6] рассматриваются вопросы, связанные с 
приложением рекурсивных вычислений к реализации языков программирования. 
 
  
 

