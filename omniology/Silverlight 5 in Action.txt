M A N N I N G
Pete Brown
Revised Edition of 
Silverlight 4 in Action 
IN ACTION

Silverlight 5 in Action
PETE BROWN
M A N N I N G
SHELTER ISLAND

For online information and ordering of this and other Manning books, please visit
www.manning.com. The publisher offers discounts on this book when ordered in quantity. 
For more information, please contact
Special Sales Department
Manning Publications Co.
20 Baldwin Road
PO Box 261
Shelter Island, NY 11964
Email: orders@manning.com
©2012 by Manning Publications Co. All rights reserved.
No part of this publication may be reproduced, stored in a retrieval system, or transmitted, in 
any form or by means electronic, mechanical, photocopying, or otherwise, without prior written 
permission of the publisher.
Many of the designations used by manufacturers and sellers to distinguish their products are 
claimed as trademarks. Where those designations appear in the book, and Manning 
Publications was aware of a trademark claim, the designations have been printed in initial caps 
or all caps.
Recognizing the importance of preserving what has been written, it is Manning’s policy to have 
the books we publish printed on acid-free paper, and we exert our best efforts to that end. 
Recognizing also our responsibility to conserve the resources of our planet, Manning books are 
printed on paper that is at least 15 percent recycled and processed without elemental chlorine.
Development editor: Jeff Bleiel
Manning Publications Co.
Technical proofreader: Thomas MacKearney
20 Baldwin Road
Copyeditor: Liz Welch
PO Box 261
Proofreader: Elizabeth Martin
Shelter Island, NY 11964
Typesetter: Marija Tudor
Cover designer: Marija Tudor
ISBN: 9781617290312
Printed in the United States of America
1 2 3 4 5 6 7 8 9 10 – MAL – 18 17 16 15 14 13 12

iii
brief contents
PART 1
CORE SILVERLIGHT...................................................... 1
1
■
Introducing Silverlight
3
2
■
XAML and the property system
26
3
■
The application model and the plug-in
47
4
■
Working with HTML and browsers
73
5
■
Out-of-browser applications
95
6
■
The security model and elevated trust
114
PART 2
CREATING THE USER INTERFACE .............................. 125
7
■
Rendering, layout, and transforming
127
8
■
Panels
160
9
■
Human input
180
10
■
Text fundamentals
199
11
■
Editing plain and rich text
225
12
■
Control basics and UserControls
247
13
■
Animation and behaviors
272

BRIEF CONTENTS
iv
14
■
Resources, styles, and control templates
307
15
■
Extensions, converters, custom controls, and panels
337
PART 3
WORKING WITH DATA AND SERVICES ......................... 365
16
■
Binding
367
17
■
Data controls: DataGrid and DataForm
410
18
■
Input validation
433
19
■
Networking basics
460
20
■
Working with SOAP services
491
21
■
RESTful services with the ASP.NET Web API
520
22
■
Working with XML, JSON, RSS, and Atom
549
23
■
Duplex, sockets, and local connections
575
PART 4
2D AND 3D GRAPHICS .............................................. 601
24
■
Graphics and effects
603
25
■
Working with images
630
26
■
Introduction to 3D
649
27
■
3D lighting, texturing, and animation
679
PART 5
MAKING THE MOST OF THE PLATFORM ..................... 709
28
■
Pop-ups, windows, and full-screen applications
711
29
■
Navigation
734
30
■
Working with files and directories
761
31
■
Printing
798
32
■
COM, Native Extensions, and p-invoke
832
PART 6
BEST PRACTICES ...................................................... 867
33
■
Structuring and testing with the MVVM pattern
869
34
■
Debugging your application
913
35
■
The install experience and preloaders
929

v
contents
preface
xxi
acknowledgments
xxiv
about this book
xxvi
about the cover illustration 
xxxi
PART 1
CORE SILVERLIGHT .......................................... 1
1 
Introducing Silverlight
3
1.1
A Silverlight primer
4
Silverlight and the web
5
■Silverlight and WPF
6
Types of Silverlight applications
6
1.2
A brief history of Silverlight
8
Features for business and client applications
8
■Media and 
graphics enhancements
10
■User interaction
11
■Text
11
1.3
Getting started with Silverlight development
12
Setting up your development environment
13
■Helpful sites
13
1.4
Building your first Silverlight web application
14
Project setup
15
■User interface
16
■Calling Twitter 
search
18
■Parsing the results and binding the ListBox
19
Making the ListBox contents more meaningful
23
1.5
Summary
25

CONTENTS
vi
2 
XAML and the property system
26
2.1
XAML basics
27
Objects
28
■Namespaces
29
■Properties
32
Dependency properties
33
■Attached properties
35
Events
36
■Commands
38
2.2
Object trees and namescope
39
Object trees
39
■Namescope
42
2.3
XAML type converters
43
2.4
Loading XAML at runtime
44
2.5
Summary
46
3 
The application model and the plug-in
47
3.1
The Silverlight application model
48
Application startup process
49
■XAP
50
■The application 
manifest file
51
■The Silverlight application object
52
Application dependencies
55
■Assembly caching 
56
3.2
Creating the Silverlight plug-in
58
Using the object tag
59
■Using the Silverlight.js utility file
60
Creating an instance of the Silverlight plug-in
61
3.3
Integrating the Silverlight plug-in
62
Relating the Silverlight application to the HTML DOM
62
Clarifying the initial experience
64
■Handling plug-in 
events
68
■Sending initialization parameters
70
3.4
Summary
71
4 
Working with HTML and browsers
73
4.1
Silverlight and the HTML DOM
74
4.2
Working with the web page from managed code
75
Navigating web page contents
76
■Working with element 
properties
77
■Handling CSS information
78
Accessing the query string
78
4.3
Working with the hosting browser window
79
Prompting the user
79
■Navigating the browser window
81
Discovering the browser properties
81
4.4
Bridging the scripting and managed code worlds
82
Calling managed code from JavaScript
82
■Using JavaScript 
from managed code
85

CONTENTS
vii
4.5
Hosting HTML in Silverlight
86
Hosting the WebBrowser control
87
■Using the 
WebBrowserBrush
92
4.6
Summary
94
5 
Out-of-browser applications
95
5.1
Implementation specifics
97
Process and hosting
97
■Capabilities and restrictions
98
5.2
The end-user experience
98
5.3
Creating out-of-browser applications
100
The out-of-browser settings file
100
■Controlling the 
experience
102
■Customizing icons
105
■Updating
105
5.4
Alerting the user with notification toast
106
5.5
Controlling the host window
107
Basic window properties
108
■Changing window 
chrome
109
■Minimizing, maximizing, restoring, and 
closing
110
■Moving a window
111
■Resizing
111
5.6
Summary
112
6 
The security model and elevated trust
114
6.1
Code classifications and the transparency model
115
6.2
User initiation and consent
117
6.3
Elevated trust
119
Creating elevated trust applications
120
■Enabling in-browser 
elevated trust applications
122
■Detecting elevated trust 
mode
124
6.4
Summary
124
PART 2
CREATING THE USER INTERFACE ................... 125
7 
Rendering, layout, and transforming
127
7.1
The UIElement and FrameworkElement 
128
Properties
128
■Methods
134
7.2
The rendering process
135
Clock tick
137
■Per-frame rendering callback
137
Rasterization
138

CONTENTS
viii
7.3
The layout system
144
Multipass layout—measuring and arranging
144
The LayoutInformation class
146
■Performance 
considerations
147
7.4
Render transforms
148
RotateTransform
149
■ScaleTransform
150
SkewTransform
150
■TranslateTransform
151
TransformGroup
151
■CompositeTransform
152
MatrixTransform
153
7.5
3D projection transforms
155
PlaneProjection
155
■Matrix3dProjection
157
7.6
Summary
159
8 
Panels
160
8.1
Canvas
161
Setting the offsets
162
■Setting the stack order
163
8.2
The StackPanel
165
8.3
The WrapPanel
166
Vertical wrapping
167
■Horizontal wrapping
168
8.4
The Grid
169
Arranging Grid content
170
■Positioning Grid content
172
Spanning cells
172
■Sizing it up
173
■Working with the 
grid programmatically
176
■Customizing cell 
boundaries
177
8.5
Summary
179
9 
Human input
180
9.1
Capturing the keyboard
181
Understanding focus
181
■Handling keyboard events
182
Dealing with modifier keys
184
9.2
Mouse input
185
Mouse movement events
186
■Mouse button events
188
Using the mouse wheel
191
9.3
Using multitouch
193
9.4
Collecting ink drawings
194
Creating the InkPresenter
195
■Collecting ink
195
Styling the ink
197
9.5
Summary
198

CONTENTS
ix
10 
Text fundamentals
199
10.1
The text system
200
Subpixel text rendering
200
■Text hinting
201
■Text 
formatting
202
■Text rendering
203
10.2
Displaying text
204
Font properties
204
■Flow control
208
■Text 
properties
209
■Spacing
212
10.3
OpenType font support
215
Ligatures
216
■Stylistic sets
217
■Font capitals
219
Fractions and numbers
220
■Variants, superscript, and 
subscript
221
10.4
Embedding fonts
223
10.5
Summary
224
11 
Editing plain and rich text
225
11.1
Handling basic text input
226
Enabling multiline text support
227
■Mastering text 
selection
228
11.2
Understanding input method editors
228
11.3
Copying text with the Clipboard API
231
11.4
Collecting sensitive data
232
11.5
Entering and displaying rich text
233
Formatting and inline elements
233
■Working with selected 
text
237
11.6
Multicolumn and free-form linked text
241
Multicolumn text
241
■Free-form text layout
242
11.7
Summary
245
12 
Control basics and UserControls
247
12.1
Control
248
Appearance
248
■Tab navigation and control state
249
Templating
250
12.2
ContentControl
251
The ContentPresenter
252
12.3
Button controls
253
The Button
254
■The HyperlinkButton
255
The RadioButton
255
■The CheckBox
257

CONTENTS
x
12.4
ItemsControls
258
The ListBox
259
■The ComboBox
262
■The 
TabControl
262
12.5
Creating UserControls
265
Defining the appearance
266
■Defining behavior of a 
control
267
■Calling the control
270
12.6
Summary
271
13 
Animation and behaviors
272
13.1
Animating a value over time
273
13.2
Mastering the timeline
275
What type of property are you animating?
275
■Where are you 
starting from and where are you going?
277
■How long should 
the animation run?
280
13.3
Storyboards
283
Understanding the storyboard
283
■Storyboard target
284
Controlling the Storyboard
287
■Resources
289
13.4
Keyframing
291
13.5
Interpolation
293
Linear interpolation
294
■Spline interpolation
294
Discrete interpolation
296
■KeyTime
296
13.6
Easing functions
297
Using easing functions
298
■Creating a custom easing 
function
301
13.7
Behaviors, triggers, and actions
302
Using existing behaviors
303
■Creating your own 
behavior
305
13.8
Summary
306
14 
Resources, styles, and control templates
307
14.1
Being resourceful
308
Declarative resources
308
■Accessing loose resources
314
Bundled resources
315
14.2
Giving your elements style
317
Defining the look
319
■Explicitly keyed style definitions
321
Implicit style definitions
322

CONTENTS
xi
14.3
Creating templates
323
Building a control template
323
■Creating reusable 
templates
328
14.4
Dealing with visual states
329
Understanding the components
329
■Leveraging the 
VisualStateManager
331
14.5
Sharing your visual states
335
14.6
Summary
335
15 
Extensions, converters, custom controls, and panels
337
15.1
Markup extensions
338
Creating a simple custom markup extension
339
■Creating a 
parameterized markup extension
340
15.2
Custom type converters
342
Creating the converter
342
■Using the converter
343
15.3
Creating a custom panel
345
Project setup
346
■The OrbitPanel class
346
Properties
347
■Custom layout
350
■Enhancements
354
15.4
Creating a custom control
355
Choosing the base type
355
■Properties
356
■The control 
template contract
357
■The default template
359
Visual states
360
■Visual states in template
361
15.5
Summary
363
PART 3
WORKING WITH DATA AND SERVICES ............. 365
16 
Binding
367
16.1
Binding basics
368
Mastering the binding syntax
369
■Choosing a binding 
mode
371
16.2
Understanding your binding source
373
Binding to a property
374
■Binding to an object
376
Binding to a UI element
378
■Binding to an indexed 
element
381
■Binding to a keyed (string indexed) 
element
382
■Binding to an entire collection
383
Deciding when to update binding
385

CONTENTS
xii
16.3
Binding to dynamic properties
386
ICustomTypeProvider overview
387
■Creating the helper 
classes
387
■Using the helper class
390
16.4
Customizing the display
395
Formatting values
395
■Converting values during 
binding
395
■Providing default fallback values
399
Handling null values
399
16.5
Creating explicit data templates
400
Using a DataTemplate with a ContentControl
400
Rendering an ItemsControl with a DataTemplate 
402
16.6
Creating implicit data templates
403
16.7
Summary
409
17 
Data controls: DataGrid and DataForm
410
17.1
The DataGrid
411
Displaying your data
411
■Editing grid data
417
Sorting items
417
17.2
The DataForm
418
Displaying your data
419
■Binding to lists of data
421
Customizing display
424
■Customizing edit, add, and display 
templates
425
■Finer control over editing and committing 
data
427
17.3
Annotating for display
428
The Display attribute
429
■The Editable attribute
430
17.4
Summary
431
18 
Input validation
433
18.1
The validation example source and UI
434
18.2
Exception-based property validation
438
Handling exception validation errors
438
■Custom 
validation code
439
■Validation error display
440
18.3
Synchronous validation with IDataErrorInfo
441
The IDataErrorInfo interface
441
■Simple validation with 
IDataErrorInfo
442
■Cross-field validation with IData-
ErrorInfo
443
■Combining exceptions and IDataErrorInfo
445
18.4
Asynchronous validation with INotifyDataErrorInfo
446
The INotifyDataErrorInfo interface
446
■Implementing the 
interface
447
■Binding support
448
■Building the WCF 

CONTENTS
xiii
web service
448
■Adding the client service code
449
Property modifications
450
18.5
Annotating for validation
451
Validation attributes
452
■Annotating your entity
453
Calling external validation functions
454
■Creating custom 
validators
456
18.6
Comparison of validation approaches
457
18.7
Summary
458
19 
Networking basics
460
19.1
The web request/response pattern
461
WebRequest and HttpWebRequest
462
■WebResponse and 
HttpWebResponse
463
19.2
Simplifying the request/response pattern with WebClient
465
String operations
465
■Stream operations
468
19.3
Asynchronous communication
469
When async methods attack
470
■Saving your sanity 
with Rx
471
■Simplifying with tasks
474
19.4
Trust and cross-domain network access
476
Structuring the cross-domain file
477
■Other cross-domain 
policy files
479
■Locating your cross-domain policy
480
19.5
The browser HTTP stack
481
Connection count limit
481
■Cookies
482
■Caching
482
19.6
The client HTTP stack
483
Manually creating the client stack
483
■Automatically using 
the client stack
484
■Automatically setting the HTTP Referer 
and other headers
484
■Authentication credentials
485
Managing cookies with the CookieContainer
486
■When to 
use the client stack
488
19.7
Checking the network state
489
19.8
Summary
490
20 
Working with SOAP services
491
20.1
Introducing ASP.NET SOAP services using ASP.NET
492
Silverlight-compatible SOAP services
492
■Service 
references
495
■Receiving data with the proxy
495
Sending data using the proxy
499

CONTENTS
xiv
20.2
Using WCF services and complex data types
500
Creating the Silverlight-enabled WCF service
501
■Sharing 
type definitions
505
■Adding the service reference
508
Using the service
509
20.3
Using the configuration file
511
20.4
Error handling with WCF
513
Using an out parameter
513
■Exposing exception information 
for debugging
515
■Error handling with WCF SOAP 
faults
516
20.5
Summary
518
21 
RESTful services with the ASP.NET Web API
520
21.1
Creating a RESTful service using the ASP.NET Web API 
522
Solution setup
523
■Creating the services
525
■Testing the 
service using the browser
530
■Adding the Silverlight 
project
531
21.2
Consuming REST services
539
REST service GET operations
540
■Updating resources by 
POSTing to the service
544
■Removing resources using 
DELETE
546
21.3
Summary
548
22 
Working with XML, JSON, RSS, and Atom
549
22.1
Parsing plain old XML
550
LINQ to XML
550
■XmlSerializer
554
22.2
Working with JSON
558
JsonObject and JsonArray
559
■DataContractJsonSerializer
562
22.3
Working with RSS and Atom
566
Reading syndication feeds
566
■Working with feed 
items
569
22.4
Summary
573
23 
Duplex, sockets, and local connections
575
23.1
WCF polling duplex services
576
Creating the project and callback contract
577
■Creating the 
service
579
■Creating the service logic
582
■Managing 
client subscriptions
584
■Using the duplex service
585

CONTENTS
xv
23.2
Connecting to sockets
589
Serving the policy file
590
■Opening the connection
591
Handling the response
591
23.3
Multicast sockets
593
Any-Source Multicast/Internet Standard Multicast
593
Source-Specific Multicast
594
23.4
Connecting to other local Silverlight applications
595
Creating the receiver
596
■Creating the sender
597
Putting it all together
597
23.5
Summary
599
PART 4
2D AND 3D GRAPHICS .................................. 601
24 
Graphics and effects
603
24.1
Shapes
604
Lines
605
■Rectangle
605
■Ellipse
606
Polyline
607
■Polygon
608
24.2
Geometry
609
Simple geometries
609
■Path geometries
611
Composite geometries
612
24.3
Brushes
613
SolidColorBrush
613
■LinearGradientBrush
614
RadialGradientBrush
616
■ImageBrush
618
VideoBrush
619
24.4
Effects
620
Using built-in effects
620
■Creating custom pixel shaders
624
24.5
Summary
629
25 
Working with images
630
25.1
Basic imaging
631
25.2
Creating images at runtime
632
Creating from existing images
633
■Creating from UI 
elements
634
■A Mandelbrot fractal generator
636
25.3
Deep Zoom
638
Showing an image
639
■Zooming in and out
639
Managing the viewport
641
■Deploying multiscale 
images
643

CONTENTS
xvi
25.4
Dealing with dead space
643
Filling the space
644
■Uniform sizing
645
■Fill the 
area
646
■UniformToFill
647
25.5
Summary
647
26 
Introduction to 3D
649
26.1
3D—a natural way of interacting with information
650
26.2
The Silverlight/XNA 3D API
652
Rendering pipeline
652
■Project templates
653
26.3
Detecting capabilities with the GraphicsDeviceManager
654
26.4
Using the DrawingSurface
658
26.5
Project structure: the scene and objects
659
The scene
660
■Renderable scene objects
663
The camera
665
26.6
Vertices
667
Building a triangle using vertices
668
■Adding the triangle to 
the scene
670
26.7
Primitives
671
The TriangleList primitive
672
■The TriangleStrip 
primitive
673
■Tessellating a sphere
674
■Rendering the 
sphere with primitives
676
26.8
Summary
678
27 
3D lighting, texturing, and animation
679
27.1
Lighting and normal vectors
680
Lighting the scene
681
■Sphere normal vectors
682
Indexed vertices
684
27.2
Applying a texture
687
The ContentManager
687
■Texturing the sphere
688
Adding and texturing a background
691
27.3
Coordinate spaces and matrices
695
The three coordinate space conversion matrices
696
The Matrix class
697
27.4
Keyframe animation
698
The KeyFrame and KeyframeAnimation classes
698
Using animation
703
27.5
Summary
706

CONTENTS
xvii
PART 5
MAKING THE MOST OF THE PLATFORM 709
28 
Pop-ups, windows, and full-screen applications
711
28.1
Showing pop-ups and child windows
712
The Popup control
713
■Displaying a dialog box with the 
ChildWindow control
713
28.2
Creating native windows
717
Creating a normal window
718
■Customizing window 
chrome
723
28.3
Running in full screen
730
Normal full-screen mode
731
■Elevated trust full-screen 
mode
732
28.4
Summary
733
29 
Navigation
734
29.1
Browser navigation background
735
Browser journals
735
■Anchor hashtags
736
Back and forth
737
29.2
The Navigation Application template
738
Creating a navigation application
738
■Adding a new 
page
740
■Changing the application theme
742
29.3
Navigating to pages
744
The Page class
744
■The NavigationService class
746
Frames and URIs
748
■Caching pages
751
Navigating to pages in other assemblies
753
29.4
Navigation out of the browser
755
Providing custom navigation controls
756
29.5
Summary
759
30 
Working with files and directories
761
30.1
Using the file open and save dialogs
762
Working with the OpenFileDialog
763
■Saving files with the 
SaveFileDialog
767
30.2
Working with directories
770
Getting directory timestamps
772
■Checking for directory 
existence
774
■Getting the directory root
774
■Creating 
and deleting directories
775
■Listing directory contents
777
Accessing special folders
778

CONTENTS
xviii
30.3
Working with individual files
780
Creating a file
784
■Writing to a file
785
■Reading from a 
file
787
■Getting and setting file metadata
789
File utility functions
790
30.4
Storing data in isolated storage 
791
IsolatedStorageFile: the virtual filesystem
792
■Reading and 
writing files: the isolated storage way
795
30.5
Summary
797
31 
Printing
798
31.1
How Silverlight printing works
799
The PrintDocument class
801
■The PrintPage Event
804
Converting to PostScript
807
■Rasterization
807
Forcing bitmap printing
808
■Forcing vector printing
809
31.2
Printing onscreen information 
810
Printing the content as is
810
■Reparenting the elements 
to fit
812
■Scaling content to fit 
814
31.3
Multipage printing dedicated trees
816
Prerequisites
816
■Printing line items
820
■Adding 
multipage support
825
■Adding a header and footer
827
31.4
Summary
830
32 
COM, Native Extensions, and p-invoke
832
32.1
COM automation
833
Detecting COM automation availability
834
■Using COM 
automation to make Silverlight talk
835
■Accessing GPS data 
using COM automation
836
■Automating Excel
837
32.2
Native Extensions for Silverlight
839
Accessing an accelerometer
840
■Integrating with the 
Windows taskbar
849
■Runtime automation server 
installation
855
32.3
P-invoke for API calls
857
Setting up the printer application
857
■The Win32 API 
interface
860
32.4
Summary
865

CONTENTS
xix
PART 6
BEST PRACTICES .......................................... 867
33 
Structuring and testing with the MVVM pattern
869
33.1
Project setup and traditional code-behind approach
870
Project and service setup
871
■A typical code-behind 
solution
875
33.2
Model-View-ViewModel basics
878
Myths about MVVM Model-View-ViewModel
881
■Keep it 
simple: a basic ViewModel implementation
882
33.3
Factoring out reusable code
887
Business rules and logic
888
■Data access and service 
calls
890
33.4
Better separation from the UI
892
Using commands
892
■Using the CallMethodAction 
behavior
896
■View-specific entities and ViewModels
898
Interfaces, IoC, and ViewModel locators
903
33.5
Testing MVVM applications
906
Introduction to the Silverlight Unit Testing Framework
906
Testing the ViewModel
910
■Testing asynchronous 
operations
911
33.6
Summary
912
34 
Debugging your application
913
34.1
Debugging basics
914
Using the Debug class
914
■IDE breakpoints
916
The good old MessageBox
918
34.2
Binding debugging
920
Viewing binding errors in the output window
921
■Debugging 
with custom value converters
922
■Using XAML 
breakpoints
922
34.3
Troubleshooting network operations
923
Installing Fiddler
924
■Monitoring and logging traffic
924
Inspecting individual requests
926
34.4
Summary
928

CONTENTS
xx
35 
The install experience and preloaders
929
35.1
Handling the ‘Silverlight not installed’ scenarios
930
Creating your own install experience
931
35.2
Using a custom preloader 
933
Creating the appearance
934
■Integrating the custom splash 
screen
936
■Monitoring the load progress
936
35.3
Summary
937
appendix A
Database, connection, and data model setup 
939
index
945
online appendixes
appendix B
Media basics 
appendix C
Raw media, webcam, and microphone
appendix D
Introduction to WCF RIA Services
appendix E
WCF RIA endpoints, security, business logic, and decoupling
appendix F
WCF RIA Services and WVVM
Online appendixes available as a free download from 
www.manning.com/Silverlight5inAction

xxi
preface
Coding on the client is fun. I started on the Commodore 64 in seventh grade in the
1980s; later moved to DOS with dBASE, QuickBasic, and C++; and eventually began Win-
dows programming using C++, Borland Delphi 1.0, PowerBuilder, Visual Basic 3-6, and
.NET. I like the ozone smell of making my CPU work for a living. I like being able to tap
into the power of the local machine. I want to be able to hear the individual bits moving
across the bus.
 I like client application development, and I really like XAML. I like Silverlight, WPF,
and Windows 8 XAML. I even like working in the WPF subset on the .NET Micro
Framework and Gadgeteer boards I own. Sometimes, when I’m feeling especially dan-
gerous I’ll write some C++, or C, or even a little assembly. It’s all about the power.
 A year and a half ago, Manning published Silverlight 4 in Action. As proud as I am of
that book, I’m even more excited to bring you this updated version. Not only because
of the work involved in bringing you this edition, but because of how far Silverlight
has come in that time. With Silverlight 5, Silverlight has the power.1
 What a difference a year and a half makes! Silverlight 4 saw significant uptake
among business application developers, and those same developers helped drive the
features that made it into Silverlight 5. These developers are writing the types of
bread-and-butter applications that leverage Silverlight for its simple deployment and
great validation and data binding capabilities.
1 And now, you have C&C Music Factory’s “I Got the Power” looping in your head. You can thank me later.

PREFACE
xxii
General adoption of Silverlight is up too, as you can see in figure 1. These unofficial
third-party charts, reformatted for print from http://riastats.com data obtained in
early 2012, show Silverlight and Adobe Flash adoption taken from a large segment of
the general internet population. They reveal overall Silverlight adoption at a hair over
75 percent with version 4 at a bit over 67 percent and overall flash adoption around 96
percent, with Flash 11 at a hair over 70 percent.
 I’m not a marketing person; I’m a developer. Although such a blunt numbers com-
parison between the two competing products may look dire at first glance, adoption
numbers like these aren’t at all bad, considering Silverlight was a far more recent
introduction and didn’t benefit from either the late 1990s boom in website intro apps
or bundling with Internet Explorer 6. You can do a lot with 75 percent of the PCs out
there. It’s my goal to help you do it.
 2011 was also a rocky year for Silverlight and Flash developers, with confusion over
what Silverlight is to be used for and where it fits into the development strategy at
Microsoft and in the web as a whole. The Apple position on Flash didn’t help Flash or
plug-ins in general. Flash definitely had a reputation for websites, whereas Silverlight
evolved to more of a browser-delivered client technology. There were as many, if not
more, out-of-browser apps as in-browser apps written in Silverlight.
  With HTML5 (and JavaScript and CSS3, all of which I’ll lump into “HTML5” just as
the media tends to) having picked up serious speed, especially on the media and
casual games front on the public web, I think it’s a sure bet to become the way forward
for broad-reach, public-facing website content. There’s so much momentum behind
HTML5 that to fight it would simply land you behind others. HTML5 will suit you just
fine, especially for run-of-the-mill, non-digital rights management (DRM), non-
smooth-streaming media like what you see on YouTube.
 But for many, HTML5 isn’t a realistic choice. Either you can’t count on browser
support for key features, or you have a behind-the-firewall (or other controlled net-
work) application scenario that makes it easier for you to use technologies you’ll be
Figure 1
Adoption of Adobe Flash vs. Microsoft Silverlight in 2012

PREFACE
xxiii
more productive in. Two key points rise above any trendy discourse and well into the
realm of GSD (Getting Stuff Done):
■
Know your audience —Develop in what your users can use (behind the firewall
has more choice and control than the public web).
■
Know your skills and requirements —Develop in what you can be most productive
in—what will meet the project requirements with the least amount of fudging.
Without a doubt, most .NET developers are more productive in Silverlight when build-
ing business applications. There’s so much there, right in the box, that makes it easy
for you to quickly create stunning, feature-rich apps. Not only that, but the added sys-
tem integration features of Silverlight 5 (like COM and p-invoke) make it even more
compelling as a platform.
 As a developer, or manager of developers, you must choose technology based not
only on the longevity of that technology, but also on what makes it possible for you to
deliver the best possible application for the most reasonable cost.
 Regardless of where Silverlight goes in the long term, you already know that XAML,
C#, and Visual Basic are all here to stay. In addition to continued desktop support for
Silverlight and WPF, Microsoft is using XAML in Windows 8 Metro and on the Windows
Phone. I believe in XAML strongly enough to have written this book (around 1,200
pages if you include the downloadable content) while working at Microsoft, as well as
a book dedicated to XAML on Windows 8. Given the resources dedicated to XAML
development and tools at Microsoft, I’m glad to see they believe in it too.
 Ultimately, it’s good to have a choice. I choose XAML. I choose Silverlight.

xxiv
acknowledgments
A book of this size and complexity takes a large number of people to write (and to
lift). Though my name is on the cover, there’s no way I could’ve completed this with-
out the support and hard work of many others. I’d like to thank:
■
Chad Campbell and John Stockton for creating such an excellent first edition.
Without their hard work covering Silverlight 2, I’d never have thought to create
a Silverlight 4 edition or this Silverlight 5 edition.
■
The Silverlight product team for their continued help in digging into the
details of the runtime. There were too many helpful people to list here.
■
My stalwart tech reviewer Tom McKearney. I appreciate most that he didn’t just
die on the spot when he was told the 800 pages he had to review were actually in
the 1,200 neighborhood.
■
I’d like to thank my friends at Manning. People like Mary Piergies, Liz Welch,
Elizabeth Martin, and others worked tirelessly to get this book published in
time. Michael Stephens, Maureen Spencer, and of course, Marjan Bace all
worked with me to help ensure that you, the reader, get all the text I wrote,
without them having to print a multivolume set. I thank them and the rest of
the folks at Manning.
■
Unique in this thanks is my development editor, Jeff Bleiel. A good editor can
make the difference between a horrible authoring experience and a good one,
and for the second time, Jeff definitely made that difference. He was my inter-
face with Manning and my continued mentor as an author. Jeff made a positive
contribution to this book and to my writing in general.

ACKNOWLEDGMENTS
xxv
■
Thanks to the following reviewers who read the manuscript at various stages of
its development; your insight and feedback made this a better book: Dave
Campbell, Mark Monster, “Anil” Radhakrishna, Darren Neimke, Michael
Crump, Dave Davis, Joe Suchy, and Rich Dudley.
■
I’d like to thank my mum for making sure I knew the difference between
“you’re” and “your” and that spelling always counts. Hi, Mum!
■
Most importantly, I’d like to thank my wife Melissa and my children Ben and
Abby for sticking by me as I spent day after day basking in the cool glow of my
twin 30-inch displays staring at a mosaic of Microsoft Word, Visual Studio, and
Adobe Illustrator. Writing a book involves the whole family, regardless of whose
name goes on the cover. 
■
A special thanks to my son Ben, who is now learning to read, and is super
excited that his old man “makes robots and writes HUGE books!” for a living. 
■
Finally, I’d like to thank you, my readers. Thank you again for making this possi-
ble. I’ll make it worth the trip.

xxvi
about this book
The goal of this book is to take you, the developer who’s at least a little familiar with
C# and .NET, and help you become an awesome Silverlight developer. If you’re already
an awesome Silverlight developer, I’ve included deep topics to help you learn more
about the platform and how things work under the covers.
 After you’ve read this book, you should be able to confidently design, develop, and
deliver Silverlight applications that meet your application requirements. To facilitate
the learning process, I’ve structured the book to get you developing as soon as possi-
ble, while providing quality, in-depth content.
 Within each chapter, I’ve included a collection of devices to help you build a firm
understanding of Silverlight. The following list explains how each device helps along
the journey:
■
Figures—Visual depictions that summarize data and help with the connection of
complex concepts. Silverlight is highly visual.
■
Code snippets—Small, concise pieces of code primarily used for showing syntacti-
cal formats. You’re usually not expected to type these in and compile, because
they’re incomplete.
■
Code listings—Code that you can type into your project in Visual Studio. In many
cases, it will take multiple code listings to build a working example.
■
Tables—Easy-to-read summaries.
In addition to these learning devices, my site http://10rem.net hosts some image
assets and contains links to the code samples used in this book.

ABOUT THIS BOOK
xxvii
Audience
This book is intended for developers who want to create nontrivial applications using
Microsoft Silverlight 5.
 Though Silverlight provides numerous avenues for interactions with designers,
this book primarily targets people who live and breathe inside Visual Studio. Team
members in the integration role (those who take designs and implement in Silver-
light) will also find the information valuable and useful.
 This book assumes you have at least a passing familiarity with common web stan-
dards such as HTML, CSS, XML, and JavaScript. This content comes up primarily in
integrating with the browser, but also to help draw parallels with other approaches. 
 In addition, and more importantly, this book assumes you have a background
using the .NET Framework and Microsoft Visual Studio. Although I’ll be using C# as
the primary development language, I won’t be reviewing the C# language or explain-
ing basic programming constructs such as classes, methods, and variables. 
 Experience with previous versions of Silverlight isn’t required for this book.
The bits: what you need
This book provides ample opportunity for hands-on learning. But it also provides a
great deal of flexibility by allowing you to learn the material without using the hands-
on content or optional tools. You’ll find it equally valuable to read this book at the
computer, on the train, or wherever else you happen to be.  
 If you want to get the greatest value out of this book and use the hands-on opportu-
nities, the following tools are recommended:
■
Visual Studio 2010 Pro or higher, or Visual Studio Web Developer 2010 (free).
■
You can also use Microsoft Visual Studio 11.
■
Silverlight 5 tools for Visual Studio 2010, including the Silverlight 5 SDK and
WCF RIA Services.
■
The Silverlight toolkit.
■
Microsoft Expression for Silverlight 5 (optional).
■
Microsoft Expression Blend SDK for Silverlight 5 (installed with Blend) for cre-
ating and using behaviors.
You’ll find links to all of these tools at http://silverlight.net/GetStarted.
Roadmap
Developing for Silverlight is a large topic. I’ve endeavored to cover a bit of everything
here, with special emphasis on topics useful to professional developers. To aid your
journey through this book, I’ve broken it up into six parts and a set of appendixes.
Part 1
Core Silverlight
Part 1 covers the most important concepts to understand when learning Silverlight. It
begins with a brief introduction to Silverlight and a step-by-step “Hello World!” exam-

ABOUT THIS BOOK
xxviii
ple. The remaining chapters in part 1 cover XAML, the application model, the plug-
ins, HTML and browsers, out-of-browser applications, and the security model and ele-
vated trust mode.
Part 2
Creating the user interface
Part 2 covers the visible parts of Silverlight applications. In this part you’ll learn about
rendering, layout, panels, transformations, mouse and keyboard input, text display
and editing, controls, animation, UI styles, and custom controls and panels.
Part 3
Working with data and services
Most applications need to access data, whether it’s on the local machine or hiding
behind a service on a remote server. Part 3 covers everything you need to know to
work with all sorts of data in Silverlight, starting with binding, data controls, and input
validation and finishing with SOAP services, RESTful services, XML, JSON, RSS, and
WCF Duplex services.
Part 4
2D and 3D graphics
Most visual elements in Silverlight are composed of graphics primitives. Part 4 starts
off with working with graphics like lines and circles, and show you how to augment
them using effects like blurs and drop shadows. You’ll even learn how to create your
own effects and shaders. To round out the 2D content, part 4 also includes great infor-
mation on working with bitmap graphics. The last two chapters in this part cover 3D
graphics from the basics of points, meshes, lighting, and shading, all the way to creat-
ing your own frame-based animation system.
Part 5
Making the most of the platform
Silverlight is a client-side technology. Because of that, it makes sense to want to inte-
grate more deeply with the computer and tap some of its capabilities. Part 5 covers
cross-platform integration features like full-screen applications, windows, pop-ups,
navigation, file access, and printing, as well as Windows-only features such as p-invoke
and COM automation.
Part 6
Best practices
This book wraps up with a number of best practices you’ll want to apply once you get
the basics under your belt. Specifically, you’ll learn about the MVVM (Model-View-
ViewModel) pattern as well as customizing the installation and loading experience.
Information on techniques for debugging applications rounds out this part.
Appendixes
There are six appendixes in the book. One is included in the print book; the others
are available as a free download from the publisher's website at www.manning.com/
Silverlight5inAction. These appendixes were originally written to be included as part
of the print book, so they’re of the same quality as the rest of the book. Because of

ABOUT THIS BOOK
xxix
their relative niche appeal, they’ve been pulled out and made into downloadable
chapters.
■
Appendix A is included in the print book. It covers setup of the database and
services used in some of the examples.
■
Appendix B covers the basics of media, including media advances in Silverlight 5.
■
Appendix C builds on this to describe how to generate media on the fly and
capture media from the webcam and microphone.
■
Appendixes D, E, and F cover WCF RIA Services. Appendix D introduces WCF
RIA Services and sets up the example project. Appendix E covers security, busi-
ness logic, and techniques for partitioning your application. Appendix F takes
all this information and applies the MVVM information from chapter 33, as well
as advances in the latest version of WCF RIA Services, to provide the best possible
structure for your WCF RIA Services application.
Code conventions and downloads
All the code used in this book is presented in a monospaced font like this. This
code can be in one of a variety of languages; the language used is indicated at the
beginning of the code block. For longer lines of code, a wrapping character may be
used to be technically correct while forming to the limitations of a printed page.
Annotations accompany many of the code listings and numbered cueballs are used if
longer explanations are needed.
 Longer listings of code examples appear under clear listing headers; shorter list-
ings appear between lines of text.
 The source code for all of the examples in the book is available for download from
the publisher’s website at www.manning.com/Silverlight5inAction and from the
author’s website at http://10rem.net.
Author Online
The purchase of Silverlight 5 in Action includes free access to a private forum run by
Manning Publications where you can make comments about the book, ask technical
questions, and receive help from the author and other users. You can access and sub-
scribe to the forum at www.manning.com/Silverlight5inAction. This page provides
information on how to get on the forum once you’re registered, what kind of help is
available, and the rules of conduct in the forum.
 Manning’s commitment to our readers is to provide a venue where a meaningful
dialogue between individual readers and between readers and the author can take
place. It isn’t a commitment to any specific amount of participation on the part of the
author, whose contributions to the book’s forum remains voluntary (and unpaid). We
suggest you try asking the author some challenging questions, lest his interest stray! 
 The Author Online forum and the archives of previous discussions will be accessi-
ble from the publisher’s web site as long as the book is in print.

ABOUT THIS BOOK
xxx
 In addition to the Author Online forum available on Manning’s website, you may
also contact us regarding this book, or anything else, through one of the following
avenues:
■
Pete’s site and blog —http://10rem.net
■
Pete’s Twitter account —http://twitter.com/pete_brown
About the author
Pete Brown currently works for Microsoft helping to educate developers on all things
XAML, as well as the .NET Micro Framework and programmable devices. Prior to joining
Microsoft in 2009, Pete was an architect, engagement manager, and user experience
designer at a consulting company in the Washington, DC, area, where he focused on
Silverlight and WPF development. During that time he was also an International .NET
Association (INETA) speaker, a Microsoft WPF MVP, and a Microsoft Silverlight MVP.
 Pete enjoys writing, woodworking, electronics, programming, making things with
no practical use, acquiring huge monitors, cooking processors, and spending time
with his wife and two children at their home in Maryland.
 Pete’s man cave…er…home office looks like a cross between a Commodore
museum, a radio station, and Dexter’s lab (the one with Dee Dee as a sister, not the
serial killer, honestly)!
 Pete’s site and blog is at http://10rem.net. Drop him a line.
About the title
By combining introductions, overviews, and how-to examples, the In Action books are
designed to help learning and remembering. According to research in cognitive sci-
ence, the things people remember are things they discover during self-motivated
exploration.
 Although no one at Manning is a cognitive scientist, we are convinced that for
learning to become permanent it must pass through stages of exploration, play, and,
interestingly, retelling of what is being learned. People understand and remember
new things, which is to say they master them, only after actively exploring them.
Humans learn in action. An essential part of an In Action book is that it’s example
driven. It encourages the reader to try things out, to play with new code, and explore
new ideas.
 There is another, more mundane, reason for the title of this book: our readers are
busy. They use books to do a job or solve a problem. They need books that allow them
to jump in and jump out easily and learn just what they want just when they want it.
They need books that aid them in action. The books in this series are designed for
such readers.

xxxi
about the cover illustration 
The figure on the cover of Silverlight 5 in Action is a “Janissary in Dress of Ceremony.”
Janissaries were the personal troops and bodyguards of the Ottoman sultan. The illus-
tration is taken from a collection of costumes of the Ottoman Empire published on
January 1, 1802, by William Miller of Old Bond Street, London. The title page is miss-
ing from the collection and we have been unable to track it down to date. The book’s
table of contents identifies the figures in both English and French, and each illustra-
tion bears the names of two artists who worked on it, both of whom would no doubt
be surprised to find their art gracing the front cover of a computer programming
book...two hundred years later.
 The collection was purchased by a Manning editor at an antiquarian flea market in
the “Garage” on West 26th Street in Manhattan. The seller was an American based in
Ankara, Turkey, and the transaction took place just as he was packing up his stand for
the day. The Manning editor did not have on his person the substantial amount of
cash that was required for the purchase and a credit card and check were both politely
turned down. With the seller flying back to Ankara that evening the situation was get-
ting hopeless. What was the solution? It turned out to be nothing more than an old-
fashioned verbal agreement sealed with a handshake. The seller simply proposed that
the money be transferred to him by wire and the editor walked out with the bank
information on a piece of paper and the portfolio of images under his arm. Needless
to say, we transferred the funds the next day, and we remain grateful and impressed by
this unknown person’s trust in one of us. It recalls something that might have hap-
pened a long time ago.

ABOUT THE COVER ILLUSTRATION 
xxxii
  The pictures from the Ottoman collection, like the other illustrations that appear
on our covers, bring to life the richness and variety of dress customs of two centuries
ago. They recall the sense of isolation and distance of that period—and of every other
historic period except our own hyperkinetic present. Dress codes have changed since
then and the diversity by region, so rich at the time, has faded away. It is now often
hard to tell the inhabitant of one continent from another. Perhaps, trying to view it
optimistically, we have traded a cultural and visual diversity for a more varied personal
life. Or a more varied and interesting intellectual and technical life.
 We at Manning celebrate the inventiveness, the initiative, and, yes, the fun of the
computer business with book covers based on the rich diversity of regional life of two
centuries ago‚ brought back to life by the pictures from this collection.

Part 1
Core Silverlight
When you’re learning a new technology, it’s always a good idea to start at
the core: the core concepts, the core features, the core technologies, and the
core skills. Taking that as a given, the first six chapters of this book will get you
the grounding you need to learn about Silverlight and make good decisions
about how you write your applications.
 In the first chapter, you’ll learn what Silverlight is and how it fits into the
developer platforms offered by Microsoft. You’ll spend the remainder of the
chapter building your very first Silverlight application. Believe me, it won’t be a
boring old “Hello World!”
XAML is the XML-based approach to defining the UI for Silverlight, WPF,
Windows Phone, and Windows 8 XAML applications. These chapters take a deep
look into XAML so that you’ll understand how it works, how to handle
namespaces, how to map objects into XAML, and much more.
 Silverlight differs substantially from other client and web technologies when
it comes to its application model and how the plug-in integrates with the system.
It’s essential and interesting to learn how all the pieces fit together, so I’ll cover
that next.
 Building on what you learned about the app model and web page plug-in, I’ll
show you how Silverlight can integrate with web applications. Silverlight has
deep integration with the browser and HTML while running on a web page.
You’ll learn how Silverlight can interact with the web page on which it resides,
even to the point of manipulating the page’s DOM from within Silverlight.
 From there, I’ll turn to an increasingly popular model for Silverlight: the out-
of-browser application. Application developers, especially those developing

business applications, have used Silverlight to create rich desktop applications that
install from the web but otherwise look and behave like any other native application.
It’s the best of both worlds.
 Part 1 wraps up with a look at the security model used by Silverlight, including how
it determines whether code is safe to run and how to get elevated permissions to
escape from the sandbox.
 First, you’ll explore the basics of Silverlight and build your first Silverlight applica-
tion. Come with me—I think you’ll enjoy the ride.

3
Introducing Silverlight
First, let me thank you for starting at chapter 1. I’m one of those people who tend
to read magazines back to front and skim technology books, so I appreciate it when
someone reads a book’s chapters in order. Then again, maybe you read this book
backward as well. In that case, you’ll find the “Hello World!” walkthrough in this
chapter to be a refreshingly simple take on building Silverlight applications unen-
cumbered with patterns such as Model View ViewModel (MVVM), words such as
DependencyProperty, and technologies such as Windows Communication Founda-
tion (WCF) Rich Internet Application (RIA) Services. For the rest of you, don’t
This chapter covers
■
Silverlight, the web, and WPF
■
The best applications for Silverlight
■
Getting started with Silverlight
■
Changes in Silverlight since the previous 
edition of this book
■
Building your first Silverlight “Hello World!” 
application

4
CHAPTER 1
Introducing Silverlight
worry—we’ll cover each of those throughout the rest of the book, steadily building
our Silverlight skills as we go.
 Because you’ve picked up a Silverlight book, you’d probably like to know what Sil-
verlight is. Luckily, I’m horrible at marketing, so I’ll put it simply: Silverlight is a cross-
platform .NET runtime, a cross-browser plug-in, and a set of Windows-based developer
tools for building RIAs. At its heart, Silverlight is an implementation of the concepts
and standards from Windows Presentation Foundation (WPF) such as binding, the
property system, and Extensible Application Markup Language (XAML) in a cross-
platform version of the .NET Common Language Runtime (CLR) and libraries.
 There. I think that paragraph managed to get all of the acronyms defined for the
rest of the book. Then again, this is a Microsoft technology, so expect more acronyms
before we’re through.
 Silverlight runs on Windows and Mac through Microsoft-supplied plug-ins as well
as on Linux through the Moonlight project. It’s the primary development platform
for Windows Phone. You’ve likely seen demos of it running on set-top boxes con-
nected to TVs and serving up ads and content on the Xbox. Put simply, short of
ASP.NET, Silverlight is the broadest reaching technology ever produced by Microsoft.
 Silverlight applications work on the web as well as on the client. You can create vir-
tually any type of application in Silverlight, from web content, to widgets, to media
players, to full-blown client applications.
 By the end of this chapter, you’ll have created your first functional Silverlight appli-
cation, a Twitter search client with nice visualization of the tweets. You’ll be intro-
duced to XAML, binding, networking, controls, and much more—even a little LINQ to
XML. These are all topics I’ll dive deeply into in the rest of the book. First, you’ll learn
a bit about where Silverlight fits into the developer ecosystem. This is a big question
for many and needs to be resolved up front. I’ll follow that up with a look at the types
of applications for which Silverlight is well suited. After that, I’ll explore the features
and capabilities that have been added since the first edition of this book.
1.1
A Silverlight primer
Silverlight’s place in the world has evolved since its original inception. Market forces
and customer preferences have both led to Silverlight moving more toward private
web and line-of-business applications as opposed to broad-reach public websites and
applications. Clearly both Microsoft’s customers and partners have moved to a stan-
dards-based public web. Nevertheless, there are great ways and reasons to use Silver-
light on the public web, especially while the HTML standards are still catching up to
what plug-ins like Silverlight can accomplish. Of course, on the desktop and in the
enterprise, Silverlight is as viable as ever.
 In this section, I’ll introduce Silverlight in context, looking at how it fits into the
developer stack both on the web and on the desktop. I’ll then look at some of the
types of applications for which Silverlight is well suited. 
 Silverlight got its start as a web page plug-in, so that’s where we’ll start as well.

5
A Silverlight primer
1.1.1
Silverlight and the web
Silverlight sits in that interesting place between desktop applications and browser
applications. In many ways, when in the browser it’s like a little traditional desktop
application embedded in HTML. Of course, the same can be said of many JavaScript
applications, themselves modeled on the code-on-the-client desktop application
paradigm.
 Great frameworks such as jQuery and the oft-confused HTML5 and CSS3 further
muddy the waters. Where’s Silverlight’s place on the web? Why should you use Silver-
light instead of these other technologies?
 I’ll give you a few reasons:
■
Silverlight has top-tier media support, including digital rights management
(DRM), far more advanced than the proposed HTML5 standards. It’ll be a while
before HTML5 catches up across all browsers.
■
Silverlight is a no-brainer if you’re already a .NET developer looking to expand
to other platforms. It’s simply easier to develop with and in.
■
Silverlight has best-of-class development and debugging tools.
Don’t get me wrong; I think HTML5 and CSS3 and even JavaScript are a great thing for
the web—exciting and capable. Having said that, I contend that Silverlight has more
advanced authoring tools, faster execution, and more capabilities than HTML5 cur-
rently has. HTML5 will continue to raise the floor, driving up the quality and experi-
ence across the spectrum of platforms and developer tools. On the public web, HTML5
will eventually catch up to the capabilities of Silverlight for the majority of typical web
scenarios and plug-ins won’t be needed. For many public sites and applications, we’ve
already reached that point due to the proliferation of plug-in–hostile tablets.
 I don’t think that the code-on-the-client application development approach is
going to completely disappear. Though doom has been forecast for many major devel-
opment approaches over the years, few have declined when another rose in popular-
ity. Silverlight and HTML5 will provide more options for how to implement the
solution you need in the most optimal way, using the tools you’re comfortable with
and the skills you already have. The balance of what code you put in each technology
will be the real point of debate for development teams. In addition, the skills you
learn as a Silverlight developer will port quite nicely to Windows 8 XAML, once you
decide to adopt that operating system.
 Remember that HTML/CSS/JavaScript and Silverlight aren’t mutually exclusive.
Silverlight applications can happily coexist on a page with JavaScript applications,
each complementing the other with features that play to their strengths.
 Silverlight is far more than a web technology. Though it can live on a web page, it’s
also common to have out-of-browser Silverlight applications, either connected to ser-
vices or simply using resources on the client. In those instances, you may wonder
when to use WPF and when to use Silverlight.

6
CHAPTER 1
Introducing Silverlight
1.1.2
Silverlight and WPF
Silverlight and WPF were born of the same ideas. WPF came first and broke the ground
required to make XAML a UI-friendly markup language. WPF also introduced you to
dependency properties and binding, storyboard-based animation, and subpixel-ren-
dered vector UIs. WPF was, and continues to be, an amazingly rich platform for devel-
oping both traditional Windows and natural user interface (NUI) applications.
 But WPF is large and complex. It’s also deeply rooted in Windows, with no good
way to substitute alternate stacks for those it relies on. WPF also relies on the rather
outdated and web-unfriendly code access security model for application security. So,
when Microsoft decided to enter the RIA space with a CLR-based vector UI technology,
it took the concepts and some of the code from WPF and reimplemented them in a
smaller, tighter, and more platform-independent way.
 Silverlight primarily is a subset of WPF
and .NET 4 with significant additions. Some
of the additions, such as the Visual State
Manager, have been migrated back from
Silverlight into WPF. Others, such as Deep
Zoom, Media Stream Source, and the web-
cam and microphone APIs, are Silverlight-
only features, unlikely to be ported to WPF.
Others like XNA sound and 3D APIs are
from entirely different technologies. Ignor-
ing alternative solutions to the same prob-
lems, figure 1.1 shows this relationship
using our friend, the Venn diagram. 
 I recommend that developers new to both technologies learn Silverlight before
learning WPF. In general, you’ll find it easier to learn Silverlight first and scale up to
WPF, should your needs dictate. Silverlight is smaller, typically having a single
approach to solving a given problem, whereas WPF may have several solutions for the
same task. Though Silverlight doesn’t have everything WPF has, Silverlight is an excel-
lent, capable development platform and can cover many types of applications you
would’ve previously written in Windows Forms, WPF, or even HTML.
1.1.3
Types of Silverlight applications
You can build just about anything you’d like using Silverlight. Of course, Silverlight is
better suited for some types of applications over others. For example, though possible,
you wouldn’t necessarily want to build an entire website using Silverlight; there are
better tools for the job. The most common types of applications where Silverlight is a
good fit are media, business, and games.
Media: Silverlight excels at media. When Silverlight 1.0 was first introduced, one of
the few capabilities it had was an excellent media stack. Silverlight through version 5
has built on that to include new media capabilities such as smooth streaming,
Figure 1.1
Silverlight is primarily a subset of 
WPF with extras added. Ignoring alternative 
solutions to the same problems, the places 
where WPF differs most are in the integration 
with the Windows OS and the access to the 
full .NET framework.

7
A Silverlight primer
enhanced navigation with trick play (media playback rate changes without pitch
changes), pluggable codecs using the Media Stream Source API, support for remote
controls and media keys, and even the DRM technologies required for the large con-
tent producers to adopt Silverlight.
 Silverlight’s early focus on media was both helpful and hurtful. Video on the web is
a great way to gain product adoption, especially when you have a capable high-def
video technology. 
Business: Early on, many potential Silverlight developers failed to see past the media
roots and missed the rich business capabilities Silverlight provides. Starting with ver-
sions 3 and 4, Silverlight gained serious business capabilities. From simple things such
as sync and async validation, to patterns such as MVVM and Prism, and entire middle-
tier frameworks such as WCF RIA Services, Silverlight showed itself to be a mature plat-
form, able to absorb the best practices from other areas and build on them.
Games: Though business and media applications certainly are great staples,
another fun application type is games. HTML5 will likely turn out to be a more popu-
lar broad-reach gaming platform, but Silverlight has good support for casual games,
including the ability to generate bitmaps on the fly, create sound from bits, loop audio
in the background, play real-time sound effects, manipulate and render 3D scenes,
and more. The community has successfully ported over physics and gaming engines to
Silverlight, making it even easier to create complex casual games.
 There are many other types of Silverlight applications, ranging from ads, to photo
viewers, to social media clients, to analogs for virtually every type of major desktop and
web application. Some, such as desktop applications, weren’t possible with Silverlight
2, the version used in the first edition of this book. Let’s take a high-level view of what
has changed in that time. For readers of the Silverlight 4 edition, I’ll mention some
key new features in Silverlight 5 as well.
How this book is organized
When I turned in the first complete version of this book, it came in at over 1,200 pages.
I can’t remember the last time I owned a 1,200-page printed book, but I’m pretty sure
that’s an awful lot of paper and shelf space.
Rather than open the publisher up to lawsuits for all the back injuries this was likely
to cause, and also end up paying for all the damage caused by broken bookshelves
sitting above your prized first-edition 1977 fine china Star Wars collector plates, I de-
cided to break up the book, with all material included in the purchase price of the
book. (Some reviewers suggested breaking up this book into a series of volumes, so
perhaps I could sell Encyclopedia Silverlightica door to door.) Material that isn’t nec-
essarily core to the book, or not really new to Silverlight 5, has been moved into a set
of appendices. Specifically:
■
Media Basics and Raw Media, Webcam and Microphone, which didn’t have
substantial product updates for Silverlight 5

8
CHAPTER 1
Introducing Silverlight
If you’re reading this online or in an e-reader, you should have all the chapters
already. If you’re reading this in print, first of all, you may stop and send me a thank-
you note for your back, and after that, download the free appendices from www
.manning.com/Silverlight5inAction. With those appendices, as a purchaser of this
book you get the whole book. Consider it the Director’s Cut of Silverlight 5 in Action.
1.2
A brief history of Silverlight
The first edition of this book was written for Silverlight 2. Silverlight 3, 4, and 5 have
added an amazing number of new capabilities to the platform in all areas, from core
capabilities, to device access, to the introduction of both trusted and sandboxed in-
browser and out-of-browser client applications. Silverlight has had five major releases
in the past four years, as shown in table 1.1.
Table 1.1 shows some of the major enhancements delivered in each version of Silver-
light over the last few years. In the remainder of this section, I’ll look at the features,
especially those new to Silverlight 4 and 5, in more detail. The advancements in Silver-
light can be loosely grouped into four main areas: business and client applications,
media and graphics, user interaction, and text.
1.2.1
Features for business and client applications
In 2008 and 2009, Silverlight 2 was just starting to gain adoption. It was a brand-new
technology from Microsoft (the managed code version was, anyway), one with strong
competition from Flash/Flex and even Java. Though Silverlight 2 could’ve been used
(continued)
■
WCF RIA Services, which—while an excellent three-chapter set of content if I
do say so myself (especially the new content on MVVM)—simply wasn’t core
knowledge required by a majority of readers.
So, both sets of chapters were voted off the island. Happily, they’re still available for
all our readers.
Table 1.1
Silverlight versions released for the desktop
Version
Release date
A few key features
1.0
Sep. 5, 2007
Media, basic graphics; JavaScript for code
2
Oct. 14, 2008
First release with the .NET runtime; rich media
3
July 9, 2009
Extensible media; out-of-browser; shaders; GPU acceleration
4
April 15, 2010
Webcam and Microphone; WCF RIA Services 1.0; validation
5
Dec. 9, 2011
3D; vector printing; OpenType text layout; trick play; more

9
A brief history of Silverlight
to build rich business applications, it didn’t yet have the chops to be a strong con-
tender in that space. Three versions later, that story has changed. Many of the features
in this section are useful in applications of all sorts; I hate to classify them under the
heading of “business,” but that’s the largest consumer of these features.
 Input validation, covered in chapter 18, was one of the biggest new features for
business applications. Silverlight didn’t add just validation but included support for
validation through attributes, validation through exceptions, and even asynchronous
validation, all of which work with the Silverlight controls. Silverlight even made it pos-
sible to customize the style of the validation information provided to the end user.
 Validation relies heavily on the binding system in Silverlight. The teams added a
number of new features to binding, including a DataContextChanged event, finer con-
trol over when the data source is updated, and the ability to bind to properties added
to objects at runtime. I cover all these new features in chapter 16.
 One technology that builds heavily on the validation stack is WCF RIA Services
(ebook appendices D, E, and F). A good bit of the validation functionality rolled into
the Silverlight runtime came from that project. WCF RIA Services provides a way to
share validation and logic between the client and server as well as a framework for val-
idation, data access, and security, shareable between Silverlight and other clients.
WCF RIA Services builds on the WCF stack, but it’s not the only enhancement there.
The Silverlight networking stack, described in chapters 19 through 23, was greatly
enhanced to support in-browser and out-of-browser operation, as well as SOAP 1.2.
When combined with technologies such as the WCF Web API (chapter 21), networking
has gotten both more flexible and more interesting.
 The Silverlight team has also done a lot to optimize networking performance and
reduce latency in Silverlight 5. These changes make it easier to use Silverlight behind
a firewall where the services often have different requirements than those on the
internet. Of course, the addition of technologies like tasks from the Task Parallel
Library (TPL) and the availability of Reactive Extensions (Rx) all help to make net-
work operations simpler. You’ll find out more about those in chapter 19 as well.
 Despite the promises of a paperless office, printing (covered in chapter 31) is still a
staple of business applications everywhere. Printing in Silverlight 4 was optimized for
relatively short reports or documents, as well as for the equivalent of print-screen
operations. Silverlight 5 adds a new PostScript, or true vector, printing mode to the
existing bitmap approach, making serious printing and print preview now possible.
 Silverlight has supported out-of-browser applications since version 3, with trusted
out-of-browser applications added to Silverlight 4. Silverlight 4 provided COM automa-
tion support for calling compatible APIs on Windows. Silverlight 5 expands on the
capabilities of trusted applications by giving them more system and file access, even p-
invoke access to call APIs. You’ll learn about out-of-browser applications in chapter 5.
Because Silverlight 5 enables trusted applications to be hosted in-browser as well, we’ll
take a deeper dive into system integration in chapter 32 and file access in chapter 30.

10
CHAPTER 1
Introducing Silverlight
 For really big applications, or those that must process a lot of data, Silverlight now
supports 64-bit browsers with a special 64-bit version of the plug-in for Windows. The
64-bit support enables applications to use more memory and resources, and avoid the
(transparent to you) thunking and virtualization required on a 32-bit browser, often
resulting in a decent performance increase.
 One of the next major areas of enhancement for Silverlight is media.
1.2.2
Media and graphics enhancements
Silverlight was first and best known for its media capabilities and had strong media
support built in from day 1. The Silverlight media team didn’t rest on that success,
instead pumping out enormous advances in media in each update to Silverlight
through Silverlight 4. Silverlight 5 includes modest, but still good, improvements in
this same area.
 Silverlight 2 included a Media Stream Source API for pushing media through the
pipeline. That API required that the bits be pre-encoded into one of the formats
natively understood at the time. Though useful, this pre-encoding could lead to dou-
ble-encoding—and made transcoding even more difficult. 
 Silverlight 3 added support for pushing raw video and audio out of custom Media
Stream Source implementations, as covered in ebook appendix C. As a result, you can
write a managed codec for any type of media or even do something crazy like I did and
use it to generate audio and video in real time for an emulator. Another option for gen-
erating video or at least images in real time is the bitmap API covered in chapter 25.
 Speaking of codecs, one of the new codecs added in Silverlight 4 was H.264 for
video. H.264 has emerged as one of the most popular codecs for TV and video for
devices. It was a logical choice for an additional native Silverlight format because now
content producers can use even more of their content without re-encoding. Silverlight
5 expanded on the H.264 support by adding hardware decoding of non-DRM media to
improve performance, especially on lower-power devices. To appeal to the same audi-
ence, Silverlight also continued to improve DRM capabilities, including the addition
of offline DRM and seamless switching between DRM media sources.
 One common request in the media space was for the ability to play video at 1.x or
even double speed. Commonly called “trick play,” this has been added to Silverlight 5
and is covered in ebook appendix B. Now you can watch my tutorial videos in 20 min-
utes instead of half an hour, with automatic pitch correction so I don’t sound like a
chipmunk (although I may inhale some helium before my next recording just to mess
with you).
 Would you prefer to watch Silverlight video on your TV in your living room? Silver-
light 5 adds support for remote controls and the media keys so many of us have on our
desktop and laptop keyboards. This new feature is covered in ebook appendix B.
 Another exciting feature introduced in Silverlight 4 was built-in support for video
and audio capture devices or, specifically, webcams and microphones. Though not yet
quite at the level that would allow you to create a real-time video chat application, the

11
A brief history of Silverlight
support does open up a number of new possibilities for application development.
Webcam and microphone support are both covered in ebook appendix C.
 Silverlight 4 added support for all formats of portable network graphics (PNG),
something that was only partially supported in previous versions. The same release
also introduced support for pixel shaders and a set of built-in performance-tuned
effects such as drop shadow and blur, covered in chapter 24.
 Easily the most anticipated feature in Silverlight 5, the addition of the new GPU-
accelerated 3D programming interface will enable all sorts of scenarios from games
to data visualization to custom third-party 3D rendering and scene management sys-
tems. It even let me create a nice animated retro Amiga demo, as you’ll see in chap-
ters 26 and 27.
 With all of these advancements, plus a number of performance optimizations and
even additions such as the Microsoft Media Platform Player Framework, Silverlight
continues its leadership in the media space, offering everything you need to build
rich, media-centric applications. 
 Sometimes, what you want is more than a media experience; you want an applica-
tion that can be truly interactive. Silverlight has your back there, too.
1.2.3
User interaction
Since Silverlight 2, user interaction has received a number of important enhance-
ments. Two of the most requested features, a mouse scroll wheel and right-click
mouse support (both covered in chapter 9), are baked into the Silverlight core run-
time. Silverlight 5 builds on that with the addition of mouse multiclick support (think
double-click), also covered in the same chapter.
 One of the newer and hotter user interaction mechanisms is multitouch, also cov-
ered in chapter 9. The ability to support multipoint interaction with the UI, especially
in kiosk and handheld/tablet scenarios, is quickly becoming a requirement for many
applications. Silverlight includes core runtime support for multipoint touch interac-
tion with Silverlight applications.
 Another user interaction piece missing from Silverlight 2 was the easy ability to
show dialogs and pop-up windows (simulated) within your applications. Silverlight 5
features not only those (covered in chapter 28) but also notification toast (pop-ups
typically located at the bottom right of the screen), covered in chapter 5. Also covered
in chapter 28, Silverlight 5 adds in a new option—real operating system windows—
which enables you to create windows that can run on different displays, or simply over-
lap and act like normal windows. 
 Finally, all the interaction in the world has no value if your user can’t read the text
on the screen. Happily, Silverlight includes plenty of improvements in text as well.
1.2.4
Text
By far the biggest improvement to text since Silverlight 2 is proper ClearType font ren-
dering. Silverlight 2 performed only grayscale rendering, giving text a fuzzy appear-

12
CHAPTER 1
Introducing Silverlight
ance unless you carefully picked your color schemes. Silverlight 5 has expanded on
this to provide better and faster text rendering, with performance and clarity-targeted
options much like those offered by WPF 4. Chapter 10 explains how to use these new
features.
 Although ClearType may be important for font rendering in general, right-to-left
or bidirectional (BiDi) text is something that’s absolutely essential for the correct ren-
dering of many non-European languagesSilverlight supports not only BiDi text but
also input method editors (IMEs) for complex composite characters for many lan-
guages, especially eastern languages.
 Silverlight 5 added enhancements to better improve layout and typography. For
example, multicolumn and linked text (chapter 11) now enables magazine-like lay-
outs with simulated fluid text flow around other elements. Tracking and leading,
always important to the typography aware (you know, the people who go around wear-
ing shirts that say “Helvetica”), was also added.
 When it comes to typography, my favorite addition to Silverlight 5 is the excellent
support for OpenType. The text team added support for ligatures, alternates, style
sets, and much more. They even expanded on the capabilities available for eastern
languages. Chapter 10 goes into detail on how to use many of these new features.
 Finally, one great improvement to text rendering and entry is the inclusion of the
RichTextBox control and the new read-only RichTextBlock. These controls allow you
to display or edit text that includes multiple fonts and styles. The controls can even
embed other elements that can be interactive when the control is in read-only mode.
 ClearType, BiDi, and IME text, as well as the new text layout functionality and the
rich text box, are all covered in chapter 11, along with insight into the text-rendering
stack in general and how to apply these new features to text throughout Silverlight.
 Those are the major items. Of course, many more improvements are sprinkled
throughout. In addition to capturing the major items in this book, I’ve added infor-
mation based on the experience gained from working with Silverlight since its incep-
tion as well as knowledge gained from working closely with the Silverlight and WPF
product teams. In important areas, such as layout and rendering, I’ve gone deeper
than needed by the average developer to provide some insight into the inner workings
of Silverlight.
 That was a lot to cover. I hope you enjoyed reading this list of exciting new features
as much as I enjoyed writing it. Before we start covering individual feature areas, we’ll
need to get our development environment set up and build a small “Hello World!”
application. 
1.3
Getting started with Silverlight development
If you’re a .NET developer, you’re well on your way to becoming a Silverlight devel-
oper. Silverlight builds on the .NET Framework and uses the same tools as other .NET
Framework applications. You’ll use Visual Studio and, optionally, Expression Blend to
build your applications. You’ll be able to turn to CodePlex, GitHub, and other open

13
Getting started with Silverlight development
source sites for sample code to use. And, of course, you’ll have a huge community of
peers to lean on when trying to figure out those hard problems.
 Before you can do any of that, though, you need to make sure your development
environment is set up.
1.3.1
Setting up your development environment
Silverlight 5 requires Visual Studio 2010, at a minimum, to work with projects and
build the solutions. The multitargeting support of Visual Studio 2010 means that your
applications can target Silverlight 3, 4, or 5, once you have the Silverlight 5 tools
installed.
 If you don’t have a version of Visual Studio 2010, you can get the free Visual Web
Developer 2010 Express from Microsoft at www.microsoft.com/express/Web/. The
free web developer tools enable you to create Silverlight 5 applications as well as
ASP.NET applications. If you want additional features and tools as well as the ability to
create more than just web applications, upgrade to Visual Studio 2010 Pro or higher.
 Once you have installed Visual Studio 2010, visit http://silverlight.net/getstarted/
and use the Web Platform Installer or manual installer to install the Silverlight 5 tools
and SDK as well as any optional components. The Silverlight tools for Visual Studio
2010 and the SDK contain everything you need to develop Silverlight 5 applications,
including WCF RIA Services 1.0 SP2.
 Optionally, you may want to install Microsoft Expression Blend for Silverlight 5.
The link for that is also available on the Get Started page on Silverlight.net. Expres-
sion Blend provides a designer-friendly set of tooling that makes creating complex
animations, behaviors, and layouts a snap.
 Microsoft and the community have created a number of helpful sites that will
make your learning process go smoothly.
1.3.2
Helpful sites
The main MSDN home page at http://msdn.microsoft.com is a great starting point for
both web-based Silverlight and desktop Silverlight applications. You’ll find videos and
tutorials (some of which I wrote/recorded) there as well as pointers to additional
resources.
 One of those additional resources is the official Microsoft Silverlight developer site
at http://silverlight.net. There you’ll find videos, sample applications, tutorials, add-
ons, and the community forums, all designed to help you be the best and most effi-
cient Silverlight developer you can be.
 In addition to Silverlight.net, http://channel9.msdn.com includes interviews with
community and product team members, as well as tutorials.
 Also, as a completely shameless plug, you may want to subscribe to my own blog at
http://10rem.net. You can also follow me on Twitter; my id is @pete_brown.
 One other place you’ll want to visit is Dave Campbell’s Silverlight Cream: http://
bit.ly/SilverlightCream. Dave has done a spectacular job, daily compiling the best

14
CHAPTER 1
Introducing Silverlight
Silverlight posts on the web. From Dave’s link blog, you’ll get an idea of what other
community member blogs to subscribe to.
 At this point, your developer machine is set up, you’ve subscribed to a few blogs,
created an account at Silverlight.net, and maybe even poked around a little on the
sites. Before we get into the features in detail in the rest of the book, I thought it’d be
good to see how easy it is to build your first Silverlight “Hello World!” application. 
1.4
Building your first Silverlight web application
Expectations have come a long way since the days of C, where just getting “Hello
World!” to compile and output to the screen was considered a great accomplishment.
If we were talking assembly, I’d go with that, but we’re not. Silverlight is so easy to use,
you need a much higher bar for your first application.
 Rather than rehash the tired “Hello World!” example, I think it’d be neat if your
first application did something interesting—like hit a public service on the web. Twit-
ter is the ubiquitous example, and far be it for me to buck a trend.
 This application will be a Twitter search application. You’ll hard-code a search
string and use that to hit a network service. You’ll take the results that come back and
parse them using LINQ to XML. When displaying the data, you’ll use ListBox templat-
ing and binding to show the power of the lookless UI and XAML. As we’ll learn
throughout this book, control implementation is completely independent of the
XAML UI representation of the control. That is, the runtime doesn’t care what the
control looks like as long as it behaves as expected. The term to describe this is called
“lookless”. The end result will look like figure 1.2.
Figure 1.2
The end result of the 
Twitter search “Hello World!” 
example. That’s a plain-old 
ListBox with your own template. 
The data came from Twitter and 
was parsed using LINQ to XML.

15
Building your first Silverlight web application
This is a surprisingly functional application for your first application. You’ll also find it
extremely easy to create using your current C# skills plus the new Silverlight skills you’ll
start building in this chapter and continue to build throughout the rest of this book.
1.4.1
Project setup
Open Visual Studio 2010. Choose File > New Project and create a Silverlight Applica-
tion project. The name isn’t important, but I chose FirstSilverlightApplication for mine.
Figure 1.3 shows the dialog with the correct project type selected and named.
Figure 1.3
Visual Studio 2010 New Project dialog with the correct project type selected and named
Once you click OK, you’ll be
presented with another dia-
log. This dialog (figure 1.4)
provides options specific to
the Silverlight project.
Figure 1.4
The New Silverlight
Application options dialog

16
CHAPTER 1
Introducing Silverlight
Typically, you’ll leave the options at their default values and click through this dialog.
But it’s important to understand what’s available to you. Table 1.2 describes each of
the options presented in this dialog.
Once the new solution is created, you’ll see two projects. The first is the Silverlight
application; the second is the website. The website project contains a folder ClientBin,
which will contain the compiled and packaged output (XAP file) from your Silverlight
application. That XAP file is what the webpage will download and load into the
browser plug-in.
 It also contains two test pages that may be used to test your Silverlight application.
By default, the ASPX page is set as the startup page, but you can use the HTML page if
you later plan to host on a non-.NET server. (Yes, Silverlight applications may be
hosted by any HTTP server and not just Internet Information Services [IIS] running
ASP.NET.)
 If you run the application at this point, you’ll get a blank page in the browser. At
first glance, it’ll look like Silverlight didn’t load. But right-click on that empty space
and you’ll get the Silverlight menu, which shows you that you are, indeed, running a
Silverlight application.
 With the project open and ready, it’s time to turn to the UI.
1.4.2
User interface
Open the MainPage.xaml file; it’s usually open by default when you create a Silver-
light project. MainPage.xaml is the start page for your application, set as such by a sin-
gle line of code inside App.xaml.cs. XAML is the markup language used by Silverlight.
Table 1.2
The New Silverlight Application dialog options
Option
Description
Host in a New Website
Silverlight applications, even out-of-browser apps, are served from a web-
site. You can also serve them from a static HTML page on the file system, 
but this is a limiting option, as you’ll see in chapter 4. You’ll typically want 
to leave this option checked, unless you have an existing website you want 
to use when building your application.
New Web Project Name
Provide a project name for the website. The default is usually sufficient.
New Web Project Type
If you’re an ASP .NET programmer and have a preference as to the  ASP .NET  
project type, set it here. Otherwise, leave it set to the default.
Silverlight Version
This option allows you to select Silverlight 3, Silverlight 4, or Silverlight 5. 
For this book, every example will assume Silverlight 5. You only have one 
plug-in installed, but if you target an older version, Silverlight will run in 
quirks mode to ensure compatibility.
Enable WCF RIA Services
Check this option if you want to link the web project to the Silverlight proj-
ect as a WCF RIA Services endpoint. Doing so enables additional compile-
time tooling.

17
Building your first Silverlight web application
We’ll cover the basics of XAML in chapter 2, but throughout the book you’ll learn
about additional features of XAML.
 One key thing to know up front is that XAML is a representation of CLR objects.
Each tag you see in XAML has an equivalent CLR object behind it. 
 Inside the opening and closing Grid tags, add the markup from listing 1.1 to add
two objects to your UI, specified as elements in XAML.
<Button x:Name="GetTweets" Content="Get Tweets" 
        Height="23" Width="75"
        Margin="12,12,0,0"
        HorizontalAlignment="Left"
        VerticalAlignment="Top" />
<ListBox x:Name="TweetList" Margin="12,41,12,12"/>
That markup creates two elements on the page: a Button and a ListBox. In the design
view, you should end up with a form that looks like figure 1.5.
 The editor you see is split into two parts: the top part is the XAML design surface
and preview pane. The bottom part is the XAML markup. Depending on your settings,
these may be two different tabs in the editor.
Listing 1.1
XAML Markup for the Hello World Twitter UI
Button Control
ListBox Control
Figure 1.5
The Visual Studio 2010 IDE showing the markup correctly entered for MainPage.xaml

18
CHAPTER 1
Introducing Silverlight
You can drag controls into the markup or directly on to the design surface. The
approach you take depends on what is more comfortable to you and which gets the
job done more efficiently. For obvious reasons, the source listings in this book will list
the XAML markup rather than myriad drag-and-drop instructions.
 If you run the application at this point, you’ll have a simple Silverlight UI with a
button and an unpopulated ListBox. If you get any compile errors, ensure that you
pasted the content into the grid as mentioned and that your tags are all matched and
correctly closed following normal XML rules.
 That’s about as basic an application as you can get. If you want, you can even
change the button content to say “Hello World!” instead of “Get Tweets.”
TIP
The code we’ve used for the “Hello World!” example, like all code in Sil-
verlight, will run on the client inside the Silverlight plug-in. In this case, it’s
also running inside the browser. The web server code is simply serving up the
containing page, and the XAP file it references. If you’re used to coding
ASP.NET applications, that’s a bit of a shift. In that case, think of Silverlight
apps more like the HTML and JavaScript on the client rather than like the
server-side code.
If you ran the application, close the browser and stop debugging. Back in Visual Stu-
dio, double-click the Get Tweets button on the design surface to create an event han-
dler in the code-behind, and automatically navigate to that code. (You could also do
this by typing the event name into the XAML, but we’ll look more at that in later chap-
ters.) The event handler will be used in the next section, where you make a call to the
Twitter search API.
1.4.3
Calling Twitter search
The next step is to call the Twitter search API. Fill out the event handler you just cre-
ated in the code-behind to include the code in listing 1.2.
private void GetTweets_Click(object sender, RoutedEventArgs e)
{
  WebClient client = new WebClient();
  client.DownloadStringCompleted += (s,ea) =>
    {
      System.Diagnostics.Debug.WriteLine(ea.Result);
    };
  client.DownloadStringAsync(
    new Uri("http://search.twitter.com/search.atom?q=silverlight"));
}
The code here does a few interesting things. First, it creates an instance of WebClient,
one of the easiest-to-use network clients in Silverlight. You’ll learn about the WebClient
in detail in chapter 19. It then sets up an event handler using a lambda expression to
respond to the results. Finally, it asynchronously calls the method to download the
result string from search.twitter.com. The search is for tweets mentioning “Silverlight.”
Listing 1.2
The event handler for the GetTweets button Click event
Temporary 
debug code

19
Building your first Silverlight web application
TIP
The seemingly strange lambda expression approach used here, signified
by the “s,ea => {…},” simply uses an anonymous delegate (an unnamed func-
tion) as the event handler. The beauty of this approach is that it doesn’t clut-
ter your code with tons of event handlers that are part of discrete processes.
I’ll use these in a number of places throughout the book. You can learn more
about lambda expressions in the C# language on MSDN at http://bit.ly/
CSharpLambda.
The network call is asynchronous because all network calls in Silverlight are asynchro-
nous. This can take a bit of getting used to but is easy to deal with once you’ve done it
a few times. Chapter 19 goes into detail on how to use the asynchronous methods as
well as the reasons behind them. It also discusses using the Task class and Reactive
Extensions to manage your async code.
 If you run the application (if F5 doesn’t do it for you, right-click the test ASPX page
in the web project and choose View in Browser), click the Get Tweets button, and view
the output window (Ctrl-W, O if it isn’t visible), you’ll see that you’ve already built
enough to call Twitter and pull back the results in XML format. Not bad for a few lines
of code! Your next step is to parse the results and display them in the ListBox control.
1.4.4
Parsing the results and binding the ListBox
If you look in the output window from your last run, you’ll see that the result format is
an Atom-formatted XML document with an entry node for each of the results. In Sil-
verlight, you can parse Atom a couple ways: you can use the built-in parsing of the
SyndicationFeed class or you can use LINQ to XML to parse the results. Both
approaches are covered in detail in chapter 22.
LINQ to XML is a great technology and has many uses above and beyond Atom doc-
ument parsing, and it’s used far more often, so let’s go that route. You’ll end up with a
little more code than the alternative approach, but I think it’s worth it for this example.
TWEET CLASS
Before you do the actual parsing, you’ll need to create a simple class to hold the con-
tent you’re interested in. In the Visual Studio Solution Explorer pane, right-click the
Silverlight project and choose Add > Class. Name the class Tweet.cs and fill it out so it
looks like listing 1.3.
using System;
namespace FirstSilverlightApplication
{
    public class Tweet
    {
        public string Message { get; set; }
        public Uri Image { get; set; }
    }
}
Listing 1.3
The Tweet class

20
CHAPTER 1
Introducing Silverlight
The Tweet class will be used to contain a tweet in your application. In Silverlight,
you’re encouraged to use strongly typed classes to represent all your entities or model
objects. If you’re familiar with using recordsets or similar loosely typed approaches,
you’ll find they either don’t work well in Silverlight or don’t work at all.
 Save that class and move back to MainPage.xaml.cs code-behind file. Somewhere
inside the MainPage class definition, add the following collection variable. Above the
GetTweets_Click method would be a perfect location:
private ObservableCollection<Tweet> _tweets =
    new ObservableCollection<Tweet>();
Be sure to right-click the ObservableCollection type name and choose Resolve to
add the appropriate using System.Collections.ObjectModel statement to your
code. This collection will be the location where you place all the parsed tweets. It’s
also what you’ll bind the ListBox to. You’ll use the ObservableCollection class in
chapter 16 (when we cover binding).
PARSING WITH LINQ TO XML
LINQ is something you may have used on other .NET projects. If so, you’ll feel right at
home because it’s supported in Silverlight as well. If not, it’s pretty easy to pick up.
Think of it almost like SQL but in code and working on objects. Oh…and written
backward, with no database in sight. Okay, it’s not exactly like SQL, but it’s a great
query language that lets you perform iterations and filters in a single line of code. In
any case, you won’t need to be a LINQ expert for this example.
 Right-click the project and choose Add Reference; add a reference to System.
Xml.Linq. Figure 1.6 shows the dialog with the correct reference selected. Note the
location is the Silverlight 5 SDK folder.
Figure 1.6
The Add Reference dialog with System.Xml.Linq selected for LINQ to XML functionality

21
Building your first Silverlight web application
Once the reference is added, replace the temporary Debug.WriteLine statement and
the event handler declaration in the code-behind with the code inside the braces in
listing 1.4. This code performs the actual parsing of the XML document returned by
the Twitter search and loads the _tweets collection with the processed results.
client.DownloadStringCompleted += (s, ea) =>
{
  XDocument doc = XDocument.Parse(ea.Result);
  XNamespace ns = "http://www.w3.org/2005/Atom";  
  var items = from item in doc.Descendants(ns + "entry")            
    select new Tweet()                                             
    {
      Message = item.Element(ns + "title").Value, 
      Image = new Uri((                                              
          from XElement xe in item.Descendants(ns + "link")
          where xe.Attribute("type").Value == "image/png"
          select xe.Attribute("href").Value
          ).First<string>()),
    };
  _tweets.Clear();
  foreach (Tweet t in items)
                                      
  {
    _tweets.Add(t);
  }
};
Be sure to right-click and resolve the XDocument class in order to add the correct
using System.Xml.Linq statement to the top of your code. 
 The code does some interesting processing. It first loads the results into an
XDocument so that it may be processed using LINQ statements. It then goes through
the document selecting each entry element and creating a new Tweet object from
each. The Tweet object itself is filled out by first grabbing the title element’s value and
assigning that to the Message and then doing another LINQ query to find the link ele-
ment that has a type of image/png and assigning that to the Image property. Finally,
the code loops through each of the results and adds them to the _tweets collection.
 The namespace declaration at the top is necessary because the Atom namespace is
the default xmlns in the document. When parsing XML, you need to have the default
namespace declared or the results will be empty. Some people like it, but that’s my
least favorite thing about XML.
 With the parsing out of the way, the next step is to bind the ListBox to the _tweets
collection so that it has a place to pull the data from.
BINDING THE LISTBOX
Silverlight is all about binding data. Chapter 16 goes into detail on how binding works
and how to use it. For now, it’s important to understand that rarely in Silverlight will
you find yourself assigning data directly to controls. Instead, you’ll set up binding rela-
tionships and let the elements pull the data as it becomes available.
Listing 1.4
Processing the Twitter search results using LINQ to XML
Atom namespace

22
CHAPTER 1
Introducing Silverlight
 In this case, you want to set the ListBox’s ItemsSource property to your collection
so that it knows to load its individual items from the collection when the collection is
updated. Because you’re using an ObservableCollection, the ListBox will be alerted
whenever an item is added to or removed from that collection.
 Add the following line of code to the MainPage constructor, under the Initialize-
Component call:
TweetList.ItemsSource = _tweets;
The resulting complete code-behind should look like listing 1.5.
using System;
using System.Linq;
using System.Net;
using System.Windows;
using System.Windows.Controls;
using System.Collections.ObjectModel;
using System.Xml.Linq;
namespace FirstSilverlightApplication
{
  public partial class MainPage : UserControl
  {
    public MainPage()
    {
      InitializeComponent();
      TweetList.ItemsSource = _tweets;   
    }
    private ObservableCollection<Tweet> _tweets =
            new ObservableCollection<Tweet>();     
    private void GetTweets_Click(object sender, RoutedEventArgs e)
    {
      WebClient client = new WebClient();
      client.DownloadStringCompleted += (s, ea) =>
      {
        XDocument doc = XDocument.Parse(ea.Result);
        XNamespace ns = "http://www.w3.org/2005/Atom";
        var items = from item in doc.Descendants(ns + "entry")
                    select new Tweet()
                    {
                      Message = item.Element(ns + "title").Value,
                      Image = new Uri((
                        from XElement xe in item.Descendants(ns + "link")
                          where xe.Attribute("type").Value == "image/png"
                          select xe.Attribute("href").Value
                          ).First<string>()),
                    };
        _tweets.Clear();
        foreach (Tweet t in items)
Listing 1.5
The complete code-behind for MainPage
Bind ListBox
ObservableCollection

23
Building your first Silverlight web application
        {
          _tweets.Add(t);
        }
      };
      client.DownloadStringAsync(new           
Uri("http://search.twitter.com/search.atom?q=silverlight"));
    }
  }
}
That’s all you need to do to set up the binding relationship for the ListBox. Run the
application and retrieve the tweets. You should end up with something that looks like
figure 1.7.
 In the example, all you see are a bunch of type names. You want to display images
and text. The reason you see the type name is because this is the default item tem-
plate behavior. By default, the individual items are presented as their ToString call.
This works fine for a string or numbers or similar, but with complex types? Not so
much. Chapter 16 talks more about item templates and how to use them with the
ListBox control.
 Your final step in this walkthrough is to pretty up the ListBox results so you can
see something more meaningful.
1.4.5
Making the ListBox contents more meaningful
To make the ListBox present items using a format of your own choosing, you need to
use a DataTemplate. DataTemplates are covered in detail in chapter 16. For now,
understand that they’re a chunk of XAML that’ll be used to format each item in the list.
 The DataTemplate for this ListBox will contain two columns for each row. The
first column will contain the picture of the tweeter; the second will contain the body
of the tweet. 
Network call
Figure 1.7
The default 
presentation for the ListBox 
items leaves something to be 
desired. It looks like 
WinForms or something! I 
demand more from our first 
Silverlight example.

24
CHAPTER 1
Introducing Silverlight
Open MainPage.xaml and replace the entire ListBox declaration (not the Button,
just the ListBox) with the XAML from listing 1.6.
<ListBox x:Name="TweetList" 
         HorizontalContentAlignment="Stretch"                      
         ScrollViewer.HorizontalScrollBarVisibility="Disabled"     
         Margin="12,41,12,12">
  <ListBox.ItemTemplate>
    <DataTemplate>                                                  
      <Grid Margin="10">
        <Grid.ColumnDefinitions>
          <ColumnDefinition Width="Auto" />   
          <ColumnDefinition Width="*" />     
        </Grid.ColumnDefinitions>
        <Image Source="{Binding Image}"                             
               Grid.Column="0" 
               Margin="3" Width="50"  Height="50"
               Stretch="UniformToFill"/>
        <TextBlock Text="{Binding Message}"                         
                   FontSize="14" Margin="3"
                   Grid.Column="1" TextWrapping="Wrap" />
      </Grid>
    </DataTemplate>
  </ListBox.ItemTemplate>
</ListBox>
In this markup, you first tell the ListBox that you want its content to take up the full
width of the ListBox, without any horizontal scrolling. The HorizontalContent-
Alignment and HorizontalScrollBarVisibility elements do that. 
 Then, you break out the ItemTemplate property and supply it with a Data-
Template. Inside the DataTemplate, you define the grid with an autosized first col-
umn and a full-width second column. The template is applied to each item loaded
into the ListBox, almost like a macro expanded for each tweet. Then, you bind an
Image element to the Image property of the Tweet class and a TextBlock to the
Message property of the same.
 The end result of the work you’ve done, including this fine ListBox Data-
Template, is shown at the start of this section in figure 1.2. 
 I’ve been working with Silverlight and WPF for well over half a decade now, but it
never fails to impress me just how easy it is to have complete control over what your
application displays. I remember the days when you had to purchase specialty controls
to do something as simple as display an image inside a ListBox. Now, all you need to
do is a little XAML. And, if you don’t feel like typing in XAML, you can crack open
Expression Blend and use it to design the DataTemplate interactively on the design
surface. As a famous dark lord of the Sith once said, “Impressive…most impressive.” 
Listing 1.6
DataTemplate to format the tweets
Autosized column
Full-width column

25
Summary
1.5
Summary
Silverlight is one of the most promising development platforms to come from Micro-
soft since the original release of .NET a decade ago. Silverlight fills a niche that sits sol-
idly between traditional desktop applications and web applications, while offering
capabilities that both lack. It does all this via a small plug-in that takes only minutes to
install and runs on different browsers and different operating systems. 
 The code you write and the skills you gain are portable between the desktop and
the web, devices in your pocket, game consoles in your living room, and the set-top
box on your TV. That’s a pretty good return on your investment.
 Silverlight has come a long way since the Silverlight 2 version covered in the origi-
nal edition of this book. It’s amazing just how much the product teams have been able
to pack into the product in those few years. In fact, even in between Silverlight 4 and
Silverlight 5, we’ve seen a huge number of great features and improvements added.
Before I joined Microsoft, I heard rumors about people with sleeping bags in their
offices and coffee delivered by the gallon. I suspect I now know which team they work
for, and I have to say that I’m “super” impressed with the results.
 Your environment is all set up, and you’ve whet your appetite by building a basic
yet nontrivial “Hello World!” Twitter application in Silverlight 5. In the next chapter,
you’ll dive right into the meat of what makes Silverlight UI work: XAML. 
 From there, you’ll take a tour of all the features this platform has to offer. By the
end of this book, you’ll have all the knowledge you need to build awesome Silverlight
applications.

26
XAML and the
property system
Before the sibling inventions of WPF and Silverlight, individual programming lan-
guages and platforms had a variety of ways of specifying the UI. Most touted the
concept of separating the UI from the implementation code. In some cases, such as
on the web with HTML and CSS, the representation of the UI was theoretically sepa-
rated from its underlying implementation but not truly so until tried-and-true pat-
terns, such as Model-View-Controller (MVC), were applied. In others, such as
Windows Forms, the separation was due only to hidden autogenerated, uneditable
files that contained the language-specific code necessary to create the UI.
This chapter covers
■
The basics of XAML
■
The structures Silverlight uses when working 
with XAML
■
The property system
■
Introduction to commands
■
Creating XAML at runtime

27
XAML basics
 With WPF, Microsoft introduced XAML (pronounced “Zammel”) to provide a
cleaner separation of concerns between the definition of the UI and the code that
makes it work. This not only allows for some sleek design patterns such as the MVVM
pattern (discussed in chapter 33) but also makes it easier to create tooling.
 Consider Windows Forms. The definition of the interface was so tied to the com-
piler and the existing tooling that it was extremely difficult for a third party to create a
tool that designed (or assisted in the design) of the UI. The files were hidden, made in
multiple implementation languages, and had that “don’t even think of editing this
file” comment at the top of the generated code. It was good at the time but the world
has moved on.
XAML helps fix those problems—it lets you, not the tools, own your UI. XAML files
are editable individually and in relative isolation from the rest of the project. You can
edit XAML in Expression Blend, Visual Studio, Notepad, Kaxaml, your favorite XML
editor, and other tools, thereby making it easier to incorporate into your own specific
workflow. Even hand-edited XAML is round-trippable with tooling because the XAML
rules are well defined and consistent internally and across implementation languages.
XAML is so fundamental to Silverlight that this entire chapter is devoted to intro-
ducing you to it. Though XAML appears in almost every chapter in this book, I’ll cover
the core concepts here and ensure sufficient understanding so that, when you open a
XAML file in Visual Studio, you can read and understand what it’s doing, even as
you’re still learning Silverlight. For those of you interested in the guts of XAML pro-
cessing and use, I’ve included information on using tree structures and the property
system in preparation for a later discussion on creating your own converters and
XAML extensions. I’ve also included some introductory information on working with
commands, a key concept to understand especially when following the MVVM pattern.
2.1
XAML basics
XAML is a declarative language that enables you to create and initialize .NET objects in
XML. Everything you can do in XAML you can do in code. But to make the most of the
platform and its tooling, you’ll want to embrace the code-plus-markup philosophy
rather than go with a 100 percent code solution. In fact, throughout this book, I’ll use
“markup” and “XAML” synonymously, because XAML truly is the UI markup language
for Silverlight just as HTML is for HTML/JS/CSS applications.
 The XAML format enables you to easily visualize a hierarchy of elements while sep-
arating presentation from code. This separation is possible because each XAML ele-
ment maps to a .NET type. Each attribute within an element corresponds to a property
within a .NET type. For example, these statements are equivalent:
<TextBlock x:Name="tb" Text="Hello World!" />
TextBlock tb = new TextBlock();
tb.Text = "Hello World!";

28
CHAPTER 2
XAML and the property system
The TextBlock element in the XAML code corresponds to an initialization statement in
code. This initialization occurs because, each time an element is created in XAML, the
corresponding .NET type’s default constructor is called behind the scenes. 
 To understand the structure of a XAML file, it’s important to understand the repre-
sentation and use of objects, namespaces, properties, and events.
2.1.1
Objects
Objects (or instances of types) are represented in XAML using XML elements. The ele-
ments have the same name as the associated class and are considered instantiated
upon declaration in the markup.
NOTE
Any type you use in XAML must have a default (parameterless) con-
structor. Silverlight XAML currently has no provision for passing arguments
into a constructor or an initialization function, so you’ll need to make sure
your types can be initialized using defaults and properties alone.
Certain types of objects may contain one or more other nested objects. For example, a
button may contain a single content object, which itself may contain one or more
other objects. In listing 2.1, the UserControl contains the Grid, the Grid contains the
Button, and the Button contains a StackPanel, which is a panel that by default lays its
children out in a vertical list. The StackPanel itself contains three TextBlock
elements.
Result:
XAML:
<UserControl x:Class="XamlElements.MainPage"          
  xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
  <Grid x:Name="LayoutRoot">                                 
    <Button Height="100" Width="150">                    
      <StackPanel>                                        
        <TextBlock Text="First Line" />  
        <TextBlock Text="Second Line" /> 
        <TextBlock Text="Third Line" /> 
      </StackPanel>
    </Button>
  </Grid>
</UserControl>
Listing 2.1
XAML showing a hierarchy of nested objects
Three TextBlocks 
in StackPanel

29
XAML basics
The UserControl and Button are both content controls, a concept I’ll discuss in
greater detail in chapter 12. For now, it’s important to understand that a content con-
trol may only have one direct child element, typically a panel (StackPanel, Grid, Can-
vas, etc.) that holds other elements. The x:Name and x:Class properties are part of
the namespace specified by the xmlns:x statement. More on that in a moment… The
Grid and StackPanel are both Panels, which is a type that has a Children collection
to allow multiple contained elements. I’ll discuss panels in detail in chapter 8.
 The ability to flexibly nest objects permits a composition approach to UI design.
Rather than having to purchase or custom-code a button control that allows, say, three
lines of text and an image, you can simply compose those into an appropriate layout
panel and make that panel the content of the button control.
 The nesting of objects is part of what gives us an object tree. I’ll cover that in more
detail shortly.
 Now that you’re familiar with the basic structure of a XAML file, let’s talk about
how you differentiate your SuperButton control from my SuperButton control, even
though we used the same control name: namespaces. 
2.1.2
Namespaces
A namespace provides a way of organizing related objects within a common grouping.
These groupings, or namespaces, give you a way to define where the compiler should
look for a type. Namespaces in XAML, which are simply XML namespaces, are similar
to namespaces in other languages such as C# and Java. To specify where to look, you
reference a namespace within an element of a XAML file, typically the root or outer-
most element. Listing 2.2 illustrates the use of the two default namespaces.
<UserControl x:Class="XamlExample.MainPage"
  xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" 
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" 
  Width="400" Height="300">
  <Grid x:Name="LayoutRoot" Background="White">
    <TextBlock x:Name="myTextBlock" Text="Hello" />
  </Grid>
</UserControl>
NOTE
WPF supports the Name property in both the namespace prefixed with
x: and the default namespace, allowing them to be specified as x:Name or just
Name. Silverlight supports only x:Name. For compatibility with Silverlight
markup, the recommended approach for WPF is to use x:Name.
As listing 2.2 illustrates, you’re permitted to reference multiple namespaces within a
single XAML file. When you reference multiple namespaces, each must be uniquely
prefixed. For instance, the x prefix in this example is used in association with the
http://schemas.microsoft.com/winfx/2006/xaml namespace. At the same time, the
Listing 2.2
A basic XAML file referencing two default namespaces

30
CHAPTER 2
XAML and the property system
http://schemas.microsoft.com/winfx/2006/xaml/presentation namespace does
not use a prefix.
STANDARD XAML NAMESPACES
The two namespaces I just mentioned will be used in almost every Silverlight applica-
tion you work with or see. These namespaces are generally defined in the following
manner:
■
xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"—
This is the default Silverlight namespace. It provides your applications with core
Silverlight elements. For that reason, this namespace generally omits a prefix,
making it the default namespace within the page. Such an approach enables
you to reference elements within this specific namespace without having to
include the prefix.
■
xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"—This is the
common XAML namespace. It provides functionality that’s common across
XAML. It’s important to remember that XAML is used by other technologies
such as WPF, Oslo, and Windows Workflow Foundation (WF), all of which need
access to common features such as Name, Key, and Class properties.
NOTE
In addition to the standard namespaces, the Silverlight runtime sup-
ports the Silverlight-specific http://schemas.microsoft.com/client/2007
namespace as a default namespace. But you should use the previously
mentioned http://schemas.microsoft.com/winfx/2006/xaml/presentation
namespace as the default because Expression Blend, Visual Studio, and other
tools are all configured to recognize that namespace by default. The use of
standard namespaces also makes it easy to share your markup with WPF
applications.
REFERENCING OTHER LIBRARIES
When another assembly is referenced, it gets copied into the configuration-specific Bin
folder of your Silverlight application. In fact, when you compile your Silverlight appli-
cation, it gets compiled into an assembly that’s placed in this directory. I’ll discuss the
application model later; for now, in order to reference these assemblies, you need to
define a new XAML namespace, which includes a prefix, CLR namespace, and assembly.
<UserControl x:Class="XamlExample.MainPage"
  xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" 
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" 
  xmlns:my="clr-
namespace:MyNamespace;assembly=MyAssembly"
  Width="400" Height="300">
  <Grid x:Name="LayoutRoot">
    <my:MyControl x:Name="myControl1" />                         
  </Grid>
</UserControl>
Listing 2.3
Using a control from an external assembly 
External assembly 
reference

31
XAML basics
As listing 2.3 illustrates, referencing other elements, including custom elements, only
requires you to provide the namespace and assembly name of the external element.
For known assemblies, like the SDK, you can also provide a URI namespace. In either
case, you then prefix the elements from that namespace with the prefix you declared.
Of course, you’ll still need to reference the external assembly so that its types are
accessible to code and to the XAML parser/compiler. The name my was used as a con-
venience here; you can use any identifier you want.
 If the referenced type is defined in the same assembly as the markup, you’ll still
need to create a XAML namespace reference for it. But the ;assembly= clause of the
namespace definition may optionally be left out, as illustrated in listing 2.4.
<UserControl x:Class="XamlExample.MainPage"
  xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" 
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" 
  xmlns:controls="clr-namespace: XamlExample.Controls" 
  Width="400" Height="300">
  <Grid x:Name="LayoutRoot">
    <controls:MyControl x:Name="myControl1" />              
  </Grid>
</UserControl>
Namespaces are typically declared within the outermost element of a XAML file, as in
listing 2.4, but that doesn’t always need to be the case. When using XAML generated
by tools, you’ll sometimes find namespaces defined at lower levels, particularly within
control templates (covered in chapter 14). In those cases, the namespace only applies
to the elements within the enclosing type (and the enclosing element itself) rather
than to the XAML document as a whole.
 Listing 2.5 shows the definition of a namespace at the Grid level rather than at the
UserControl level. The namespace could also have been defined at the MyControl
level, but then you’d need to do it for each instance of MyControl. This approach is
sometimes taken when using control templates and other situations where you want to
minimize possible namespace prefix collisions while still preserving the ability to ref-
erence external code.
<UserControl x:Class="XamlExample.MainPage"
  xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" 
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" 
  Width="400" Height="300">
  <Grid x:Name="LayoutRoot"
        xmlns:controls="clr-namespace:XamlExample.Controls"> 
    <controls:MyControl x:Name="myControl1" />
    <controls:MyControl x:Name="myControl2" />
    <controls:MyControl x:Name="myControl3" />
  </Grid>
</UserControl>
Listing 2.4
Using a control from a different namespace in the same assembly
Listing 2.5
Namespace declaration at a level lower than the root
Namespace 
declaration
Namespace 
declaration

32
CHAPTER 2
XAML and the property system
The namespace shown in listing 2.5 will only apply to the grid LayoutRoot and its chil-
dren. Controls outside of that hierarchy won’t have access to the controls namespace
or prefix. You’ll typically find this inside complex styles in resource dictionaries. The
same approaches to referencing namespaces and assemblies apply to resource diction-
aries, pages, and other types commonly associated with XAML. Though it’s important
to understand the rules for referencing namespaces, in practice the tooling will create
the namespaces for you either by IntelliSense or when you drag and drop items into
the markup editor or onto the design surface. 
2.1.3
Properties
There are two ways to reference properties in XAML: inline with the element as you
would any XML attribute, and as a nested subelement. Which method you should
choose depends on what you need to represent. Simple values are typically repre-
sented with inline properties, whereas complex values are typically represented with
element properties.
INLINE PROPERTIES
The use of an inline property requires a type converter that will convert the string rep-
resentation—for example, the "Black" in Background="Black"—into a correct
underlying .NET type (in this case, a SolidColorBrush). I’ll cover type converters in
chapter 15. The example in listing 2.6 shows a built-in type converter in use to convert
the string "Black" for the inline property Background.
<UserControl x:Class="XamlExample.MainPage"
  xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" 
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" 
  Width="400" Height="300">
  <Grid x:Name="LayoutRoot" Background="Black" /> 
</UserControl>
Another way to specify properties is to use the expanded property element syntax.
Although this can generally be used for any property, it’s typically required only when
you need to specify something more complex than the inline syntax will easily allow.
The syntax for element properties is <Type.PropertyName>value</Type.PropertyName>, as
seen in listing 2.7.
<UserControl x:Class="XamlExample.MainPage"
  xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" 
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" 
  Width="400" Height="300">
  <Grid x:Name="LayoutRoot">   
    <Grid.Background>     
      Black               
    </Grid.Background>  
Listing 2.6
Specifying a property value inline using an XML attribute
Listing 2.7
Specifying a property value using property element syntax
Inline propertyElement 
properties
Property element 
syntax

33
XAML basics
  </Grid>
</UserControl>
The use of the string to invoke the type converter is, in its end result, identical to
using <SolidColorBrush Color="Black" /> in place of "Black". Though these exam-
ples are rarely seen in practice, the more complex example of setting the background
to a LinearGradientBrush is common, so I’ll cover that next. 
 Rather than have the brush represented as a simple string such as "Black" as
shown in the previous listing, the value can be an element containing a complex set of
elements and properties such as the <LinearGradientBrush> in listing 2.8.
<UserControl x:Class="XamlExample.MainPage"
  xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" 
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" 
  Width="400" Height="300">
  <Grid x:Name="LayoutRoot">
    <Grid.Background>                
      <LinearGradientBrush>                  
        <LinearGradientBrush.GradientStops>                 
          <GradientStop Offset="0.0" Color="Black" />     
          <GradientStop Offset="0.5" Color="LightGray" /> 
          <GradientStop Offset="0.5" Color="DarkGray" />  
          <GradientStop Offset="1.0" Color="White" />     
        </LinearGradientBrush.GradientStops>
      </LinearGradientBrush>
    </Grid.Background>
  </Grid>
</UserControl>
In this example, you’ve expanded the Background property using property element
syntax. You then have the ability to nest a complex type, such as the LinearGradient-
Brush, within it.
 Now that you know how to specify properties in markup, let’s dive deeper into how
those properties work. 
2.1.4
Dependency properties
Dependency properties are part of the property system introduced with WPF and used in
Silverlight. In markup and in consuming code, they’re indistinguishable from stan-
dard .NET CLR properties, except that they can be data bound, serve as the target of
an animation, or set by a style.
TIP
A property can’t be the target of an animation or obtain its value
through binding unless it’s a dependency property. Chapter 16 covers bind-
ing in detail.
To have dependency properties in a class, the class must derive from Dependency-
Object or one of its subclasses. Typically, you’ll do this only for visuals and other ele-
ments that you’ll use within XAML and not in classes defined outside the UI.
Listing 2.8
A more complex example of the property element syntax
Background 
property

34
CHAPTER 2
XAML and the property system
 In regular .NET code, when you create a property you typically back it by a private
field in the containing class. Storing a dependency property differs in that the loca-
tion of its backing value depends on its current state. The way that location is deter-
mined is called value precedence.
VALUE PRECEDENCE
Dependency properties obtain their value from a variety of inputs. What follows is the
order the Silverlight property system uses when assigning the runtime values of
dependency properties, with the highest precedence listed first:
■
Active or hold animations—Animations will operate on the base value for the
dependency property, determined by evaluating the precedence for other
inputs. In order for an animation to have any effect, it must be highest in prece-
dence. Animations may operate on a single dependency property from multiple
levels of precedence (for example, an animation defined in the control tem-
plate and an animation defined locally). The value typically results from the
composite of all animations, depending on the type being animated. If you
think about animating the position of an element, you’ll want that animated
value to take precedence over one set in code or markup. The property system
helps ensure that happens.
■
Local value—Local values are specified directly in the markup and are accessed
via the CLR property wrappers for the dependency property. Because local val-
ues are higher in precedence than styles and templates, they’re capable of over-
riding values such as the font style or foreground color defined in the default
style for a control.
■
Templated properties—Used specifically for elements created within a control or
data template, their value is taken from the template itself.
■
Style setters—These are values set in a style in your application via resources
defined in or merged into the UserControl or application resource dictionar-
ies. I’ll explore styles in chapter 14.
■
Default value—This is the value provided or assigned when the dependency
property was first created. If no default value was provided, normal CLR defaults
typically apply. 
The strict precedence rules allow you to depend on behaviors within Silverlight, such
as being able to override elements of a style by setting them as local values from within
the element itself. In listing 2.9, the foreground of the button will be red as set in the
local value and not black as set in the style. The local value has a higher precedence
than the applied style. 
<UserControl x:Class="XamlExample.MainPage"
  xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" 
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" 
Listing 2.9
Dependency property precedence rules in practice

35
XAML basics
  Width="400" Height="300">
  <UserControl.Resources>
    <Style x:Key="ButtonStyle" TargetType="Button">
      <Setter Property="Foreground" Value="Black" />
      <Setter Property="FontSize" Value="24" />
    </Style>
  </UserControl.Resources>
  <Grid x:Name="LayoutRoot">
    <Button Content="Local Values at Work"
            Style="{StaticResource ButtonStyle}"
            Foreground="Red" />           
  </Grid>
</UserControl>
The Style tag in UserControl.Resources is a reusable asset that sets some key proper-
ties for your button.
 I’ll cover creating dependency properties in chapter 15 when you create your own
controls. For the purposes of this chapter, it’s sufficient to understand that the major-
ity of the properties you’ll refer to in XAML are dependency properties. One type of
dependency property that has a slightly odd appearance is an attached property. 
2.1.5
Attached properties
Attached properties are a specialized type of dependency property that’s immediately
recognizable in markup due to the TypeName.AttachedPropertyName syntax. For exam-
ple, Canvas.Left is an attached property defined by the Canvas type. What makes
attached properties interesting is that they’re not defined by the type you use them
with; instead, they’re defined by another type in a potentially different class hierarchy.
 Attached properties allow flexibility when defining classes because the classes
don’t need to take into account every possible scenario in which they’ll be used and
define properties for those scenarios. Layout is a great example of this. The flexibility
of the Silverlight layout system allows you to create new panels that may never have
been implemented in other technologies—for example, a panel that lays elements out
by degrees and levels in a circular or radial fashion versus something like the built-in
Canvas that lays elements out by Left and Top positions. 
 Rather than have all elements define Left, Top, Level, and Degrees properties (as
well as GridRow and GridColumn properties for grids), you can use attached proper-
ties. The buttons in listing 2.10, for example, are contained in panels that have greatly
differing layout algorithms, requiring different positioning information. In this case,
I’ll show a fictional RadialPanel in use.
<UserControl x:Class="XamlExample.MainPage"
  xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" 
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" 
  xmlns:panels="clr-namespace:Xaml09.Panels"
  Width="400" Height="600">
  <StackPanel x:Name="LayoutRoot">
Listing 2.10
Attached properties in use
Local value

36
CHAPTER 2
XAML and the property system
    <Canvas Width="400" Height="200">
      <Button Canvas.Left="10"              
              Canvas.Top="50"               
              Width="200" Height="100"
              Content="Button in Canvas" />
    </Canvas>
    <panels:RadialPanel Width="400" Height="400">
      <Button panels:RadialPanel.Degrees="25"    
              panels:RadialPanel.Level="3"    
              Width="200" Height="100"
              Content="Button in Radial Panel" />
    </panels:RadialPanel>
  </StackPanel>
</UserControl>
Attached properties aren’t limited to layout. You’ll find them in the animation engine
for things such as Storyboard.TargetProperty as well as in other places of the
framework.
PROPERTY PATHS
Before I wrap up this discussion of properties, there’s one concept left for you to
understand: property paths. Property paths provide a way to reference properties of
objects in XAML both when you have a name for an element and when you need to
indirectly refer to an element by its position in the tree.
 Property paths can take several forms, and may dot-down into properties of an
object. They can also use parentheticals for indirect property targeting as well as for
specifying attached properties. Here are some examples of property paths for the
Storyboard target property:
<DoubleAnimation Storyboard.TargetName="MyButton"
                 Storyboard.TargetProperty="(Canvas.Left)" ... />
<DoubleAnimation Storyboard.TargetName="MyButton"
                 Storyboard.TargetProperty="Width" ... />
...
<Button x:Name="MyButton" 
        Canvas.Top="50" Canvas.Left="100" />
I’ll cover property paths in detail in chapter 16 when I discuss binding.
 Properties are one of the pieces that define an object’s interface. Because XAML
(without the addition of something like the CallMethodAction behavior, discussed in
chapter 33) doesn’t allow you to do anything specifically with methods, the only other
part of the interface left is the definition of events. 
2.1.6
Events
Events in Silverlight are used much like events in any other .NET technology. The
sender of the event wants to notify zero or more receivers of something that hap-
pened. Silverlight enhances that, though, to make it possible for events to work their
way up the object tree, from the event source to the root element.
Attached properties

37
XAML basics
 Silverlight and WPF introduce the concepts of routed events and event bubbling.
These allow events to be generated at one level of the tree, then provide an opportu-
nity to be handled by each level above, until reaching the root of the tree—an effect
known as bubbling.
 The main difference between routed events and standard CLR events, to the han-
dler of the event, is that the event sender isn’t necessarily the original source of the
event. To get the original source of the event, you need to check the OriginalSource
property of the RoutedEventArgs supplied to the handler.
 User-created events, such as the ones you might create in your own code, can’t
bubble. Bubbling is reserved only for built-in core events such as MouseLeftButton-
Down. Bubbled events include a Handled property in the event arguments, as well as
the standard RoutedEventArgs information.
WPF ROUTED EVENTS
If you’re familiar with the eventing system in WPF, you may wonder what happened to
the Tunneling and Direct types of routed events. Silverlight doesn’t currently imple-
ment these. In fact, Silverlight doesn’t include the EventManager available in WPF, so
routed events can’t be created in user code. Some clever folks at control vendors have
implemented their own analog that allows for user-created routed events but isn’t
built into the core Silverlight runtime.
EVENTS REFERENCED IN XAML
In XAML, referencing an event handler defined in code-behind is simple. If you use
Visual Studio when doing so, the event handler in the code-behind can be created for
you automatically.
 Say you have a button in XAML:
<Button Click="MyButton_Click" />
You can wire it up to an appropriate event handler in the code-behind:
private void MyButton_Click(object sender, RoutedEventArgs e)
{
  MessageBox.Show("Click event");
}
The approach is a good shortcut for hooking up events. When working in XAML, the
tooling in Visual Studio will even let you define a new event handler or use an existing
one. One slight advantage of this approach is that you don’t necessarily need to define
a name for your button.
EVENTS REFERENCED IN CODE
To attach an event handler from code, follow the same approach you would for any
normal CLR event: create an event handler and add it to the event using the += syntax.
So, if you have the same button as earlier and give it a name that can be referenced
from the code-behind:
<Button x:Name="MyButton" />

38
CHAPTER 2
XAML and the property system
you can then wire up the event handler in the constructor. Do this after the
InitializeComponent call so that MyButton is valid:
public MainPage()
{
    InitializeComponent();
    MyButton.Click += new RoutedEventHandler(MyButton_Click);
}
private void MyButton_Click(object sender, RoutedEventArgs e)
{
  MessageBox.Show("Click event");
}
Both approaches are equally valid. The approach you use will depend primarily on
your personal style. My preferred approach when not using commands is to wire up
events in the code-behind, in the constructor as shown.
 Silverlight 4 added the ability to use commands as a way to clean up event handling
and wire-up code. Rather than specify an event handler, you can specify one or more
command properties in XAML. 
2.1.7
Commands
One of the more architecturally significant additions to Silverlight 4 was the addition
of WPF-style commands. Commands allow you to remove the event handler middle-
man from your code-behind when you want something other than the code-behind to
handle the action. For example, if you follow the MVVM pattern covered in chapter
33, you probably want the button clicks to be handled by the view model and not the
code-behind. Typical event handler code to forward the event might look like this:
private void Save_Click(object sender, RoutedEventArgs e)
{
  _viewModel.Save();
}
That’s extra goo that you don’t necessarily want in your view. It complicates unit test-
ing and makes the code-behind an essential ingredient. It also requires separate view-
model properties to set the IsEnabled property on the Save button. It’s not terrible,
but it’s not great. The command code that eliminates the code-behind goo might look
like this:
// no code in code-behind required :)
I love the code I don’t have to write. It’s all handled in the markup and the view
model, so you don’t need any forwarding code at all. The controls in the view bind to
a command that exists somewhere in the binding path. Assuming you have the page’s
data context set to the view model, the markup to bind to the exposed view-model
command looks like this:
<Button x:Name="SaveButton"
        Height="25" Width="75" Content="Save"
        Command="{Binding SaveCommand}" />

39
Object trees and namescope
The related bits of the view model might look something like this, assuming you’ve
implemented an EmployeeSaveCommand that implements ICommand:
private EmployeeSaveCommand _saveCommand;
public ICommand SaveCommand
{
    get { return _saveCommand; }
}
In this way, you avoid having your code-behind stand in the way of separating your
view from your view model. Commands also provide other capabilities such as auto-
matically disabling the associated controls if the command can’t be run at that time
via an implicit binding of the ICommand.CanExecute method with IsEnabled property
of the Button.
 Commands are supported on any control that inherits from ButtonBase as well as
on the Hyperlink control (not to be confused with HyperlinkButton, which inherits
from ButtonBase).
 You’ll create your own commands in chapter 33 when I explain how to build appli-
cations using the MVVM pattern. 
 Objects, properties, events, and commands make up the majority of what you’ll see
when you look at a XAML file. At this point, you should be able to read XAML and have
a general understanding of what you’re looking at. Another thing you may see in
XAML is object and property names inside curly braces. I’ll explore that later in this
chapter, but first I’ll go through what Silverlight sees when it looks at XAML source
and builds the in-memory representation of the elements. 
2.2
Object trees and namescope
In the previous sections, I mentioned the concept of an object tree. To understand
the object tree, you need to grasp the layout and contents of XAML files. Once you do,
it’s easier to conceptualize the object tree and its related concept, namescope.
 A common misconception is that Silverlight creates XAML for any objects you create
in code. In fact, the opposite is what happens: Silverlight creates objects from XAML.
Objects you create in code go right into the trees as their native .NET object form. Ele-
ments in XAML are processed and turned into objects that go into the same tree.
2.2.1
Object trees
Now that you’re familiar with the structure of a XAML file, you can look at one and
quickly realize it represents a hierarchical tree of objects starting from the root (typi-
cally a UserControl or Page) and going all the way down to the various shapes, panels,
and other elements that make up the control templates in use. That hierarchical
structure is known as an object tree. Figure 2.1 shows a hypothetical object tree.

40
CHAPTER 2
XAML and the property system
 Each element has the con-
cept of a parent (the containing
element) and may have a child
or children in panel-type collec-
tion properties, content proper-
ties, or other general-purpose
properties.
NOTE
Unlike 
WPF, Silver-
light doesn’t expose the con-
cept 
of 
a 
logical 
tree.
Operations 
that 
in 
WPF
might return logical tree
information will in Silverlight
return visual tree informa-
tion. This distinction is only
important if you’re coming
from the WPF world or port-
ing code from WPF that hap-
pened to use tree traversal
functions.
The visual tree is a filtered view
of the object tree. Whereas the
object tree contains all types
regardless of whether they participate in rendering (collections, for example), the
visual tree contains only those objects with a visual representation. Figure 2.2 shows
the visual tree; note the lack of nonvisual objects such as collections.
UserControl
Grid
(LayoutRoot)
ElementCollection
(Children)
TextBlock
TextBlock
ListBox
ItemCollection
(Items)
TextBlock
TextBlock
TextBlock
Figure 2.1
A hypothetical object tree showing not only the 
visual elements such as TextBlocks and ListBoxes, but 
also the internal collections used to contain child elements.
Grid
(LayoutRoot)
TextBlock
TextBlock
ListBox
TextBlock
TextBlock
TextBlock
UserControl
Figure 2.2
The visual tree 
representation of the object 
tree from figure 2.1. Note that 
only visual elements, not 
collections, are represented.

41
Object trees and namescope
WALKING THE VISUAL TREE
Silverlight includes the VisualTreeHelper static class to assist in examining the visual
tree. Using the GetChild and GetChildrenCount methods, you can recursively walk the
tree from any element down as deeply as you want. The GetParent method allows you
to trace the tree from a given element up to the visual tree root.
Helper to walk the tree from an element to the rootResult:
System.Windows.Controls.StackPanel
System.Windows.Controls.Border
System.Windows.Controls.Grid
System.Windows.Controls.Grid
VisualTree.MainPage
XAML:
<UserControl x:Class="VisualTree.MainPage"
  xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" 
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" 
  Width="400" Height="300">
  <Grid x:Name="LayoutRoot" Background="White">
    <Grid>
      <Border BorderThickness="1" BorderBrush="Black"
              Margin="10">
        <StackPanel Margin="10">
          <TextBlock x:Name="MyTextBlock"         
                     Text="Hello!" />
          <TextBlock Text="Lorem ipsum" />   
        </StackPanel>
      </Border>
    </Grid>
  </Grid>
</UserControl>                                            
C#:
public MainPage()
{
    InitializeComponent();
    Loaded += new RoutedEventHandler(MainPage_Loaded);
}
void MainPage_Loaded(object sender, RoutedEventArgs e)         
{
    DependencyObject o = MyTextBlock;
    while((o = VisualTreeHelper.GetParent(o)) != null)
    {
        Debug.WriteLine(o.GetType().ToString());
    }
}
Listing 2.11
Using the VisualTree
Start element
Sibling element
Stop when at root

42
CHAPTER 2
XAML and the property system
You start the tree walk in the Loaded event handler because the tree isn’t valid until
the UserControl has been loaded. You know the walk is complete when you hit an ele-
ment with a null parent—the root of the tree.
 You’ll notice that, when you generate an object tree for an entire application,
you’ll have multiple instances of controls, each of which contains elements with the
same name. Namescope, the next topic, is how Silverlight ensures that the names
remain uniquely addressable across the breadth of the object tree. 
2.2.2
Namescope
Earlier in this chapter you saw that you can define an x:Name for elements in XAML.
This provides a way to find the control via code and perform operations on it, or han-
dle its events.
 Consider the idea of having multiple controls on the same page, each of which
contains named elements. To handle this situation, XAML introduces the concept of a
namescope. A namescope ensures that the names across instances of controls don’t col-
lide. This is similar in concept to the approach taken by ASP.NET to mangle control
names to ensure they remain unique. Listing 2.12 shows an example where name-
scope is required to prevent duplicate control names.
XAML:
<UserControl x:Class="NamescopeExample.MyNestedControl"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" 
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" 
    Width="200" Height="150">
    <Grid x:Name="LayoutRoot" Background="White">
        <Button x:Name="MyButton" />  
    </Grid>
</UserControl>
XAML:
<UserControl x:Class="NamescopeExample.MainPage"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" 
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" 
             xmlns:local="clr-namespace:NamescopeExample"
    Width="400" Height="300">
    <StackPanel x:Name="LayoutRoot" Background="White">
        <local:MyNestedControl x:Name="Control1" />    
        <local:MyNestedControl x:Name="Control2" />   
        <local:MyNestedControl x:Name="Control3" />   
    </StackPanel>
</UserControl>
With three instances of the user control in listing 2.12, how does the XAML parser pre-
vent naming collisions among all the MyButtons in the object tree but still allow you to
uniquely reference each one? Namescope. As you’d expect, using the same name
twice within the same XAML namescope will result in a parsing error. This is similar to
Listing 2.12
Without namescope, the name MyButton would be duplicated in the tree
Named “MyButton”
Multiple instances

43
XAML type converters
the compile-time error you’d receive if you gave two variables the same name within
the same scope level in a C# application.
NOTE
Silverlight 2 had a namescope bug that manifested itself when you
named an element inside a tool tip (or pop-up) attached to items in an
ItemsControl such as a ListBox. The resulting error indicated that there
were duplicate names in the object tree. This was fixed in Silverlight 3.
In practice, you typically don’t need to worry about namescopes unless you’re loading
and parsing XAML at runtime using the createFromXaml JavaScript API or Xaml-
Reader.Load managed API. The namescopes are created for you automatically at run-
time when you instantiate your controls.
 Now that you understand namescope, let’s go back to one of the other things
you’ll run into in XAML: the curly brace syntax for markup extensions. 
2.3
XAML type converters
Now that you know the structure and rules for XAML files, let’s look at something that
allows you to bend those rules: type converters.
 Type converters give you a powerful way to extend XAML using your own code;
they’re also used throughout the entire .NET Framework to handle translation of one
CLR type to another. Specifically in the context of XAML, type converters are used to
convert string representations such as “Black” into their equivalent .NET CLR objects.
In the case of the example in listing 2.12, a SolidColorBrush with Color set to Black
is converted to a string that resolves to the color Red=0, Green=0, Blue=0, Alpha=255.
This is shown in listing 2.13.
<UserControl x:Class="TypeConverterExample.MainPage"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" 
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
    <Grid x:Name="LayoutRoot"
          Background="Black">     
    </Grid>
</UserControl>
There are enough built-in type converters that you may never have to write a new one
yourself. But they’re an extensibility point in XAML and, therefore, provide you with
flexibility to do some things that XAML may not handle natively. Chapter 15 covers
how to create your own custom type converters.
 Markup extensions and type converters are important tools you’ll use when work-
ing in XAML. You’ll run across their use, both implicit as with most type converters,
and explicit with markup extensions, in every nontrivial XAML file you look at. It’s
important to understand how they extend XAML to provide additional functionality.
 When you’re working with XAML, not everything is necessarily available at compile
time. With the exception of the support classes for converters and extensions, the rest
of XAML can be loaded from text at runtime. Section 2.4 covers that process.
Listing 2.13
A type converter in action 
Brush type 
converter

44
CHAPTER 2
XAML and the property system
2.4
Loading XAML at runtime
You can use dynamically loaded XAML to create entire sections of the object tree at run-
time. This approach can be useful for rendering user-generated content such as shapes
drawn on a screen and saved in a database or for creating highly dynamic controls.
 The process of loading XAML at runtime is incredibly easy. You only need to rely
on the XamlReader class, which belongs to the System.Windows.Markup namespace.
This class empowers you to parse XAML and convert it into an in-memory object. This
object can be created by a statically visible method called Load. This method takes a
string of XAML and converts it to the appropriate object. Then you can insert this
object into another UIElement. Listing 2.14 shows this entire process in action.
Result:
XAML:
<UserControl x:Class="XamlReaderExample.MainPage"
xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" 
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" 
  Width="400" Height="300">
  <Grid x:Name="LayoutRoot">
  </Grid>
</UserControl>
C#:
public MainPage()
{
  InitializeComponent();
  Loaded += new RoutedEventHandler(MainPage_Loaded);
}
void MainPage_Loaded(object sender, RoutedEventArgs e)
{
  var element = CreateRectangle();
  LayoutRoot.Children.Add(element);    
}
private Rectangle CreateRectangle()
{
  StringBuilder xaml = new StringBuilder();
  string ns =
"http://schemas.microsoft.com/winfx/2006/xaml/presentation";
  xaml.Append("<Rectangle ");
  xaml.Append(string.Format("xmlns='{0}'", ns)); 
  xaml.Append(" Margin='5 10 5 15'");
Listing 2.14
Loading and parsing XAML at runtime
Add to tree
Namespace 
declaration

45
Loading XAML at runtime
  xaml.Append(" Fill='Orange'");
  xaml.Append(" Stroke='Black' />");
  var rectangle = (Rectangle)
      XamlReader.Load(xaml.ToString()); 
  return rectangle;
}
This example dynamically creates a rectangle and adds it to the object tree. The code
in CreateRectangle simply builds up a string with XAML similar to what you’d have
inside a regular XAML file. Note that you need to specify the namespaces used for any
segment of XAML you’ll pass into XamlReader.Load. The code that adds the gener-
ated XAML to the object tree can be seen inside the loaded event. 
 You can do more with the element than just add it to the LayoutRoot. Listing 2.15
illustrates how you can take the XAML and integrate it with the managed code repre-
sentations of XAML constructs to create multiple instances of the rectangle.
Result:
XAML:
<UserControl x:Class="XamlReaderExample2.MainPage"
  xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" 
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" 
  Width="400" Height="300">
  <Grid x:Name="LayoutRoot">
  </Grid>
</UserControl>
C#:
public MainPage()
{
...
}
void MainPage_Loaded(object sender, RoutedEventArgs e)
{
  for (int i = 0; i < 4; i++)                  
  {
    RowDefinition def = new RowDefinition();
    LayoutRoot.RowDefinitions.Add(def);
    Rectangle rect = CreateRectangle();
    Grid.SetRow(rect, i);                
    LayoutRoot.Children.Add(rect);
  }
Listing 2.15
Mixing dynamic XAML with code
XamlReader.Load
Loop to create 
four instances
Set grid row

46
CHAPTER 2
XAML and the property system
}
private Rectangle CreateRectangle()
{
...
}
In this example, you loop to create four instances of the rectangle object. You then
dynamically create grid row definitions (see chapter 8) in code rather than in parsed
XAML and assign them via attached properties to your rectangle object.
 This shows a mix of the CLR representations of elements such as the grid row and
the XAML representations of elements such as the rectangle. In practice, you’ll rarely
create visual elements in code except for specific circumstances, but the power and
flexibility to do so is available to you. 
2.5
Summary
Silverlight development is all about code plus markup. To make the most of the plat-
form, you’ll want to learn how to leverage the capabilities that XAML provides, while
keeping a balance between what you write in code and what you put in the markup.
Learning the markup language will allow you to use tooling to quickly create great user
interfaces, work on a team including designers and developers without friction, and
help enforce the separation of the view from the rest of the application architecture.
 A basic understanding of XAML is fundamental to getting the most from the rest of
this book and from Silverlight itself. In later chapters, I’ll expand on what you’ve
learned here to encompass topics such as brushes, shapes, controls, animation, and all
the other things that make Silverlight such a great presentation platform.
 In chapter 3, I’ll cover the Silverlight plug-in and show you how to use it to create
applications that run inside and outside the browser.

47
The application model
and the plug-in
Application is an overloaded term that means different things to different people.
Some may question what level of footprint, functionality, or other metrics you need
to meet before something can be called an application. For example, is the weather
tracker sidebar gadget in Windows an application? What about Notepad? The code
for the sidebar gadget is almost certainly more complex than Notepad, but most peo-
ple would see Notepad as an application and the sidebar gadget as, well, a gadget.
 In my participation in the Silverlight community, I’ve been asked on a number of
occasions what to call the Silverlight “thing” that the plug-in loads in the browser.
How I answer depends on the context of the question and the nature of the Silver-
light thing. In this chapter I’m going to talk about Silverlight applications. I’ll use the
This chapter covers
■
Understanding the XAP and the Silverlight 
application model
■
Creating the Silverlight plug-in control in the 
browser
■
Initializing the plug-in and responding to plug-in 
events

48
CHAPTER 3
The application model and the plug-in
term application in the technical sense of the word: a compiled runnable Silverlight proj-
ect. The application can be as small as a tiny menu widget or a “punch the monkey” ad
on a web page or as complex as some of the Microsoft and Adobe tools I’ve used to write
this book. I’ll leave the other question of when something can be called an application
open so you can have something interesting to debate at code camp.
 Regardless of your own definition of application, a Silverlight application consists
of a XAP (pronounced “zap”) file with your compiled code, entry-point information,
potentially some resources, and a host for the Silverlight plug-in.
 As you saw in chapter 1, you can get up and running with Silverlight with little
understanding of these concepts, thanks to the great templates provided by Microsoft.
But as a developer, you have a natural curiosity to dig deeper and learn more about
what’s going on when the magic happens and the Silverlight content lights up on the
web page, both because you’ll need the knowledge once your applications reach more
than “Hello World!” complexity and also because it’s neat stuff. The core information
on which I’ll build in the rest of this book is the Silverlight application model and the
Silverlight plug-in.
3.1
The Silverlight application model
Silverlight applications consist of at least one or more compiled .NET dynamic link
libraries (DLLs) and a manifest file, all compressed into a file known as XAP. This is all
loaded into the plug-in at runtime and then executed at a specific entry point to start
your application.
 The XAP file is the key deployment mechanism for all Silverlight managed code
applications. When you talk about deploying a Silverlight application, you’re really
talking about:
■
Surfacing the XAP to the client via some URI
■
Instantiating the Silverlight plug-in on the web page or within a hosting out-of-
browser process
That’s it. There’s no additional installation, no MSI to install, no registry entries, no
elevation prompts (unless you request elevated rights). It’s all about getting content
down to the end user and instantiated in the plug-in with as little friction as possible.
The subtleties of how that process works are what I find particularly interesting.
 When I first learned ASP.NET—back when a 17-inch display would take up your
whole desk, contain more glass than your car, and weigh about 200 lbs.—one of the
things I was most curious about was the startup cycle and the order of events when a
request was made. If you want to understand how to target a particular application
platform, you need to know how it’s going to run your application, when things get
loaded, when they’re rendered, and how key decisions are made—the application
startup process.

49
The Silverlight application model
3.1.1
Application startup process
What happens when you enter a web page that contains a Silverlight application? The
application startup process is shown in figure 3.1. The flowchart includes the details
for Silverlight 1 through 5 but doesn’t address dynamic languages. The “XAML or
XAP?” step is what makes the decision between the old Silverlight 1.0 model and the
current Silverlight 2+ model. That decision is based on a combination of the source (a
XAML or XAP file) and the specified type property of the plug-in.
Browser Loads 
HTML and Files
Required
Version
Installed?
XAML
or
XAP?
Display Install
Experience
Custom
Splash
Screen?
Load Custom
Splash XAML 
and Wire Events
Show Default
Splash Screen
Download
Xap
Read App
Manifest
Load
Assemblies
Instantiate
Entry Point 
Class
Class
Call App
Startup Handler
Load Root
Visual
Render / Run
Call JavaScript
Event Handlers
No
Yes
XAML
Xap
Yes
End
Figure 3.1
The Silverlight startup process. This 
flowchart describes the loading process from the load 
of the HTML page to the execution of the events on 
the root visual of a Silverlight application.

50
CHAPTER 3
The application model and the plug-in
The dotted line between the JavaScript and the managed code event handlers is there
because, though you typically wouldn’t do it, you can have both JavaScript and man-
aged handlers active for the load event of the application. The order in which they
fire in relation to each other isn’t guaranteed.
 Some additional parts of the process aren’t displayed in figure 3.1 but are interest-
ing nonetheless. For example, when the Silverlight plug-in determines it’ll have a
managed code XAP file to work with, it loads the Silverlight .NET CLR (CoreCLR) into
the memory space of the browser.
Apparent in all this is that the most important artifact in the process is the Silverlight
application itself: the XAP file. 
3.1.2
XAP
A managed code Silverlight application is
packaged into a XAP when built. A XAP is sim-
ply a zip file and may be inspected by renam-
ing it to .zip and opening it with any zip-
compatible archiver. The contents of a typical
XAP file are shown in figure 3.2.
 This compressed file will always contain a
manifest file named AppManifest.xaml. In
addition, there will always be a DLL file that
serves as the entry point to the Silverlight
application. This application may require
other Silverlight libraries, service connection information, or other types of content.
Content items and additional libraries may be in the application XAP file or down-
loaded at runtime; either way, they represent the dependencies of the application.
 Because the XAP file is a zip-compatible compressed archive, you may alter its con-
tents and rezip it after compilation. Reasons for doing this include updating the ser-
vice references to move from (for example) a test environment to a production
environment or altering other environment or customer-specific XML configuration
files, branding assets, or other content. 
CoreCLR
Silverlight uses a version of the CLR known as CoreCLR. This is a version of the .NET
CLR that has been optimized for size and use for client-side RIAs. The CoreCLR shares
code with the full .NET CLR for core bits such as the type system, the workstation-
optimized garbage collector, and the just-in-time (JIT) compiler. These size optimiza-
tions and intelligent decisions on what is and isn’t necessary for a client-side RIA allow
the Silverlight plug-in, including the CoreCLR, to come in at around 8 MB total size.
For more details on CoreCLR, see Andrew Pardoe’s CoreCLR MSDN article at http://
msdn.microsoft.com/en-us/magazine/cc721609.aspx.
MyApp.xap
AppManifest.xaml
MyApp.dll
ServiceReferences.ClientConfig
Additional Libraries (.dll)
Packaged Content (images, media, etc.)
Figure 3.2
Structure of a typical XAP 
file showing the types of files that are 
normally included

51
The Silverlight application model
 You can also slightly decrease a XAP file’s size by rezipping it with an efficient zip
tool such as the open source 7-Zip, at the expense of a slightly slower decompression
and application startup time on older machines. This may be important in situations
where bandwidth is at an extreme premium.
 The XAP contains a number of different files, one of which is the file that tells Sil-
verlight what other files the XAP contains and where to find the application entry
point—the application manifest file. 
3.1.3
The application manifest file
The manifest file is responsible for describing the Silverlight application to the Silver-
light runtime. This file is created at build time by Visual Studio and is almost never
hand edited. 
 The Silverlight runtime reads the AppManifest.xaml file beginning with the root-
most element, Deployment. This element exposes two attributes that tell the Silver-
light runtime how to start the Silverlight application, as shown here:
<Deployment 
  xmlns="http://schemas.microsoft.com/client/2007/deployment"   
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
  EntryPointAssembly="MyApp" EntryPointType="MyApp.App"  
  RuntimeVersion="5.0.61027.0">                          
  <Deployment.Parts>                                     
    <AssemblyPart x:Name="MyApp" Source="MyApp.dll" />     
  </Deployment.Parts>
</Deployment>
This example shows a basic manifest file, which uses the EntryPointAssembly and
EntryPointType attributes to launch the Silverlight application. (61027 will corre-
spond to the build you use. This number gets updated with service releases.) The first
attribute, EntryPointAssembly, will always reference one of the AssemblyPart ele-
ments in the Deployment.Parts section. The second attribute, EntryPointType,
explains which class should be used to start the Silverlight application. The third attri-
bute, called RuntimeVersion, broadcasts the version of the Silverlight runtime that
the Silverlight application was built with.
NOTE
AppManifest.xaml is generated during project compilation based on
the settings found in the project’s property pages. If you change the name
and/or namespace of the startup application class (App), you must adjust the
startup object setting in the Silverlight property page. If you forget to make
these changes, you’ll get a runtime error mentioning an invalid or missing Sil-
verlight application. Also note that an appmanifest file with no deployment
parts, entrypoint, or runtime version is the default behavior for simple Silver-
light applications.
The Deployment section of the manifest contains two sections: 
■
Deployment.Parts
■
Deployment.ExternalParts

52
CHAPTER 3
The application model and the plug-in
I’ll cover Deployment.ExternalParts in section 3.1.6 when I discuss assembly caching
because it’s only used in caching situations. Deployment.Parts is used regardless of
the caching strategy used.
DEPLOYMENT.PARTS
The Deployment.Parts section includes a collection of AssemblyPart entries, each of
which corresponds to a DLL in our application. In a complete application, at least one
of the DLLs will be the entry point assembly.
 As you saw here, the application manifest contains a reference to the startup object
type and assembly. The startup object is always the Silverlight application object. 
3.1.4
The Silverlight application object
The entry point into the Silverlight application is the App object. This object is defined
in the App.xaml and App.xaml.cs files and derives from the System.Windows
.Application type. This type allows you to interact with the three events affecting the
application’s lifecycle—the start of the application, the unhandled errors in the appli-
cation, and the exit of the application. In addition to these events, you can read the
settings of the hosting plug-in.
MANAGING THE START OF A SILVERLIGHT APPLICATION
Once the App object has been created, the Startup event fires. By default, this event
loads the default XAML page into view. You can also use this event to perform any
other type of application initialization task. For instance, you may want to use this
event to set application-wide resources or properties. Or you may want to use this
event to load the initParams that were passed into the application (see section 3.3.4).
Either way, this type of task can be accomplished by using the Startup event: 
private void Application_Startup(object sender, StartupEventArgs e)
{
  foreach (string key in e.InitParams.Keys)             
  { 
    // Process the initParam from the createObjectEx function
  } 
  this.RootVisual = new MainPage();
}
This particular event handler shows how to parse the initParams that may have been
passed into the application. The Startup event creates a StartupEventArgs variable
that assists in the initialization tasks. The first iterates through the initialization param-
eters. You could access the individual dictionary entries by a string key. The second
task in this listing displays the first page of the application. Both of these tasks intro-
duce important facts about the Silverlight application lifecycle.
 The first important fact is that the StartupEventArgs type is created only by the
Startup event. No other event in Silverlight will create a StartupEventArgs object.
Because of this, it’s logical to deduce that the InitParams used in the preceding code
are only available during application startup. If you’re going to use initialization
parameters, the Startup event is your only chance to use them. If you need to access

53
The Silverlight application model
them throughout the application, you’ll want to store them in a singleton application
settings object or a data class of your own creation. In addition to the initialization
parameters, you should consider the RootVisual.
 The RootVisual is the content that Silverlight will load into the root of the object
tree. (For more on object trees, see chapter 2.) Typically, this is a master-page style
application page. In the default Silverlight templates, it’s MainPage. 
 Once set, the RootVisual of the application can’t be changed for the lifetime of
the application. This may cause confusion because you may wonder how to switch
pages in a Silverlight application. Think of the RootVisual in a complex multipage
application more as a container for other content pages. You’ll learn more about that
when I discuss navigation in chapter 29. For now, know that when the Startup event
has completed, the RootVisual will be loaded and rendered. At this point, a Silver-
light application will be visible to your users, so let’s begin discussing how to guard
against unforeseen errors.
HANDLING UNFORESEEN ERRORS
The Application.UnhandledException event enables you to handle uncaught excep-
tions. Any Exception that hasn’t been caught by a try-catch block in the application
will be sent here. This is the last chance to gracefully deal with an unknown problem
by displaying a message or perhaps logging to a service or isolated storage:
private void Application_UnhandledException(object sender,   
  ApplicationUnhandledExceptionEventArgs e)
{
  LogError(e.ExceptionObject); 
  e.Handled = true;  
}
This shows a basic UnhandledException event handler. The event handler uses an
argument to assist in properly handling an unhandled exception. This argument is of
the ApplicationUnhandledExceptionEventArgs type, giving you access to the
Exception that caused the event through the ExceptionObject property. Once this
Exception has been dealt with, you need to signal that you’ve found an acceptable
solution. You can do so by setting the ApplicationUnhandledExceptionEventArgs
object’s Handled property.
 The Handled property is a bool value that signals whether an exception has been
addressed. By default this property value is set to false, but you have the opportunity
to set it to true within your code. By setting this property to true, you signal that your
Silverlight application should continue to run. If this property remains false, the
Silverlight plug-in will unload the application, causing the plug-in’s onError event to
be fired. I’ll discuss this event in section 3.3.3. Note that this unnatural way of ending
an application won’t trigger the Application.Exit event.
EXITING THE SILVERLIGHT APPLICATION
The Application.Exit event is the last thing that occurs before an application is shut
down and provides one final opportunity to wrap things up. This event can be useful

54
CHAPTER 3
The application model and the plug-in
for logging information or performing last-minute saves. The Application.Exit
event is fired when one of the following happens:
■
The user closes the browser window.
■
The user closes the browser tab that the Silverlight application is running in.
■
The user navigates away from the Silverlight application (such as going from
www.10rem.net to www.silverlightinaction.com).
■
The user closes the out-of-browser application.
■
The HTML element associated with the Silverlight plug-in is removed from the
HTML Document Object Model (DOM).
This event doesn’t have any special event-handling parameters like the Startup and
UnhandledException events, but it can still read settings associated with the plug-in, if
needed. Note that, when this event is fired, the browser has already been closed (if
closing was the cause) and the Silverlight application has already disappeared. There-
fore, displaying a XAML UI or attempting to prevent the browser page from closing
isn’t supported. You may display a message box if you absolutely must get some UI in
front of the user:
private void Application_Exit(object sender, EventArgs e)
{
    MessageBox.Show("Daisy, daisy...");
}
But you can still obtain information about the HTML page that’s hosting the applica-
tion when running in-browser. For example, this code displays a message box contain-
ing the URL of the page hosting the Silverlight application, even though that page is
no longer visible:
private void Application_Exit(object sender, EventArgs e)
{
    HtmlDocument doc = System.Windows.Browser.HtmlPage.Document;
    MessageBox.Show(doc.DocumentUri.ToString());
}
Keep in mind that other dynamic elements on the HTML page may have their own
shutdown handling, so be careful of how much you access from this event. A best prac-
tice is to do as little as possible in this event, keeping in mind that you no longer have
the Silverlight UI displayed to the user.
 One thing you can do in this event (and the others) is read plug-in settings.
READING PLUG-IN SETTINGS
Once the Silverlight application has been loaded, you can retrieve information about
the hosting plug-in. This plug-in exposes information set during the creation of the
plug-in (createObjectEx; see section 3.2.3). This information is useful throughout
the entire life of the application and can be accessed through the Host property of the
Application:
Application.Current.Host; 

55
The Silverlight application model
The Host property on the Application object is a SilverlightHost, which gives you
access to information about the plug-in. The information is listed and described in
table 3.1.
The properties available through the SilverlightHost object give you access to most
of the information discussed in this chapter, which enables you to dynamically create a
truly integrated experience. This experience will have a beginning, which can be man-
aged through the Startup event and it will have an ending, which can be handled
through the Exit event. These are the main events affecting the life of an Applica-
tion. In addition, this Application may have other types of content that it depends
on. This content makes up what are known as the application dependencies. 
3.1.5
Application dependencies
Application dependencies are items that your application needs to run correctly. These
items include assemblies, images, audio or video files, fonts, XAML files, configuration
files, or any other type of file. Each file that’ll be used by the Silverlight application
can be included in the XAP file. This approach can ensure a faster access time, but it
can also cause a slower initial download of your application.
 To help you overcome long load times, Silverlight lets you divide your application
into smaller chunks that can be downloaded as they’re needed. This approach can
ensure a faster initial application download, but it doesn’t happen automatically.
Instead, you must rely on a class called WebClient, which is discussed in chapter 19, or
use the built-in partitioning functionality from the Managed Extensibility Framework
(MEF). For now, just know that you have a way of including application dependencies.
 Application dependencies belong to just one set of the items you may find in a XAP
file. This file also includes a DLL, which contains an Application. This Application is
described by the AppManifest.xaml file, which is used by the Silverlight runtime to
start the application.
 Other DLLs required on initial load of the application must either be included in
the XAP file or found through the assembly cache. 
Table 3.1
The properties of the SilverlightHost object
Property
Description
Background
Retrieves the background Color of the plug-in.
Content
The content subobject of the createObjectEx function call. This includes the 
height and width of the plug-in.
IsLoaded
Returns whether the hosting plug-in has completed loading.
Settings
The settings subobject of the createObjectEx function call. This subobject 
relays information about the Silverlight application’s instantiation settings. In addition, 
this subobject provides values associated with the HTML DOM.
Source
The Uri of the currently loaded XAML content.

56
CHAPTER 3
The application model and the plug-in
3.1.6
Assembly caching 
Assembly caching was introduced with
Silverlight 3 to provide a way to avoid
packaging common DLLs into every
application XAP. Because the DLLs
are usually hosted on your own
server, you may include both third-
party DLLs and DLLs common across
your own applications. This can
reduce initial application load time
and make subsequent upgrades to
your application easy to deploy and
superfast to download.
 To use assembly caching, select the Reduce XAP Size by Using Application Library
Caching option on the project Silverlight property page, as shown in figure 3.3.
Note that assembly caching is available only for browser-hosted applications—it
doesn’t currently work for out-of-browser applications.
HOW IT WORKS
Here’s the Deployment.Parts section of the application manifest for a simple applica-
tion that uses one Microsoft assembly not included in the core runtime:
<Deployment.Parts>
  <AssemblyPart x:Name="AssemblyCaching" 
                Source="AssemblyCaching.dll" />
  <AssemblyPart x:Name="System.ComponentModel.DataAnnotations"
                Source="System.ComponentModel.DataAnnotations.dll" />
</Deployment.Parts>
Note that you have your application assembly AssemblyCaching.dll and the Microsoft
assembly all packaged in the same XAP file. The resulting file size is 29 KB—hardly
large by web standards, but it could be even smaller.
 Once you select the option to use cached framework extension assemblies, the
manifest changes to include a new section named Deployment.ExternalParts:
<Deployment.Parts>
  <AssemblyPart x:Name="AssemblyCaching" Source="AssemblyCaching.dll" />
</Deployment.Parts>
<Deployment.ExternalParts>
  <ExtensionPart Source="System.ComponentModel.DataAnnotations.zip" />
</Deployment.ExternalParts>
The ExtensionPart entries in the Deployment.ExternalParts section correspond to
the Microsoft DLL that was originally packaged in your application. Now instead of
including them in the application package, they’ll be downloaded from your server
on first access, then cached locally for future use. Upon compiling your application,
you’ll see that the ClientBin folder on the website will have one zip file added for each
Figure 3.3
Setting the assembly caching option via 
the project property pages for the Silverlight project

57
The Silverlight application model
ExtensionPart included in the manifest. Each zip file contains just the compressed
DLL—no additional baggage.
TIP
If you want to reduce per-application load time on a site that uses Silver-
light on various pages, you could preload the cache by creating a small headless
Silverlight application on a landing page and ensuring that it references all the
required assemblies and has assembly caching turned on. Your decision
depends on the nature of the site and the landing page and whether you con-
sider it okay to download several kilobytes of binaries that may not be used.
Assembly caching is available for any assembly you use. The core Microsoft DLLs have
a built-in support because they include <dllname>.extmap.xml files for each DLL in the
software development kit (SDK). If you want to add support for your own (or third-
party) DLLs, you’ll need to create an .extmap.xml file for each DLL. The .extmap.xml
file looks like this:
<?xml version="1.0"?>
<manifest xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <assembly>
    <name>System.ComponentModel.DataAnnotations</name>
    <version>2.0.5.0</version>
    <publickeytoken>31bf3856ad364e35</publickeytoken>
    <relpath>System.ComponentModel.DataAnnotations.dll</relpath>
    <extension downloadUri="System.ComponentModel.DataAnnotations.zip" />
  </assembly>
</manifest>
If you provide an absolute URI, the assembly will be served up by that URI. This is use-
ful for third parties or independent software vendors (ISVs) who may want to offer
hosting of their DLLs or for organizations that want to have a centralized location for
common application DLLs. Note that the server hosting the DLL will need to adhere
to cross-domain restrictions by providing a ClientAccessPolicy.xml file to support cli-
ents calling it from other servers.
 The files are cached in the default browser cache for the current browser so they
can be used by any other Silverlight application that has enabled assembly caching. If
you use multiple browsers, you’ll need to download and cache for each browser just
like any other web content. Similarly, the content can be cleared from the cache like
any other browser content.
 The end result is a XAP that weighs in at all of 4 KB, much smaller than most on-
page icons and an almost instantaneous download for your users. Assembly caching
can make a significant difference in the load time of your applications.
 At this point, I’ve covered all the core parts of a Silverlight application, including
the startup process, key events, packaging applications, and sharing assemblies
between applications. Next I’ll discuss how to surface those applications on a web
page using the Silverlight plug-in. 

58
CHAPTER 3
The application model and the plug-in
3.2
Creating the Silverlight plug-in
The Silverlight plug-in is a lightweight cross-platform browser plug-in responsible for
rendering Silverlight content. To ensure cross-platform and cross-browser support,
the Silverlight plug-in must take advantage of each browser’s plug-in technology. This
requirement forces the plug-in to be packaged differently across platforms. For
instance, when Silverlight runs within Microsoft’s Internet Explorer browser, the
ActiveX model is used. Alternatively, if Safari or Chrome is used, the WebKit model is
used. When any other browser is used, the plug-in uses the Netscape Server API
(NSAPI) plug-in approach. Regardless of the combination of browsers a user chooses,
Silverlight needs to be installed only one time on a workstation to work across all sup-
ported browsers.
 The Silverlight installation is extremely compact, weighing in at around 7–8 MB on
Windows. This installation requires that users have administrative privileges on their
machines. If they don’t have these privileges, an administrator will need to assist them.
Once the Silverlight plug-in is installed on their machines, users are free to enjoy rich
Silverlight content in the browser of their choice without additional installation
requirements.
The goal of creating a Silverlight plug-in is to host a Silverlight application. This plug-
in can be created in at least two different ways, not counting things like custom MVC
Razor tags. One approach is to use the HTML object tag directly. 
 Another approach for creating a Silverlight plug-in enables you to easily deliver Sil-
verlight content through any server technology while ensuring maximum flexibility
on the client. You can use Silverlight along with a variety of technologies, including
PHP, JSP, ASP, and ASP.NET. To get Silverlight to work with these technologies, you use
the two steps covered in this section. The first step is to reference the required Silver-
light JavaScript utility file. The second step involves writing the JavaScript that’ll create
an instance of the Silverlight plug-in.
Installation rights
Silverlight requires administrative rights to install the plug-in on Windows OSs. This
was a conscious decision by the Silverlight team to allow Silverlight to be installed
once per machine rather than require managing installations per user, per machine.
In centrally managed environments, where administrative rights aren’t typically given
to users, Silverlight may be installed via tools such as Windows Server Update Services
(WSUS). Once the plug-in is installed, individual applications don’t require admin rights
because they’re treated as content by the browser.

59
Creating the Silverlight plug-in
 The pros and cons of the two approaches are covered in table 3.2.
3.2.1
Using the object tag
You may choose to explicitly create the object tag that hosts your Silverlight applica-
tion. This approach is used in the “Instantiating a Silverlight Plug-In” section of the
Silverlight SDK. I use the Silverlight.js approach in this book because there are addi-
tional methods, such as buildPromptInstall and isInstalled, in the Silverlight.js
file. If you want to explicitly create an object tag, you can do so by embedding code
similar to the following:
<div id="mySilverlightHost" style="height:100%;">
  <object 
    id="SilverlightPlugInID"
    data="data:application/x-silverlight-2," 
    type="application/x-silverlight-2" 
    width="100%" height="100%">
    <param name="source" value="ClientBin/MySilverlightApp.xap" />
  </object>    
  </div>
Note that the data and type are both x-silverlight-2. The -2 in this case doesn’t
mean Silverlight 2; it means version 2 of the Silverlight MIME type. If in the future
Microsoft decides to change the object tag signature in some way, it may introduce an
x-silverlight-3 for MIME type version 3 even though the related version of Silver-
light may be something like Silverlight 5. That’s not expected at this time.
 In general, the properties specific to the Silverlight plug-in can be set through the
param elements. There are some exceptions to this. If you decide to explicitly create
the object tag, I recommend referring to the documentation in the Silverlight SDK.
Table 3.2
Pros and cons of the two plug-in creation approaches
Approach
Pros
Cons
HTML object tag
No additional libraries
No server dependency
Basic installation experience
Older versions of Internet Explorer 
displayed a warning dialog
Silverlight.js 
utility functions
Complete control over the installation 
experience for various client configurations
No server dependency
Additional effort
Requires keeping the Silverlight.js 
file up to date
Getting just a blank page?
There are many reasons why you might get the Silverlight White Screen of Death
(WSOD), such as bad XAML, incorrect XAP file location, errors in startup code, and
so forth. The WSOD appears when the Silverlight plug-in is present and instantiated
(verified by right-clicking) but devoid of content. (Mac users: Every time you see “right-
click,” think “Control-click.” No need to constantly remind you.)

60
CHAPTER 3
The application model and the plug-in
3.2.2
Using the Silverlight.js utility file
The Silverlight.js utility file is part of the free Silverlight SDK and part of the Visual
Studio Silverlight project templates. The Silverlight SDK is available through the
Silverlight website at http://silverlight.net/getstarted, and installed as part of the Sil-
verlight tools installation package. Once you’ve downloaded the SDK, you can find the
Silverlight.js file in the installation’s Tools directory. This file is an integral part of
every Silverlight application, so you should know where to find it. Then, you can dis-
tribute and reference this file within your applications. Once it’s referenced, you can
use any number of the valuable features exposed by this file.
NOTE
Microsoft periodically releases new versions of the Silverlight.js file,
related files such as Silverlight.supportedUserAgent.js, and associated docu-
mentation. To facilitate distribution to developers, Microsoft created a Code
Gallery project for Silverlight.js. You can download the latest version of Silver-
light.js from http://code.msdn.microsoft.com/silverlightjs.
REFERENCING THE SILVERLIGHT.JS FILE
The Silverlight.js file is licensed under the Microsoft Public License (Ms-PL), which
allows you to modify the file to suit your own needs if necessary. Referencing the Sil-
verlight.js file is as easy as referencing any other script file: you set the src property of
an HTML script tag: 
<html xmlns="http://www.w3.org/1999/xhtml" >
<head>
  <title>My Silverlight Project</title>
  <script type="text/javascript" src="Silverlight.js"></script>
  <!-- Other Script and Style References -->
</head>
<body>
  <!-- We will create a Silverlight plug-in here -->
</body>
</html>
You gain the ability to create a Silverlight plug-in by adding a reference to the Silver-
light.js JavaScript file. Let’s look at what’s inside.
FUNCTIONS OF THE SILVERLIGHT.JS FILE
The Silverlight.js file exposes a number of valuable functions, all of which give you the
flexibility to tailor a custom experience within a web application. Table 3.3 describes
the primary utility functions, in alphabetical order.
(continued)
One of the most common WSOD causes for first-time users is a missing MIME type
on the web server. If you’re using Windows Server 2003 or older, ensure the MIME
type x-silverlight-app is registered. This MIME type is present on Windows Server
2008 R1 and newer. Many other web servers, such as some versions of Apache, will
serve the content up without any MIME type registration.

61
Creating the Silverlight plug-in
These methods provide a powerful arsenal of options to help deliver the appropriate
experience to your users. But two options encapsulate most of the other functions
under one roof—the createObject and createObjectEx functions. These two utility
functions shoulder the responsibility of creating an instance of the Silverlight plug-in.
3.2.3
Creating an instance of the Silverlight plug-in
To initialize and create a Silverlight plug-in, you use one of two utility functions:
createObject or createObjectEx. These methods do the same thing; in fact,
createObjectEx calls createObject. But the createObjectEx function uses the more
verbose JavaScript Object Notation (JSON) approach to pass in the necessary parame-
ters. For this reason, I’ll use createObjectEx in this book.
 The createObjectEx function requires an HTML element as a parameter. This ele-
ment ultimately serves as the host for the Silverlight plug-in. Because of this, you must
first either identify or create the HTML element to serve as the host. Within that ele-
ment, you then call the createObjectEx method to add a Silverlight control as a child
to the hosting HTML element. The creation process is shown in listing 3.1.
<html xmlns="http://www.w3.org/1999/xhtml" >
<head>
  <title>My Silverlight Project</title>    
  <script type="text/javascript" src="Silverlight.js"></script>
</head>
<body style="height:100%">
  <div id="mySilverlightHost" style="height:100%;"> 
Table 3.3
The primary utility functions exposed through the Silverlight.js utility file
Function name
Function description
buildPromptHTML
Returns the HTML that creates the Silverlight installation prompt. Takes 
a Silverlight object in order to determine the prompt to build.
createObject/ 
createObjectEx
Initializes and creates a Silverlight plug-in. The details and a sample of 
this method are included in the next section. In addition, the next sec-
tion will explain the difference between the createObjectEx and 
createObject functions.
HtmlAttributeEncode
Performs basic operations to encode a string into an HTML-encoded 
string. This internal function was primarily designed to be used only 
within the realm of the Silverlight.js file, so use caution. Here’s an 
example:
var result = 
Silverlight.HtmlAttributeEncode('"Hello"');
isInstalled
Returns whether a specific version of the Silverlight runtime is available. 
This method takes one parameter, a string that represents a version 
number. Here’s an example:
var result = Silverlight.isInstalled("3.0"); 
Listing 3.1
Instantiating the Silverlight control (HTML)
Silverlight.js 
reference
Hosting DIV

62
CHAPTER 3
The application model and the plug-in
    <script type="text/javascript">
                                              
      Silverlight.createObjectEx({             
        source: "ClientBin/MySilverlightApp.xap",
        parentElement: document.getElementById("mySilverlightHost"),
       id: "mySilverlightControl",
         properties: {
           width: "100%",
           height: "100%",
           version: "5.0"
         },
         events: {}
      });
    </script>
  </div>
</body>
</html>
This listing demonstrates the two main steps of creating a Silverlight plug-in. The first
step is to reference the Silverlight.js utility file. Once this file is referenced, you create
an instance of the Silverlight plug-in, in a specific HTML <div> tag, using the create-
ObjectEx function.
 This function accepts a wide range of parameters, which are responsible for speci-
fying which Silverlight application to run and how it should be integrated within a
web page. Because a Silverlight application will ultimately be integrated within a web
page, even if only as the installation source for an out-of-browser application, I’ll
explain how to integrate a Silverlight control with the surrounding page. 
3.3
Integrating the Silverlight plug-in
Once you’ve decided to create a Silverlight plug-in, you must ensure that it integrates
nicely within your web page. This integration must not only look right but must also
behave properly. So, let’s study the items you can control. At a high level, these items
give you the ability to
■
Relate your Silverlight application to the HTML DOM
■
Clarify the initial experience
■
Handle plug-in events
■
Send initialization parameters
These general tasks cover a lot of ground, but I’m going to dive into the details that
make each task possible.
3.3.1
Relating the Silverlight application to the HTML DOM
The first three parameters of the createObjectEx function build the relationship
between a Silverlight application and the HTML DOM. These parameters are called
source, parentElement, and id.
Create
Silverlight
object

63
Integrating the Silverlight plug-in
SOURCE
The source parameter specifies the URI of the Silverlight content that should be
loaded. In a managed code application, this content is bundled as a XAP file, as dis-
cussed earlier in this chapter. The source property can reference a XAP file on the
hosting server or on a remote server. This gives you the ability to easily share your Sil-
verlight applications and improve server performance through load balancing. This
wasn’t as easy with Silverlight 1.0.
 Silverlight 1.0 didn’t have support for XAP files. Instead, Silverlight 1.0 relied on
setting the source of a plug-in through one of two approaches. The first approach
involved referencing a XAML file that exists on the hosting server. The other approach
was to reference XAML content defined in the hosting web page. This type of XAML
content is known as inline XAML. Either way, both of these approaches are dependent
on the JavaScript programming model. Although rarely used, Silverlight 2+ still sup-
ports these approaches so that the source property in Silverlight 5 can be used in
three different ways, all of which are shown in table 3.4.
We won’t be discussing the loose and inline approaches in detail because the XAP
packaged approach is the most widely used and is the only option that supports the
managed code Silverlight 2+ APIs. Microsoft recommends the XAP approach because
of its flexible, compact, and portable nature. Regardless of the approach you choose,
the Silverlight plug-in is always placed inside the parentElement.
PARENTELEMENT
The parentElement parameter specifies the HTML object that hosts the Silverlight
plug-in. It’s important to recognize that this property requires an object and not just
the ID of the parent. You may need to use the HTML DOM approach of retrieving an
object using document.getElementById. Once the object is retrieved, a new HTML
element will be appended to it when the Silverlight plug-in is created.
 The specific type of object that’s created is based on the user’s browser. If the user
is using Microsoft Internet Explorer, Google Chrome, or Mozilla Firefox, an HTML
OBJECT element is created. Alternatively, if the user is using Apple Safari, an HTML
EMBED element is created. Regardless of the type of object, it gets appended to the ele-
ment you defined as the parentElement.
 This newly created HTML object is given the unique identifier you set in the id
parameter.
Table 3.4
Three approaches for referencing a Silverlight application
Approach
File extension
Examplea
a. Assuming this is part of a createObjectEx call
Packaged
.xap
source: "http://www.myserver.com/myApp.xap"
Loose
.xaml
source: "/relativePath/page.xaml"
Inline
[none]
source: "#myXamlID"

64
CHAPTER 3
The application model and the plug-in
ID
The unique identifier of the Silverlight plug-in is specified by the third parameter of
the createObjectEx method, id. The value you must supply to this parameter is the
id attribute of the OBJECT or EMBED element mentioned in the previous section. This
parameter is the primary hook from the HTML DOM to the Silverlight plug-in. You can
easily access a Silverlight plug-in using the document.getElementById function. This
function is available within the HTML DOM Document object, and you can use it from a
scripting environment such as JavaScript. This fact will come into play at the end of
this chapter. But first I’ll show you how to clarify a user’s default experience. 
3.3.2
Clarifying the initial experience
While a Silverlight plug-in is being initialized, a number of properties clarify how that
plug-in will initially render. These properties are demonstrated here: 
Silverlight.createObjectEx({ 
  source: "ClientBin/MySilverlightApp.xap", 
  parentElement: document.getElementById("mySilverlightHost"), 
  id: "mySilverlightControl", 
  properties: {
    height: "100%", 
    width: "100%", 
    background: "blue", 
    isWindowless: "true", 
    frameRate: "30", 
    inplaceInstallPrompt: true, 
    version: "5.0", 
    ignoreBrowserVer: "true", 
    enableHtmlAccess: "true" 
  },
  events: {} 
});   
These properties can be used to define an initial experience. (All the properties listed
here use pretend values to show the syntax.) We’ll explain the details of each of these
properties in the order they’re shown. In addition, these properties will be logically
grouped together when possible, such as grouping height and width.
HEIGHT AND WIDTH
The height and width properties specify the boundaries of the rectangular region
that the Silverlight application will be presented within. By default, these property val-
ues represent a rectangle with no height and no width. You can change this by pro-
viding either a pixel or percentage value, as you can with other HTML elements to
provide either absolute or relative sizing. 
Relative sizing is a widely used technique in the HTML world, so it’s nice to see that
the Silverlight plug-in provides this option to simplify integration efforts. To further
integrate your Silverlight content within the HTML page, you need to use the back-
ground and isWindowless properties.

65
Integrating the Silverlight plug-in
BACKGROUND AND ISWINDOWLESS
The background property allows you to specify the color of the rectangular region
where the Silverlight plug-in will appear. By default, this property is set to null, which
is the same as white. There are two techniques for setting this property value. The first
is to use a hexadecimal color value. The second is to use a color name recognized by
the user’s browser, such as Silver. Perhaps the most interesting known color name,
though, enables you to hide the background entirely.
 By setting the background property to transparent, you can make the background
of the plug-in region invisible. At the same time, your Silverlight application is still vis-
ible. Before you get too excited, I strongly recommend searching for alternatives
before using this option. When the background property is set to transparent, your
Silverlight applications will incur a significant performance hit, which may detract
from a user’s experience, especially when playing media or doing heavy animation. If
you choose to use the transparent option, it’s important to take the isWindowless
property into consideration.
 The isWindowless property lets you determine whether the plug-in allows any
underlying HTML content to display through any transparent areas. By default, this
property is set to false, meaning that your Silverlight plug-in will appear on top of
any underlying HTML content. This property defaults to false because, once again,
when this value is set to true, your Silverlight application will take a significant perfor-
mance hit.
 Setting the isWindowless property to true does have an advantage. When this
property is true, any underlying HTML content will show through the transparent
areas of the Silverlight plug-in. This option is most useful when you want seamless
integration with an HTML page such as flyovers and overlays. As figure 3.4 shows, the
background and isWindowless properties are somewhat reliant on each other.
 It’s critical to your integration efforts to understand how the background and
isWindowless properties cooperate. As the third image in figure 3.4 shows, setting the
background property to transparent is only half the battle. The fourth image shows
Figure 3.4
The consequences of various background and isWindowless property 
combinations. The outermost rectangle represents a section of HTML within a web page. The 
inner rectangle represents the region occupied by a Silverlight plug-in. The rounded rectangle 
is the pure Silverlight content, which will be explained later.

66
CHAPTER 3
The application model and the plug-in
that you truly have the ability to seamlessly integrate Silverlight content within your
web assets by setting both the background and isWindowless properties. The process
of integration will become clearer to you once I begin discussing the Silverlight con-
tent in the next chapter. 
FRAMERATE
The frameRate property (object tag and ASP.NET property name: MaxFrameRate)
enables you to determine the maximum number of frames you want to render per sec-
ond. This built-in throttling mechanism ensures that your Silverlight plug-in doesn’t
hog the system resources. By default, this property is set to render 60, which is more
than most non-media applications need, so feel free to experiment. Ultimately, the
frame rate is based on the available system resources. For more on frame rate and the
rendering process, see section 7.2.
 To view the actual frame rate, set the EnableFrame-
RateCounter plug-in property (enableFrameRateCounter
in JavaScript) to true. This will show the actual and max
frame rates in the browser status bar, as seen in figure 3.5.
Note that this feature only works in Internet Explorer on
Windows.
VERSION
When instantiating a Silverlight plug-in, you need to set
the version property in the createObjectEx function.
This property represents the minimum runtime version required by your Silverlight
application. If users don’t have at least this version of the Silverlight runtime installed,
they’ll be greeted by a default installation prompt. This installation prompt looks like
figure 3.6.
 You can override this default image and show something that may be branded or
more appropriate for your specific application. You’ll learn about that in chapter 35
when I discuss optimizing the install experience. Figure 3.6 shows the default visual
prompt users will see if they don’t have the necessary version of Silverlight installed. 
 Once Silverlight is installed, it’ll automatically install future versions of Silver-
light—if configured to do so. These updates will continue to be installed as long as the
users don’t disable this feature in the Silverlight Configuration dialog box, shown in
Figure 3.5
The browser 
window displaying the 
current and maximum 
frame rates in a CPU-
intensive application
Figure 3.6
The default Silverlight installation badge 
displayed when the user doesn’t have the required 
Silverlight version installed

67
Integrating the Silverlight plug-in
figure 3.7 . The dialog box can be accessed by right-clicking any Silverlight application
in the browser.
NOTE
Windows 7 and 8, and Windows Vista users with User Account Control
(UAC) enabled won’t have the option to install updates automatically. In
those instances, Silverlight will require permission to download and install
updates when new updates are found. Windows Vista and Windows 7 users
are encouraged to choose the second option shown in figure 3.7 to check for
updates and be prompted to install new versions when available.
As you can see, this dialog box gives you the option of turning off automatic updates
of Silverlight. But, by default, users’ machines will typically have the latest and greatest
version of Silverlight.
IGNOREBROWSERVER
The ignoreBrowserVer option empowers you to specify whether you should check to
see if Silverlight can run within the browser environment. By default, this parameter is
set to false, which ensures that only supported browsers will run a Silverlight applica-
tion. You can set this property value to true to bypass this safety check. This brute-
force approach can slightly speed up the plug-in initialization process but can lead to
undesired effects. If you want to support browsers that mostly work but aren’t officially
supported, update the user agent file (available on http://code.msdn.microsoft.com/
SLsupportedUA) instead, so you still maintain control over the spectrum of browsers
that’ll access your application.
ENABLEHTMLACCESS
The final Boolean property in the Silverlight plug-in initialization provides an extra
layer of security. This property, called enableHtmlAccess, specifies whether the
Figure 3.7
The Silverlight 
Configuration dialog 
box (Silverlight 4 adds a 
Webcam/Mic tab). This 
dialog box is accessible 
by right-clicking 
Silverlight content 
within a web browser. 
Administrators may 
configure the Silverlight 
auto-updater for all 
users, thereby disabling 
the ability to change 
options on this screen.

68
CHAPTER 3
The application model and the plug-in
managed code running within a plug-in instance can access the HTML DOM. By
default, this property is set to true for the same domain applications and false for
cross-domain applications. This ensures a safe-by-default development experience.
You can set this property value to true for cross-domain applications, but you should
first consider the ramifications.
NOTE
Cross-domain applications are applications that run on one domain
but are sourced from another. If, for example, you host a web page at http://
www.mycoolsite.com and the XAP file used by the Silverlight plug-in on that
page is served up from http://PetesHouseOfXap.org, that would be a cross-
domain application.
Let’s pretend for a second that a political candidate (I’ll call him Gill Thrives) has cre-
ated a Silverlight application that everybody wants. This application is so amazing that
even the competing political candidate, Loth Slivering, wants it. Gill makes this con-
trol available for free download via a third-party control site. Gill has deceptively
added code that will edit the hosting web page’s DOM to say “Vote for Gill” on a future
date before the election. Unfortunately for Loth, Loth added this application to his
website, and now his campaign site has been trashed with “Vote for Gill” all over it.
What an embarrassment!
 Loth could’ve easily avoided this time-bomb embarrassment by explicitly setting
the enableHtmlAccess property value to false. When this property value is false,
any managed code associated with the plug-in instance that attempts to access the
HTML DOM will trigger an error. And, fortunately, an error is just a type of event,
which Silverlight enables you to elegantly handle (more on that in a moment).
 The enableHtmlAccess property is but one of the many configuration options you
have. The others are ignoreBrowserVer, inplaceInstallPrompt, version, isWindow-
less, background, height, and width. Collectively, these options are all set through
the properties nested object within createObjectEx. This nested object syntax may
seem awkward at first, but it’s just a part of JSON syntax. This syntax gives you a way to
logically group together items, making it easy to separate the items that define the
look of a Silverlight plug-in instance from its behavior. The behavioral items are part
of the events nested object. 
3.3.3
Handling plug-in events
At this point, we’ve covered all the items required to create an instance of the Silver-
light plug-in. Remember that this plug-in has events that affect it and, in turn, your
application. These events are onLoad and onError. I’ll discuss each in detail but first
let’s look at how to wire these event handlers up with a plug-in instance. This can be
done in the createObjectEx function in the events subobject, as shown here:
Silverlight.createObjectEx({ 
...
  properties: { 
...

69
Integrating the Silverlight plug-in
  },
  events: { 
    onLoad:plugin_Load, 
    onError:plugin_Error 
  } 
});
This shows how to wire up the two events associated with a Silverlight plug-in. In real-
ity, neither has to be set. But, by setting them, you can create a more tailored experi-
ence when loading or handling an unexpected error. Either way, you can accomplish
what you need to by responding to the onLoad and onError events.
ONLOAD
The onLoad event occurs immediately after your Silverlight application has been
loaded. By default, nothing special will happen when this event occurs. You do have
the option of creating an event handler for when this event fires. Regardless of how
you intend to use it, you can create an event handler by using JavaScript like this:
function plugin_Load(sender, context, source)
{
  alert("loaded");
} 
This shows an extremely basic onLoad event handler with the three parameters that
are passed with the onLoad event: sender, context, and source. The purposes of these
parameters are described in table 3.5.
In addition to the parameters of this event, you should know that there are times
when this event won’t fire. This event won’t be triggered if you attempt to reference a
Silverlight application that doesn’t exist. Along the same lines, the onLoad event won’t
fire if there’s an error in your createObjectEx function call. You may think that an
error will fire the onError event; in reality, the onError event will fire only after the
Silverlight application has loaded.
ONERROR
The onError event is triggered when an exception hasn’t been handled by managed
code in your application. But some errors, such as image and media download or play-
back errors, can’t be handled with a managed code unhandled exception handler
(they must be handled in specific events or the onError handler in JavaScript, because
there’s no user code active when they happen). Consequently, you may want to create
Table 3.5
The parameters of the onLoad event handler
Parameter
Description
sender
A handle to the Silverlight plug-in itself.
context
A value specified to distinguish the plug-in instance; this value is provided by a developer.
source
The root element of the content loaded into the plug-in.

70
CHAPTER 3
The application model and the plug-in
an error handler at the plug-in level. You can do so by using an onError event handler
like this:
function plugin_Error(sender, errorArgs)
{
  errorType = errorArgs.ErrorType;
  if (errorType == "ImageError" || errorType == "MediaError")
    return;
  alert("An unexpected error has occurred.");
}
This all-purpose onError event handler can be used to gracefully handle errors that
haven’t been caught elsewhere. When called, the value in the sender parameter rep-
resents the plug-in where the error occurred. The second parameter, errorArgs,
describes the error. This description is accessible through a variety of publicly visible
properties, listed and described in table 3.6.
You can learn a lot about an error through the errorArgs parameter. This parameter
is a valuable part of the onError event handler. As hinted at earlier, this event handler
is useful for some situations that can’t be covered by application-level error handling.
Examples of such an error would be a stack-overflow exception or the media errors
shown earlier. Regardless of the error, it’s nice to know that there’s a way to handle
those errors that can’t be handled elsewhere. It’s also nice to know how to pass initial-
ization information to a Silverlight application when it starts. 
3.3.4
Sending initialization parameters
A Silverlight application is a lot like any other .NET application. As an example, imag-
ine a basic command-line program. This program allows you to pass parameters to it
before it starts. Then, when the application does start, it’s responsible for parsing the
parameters. Once parsed, the application decides what to do with these parameters.
This is exactly how Silverlight uses initialization parameters.
 The initialization parameters in Silverlight are sent through a parameter named
initParams, another parameter in the createObjectEx function. Likewise, there’s a
parameter called context which allows you to uniquely tag a Silverlight plug-in
instance. Both parameters are shown here:
Silverlight.createObjectEx({ 
...
Table 3.6
Properties associated with the errorArgs parameter
Property
Description
ErrorCode
A numeric code associated with the error; this property can’t be set.
ErrorMessage
A read-only description of the error.
ErrorType
The category of the error.
Name
The name of the object that caused the error.

71
Summary
  properties: { 
...
  },
  events: { },
  initParams: "key1=value1, key2=123, keyX=valueY",         
  context: "27d3b786-4e0c-4ae2-97a3-cee8921c7d3d"         
});
This code demonstrates the basic usage of the initParams and context parameters.
Each parameter serves its own special purpose. In reality, you’ll probably use only the
initParams parameter because the context parameter doesn’t have as much value in
the Silverlight 4 world. The reason is because each Silverlight application runs within
its own domain and code sharing isn’t necessary as it is in the scripting world of Silver-
light 1.0. I’ll cover both in detail for the sake of completeness.
INITPARAMS
The initParams parameter enables you to send any number of user-defined, key-
value pairs to a Silverlight application. The application is then responsible for reading
and interpreting the key-value pairs when it starts, as shown in section 3.1.4. But first,
let’s build an understanding of how these key-value pairs are created.
 The key-value pairs are represented in typical dictionary [key]=[value] form, sepa-
rated by commas. Naturally, the entire string of initParams represents a collection
of key-value pairs. This is different from initParams in Silverlight 1.0.
 In Silverlight 1.0, the initParams parameter took a list of comma-delimited values.
This is important to recognize if you’re promoting your Silverlight 1.0 application to
Silverlight 5 because this approach isn’t valid in 5. If you are, in fact, doing this kind of
migration, you may want to consider how the context parameter is used as well.
CONTEXT
The context parameter gives you a way to uniquely identify a Silverlight plug-in. This
plug-in passes the value of the context parameter to the onLoad event associated with
the plug-in. The event then uses this string value to distinguish the plug-in from oth-
ers without having to check the HTML DOM. This empowers you to share scripted
code across multiple Silverlight plug-ins that exist on the same web page.
 The context and initParams serve as valuable initializers in the plug-in creation
process, which involves deciding how to handle the onError and onLoad events
impacting the plug-in. The initial look of this plug-in is set up through a variety of
property settings declared within the properties subobject.
 Initialization parameters and context are great ways to get simple values to Silver-
light applications running in the browser. Keep in mind that those values don’t cur-
rently carry over to applications running out of the browser—something I’ll cover in
chapter 5. 
3.4
Summary
One of the most important things you can learn about any given platform or technol-
ogy is how it handles the concept of an application, including the packaging of that

72
CHAPTER 3
The application model and the plug-in
application and the startup process. Back when I used to write straight C code, and
everything started at int main(int argc, char **argv) with statically linked libraries
into a single EXE or COM file, this was trivial to understand. In more complex technol-
ogies such as Silverlight, both the packaging and the startup processes are significantly
more involved, but the benefits are great. Because of that, you get great things like
internet deployment, browser integration, hands-off memory management, an event-
driven input model, full media, and rich graphics. Who could’ve foreseen that back
when code editors only handled a line at a time, compiles were initiated from the
command prompt, ASCII graphics were popular, and the presence of a working TCP/
IP stack wasn’t a given?
 Once the plug-in is installed on the end-user machines and the hosting page set
up, deploying the application can be as simple as those C programs of yore: just copy
the deployment file (the XAP) to a known location and have at it. The options avail-
able for creating the plug-in allow you to support just about any server environment
and installation experience you’d like. I’ll talk more about custom installation experi-
ences in chapter 35.
 In this chapter I covered HTML page integration primarily from a plug-in-centric
view. In the next chapter I’ll talk more about how to integrate Silverlight with a web
page, including interacting with JavaScript and the DOM. 

73
Working with
HTML and browsers
Silverlight has always been a web technology, integrated into the web page. Even
when a Silverlight application took over the entire browser client area, it was still
contained within several layers of HTML tags. Given the history, it makes sense that
a Silverlight plug-in would have complete access to the Document Object Model
(DOM) on the page in which it resides. In fact, the access is so complete that a
Silverlight application could take over all of the functionality normally provided by
JavaScript if you wanted to go that route.
 Silverlight 4 added the ability for Silverlight to host HTML within itself when
running in out-of-browser mode. Silverlight 5 expanded that to support hosting an
HTML browser when running inside the browser. The integration is provided by the
default browsing engine in the OS and supports some script integration.
This chapter covers
■
Interacting with the HTML Document Object 
Model
■
Scripting Silverlight with JavaScript
■
Hosting HTML in Silverlight

74
CHAPTER 4
Working with HTML and browsers
 This chapter starts where Silverlight started, in the browser, where it can take
advantage of the DOM. From there, I’ll drill deeper into the HTML DOM and discuss
the embedded Silverlight control. This control, also known as the Silverlight plug-in,
ultimately hosts your Silverlight content. Finally, I’ll move on to hosting HTML within
your Silverlight application.
4.1
Silverlight and the HTML DOM
As mentioned in chapter 1, Silver-
light is a browser-based plug-in. This
plug-in was designed to be consis-
tent with the well-established web
architecture. This design decision
ensures that you can integrate Sil-
verlight content within any new or
existing web property. The web
property could be anything from a
web page to a blog, intranet portal,
or desktop gadget. As shown in fig-
ure 4.1, this decision gives you the
flexibility to use as little or as much
Silverlight as you want.
 Figure 4.1 shows the amount of flexibility you have when it comes to using Silver-
light. In reality, you can place Silverlight anywhere you want within a web property.
This is accomplished through Silverlight’s harmonious relationship with the well-
known HTML DOM. The DOM allows you to embed a Silverlight plug-in within it. Once
you embed the plug-in, the overall application tree expands to something similar to
that shown in figure 4.2.
Figure 4.1
Two theoretical in-browser uses of 
Silverlight. The shaded areas represent Silverlight 
applications on web pages.
Figure 4.2
The darkly shaded area 
represents the HTML 
DOM. The lightly 
shaded area represents 
the Silverlight control. 
This control hosts the 
Silverlight Object 
Model.

75
Working with the web page from managed code
The HTML DOM enables you to easily access and manage content in a web page. As
illustrated in figure 4.2, this content is represented as a structured tree of elements.
These elements represent children and contain attributes and text that give them def-
inition. Each child of the tree can be accessed through the HTML DOM. This gives you
the ability to add, edit, or remove content as needed. 
 In 1998, the World Wide Web Consortium (W3C) published the first version of the
HTML DOM specification. Since then, this specification has been implemented, at
least in some form, by every web browser. Over time, developers of some web browsers
have decided to augment the original specification to provide additional functionality,
causing a number of inconsistencies that can make it difficult to deliver platform-neu-
tral content.
 To ensure that Silverlight could deliver platform-neutral content, the browsers sup-
ported by Silverlight had to be identified. Each of these browsers uses one of the Sil-
verlight-supported DOM variants. These DOM variants and their descriptions are
shown in table 4.1.
Most web browsers implement one of the DOM variants supported by Silverlight. To
interact with the browser’s DOM for the hosting page, you use the System.Windows
.Browser namespace.
 The System.Windows.Browser namespace exposes a number of classes that encap-
sulate the features of the HTML DOM. The entry point into this DOM is accessible
through the HtmlPageclass. This static class gives you the ability to work with a web
page, including modifying on-page elements and displaying alerts. 
4.2
Working with the web page from managed code
The Document property of the HtmlPage object is an HtmlDocument object represent-
ing the current page. This is similar to the DOM approach in script, which also
exposes a Document property for the same purposes. In Silverlight, this property
enables you to navigate the contents of a web page, work with individual element
properties and styles, and retrieve information from the query string.
Table 4.1
The DOM variants officially supported by Silverlight
Specification
Browser(s)
Description
DHTML Object Model
Internet Explorer
The DHTML Object Model gives developers programmatic 
access to the individual elements within a web property.
Gecko DOM
Firefox
Mozilla
Netscape
Safari
Chrome
The Gecko DOM approach parses and renders HTML con-
tent and utilizes the HTML DOM.

76
CHAPTER 4
Working with HTML and browsers
4.2.1
Navigating web page contents
The HtmlDocument gives you two entry points into the currently loaded document,
both shown in table 4.2.
These properties are geared toward navigating an HtmlDocument using a top-down
approach. For situations where you need to dive into the middle of the action and
find a nested element, you have two other options, shown in table 4.3.
Table 4.3 introduces the GetElementById and GetElementsByTagName methods. Note
that these method names match their HTML DOM equivalents often used from script,
so you have a familiar approach for retrieving elements from managed code:
HtmlDocument document = HtmlPage.Document;
HtmlElement element = document.GetElementById("myDiv");
This example shows how to access an HTML element, in this case myDiv, via managed
code. Note that the myDiv element is simply an HTML DIV element within the HTML
page hosting the Silverlight plug-in. The example also introduces the important
HtmlElement class, a strongly typed wrapper for any element in the HTML DOM. This
wrapper exposes properties, listed next, that enable you to interact with an HTML ele-
ment from managed code.
Table 4.2
The two entry points into the HtmlDocument 
Property
Description
DocumentElement
This property represents the root element of the HTML DOM. It always repre-
sents the HTML element of a web page.
Body
This property gives you immediate access to the contents of the BODY element 
of a web page.
Table 4.3
The navigation methods of an HtmlDocument 
Method
Description
GetElementById
This method enables you to find any element within an HtmlDocument
by referencing its unique identifier. If the element is found, an object-
oriented version of the element, known as an HtmlElement, is 
returned. If the element isn’t found, null will be returned.
GetElementsByTagName
This method finds all the elements with a specified tag name. The results 
are returned as a collection of browser elements.
Table 4.4
The navigation properties of an HtmlElement 
Property
Description
Children
A collection of items hosted by the current HtmlElement. 
CssClass
The name of the CSS (CSS) class in use by the HtmlElement.

77
Working with the web page from managed code
Table 4.4 shows the properties that define an HtmlElement. The Parent and Children
properties give you the ability to navigate a web page starting from a specific element,
moving either up or down the tree, respectively. Each element will have a specific
HTML tag associated with it, which can be viewed through the TagName property. If
this tag is an input tag, you can give it the focus by calling a method that’s appropri-
ately named Focus(). Beyond the Focus method and the properties listed in table 4.4,
each HTML element may contain additional element-specific properties. 
4.2.2
Working with element properties
Each element in the HTML DOM exposes a number of descriptive properties. Some
are shared with all other elements in the HTML DOM (such as TagName); some are
only relevant to some HTML elements—for example, the value property of an HTML
input tag. Because this property is only relevant to one kind of element, you may be
wondering how HtmlElement works in these situations.
HtmlElement exposes two utility methods designed to interact with the properties
of an HTML element. The first method, GetProperty, retrieves the value assigned to a
property accessed by name. The other method, SetProperty, can be used to assign a
value to a property, again using its name. These general methods give you the flexibil-
ity to work with any kind of HtmlElement:
HtmlDocument document = HtmlPage.Document;
HtmlElement myTextField = document.GetElementById("myTextField");
int value = Convert.ToInt32(myTextField.GetProperty("value"));    
value = value + 1;
myTextField.SetProperty("value", Convert.ToString(value)); 
This code demonstrates how the GetProperty and SetProperty methods can be used.
Note that this sample retrieves the value associated with the value attribute of an
HTML Input field. This value is incremented by 1 and assigned back to the field. The
GetProperty method takes a string that represents the name of the property value to
retrieve. This value is then returned as a string. In a similar fashion, the SetProperty
method takes a string that represents the value to set to a property. This property is
identified by the first parameter in the SetProperty method. From this, you can see
that it’s easy to work with property values programmatically. Thankfully, it’s just as easy
to work with an element’s CSS information.
Id
The unique identifier of the HtmlElement.
Parent
The HtmlElement that hosts the calling item; if the calling item is the 
DocumentElement, this value will be null.
TagName
The name of the tag used by the HtmlElement.
Table 4.4
The navigation properties of an HtmlElement  (continued)
Property
Description

78
CHAPTER 4
Working with HTML and browsers
4.2.3
Handling CSS information
Elements within the HTML DOM are designed to separate content from presentation.
When using inline styles for elements, the presentation information is stored in style
attributes, adhering to the CSS specifications, that describe how the element should
be shown. You can access and modify this style information from Silverlight, using
code similar to the following:
HtmlDocument document = HtmlPage.Document;  
HtmlElement myDiv = document.GetElementById("myDiv"); 
myDiv.SetStyleAttribute("backgroundColor", "gray");  
The first step in accessing a style attribute from managed code is to retrieve the
HtmlElement whose style needs to be used. Then, the style can be set using the
SetStyleAttribute method. Alternatively, you can retrieve the current style of an
HtmlElement by using the GetStyleAttribute method. Both require you to reference
a style using the scripting naming approach.
 The scripting naming approach is used to interact with styles from JavaScript and
from Silverlight. This approach uses camel case for style names, slightly different than
the CSS approach, which uses dashes to separate words. This means that the CSS name
for the backgroundColor property used in the previous example is background-color.
If you’re an experienced web developer, you’ve probably run into this discrepancy
before. If you try to reference a style using the CSS naming, an exception won’t be
thrown but the style value also won’t be set or retrieved. Either way, it’s nice to know
there are ways to get and set style attributes.
 In addition to the page elements and styles you can access via the HTML DOM,
Silverlight provides a mechanism to work with the page URL and its query string.
4.2.4
Accessing the query string
One common approach for managing state and passing parameters in a web applica-
tion is to use the query string. Within URL-length limitations, you can pass a small
amount of data on the query string using key-value pairs. In addition, the query string
contains parameter information that modifies what the page shows or represents.
Because it’s part of the URL, you can provide the URL as a link elsewhere on the web,
sharing the parameter information with others. For example, pretend you want to
send a friend the search results for a query on Silverlight; you could email your friend
the following web address:
http://www.bing.com/search?q=silverlight
This web address enables your friend to see the search results you’re referring to. This
is more convenient than telling someone to go to a search engine, enter “Silverlight”
into the search box, and wait for the results. This simpler approach is made possible
through the values that are stored after the ? (question mark)—values that represent
the QueryString of the Uri for an HtmlDocument.

79
Working with the hosting browser window
The QueryString is readable through a collection of key-value pairs. This collection is
part of a larger entity known as the DocumentUri. The DocumentUri represents the
Uri of the current page, allowing you to always gain your current bearings within an
application. 
 Figure 4.3 shows the breakdown of a web address. The QueryString starts after the
question mark in a web address. In addition, each key-value pair is separated by an &
(ampersand). The QueryString in figure 4.3 has two key-value pairs, which could be
read using this code:
HtmlWindow window = HtmlPage.Window;
HtmlDocument document = HtmlPage.Document;     
foreach (string key in document.QueryString.Keys)
{
  window.Alert("Key: " + key + "; Value: " + document.QueryString[key]);
}
Note that you can’t set the key-value pairs of this collection from code. Instead, if you
need to set the QueryString values, you’ll have to use the navigation techniques
shown in section 4.3.2. Doing so will reset the values associated with the QueryString,
as well as the contents of the page. Once the contents of the page are loaded, you can
use the HtmlDocument to navigate the page. 
4.3
Working with the hosting browser window
The hosting browser window is represented as an HtmlWindow object. This object can’t
be instantiated from code, but you can get the current instance of the hosting
browser’s HtmlWindow through the HtmlPage class’s Window property. This can be
accomplished by using the following code:
HtmlWindow window = HtmlPage.Window;
Once you have a handle to it, you can use the HtmlWindow to display alerts and
prompts to a user. Alternatively, you can use this object to navigate the browser to a
different location using the Navigate method.
4.3.1
Prompting the user
The HtmlWindow class enables you to deliver HTML prompts to your users to quickly
show or collect information. It’s important to note that these prompts aren’t Silver-
light items. Instead, these prompts are constructed entirely by the user’s browser
window, so you have a limited ability to customize how they’re displayed. The three
Figure 4.3
The elements of a web 
address showing the relationship of the 
QueryString to the DocumentUri

80
CHAPTER 4
Working with HTML and browsers
modal dialog prompt options available through the HtmlWindow class are listed in
table 4.5.
These prompt options duplicate the prompt choices available through the HTML DOM
Window object. This is especially useful for important alerts, as shown in this code:
HtmlWindow window = HtmlPage.Window;
window.Alert("Your CPU is about to melt!");
Note how easy it is to deliver an HTML prompt to a user. It’s also important to note
that these prompts prevent the execution of succeeding code until the user responds
to the prompt—they’re blocking operations. Either way, you can use this approach to
use the other prompt types shown in table 4.5.
 Silverlight 3 introduced another easy way to alert the user. The MessageBox.Show
method encapsulates the HtmlWindow.Alert functionality to provide a more discover-
able way to display alerts. More importantly, the MessageBox.Show method also works
for out-of-browser applications where there’s no valid HtmlPage and has no depen-
dence on the underlying JavaScript capabilities.
 The early versions of Silverlight contained only the HTML prompts shown so far.
But most .NET Windows developers are used to MessageBox.Show and will find it just
as intuitive in Silverlight:
MessageBox.Show("Welcome!");
The Show method also takes additional parameters to allow you to set the window cap-
tion and display either the OK button or both the OK and the Cancel buttons:
MessageBox.Show("Format your C drive?",
                "Windows Caption", 
                MessageBoxButton.OKCancel);
Just as in the case with Alert and the other methods, this is a blocking operation and
will suspend your application until the user closes the window. This version will also
work in out-of-browser applications.
Table 4.5
The prompt options available through the HtmlWindow class 
Method
Description
Alert (…)
This method shows a single message in an HTML alert window.
Confirm (…)
This method prompts the user to agree or disagree with a statement or question. 
The prompt displays two buttons: OK and Cancel. The text of these buttons can’t 
be customized. If the user clicks OK, this method returns true; if the user clicks 
Cancel, it returns false.
Prompt (…)
This method creates a dialog window that displays a single message. In addition, 
this dialog displays a single text box that the user can enter information into. If the 
user clicks the OK button in this dialog window, the value of that text box is 
returned as a string. Otherwise, if a user clicks Cancel or exits the window, 
null is returned.

81
Working with the hosting browser window
 The MessageBox class and the HtmlWindow methods make it easy to display confir-
mation messages to the user via the browser. Luckily, it’s just as easy to perform naviga-
tion tasks through the browser window.
4.3.2
Navigating the browser window
Navigation is an important part of any web application. There may be times when you
want to redirect a user to another web page or perhaps you want to launch another
browser window and load a web page into it. Either way, the HtmlWindow class provides
two methods, shown in table 4.6, that you can use to get the job done.
It’s important to recognize that these navigation methods can have undesired effects
on your Silverlight application. For instance, if you redirect the hosting browser win-
dow away from the hosting web page, your Silverlight application will be unloaded.
You should strongly consider loading a different web page into a new browser window,
as shown here:
Uri uri = new Uri("http://10rem.net");  
HtmlWindow window = HtmlPage.Window;
window.Navigate(uri, "_blank");   
One of the key items to notice from this code is that you must always use a Uri for a
web address. In addition, you can still use a target with an address, just like in HTML,
making it easy to fully control the experience. 
 In addition to the properties of the windows or elements in the DOM, you may
want to obtain information about the browser itself.
4.3.3
Discovering the browser properties
The static BrowserInformation property exposes detailed information about the
hosting browser, when present. This information is stored within a System.Windows.
Browser.BrowserInformation object that corresponds nicely to the Navigator object
available within the HTML DOM. Table 4.7 shows the properties exposed by the
BrowserInformation object and the equivalent Navigator property.
Table 4.6
The navigation options available through the HtmlWindow class
Method
Description
Navigate(…)
This method will redirect the browser window to the provided URI. 
This URI can be loaded in an optional target window. The specifica-
tions of this target window can be set via an optional third parame-
ter. The name and specification of the target window parameters 
match those used by the HTML DOM window.open function.
NavigateToBookmark(…)
This method is used to navigate to a location within the current 
HTML page.

82
CHAPTER 4
Working with HTML and browsers
Based on these options, you can see that you have access to a lot of information. This
information can be useful for creating a statistical analysis of your application’s users,
or to verify browser capabilities before doing any DOM manipulation. With the
BrowserInformation class, you can easily code against these inconsistencies. To do
so, you must first get to the BrowserInformation by using code similar to this:
BrowserInformation browserInfo = HtmlPage.BrowserInformation;
HtmlWindow window = HtmlPage.Window;
window.Alert(browserInfo.Name);
The BrowserInformation class provides a way to learn about the user’s browser win-
dow, which is represented by the HtmlWindow class. With this class, you can navigate to
locations within a web page or on the internet. In addition, you can reach out to users
and communicate with them through HTML prompts, if needed. These prompts are
something you’re probably familiar with if you’ve developed web applications using
JavaScript. If you’ve used JavaScript in the past, you’ll probably be excited to know
that there are also ways to bridge the scripting world with the managed code world.
4.4
Bridging the scripting and managed code worlds
Silverlight allows you to create a bridge between the scripting and managed code
worlds to let you leverage each platform for the area in which it excels. For example,
you can use Silverlight purely for its rich and powerful .NET features; Silverlight can
provide value even if you don’t need a rich vivid UI. You may also want to integrate
JavaScript libraries and functionality—for example, automating Silverlight functions
from jQuery. To take advantage of these features, you need to learn to call managed
code from JavaScript and use JavaScript from managed code.
4.4.1
Calling managed code from JavaScript
Calling managed code from JavaScript is a fairly simple process—it consists of three
basic steps intended to expose managed code elements to the scripting world. Once
these tasks have been performed, you’re free to reference the managed elements
Table 4.7
Descriptions of the BrowserInformation properties and their corresponding
Navigator properties
BrowserInformation
Navigator
Description
BrowserVersion
appVersion
The platform and version associated with the browser
CookiesEnabled
cookieEnabled
Specifies whether cookies are enabled within the browser
Name
appName
The name of the browser
Platform
Platform
The operating system
UserAgent
userAgent
The value of the user-agent header that will be sent from 
the browser to a server

83
Bridging the scripting and managed code worlds
from JavaScript. To demonstrate this, let’s pretend you want to use a method from
managed code to call a web service.
 The first step in calling managed code from JavaScript involves using the
ScriptableType attribute. This attribute, which is part of the System.Windows
.Browser namespace, makes a class accessible to the JavaScript world. This attribute
doesn’t expose any special properties, so you can apply it to any class using the follow-
ing approach:
[ScriptableType]
public partial class MainPage : UserControl
This C# code shows how to make a type accessible to JavaScript by exposing the
default Silverlight page to JavaScript. In reality, you can make any class accessible to
the scripting world and will typically create a dedicated class or classes just for that
interface. Once a class has been marked as a ScriptableType, all public properties,
methods, and events are available to JavaScript. Alternatively, you can decide to only
expose select member items. Fortunately, this is also an easy process.
 The second step is to expose the member properties and methods. To expose
member items, you use a similar but different attribute—ScriptableMember. The
ScriptableMember attribute may be applied to the events, methods, and properties
that can be used with script. You add the attribute as shown in this C# code:
[ScriptableMember]
public void ExecuteWebService()
{
  // Make a call to a web service
}
This attribute gives you the ability to set a scripting alias if you so desire, which you can
accomplish by setting the string-typed ScriptAlias property. This may be useful if
you want to prevent naming conflicts within script. Everything you’ve seen up to this
point is basic, but we haven’t created the bridge to JavaScript yet.
 Finally, to create the bridge to the scripting world, you must register an instance of
the class to be exposed by using the statically visible RegisterScriptableObject
method. This method, which belongs to the HtmlPage class, empowers you to give a
class instance an alias. This alias can then be used from script. You can accomplish this
by using the RegisterScriptableObject method shown in the following C# code:
public MainPage()
{
  InitializeComponent();
  HtmlPage.RegisterScriptableObject("bridge", this);
}
This method accepts an instance of a class described as being a ScriptableType. The
object is registered with the scripting engine by passing it as the second parameter to
the RegisterScriptableObject method, which then uses the first parameter to
create an alias for the class instance. This alias is appended to the content property of
the hosting Silverlight plug-in.

84
CHAPTER 4
Working with HTML and browsers
 The Silverlight plug-in exposes a subobject called content, which exposes the con-
tent of a Silverlight plug-in; this is the scripting version of the Content property of the
SilverlightHost class previously discussed. You can access your scriptable object by
first retrieving the plug-in instance and then referencing the ScriptableMember you
want, as demonstrated in listing 4.1.
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" 
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" >
<head>
  <title>Silverlight Project Test Page </title>
  <script type="text/javascript" src="Silverlight.js"></script>
  <script type="text/javascript">
    function buttonClick()
    {
      var plugin = document.getElementById("mySilverlightControl");
      plugin.content.bridge.ExecuteWebService();  
    }
  </script>
</head>
<body style="height:100%;">
  <div id="mySilverlightHost" style="height:100%;">
    <script type="text/javascript">
      var host = document.getElementById("mySilverlightHost");
      Silverlight.createObjectEx({                                        
        source: "ClientBin/MySilverlightApp.xap",                         
        parentElement: host,      
        id: "mySilverlightControl",                                       
        properties: {          
          height: "100%",                         
          width: "100%",                               
          version: "2.0"
        },
        events: { }  
      });    
    </script>
  </div>
  <input type="button" onclick="buttonClick();"
    value="Execute Web Service" />
</body>
</html>
This listing demonstrates how a scriptable object can be accessed from a plug-in
instance. This plug-in gives you the ability to use managed code from JavaScript. You’ll
find this ability valuable in situations where you don’t need the rich visual features of
Silverlight. For instance, you may decide to create something known as a headless Silver-
light application.
 A headless Silverlight application is one that doesn’t have a UI. Instead, it uses
objects registered as ScriptableType elements as the brains for a traditional web page.
This approach allows you to write nonvisual components using the .NET Framework
Listing 4.1
Referencing a managed item from script on the HTML page
Scriptable object
and method

85
Bridging the scripting and managed code worlds
and integrate existing code libraries. This type of application is valuable because you
can use it to perform tasks that the browser’s JavaScript engine can’t do, or can’t do
quickly or well. For instance, you may choose to use a headless Silverlight application to
make cross-domain requests or listen to a socket (both items discussed in chapter 23)
or to provide HTML5 polyfill features in non-HTML5 browsers. Regardless, you may still
need to rely on the features of a preexisting JavaScript library. For these situations, you
can use Silverlight to call JavaScript from managed code. 
4.4.2
Using JavaScript from managed code
Silverlight gives you the flexibility to call JavaScript from managed code and, in turn,
the ability to call any method on an HTML or JavaScript object. This can be useful if
you’re integrating Silverlight with a preexisting web application.
 Let’s say that the HTML application has basic reporting features. Silverlight has
really good printing capabilities (see chapter 31), but that won’t integrate any HTML
content in its output. But the Window object in the HTML DOM also exposes a print
method that will handle the HTML content and the visible Silverlight content. You can
use Silverlight’s ability to call a function on a JavaScript object to deliver this function-
ality. To accomplish this, you use a method called Invoke. This method can be used to
execute a JavaScript function from managed code, as demonstrated in the following
C# code:
HtmlWindow window = HtmlPage.Window;
window.Invoke("print", new object[]{});
This code can be used to print the current web page, including your Silverlight appli-
cation. The Invoke method can be applied to any HtmlDocument, HtmlElement, or
HtmlWindow object. The first parameter of this method represents the name of the
function to be invoked. The second parameter represents the arguments that will be
passed to this function when it’s called. As you can see, this parameter is an array of
objects, so you have the flexibility to pass anything you need to a JavaScript function.
 Silverlight gives you the ability to execute JavaScript code from managed code. In
addition, you can go the other way and call managed code from JavaScript. These two
features show how you can use Silverlight to bridge the scripting and managed code
worlds. You need to use this approach if you want to communicate between two differ-
ent types of plug-ins, such as Flash and Silverlight, or between technologies such as
Ajax and Silverlight.
 Silverlight gives you the ability to bridge scripting and managed code running
inside the browser. In addition, you can use Silverlight to learn about the user’s
browser window. What’s perhaps even more interesting, you can use managed code to
interact with the HTML DOM. All this is made possible by the rich HTML DOM API
that’s an integral part of Silverlight.
 So far, I’ve been discussing Silverlight sitting on a web page. What about instances
where you need HTML content to be displayed inside your application? Happily, Sil-
verlight supports that as well.

86
CHAPTER 4
Working with HTML and browsers
4.5
Hosting HTML in Silverlight
Silverlight 4 added the ability to host arbitrary HTML content on the Silverlight plug-
in surface. Silverlight 5 enhanced this to support hosting in in-browser applications.
This feature was initially added primarily to support advertising scenarios such as
Flash and animated GIF banner ads, but it has grown to be used to display anything
the web browser can display, including instances of other Silverlight applications.
NOTE
Internally, this feature was implemented by hosting an instance of the
system browser within Silverlight. On the Mac, this is the WebKit-based Safari;
on Windows, it’s Internet Explorer. This is an OS setting independent from
what browser you set as the default to open web content. Because you’ve now
brought back the variability in rendering that’s inherent across the spectrum
of web browsers, I recommend you use this feature sparingly.
HTML hosting in Silverlight initially worked only in out-of-browser applications (cov-
ered in chapter 5). With Silverlight 5, this has been expanded to support in-browser
trusted applications as well. (Trust and security are covered in chapter 6.) When in-
browser hosting is not enabled, you’ll simply get a gray or otherwise boring-looking
rectangle on the screen, as seen in figure 4.4. If your application supports situations
where the embedded browser isn’t supported, you’ll want to dynamically add or
enable the control based on a runtime check to see which mode you’re running in.
 There are two ways to host HTML content in your Silverlight application: you can
host the WebBrowser control or you can use the WebBrowserBrush to paint HTML over
other elements.
Figure 4.4
When running in the browser, HTML hosting features are disabled. This example shows 
the WebBrowser control.

87
Hosting HTML in Silverlight
4.5.1
Hosting the WebBrowser control
The WebBrowser control allows you to display a rectangular region on the screen con-
taining a functional and interactive web browser. There are three ways you can load
content into the control: the Source property and the Navigate and Navigate-
ToString methods.
SOURCE PROPERTY
The Source property is the XAML-friendly way to host content for the control. Simply
set the Source to a valid URI on the same domain that originally served the Silverlight
application:
<Grid x:Name="LayoutRoot" Background="White">
  <WebBrowser Source="http://www.mydomain.com" Margin="15" />
</Grid>
In the case of a cross-domain error, you’ll get a blank control for the display and a
XamlParseException (attribute out of range), which may be trapped in the applica-
tion-level exception handler. If you want to host cross-domain content, you’ll need to
use the NavigateToString method and host an iframe.
 Because Source isn’t a dependency property and therefore doesn’t support bind-
ing, its utility in real-world applications is pretty low. Instead, you’ll want to use the
Navigate method.
NAVIGATE METHOD
The Navigate method is the counterpart to the Source property. Though it doesn’t
support binding like the Source property, you have more control over exception han-
dling when the page is cross-domain. Listing 4.2 shows how to load a local page using
the Navigate method.
HTML (example-page.aspx):
<html xmlns="http://www.w3.org/1999/xhtml">
<head runat="server">
  <title>Demo Page</title>
</head>
<body>
  <div style="margin:20px;font-family:Arial;font-size:20pt">
  This is HTML from the same domain as this out-of-browser 
  application. If this were a cross-domain page, you 
  wouldn't be able to see it here.
  </div>
  <div style="margin:20px">
    <img src="pete_headshot.jpg" />
  </div>
</body>
</html>
XAML:
<Grid x:Name="LayoutRoot">
  <Grid.Background>
Listing 4.2
Loading a page using the Navigate method

88
CHAPTER 4
Working with HTML and browsers
    <LinearGradientBrush StartPoint="0,0"
                         EndPoint="0,1">
      <GradientStop Color="#FF0055DD"
                    Offset="0" />
      <GradientStop Color="#FF00DDFF"
                    Offset="1" />
    </LinearGradientBrush>
  </Grid.Background>
  <WebBrowser x:Name="b"         
              Margin="15" />
</Grid>
C#:
public partial class MainPage : UserControl
{
  public MainPage()
  {
    InitializeComponent();
    Loaded += new RoutedEventHandler(MainPage_Loaded);
  }
  void MainPage_Loaded(object sender, RoutedEventArgs e)
  {
    b.Navigate(new Uri("/example-page.aspx",     
                        UriKind.Relative));
  }
}
Note that the URI is relative to the position of the XAP so, in this case, example-
page.aspx is sitting in the ClientBin folder on the project. When you run this app, you
get the result shown in figure 4.5, assuming you happen to have a gigantic photo of
me hanging around for just such the occasion.
WebBrowserControl
Navigate method
Figure 4.5
The WebBrowser
control with a page loaded via 
the Navigate method

89
Hosting HTML in Silverlight
As with the Source property, you still have the cross-domain restrictions that make this
method less than useful for the majority of circumstances. The most flexible approach
for loading content into the WebBrowser control is to use the NavigateToString
method.
NAVIGATETOSTRING METHOD
NavigateToString allows you to build and display arbitrary HTML in the control. This
can be useful if, say, you’re building an RSS reader or similar application where the
source isn’t exactly an HTML page but has HTML content you want to display. To use
this method, provide a string containing the HTML source, as shown in listing 4.3.
(Use the same XAML as in listing 4.2.)
void MainPage_Loaded(object sender, RoutedEventArgs e)
{
  StringBuilder html = new StringBuilder();  
  html.Append("<html><head></head>");
  html.Append("<html><head></head>");
  html.Append("<body style='font-family:Arial;font-size:20pt'>");
  html.Append("<div style='color:blue'>");
  html.Append("This is the first div");
  html.Append("</div>");
  html.Append("<div style='color:orange'>");
  html.Append("This is the second div");
  html.Append("</div>");
  html.Append("<html><head></head><body>");
  html.Append("</body></html>");
  b.NavigateToString(html.ToString());   
}
When run, the resulting application looks
like figure 4.6. Note that the styles all came
through just as you’d expect it from any
other browser page.
NavigateToString will allow you to host
an iframe to enable loading content from
another web domain. In this way, you can
get around the same-domain limitations
imposed by the Navigate method and
Source properties. Simply change the
HTML-generating code in listing 4.3 to this:
html.Append("<html><head></head><body>");
html.Append("<iframe width='100%' height='100%'");
html.Append("src='http://windowsclient.net/learn/video.aspx?v=289850'/>");
html.Append("<html><head></head><body>");
html.Append("</body></html>");
The resulting page will look like figure 4.7. On this page, we have a Silverlight media
player with a loaded video and several animated GIF ads. This provides all the
Listing 4.3
Loading an HTML string via NavigateToString
NavigateToString 
method
Figure 4.6
Runtime-generated HTML loaded 
into the Silverlight Web-Browser control via 
the NavigateToString method

90
CHAPTER 4
Working with HTML and browsers
flexibility you’d need to be able to create your own Silverlight web browser or to incor-
porate browsing capabilities into your own application.
 You can use normal HTML attributes and techniques to avoid the scrollbars and
deal with overflow content just as you would on any other web page. Remember,
though, the more HTML you put in your string, the more you’ll have to test across the
browsers. One of the biggest benefits of Silverlight is that it looks and behaves the
same across different browsers. Relying too much on HTML content largely negates
this benefit.
 Though having an interactive web browser control may be enough for most cases,
sometimes you may want to run scripts on the page or save the content off to a file. 
INVOKING SCRIPT
Up until now, the web page loaded in the WebBrowser control has been a black box.
The user can type into it, but the application can’t do anything other than load the
content and let it fly. Sometimes you need to invoke behavior on the web page. The
WebBrowser control includes two overloads of the InvokeScript method just for that.
Figure 4.7
We’re loading http://windowsclient.net in an iframe using the 
NavigateToString method. Note the embedded Silverlight player and animated 
GIF ads, all hosted in the control inside our Silverlight out-of-browser application.

91
Hosting HTML in Silverlight
 Listing 4.4 shows how to invoke a script both with and without a parameter.
HTML:
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title></title>
  <script language="JavaScript">
    function GreetMe(name) {                      
      div1.innerHTML += "<p>Hello " + name + "</p>";
    }
    function SayHello() {                        
      div1.innerHTML += "<p>Hello</p>";
    }            
  </script>
</head>
<body>
  Hello world!<br />
  <div id="div1">
  </div>
</body>
</html>
XAML:
...
<WebBrowser x:Name="b"
            Source="/script-page.htm" />
C#:
public MainPage()
{
  InitializeComponent();
  b.LoadCompleted += 
    new LoadCompletedEventHandler(b_LoadCompleted);          
}
void b_LoadCompleted(object sender, NavigationEventArgs e)
{
  b.InvokeScript("SayHello");                  
  b.InvokeScript("GreetMe","'Pete'");      
}
You must ensure you wait for the Load-
Completed event before you attempt to
call any scripts. Otherwise, there’s no
guarantee that the script functions are
available. The resulting application
looks like figure 4.8.
Figure 4.8
InvokeScript used to
manipulate the contents of the web
page in the WebBrowser control
Listing 4.4
Invoking scripts on a loaded web page
JavaScript function 
expecting parameters
Basic JavaScript 
function
Invoking script

92
CHAPTER 4
Working with HTML and browsers
Another task you may want to perform with the web page is to render its content to a
string for use elsewhere in the application. Though this could be done via a separate
WebRequest, the information is already here and there’s a handy function to expose
the content to your application code.
SAVING THE CONTENT
The WebBrowser control includes the SaveToString method, which takes the currently
loaded HTML and, well, saves it to a string. From there you can upload it to a service,
save it locally, display it to the user, or do pretty much anything else you’d like with it:
string html = BrowserControlInstance.SaveToString();
But if the content is from a cross-domain location, you’ll receive a SecurityException.
This restricts the use of the control to saving the HTML generated by your local server.
 The WebBrowser control forms the core of the embedded HTML in Silverlight
applications. Building on that and providing flexibility that’s both useful and fun is
the WebBrowserBrush. 
4.5.2
Using the WebBrowserBrush
If you play with the WebBrowser control, you’ll eventually notice that you can’t overlay
other Silverlight content on top of it. On Windows, the WebBrowser control has a sep-
arate hWnd or handle to a window in Windows (the equivalent thing happens on the
Mac) and, therefore, has what is known as airspace issues, in that it’ll be on top of any-
thing else you draw. If you want to have the content behave like normal Silverlight
content, allowing transforms and otherwise respecting z-order, you’ll need to use the
WebBrowserBrush but at the cost of interactivity.
 The WebBrowserBrush takes a WebBrowser control as its source and is then used to
paint on any arbitrary path or shape. It doesn’t allow the user to interact with the web
page. During PDC09, Scott Guthrie demonstrated an application that puzzlefied a You-
Tube page with a Rick Astley video playing in a Flash player. This was accomplished
using the WebBrowserBrush on the individual puzzle shapes.
 Listing 4.5 shows how to use the WebBrowserBrush to show the contents of a web
page within an ellipse. The HTML used is the same as that from listing 4.2.
XAML:
<Grid x:Name="LayoutRoot">
  <Grid.Background>
    <LinearGradientBrush StartPoint="0,0"
                         EndPoint="0,1">
      <GradientStop Color="#FF0055DD"
                    Offset="0" />
      <GradientStop Color="#FF00DDFF"
                    Offset="1" />
    </LinearGradientBrush>
  </Grid.Background>
Listing 4.5
Using the WebBrowserBrush to paint an ellipse with a web page

93
Hosting HTML in Silverlight
  <WebBrowser x:Name="b"
              Height="1000"   
              Width="1000"  
              Visibility="Collapsed"
                Source="/example-page.aspx" />
  <Ellipse Margin="25"
           Stroke="Black"
           StrokeThickness="2">
    <Ellipse.Fill>
      <WebBrowserBrush SourceName="b"   
                       x:Name="EllipseBrush" />
    </Ellipse.Fill>
  </Ellipse>
</Grid>
C#:
void MainPage_Loaded(object sender, RoutedEventArgs e)
{
  CompositionTarget.Rendering += (s, ev) =>          
    {                                              
      EllipseBrush.Redraw();                    
    };                                 
}
The resulting application looks like figure 4.9.
 In listing 4.5, the code is redrawing the control during the Composition-
Target.Rendering event. That event typically fires once for every frame being drawn.
For a static web page, this is overkill, and you can simply use the LoadCompleted event
Ensure that 
browser has size
WebBrowserBrush
Redraw on 
every frame
Figure 4.9
WebBrowserBrush used to 
paint web content onto an 
Ellipse element. Note the 
aspect ratio isn’t quite 
correct due to enabling 
stretching of content

94
CHAPTER 4
Working with HTML and browsers
of the WebBrowser control. But if you have video content or a web page that otherwise
constantly changes its appearance, you’ll need to wire up to this event or to a timer to
update the display.
 Another point to note is that the WebBrowser control must have a size. What’s ren-
dered by the WebBrowserBrush is the same as what would be rendered by the
WebBrowser if it were visible. If the WebBrowser were sized to 10 × 10, the
WebBrowserBrush would show that 10 × 10 content, scaled up to the size specified by
the brush’s stretch setting.
 That’s everything you need to be able to paint HTML all over your out-of-browser
application whether running in a window or full screen. 
4.6
Summary
Despite the expanding presence on the desktop, Silverlight’s roots are in the web. As a
web technology, it has excellent integration with the hosting browser. Anything you
can do from JavaScript can be done from within Silverlight.
 When running in the browser, Silverlight provides you with enough control that
you could automate the entire page without any JavaScript, if you desired, while bene-
fitting from the capabilities and development model offered by managed code lan-
guages. The other end of the spectrum is a full-page Silverlight application hosted in a
thin HTML shell. For many applications, a middle ground using the in-browser experi-
ence integrated with an existing web property or into a system such as SharePoint will
be the way to go.
 In the next chapter, I’ll show you how Silverlight reaches beyond the browser to inte-
grate more closely with the desktop in a model known as “out-of-browser applications.”

95
Out-of-browser applications
Out-of-browser (sometimes referred to as OOB) application support in Silverlight
enables you to create a class of applications that combine the best of Silverlight web
development with the great experience of a desktop application, all without install-
ing an additional application or plug-in. If you want to enable out-of-browser and
offline scenarios, need access to keys normally swallowed by the browser, or want
more screen real estate, you can take advantage of the new OOB features. Best of
all, the partial-trust, sandboxed, OOB applications are just as safe and secure as
their browser-hosted versions, and they’re easier to install than typical desktop
applications.
 Out-of-browser Silverlight applications aren’t hosted in a real browser instance—
at least not in the way you’d typically think of a browser—and therefore don’t have
access to the HTML DOM covered in the previous chapter. Instead, the applications
must be full-page, self-contained applications, without reliance on enclosing HTML,
JavaScript, or other in-page assets. Out-of-browser Silverlight applications have seen
This chapter covers
■
Running Silverlight applications out of the 
browser
■
Creating out-of-browser applications
■
Displaying notification toast
■
Controlling the out-of-browser window

96
CHAPTER 5
Out-of-browser applications
significant uptake within corporations, behind the firewall, due to their simple instal-
lation and update models and their presentation and data manipulation capabilities—
they’re a great compromise between the simple deployment model of a web application
and the power of a full-blown platform-specific desktop application.
 Silverlight OOB applications look just like their full-page in-browser equivalents
but without all the extra browser chrome. A sample OOB Silverlight application
appears in figure 5.1 and its in-browser version in figure 5.2.
Figure 5.1
My first out-of-browser Silverlight application—a Commodore 64 emulator 
using the updated MediaStreamSource API described in ebook appendix C.
Figure 5.2
The same Silverlight 
application running 
in the browser

97
Implementation specifics
Comparing the screenshots, you can see that the Silverlight portion of the experience
remains identical (with the exception of the frame rate display I’ve turned on when in
the browser). The code and the XAP file are the same. What changes is how much
chrome surrounds the application and how much real estate is made available to Sil-
verlight rather than to browser functionality.
 Silverlight provides APIs for identifying whether the application is running in or out
of the browser and whether any updates are available. These, combined with the already
rich set of capabilities offered by Silverlight, make for a compelling out-of-browser appli-
cation platform, suitable for creating client applications that fit a variety of scenarios.
 Now that you’ve seen what an out-of-browser application looks like, the next sec-
tion explores the implementation specifics, including the capabilities and restrictions
of these types of applications. You’ll then dive into the end-user installation experi-
ence, because it differs from traditional client applications. From there, you’ll create
your own out-of-browser application and enhance it with notification toast. Then,
because out-of-browser applications need not take on the native window chrome of
the host OS, you’ll learn how to create your own window borders and control buttons.
5.1
Implementation specifics
When developing and debugging out-of-browser applications, you must know how
Silverlight implements them under the covers, and what capabilities and restrictions
are associated with this application model. This understanding is especially important
when you’re developing a true cross-platform application and need to ensure consis-
tent behavior.
5.1.1
Process and hosting
On Windows, out-of-browser Silverlight applications run in a process named
sllauncher.exe. That process hosts the Internet Explorer (IE) rendering surface
mshtml.dll hosted in shdocvw. The rendering surface is where your Silverlight applica-
tion exists, visually. Similarly, on Apple OS X the process hosts the Safari/WebKit ren-
dering surface and related libraries. In both cases, Silverlight doesn’t rely on the
entire browser stack but instead on the core functionality required to host Silverlight
content inside the native OS window chrome.
 Though the Silverlight team has gone through great pains to ensure performance
is similar on all supported operating systems, understanding the limitations of Safari/
WebKit and Internet Explorer can help with diagnosing performance issues. For
example, current implementations of Safari use a plug-in compositing mode that’s
not as efficient as Internet Explorer. If your application has lots of animation and
internal compositing going on, it’s a good idea to test performance on OS X before
the release. In general, this limitation applies only to Safari on the Mac.
 As in the case with process-isolated tabs in the browser, each out-of-browser Silver-
light application will have its own process, app domain, and instance of the CoreCLR.
 Out-of-browser applications have unique capabilities and restrictions when com-
pared to their browser-hosted counterparts. 

98
CHAPTER 5
Out-of-browser applications
5.1.2
Capabilities and restrictions
Out-of-browser Silverlight applications work the same as in-browser Silverlight applica-
tions with some minor but notable differences:
■
Isolated storage quota for out-of-browser applications is 25 MB by default as
opposed to 1 MB for in-browser applications. In both cases, this can be
extended by prompting the user.
■
Out-of-browser applications provide access to keys that the browser normally
captures, such as function keys.
■
Out-of-browser applications can be pinned to the Start menu or taskbar on Win-
dows systems and display custom icons but otherwise can’t integrate with the
Windows 7 taskbar without using COM automation in the elevated trust mode.
■
Out-of-browser applications require an explicit check for a new version,
whereas in-browser versions automatically update in connected scenarios.
■
Out-of-browser applications can’t receive initialization parameters or take
advantage of any of the plug-in parameters while running out of the browser.
■
Out-of-browser applications can’t interact with the HTML DOM—there’s no
DOM to work with.
If you want those capabilities and can live with those restrictions, an out-of-browser
application may be for you. If you need more power and fewer restrictions, consider
creating a click-once WPF application.
 The end-user experience for installing Silverlight applications is slightly more com-
plex than hitting a web page and running Silverlight content but not nearly as
involved as a regular platform application (EXE) install.
5.2
The end-user experience
An end user visiting your site will see a typical Silverlight application. If the applica-
tion is out-of-browser enabled, he or she will be able to right-click on the surface to
install it locally, assuming you’ve left that capability intact. In addition, you may pro-
vide an onscreen button to perform the installation without requiring the right-click.
The default experience is shown in figure 5.3.
Figure 5.3
The install menu for an 
out-of-browser-enabled application is 
accessed by right-clicking on the 
Silverlight surface.

99
The end-user experience
The installation process is painless; it’s simply copying files to an obfuscated location on
the local machine. No registry entries, no additional platform DLLs, and no admin
rights are required—nothing extra. As seen in figure 5.4, there’s only a choice of where
to put shortcuts (Start menu and/or desktop) and whether to approve or cancel the
install—a low-friction experience compared to a typical platform application install.
 Once the user takes the applica-
tion out of the browser, the XAP will
be re-requested from the server and
stored in a low-trust location on the
local machine along with the infor-
mation about the original URI of the
XAP and the download timestamp.
It’ll then appear in the places the
user selected (Start menu and/or
desktop) via the dialog shown in fig-
ure 5.4 and also on the taskbar. The
user may, as with any other applica-
tion, pin the shortcut to the Start
menu or (in Windows 7) to the task-
bar for convenience. 
    The application will also immediately
launch in the out-of-browser mode, as
seen in figure 5.5. At this point, the user
may close the browser window if she
wishes to do so.
    Figures 5.6 and 5.7 show a Silverlight
application (the Commodore 64 emula-
tor) pinned to the Start menu and the
taskbar on a Windows 7 machine. Note
the use of custom icons and information
about the name of the application.
Figure 5.4
The install dialog gives the 
user the option to place shortcuts on the 
Start menu and on the desktop. The install 
icon on the left is customizable, as is the 
application name.
Figure 5.5
The application is running in the out-of-
browser mode. Note that both the application 
window title and source domain (localhost in this 
case) are displayed in the title bar.
Figure 5.6
An out-of-browser Silverlight 
application with custom icons pinned to the Start 
menu in Windows 7. The application below it, 
TweetDeck, is an Adobe AIR application, another 
competing out-of-browser RIA technology.
Figure 5.7
The same Silverlight out-of-browser 
application pinned to the taskbar in Windows 7

100
CHAPTER 5
Out-of-browser applications
To uninstall the application, the user can either right-click the Silverlight application
and select the menu option Remove This Application or use the control panel’s Add/
Remove Programs applet. Again, no special rights are required and the process is
painless.
 As you can see, out-of-browser Silverlight applications look and act much like any
other desktop application while providing a simple installation experience for the end
user. You get the local experience of a desktop application with the ease of deploy-
ment of a web application. Next, I’ll show you how to configure and code your appli-
cations for out-of-browser support. 
5.3
Creating out-of-browser applications
An out-of-browser application may be as simple as an existing Silverlight application
enabled to be run outside the browser chrome or something more complex that uses
the Silverlight APIs to check the network state and support offline scenarios. Perhaps
it even has a different UI when running out of the browser, building on those APIs
and those for runtime mode detection. Before exploring the more advanced scenar-
ios, you’ll start with the minimal changes needed common for all three cases—the
settings file.
5.3.1
The out-of-browser settings file
As you saw in chapter 3, the application manifest file tells the Silverlight plug-in all
about the components of your Silverlight application. What it doesn’t include is infor-
mation about the out-of-browser configuration. That information is included in the
out-of-browser configuration file OutOfBrowserSettings.xml (see listing 5.1).
<OutOfBrowserSettings ShortName="Pete's App"             
                      EnableGPUAcceleration="True"
                      ShowInstallMenuItem="True">
  <OutOfBrowserSettings.Blurb>                              
      Pete's Application on your desktop; at home, at work 
      or on the go.
  </OutOfBrowserSettings.Blurb>
  <OutOfBrowserSettings.WindowSettings>
    <WindowSettings Title="Pete's Out-of-Browser Application" 
                    Top="100" Left="100"                   
                    WindowStartupLocation="Manual"         
                    Height="450" Width="700" />           
  </OutOfBrowserSettings.WindowSettings>
  <OutOfBrowserSettings.Icons>                                    
    <Icon Size="16,16">AppIcon016.png</Icon>
    <Icon Size="32,32">AppIcon032.png</Icon>
    <Icon Size="48,48">AppIcon048.png</Icon>
    <Icon Size="128,128">AppIcon128.png</Icon>
  </OutOfBrowserSettings.Icons>
</OutOfBrowserSettings>
Listing 5.1
A basic out-of-browser application configuration file
Window 
settings

101
Creating out-of-browser applications
The short name of the application is what’s displayed in the right-click Silverlight
menu, the installation dialog, and the created desktop and Start menu shortcuts. The
Blurb is what maps to the description in the settings dialog, and it’s used as a descrip-
tion for the shortcut.
 This file also contains settings for the hosting window. The title, when combined
with the domain name, is shown in the title bar of the window hosting your applica-
tion. The Top and Left properties set where the window appears on the screen, when
the startup location is set to Manual. The Height and Width properties control the size
of the window.
 Finally, the file contains references to the icons used by the application. These are
PNG files, not ICO icon files. The use of PNG files allows you to support multiple plat-
forms while retaining the transparency capability of ICO files.
 It’s good to understand the role of this file in your project, but you typically won’t
create this file manually or edit the settings directly. Instead, you’ll use the Out-
of-Browser Settings dialog from the project properties in Visual Studio, as seen in
figure 5.8.
 This dialog is displayed when you click the Out-of-Browser Settings button on the
Silverlight tab of the project properties. One of the options is Show Install Menu,
Figure 5.8
The Out-of-Browser 
Settings dialog

102
CHAPTER 5
Out-of-browser applications
which allows you to toggle whether the default right-click install experience is dis-
played. If you uncheck that option, you must provide another way for users to install
your application out of the browser.
 The default right-click installation experience is adequate, but there may be times
when you want to provide a more controlled experience both with custom icons and
with a more obvious way to take the application out of the browser. I’ll cover that next. 
5.3.2
Controlling the experience
Silverlight provides several useful APIs for both detaching your application from the
browser and for checking the current state of your application. The first is the Appli-
cation.Current.InstallState value. The values for InstallState are shown in
table 5.1.
When the installation state is changed, the Application object will raise an Install-
StateChanged event that tells you to look at the InstallState property for the latest
state.
 You can extend this concept to force an out-of-browser-only mode in your applica-
tion simply by refusing to display the application UI unless running outside of the
browser. In that case, your in-browser application would simply be an install-me-locally
splash screen. Listing 5.2 shows how to set up your application so that it provides a
meaningful experience only when run out of the browser.
XAML: 
...
<Grid x:Name="IBNotInstalledExperience">
  <Button x:Name="InstallButton"
          Height="100" Width="400" FontSize="30"
          HorizontalAlignment="Center"
          VerticalAlignment="Center"
          Content="Take Out of Browser" />
</Grid>
Table 5.1
The values of InstallState
State
Meaning
Installed
The application has been installed by the user. Note that the current instance of 
the application may still be running in the browser. This value only tells you it’s 
available in the locally installed mode for the current user/machine.
InstallFailed
The application tried to install but failed.
Installing
The application is currently installing. When this state is active, it’s a good time to 
download the required assets if you intend to allow the application to run offline 
as well as out of the browser.
NotInstalled
This value indicates that the application hasn’t been locally installed.
Listing 5.2
Forcing out-of-browser mode

103
Creating out-of-browser applications
<Grid x:Name="IBInstalledExperience">
  <Rectangle Fill="Azure" Stroke="LightBlue"
             RadiusX="10" RadiusY="10" Margin="20" />
  <TextBlock Text="This application is installed locally. 
  ➥ Please run from the shortcut."
             FontSize="30" Margin="30" TextWrapping="Wrap"
             HorizontalAlignment="Center"
             VerticalAlignment="Center" />
</Grid>
<Grid x:Name="OobExperience" Visibility="Collapsed">
  <Rectangle Fill="Azure" Stroke="LightBlue"
             RadiusX="10" RadiusY="10" Margin="20" />
  <TextBlock Text="Running out of browser"
             FontSize="30" Margin="30" TextWrapping="Wrap"
             HorizontalAlignment="Center"
             VerticalAlignment="Center" />
</Grid>
C# code:
public MainPage()
{
  InitializeComponent();
  Loaded += new RoutedEventHandler(MainPage_Loaded);
  InstallButton.Click += new RoutedEventHandler(InstClick);
  Application.Current.InstallStateChanged += 
      new EventHandler(OnInstallStateChanged);
}
private void UpdateUserInterface()              
{
  if (Application.Current.IsRunningOutOfBrowser)
  {
    OobExperience.Visibility = Visibility.Visible;
  }
  else
  {
    if (Application.Current.InstallState == InstallState.Installed)
    {
      IBInstalledExperience.Visibility = Visibility.Visible;
      IBNotInstalledExperience.Visibility = Visibility.Collapsed;
      OobExperience.Visibility = Visibility.Collapsed;
    }
    else
    {
      IBInstalledExperience.Visibility = Visibility.Collapsed;
      IBNotInstalledExperience.Visibility = Visibility.Visible;
      OobExperience.Visibility = Visibility.Collapsed;
    }
  }
}
void OnInstallStateChanged(object sender, EventArgs e) 
{
  UpdateUserInterface();
}
void MainPage_Loaded(object sender, RoutedEventArgs e)
{
Installation and 
execution state 
Fired when installed 
or uninstalled

104
CHAPTER 5
Out-of-browser applications
  UpdateUserInterface();
}
void InstClick(object sender, RoutedEventArgs e)  
{
  Application.Current.Install();
}
The experiences resulting from the code in listing 5.2 are shown in figures 5.9 and
5.10. Note that the Install method may only be called from a user-generated UI
event, such as a button click. That way, you prevent applications from self-installing
without explicit user intervention.
Install button 
click handler
Figure 5.9
The same application 
after it’s detected that it was 
installed and is running outside of 
the browser. Note that the 
browser-hosted version responded 
to the InstallStateChanged 
event by changing its own UI.
Figure 5.10
The screen a user 
will see if he hasn’t installed this 
application. Clicking the button 
calls Application.Current 
.Install().

105
Creating out-of-browser applications
So though you can’t exactly force an application to install locally, you can design it to
show different interfaces depending on its installation state and current mode of
operation. Think carefully before you use this type of code in your own applications; if
there’s no compelling reason to force an application to run out of the browser only,
don’t force the user.
 The next step in customizing the experience is to change the icons displayed in
the install dialog, the application window, the Start menu, and the taskbar. 
5.3.3
Customizing icons
The next step in creating a customized out-of-browser experience is changing the
icons used in the application. The icons, which must be PNG files, are typically pro-
vided in four sizes from 128 × 128 to 16 × 16. The 128 × 128 size is used in the installa-
tion dialog. The other sizes are used in the Start menu, the window icon, shortcuts,
and the Apple OS X application list. Though you don’t need to provide every size, I
highly recommend that you do because they may not scale at runtime in quite the way
you want them to. The approach is similar to exploding a typical Windows ICO file
into four PNG files.
 To include icons, you add the OutOfBrowserSettings.Icons section to OutOf-
BrowserSettings.xml in the OutOfBrowserSettings section, as shown here:
<OutOfBrowserSettings ...>
...
  <OutOfBrowserSettings.Icons>
    <Icon Size="16,16">AppIcon016.png</Icon>
    <Icon Size="32,32">AppIcon032.png</Icon>
    <Icon Size="48,48">AppIcon048.png</Icon>
    <Icon Size="128,128">AppIcon128.png</Icon>
  </OutOfBrowserSettings.Icons>
</OutOfBrowserSettings>
The icons themselves are included in your project as Content and copied into the XAP
file at compile time. In the preceding example, they’re in the project root but you can
include them in a subfolder. The filenames can be anything you want as long as the
actual resolution of the file matches up with the known resolution assigned to it in the
Size property.
 That’s it for customizing the install experience. Next, you’ll learn how to handle
updating the application once it’s been installed.
5.3.4
Updating
A real benefit of browser-based applications is the ability to automatically update the
application without requiring any sort of explicit installation or push to the client
machine. Out-of-browser Silverlight applications aren’t different in that regard,
except that the developer controls the update process.
 The Silverlight Application object includes a CheckAndDownloadUpdateAsync
method that, as its name indicates, will check for any available XAP updates and
download, if present. When the method completes, it fires the CheckAndDownload-
UpdateCompleted event.

106
CHAPTER 5
Out-of-browser applications
 The code is fairly simple, and if you use a little lambda expression sugar to create
the delegate, you can even fit it all into a single short function:
private void CheckForUpdates()
{
  Application.Current.CheckAndDownloadUpdateCompleted += (s, e) =>
    {
      if (e.UpdateAvailable)
      {
        MessageBox.Show("A new version was downloaded.");
      }
    };
  Application.Current.CheckAndDownloadUpdateAsync();
}
When the CheckForUpdates call is made, Silverlight looks at the stored origin URI of
the XAP file and makes a normal background HTTP request to that location to verify
that the latest version is installed. If a new version is available, Silverlight will receive
that in the background and programmatically indicate that a new version is available
by setting the UpdateAvailable property to true in the returned event arguments
class. Unless you prompt the user to shut down and relaunch the application, the user
will still be running the old version. It’s not until the next run that the user will exe-
cute the newly downloaded version.
 But when you detect that a new version is available, you can display a dialog to the
user and request a restart. If the nature of the application allows it, you can also be
more draconian and completely block all of the UI functionality until the user restarts
the application. What you can’t do is force an application to restart programmatically.
A best practice is to gently inform your user (perhaps soothing music and pastel colors
will help) that a new version is available and let him restart at his convenience. At the
worst, he’ll get the new version during the next session.
 Once you’ve decided to take your application out of the browser, one of the capa-
bilities you’ll enable is the notification API. 
5.4
Alerting the user with notification toast
Windows notifications have been nicknamed toast due to their way of popping up
from the bottom right of the desktop, like a piece of bread in a toaster. Notification is
used for everything from displaying new email messages in Outlook, to new tweets in
the popular Twitter programs, to new items in the queue of a business application.
Notifications are an essential tool for alerting the user when the application is sitting
in the background or on another screen.
 Creating a simple notification window is easy. All you need to do is create an instance
of NotificationWindow, set the size, and set the content. The result will be less than
stellar, though; it’ll be a simple opaque white rectangle with your text overlaid:
if (Application.Current.IsRunningOutOfBrowser)
{
  NotificationWindow notify = new NotificationWindow();
  notify.Height = 75;

107
Controlling the host window
  notify.Width = 300;
  TextBlock text = new TextBlock();
  text.Text = "Basic Notification";
  notify.Content = text;
  notify.Show(5000);
}
The Show method takes a number of milliseconds representing how long you want to
show the window. The value of 5000 milliseconds used in this example is 5 seconds.
 
To 
take 
advantage 
of
NotificationWindow, you’ll need
to fill it up with something more
meaningful. Typically you’ll cre-
ate a user control to represent
the content and assign that
rather than a simple TextBlock.
Figure 5.11 shows an example of
a user control with a red and
black border, gray header text,
and white body text.
 On Windows, the notification windows will always display on the bottom-right cor-
ner on the screen. On Mac OS X, they display at the top-right corner.
 The window may be closed by timing out or by calling the Notification-
Window.Close method. In either case, the NotificationWindow.Closed event is fired,
allowing you to take action as necessary.
 Notifications windows enable you to display alerts outside the bounds of your
application window. You can customize the colors and borders for the notification
window. To keep things consistent throughout the application, you can also control
and customize the host window.
5.5
Controlling the host window
To create a truly differentiated out-of-browser experience, you’ll probably want to
have complete control over the title bar, resize bar, window buttons, and other ele-
ments that make up the window chrome. You may want to change only the color or
you may want to provide a completely different look and feel that blends seamlessly
with the application, without any jarring window borders.
 Silverlight supports several levels of customization to the out-of-browser window.
The simplest is setting the size and position of the window. From there, you can set it
to be a topmost window—one that floats above all others. You can also programmati-
cally activate it.
 Those are all easy controls, but often you need to go a step further. Silverlight sup-
ports customizing the out-of-browser window chrome. It even includes functions and
properties that make it possible for you to easily replicate the normal window behav-
ior, including minimizing, maximizing/restoring, closing, moving, and resizing the
window.
Figure 5.11
A customized notification window

108
CHAPTER 5
Out-of-browser applications
 This section starts with the basic properties, but because they’re simple and pretty
self-explanatory, you won’t linger. Instead, you’ll hop right into the meatier topics of
changing the window chrome, modifying the window state, and moving and resizing
the window.
5.5.1
Basic window properties
Elevated trust applications can change the properties of the host window at runtime,
including size, location, and even the chrome. The Window class used is similar to the
one used by WPF, so many of the properties and methods may be familiar to you. The
list of important properties and functions is shown in table 5.2.
The following example uses all of these properties and functions to size and position
the window, set its state, ensure it’s topmost, and then activate if it’s not already acti-
vated. I’ll cover the window state changes after I cover customizing the window
chrome because that’s where the window state typically comes into play:
if (Application.Current.HasElevatedPermissions)
{
  Window win = Application.Current.MainWindow;
  win.TopMost = true;
  win.Height = 200;
  win.Width = 200;
  win.Left = 150;
  win.Top = 150;
  if (!win.IsActive)
    win.Activate();  
}
Setting the size and state of the window is important, but that’s not changing the look
of the window chrome itself. To do that, you’ll need to use a few more features intro-
duced with Silverlight 4.
Table 5.2
Runtime-controllable properties of the out-of-browser host window
Member
Description
Top, Left
Gets or sets the position of the window.
Height, Width
Gets or sets the size of the window.
TopMost
Set to true to make the Silverlight application float above all other windows.
Useful for certain types of utility applications, but don’t abuse.
WindowState
Gets or sets the state of the window.
Possible values are Normal, Minimized, and Maximized.
IsActive
Read-only.
Returns a Boolean indicating whether the window is currently active.
Activate
Attempts to activate the application window by bringing it to the foreground and 
setting focus to it.

109
Controlling the host window
5.5.2
Changing window chrome
Silverlight applications tend to be highly visual and highly branded experiences.
When an out-of-browser application with a custom look gets wrapped in the standard
OS window chrome, it can ruin the experience. What you want is edge-to-edge control
over the look of your application, including the borders, buttons, and title bar.
 Elevated trust out-of-browser applications enable you to control the window
chrome. (I’ll cover the trust model in the next chapter.) You can choose to have the
default OS chrome, no border, or borderless rounded corners. You can’t have irregu-
larly shaped windows or windows with transparency. Figure 5.12 shows the options
inside the out-of-browser configuration dialog in Visual Studio 2010.
 The setting here adds an attribute to the Window element in the OutOfBrowserSet-
tings.xml file. The possible values for the style are shown in table 5.3.
Figure 5.13 shows a close-up of the corner of the
window when using the BorderlessRound-
CornersWindow as the window style. The result is
a rectangle with a 5-pixel corner radius on all
four corners, with no antialiasing or OS drop
shadow. This is a clipping function in Silverlight;
you don’t need to make any changes to your lay-
out to accommodate the rounded corner, unless
you want to.
 When you create custom chrome for your windows, you’re suddenly responsible for
the full behavior of the window, including creating a title bar (should you want one);
adding your own minimize, maximize, and close buttons; and handling moving and
resizing. Luckily, Silverlight provides several functions and events to help you do this.
Table 5.3
Window styles for out-of-browser applications
Value
Description
(unspecified element)
The default window chrome is based on the OS in use.
BorderlessRoundCornersWindow
The window is drawn with a 5-pixel corner radius on all 
four corners.
None
The window is a rectangular shape with no border.
Figure 5.12
 Custom chrome settings 
for elevated trust out-of-browser 
applications
Figure 5.13
A close-up view of the 
top-left corner of a black window using 
the round-corners setting. The radius is 
fixed by Silverlight itself.

110
CHAPTER 5
Out-of-browser applications
5.5.3
Minimizing, maximizing, restoring, and closing
Most chrome implementations will have at least three buttons on the upper right of
the window: Minimize, Maximize/Restore, and Close. When you use the normal OS
chrome, those buttons are provided for you. When using custom chrome, you’ll need
to set the window state or call the Close method on the Application.Current.Main-
Window object. Listing 5.3 shows how to handle these functions in an application with
custom chrome. The Grid is assumed to be the main layout root in MainPage.xaml.
XAML:
<Grid x:Name="LayoutRoot" Background="Orange">
  <StackPanel Orientation="Horizontal" HorizontalAlignment="Right"
              VerticalAlignment="Top" Margin="8">
    <Button x:Name="MinimizeButton" Width="15" Height="15" />
    <Button x:Name="MaximizeButton" Width="15" Height="15" />
    <Button x:Name="CloseButton"    Width="15" Height="15" />
  </StackPanel>
</Grid>
C#:
public MainPage()
{
  InitializeComponent();
  MaximizeButton.Click += MaximizeButton_Click;
  MinimizeButton.Click += MinimizeButton_Click;
  CloseButton.Click += CloseButton_Click;
}
void CloseButton_Click(object sender, RoutedEventArgs e)
{
  Application.Current.MainWindow.Close();  
}
void MinimizeButton_Click(object sender, RoutedEventArgs e)
{
  Application.Current.MainWindow.WindowState =
        WindowState.Minimized;          
}
void MaximizeButton_Click(object sender, RoutedEventArgs e)
{
  if (Application.Current.MainWindow.WindowState ==
        WindowState.Maximized)
  {
    Application.Current.MainWindow.WindowState =
          WindowState.Normal;        
  }
  else
  {
    Application.Current.MainWindow.WindowState =
          WindowState.Maximized;    
  }
}
Listing 5.3
Handling window state with custom chrome
Close
Minimize
Restore
Maximize

111
Controlling the host window
In this example, you can see how easy it is to add your own window state management
buttons to the elevated trust out-of-browser application. That gets you halfway there.
The other half of the required functionality is the ability to move your window by
dragging it with the mouse. 
5.5.4
Moving a window
There are three approaches to moving your window in Silverlight: making the whole
window draggable, making an element (such as the title bar) draggable, or not both-
ering. The last option isn’t going to make you any friends unless you’re writing some
sort of a docking tool that can only sit on certain positions on the screen, so that
leaves the first two. 
 Silverlight includes the DragMove method on the MainWindow object you used in
the previous examples. DragMove can be called from anything but is typically called
from the MouseLeftButtonDown event of a title bar, or of the window itself. Listing 5.4
builds on the previous example by adding a grid to represent the title bar and one
event handler.
XAML:
<Grid x:Name="LayoutRoot" Background="Orange">
  <Grid x:Name="TitleBar"                      
        Background="Blue" Height="30"
        VerticalAlignment="Top" />
  <StackPanel Orientation="Horizontal" ...
C#:
public MainPage()
{
  InitializeComponent();
  ...
  TitleBar.MouseLeftButtonDown += TitleBar_MouseLeftButtonDown;
}
void TitleBar_MouseLeftButtonDown(object sender, 
                                  MouseButtonEventArgs e)
{
  Application.Current.MainWindow.DragMove();   
}
The DragMove method is interesting because it takes over the mouse management
until the mouse is released. For that reason, you don’t need to wire up any mouse
movement events, or worry about the mouse getting outside the bounds of the win-
dow, or any of the other cruft you may have thought would be required.
 Silverlight provides one more method for window management, this one to allow
the user to resize the window when using custom chrome.
5.5.5
Resizing
Although all the other functions are considered essential to window management,
resizing is optional. Some applications don’t allow resizing by the end user. But
Listing 5.4
Code to implement dragging a window
Stand-in title bar
Dragging to move

112
CHAPTER 5
Out-of-browser applications
because Silverlight makes it so simple to rescale or resize elements when the window is
resized, this decision should be made only for aesthetic reasons and not for lack of
time to implement. 
 To support resizing, DragMove has a sister function named DragResize. The
DragResize function works much like DragMove, except it takes in a parameter that
allows you to specify where in the window the user is grabbing to resize. Listing 5.5
builds on the previous examples and shows how to use DragResize with a typical cor-
ner resize. Keep in mind that you can specify any edge by using multiple resize ele-
ments and calling DragResize with the appropriate parameter.
XAML:
<Grid x:Name="ResizeArea"                    
  Background="Blue" Height="30" Width="30"
  VerticalAlignment="Bottom" HorizontalAlignment="Right" />
<StackPanel Orientation="Horizontal" ...
C#:
public MainPage()
{
  InitializeComponent();
  ...
  ResizeArea.MouseLeftButtonDown += ResizeArea_MouseLeftButtonDown;
}
void ResizeArea_MouseLeftButtonDown(object sender, 
                                    MouseButtonEventArgs e)
{
  Application.Current.MainWindow.DragResize(   
                       WindowResizeEdge.BottomRight);
}
The ability to control the main window when running in the out-of-browser mode is
an essential addition to the Silverlight platform. It enables you to write applications
that look and feel like native OS apps—if you want them to. It also enables you to cre-
ate truly branded experiences that extend all the way to the edges of the window.
 Silverlight provides a number of ways you can control the window, from simply set-
ting its size and position, to floating it above other windows, all the way to using cus-
tom chrome. Silverlight also provides functions and properties to make window
manipulation easier when you implement your own chrome
5.6
Summary
Silverlight began as an in-browser web technology. Over time, it has evolved so that
the out-of-browser application model has become as popular, or more popular, than
the web-hosted model. Silverlight out-of-browser applications are compelling for
many types of applications, from simple forms-over-data business applications, to
locally installed games and media applications. The web-based deployment and
update model is appealing in all of these application categories.
Listing 5.5
Implementing resize using an element in the bottom-right corner
Resize corner
Drag resize

113
Summary
 When running out of the browser in partial trust, you gain additional storage
capacity without prompting, additional keyboard information, and a reduction in host
chrome that allows you to take a greater advantage of screen real estate and provide a
truly custom experience. For many behind-the-firewall business applications, and
both custom experiences and self-contained internet-delivered applications, this is a
compelling option with no real downside.
 With out-of-browser applications, you get the full Silverlight application model dis-
cussed in chapter 3 as well as support for great user experience capabilities, including
the layout and transformation capabilities we’ll discuss in chapter 7. Before we cover
that, though, let’s take a look at the security model and elevated trust. It’s hard not to
get excited about something so compelling and easy to use.

114
The security model and
elevated trust
The .NET desktop application code security model is centered on the concept of
code-access security (CAS). This model, although extremely powerful, was found to
be difficult to configure and maintain on end-user workstations using tools like
CASPOL (Code Access Security Policy editor), and sometimes difficult to use in pro-
duction code. It was also difficult for users to understand exactly what rights they’ve
granted to specific applications. Finally, it had no provision for easy runtime or appli-
cation install-time permissions granting to system resources like the webcam.
 For Silverlight, the team has implemented a simpler but more restrictive secu-
rity model, appropriate for web-delivered applications. The new model has two
main parts: the transparency model and user initiation and consent.
This chapter covers
■
Code classifications and the transparency model
■
User initiation and consent 
■
Elevated trust out-of-browser
■
Special considerations for elevated trust in-
browser
■
Elevated trust mode detection

115
Code classifications and the transparency model
 Code transparency helps ensure that application code is well behaved and can’t
compromise the machine. Specifically, it ensures that access to the file system and to
different APIs is heavily controlled by Silverlight itself. User initiation and consent
ensures that the application cannot do things on the user’s behalf without the user
either causing it to happen (initiation) or approving it (consent). 
 Of course, where would all these be if you didn’t have an escape chute? Silverlight
includes that in the form of elevated trust mode. Elevated trust mode, now supported
both in-browser and out-of-browser, relaxes the initiation and consent rules, and con-
siderably relaxes the transparency rules.
 This chapter explores the transparency model that forms the core of the sandbox
as well as the user initiation requirements added to Silverlight. It also looks at elevated
trust mode, including out-of-browser and the new in-browser elevated trust mode,
both of which may be used to escape the sandbox. But before you can learn about
how to escape the sandbox, you need to learn about the sandbox itself.
6.1
Code classifications and the transparency model
The types of code that execute in Silverlight can be divided into two classifications:
platform code and application code. Platform code is provided as part of the runtime
and SDK. Application code is the code you or others write on top of that platform
code. Your code, third-party controls, toolkits, and so forth are all considered applica-
tion code. The determination between the two types of code is based both on the loca-
tion from which it’s loaded and the public key for the assembly.
 The precursor to the Silverlight sandbox, called the Simple Sandboxing API, has
existed in the full .NET Framework since .NET 2.0 to better support code coming from
different locations, such as the GAC (Global Assembly Cache) and the internet. That
model included some of what we know as the transparency model in Silverlight.
NOTE
See Shawn Farkas’s description of the Simple Sandboxing API for the
full .NET Framework here: http://bit.ly/SandboxAPI.
In addition to the classifications, Silverlight has the concept of three security levels:
transparent code, safe critical code, and critical code.
Table 6.1
The three security levels in Silverlight from most secure to most privileged
Level
Description
Transparent code
Code that can’t elevate the permissions of the call stack, running only within the per-
missions of the calling code. Can’t call unsafe or otherwise unverifiable code. Must 
be type-safe. Application code falls into this area, as does some platform code.
Attribute: SecurityTransparentAttribute (default)
Safe critical code
Code that serves as the interface between transparent code and critical code. Trans-
parent code may call safe critical code.
Attribute: SecuritySafeCriticalAttribute

116
CHAPTER 6
The security model and elevated trust
Transparent code is code that can be verified as trustworthy. It doesn’t use pointers or
call into unmanaged APIs. The CoreCLR (Silverlight’s version of the .NET CLR) can
easily walk its call stack and identify the security level for all calls as calling transparent
or safe critical code. By default, all code in Silverlight must be transparent; there’s no
need to mark it with an attribute.
 Transparent code can’t call critical code directly; those calls must be routed
through safe critical code. Any attempt to call critical code directly will result in a
MethodAccessException. Safe critical code is responsible for validating that the call
stack is in an appropriate state to call potentially dangerous critical code. It also veri-
fies parameters and other security checks. Because transparent code can only call crit-
ical code via a safe critical code intermediary, all security checks and sandbox
restrictions are enforced. Safe critical code can also do everything critical code can
do—there’s just an assumption (verified by testing and auditing by Microsoft) made
that safe critical code has performed the appropriate steps to ensure transparent code
can call it without compromising security. Figure 6.1 shows the transparency model
and how the types of code interact.
 Your application code can only be transparent code; you can’t create safe critical
or critical code, regardless of the attributes, unless you happen to work at Microsoft
and have access to the build system and public/private key pair. That said, elevated
trust mode profoundly impacts the security levels, as you’ll see later in this chapter
and also in chapter 32, when I discuss COM automation and P-Invoke.
Critical code
Code that can escape the sandbox and perform operations such as file I/O that oth-
erwise wouldn’t be accessible to transparent code. When called from transparent 
code, it must be via safe critical code.
Attribute: SecurityCriticalAttribute
Table 6.1
The three security levels in Silverlight from most secure to most privileged
Level
Description
Figure 6.1
The transparency model in 
Silverlight allows transparent code 
access only to other transparent code 
and to safe critical code. Your 
application code is transparent code 
when running in the normal sandbox.

117
User initiation and consent
Critical and transparent code may have been a part of the .NET Framework for years,
but it’s the additional concept of safe critical code, new to Silverlight, that makes
proper sandboxing both easy and performant. Security in Silverlight isn’t just about
code—it’s also about user consent for access to key system resources.
6.2
User initiation and consent
Several features in Silverlight require user initiation, user approval, or both. User initi-
ation means that the call to the feature must be a direct result of a user action, such as
a menu option selection, button click, or accessibility device input from within Silver-
light. The action can’t be user input passed along from HTML. In addition, the code
must execute within a short window of time (the actual value of which is internal to
Silverlight and not public) after the user action, to prevent you from storing up a user
action and executing something 20 minutes later when they’ve forgotten about it.
Calling a function from, say, the Load event of a Page doesn’t count as user initiation.
 The user initiation requirement exists to prevent the application from doing
potentially invasive things on its own. Consider, for example, a widget sitting on a web
page. Would you want that to be able to turn on the webcam and stream video from
your PC without an explicit action on your part? I didn’t think so.
 In addition to (and some-
times instead of) user initiation,
some features require user con-
sent or approval. The webcam
example is a perfect illustration
of this. Figure 6.2 shows the
user consent dialog for the web-
cam and microphone. Other
consent dialogs look similar.
 As a bit of a double-whammy
for you, and a security win for
the user, the call to display this consent dialog must be made from a user-initiated
action, such as a button click, as shown in this example:
private void StartWebcam_Click(object sender, RoutedEventArgs e)
{
    if (CaptureDeviceConfiguration.AllowedDeviceAccess || 
Security and reflection
If you’re familiar with reflection in .NET, you may wonder how Reflection.Emit works
into this security model. In Silverlight normal trust applications, the code you generate
via reflection must be security transparent, like regular application code. The code
can’t call Security Critical .NET code, and it can’t call unmanaged code or access types
that wouldn’t normally be visible outside their defining assembly.
Figure 6.2
The user consent dialog for accessing the 
webcam and/or microphone

118
CHAPTER 6
The security model and elevated trust
        CaptureDeviceConfiguration.RequestDeviceAccess()) 
    { 
        _source.Start(); 
    }
}
If you fail to call RequestDeviceAccess from a user-initiated event, it’ll fail. There’s no
exception thrown, but you won’t get the results you’re hoping for.
 You’ll learn more about the webcam and microphone in particular in appendix C
of the ebook. And it isn’t the only feature of Silverlight that requires user initiation or
consent—table 6.2 shows the complete list.
User consent is an important part of the security model in Silverlight. The team has
made quite an effort to ensure that the consent is useful and necessary, while not bur-
dening the user with dialog after dialog of annoying prompts. The balance stricken is
tipped toward the user, but you’ll find it unobtrusive and reasonable. The work here
was received well enough that the same consent requirement concept was also
brought forward to Windows Phone 7 and to Windows 8 Metro, albeit in a slightly dif-
ferent form, with consent required for additional features but granted on install
rather than on demand.
 The security model in Silverlight is a sandbox based on code transparency, user ini-
tiation, and user consent. The intent is to ensure that users feel confident in down-
loading and installing applications, knowing they can’t harm their machine or invade
their privacy.
Table 6.2
Actions requiring user initiation or approval in partial-trust applications
Action
Description
Clipboard access
All clipboard access (copy and paste through the Clipboard class) 
must be user-initiated and must also have explicit permission 
granted through the approval dialog.
File dialogs
All file access in partial trust Silverlight applications must be per-
formed through the OpenFileDialog and SaveFileDialog dialogs, 
which must be user-initiated.
Full-screen mode
In partial-trust applications, full-screen mode must be user-initiated 
and will display a message indicating that the user can press Esc to 
exit full-screen mode.
Full-screen pinned mode
Pinned mode (remaining full screen on one monitor while you con-
tinue to work on another) requires user initiation as in regular full-
screen mode, but also requires a consent dialog.
Isolated storage quota increase
An increase to isolated storage quota doesn’t need to be user-initi-
ated, but it requires user consent.
Print dialog
Printing must be performed through display of the print dialog, which 
must be user-initiated.
Webcam/microphone access
Webcam and microphone access must be user-initiated and must 
also have explicit permission granted through the approval dialog.

119
Elevated trust
 User initiation and approval and, most importantly, the code transparency model,
are all tossed aside when you run the application in elevated trust mode. This mode,
which the user must approve, enables all the things that desktop applications might
normally do outside the sandbox.
6.3
Elevated trust
Elevated trust applications are those that have access to additional capabilities on the
machine on which they’re installed. For all intents and purposes, elevated trust appli-
cations are full-trust applications in .NET-speak. For example, elevated trust applica-
tions can use the new COM automation capabilities discussed in chapter 32, as well as
make web network requests without first checking for a client access policy. The full
list of capabilities enabled by elevated trust includes:
■
The ability to use COM or P-Invoke for native Windows integration.
■
The ability to call web services and make network requests without requiring a
client access policy check and without any cross-domain or cross-scheme
restrictions.
■
The elimination of the user consent requirement for webcam, microphone,
and other features.
■
Relaxed user initiation requirements. For example, you can enter the full-
screen mode in an Application.Startup event handler rather than requiring a
button click or other user-initiated event.
■
The ability to read and write files in user document folders.
■
The ability to use full-screen mode without keyboard restrictions and without
the “Press Esc to Exit” overlay.
■
The ability to control the size, position, and chrome for the host window.
That’s a pretty powerful list; it addresses most of the transparency and consent restric-
tions developers have been bothered by since the initial release of Silverlight 2. In par-
ticular, two of these items—the ability to make network calls without worrying about
cross-domain and the new COM automation capability—open up entirely new areas
for Silverlight development.
In this section, I’ll first cover how to create out-of-browser elevated trust applications
and the important step of how to sign them. Then, I’ll briefly look at in-browser ele-
vated trust applications, a real boon to people writing web parts that need system
In-browser or out-of-browser?
Silverlight 4 introduced the concept of elevated trust applications for out-of-browser
applications. Silverlight 5 enables it for in-browser applications as well. Most elevated
trust applications, though, continue to be out-of-browser because of the additional ca-
pabilities offered.

120
CHAPTER 6
The security model and elevated trust
access. I’ll wrap up with an example of how to check for elevated trust mode in your
own applications.
6.3.1
Creating elevated trust applications
The most common type of elevated trust application is an out-of-browser elevated trust
application. To mark your out-of-browser application as requiring elevated trust, first
you must make the application support the out-of-browser mode, as explained in chap-
ter 5. Then, it’s as easy as selecting a check box on the Out-of-Browser Settings page.
 It may seem simple to mark all out-of-browser applications as requiring elevated
trust, but the end-user install prompt is slightly more daunting when elevated trust is
used. Figure 6.3 shows the normal out-of-browser installation prompt. It’s pretty tame,
because the application is still running in the normal Silverlight sandbox.
 Once you move into the elevated trust mode, the dialogs become more intimidat-
ing to encourage the user to install applications only from the sources they trust.
UNSIGNED APPLICATIONS
Figure 6.4 shows the elevated trust install dialog for an unsigned application. It’s a
scary dialog that’ll give most users pause. For that reason alone, it’s good to be judi-
cious about which applications require elevated trust; you might consider offering
alternative versions of your application that don’t require additional permissions.
 If you want to have a friendly elevated trust installation dialog, you’ll need to sign
the application (sign the XAP) using a certificate from a trusted certificate authority.
Figure 6.3
Normal out-of-browser 
installation prompt showing the 
name of the application as well as 
the URL from which it originated
Figure 6.4
Unsigned out-of-browser 
elevated trust install prompt. Will your 
users be okay with clicking Install here?

121
Elevated trust
SIGNED APPLICATIONS
The only way to have an elevated trust application without a scary dialog is to sign the
XAP using a certificate from a trusted authority such as VeriSign, Thawte, GoDaddy, or
Comodo. Once you sign the XAP, you’ll get a much friendlier dialog, as shown in
figure 6.5.
 Users are much more likely to install an application with the friendlier dialog and
your publisher information than with the yellow-bannered “unverified source” shown
in figure 6.4. 
 For testing purposes, you can self-sign your XAP using a test certificate. Visual Stu-
dio, via the options on the Signing tab for the Silverlight project, will generate the test
certificate for you. You’ll then need to add the certificate to your own store in the
Trusted Certificate Root. Anyone else who’s going to test the application will also need
to install the certificate. The fewer people with your test cert, the better, so be sure to
get a real certificate early in the process.
 Once you have a certificate, you can use it in Visual Studio 2010 to sign your XAP.
This is accomplished via the Signing tab in the project properties window for the Sil-
verlight application. Figure 6.6 shows a XAP file signed by my own test certificate.
 Once you have the certificate installed and it’s recognized by your target machines,
you’re good to test and deploy. Make sure you get the certificate early in the process
because it typically isn’t a simple, quick, or completely online process. Nevertheless,
Figure 6.5
Signed out-of-browser elevated trust 
install prompt. This is more like it.
Figure 6.6
Signing options in 
Visual Studio 2010

122
CHAPTER 6
The security model and elevated trust
this is the same process you’ll go through for certificates for any use, including appli-
cation signing and secure sockets.
TIP
Jeff Wilcox from the Silverlight team at Microsoft put together a great
walkthrough for purchasing and installing a certificate for personal use. You
can find it on his blog here: http://www.jeff.wilcox.name/2010/02/
codesigning101/. 
In addition to the nice install prompt, XAP signing is required if you want your ele-
vated trust out-of-browser application to be able to use the out-of-browser update
mechanism. For that reason, it should be clear that signing is more than just a good
idea—it’s a requirement.
 Out-of-browser elevated trust applications are the most common, but Silverlight 5
added support for in-browser trusted applications as well. 
6.3.2
Enabling in-browser elevated trust applications
Silverlight applications running in-browser fill an important gap for enterprise cus-
tomers: they enable scenarios such as web parts in SharePoint portals that have access
to system resources and that can make cross-domain networking calls, for example.
 In-browser elevated trust applications have nearly identical capabilities when com-
pared to out-of-browser applications. The places where they differ have to do with fea-
tures that require out-of-browser functionality, such as customizing the window
chrome and displaying pop-up native windows (chapter 28). 
 It’s deceptively simple to create and test an in-browser elevated trust app. All you
need to do is set the appropriate option on the project properties page, as shown in
figure 6.7.
 Once this option is selected, the tooling will create an InBrowserSettings.xml file
in the project properties folder. This file will contain a single setting to enable ele-
vated permissions, as shown here:
<InBrowserSettings>
  <InBrowserSettings.SecuritySettings>
    <SecuritySettings ElevatedPermissions="Required" />
  </InBrowserSettings.SecuritySettings>
</InBrowserSettings>
With that simple change, the application can now be run in elevated trust mode from
your IDE on your local machine, from localhost. 
Figure 6.7
Marking an application as 
an in-browser elevated 
trust application

123
Elevated trust
Unlike out-of-browser applications, signing your XAP is a hard requirement for
deploying your in-browser application beyond localhost. In addition, you’ll need to
take steps to enable in-browser elevated trust on client machines.
 The architects of this mode intended it to be used inside firewalls (corporations), so
unlike out-of-browser elevated trust, this feature is disabled by default on all machines.
You can update this using a set of registry keys set by Group Policy, as shown here:
 On 32-bit machines:
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Silverlight
and on 64-bit machines:
HKEY_LOCAL_MACHINE\Software\Wow6432Node\Microsoft\Silverlight\
In that location, you’ll need to create one or more of the REG_DWORD values shown in
table 6.3.
NOTE
There are a number of Group Policy settings for Silverlight, all
designed to make corporate use easier. You can find a helpful article listing
them here: http://bit.ly/SLGroupPolicy.
The reason you didn’t need these registry entries when creating your own applications
on localhost is because localhost is a special whitelisted domain. If you host your
Silverlight application in an external website (anything other than localhost) and try
to launch it without these keys, you’ll get a SecurityException when you perform an
elevated trust operation.
 Unlike out-of-browser elevated trust, which is internet-friendly, in-browser elevated
trust is meant only for use on an internal network. Clearly you wouldn’t ask an inter-
net user to update their registry in order to run your browser plug-in, and it just seems
strange to download an MSI to update some settings to enable a web page to function. 
 I’d be remiss if I didn’t point out that in-browser elevated trust applications are still
at the mercy of the browser. In particular, if the site runs in Internet Explorer pro-
tected mode, you’ll find there’s little you can do. In that case, you need to make sure
the domain is configured in IE not to kick into protected mode.
Table 6.3
Registry entries for enabling Silverlight elevated trust on a single machine
Key
Description
AllowElevatedTrustAppsInBrowser
Set to 1 to enable elevated trust applications to run in-
browser on this machine.
Default value when not specified is False (0).
AllowInstallOfElevatedTrustApps
Set to 1 to enable out-of-browser elevated trust applica-
tions to be installed on this machine.
Default value when not specified is True (1).
AllowLaunchOfElevatedTrustApps
Set to 1 to enable previously installed elevated trust 
applications (in-browser or out-of-browser) to be run on 
this machine.
Default value when not specified is True (1).

124
CHAPTER 6
The security model and elevated trust
NOTE
Find out more about IE Protected mode here: http://bit.ly/
IEProtectedMode.
Trusted applications have a lot going for them, but users can still reject elevated per-
missions. If you’re going to build elevated trust applications and potentially share any
code with a normal trust application, one thing you’ll need to do is check to see
whether the user has actually granted you elevated permissions. 
6.3.3
Detecting elevated trust mode
Before enabling certain features in your application, it’s a good practice to check to
see if you’re running in elevated trust mode. The Application object exposes the
HasElevatedPermissions property, which allows you to do just that:
if (Application.Current.HasElevatedPermissions)
{
    // Light up the awesomeness
}
Checking for elevated permissions allows you to take alternative approaches in cases
where the permissions weren’t granted. Graceful downgrading of functionality is
always a good idea when it comes to Silverlight applications. You can provide the users
with the level of features they’re comfortable with while maximizing the number of
people you’re able to serve.
6.4
Summary
Silverlight is, by default, a highly secure sandboxed application environment. As a web
plug-in, this makes complete sense: you don’t want random web pages having access to
the innards of your machine. If your code wants to access the webcam, it needs to obtain
permission from the user to do so. If it wants to open a file, it needs to use the Open-
FileDialog (or SaveFileDialog) and get no information about the user’s file system. 
 When Silverlight moved out of the browser, there came a call for greater access to
the local system. The subsequent version of Silverlight introduced elevated trust mode
for out-of-browser applications. This mode allowed much more system access and
removed many of the user consent requirements that plagued desktop application
developers.
 Enterprises loved the idea of elevated trust, but they wanted to use it in-browser, in
portal plug-ins, and on web pages, without requiring special code to handle updating
as you would in out-of-browser mode. For those customers, Silverlight 5 added support
for in-browser elevated trust mode. Unlike out-of-browser elevated trust, though, it’s not
meant to be used on the public internet and therefore has no support for that scenario.
 Throughout the rest of this book, I’ll explore the features of Silverlight, including
those that require elevated trust, those that require user initiation, and those that
require user consent. I touched on a few of those features in this chapter, but by no
means provided a full treatment for each topic.
 In the next chapter, I’ll continue our dive into the depths of Silverlight with a look
at the rendering and layout engines and transformations.

Part 2
Creating the user interface
Silverlight is an entire platform based on a specific .NET profile, but it’s bet-
ter known as a UI technology based on XAML. In part 1, you saw how Silverlight,
.NET, and XAML fit together to enable you to build both in-browser and out-of-
browser desktop applications.
 In part 2, you’ll look at the specific UI elements and stacks that make Silver-
light applications tick. I’ll start with the fundamentals of layout and rendering
and build on that with an in-depth look at panels such as the Grid and Stack-
Panel. Then you’ll learn about accepting input from application users, whether
they use mouse, touch, ink, or keyboard as their mode of interaction. 
 Text is an important part of most applications, so I’ll cover it in detail—from
the basics of the text stack, to fancy OpenType text, to support for eastern lan-
guages. I’ll then show you how to display and input both plain and rich text
using the built-in elements.
 During the discussion of text, I’ll introduce a few controls such as the Text-
Box and RichTextBox. In chapter 12, I’ll expand on that discussion to cover the
various types of controls Silverlight offers, how to use them, and even how to cre-
ate your own UserControls.
 Silverlight XAML stands above many other UI technologies due to the rich
support for animations and for styling the controls. You’ll learn how to effec-
tively use animation in your applications, as well as how to encapsulate anima-
tion and control properties into reusable styles and templates.
 Part 2 wraps up by bringing you back to where you started, XAML, and shows
you how to extend XAML through converters and extensions and by creating
your own rich controls. 


127
Rendering, layout, and
transforming
In the past few chapters, I covered some fairly big-picture topics, such as how to
have Silverlight work in and out of the browser, how to use elevated trust, and how
to use XAML. Those are all important to understand in order to create Silverlight
applications. XAML and the property system are also important, and you’ll build
upon that knowledge in every subsequent chapter, including this one.
 This chapter focuses on fundamentals of the core UI base classes and the ren-
dering and layout systems that make everything fit on the screen and render to the
user. Silverlight’s rendering process involves a number of steps and has provisions
for several developer-provided optimizations to the process. Silverlight also has a
far more advanced layout system than simple left/top positioning of elements on
the screen. The multipass layout system handles measuring and arranging elements
across the entire visual tree.
This chapter covers
■
UI elements and framework elements
■
The layout system
■
The rendering pipeline
■
2D and 3D transformations

128
CHAPTER 7
Rendering, layout, and transforming
 Once you have the rendering, layout, and core object fundamentals down, you’ll
have fun with performing 2D transformations on your objects. If you’ve ever wanted to
rotate or scale an object on the screen, you’ll find the section on render transforma-
tions to your liking.
 Of course, if you have 2D, you always want one more, so you also have 3D transfor-
mations. You can do wild things with the power of the PlaneProjection and the
Matrix3dProjection classes. The former is great for most use cases, including the
ubiquitous CoverFlow scenario. The latter is one of the most powerful transforma-
tions in Silverlight. If you’ve ever wanted to do something akin to a 3D-rotated,
sparsely populated, and z-layered deep zoom, you’ll definitely get a kick out of the
power of the 3D matrix. Note that this is separate from the full frame-based 3D system
covered in chapters 26 and 27.
 I’ve covered the fundamentals of XAML, so let’s start with the base classes that
underlie all those angle-bracketed elements that make up the UI: the UIElement and
FrameworkElement classes.
7.1
The UIElement and FrameworkElement 
In previous chapters, you saw examples of TextBlocks, TextBoxes, and other controls
and elements. All of the UI elements in XAML are FrameworkElement items, so they’re
also inherently UIElement items because FrameworkElement inherits from UIElement.
 A UIElement is an object that represents a visual component. These types of ele-
ments have built-in support for layout, event handling, and rendering. Although this
extremely generic description may seem pointless, it isn’t. In fact, by deriving from
this type, a large majority of the elements within Silverlight share the same types of
features. These features are exposed through a number of extremely valuable meth-
ods and properties.
 Throughout this section, I’ll cover the methods and properties that you’ll probably
use most often. It’s important to recognize that some of these belong to the Frame-
workElement class, whereas others belong to the UIElement class. I’ll point this out as
I go along, but for now, let’s begin by addressing some of the common properties.
7.1.1
Properties
The UIElement and FrameworkElement classes expose a number of properties com-
mon to all the visual elements in your application. Because of the abstract nature of
the UIElement and FrameworkElement classes, these properties may be set on any con-
trol in a variety of scenarios. 
 This section starts with a look at cursors, then explains how to make your entire
element partially or completely transparent. Sometimes, transparent isn’t good
enough and what you want is to have the control logically removed from the visual
tree, so I’ll look at the Visibility property. From there, you’ll learn how to align an
element in the horizontal and vertical spaces. Finally, I’ll cover how to set margins to
give your elements a little breathing room and show you how to snap the layout to
whole pixels so your lines look crisp and fully rendered.

129
The UIElement and FrameworkElement 
CURSOR
When a user navigates the mouse cursor over a FrameworkElement, the cursor will
change to indicate the type of action the user can take. For instance, when you hover
around a Canvas, you’ll see a basic arrow. Alternatively, if you move your mouse over a
HyperLinkButton, you’ll see a cursor that looks like a hand. But you can use whatever
cursor you want by setting the Cursor property; for example, using the Stylus cursor
with a TextBlock:
<Canvas Cursor="Hand" Background="Green" Height="60" Width="180">
  <TextBox Cursor="Stylus" Height="20" Width="60" />
</Canvas>
This example uses two nondefault cursor options: Stylus and Hand. These options
represent Cursor items, each of which is accessible through the System.Windows.
Input.Cursors class. This class exposes nine statically visible Cursor properties: the
Arrow, IBeam, SizeWE, Eraser, Stylus, Hand, SizeNS, Wait, and None. 
 Most of these cursor types  reflect the cursor options found in CSS. One, Opacity,
only made it into some of the latest CSS standards.
OPACITY
The Opacity property represents an element’s transparency. By default, this double-
precision value is set to 1.0, which means the element is completely visible. You have
the flexibility to set this value as low as 0.0, making it completely transparent. To get a
feel for how the Opacity property renders content, look at figure 7.1, which shows a
TextBlock with varying Opacity values.
 The Opacity values ensure that a UIElement is visible. If you set the Opacity value
to 0.0, the element wouldn’t be visible. Just because a UIElement can’t be seen, it
doesn’t mean it’s not there. Instead, even if a UIElement has an Opacity of 0.0, it’ll
still behave as though it can be seen. For instance, a transparent element will still
respond to mouse events. If you want to completely hide an element, you must change
the Visibility property.
Web cursor standards
The ubiquity of browser applications has altered some of the UI standards you’ve tra-
ditionally followed on the desktop. For example, a common standard to apply in your
web application is to use the Hand cursor for many things a user can click and not
just hyperlinks. This standard is slowly finding its way to traditional desktop applica-
tions, where it’s helpful to differentiate dead space from active areas such as buttons.
Anything that helps your users quickly identify actions they can take is a good thing.
Figure 7.1
An example 
of the Opacity property

130
CHAPTER 7
Rendering, layout, and transforming
VISIBILITY
The Visibility property gives you the ability to toggle whether a UIElement can be
seen and whether it participates in layout. By default, all UIElement objects have a
Visibility value of Visible. This ensures that a UIElement can be seen and occupies
its allotted layout area. If you set the Visibility of a UIElement to Collapsed, no lay-
out area is reserved for the UIElement. Consider the StackPanel in listing 7.1.
Result:
<StackPanel x:Name="myStackPanel" Background="Orange" Width="90">
  <TextBox x:Name="tb1" Width="60" Background="LightGray" />
  <TextBox x:Name="tb2" Width="60" Background="DarkGray" />
  <TextBox x:Name="tb3" Width="60" Background="Gray"  />        
</StackPanel>
Listing 7.1 shows three TextBox elements. By default, each has a Visibility value of
Visible. Listing 7.2 shows what happens when the Visibility property of the middle
TextBox is set to Collapsed.
<StackPanel x:Name="myStackPanel" Background="Orange" Width="90">
  <TextBox x:Name="tb1" Width="60" Background="LightGray" />
  <TextBox x:Name="tb2" Width="60" Background="DarkGray" 
    Visibility="Collapsed" />
  <TextBox x:Name="tb3" Width="60" Background="Gray"  />        
</StackPanel>
This listing highlights the effects of Collapsed. The TextBox with the name tb2 isn’t
shown. You could just set Opacity to 0.0, but the layout space wouldn’t be freed. In
addition, using the Opacity property to hide an element can be wasteful; an element
with an Opacity value of 0.0 still participates in the layout and rendering. Elements
with Visibility set to Collapsed skip the rendering stem and report no size in the
layout steps.
Cursor, Visibility, and Opacity all affect visible portions of the UIElement, but
not the layout. The alignment properties typically have a great impact on the layout of
an element, depending on the panel in which the element is hosted.
Listing 7.1
Three visible elements in a StackPanel
Listing 7.2
Two visible elements and one collapsed element in a StackPanel

131
The UIElement and FrameworkElement 
HORIZONTALALIGNMENT AND VERTICALALIGNMENT
Every FrameworkElement gives you the opportunity to specify how it should be aligned
within its parent. This alignment setting will trickle down through the object tree and
affect the alignment of all child elements—well, at least until another Framework-
Element sets its alignment. You have two ways to align visual elements.
 Visual elements can be aligned both vertically and horizontally by setting the
VerticalAlignment and HorizontalAlignment property values to one of the accept-
able values. These values belong to two separate enumerators, aptly called Vertical-
Alignment and HorizontalAlignment as shown in listing 7.3.
<StackPanel Orientation="Horizontal">
  <StackPanel Width="200" Background="LightGray">
    <TextBox HorizontalAlignment="Left" />       
    <TextBox HorizontalAlignment="Center" /> 
    <TextBox HorizontalAlignment="Right" />
    <TextBox HorizontalAlignment="Stretch" />
  </StackPanel>
  <Canvas Width="20"></Canvas>
  <StackPanel Width="200" Background="LightGray" Orientation="Horizontal">
    <TextBox VerticalAlignment="Top" />          
    <TextBox VerticalAlignment="Center" />
    <TextBox VerticalAlignment="Bottom" />
    <TextBox VerticalAlignment="Stretch" />
  </StackPanel>
</StackPanel>
This example shows the effects of all four HorizontalAlignment options and all four
VerticalAlignment options. The HorizontalAlignment property accepts the Left,
Center, Right, and Stretch values, whereas the VerticalAlignment property accepts
What about Visibility.Hidden?
In WPF, the Visibility enumeration contains Hidden in addition to the Collapsed
and Visible values supported by Silverlight. Hidden hides an element but reserves
a space for it during layout. Originally, Silverlight 1.0 supported the Hidden value, but
it acted like Collapsed, so the team decided to change it to Collapsed during the
1.0 beta cycle. To get the same effective behavior as Hidden, set Opacity to 0.0
and IsHitTestVisibile to False. The end result will be an element that takes up
space on the screen but is both invisible to the eye and to the mouse. But unlike
Visibility.Hidden, the control will still participate in the layout and rendering—a
potential performance concern if you use this often or in animation-heavy scenarios.
Listing 7.3
Horizontal and vertical alignment
Horizontal
alignment
Vertical 
alignment

132
CHAPTER 7
Rendering, layout, and transforming
the Top, Center, Bottom, and Stretch values. The alignment properties behave dif-
ferently depending on the container in which the UIElement resides. For example,
they have no effect when put into a Canvas due to the Canvas panel’s lack of layout
functionality.
 Both properties default to their Stretch values. Because the Stretch options alter
the rendered height or width of an element to take up the maximum amount of space
available, you may want to consider giving the element some breathing room with the
Margin property.
MARGIN
Similar in nature to the Padding property, the Margin property enables you to specify
a cushion, but this specific cushion works outside the bounds of a FrameworkElement.
This cushion can be set using a single value or a space-delimited or comma-delimited
list of two (horizontal, vertical) or four (left, top, right, bottom) values just like the
Padding property, as shown in listing 7.4. 
<StackPanel Background="Gray">
  <TextBox Background="LightGray" 
           Margin="10"                
           Padding="10"                          
    Text="Margin is outside, Padding is inside" />
</StackPanel>
This small bit of markup shows the Margin and Padding properties working together.
The Padding property is valid in this code because this property is exposed by the
System.Windows.Controls.Control class. This topic is explained further in the next
chapter. For now, it’s important to recognize that the Padding property isn’t accessible
to all FrameworkElement items but the Margin property is.
 Margins and padding can alter the location of contained elements, sometimes
pushing them to subpixel locations and making them look fuzzy. Luckily, Silverlight
has the UseLayoutRounding property to help you avoid that.
USELAYOUTROUNDING
Silverlight supports aligning elements on subpixel boundaries. An unfortunate side
effect of this is the loss of crisp lines. Sometimes, you really want that 1 pixel line to be
just 1 pixel thick and not antialiased to 2 pixels in thickness.
 One way to avoid this problem is to place your elements on whole pixel locations.
But when your element is nested inside a panel, which is inside a control, which is in a
stack panel located in another grid—all of which can have margins, padding, and
other properties affecting layout—you can’t easily calculate exactly where your ele-
ment will appear.
Listing 7.4
Margin and padding
Margin on outside
Padding on inside

133
The UIElement and FrameworkElement 
 Silverlight supports a property of the UIElement called UseLayoutRounding. When
UseLayoutRounding is set to true, the layout system (see section 7.3) will round the
points of your element to the nearest whole pixel. When it is set to false, Silverlight
will respect the subpixel location of the points and won’t attempt to move them. List-
ing 7.5 shows the impact of layout rounding on two rectangles. The first rectangle has
layout rounding turned on; the second has it turned off.
Result:
Result (enlarged):
XAML:
<Grid x:Name="LayoutRoot" Background="White">
    <Rectangle Margin="10.5"
               UseLayoutRounding="True"        
               HorizontalAlignment="Left"
               VerticalAlignment="Top"
               Fill="Transparent"
               Stroke="Black" StrokeThickness="1"
               Width="150" Height="30" />
    <Rectangle Margin="20.5"
               UseLayoutRounding="False"      
               Fill="Transparent"
               HorizontalAlignment="Left"
               VerticalAlignment="Top"
               Stroke="Black" StrokeThickness="1"
               Width="150" Height="30" />
</Grid>
In this listing, you can see that the rectangle that isn’t rounded to the nearest pixel
has lines that are 2 pixels thick and light gray. When viewed in its native 1:1 pixel reso-
lution, it looks fuzzy. When layout rounding is turned on, the result is a crisp line with
sharp corners and no fuzz. When verifying this yourself, make sure neither your
design surface nor your browser is zoomed in or out.
UseLayoutRounding is respected by almost every element in Silverlight. The
Polygon class exposes this property but ignores it. Polygons are expected to be complex
shapes where layout rounding wouldn’t make sense, so layout rounding is a no-op.
NOTE
When sharing code with WPF, it’s important to note that layout round-
ing is turned on by default in Silverlight. This is in contrast to WPF, where it’s
turned off by default.
Listing 7.5
Layout rounding in action with two rectangles
Rounding
No rounding

134
CHAPTER 7
Rendering, layout, and transforming
This chapter covered the Margin property as well as the useful HorizontalAlignment
and VerticalAlignment properties. In addition, it highlighted the value of the
Visibility, Opacity, and Cursor properties. Finally, you saw how to scare away the
fuzzies with UseLayoutRounding. Collectively, these represent some of the more
widely used properties of the FrameworkElement and UIElement classes. But these
properties only serve to describe an element. There are times when you need to per-
form an action on them; in these scenarios, you need to rely on their methods. 
7.1.2
Methods
Two common tasks are often performed during runtime. The first involves managing
attached properties. The second involves finding an element within the element tree.
I’ll cover each in detail.
MANAGING ATTACHED PROPERTIES
Every UIElement is a DependencyObject. A DependencyObject gives you the ability to
retrieve and change attached property values. Consider the process of programmati-
cally altering the position of an element within a Canvas. Although you might initially
think to simply set the Canvas.Left and Canvas.Top properties as you would in
markup, you’ll quickly run into a wall. Instead, you must take advantage of the
SetValue method, as shown in listing 7.6.
XAML:
<Canvas x:Name="parentCanvas"
  Width="400" Height="400" Background="LightGray">
  <TextBlock x:Name="myTextBlock" 
    Text="Click Me" 
    Cursor="Hand" 
    MouseLeftButtonUp="MyTextBlock_Click"    
    FontFamily="Verdana" />
</Canvas>
C#:
private void MyTextBlock_Click(object sender, MouseButtonEventArgs e)
{
  double top = 
    (double)(myTextBlock.GetValue(Canvas.TopProperty));   
  double left = 
    (double)(myTextBlock.GetValue(Canvas.LeftProperty));   
  myTextBlock.SetValue(Canvas.TopProperty, (top+5));    
  myTextBlock.SetValue(Canvas.LeftProperty, (left+5)); 
}
When a TextBlock is clicked and the click event raised, it’ll move 5 pixels down and to
the right. This is made possible by retrieving the current Left and Top positions of the
TextBlock within the Canvas through the GetValue methods. Then, the TextBlock is
moved within the Canvas using the SetValue methods. But how do the TopProperty
and LeftProperty values come from the Canvas when they’re used on the TextBlock?
Listing 7.6
Moving a TextBlock five pixels with GetValue and SetValue
GetValue
SetValue

135
The rendering process
 These properties are DependencyProperty elements—a special type of property
designed to depend on information from multiple sources, covered in chapter 2. For
instance, as shown in listing 7.6 you use two DependencyProperty (specifically
attached properties) attributes—Canvas.Left and Canvas.Top—to position the
TextBlock. At the same time, there could be an animation affecting the TextBlock, so
the position of the TextBlock would be dependent on both the layout panel (the
Canvas) and the animation. (Animations are discussed in chapter 13.)
 Thanks to the DependencyProperty, it’s incredibly easy to manage or retrieve the
value associated with an attached property. Dependency properties also provide sev-
eral other advantages, discussed in more detail in chapter 2. For now, let’s look at how
to find elements within the element tree.
FINDING ELEMENTS
As described in chapter 2, the Silverlight Object Model is represented as a hierarchi-
cal tree of elements. Considering that each element in this visual tree is, at its core, a
FrameworkElement, you have the flexibility to navigate this tree. With this element,
you have the ability to go either up or down the tree.
 To go down the tree, you must call the FindName method. (Or you can traverse the
tree yourself starting at the root, recursing through the Children collections in the
various panels. Using FindName handles that for you.) This method takes the name of
an element and retrieves it. It doesn’t matter if the element is a child, grandchild, or
located even further down the tree. The FindName method will retrieve it as long as it’s
a descendent. If it isn’t found, the method will return null.
 Alternatively, if you need to find an element up the tree, you use the Parent prop-
erty to recursively navigate up the tree and search the sibling nodes.
 Finding elements is a task that you may need to perform in certain circumstances,
such as when you dynamically load XAML. Once these elements are found, you can
readily get or set the attached property values of a UIElement using the GetValue and
SetValue methods. These methods aren’t difficult to understand, but the process of
using a DependencyProperty to set the value of an attached property may seem strange
at first. As you grow more familiar with it, it’s easier to see the power of this approach,
which can lead to new ways of delivering a rich and interactive user experience.
 The UIElement and FrameworkElement classes form the base of everything that’s
rendered in Silverlight. You’ve seen that they offer a number of useful properties and
methods to control everything from their alignment, to visibility, to how opaque they
should appear. Now that you understand the capabilities they offer, it’s time to take a
step back and look at the rendering process as a whole, in which the UIElement and
FrameworkElement play a core role. 
7.2
The rendering process
User interfaces in Silverlight are complex. They often have multiple layers of semi-
transparent or overlapping content, animation, video, and more. The level of prob-
lems the runtime must solve is more akin to that of a gaming platform than, say,
something like Windows Forms.

136
CHAPTER 7
Rendering, layout, and transforming
 The problem is made even more complex by the restrictions and capabilities of the
various browser platforms. Most browsers have a simple threading model, varying
sandboxed capabilities, and what can only be described as personality.
 It’s important to understand the rendering process, especially as it relates to per-
formance. In this section, I’ll cover some of the highlights of the process, including
browser threading, drawing, performance optimizations, and how you can plug into
the process using the callback function.
 The rendering process can be broken down into the steps described in table 7.1.
More than just that happens, of course. There’s user code, media decoding, anima-
tions on a separate thread, network access, and so on, but this table captures the
essence of the rendering process. Though it can help to conceptualize this as an ongo-
ing loop, it’d be slightly inaccurate to do so, because the individual steps trigger timer
events and window messages and not a single cycle timer. Nevertheless, just as we still
refer to the various timer- and event-driven processes in game development as the
game loop, it’s a reasonable abstraction.
 This process is continually optimized from release to release and even across
devices. For example, the Windows Phone 7 process, though similar to what I’ve just
described, actually runs the animations on a separate thread.
 One of the most significant limitations of the rendering process for any browser
plug-in is the UI thread. Each browser offers up one UI thread per process, shared
across all plug-ins in that process. For some browsers, the scope of a process is a single
tab; for others, it’s the entire browser.
 Of the preceding steps, a few demand additional explanation. Specifically, the
clock tick, the per-frame render callback, rasterization, and layout all require more
Table 7.1
The steps of the render process
Step
Description
Update hosted 
HTML
Get updated visuals for the hosted WebBrowser control, if used—for example, a 
hosted web page playing a video.
Clock tick
Increment the animation and video clock.
Event handlers
Run the user code in event handlers, except for the per-frame render callback.
Layout
Measure and arrange elements for display. Because this is one of the most impor-
tant steps in this process, I’ll cover this in more detail in section 7.3.
Per-frame render 
callback
Run the per-frame callback CompositionTarget.Rendering.
Rasterize
Rasterize the vector content, media, images, and more onto their intermediate ren-
der surfaces. Then composite to the back buffer.
Show Frame
Show the frame in the browser. Blit (direct memory chunk copy; short for bit block 
transfer) the back buffer to video memory or to the software rendering surface.

137
The rendering process
detail. I’ll start with an explanation of rasterization and the various steps involved in it
and then look at how you can plug into the process via the render callback. Finally,
because it’s a much larger topic and arguably is the most important one to under-
stand, I’ll cover layout in section 7.3. Before that, let’s look at a few of the other steps,
starting with the clock tick.
7.2.1
Clock tick
Animation and video in Silverlight are governed by clock time and not by frame rate.
Because of this, Silverlight can skip frames on the machines that can’t keep up while
still maintaining the correct real time of the media or the animation frames shown. In
other words, an animation that lasts 2 seconds will last 2 seconds on a slow machine
and on a fast machine.
 The clock tick on Windows happens at 60 frames per second at the most (it hap-
pens to be capped at 30 frames per second on the Windows Phone). If you set the Sil-
verlight MaxFrameRate property to a value lower than that or the system can’t keep up,
the tick will happen at a lower rate but will ensure the time remains correct. Figure 7.2
shows an example of the dropped frame approach.
 Figure 7.2 shows a theoretical dropped frame. Both frames 1 and 2 are at their cor-
rect times. What would’ve been frame 3 (timed at 3/60 of a second) was dropped, so
the next presented frame, the new frame 3, picks up at the correct time. This prevents
the undesired effect of slow-running animations or movies.
 After the clock has ticked and all the animations and media element frames have
been incremented, the next step is to call an optional per-frame rendering callback
function.
7.2.2
Per-frame rendering callback
There may be times when you want to perform an action during every frame that’s
rendered on the screen. That may be as simple as keeping a count of frames, swap-
ping a back buffer to simulate an immediate-mode rendering system, or performing
game loop-style operations.
 Silverlight includes the Rendering event on the CompositionTarget class, which is
suitable for these tasks. CompositionTarget.Rendering is an event that fires once per
frame, allowing you to synchronize code with the rendering system.
Figure 7.2
If the machine can’t keep up with the workload, Silverlight will drop frames but will 
ensure that the displayed frames are correctly synchronized with the clock tick.

138
CHAPTER 7
Rendering, layout, and transforming
There’s no guarantee that the callback will happen at the max frame rate. Though it
often does work out this way, many factors, including the amount of work being done
inside the callback and the overall speed of the system, contribute to how often this
runs. You can generally expect the callback to happen once per frame, assuming your
code is well behaved.
 Listing 7.7 shows how to wire up the Rendering event and show the current
timestamp.
public MainPage()
{
  InitializeComponent();
  CompositionTarget.Rendering += new EventHandler(OnRendering);
}
void OnRendering(object sender, EventArgs e)
{
  RenderingEventArgs args = e as RenderingEventArgs; 
  Debug.WriteLine(args.RenderingTime.ToString());
}
Note the cast to RenderingEventArgs. This is unusual and not something you’d intuit
without knowing something about the underlying code. The underlying code is send-
ing an instance of RenderingEventArgs, but the event signature is just regular
EventArgs. By casting to RenderingEventArgs, you gain access to the RenderingTime
property, which you can use to synchronize your logic to Silverlight’s own rendering
process.
NOTE
CompositionTarget.Rendering may not have a 1:1 correspondence
with the actual rendering frame rate. A static scene with no changes, for
instance, may require no actual render, but CompositionTarget.Rendering
will still fire at the expected frame rate.
The event signature uses EventArgs simply for historical reasons. The additional
property was added late during the WPF v1 development cycle, and it was considered
too late to introduce a new event signature—a breaking change. Silverlight strives to
maintain WPF compatibility whenever possible, so the same signature was carried over
to Silverlight.
 You can modify layout inside this callback, but that’ll cause another layout pass to
happen. For that reason, you may want to consider other approaches to avoid the dou-
ble layout tax on each frame. I’ll cover layout in detail in section 7.3. Before I do that,
let’s look at another processing-intense operation in this cycle: rasterization.
7.2.3
Rasterization
Rasterization is the process of turning the vectors in the vector cache into their bit-
map representation. Though not exactly rasterization by that definition, I’ll also
include video and image blitting in this process.
Listing 7.7
Using the per-frame rendering callback
Cast to 
RenderingEventArgs

139
The rendering process
 In this section, I’ll cover the basics of how rasterization works, including the order
of the steps. Then, I’ll look at some optimizations in the process and, finally, dive into
the use of caching and hardware acceleration to improve performance.
 The most fundamental aspect of rasterization that you’ll need to understand is the
order in which elements are rasterized.
ORDER OF RENDERING
As you recall from chapter 2, elements in Silverlight are organized into the visual tree.
This tree has a single root and it branches off into hundreds or thousands of nodes
depending on the complexity of what’s on the screen.
 The structure of that tree is critical to the rendering process. For any branch of the
tree, Silverlight rasterizes elements in the visual tree in the following order:
1
Children 
2
Cache
3
Opacity mask
4
Opacity
5
Effects (intermediate surface)
6
Clip
7
Projection (intermediate surface)
8
Render transform
9
Layout offset (internal layout transform)
10
 Parent node
This is a recursive process; it starts at leaf nodes (the furthest children) and works its
way back to the root.
 Note that the clipping happens after the opacity calculations. One performance
consideration is that a large shape that has opacity other than 1.0 and has only a small
portion shown due to clipping (manual or via a panel) can waste a fair number of CPU
cycles due to the opacity calculation. Similarly, effects are also calculated prior to the
clip and have even more impact on performance.
 The intermediate surfaces mentioned are all bitmap caches that are later compos-
ited together. Note that the Writeable bitmap is a special case because it essentially is
an intermediate surface of its own.
 The rendering process involves a recursive traversal of the visual tree, with optimi-
zations to eliminate branches of the tree that have been cached and haven’t changed.
Another optimization is the handling of occluded pixels.
OCCLUSION
I used to play around with 3D rendering. One of the most basic performance optimi-
zations I’d make is the culling of occluded triangles. When 3D objects are rendered in
2D, the surface is typically broken down into many planar triangles. I’d check to see
whether the normals (the direction the surface faces) for the triangles were pointing
away from me and I was, therefore, looking at the back side of a triangle. If so, I’d

140
CHAPTER 7
Rendering, layout, and transforming
remove the triangle from the pipeline. I’d also check to see if there were any triangles
that were completely covered by other triangles. 
 Consider a complex scene where there’s an opaque wall in front of you (the cam-
era) and a bunch of complex shapes on the other side of the wall, as shown in figure
7.3. In such a scene, the shapes would be occluded by the wall; it’d be wasteful to
include them in the rendering process.
 Occlusion culling in a 3D system can be expensive to calculate. The least perfor-
mant but most accurate approach is to shoot an imaginary ray from the camera to
each and every point in the geometry making up the shapes, and see if the ray must
cross through any other geometry before hitting the target. If it does, then that point
is occluded. That process is known as raytracing.
 Surprisingly, in a 2D system such as Silverlight, where you can have transforms and
effects that play into both the size and shape of elements and as varying degrees of
opacity, occlusion culling is more complicated.
 Silverlight doesn’t handle occlusion culling at the shape level. Instead, it handles it
at the brush pixel level. If you consider that performing blends between multiple pix-
els can be an expensive operation, it makes sense that Silverlight would optimize that
process out of the loop for any pixels that wouldn’t be visible in a frame. 
 This optimization does speed up rendering in most cases. But if you know an ele-
ment won’t be visible on the screen and you either have many elements or that spe-
cific element is expensive to render, you’ll want to set its Visibility property to
Collapsed so that Silverlight doesn’t spend any time on its rendering or layout. Simi-
larly, you need to take into consideration the complexity of any alpha blending you
perform, especially when there could be several layers of pixels in play.
 One way to cut down on the number of layers and also avoid several other render-
ing and layout steps is to cache segments of the visual tree into their own bitmaps. 
CACHED COMPOSITION
Cached composition enables branches of the visual tree to be stored in bitmap form
after the first rendering. (For the web programmers reading this, understand that the
cache is a local in-memory cache on the client.) This bitmap is then used on subse-
quent frames until the elements change. For complex subtrees, cached composition
Figure 7.3
An overhead view of occlusion in a 3D system. 
The shapes are occluded by the wall; the camera can’t see 
them. It’d be wasteful to include their geometry in the 
rendering process. Silverlight does occlusion culling at the 
pixel level rather than the shape level.

141
The rendering process
can realize huge performance benefits. Figure 7.4 helps you visualize how cached
composition works.
 On first render, any elements that have been marked to be cached are rendered as
usual and then the output of that render is stored in the bitmap cache. Listing 7.8
shows how to enable caching for a group of elements in a Grid.
Result:
XAML:
<Grid x:Name="LayoutRoot" Background="White"
      CacheMode="BitmapCache">            
  <Rectangle Height="60" Width="50"
             Fill="Green" />
  <Ellipse Height="30" Width="200" Opacity="0.75"
           Fill="Blue" />
  <Path Stroke="Orange" StrokeThickness="10"
        Height="200" Width="200"
        Data="M 10,80 C 150,5 100,0 200,50 H 100" />
  <Path Stroke="Purple" StrokeThickness="10"
        Height="100" Width="300"
        Data="M 80,10 C 350,5 100,0 100,55" />
</Grid>
Listing 7.8
Caching a group of elements in a Grid
Figure 7.4
Cached composition in 
use. On the first render, or any 
layout change, the cache is updated 
with the result of the render. 
Subsequent frames use the 
prerendered contents of the cache.
CacheMode 
directive

142
CHAPTER 7
Rendering, layout, and transforming
Listing 7.8 shows some Silverlight artwork (suitable for submission to the Freer and
Sackler Galleries, no doubt!) composed of a number of shapes and paths. The paths
here are relatively simple, but more complex artwork may be made of hundreds or
thousands of points. The process of rasterizing complex artwork has a real CPU cost
but, when cached, that cost is one time rather than per frame.
 Section 7.4 discusses render transforms. Render transforms can affect size and ori-
entation of a group of elements. If you apply a render transform to a subtree that has
been cached—for example, to increase its size to 200 percent—you may end up los-
ing the benefit of the cache because Silverlight has to render at the larger size. Luck-
ily, there’s another form of the CacheMode property that enables you to cache the
render at a different size. Listing 7.9 shows how to cache elements at four times their
natural size.
<Grid x:Name="LayoutRoot" Background="White">
  <Path Stroke="Orange" StrokeThickness="10"
        Height="200" Width="200"
        Data="M 10,80 C 150,5 100,0 200,50 H 100" />
  <Path Stroke="Purple" Height="100" Width="300"
        StrokeThickness="10"
        Data="M 80,10 C 350,5 100,0 100,55" />
  <Grid.RenderTransform> 
    <ScaleTransform ScaleX="2" ScaleY="2" />  
  </Grid.RenderTransform>
  <Grid.CacheMode>
    <BitmapCache RenderAtScale="4" />     
  </Grid.CacheMode>
</Grid>
Note that the bitmap cache is set to a 4× render whereas I’m using a 2× transform.
That’s a bit wasteful but certainly is allowed and useful, and you can always scale down
without losing quality. If the RenderAtScale option hadn’t been used, caching
wouldn’t have worked for this subtree of elements.
 Caching the elements as bitmaps allows Silverlight to use hardware acceleration
by keeping those surfaces as textures cached on the video card—assuming sufficient
texture memory and assuming hardware acceleration has been enabled at the plug-in
level. 
ENABLING HARDWARE ACCELERATION FOR THE CACHE
Once a tree of visual elements has been cached, you can take advantage of hardware
acceleration for composting those elements with other layers in the application. In addi-
tion, hardware acceleration can benefit transforms, such as stretching and rotation.
 To use hardware acceleration, you must set the EnableGPUAcceleration plug-in
parameter to true. In chapter 4, we covered how to build the object tag. Here’s the
line for enabling acceleration:
<param name="EnableGPUAcceleration" value="true" />
Listing 7.9
Caching at a size larger than the default (XAML)
2× Scale transform
4× Caching

143
The rendering process
If your application is an out-of-browser application (chapter 5), you can set this via the
OutOfBrowserSettings.EnableGPUAccelerationProperty, typically handled through
the out-of-browser settings dialog. 
 The only time acceleration is required is when using the XNA-based 3D system, cov-
ered in chapters 26 and 27. At other times, hardware (GPU) acceleration can help you
realize real performance gains with 2D. But there can also be times when it’s a net per-
formance drain in your application. The main reason for this is the number of sur-
faces that must be created when hardware caching is used.
 For each bitmap of cached content, Silverlight must then create two additional sur-
faces in video RAM: a surface to hold all content above the cached bitmap and one to
hold the content below it. In an application with a large height/width on a machine
with relatively low video memory (especially all those integrated graphics chips), you
can quickly run out of memory should you try to cache too many separate subtrees.
 When caching, especially when using hardware acceleration, you should endeavor
to create as few bitmap caches as possible, as creating a bitmap cache takes time and
memory. Once you create more bitmap surfaces than will fit in the texture buffer for
your card, you start to lose some of the performance benefits. When using accelera-
tion, you may want to debug how the process is working. For that, you can use the
cache visualization debug settings.
VISUALIZING THE CACHE AND REDRAW REGIONS
When performance is important, one thing that can help is visualizing the bitmap
caches in use in your application. Silverlight provides a setting that draws colored over-
lays on different regions in your UI, indicating which content is or isn’t cached. Cached
content shows up normally; uncached content shows up with a colored overlay.
 Cache visualization is another parameter on the plug-in object described in chap-
ter 4. The parameter is named enableCacheVisualization:
<param name="enableCacheVisualization" value="true"/>
You can also set this value via code, which is essential for debugging out-of-browser
applications. The setting is the EnableCacheVisualization property of the Settings
object: 
Application.Current.Host.Settings.EnableCacheVisualization = true;
In both cases, this is a debug setting, so be sure to turn it off when you move your
application to testing or production environments. The in-code approach allows you
to turn the property on and off via a menu setting or similar approach.
 Similarly, you can visualize redraw regions to see exactly what content Silverlight
must redraw for each frame. Like cache visualization, this is an object tag setting:
<param name="enableRedrawRegions" value="true" />
When you enable this visualization, Silverlight will display redraw regions in a differ-
ent color for each frame, making it obvious what elements are causing which parts of
the interface to be redrawn at runtime. Just as with the other setting, this isn’t

144
CHAPTER 7
Rendering, layout, and transforming
something you want to leave enabled in production. Also with the other settings, this
has a runtime-settable version especially useful for out-of-browser applications:
Application.Current.Host.Settings.EnableRedrawRegions = true;
Between the redraw visualization and the cache visualization, you should have a good
start on debugging any rendering performance issues in your application.
 Rasterization is an important process to understand in Silverlight, especially if
you’re creating an application, such as a game or media player, that’s performance
sensitive. Consider using cached composition and hardware acceleration to help you
out but know the limitations and where the point of diminishing returns lies for your
application.
 The rendering process as a whole has a number of important steps. Of those, the
chief steps to understand are the clock tick, which increments all the animation and
media counters; the per-frame rendering callback, which is useful for game loops and
similar operations; and the rasterization process.
 One other important step I haven’t yet covered is layout. Layout is important
enough to require a more in-depth look than some of the other steps. In fact, of all
of them, I consider layout the most important step for the majority of Silverlight
developers. 
7.3
The layout system
Layout systems across different technologies vary greatly in complexity. Take, for
example, the Windows Forms layout system. Fundamentally, that layout system
involves absolute x- and y-coordinate pairs and an explicit or implicit z-order. Controls
can overlap, get clipped on the edge of the window, or even get obscured completely.
The algorithm is simple—sort by z-order (distance from the viewer) and then blit the
bits to the screen. 
 For another example, you can look to HTML and CSS. HTML and CSS support ele-
ments that must size to content and page constraints (tables, divs), as well as support
absolute positioning, overlapping, and so forth. It’s more of a fluid approach, where
the size and position of one element can affect the size and position of another.
Therefore, the layout system for HTML and CSS is significantly more complex than
that for something like Windows Forms.
 Silverlight and WPF support both types of layout: content that self-sizes based on
constraints, and content that’s simply positioned by way of an x- and y-coordinate pair.
Depending on the container in use, it can even handle laying elements out on curves
or radially from a central point. The complexity that makes that possible deserves a
deeper look.
7.3.1
Multipass layout—measuring and arranging
Layout in Silverlight and WPF involves two primary passes: the measure pass and the
arrange pass. In the measure pass, the layout system asks each element to provide its
dimensions given a provided available size. In the arrange step, the layout system tells

145
The layout system
each element its final size and requests that it lay itself out and also lay out its child ele-
ments. A full run of measuring and arranging is called a layout pass.
 In this section, we’ll go through the layout system in more detail, especially these
two key steps and their implications for performance and design. If you’re curious
about layout or you’ve ever been confused by something like Height and Width versus
ActualHeight and ActualWidth, read on.
THE MEASURE PASS
Whenever elements need to be rendered to screen due to having just been added,
made visible, or changed in size, the layout system is invoked for an asynchronous lay-
out pass. The first step in layout is to measure the elements. On a FrameworkElement,
the measure pass is implemented inside the virtual MeasureOverride function, called
recursively on the visual tree:
protected virtual Size MeasureOverride(Size availableSize)
The availableSize parameter contains the amount of space available for this object
to give to itself and child objects. If the FrameworkElement is to size to whatever con-
tent it has, the availableSize will be double.PositiveInfinity.
 The function returns the size the element requires based on any constraints or
sizes of child objects.
 Note that MeasureOverride isn’t called directly from the layout system: it’s a pro-
tected function. Instead, this function is called from the UIElement’s Measure func-
tion, which, in turn, is called by the layout system.
THE ARRANGE PASS
The second pass of layout is to arrange the elements given their final sizes. On a
FrameworkElement, the Arrange method is implemented inside the virtual Arrange-
Override function, also called recursively:
protected virtual Size ArrangeOverride(Size finalSize)
Height and Width versus ActualHeight and ActualWidth 
If you don’t explicitly set the height and width properties of a control, the ActualHeight
and ActualWidth properties may be zero or not a number (NaN). Why is that? Due
to the asynchronous nature of the layout pass, ActualHeight and ActualWidth might
not be set at any specific point in time from run to run or, more importantly, might
change their values over time as the result of layout operations.
ActualHeight and ActualWidth are set after the rendering pass and may also be
affected by layout rounding settings or content.
In short, check them and, if they’re zero, they haven’t been set. If you want a single
place where you can guarantee they’ll have a value, subscribe to the LayoutUpdated
event on the element and check them there.

146
CHAPTER 7
Rendering, layout, and transforming
The finalSize parameter contains the size (the area within the parent) this object
should use to arrange itself and child objects. The returned size must be the size used
by the element and smaller than the finalSize passed in; larger sizes typically result
in clipping by the parent.
 Similar to the relationship between the measure pass and MeasureOverride,
ArrangeOverride isn’t called directly by the layout system. Instead, the Arrange
method on UIElement is called, which then calls the protected ArrangeOverride
function.
 At the end of the arrange pass, Silverlight has everything it needs to properly posi-
tion and size each element in the tree. But it doesn’t have everything it needs to dis-
play the element because its render position or size could be affected by a render
transform, as covered in the previous section.
LAYOUTUPDATED
Despite the name, the LayoutUpdated event isn’t technically part of the layout pass.
Instead, it’s fired as the last event before an element is ready to accept input. Layout-
Updated is the safe location for inspecting the size and position of the element or oth-
erwise responding to changes in same.
 Don’t do anything in LayoutUpdated that would cause another layout pass. For
example, don’t change the size or position of an element, modify its contents, change
its layout rounding, or otherwise manipulate properties that could change the size of
the element’s bounding box. If you have multiple nested layout passes and they take
longer than the time allowed for that frame, the Silverlight runtime may skip frames
or throw a layout exception. 
7.3.2
The LayoutInformation class
The LayoutInformation class in System.Windows.Controls.Primitives contains a
few methods that are useful to folks implementing their own MeasureOverride and
ArrangeOverride code. Specifically, GetLayoutSlot and GetLayoutClip are helpful
when hosting child elements in a
custom panel.
GETLAYOUTSLOT
Regardless of its actual shape,
each visual element in Silverlight
can be represented by a bound-
ing box or layout slot. This is a
rectangular shape that takes into
account the element’s size and
any margins, padding, or con-
straints in effect. Figure 7.5 shows
the relationship between a layout
slot and the child element hosted
in a panel.
Figure 7.5
The relationship between the layout slot and 
the child element for an element smaller than the slot

147
The layout system
The layout slot is the maximum size to be used when displaying an element. Portions
of the element that fall outside the slot will be clipped. To see the layout slot for an
element, you can call the static function GetLayoutSlot:
public static Rect GetLayoutSlot(FrameworkElement element)
The returned Rect will contain the bounding box or layout slot for that element. This
return value can be valuable when creating a custom panel or when debugging layout
issues.
GETLAYOUTCLIP
Sometimes elements may be larger
than their layout slots, even after
the code in the measuring and
arranging steps has attempted to
fit them. When that happens, you
have a layout clip that represents
the intersection of the child ele-
ment’s size and the layout slot.
 Figure 7.6 shows the relation-
ship between the layout slot, the
child element, and the layout clip
for that child element in an
instance where the child element
is too large for its slot.
 The function GetLayoutClip returns the intersection that represents the layout
clip. In this case, the function returns an actual geometry object, useful for setting the
clip geometry for an element should you need to:
public static Geometry GetLayoutClip(FrameworkElement element)
The returned Geometry contains the intersection or null, if the element wasn’t
clipped. It should be noted that, in WPF, the GetLayoutClip method has a counter-
part by the same name that resides on the UIElement and takes in the slot size and
returns clip geometry.
7.3.3
Performance considerations
Layout is a recursive process; triggering layout on an element will trigger layout for all
the children of that element, and their children, and so on. For that reason, you
should try to avoid triggering layout for large visual trees as much as possible. In addi-
tion, when implementing your own MeasureOverride or ArrangeOverride code,
make sure it’s as efficient as possible.
VIRTUALIZATION
An example of the potential performance problems with recursive layout is large col-
lections of children in controls such as lists and grids. Drawing the elements takes a
certain amount of time but that only happens for elements that are onscreen.
Figure 7.6
The relationship between the layout clip and 
the layout slot for a child element too large for its slot

148
CHAPTER 7
Rendering, layout, and transforming
Creation of the CLR objects representing the items also takes a certain amount of
time. Most importantly for you, the measure and layout passes happen for all chil-
dren, regardless of their potential position on screen or off. Therefore, if you have a
thousand elements in a ListBox, MeasureOverride and ArrangeOverride will be
called for each of them. If those elements contain children (as often is the case with
item templates), you’ll have even more calls in the layout passes.
 One solution to this is virtualization. A subset of the built-in controls (such as the
DataGrid) supports UI virtualization. For those, precreated elements are reused with
new data. The end result is a reduction in the number of in-memory elements, as well
as a reduction of MeasureOverride and ArrangeOverride calls.
SIZING AND POSITIONING
Another performance consideration has to do with sizing and positioning elements. For
example, if you change the margin of an element or modify its width or height, you’ll
trigger a layout pass. If you instead call a render transform to either move or resize that
element, you won’t trigger a pass. I’ll cover render transforms in the next section.
 Understanding the layout system helps take some of the mystery out of what hap-
pens when you size elements in Silverlight and they don’t quite do what you might’ve
expected them to do. It’s also a key concept to understand if you plan to implement
your own panels or container controls.
WPF has the concept of a layout transform. This type of transform is parallel to a
render transform but triggers a layout pass. As you’ve seen here, triggering a layout
pass can be an expensive operation, especially if done inside an animation. For per-
formance considerations and due to their relatively low adoption, layout transforms
were omitted from Silverlight.
 The render transforms provided by Silverlight are almost always adequate to solve
problems you used to solve with layout transforms—and often superior. Let’s look at
them next. 
7.4
Render transforms
The Transform element gives you the flexibility to alter the appearance of any
UIElement within Silverlight. Transforms let you change the size, location, gyration,
and angling apart from the other related properties that have been defined up to this
point. The real value of transforms will become apparent when you learn about anima-
tions in chapter 13. But first, table 7.2 lists the ways UIElement objects can be altered.
Table 7.2
A list of the available transformation options
Transform
Description
RotateTransform 
Rotates an object by a specific Angle
ScaleTransform 
Provides a zoom-in or -out effect by specified amounts
SkewTransform 
Tilts an element by defined amounts
TranslateTransform 
Moves an element by specified amounts

149
Render transforms
As the table shows, each Transform has its own special purpose. As you’ll see in the
next few sections, applying a transformation generally involves altering one or two
basic properties. 
7.4.1
RotateTransform
RotateTransform is responsible for rotating an object clockwise around a specified
point by a specified angle. This rotation affects the local coordinate system of the
rotated object. If you need to rotate an object in place, you must specify the center
point as the center of the object being rotated. Listing 7.10 shows a basic square
rotated clockwise by 30 degrees. The dashed version represents the original square
before the transform was applied.
Result:
XAML:
<Rectangle Width="50" Height="50" Fill="Green" Stroke="Black">
  <Rectangle.RenderTransform>
    <TransformGroup>
      <RotateTransform Angle="30"/>
    </TransformGroup>
  </Rectangle.RenderTransform>
</Rectangle>
The Angle property specifies to rotate clockwise around the optional CenterX and
CenterY properties, which default to 0. Because these values are initially set to 0, an
element will rotate around the upper-left corner. If you set these values to the center
of the object you’re rotating, it’ll give the element the appearance of rotating in place.
 When you are rotating elements, sometimes it becomes necessary to rotate them
counterclockwise. As you may have already guessed, you perform this task by provid-
ing a negative value within the Angle property. Note that an element will complete
one full rotation if the Angle is set to 360 or –360.
TransformGroup
Not a type of transform; rather, a container that groups multiple 
transforms to be applied
CompositeTransform
Provides an easy way to combine the other four transforms
MatrixTransform
Provides a way to use a low-level matrix to perform multiple 
simultaneous transforms
Listing 7.10
A square that has been rotated by 30 degrees
Table 7.2
A list of the available transformation options (continued)
Transform
Description

150
CHAPTER 7
Rendering, layout, and transforming
7.4.2
ScaleTransform
ScaleTransform enables you to expand or contract an object horizontally or verti-
cally, empowering you to create the effect of zooming in or out. Listing 7.11 shows
how a basic square was zoomed in on via a ScaleTransform.
Result:
XAML:
<Rectangle Width="30" Height="30" Fill="Green" 
  Stroke="Black" Canvas.Left="35" Canvas.Top="35">
  <Rectangle.RenderTransform>
    <TransformGroup>
      <ScaleTransform ScaleX="2.5" ScaleY="2.5"/>
    </TransformGroup>
  </Rectangle.RenderTransform>
</Rectangle>
The ScaleX and ScaleY properties determine the magnitude by which to zoom in or
out. As you may expect, the ScaleX property stretches or shrinks the element along
the x-axis. The ScaleY property stretches or shrinks the element along the y-axis. If
you provide the same value in both properties, the object will expand or contract pro-
portionally.
 You may have also noticed that Rectangle expands from the upper-left corner.
This is because the CenterX  and CenterY properties determine the point from
where the scale operation should take place. By default, these values are set to 0.
7.4.3
SkewTransform
A SkewTransform warps the coordinate space in a divergent manner. By skewing or
shearing an element, you basically slant the element in a direction. Listing 7.12 illus-
trates a basic square skewed by 18 degrees on both the x- and y-axes.
Result:
XAML:
<Rectangle Width="75" Height="75" Fill="Green" 
  Stroke="Black" Canvas.Left="12" Canvas.Top="12">
Listing 7.11
A square that has been scaled by a magnitude of 2.5
Listing 7.12
A Rectangle that’s been skewed by 18 degrees

151
Render transforms
  <Rectangle.RenderTransform>
    <TransformGroup>
      <SkewTransform AngleX="18" AngleY="18"/>
    </TransformGroup>
  </Rectangle.RenderTransform>
</Rectangle>
The AngleX  and AngleY properties specify the amount to shear the rectangle horizon-
tally and vertically. Much like the other transforms you’ve seen, the SkewTransform
also exposes CenterX and CenterY  properties to specify the horizontal and vertical
origin of the skew rendering.
7.4.4
TranslateTransform
The TranslateTransform element allows you to define how to transfer an element
from one location to another. Listing 7.13 shows a square translated by 25 pixels verti-
cally and horizontally. 
Result:
XAML:
<Rectangle Width="50" Height="50" Fill="Green" Stroke="Black">
  <Rectangle.RenderTransform>
    <TransformGroup>
      <TranslateTransform X="25" Y="25"/>
    </TransformGroup>
  </Rectangle.RenderTransform>
</Rectangle>
As this listing demonstrates, by specifying a double-precision floating-point value within
the X and Y properties of a TranslateTransform, you can move a visual element hori-
zontally or vertically. As you can imagine, TranslateTransform and the other trans-
forms mentioned give you a lot of flexibility with your visual elements. These transforms
can be used to provide even more radical changes when you group them.
7.4.5
TransformGroup
In the previous transform-related examples, you may have noticed the TransformGroup
element. This element wasn’t required when there was only one applied transform. But
it’s usually a good idea to include it if there’s any chance you’ll be adding additional
transformations and you aren’t using the new CompositeTransform described in the
next section. The TransformGroup element makes it possible to simultaneously define
multiple transformations on a visual element in any arbitrary order.
Listing 7.13
A basic translation in action

152
CHAPTER 7
Rendering, layout, and transforming
 Up to this point, you’ve primarily used a Rectangle as the visual element for trans-
formations, but you can also apply these interesting renderings to any UIElement. You
can apply these transformations to items such as TextBox elements, Buttons, the
MediaElement, and so many more that you’ll need to refer to the Silverlight SDK to
see. For the sake of illustration, all the primary transforms that have been discussed
are applied to the TextBox shown in listing 7.14; note how the TextBox is still active.
Result:
XAML:
<TextBox x:Name="myTextBox" Text="Ben and Abby" 
         Height="25" Width="100">
  <TextBox.RenderTransform>
    <TransformGroup>
      <ScaleTransform ScaleX="2" ScaleY="2" />
      <SkewTransform AngleX="10" AngleY="10" />
      <RotateTransform Angle="15" />
      <TranslateTransform X="10" Y="10" />
    </TransformGroup>
  </TextBox.RenderTransform>
</TextBox>
Although the use of transforms in this example is a bit over the top, it does accurately
display the true flexibility provided by the transform elements.
7.4.6
CompositeTransform
Introduced in Silverlight 4, the CompositeTransform element applies the four built-in
render transforms using a single statement. Though a TransformGroup with all four
transforms is still supported, you’ll find this approach generally easier to use. The
CompositeTransform applies the transforms in the following order:
1
Scale
2
Skew
3
Rotate
4
Translate
That’s the order generally recommended for transformation. If you play with trans-
forms much, you’ll quickly find out that the order has a real impact on the final result.
The transforms themselves are equivalent to the same individual transforms applied
Listing 7.14
Four transforms on a TextBox

153
Render transforms
using a TransformGroup. Listing 7.15 shows the same example from listing 7.14 but
now implemented via a CompositeTransform.
Result:
XAML:
<TextBox x:Name="myTextBox" Text="Ben and Abby"
         Height="25" Width="100">
  <TextBox.RenderTransform>
    <CompositeTransform ScaleX="2" ScaleY="2"
                        SkewX="10" SkewY="10"
                        TranslateX="10" TranslateY="10"
                        Rotation="15" />
  </TextBox.RenderTransform>
</TextBox>
As you’d expect, the result is the same as the previous listing. But now the code is
arguably easier to read, contains four fewer elements (three fewer transforms and no
transform group), and is slightly more efficient due to the use of a single set of trans-
formation matrices multiplied together in a single function.
 Once all the tooling switches over to using this approach, it’ll be much simpler to
animate transforms without having to remember lengthy and error-prone property
paths for the nested transform elements.
 With that said, you had the ability to do all of this in previous versions of Silverlight
using the MatrixTransform class.
7.4.7
MatrixTransform
MatrixTransform is a powerful class that’s rarely used in Silverlight applications. Why?
Because the idea of matrix math is, to many, something new. But all the other trans-
forms use matrix math behind the covers; it’s just nicely shielded behind friendly
property names.
 The Silverlight transformation matrix is a 3 × 3 affine transformation row-major
matrix. The size is three rows by three columns. Affine means that the edges all need
to stay the same length (proportionally) as they originally were. All points on a single
line in the original shape will remain in a single line in the resulting transformed
shape. You can’t do a true perspective transform in an affine matrix or other trans-
form that would violate this. Row major means the vectors are expressed as rows and
not columns.
Listing 7.15
The same four transforms on a TextBox using a CompositeTransform

154
CHAPTER 7
Rendering, layout, and transforming
 As a result of the affine nature and row-major approach, the last column of the
matrix will always contain the rows “0,0,1.” Here’s what the structure looks like,
including the default values:   
To perform a translate transform that moves the shape 10 pixels in the positive x-axis
and 20 pixels in the positive y-axis, you’d supply 10 for OffsetX and 20 for OffsetY. 
 To increase the x scale of the target, provide a value larger than 1.0 to the M11
property. Similarly, to increase the y scale, provide a value larger than 1.0 to the M22
property. Values smaller than 1.0 will shrink the size.
 You can skew the target in the x direction using M21. A value of 1.0 will skew it 100
percent. Similarly, you can skew the target in the y direction using M12.
 To rotate, you’d need to plug in the sine and cosine values into M11, M12, M21,
and M22. For example, to rotate by 15 degrees, the matrix would look like this:
Listing 7.16 shows the hard-coded values for a rotation of 15 degrees plus an offset of
100 pixels in the x-axis and 20 pixels on the y-axis.
Result:
XAML:
<TextBox x:Name="myTextBox" Text="Ben and Abby"
         Height="25" Width="100">
  <TextBox.RenderTransform>
    <MatrixTransform>
      <MatrixTransform.Matrix>
        <Matrix M11="0.96592583"       
1
2
3
1
M11 (1.0)
M12 (0.0)
0
2
M21 (0.0)
M22 (1.0)
0
3
OffsetX (0.0)
OffsetY (0.0)
1
1
2
3
1
M11 (Cos(15))
M12 (Sin(15))
0
2
M21 (-Sin(15))
M22 (Cos(15))
0
3
OffsetX (0.0)
OffsetY (0.0)
1
Listing 7.16
Rotation and translation using a Matrix
Cos(15)

155
3D projection transforms
                M12="0.25881905"    
                M21="-0.25881905" 
                M22="0.96592583" 
                OffsetX="100"
                OffsetY="20" />
      </MatrixTransform.Matrix>
    </MatrixTransform>
  </TextBox.RenderTransform>
</TextBox>
One nice thing you can do with MatrixTransform is perform multiple transforma-
tions in a single step. Prior to the introduction of slightly friendlier Composite-
Transform, the MatrixTransform was the only way to reduce the number of transform
elements while doing a multistep transform. If you need to control the order of those
transformations, you can multiply two or more matrices in code.
 Render transforms are a powerful way to manipulate the display of your elements.
You’ll find transforms essential in animation, both to provide gross-level movement
and to provide more subtle effects such as a pop when you click a button. They’re also
helpful in that they don’t force a layout pass to happen, as would be the case if you
animated something like the actual Width and Height of the element.
 One thing none of the transformations can do, though, is a nonaffine transform
such as a perspective effect. For that, you need to turn to 3D projection. 
7.5
3D projection transforms
3D projection transforms, introduced in Silverlight 3, provide a way to do nonaffine
(perspective and distortion) transforms on an object. The UI elements to which the
transforms are applied remain active and available, just as with render transforms.
 Like render transforms, projections don’t affect layout; they’re a render-time trans-
formation that exists outside the layout pass. In addition, this projection is not to be
confused with the full 3D API introduced in Silverlight 5.
 You’ll start with the PlaneProjection, the easiest and most popular of the two
types of projections, and then explore the somewhat more obscure, but extremely
powerful, Matrix3dProjection.
7.5.1
PlaneProjection
Plane projection (System.Windows.Media.PlaneProjection), introduced in Silver-
light 3, was one of the most anticipated features to make it into the product. Although
using it now will likely earn you a whack in the back of the head from some hipster, at
the time of Silverlight 3, the CoverFlow effect from iTunes was all the rage. You could
simulate it using skew transforms and stitching of images but the result was never
quite right.
PlaneProjection has several key properties, as described in table 7.3. You may
wonder why it exposes denormalized properties instead of three 3D point structures.
 Sin(15)
Sin(15)
Cos(15)

156
CHAPTER 7
Rendering, layout, and transforming
The reason is binding and animation: when you provide the individual properties as
DependencyProperty properties, they can be used in binding and animation. 
For each of the properties, the screen axes are defined as shown in figure 7.7. Positive
y is vertical top, positive x is horizontal right. Silverlight, at least in the case of the
PlaneProjection, follows a right-hand coordinate system, so positive z is closer to you,
and negative z is further “into” the screen.
 Both the PlaneProjection and its related Matrix3dProjection are assigned to an
object via its Projection property.
Table 7.3
PlaneProjection properties
Property
Description
RotationX, RotationY, 
RotationZ
These represent the overall rotation of the object, in degrees for each 
axis.
CenterOfRotationX, 
CenterOfRotationY, 
CenterOfRotationZ
These represent the object-oriented center of rotation. 0.5, 0.5 is the 
center of the plane on that axis and is the default value.
GlobalOffsetX, 
GlobalOffsetY, 
GlobalOffsetZ
These values translate the object along the specified axis, providing for 
motion in 3D space. The values are relative to the screen. So the y-axis 
will always be vertical and point up, and the x-axis will always be horizon-
tal and point to the right.
LocalOffsetX, 
LocalOffsetY, 
LocalOffsetZ
Unlike the GlobalOffset values, these values translate on an object-
relative axis. So, if the object was already rotated 20 degrees to the left, 
the positive y-axis would point 20 degrees to the left and the positive x-
axis would point 70 degrees to the right. The values of RotationX, 
RotationY, and RotationZ directly impact how LocalOffsetX, 
LocalOffsetY, and LocalOffsetZ, respectively, are interpreted.
Figure 7.7
The x-, y-, and z-axes as recognized by 
the PlaneProjection element

157
3D projection transforms
 Listing 7.17 shows a simple PlaneProjection applied to a set of UI elements. In
this case, the projection is on the y-axis, giving you that classic CoverFlow look but
applied to live input controls. 
Result:
XAML:
<Grid Width="200" Height="175">
  <Rectangle Fill="#FFe0e0c0" Stroke="#FF000000" StrokeThickness="3"
             RadiusY="10" RadiusX="10" />
  <StackPanel Margin="10">
    <TextBlock Text="Pete, Melissa, Ben, Abby" Margin="5" />
    <TextBox Text="Silverlight" Margin="5" />
    <TextBox Text="In Action" Margin="5" />
    <Button Content="I’m a Button!" Margin="5" />
  </StackPanel>
    
  <Grid.Projection>
    <PlaneProjection RotationY="-45" />       
  </Grid.Projection>
    
</Grid>
In most designers, you won’t see the transform until runtime. On the design surface,
it will appear normal. 
7.5.2
Matrix3dProjection
As with 2D affine transforms, Silverlight also supports a lower-level Matrix transform
for 3D. The class is named System.Windows.Media.Matrix3dProjection. 
 Due to the complexity of explaining 4 × 4 nonaffine matrices, and the relatively
small subset of readers who’ll be interested in that, I’ll leave the fine details of 3D
matrix projections out. But let’s look at a simple code example to get you started.
 Listing 7.18 shows how to do something that isn’t provided just by 3D rotation on
an axis. This combines skew effects with rotation to come up with something that can
only be described as interesting.
Listing 7.17
Simple perspective effect on a Grid containing multiple elements
PlaneProjection

158
CHAPTER 7
Rendering, layout, and transforming
Result:
XAML:
<Grid Width="200" Height="175">
  <Rectangle Fill="#FFe0e0c0" Stroke="#FF000000" StrokeThickness="3"
             RadiusY="10" RadiusX="10" />
  <StackPanel Margin="10">
    <TextBlock Text="Pete, Melissa, Ben, Abby" Margin="5" />
    <TextBox Text="Silverlight" Margin="5" />
    <TextBox Text="In Action" Margin="5" />
    <Button Content="I’m a Button!" Margin="5" />
  </StackPanel>
  <Grid.Projection>
    <Matrix3DProjection>                        
      <Matrix3DProjection.ProjectionMatrix>
        <Matrix3D M11="0.4269" M12="0.0592"  M13="0.0" M14="-0.0012"
                  M21="-0.3600" M22="1.0548" M23="0.0" M24="-0.0028"
                  M31="0.0" M32="0.0" M33="1.0" M34="0.0"
                  OffsetX="9.0" OffsetY="-117.0" OffsetZ="0"
                  M44="1.0" />
      </Matrix3DProjection.ProjectionMatrix>
    </Matrix3DProjection>
  </Grid.Projection>
</Grid>
Matrix3dProjection is something you may only ever use once, but for that one time,
it’ll be exactly what you need to solve a specific problem. The sky’s the limit when it
comes to 3D transformations for your Silverlight applications.
 One thing you may have noticed with the projection transforms is that they add
some fuzziness to the elements when they render. That’s because the render trans-
forms operate on frame-by-frame bitmap representations of the objects. That makes
them extremely performant, but also causes them to have a slight degradation in qual-
ity, especially when you do something such as an extreme z scale, as in the
Matrix3dProjection example.
 Silverlight provides two easy-to-use but powerful ways to transform objects in 3D
space: PlaneProjection and Matrix3dProjection. PlaneProjection, in particular,
will find its way into a lot of your applications. In fact, if you develop for Silverlight for
Listing 7.18
Mangling elements using a Matrix3DProjection
Matrix3dProjection

159
Summary
the Windows Phone, you’ll find the PlaneProjection indispensable for providing the
expected page flip UI transitions.
 In the last two examples, you used a combination of Grids and StackPanels to
hold the elements you were transforming. Both of these are types of Panels and will
be something you use over and over again in your own applications. 
7.6
Summary
The basis for all onscreen elements is the FrameworkElement and UIElement pair. The
two define the majority of the commonly used properties and methods for other ele-
ments. In addition, they define the abstract methods for measuring and layout, the
core of the layout system.
 Framework elements, UI elements, and panels are the fundamental players in the
layout system. Layout in Silverlight is so flexible because so much of the measurement
and layout is delegated to the elements themselves. An understanding of the layout
system is important for both performance and flexibility reasons and is a must should
you wish to create your own panels.
 The layout system is a major part of a much larger rendering system. The render-
ing system in Silverlight does a good job at optimizing the elements onscreen for effi-
cient rendering, but also provides appropriate places where you can tune that process
to fit your own applications. Silverlight enables you to cache elements, for example,
and even to control whether cached elements are cached to hardware surfaces on a
compatible video card.
 Render transformations allow you to transform the location, rotation, skew, or size
of any visible element without incurring the performance hit of a layout system pass.
For that reason, they’re perfectly suited to animation and more performance-hungry
uses. What render transformations lack is support for nonaffine or perspective trans-
forms.
 The two types of 3D projections pick up where render transforms leave off, and
provide support for nonaffine, perspective, and distorting 3D transformations.
PlaneProjection is the easiest to use and suitable for most types of basic projection
work. Matrix3dProjection is a little harder to use but is extremely powerful. If you
want to do basic CoverFlow-style work, PlaneProjection is for you. If you want to do a
more immersive 3D experience with floating panels zipping past you and appearing
off in the distance, you’re probably looking at the Matrix3dProjection class and
some of its helper libraries on www.codeplex.com.
 With framework and UI elements, the rendering and layout system, transforma-
tions, and projections under your belt, you’re ready to move on to the fundamentals
of working with layout panels. Panels form the root elements for most of your inter-
faces and are the main elements responsible for layout in Silverlight.

160
Panels
Panels in Silverlight provide a way to host multiple elements and provide unique
layout logic. For example, you may want a panel that lays out elements so they
appear to radiate out of a central point (think of the wheel on Wheel of Fortune).
Rather than provide each and every control with the knowledge required to per-
form that layout, Silverlight leaves it to the panel.
 This delegation to panels and the layout system is why you won’t see Left and
Top properties on UI elements—those properties are provided by the panels in the
form of attached properties (see section 2.1.5 for more information on attached
properties).
 In typical use, any control you place in the UI in Silverlight is going to be hosted
in a panel at some level. Understanding how the different panels work is essential
to making the most of Silverlight’s UI capabilities.
 Though numerous types of panels are available, the four most important and
widely used are Canvas, StackPanel, WrapPanel, and Grid. Of them, Grid, the most
This chapter covers
■
Using absolute layout with the Canvas
■
Stacking items with the StackPanel
■
Wrapping items with the WrapPanel
■
Using the Grid for cell-based layout 

161
Canvas
widely used and most flexible of the panels, and also the default for UserControl and
Page templates, is arguably the most important panel to understand.
 I’ll start with the simplest panel, Canvas, then move on to panels that provide more
layout functionality. The StackPanel forms the basis of most list and menu implemen-
tations but is still relatively simple in its layout and functionality. WrapPanel is similar
to StackPanel but provides automatic wrapping of its child elements. Grid, the final
panel in this section, is typically the root of your interfaces and is one of the most pow-
erful, flexible, and complex panels available.
8.1
Canvas
Envision a painter inspired to recreate a mountainous landscape. As you can imagine,
a tremendous amount of artistic freedom is required to adequately mimic this majes-
tic view. Painters have the luxury of a conventional canvas, which gives them free rein
over their illustrations. Unfortunately, traditional web technologies can occasionally
be overly rigid, imprisoning you and making it difficult to deliver awe-inspiring con-
tent over the internet.
 Thankfully, in addition to being the highest-performing and lightest-weight layout
panel, the Canvas element gives you the same type of freedom that painters have long
taken for granted. This Panel allows you to say, “I want this element at this exact loca-
tion,” and accomplish that. Before I discuss the details of Canvas, let’s look at the basic
syntax of a Canvas, as shown here:
<Canvas Height="200" Width="300" Background="White">
</Canvas>
This bit of XAML shows an empty Canvas with a white background. To show some-
thing contained within the canvas, you need to add content, such as a basic block of
text, as seen here:
<Canvas>
  <TextBlock Text="Hello, Silverlight" />
</Canvas>
This shows a basic Canvas with a small amount of content: a single TextBlock. The
content of a Canvas consists of elements inside the Canvas. These child elements are
added to a collection, called Children, which is accessible from code. Each item in
this collection derives from the UIElement type described in section 7.1. I’ll use a
UIElement called TextBlockto show you how to arrange content within a Canvas.
Canvas performance
As described in section 7.3 on the layout system, the process of determining where
elements are positioned can be quite involved. As each element is added to its con-
tainer, Silverlight must perform layout calculations. The number of calculations is usu-
ally based on the requirements placed on an element by its ancestors and by siblings

162
CHAPTER 8
Panels
You can arrange the content within a Canvas by using one of two approaches. The first
approach involves setting the vertical and/or horizontal offsets of an element within a
Canvas. The other method revolves around setting the stack order of an element
within a Canvas. These methods can be used in combination for full control over how
each piece of content is shown. Let’s take it one step at a time and investigate how to
set an element’s offsets.
8.1.1
Setting the offsets
By default, the content within a Canvas is automatically arranged at 0,0. This
approach places all of the content in the upper-left corner of a Canvas. To move con-
tent out of this corner, you must take advantage of two attached properties—Left and
Top—which are shown here: 
<TextBlock x:Name="tb" Text="Hello" Canvas.Left="20" Canvas.Top="30" />
This TextBlock uses the Left and Top attached properties to set its position within an
imaginary Canvas. The Left property specifies the distance, in pixels, from the left
edge of the TextBlock element to the left edge of the parent Canvas. Likewise, the
Top property sets the number of pixels between the top edge of the parent Canvas and
the top edge of the TextBlock. This specific sample places the TextBlock 20 pixels
from the left and 30 pixels from the top of a parent Canvas. Alternatively, you may
need to set these values at runtime.
 To set the position of an element within a Canvas at runtime, you must do so pro-
grammatically. The Canvas element exposes two statically visible methods that enable
you to set an element’s position at runtime. There are also two other methods—illus-
trated here using the TextBlock from the previous example—that enable you to
retrieve an element’s position at runtime:
double newLeft = Canvas.GetLeft(tb) + 15.0; 
Canvas.SetLeft(tb, newLeft);
double newTop = Canvas.GetTop(tb) + 30.5; 
Canvas.SetTop(tb, newTop);              
This example shows how the GetLeft and SetLeft methods are used to move a Text-
Block 15 pixels to the right. Alternatively, you could’ve subtracted a value to move the
TextBlock to the left. This example also moves a TextBlock down by 30.5 pixels using
(continued)
in the same container. In general, as the number of relative elements grows, so does
the number of necessary calculations.
Because of its explicit nature and minimal layout requirements, Canvas can minimize
the number of necessary calculations, providing a potentially important performance
boost for applications with many onscreen elements. To realize this performance gain,
you’d need to have thousands or tens of thousands of visible elements on the screen.

163
Canvas
the GetTop and SetTop methods. In a similar approach, you could’ve subtracted a
value to move the TextBlock up. Either way, it’s important to note that you could’ve
passed any UIElement to this method in place of the TextBlock.
Any time you set the location of an element, you must use a double value. This double-
precision value represents a specific number of pixels. If you aren’t careful, you may
inadvertently overlap the content within a Canvas. Although this overlapping effect can
occasionally be desirable, it’s still useful to know how to set the stacking order.
8.1.2
Setting the stack order
By default, when content is rendered within a layout panel, each element is rendered
on its own imaginary layer. This ensures that the last element in a layout panel is
shown on top of all the others. The other elements are still present; they’re just over-
drawn by the overlapping content, as shown in listing 8.1.
Result:
XAML:
<Canvas Width="180" Height="180" >        
  <Canvas Width="60"    
          Height="60" 
          Background="LightGray"/>
  <Canvas Width="60"            
          Height="60"
          Canvas.Left="20" 
          Canvas.Top="20" 
          Background="Gray" />        
  <Canvas Width="60"             
          Height="60"
Wait…30.5 pixels?
Silverlight’s rendering and layout system support subpixel layout and rendering. This
allows you to specify fractions of pixels and allow Silverlight to create the appropriate
display. For example, if you have a white canvas with a black vertical line located halfway
between two pixels—a width of one pixel at position 30.5, for example—Silverlight will
show two gray lines side by side (the average of white and black) in order to produce the
illusion of a line at the fractional offset. The end result can be described as fuzzy or blurry
and is often something you want to avoid. To have exact pixel snapping and crisp lines,
set the UseLayoutRounding property of the panel or control you want snapped.
Listing 8.1
Natural stacking order
Background 
canvas
Middle 
canvas
Foreground 
canvas

164
CHAPTER 8
Panels
          Canvas.Left="40" 
          Canvas.Top="40" 
          Background="Black"/>
</Canvas>
Listing 8.1 shows the natural stacking approach used when rendering overlapping
content. The content overlaps in this orderly fashion because, by default, its ZIndex
(or stacking position) is set to 0.
TIP
Even though Canvas.ZIndex is an attached property on the Canvas type,
it works within other panels such as the grid, even if there’s no canvas present
anywhere in the visual tree. Note that ZIndex is relative only to the panel and
not to the application as a whole.
You can change the ZIndex value to a value greater than 0 to move the Canvas further
into the foreground, as shown in listing 8.2. The element will be placed on top of the
elements that have a smaller ZIndex within the same panel.
Result:
XAML:
<Canvas x:Name="myCanvas">
  <Canvas Canvas.ZIndex="2"        
          Width="60" Height="60"
          Background="LightGray"/>
  <Canvas Canvas.ZIndex="1"          
          Width="60" Height="60" 
          Canvas.Left="20" Canvas.Top="20" 
          Background="Gray" />
  <Canvas Width="60" Height="60"     
          Canvas.Left="40" Canvas.Top="40" 
          Background="Black"/>
</Canvas>
This short example shows how to move an element further into the foreground of a
Canvas. You add a value to the integer value represented by the ZIndex. Alternatively,
you could’ve moved the element somewhere into the background by subtracting a
value. Either way, the Canvas gives you the ability to set the stack order and offsets to
your liking. In addition, the Canvas provides some performance features that really
pack a punch. 
TIP
Playing around with ZIndex can get frustrating and difficult to track
once you have several overlapping panels, each with elements with specific
ZIndex values. Whenever possible, arrange your elements so they make sense
Listing 8.2
Changing the stacking order using ZIndex
Foreground 
canvas
Middle 
canvas
Background
canvas

165
The StackPanel
in the natural order. In addition, try not to animate ZIndex because the Sil-
verlight runtime rearranges the visual tree to get the required z positioning.
This can be a real performance drain.
8.2
The StackPanel
The StackPanel is a panel that arranges items either vertically or horizontally one
after the other. Elements in a StackPanel are given as much room as they need, and
no more. If you consider a ListBox, for example, the elements are arranged in a verti-
cal list, with each element having enough room to display itself (which can differ from
element to element in the same StackPanel); the elements don’t overlap. 
 By default, the ListBox uses a StackPanel control for the arrangement of those
items. Many other controls benefit from this simple layout technique, especially vari-
ous types of menus and navigation elements.
 Listing 8.3 shows a simple StackPanel with three items positioned vertically.
Result:
XAML:
<StackPanel>
  <Canvas Width="90" Height="30" Background="Red"/>
  <Canvas Width="90" Height="30" Background="Green"/>
  <Canvas Width="90" Height="30" Background="Blue"/>
</StackPanel>
As shown in the listing, elements within a StackPanel are rendered one after another
from top to bottom. The StackPanel exposes an Orientation property, which allows
you to specify whether child elements are stacked in a Vertical or a Horizontal man-
ner, as shown in listing 8.4.
Result:
XAML:
<StackPanel Orientation="Horizontal">
  <Canvas Width="90" Height="30" Background="Red"/>
  <Canvas Width="90" Height="30" Background="Green"/>
  <Canvas Width="90" Height="30" Background="Blue"/>
</StackPanel>
Listing 8.3
The StackPanel in vertical mode
Listing 8.4
The StackPanel in horizontal mode

166
CHAPTER 8
Panels
As you can see, shifting the layout from a vertical to horizontal orientation is as simple
as including a single property. In addition, layout panels of any type can be nested
within one another to fully dictate an application’s arrangement.
 The StackPanel is a great panel, but it lacks the ability to move elements that
would otherwise appear off-screen due to the number of elements contained in the
StackPanel. The ListBox handles this by placing the StackPanel into a Scroll-
Viewer, enabling vertical and/or horizontal scrolling. Another way to handle this
would be to have the ListBox use a WrapPanel, so you can have multiple columns of
elements.
8.3
The WrapPanel
If you’ve ever viewed Windows Explorer in any mode other than details (for example,
Icons or Large Icons), you’ve viewed WrapPanel-like functionality. Take a moment
now and open Windows Explorer and look at a folder with more than a few items in it.
The pictures library might be a good place. Figure 8.1 shows what mine looks like.
 Windows Explorer automatically arranges a large number of thumbnail images
using rows and columns—a common approach, especially when viewing images. If
you were to use a StackPanel, you’d have only one row or column. If you were using a
Grid (covered later in this chapter), you’d need to know the number of rows and col-
umns in advance, and moving items around might be a bit more difficult. What this
calls for is a solution that’ll dynamically adjust to the size of the items and the available
space—a WrapPanel.
Figure 8.1
Windows Explorer 
using WrapPanel-like 
functionality 
to display images

167
The WrapPanel
Unlike the other panels described so far, the WrapPanel isn’t in the core Silverlight
runtime. Instead, it’s located in the Silverlight toolkit (http://silverlight.codeplex
.com), released as an extra control.
 Much like StackPanel, WrapPanel orders elements based on the order they were
added to the Children collection. Also like StackPanel, WrapPanel supports arrange-
ment horizontally or vertically.
8.3.1
Vertical wrapping
A WrapPanel with the Orientation property set to Vertical will wrap elements by col-
umns. That is, the first element will be at the top, the second right below it, the third
below that, and so forth until it reaches the end of the vertical space. Then it’ll start
back over in the next column with the next element at the top.
 Figure 8.2 shows an example of a WrapPanel with seven elements, displayed using
the vertical wrapping option.
 Items in a WrapPanel don’t need to be the same size. The panel will intelligently
adjust the space required based on the orientation used. In figure 8.3 you can see that
the elements are laid out vertically and that each column takes up a fixed width but
that there are no discernible rows.
 If the orientation is changed to Horizontal, you’ll be able to discern rows but not
columns. If you wish to have a nice, even layout, adjust the elements so they have con-
sistent width and height, or have margins around the elements to account for the
differences.
1
2
3
4
5
6
7
Figure 8.2
A WrapPanel with the Orientation property set to Vertical. 
The numbers indicate the order in which the elements were added.
Figure 8.3
A vertical WrapPanel with 
elements of differing sizes

168
CHAPTER 8
Panels
Listing 8.5 shows the markup required to create a vertical orientation WrapPanel,
minus the number annotation. The easiest way to get the toolkit namespace added is
to drag the WrapPanel control from the Visual Studio toolbox on the left onto the
design surface or XAML editor.
<toolkit:WrapPanel Margin="12"
                   Orientation="Vertical">   
  <Rectangle Margin="5"
             StrokeThickness="3" 
             Stroke="Black" 
             Width="100" Height="100"/>
  <Rectangle Margin="5" StrokeThickness="3" Stroke="Black"
             Width="100" Height="100" />
  <Rectangle Margin="5" StrokeThickness="3" Stroke="Black"
             Width="100" Height="100" />
  <Rectangle Margin="5" StrokeThickness="3" Stroke="Black"
             Width="100" Height="100" />
  <Rectangle Margin="5" StrokeThickness="3" Stroke="Black"
             Width="100" Height="100" />
  <Rectangle Margin="5" StrokeThickness="3" Stroke="Black"
             Width="100" Height="100" />
  <Rectangle Margin="5" StrokeThickness="3" Stroke="Black"
             Width="100" Height="100" />
</toolkit:WrapPanel>
Be sure to resize the height of the page containing this WrapPanel to see it wrap to the
next column. The key property shown in this listing is the Orientation property. If
you wish to lay out the elements horizontally, change this property to Horizontal. 
8.3.2
Horizontal wrapping
It’s easy to change the behavior of the WrapPanel to lay out items horizontally rather
than vertically. All that you need to do is change the Orientation property. The Wrap-
Panel in listing 8.5 could be changed like this:
<toolkit:WrapPanel Margin="12" Orientation="Horizontal">
As you’d expect, the items are now laid out from left to right, top to bottom. Figure
8.4 shows what the same panel looks like with the horizontal orientation.
Listing 8.5
A vertical orientation WrapPanel
Orientation
1
4
7
2
5
6
3
Figure 8.4
The WrapPanel from figure 8.3 now using horizontal 
orientation. Items are laid out left to right, top to bottom.

169
The Grid
The WrapPanel is a nice improvement over the base StackPanel, providing better use
of onscreen real estate, with automatic wrapping of elements of homogenous or het-
erogeneous size.
 Nesting layout panels is incredibly important when you begin to consider the
entire scope of an application. Although the StackPanel is great for one-dimensional
(vertical or horizontal) content and the WrapPanel is good for the same but wrapping
in columns or rows, neither is suited for organizing large amounts of elements in a
precise way. Consider the illustration in figure 8.5.
 Imagine attempting to recreate the purchase order shown in figure 8.6 using a
series of StackPanel or WrapPanel elements. Up front, you’d have to decide if you
want to create vertical or horizontal elements. Then, you’d have to specify the Width
of each StackPanel because StackPanel elements are arranged and sized indepen-
dently of each other. There has to be a better way to organize tabular data. Thankfully,
Silverlight provides the powerful Grid panel to do just that. 
8.4
The Grid
Of all the layout panels, the Grid is the one you’re likely to use the most. It’s the
default root layout element for all the UserControl and Page templates, and is the
one control that allows you to easily resize (not rescale) content to take up the space
available to the plug-in.
NOTE
The Grid is not to be confused with The Grid from Tron, which is what
I hear in my head every time I read “The Grid”: “The Grid. I tried to imagine
data in a purchase order, more beautiful than I ever dreamed…”
Though the Grid is similar to an HTML table element, it expands on a number of fea-
tures, such as proportional and absolute row and column sizing, the ability to have any
Figure 8.5
A basic purchase order, using tabular layout. This would be perfect for a Grid.

170
CHAPTER 8
Panels
row or column be the one that takes up all the available space, gracefully handling col-
umn and row spanning, and an easily consumed API for manipulating rows and col-
umns at runtime. 
 Throughout the remaining sections, you’ll take a deep look at the Grid, starting
with the basics of how to position content in rows and columns. From there, you’ll
work on cell spanning and sizing of Grid cells. Up until that point, you’ll primarily be
working with XAML. For that reason, I’ll explain what’s required to build and manipu-
late the Grid from code. Finally, I’ll cover using the splitter to allow the end user to
resize Grid columns and rows.
 The Grid panel gives you the ability to easily lay out content in a tabular format.
This tabular format is similar to the table element in HTML, but the table element
can occasionally be difficult to work with during development. For instance, it can be
challenging to determine how many rows or columns exist in a table while coding. To
help overcome this challenge, the Grid in Silverlight defines its rows and columns in
two distinct collections. Appropriately, these collections are called Column-
Definitions and RowDefinitions.
8.4.1
Arranging Grid content
The RowDefinitions collection stores the definitions of the rows of a Grid. Each row
is set through an element called RowDefinition. This element is primarily responsi-
ble for defining the dimensions of a single horizontal row. Similarly, the Grid also
enables you to create a ColumnDefinition element. This element must be defined
within the ColumnDefinitions collection. As you’d expect, this element generally sets
the dimensions of a vertical column within a Grid. By default, you don’t have to set
these dimensions, as shown in listing 8.6.
Result:
XAML:
<Grid x:Name="myGrid" ShowGridLines="True"
  Height="120" Width="120" Background="LightGray">
  <Grid.ColumnDefinitions>
    <ColumnDefinition />      
    <ColumnDefinition />      
    <ColumnDefinition /> 
  </Grid.ColumnDefinitions> 
  <Grid.RowDefinitions>
    <RowDefinition />  
    <RowDefinition />   
    <RowDefinition />  
Listing 8.6
Grid with uniformly sized cells
Column 
definitions
Row definitions

171
The Grid
  </Grid.RowDefinitions>                              
</Grid>
The listing defines a Grid with three columns and three rows, all defined within the
Grid.RowDefinitions and Grid.ColumnDefinitions elements. These elements rep-
resent strongly typed collections that serve as containers for the row and column defi-
nitions. The individual row and column definitions are shown by the RowDefinition
and ColumnDefinition elements. These elements intersect at different points across
the Grid, creating a total of nine cells.
 Each cell represents the area allocated to a specific region within a Grid. This
region is created by the intersection of a row and a column within a Grid. The easiest
way to see the boundaries of each cell is to use the Grid element’s ShowGridLines
property. Although this property defaults to a value of False, you can set it to True to
see the area reserved for each cell. Because these particular grid lines aren’t customiz-
able, they’re generally only used during development. As you’ll see shortly, you can
add several GridSplitter elements to customize the cell boundaries while giving the
user control of cell sizing. Nevertheless, the ShowGridLines property and the Grid-
Splitter element are both useful when sizing a Grid’s rows and columns or arrang-
ing its content.
 The content of a Grid consists of the elements that you want to arrange in a tabu-
lar fashion. These elements could be controls such as TextBox and TextBlock. Text-
Block will be covered at the end of this chapter, but TextBox won’t be covered until
the next chapter when I discuss collecting user input. For now, you’ll use these basic
controls to arrange content in a Grid to create an input form, as shown in listing 8.7.
Result:
XAML:
<Grid x:Name="myGrid" ShowGridLines="True" 
  Background="LightGray" Width="310" Height="75">
  <Grid.ColumnDefinitions>
    <ColumnDefinition />
    <ColumnDefinition />
  </Grid.ColumnDefinitions>
  <Grid.RowDefinitions>
    <RowDefinition />
    <RowDefinition />
    <RowDefinition />
  </Grid.RowDefinitions>
  <TextBlock Text="Please enter your name and email address." 
    Grid.ColumnSpan="2" />                            
  <TextBlock Text="Name: " Grid.Row="1" /> 
Listing 8.7
Grid Row, Column, and ColumnSpan properties on a simple form
ColumnSpan 
property

172
CHAPTER 8
Panels
  <TextBlock Text="Email Address: " Grid.Row="2" />
  <TextBox Width="150" Grid.Column="1" Grid.Row="1" />  
  <TextBox Width="150" Grid.Column="1" Grid.Row="2" />  
</Grid>
The listing shows a basic input form that uses a Grid to arrange its content. This con-
tent is arranged using a number of the Grid’s attached properties. The first attached
property is ColumnSpan. This property gives you the ability to span an element across
multiple cells. I’ll discuss this feature in greater detail in a moment. But first, let’s
explore the Grid.Row and Grid.Column attached properties, which are used more
often and enable you to position content within a Grid. 
8.4.2
Positioning Grid content
Positioning content within a Grid is handled mainly by two attached properties—
Column and Row—which store integer values. These values specify the row and/or col-
umn in which to place the content. To illustrate the syntax of these attached proper-
ties, use the TextBlock:
<TextBlock Text="Rock On!" Grid.Row="3" Grid.Column="2" />
The properties in this example are assigned explicit integer values. If values aren’t
assigned, they default to 0. Alternatively, if you provide a value outside the available
row or column range, they’re simply capped at the end of that range, and the element
will be displayed as though you specified the max row or max column for your grid,
possibly overlapping other elements.
 Although overlapping can be an unwanted side effect, clipped content is also unde-
sirable. Clipped content can happen when a row or column is too small for its con-
tent. One way to overcome this problem is to size your row or column using one of the
techniques discussed in section 8.3.1. Another option is to let your content span mul-
tiple cells.
8.4.3
Spanning cells
Occasionally, you run into situations where you need to allow content to span multiple
cells. You saw this in section 8.4.1, where you had a heading that demanded this func-
tionality. As you saw then, to accomplish this you need to use the ColumnSpan attached
property.
 The ColumnSpan attached property empowers you to spread content across several
cells horizontally. By default, this integer value is set to 1, meaning that the content
can occupy a single column. If this value is larger than the number of columns avail-
able in the row, the content extends to the end of the row but not beyond it. In addi-
tion to the ability to span horizontally, you can span vertically with RowSpan, which
works just like ColumnSpan:
<TextBox Grid.Row="1" Grid.RowSpan="3" 
         Grid.Column="1" Grid.ColumnSpan="2" />
Grid.Row, Grid.Column 
properties

173
The Grid
The ColumnSpan and RowSpan properties are easy to add to any piece of content in a
Grid. Occasionally, though, allowing content to span multiple cells isn’t desirable, but
you may need more space for content. Let’s look at the Grid’s sizing options.
8.4.4
Sizing it up
The overall dimensions of a Grid can be set to a specific number of pixels using the
Height and Width properties. These dimensions are set like almost every other ele-
ment in Silverlight. Defining the dimensions of a row or column within a Grid is an
entirely different story because the Height of a RowDefinition and Width of a
ColumnDefinition are represented as GridLength values.
 The System.Windows.GridLength type provides three ways to specify how to allo-
cate space. I’ll discuss each of these options throughout this section. It’s important to
understand how each approach works because these options can be intertwined
within the same Grid. Based on this fact, I’ll cover the typical pixel approach to sizing.
In addition, I’ll cover the more dynamic autosizing approach. But first, I’ll describe
the default option used for sizing rows and columns: star sizing.
STAR SIZING
Star sizing enables you to equally distribute the available area of a Grid across its rows
and columns. This is the default approach used within a Grid. But if any row or col-
umn in a Grid uses some other form of sizing, the other approach will take prece-
dence. (It may be more appropriate to say that star sizing is used by the remaining
available area.) Listing 8.8 illustrates this concept.
Result:
XAML:
<Grid x:Name="myGrid" ShowGridLines="True" 
  Background="LightGray" Width="200" Height="200">
  <Grid.RowDefinitions>
    <RowDefinition Height="50" />    
    <RowDefinition Height="2*" />                       
    <RowDefinition Height="3*" />                       
  </Grid.RowDefinitions>
  <Grid.ColumnDefinitions>
    <ColumnDefinition Width="50" />
    <ColumnDefinition Width="2*" />      
    <ColumnDefinition Width="3*" />   
  </Grid.ColumnDefinitions>
</Grid>
Listing 8.8
Absolute and star sizing
Absolute sizing
 Star sizing

174
CHAPTER 8
Panels
The listing shows a Grid using star sizing in addition to absolute sizing. Absolute sizing
will be discussed in just a moment; for now, observe the values with the n* in them—
the Height and Width values for the second and third rows and columns. This asterisk
signals that the element will use star sizing with a multiplier. Although this example
only uses integer values, you can use any positive double-precision value. The value
specifies the proportion of the remaining space to allocate to the element.
 Star sizing works by determining how much space is available after the other sizing
schemes have rendered. These calculations will return a remaining amount of avail-
able space. This space is divided proportionally across all the items using star sizing. As
you can see, this approach offers an easy way to provide a proportionate-looking inter-
face. Occasionally, you may want the size of the cells to be automatically determined
based on their content. For these situations, it’s appropriate to use the Auto Grid-
Length option.
AUTOSIZING
The Auto GridLength option automatically determines how large or small to make an
element, as shown in listing 8.9. With this option, the element’s size is based primarily
on the content that occupies it, but other factors can also dictate the size of an ele-
ment using the Auto approach. 
Result:
XAML:
<Grid x:Name="myGrid" Height="100" Width="300" 
  ShowGridLines="True" Background="LightGray">
  <Grid.ColumnDefinitions>
    <ColumnDefinition Width="Auto" />        
    <ColumnDefinition Width="Auto" />
  </Grid.ColumnDefinitions>
  <Grid.RowDefinitions>
    <RowDefinition Height="Auto" />
    <RowDefinition Height="Auto" />
  </Grid.RowDefinitions>
  <TextBlock Text="Hello there, how are you?" />
  <TextBlock Text="I'm fine thanks!" Grid.Column="1" />
  <TextBlock Text="That's Great" Grid.Row="1" />        
</Grid>
Listing 8.9 uses the autosizing approach for the Grid’s columns and rows. The run-
time result produced from this XAML shows two key aspects of autosizing. First, if a
row or column uses autosizing, the size of the largest element in the row or column
Listing 8.9
Autosizing
Autosizing

175
The Grid
determines the size of the others. Second, any remaining space is allocated to the last
row or column—this is why the cells in the last row look so bloated. If you want to have
complete control over the size of your cells, you need to use a more exact approach.
ABSOLUTE
The final approach for allocating the available area to a row or column involves using
a double. This double-precision floating-point value represents a number of pixels.
These pixels single-handedly dictate the area reserved for a row or column. If this
space is larger than the content, there’s no problem. If the amount of space is smaller
than the content, you may get some undesired results because the overlapping con-
tent is clipped, as shown in listing 8.10.
Result:
XAML:
<Grid x:Name="myGrid" Height="100" Width="300" 
  ShowGridLines="True" Background="LightGray">
  <Grid.ColumnDefinitions>
    <ColumnDefinition></ColumnDefinition>            
  </Grid.ColumnDefinitions>
 <Grid.RowDefinitions>
    <RowDefinition Height="68.5" />
    <RowDefinition Height="6" />
    <RowDefinition Height="19.5" />
  </Grid.RowDefinitions>
  <TextBlock Text="This row is too tall" />
  <TextBlock Text="This row is too small" Grid.Row="1" />
  <TextBlock Text="This row is just right!" Grid.Row="2" />
</Grid>
The previous listing shows the absolute sizing approach in action at runtime (design-
ers may have small rendering differences). The rows use a double-precision value to
specify their Height. The third row displays the text “This row is just right!” Although
you could use the autosizing approach for this row, I chose the absolute approach pri-
marily for illustration. It’s important to know that the absolute approach takes prece-
dence over all other sizing options, giving you some flexibility to get a Grid to look
exactly how you want.
 As you’ve seen, the Grid provides three sizing options, giving you the flexibility to
create a great-looking layout at design time. Occasionally, you may need to set the siz-
ing options at runtime. Alternatively, you may need to add or remove rows and col-
umns at runtime. For both reasons, it’s important to understand how to work with the
Grid programmatically.
Listing 8.10
Absolute sizing

176
CHAPTER 8
Panels
8.4.5
Working with the grid programmatically
Usually, the rows and columns of a Grid are created at design time using XAML. This
approach ensures that you can easily arrange the content of a Grid before an applica-
tion is up and running. Once the application is running, there may be situations
where you need to dynamically add or remove rows or columns from a Grid. In times
like these, it’s nice to know how to add and remove these items at runtime.
ADDING ROWS AND COLUMNS AT RUNTIME
Adding rows or columns programmatically at runtime is as simple as writing two lines
of code. The first line is responsible for creating either a RowDefinition or
ColumnDefinition object. The other line is then responsible for adding the newly cre-
ated object to the appropriate collection. Significantly, there are two different ways to
add the object to the collection. First, here’s how to programmatically add a row:
RowDefinition myRow = new RowDefinition();
myGrid.RowDefinitions.Add(myRow);
The preceding adds a row to the grid created in the previous example. Similarly, this
code adds a column to the same grid but uses the Insert method to insert the column
definition at the far left of the grid:
ColumnDefinition myColumn = new ColumnDefinition();
myGrid.ColumnDefinitions.Insert(0, myColumn);
The first approach adds a single row to the bottom of the Grid because the Add
method always appends an object to the end of a collection. In situations where you
need to have more control over where a column or row is added to a Grid, you may
consider using the Insert method. Either way, you can see how easy it is to add rows
and columns on the fly. Fortunately it’s just as easy to remove them.
REMOVING ROWS AND COLUMNS AT RUNTIME
To remove either a row or a column from a Grid, you must use one of two approaches.
The first uses the Remove method, which attempts to remove the first occurrence of
the object provided. If the row or column is successfully removed, this method returns
true. If something unexpected has occurred, this method returns false:
RowDefinition myRow = myGrid.RowDefinitions[0];
myGrid.RowDefinitions.Remove(myRow);
Occasionally, you may want to explicitly state which row or column to remove based
on an index. For these situations, consider using the RemoveAt method:
int lastColumnIndex = myGrid.ColumnDefinitions.Count - 1;
myGrid.ColumnDefinitions.RemoveAt(lastColumnIndex);
The RemoveAt method enables you to specify which row or column to remove by using
a specific index. This index is based on the zero-based indexing scheme used by the
RowDefinitions and ColumnDefinitions collections. Once the row or column is
removed, the remaining rows or columns will simply move up in the collection. This
process occurs completely at runtime and demonstrates how powerful the Grid can

177
The Grid
be. Another feature that shows the power of the Grid is the ability to customize the
cell boundaries.
8.4.6
Customizing cell boundaries
Silverlight provides a way to customize the cell boundaries of a Grid that’s similar to
the border property in CSS. But Silverlight goes one step further and gives the user the
ability to use this boundary to dynamically resize the cells of a Grid. This user-
controlled sizing feature enables a user to reallocate space from one cell to another.
During this process, as one cell increases in size, other cells in the Grid may decrease
in size. Significantly, this resizing process doesn’t change the dimensions of the overall
Grid. To take advantage of this powerful feature, you use a GridSplitter.
 A GridSplitter is an element in the System.Windows.Controls namespace. But
this item isn’t part of the core Silverlight runtime. Instead, this element is known as an
extended control. These types of controls must be accessed slightly differently than a
standard element such as a Grid. Over the course of this section, you’ll learn how to
access the library of extended controls. Then you’ll learn how to use the Grid-
Splitter within a Grid.
ACCESSING EXTENDED CONTROLS
The extended controls, including the GridSplitter, are part of an assembly called
System.Windows.Controls, which is included in the Silverlight SDK, itself part of the
developer tools download. This assembly includes a number of controls designed to
complement the core Silverlight controls. You’ll learn about the core Silverlight con-
trols in chapter 12 and the other extended controls throughout this book. For now,
it’s important to recognize that this assembly is not part of the core Silverlight runtime;
if you want to use any of the extended controls, you must reference the System.Win-
dows.Controls assembly. You can do so by adding a reference to the assembly in
Visual Studio, then referencing the namespace through a prefix: 
<UserControl x:Class="ExtendedControls.Page"
  xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" 
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" 
  xmlns:sdk="clr-namespace:System.Windows.Controls;
 [CA]assembly=System.Windows.Controls"
  Width="400" Height="300">
  <Grid x:Name="LayoutRoot" Background="White" />
</UserControl>
This code shows how to reference the extended controls assembly to pull in a control
not included in the core Silverlight runtime.
WARNING
Referencing the System.Windows.Controls assembly will cause it
to be bundled with your application’s XAP, increasing the size of the XAP file
by about 427 KB before compression (as of this writing). This can cause your
application to take slightly longer to download unless you take advantage of
assembly caching described in chapter 3.

178
CHAPTER 8
Panels
I’ve given this assembly the friendly prefix ext to reference the extended controls. The
sdk prefix will also be used in relation to the current discussion involving the Grid-
Splitter.
USING THE GRIDSPLITTER
The GridSplitter defines a divider within a Grid. This divider can be used to style
the boundaries of the cells in the Grid. Alternatively, a GridSplitter can be moved by
a user with the mouse or keyboard. To get a feel for how this works and the basic syn-
tax of a GridSplitter, look at listing 8.11.
Result:
XAML:
<Grid x:Name="LayoutRoot" Background="White">
  <Grid.RowDefinitions>
    <RowDefinition />
    <RowDefinition />
    <RowDefinition />
  </Grid.RowDefinitions>
  <Grid.ColumnDefinitions>
    <ColumnDefinition />
    <ColumnDefinition />
    <ColumnDefinition />
  </Grid.ColumnDefinitions>
  <Canvas Background="Silver" Margin="10" />
  <Canvas Background="Gray" 
          Margin="10" Grid.Column="1" />
  <Canvas Background="Silver" 
          Margin="10" Grid.Column="2" />
  <sdk:GridSplitter Width="2" />           
  <Canvas Background="Gray" 
          Margin="10" Grid.Row="1" />
  <Canvas Background="Silver" Margin="10" 
          Grid.Column="1" Grid.Row="1" />
  <Canvas Background="Gray" Margin="10" 
          Grid.Column="2" Grid.Row="1" />
  <sdk:GridSplitter Background="Black" Width="2"      
                    Grid.Column="1" Grid.RowSpan="2" />  
  <Canvas Background="Silver" Margin="10" Grid.Row="2" />
  <Canvas Background="Gray" 
          Margin="10" Grid.Column="1" Grid.Row="2" />
  <Canvas Background="Silver" 
          Margin="10" Grid.Column="2" Grid.Row="2" />
</Grid>
Listing 8.11
GridSplitter
Basic GridSplitter 
control
GridSplitter with 
appearance

179
Summary
Listing 8.11 shows a 3 × 3 Grid that has two GridSplitter elements. The first Grid-
Splitter shows the most basic implementation of a GridSplitter. At the same time,
the second GridSplitter goes a step further and shows how to control the appear-
ance. The appearance of a GridSplitter is based on a variety of properties, including
Width and Background.
 The Width property is a double-precision value that defines the thickness of a
GridSplitter. By default, this property is not set to a value so the GridSplitter takes
on a default appearance of a bar with a handle the user can grab. When the Width is
set to a value greater than 0, the GridSplitter takes the shape of a basic line. This
line will be visible as long as the Background isn’t Transparent.
 The Background property defines how a GridSplitter is painted. I use the term
painted because the Background property is defined as a Brush. I’ll cover brushes in
chapter 24; for now, just know that the Background defaults to being transparent. Also
know that you have the GridSplitter to empower a user to resize the columns of a
Grid at runtime. 
 In general, the Grid is the most powerful layout panel in Silverlight because it can
do almost everything that the other layout panels can do. There may be times when
you don’t want the additional bulk of the Grid. For these situations, it’s nice to know
you have the StackPanel, WrapPanel, and Canvas layout options. 
8.5
Summary
A rich and interactive user experience is primarily about presenting information. The
users’ acceptance and adoption of your application can hinge on how that informa-
tion is presented to them, so it’s important to know how to show this information in a
pleasing way. To help accomplish an orderly UI, Silverlight provides the Canvas,
StackPanel, WrapPanel, and Grid layout options, as well as the other brand-new pan-
els such as the DockPanel and even the custom panel you’ll create later in chapter 15.
 The Canvas is the panel to use if you want to have the lightest layout possible and
simply position elements using Left and Top properties. Canvas offers no scaling and
no other layout.
 When you want to build a list of items, such as you’d see in a ListBox or a Menu, the
StackPanel is the panel to use. Like the Canvas, it offers no scaling but it does offer
automatic placement of elements in a vertical or horizontal list. The WrapPanel builds
on the concept of the StackPanel by providing automatic wrapping of items in rows
or columns.
 Finally, if you want to lay out elements using a grid or tabular format and take
advantage of automatic scaling, the Grid is the panel for you. By far, the Grid is the
most commonly used layout panel in Silverlight.
 With the layout and rending background from the previous chapter and the infor-
mation about panels from this chapter under your belt, you’re ready to move on to the
fundamentals of working with human input such as the mouse, keyboard, and touch.

180
Human input
Real-world applications need a way to accept input from users. This process of col-
lecting input is managed by a wide range of input devices, such as the mouse,
touch, stylus, and keyboard. Silverlight provides direct support for these devices
through the System.Windows.Input namespace. 
 Whether you’re implementing drag and drop or mouse-wheel zoom or creating
your own right-click context menus, you’ll almost certainly end up handling mouse
input in your applications. Silverlight has great support for mouse states as well as
for handling both left and right mouse buttons and allowing you to respond to the
mouse wheel. Silverlight even makes it possible for you to respond to double-click,
triple-click, and any other multiclick scenario you may want.
 Multitouch is now coming of age due to the proliferation of multitouch devices,
PC displays, slates, and notebooks. Silverlight can now accept single- and multi-
touch input to allow you to write modern touch-enabled applications.
This chapter covers
■
Capturing keystrokes
■
Responding to mouse clicks, movement, and 
the wheel
■
Handling multitouch input
■
Working with pen ink input

181
Capturing the keyboard
 If you have a tablet PC, an external drawing pad, or perhaps one of the newer slate
form factors that we’re just dreaming about as I write this, then ink input using a stylus
is a must. Ink is also a convenient way to capture drawings done with the mouse.
 Most keyboard input will be handled by the TextBox and similar controls. But what
happens when you want to implement custom accelerators or write a game that
responds to keystrokes? In those instances, you’ll need to access the lower-level key-
board events as I did in the Commodore 64 emulator shown in chapter 5.
 The keyboard has been the input of choice since the dawn of terminal-based com-
puting (no, Silverlight doesn’t have a paper tape input API, but you could probably
write one) and is used by virtually all applications, so I’ll start there.
9.1
Capturing the keyboard
Have you ever considered how an application determines how to handle your key-
strokes? Often, you click and clack your way through your days and take for granted
how your information gets where you intend it to go. If you’d slow down for a second,
you’d notice there’s an intermediary step.
 Before typing any information, you must target an element and give it the focus.
This section will provide an explanation of the concept of focus. Once an item has
focus, it can begin receiving keyboard events—the topic of the second subsection. For
the special situations where you want to handle key combinations, you must learn to
deal with modifier keys—this section’s final keyboard topic.
9.1.1
Understanding focus
When an element has focus, it becomes the primary target for any information entered
through the keyboard. This target element must be a System.Windows.Con-
trols.Control element because only Control elements can be given focus in Silver-
light. You can give these elements focus by selecting them with the mouse, by tabbing
to them through the keyboard, or via the Focus method. Regardless of your approach,
the concept of focus is especially important within the realm of the World Wide Web.
 Web pages pose a unique challenge with focus because Silverlight plug-in instances
are part of a larger ecosystem. In chapter 2, this ecosystem was shown to begin with an
HTML document. This document may have multiple Silverlight controls or a mix of
Silverlight controls and other control types such as Flash. In order for a Silverlight
control to accept input from the keyboard on an HTML page with additional content,
the Silverlight control itself must first have the focus. To accomplish this, you can use
the following JavaScript:
var silverlightControl = document.getElementById('SilverlightControl');
if (silverlightControl)
  silverlightControl.focus();
This example uses the HTML DOM to manually give the focus to an instance of the Sil-
verlight plug-in. This approach can be useful if you want to give your Silverlight appli-
cation the focus when a web page is loaded. If you don’t do this, a user will either have

182
CHAPTER 9
Human input
to click or tab to your Silverlight plug-in instance. Once that’s done, you’ll be able to
set focus to individual controls. 
ELEMENT FOCUS
Individual elements on the Silverlight page receive focus by click or tab. But you can
manually set focus to an element by calling the Focus method of the UIElement:
myTextBox.Focus();
You may want to do that in response to a special accelerator key, or to automatically set
focus to a field with a validation error, or perhaps to allow for skipping fields based on
prefilled data.
 Once the plug-in instance has focus and one of the input controls on your page
has focus, you can begin handling keyboard events within your Silverlight application.
9.1.2
Handling keyboard events
Silverlight provides two events directly related to the keyboard. These events, KeyDown
and KeyUp, are available through the UIElement class. The KeyDown event happens
when a user presses a key. Once that key is released, the KeyUp event fires. When
either event is triggered, its event handler receives a KeyEventArgs parameter. This
parameter and the KeyDown and KeyUp events are shown in listing 9.1.
XAML:
<UserControl x:Class="Keyboard01.MainPage"
  xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" 
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" 
  Width="400" Height="300"
  KeyDown="MainPage_KeyDown">          
  <Canvas x:Name="LayoutRoot" Background="Black">
    <TextBlock x:Name="myTextBlock" Foreground="White" Text="Waiting..." /> 
  </Canvas>
</UserControl>
C#:
public partial class MainPage : UserControl
{
  public MainPage()
  {
    InitializeComponent();
    this.KeyUp += new KeyEventHandler(MainPage_KeyUp); 
  }
  private void MainPage_KeyUp(object sender, KeyEventArgs e)
  {
    myTextBlock.Text = "Key (" + e.Key + ") was released.";            
  }
  private void MainPage_KeyDown(object sender, KeyEventArgs e)
Listing 9.1
A page in Silverlight that responds to the KeyDown and KeyUp events
Handler wired up 
in XAML
Handler wired up
in code

183
Capturing the keyboard
  {
    myTextBlock.Text = "Key (" + e.Key + ") is down.";
  }
}
Listing 9.1 shows a page in Silverlight that responds to the KeyDown and KeyUp events.
The event handlers associated with these events update the TextBlock to show the key
that was used. These events are watched through the UserControl element, which is
inherently a UIElement. I’ll discuss this element further in chapter 15, but for now,
note how the keyboard events are attached in two different ways. In one, the KeyDown
event is attached through the XAML declarative approach. The other approach uses
traditional procedural code. Regardless of the method, the appropriate keyboard
event handler will receive a KeyEventArgs parameter.
NOTE
If the user holds the key down, and her system is set up to allow key
repeating (the default), multiple KeyDown events will be fired and KeyUp will
only be fired when the key is released. If you want to process typing, you
should process KeyDown (to capture each character), but if you want to pro-
cess keystrokes for hotkeys or similar functionality, KeyUp may be a better
event to use.
The KeyEventArgs class enables you to fetch data relayed from a user’s keyboard. Once
a user begins typing, you can use this object to interpret the user’s keystrokes and act
accordingly. The KeyEventArgs class provides the properties shown in table 9.1.
After reviewing this table, you may be wondering, “Why would I ever use the
PlatformKeyCode property when Silverlight is cross-platform?” When I ported the C64
emulator to Silverlight, I had to use the PlatformKeyCode to gain access to a number
of keys Silverlight didn’t surface through the Key enumeration—for example, the
bracket and pipe keys. The key codes for those keys will be different on each
supported platform and each type of keyboard, such as Qwerty in the United States
and AZERTY in France.
Table 9.1
The properties of the KeyEventArgs class 
Property
Description
Handled
A bool that signals whether the key event has been handled.
OriginalSource
A reference to the element that originally raised this event. Because the key-
board events are bubbling routed events, you need this to identify the source 
of the event as opposed to the sender of the event.
Key
This value identifies which key has been pressed. Unlike the PlatformKey-
Code property, this value is consistent across all operating systems.
PlatformKeyCode
An integer value that provides the key code of a pressed key. This value is spe-
cifically tied to the OS the user is using.

184
CHAPTER 9
Human input
Another reason is because some keys are irrelevant on other operating systems. For
instance, checking for a Windows Logo keystroke on OS X makes as much sense as
checking for a Command key press on Windows. If handling other OS-specific key-
strokes is necessary, you can use the PlatformKeyCode. Otherwise, I recommend
sticking with the Key property. 
 In addition to straight key presses, you may need to capture key combinations such
as Ctrl-C.
9.1.3
Dealing with modifier keys
Modifier keys are specific keys used in combination with other keys. Modifier keys are
necessary because the KeyEventArgs class only exposes information about the cur-
rently pressed key. If you press something like the Shift key or Ctrl key, then another
key, the initially selected key data will be lost. You can overcome this problem with the
help of the statically visible Keyboard class.
 The Keyboard class, in the System.Windows.Input namespace, exposes informa-
tion directly related to the selected modifier keys. This information is available
through the Modifiers property, which is a bit field enumeration that represents the
set of ModifierKeys that are pressed. These ModifierKeys represent options of an
enumeration.
 Table 9.2 shows the options available in the ModifierKeys enumeration. Notably,
the Apple key is equal to the Windows key in value, as they serve conceptually similar
roles on the two platforms. The reason for this enumeration is to allow for bitwise
operations. 
If it’s not Windows, don’t assume it’s a Mac
One thing that got me into trouble with my friends on the Moonlight team (the team
creating the open source Linux version of Silverlight) was my assumption in code that,
if the keystroke wasn’t from Windows, it was from a Mac. Remember, there are other
platforms that support Silverlight without a recompile: Linux, Moblin, Nokia Symbian
OS (for Silverlight 2), as well as code-sharing with Windows Phone, Xbox, and more.
Table 9.2
The ModifierKeys available within Silverlight
Key
Description
None
No modifier keys are pressed.
Alt
The Alt key is pressed. This key is available on all supported platforms. 
On an Apple keyboard, this is also referred to as the Option key.
Apple
The Command key is pressed on an Apple system. These keys used to 
have open apples on them.
Control
The Ctrl key is pressed. This key is available on all supported platforms, 
despite usage differences between Windows and Mac.

185
Mouse input
The modifiers are important because they allow you to check whether multiple keys are
selected at the same time. If you want to change the KeyDown event used in listing 9.1 to
listen for Shift-B, you could use this code:
private void MainPage_KeyDown(object sender, KeyEventArgs e)
{
  if (e.Key == Key.B)
  {
    if (Keyboard.Modifiers.HasFlag(ModifierKeys.Shift))
      myTextBlock.Text = "You pressed SHIFT+B";
  }
}
This code shows how you can go beyond individual key events in Silverlight. By appro-
priately listening to and responding to these events, you can extend the input and nav-
igation of your application beyond just the mouse alone. Though that’s compelling,
especially for those of us who grew up with 40- or 80-character displays and a fondness
for the command prompt, the mouse is the primary input device for most web appli-
cations today. 
9.2
Mouse input
The mouse requires different input processing compared with the keyboard. In addi-
tion to responding to button-related events, the mouse can respond to movement. It’s
also common for the mouse to be moving with one or more buttons pressed, as in a
drag operation. Another input vector on the mouse, one that’s relatively new com-
pared to the mouse itself, is the scroll wheel or mouse wheel. Though implementa-
tions vary from traditional wheels to capacitive touch pads, it’s rare to find a modern
mouse that omits this handy feature, so it’s important that Silverlight developers be
able to gather meaningful input from it.
 I’ll start with mouse movement events followed by the mouse button events. The
two are often used together to handle dragging and resizing operations. Even when
used separately, they’re often thought of together due to their ubiquity from the first
days of mouse-based UIs.
 From there, I’ll look at the mouse wheel support added with Silverlight 3. The
mouse wheel isn’t necessarily an essential input like the mouse button and mouse
movement, but it can make the difference between a mediocre user experience and
an awesome one.
Shift
The Shift key is pressed. This key is available on all supported platforms.
Windows
The Windows Logo key is pressed on a Windows-enabled keyboard.
Table 9.2
The ModifierKeys available within Silverlight (continued)
Key
Description

186
CHAPTER 9
Human input
9.2.1
Mouse movement events
One fundamental user interaction is the movement of the mouse. As a developer and
UI designer, you’ll find it interesting to know when the user brings his mouse in over
your element and when they leave. It can also be useful just to know that he’s moving
the mouse around, especially when working with drawing or drag-and-drop scenarios.
 In support of tracking the mouse, the UIElement class exposes the mouse-move-
ment events shown in table 9.3.
The events in table 9.3 are each passed a MouseEventArgs parameter so you can be
readily informed of mouse movement. This feature can especially be useful if you want
to implement drag-and-drop features in Silverlight or track the mouse for drawing.
 Knowing that the mouse has moved is only half the picture—you also need to
know where the mouse moved to. You can get the location of the mouse cursor in rela-
tion to a specific UIElement through the GetPosition method of the MouseEventArgs
class, the key members of which are shown in table 9.4.
The previous table lists the properties available through the MouseEventArgs class. In
addition to the mouse-specific properties and methods, Silverlight has built-in support
for working with another type of pointing device: the stylus, which I’ll discuss later in
this chapter. One method in the MouseEventArgs class demands more immediate
attention: GetPosition.
Table 9.3
The mouse movement-related event handlers
Event
Description
MouseEnter 
Triggers when the user enters the boundary of a UIElement
MouseMove 
Reports mouse movement within the boundary of a UIElement
MouseLeave 
Fires when the move leaves the boundary of a UIElement
Table 9.4
Key properties and methods exposed by the MouseEventArgs
Property
Description
Handled 
A bool property that flags whether the mouse event has been dealt with.
Set to true on a RightMouseButtonDown event to avoid showing the default 
Silverlight configuration menu.
OriginalSource 
A reference to the element that originally raised this event.
Because the mouse events are bubbling routed events, you need this to iden-
tify the source of the event as opposed to the sender of the event.
StylusDevice 
Property that primarily includes information associated with a tablet pen. It also 
has some seldom-used but interesting mouse-related properties.
GetPosition
Method that returns the mouse’s position relative to an element.

187
Mouse input
GETTING THE MOUSE POSITION
The GetPosition method gives you immediate access to the current location of the
mouse. This location is returned from the GetPosition method as a Point in relation
to any UIElement. This UIElement is determined by passing it as the sole parameter to
the method. Optionally, you can pass null as the parameter to the GetPosition
method to get the location of the mouse in relation to the Silverlight plug-in instance.
Regardless of how you use it, this method is useful when handling both click and
movement events. 
 Listing 9.2 shows how to use GetPosition to display the current mouse coordi-
nates from within the MouseMove event of the page.
XAML:
<UserControl x:Class="MouseGetPositionExample.MainPage"
  xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
  <Grid x:Name="LayoutRoot" Background="White">
    <TextBlock x:Name="PositionDisplay" FontSize="30"
               HorizontalAlignment="Center" 
               VerticalAlignment="Center" />
  </Grid>
</UserControl>
C#:
public MainPage()
{
  InitializeComponent();
  MouseMove += new MouseEventHandler(MainPage_MouseMove);
}
void MainPage_MouseMove(object sender, MouseEventArgs e)
{
  Point p = e.GetPosition(this);             
  PositionDisplay.Text = string.Format("{0},{1}", p.X, p.Y);
}
Listing 9.2 shows how to use GetPosition to display the mouse position relative to the
main page. If you wished to display the position relative to a rectangle or other ele-
ment onscreen, you’d pass that element into the GetPosition call.
 The mouse movement events tell you what the business side of the mouse is doing.
The top side, where the buttons are, is at least as interesting to an application developer.
NOTE It would be nice if the mouse event arguments class included helpful
information on the amount of lint stuck to the adhesive on the mouse glide
pads as well, but alas, no such information is available.
Listing 9.2
Using GetPosition to display the mouse coordinates
GetPosition

188
CHAPTER 9
Human input
9.2.2
Mouse button events
In addition to the mouse movement events, Silverlight supports a number of mouse
button events that can be raised by any UIElement. The following table shows these
mouse click–related actions along with their descriptions.
Table 9.5 shows two pairs of events tied to the mouse buttons. When a mouse button is
selected, the corresponding event handlers will receive a MouseButtonEventArgs
object. This object derives from the MouseEventArgs class previously described, which
includes information about the mouse state at the time the event was raised.
 In addition to the properties common to all mouse events, the MouseButtonEvent-
Args class includes a new property, ClickCount, which can be used to implement dou-
ble-, triple-, and other multiclick handlers.
CLICKCOUNT
ButtonBase-derived classes automatically handle the single click. But nothing in Sil-
verlight has double-click wired up for you already. Rather than implement discrete
double-click and even triple-click events (yes, some graphics and music software uses
the triple-click, as do all browsers, Microsoft Word, and more), the Silverlight team
decided to leave the number of clicks you’re interested in up to you. 
 To support this, team members added the ClickCount property, which increments
for each click that falls within a double-click timing from the previous click. So, if you
click twice slowly, you’ll get a click count of one each time. If you double-click, you’ll get
a click count of two. As you may have guessed, triple-clicking will get you a click count
of three. Listing 9.3 shows how to handle double-click using the ClickCount property.
XAML:
<UserControl x:Class="MouseClickCount.MainPage"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
     xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
  <Grid x:Name="LayoutRoot" Background="White">
    <Rectangle x:Name="ClickRectangle"
               Height="85" Width="93"
               HorizontalAlignment="Left" VerticalAlignment="Top"
               Margin="30,40,0,0"               
Table 9.5
The click-related events associated with the mouse
Event
Description
MouseLeftButtonDown 
Responds to the user pressing the left mouse button
MouseLeftButtonUp 
Reacts to the user releasing the left mouse button
MouseRightButtonDown 
Responds to the user pressing the right mouse button
MouseRightButtonUp 
Fired when the user releases the right mouse button
Listing 9.3
Handling double-click using the ClickCount property

189
Mouse input
               Stroke="Black" StrokeThickness="1" 
               Fill="#FFE82A2A"
               MouseLeftButtonDown="RectMouseLeftButtonDown" />
  </Grid>
</UserControl>
C#:
void RectMouseLeftButtonDown(object sender, MouseButtonEventArgs e)
{
  if (e.ClickCount == 2)               
  {
    MessageBox.Show("Double click!");
  }
}
As listing 9.3 shows, handling a double-click is as simple as waiting to take action until
the click count is equal to two.
 The implementation of ClickCount is not without its challenges. For instance, if
you need to handle more than a single discrete number of clicks (for example, if you
want both double-click and triple-click), you have to do a little dancing around to fig-
ure out if the user actually triple-clicked. For a moment, assume the event handler
code from the previous example looked like this:
if (e.ClickCount == 2)
    MessageBox.Show("Double click!");
else if (e.ClickCount == 3)
    MessageBox.Show("Triple click!");
In such cases, a double-click would be inappropriately handled first unless you added
a delay in the processing to log the number of clicks before deciding which type of
click the user actually did—the triple-click code in this example would never execute.
The next listing shows one way to implement this delay to handle both double- and tri-
ple-click scenarios.
private TimeSpan _clickDelay = TimeSpan.FromMilliseconds(300);
private int _clickCount = 0;
private DispatcherTimer _timer = new DispatcherTimer();
        
void RectMouseLeftButtonDown(object sender, MouseButtonEventArgs e)
{
  _clickCount = e.ClickCount;
  if (e.ClickCount >= 2 && !_timer.IsEnabled) 
  {
    _timer.Interval = _clickDelay;
    _timer.Tick += TimerTick;
    _timer.Start();
  }
  else if (e.ClickCount < 2)
  {
    _timer.Stop();
Listing 9.4
Implementing a delay to support multiple click counts
Double-click
Wait in case of 
triple-click

190
CHAPTER 9
Human input
  }
}
private void TimerTick(object sender, EventArgs e)
{
  _timer.Stop();
  _timer.Tick -= TimerTick;
  if (_clickCount == 2)       
    OnRectDoubleClick();
  else if (_clickCount == 3)          
    OnRectTripleClick();
}
private void OnRectDoubleClick()
{
  MessageBox.Show("Double Click!");
}
private void OnRectTripleClick()
{
  MessageBox.Show("Triple Click!");
}
In this code, you use a timer to wait for a small amount of time (300 milliseconds in
this case) after a double-click to give enough time to identify whether or not you’re
actually dealing with a triple-click. After the timer goes off, you see how many clicks
you have and respond appropriately.
 You’ll want to experiment with the timer interval to get the timing correct in your
application. Admittedly, that code seems a little messy just for some click handling.
This is a perfect case for wrapping this functionality either in a behavior (chapter 13)
or in a custom control (chapter 15) and firing off discrete double- and triple-click
events as appropriate for your specific scenarios.
Implementing a custom single-click event
Implementing a custom click event (rather than using a click-enabled base class such
as ButtonBase) is more involved than simply handling the MouseLeftButtonUp event.
Back in Silverlight 1.1a, when you had to create buttons from scratch, you learned
that a click event requires the following steps:
1
On MouseLeftButtonDown on your control, capture the mouse using
UIElement.CaptureMouse.
2
On MouseEnter, update an internal flag that indicates that the mouse is cur-
rently over your control. On MouseLeave, set that flag to false.
3
On MouseLeftButtonUp, verify that the mouse is still over your control, using
the flag you set in step 2. If it is, raise your own custom click event. If it isn’t,
do nothing. In either case, release the mouse capture using UIElement.
ReleaseMouseCapture.
You may never need to implement your own click event but, if you do, ensure that you
follow these steps rather than simply responding to MouseLeftButtonUp.
Double-click
Triple-click

191
Mouse input
Besides mouse button down and up, multiclick, and pointer movement, the modern
mouse offers one more form of input: the mouse wheel. 
9.2.3
Using the mouse wheel
Silverlight 3 added built-in support for the mouse wheel, in the form of the
IElement.MouseWheel event. It was possible to wire up a mouse wheel handler in
Silverlight 2, but you had to resort to JavaScript to do it—something that won’t work
out-of-browser, always seemed a bit of a hack, and is difficult to support cross-browser
and cross-platform. Silverlight 4 expanded that by adding in support in the controls
themselves, with a few caveats.
Silverlight includes first-class mouse wheel support in the form of the MouseWheel
event on the UIElement class. When the user scrolls the mouse wheel, this event is
raised with an instance of the MouseWheelEventArgs class. The properties available in
the MouseWheelEventArgs class are detailed in table 9.6.
The MouseWheel Implementations
The MouseWheel event only works in specific situations: windowed controls on IE and
Firefox (or other Netscape Server Application Programming Interface (NSAPI)-based
browsers) for Windows, as well as windowless controls for IE. 
The approach used with the Netscape Plug-in API (NPAPI) doesn’t provide the plug-in
with mouse wheel information when running in windowless mode. In addition, Silver-
light doesn’t support the mouse wheel in Safari or Firefox on the Mac; you’d need to
manually wire up JavaScript handlers in those cases. One of the Silverlight 4 GDRs
(an interim update) added out-of-browser support on the Mac. 
On Windows, when using windowed mode on those browsers, the Silverlight runtime
bypasses the plug-in API and grabs the underlying window handle (hWND) for the control
as a workaround.
Table 9.6
The properties exposed by MouseWheelEventArgs 
Property
Description
Delta 
An integer representing the relative change since the last time the event was 
raised.
A positive value indicates that the mouse wheel was scrolled up or away from the 
user. A negative value means the mouse wheel was scrolled down or toward the 
user. The higher the absolute value of the number, the faster the mouse wheel 
was scrolled.
Handled 
A bool that flags whether the mouse event has been dealt with.
OriginalSource 
A reference to the element that originally raised this event.
Since the mouse events are bubbling routed events, you need this to identify the 
source of the event as opposed to the sender of the event.
StylusDevice 
Includes information primarily associated with a tablet pen.

192
CHAPTER 9
Human input
Listing 9.5 shows the mouse wheel properties in action. 
XAML:
<UserControl x:Class="SilverlightApplication17.MainPage"
  xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" 
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" 
  Width="400" Height="300">
  <Grid x:Name="LayoutRoot" Background="White">
    <TextBlock x:Name="Info" />
  </Grid>
</UserControl>
C#:
public MainPage()
{
  InitializeComponent();
  MouseWheel += new MouseWheelEventHandler(OnMouseWheel);   
}
void OnMouseWheel(object sender, MouseWheelEventArgs e)
{
  if (e.Delta > 0)                                           
    Info.Text = string.Format("Up {0}", e.Delta);           
  else                                                       
    Info.Text = string.Format("Down {0}", Math.Abs(e.Delta));
}
Listing 9.5 shows how to obtain the Delta value from the MouseWheel event in order
to determine both direction and speed. Negative values mean the wheel was scrolled
down or toward the user; positive values mean the wheel was scrolled up or away from
the user.
 The ScrollViewer control automatically handles the MouseWheel event, so the
ListBox, ComboBox, TextBox, and other ScrollViewers will automatically scroll using
the wheel. If you want to support the mouse wheel on other controls, simply handle
the MouseWheel event as shown in listing 9.2. As another example, here’s the mouse
wheel integrated with a Slider:
private void OnMouseWheel(object sender, MouseWheelEventArgs e)
{
  if (e.Delta > 0)
    slider_X.Value += slider_X.LargeChange;
  else
    slider_X.Value -= slider_X.LargeChange;
}
First-class support for the mouse wheel event isn’t the only advanced input supported
by Silverlight. Silverlight also has a great feature for Windows 7 systems and beyond:
multitouch support. 
Listing 9.5
Responding to the mouse wheel
Wiring up 
event
Responding 
to scroll

193
Using multitouch
9.3
Using multitouch
Microsoft Windows 7 was the first Microsoft OS to have official built-in support for
multitouch-enabled hardware. For a platform to be touch enabled, it needs to recog-
nize a single finger on the screen. Many tablets and portable devices support this, as
do touch screens going back to the 1980s and earlier. Multitouch is fairly new ground.
A multitouch-enabled display will recognize more than one finger on the screen,
allowing you to do things such as resize and rotate images by touching both corners or
make complex multifinger gestures to perform specific functions, such as sweeping a
screen to the side.
 Although multitouch has become essential in tablet and handheld form factors,
it’s hard to predict how popular multitouch will be on the desktop. It’s already finding
use in new technology like Microsoft Surface 2.0, and in kiosk and kitchen-PC scenar-
ios (as long as you have a cake-batter-and-bacon-grease-proof screen).
 The static Touch.FrameReported event is the primary entry point into the touch
API in Silverlight. A Frame, in this context, is a snapshot of all touchpoints for a partic-
ular point in time. This event fires on a regular interval, the timing and triggering of
which depends on the touch-enabled hardware and drivers in use. As soon as you wire
up the event handler, you’ll begin receiving notifications.
 The FrameReported event includes an instance of the TouchFrameEventArgs class
with members as described in table 9.7.
The GetPrimaryTouchPoint function returns a single instance of the TouchPoint class.
The GetTouchPoints collection returns a collection of TouchPoints, including the pri-
mary touchpoint. The TouchPoint class includes the members listed in table 9.8.
Table 9.7
Properties and methods exposed by the TouchFrameEventArgs class
Property or method
Description
Timestamp
An integer representing the time for this specific frame.
You can use this to facilitate time-sensitive gestures.
SuspendMousePromotionUntilTouchUp
Use this method when the primary touchpoint is down 
in order to suspend promoting that point to a mouse 
gesture until all the touchpoints are up.
GetPrimaryTouchPoint
Returns the first touch made since the last time all 
touches were lifted from the screen.
This is the touchpoint that’ll be promoted to a mouse 
event.
GetTouchPoints
Use this method to return a collection of TouchPoint
values for the frame. 

194
CHAPTER 9
Human input
Listing 9.6 shows how to listen for the FrameReported event, enumerate the Touch-
Point objects, and display their positions to the debug window. 
public MainPage()
{
  InitializeComponent();
  Touch.FrameReported += new TouchFrameEventHandler(OnTouchFrameReported);
}
void OnTouchFrameReported(object sender, TouchFrameEventArgs e)
{
  foreach (TouchPoint tp in e.GetTouchPoints(this))
  {
    Debug.WriteLine(tp.Position);
  }
}
One final method of interaction with your application is ink input. Though ink is typ-
ically used with tablet-style PCs, it can be used with mice as well. With new pen-enabled
devices such as multitouch tablet PCs, there’s renewed interest in ink collection in Sil-
verlight applications. 
9.4
Collecting ink drawings
Although most touch-enabled devices are meant to be used with your fingers, there’s
still a need for stylus-based input, especially in signature and annotation scenarios.
Silverlight provides an intuitive way to collect handwritten information through an
element known as the InkPresenter. This element enables you to collect and display
a kind of content known as ink, a term that refers to a series of points related to the
Table 9.8
Properties and methods exposed by the TouchPoint class 
Property
Description
Action 
The user activity associated with this touch.
Possible values are Down, for finger down on the screen, Move for 
finger moved/dragged on the screen, and Up for finger up from the 
screen.
Position 
The x,y coordinates of the touch. This is relative to the application’s 
RootVisual.
Size 
A rectangle describing the size of the touchpoint. You can use this 
to differentiate between, say, a light tap and a full press.
TouchDevice 
Information about the device that provided the touch information.
TouchDevice.DirectlyOver 
This property is located on the TouchDevice for WPF compatibil-
ity reasons. It’ll return the topmost UIElement over which the 
touch occurred.
Listing 9.6
Responding to the FrameReported event and reporting touchpoints

195
Collecting ink drawings
movement of a device. These points can be collected from a mouse, stylus, or touch
screen and are stored as a Stroke. The process of collecting Stroke elements is han-
dled through the InkPresenter.
 In this section, you’ll learn how to gather and display ink with the InkPresenter.
This process involves three simple but important steps. The first step involves creating
a canvas to collect the ink. After that, you must wire up the canvas to collect ink-
related information. Finally, once the ink has been collected, you can decide how to
style the content.
9.4.1
Creating the InkPresenter
To create a place to capture and display the ink, you must define an InkPresenter
object. This object can be thought of as a Canvas because the InkPresenter class
derives from that type. And as with the Canvas, you can create an InkPresenter in
XAML, as shown here:
  <Grid x:Name="LayoutRoot" Background="White">
    <InkPresenter x:Name="myInkPresenter" Background="Silver"/>
  </Grid>
This example creates a basic InkPresenter within a Grid. If you were to create a Silver-
light application using this XAML, it’d look like the InkPresenter doesn’t do anything.
 The InkPresenter is designed to dynamically render ink as it’s drawn, so let’s look
at how to dynamically collect ink content.
9.4.2
Collecting ink
The first step in collecting ink involves listening for the mouse button or stylus to be
pressed. When this event occurs, the MouseLeftButtonDown will fire and you can sig-
nal that the input device is pressed. At that point, you can begin to construct a Stroke
object that can be added to an InkPresenter.
 The Stroke object represents a continuous series of points. As a user moves a
device around an InkPresenter, you build on that Stroke until the user releases the
device. It’s a general practice to define a Stroke object as a member variable of your
Silverlight page, so you can interact with the same instance within the MouseLeft-
ButtonDown, MouseMove, and MouseLeftButtonUp events. The MouseLeftButtonDown
event is generally responsible for instantiating or resetting the Stroke, as shown in
listing 9.7.
private Stroke _stroke;                               
public MainPage()
{
  InitializeComponent();
  myInkPresenter.MouseLeftButtonDown += 
    new MouseButtonEventHandler(ipMouseLeftButtonDown);    
Listing 9.7
Receiving mouse events and creating ink strokes

196
CHAPTER 9
Human input
  myInkPresenter.MouseMove +=
    new MouseEventHandler(ipMouseMove);               
  myInkPresenter.MouseLeftButtonUp += 
    new MouseButtonEventHandler(ipMouseLeftButtonUp);   
  myInkPresenter.MouseLeave += 
    new MouseEventHandler(ipMouseLeave);          
}
public void ipMouseLeftButtonDown(object sender, MouseButtonEventArgs e)
{
  myInkPresenter.CaptureMouse();
  _stroke = new
    Stroke(e.StylusDevice.GetStylusPoints(myInkPresenter));
  _stroke.DrawingAttributes.Color = Colors.Blue;   
  _stroke.DrawingAttributes.OutlineColor = Colors.White;
  myInkPresenter.Strokes.Add(_stroke);      
}
This example shows the member variable stroke used on these listings as well as the
event handler wire-up required for listings 9.4 through 9.6. Importantly, it also shows
the initial mouse capture established when the mouse left button is pressed.
 The member variable _stroke is reset each time the user presses the input device.
This reset process involves retrieving the styles points that have been collected. This
task is handled by the GetStylusPoints method of the StylusDevice object. Because
of the reset, you must also reapply the styling settings, which I’ll discuss shortly. With
the styled Stroke in hand, you can add it to the InkPresenter, which will be immedi-
ately rendered. You can even do this as the mouse moves around an InkPresenter, as
shown in listing 9.8.
public void ipMouseMove(object sender, MouseEventArgs e)
{
  if (_stroke != null)
  {                  
    _stroke.StylusPoints.Add(                
      e.StylusDevice.GetStylusPoints(myInkPresenter));
  }
}
This adds to the Stroke initialized in the previous example. You’ll notice that this task
is wrapped in a null check statement. The reason will become apparent as you com-
plete the final step of drawing ink.
 The final step involves completing the Stroke. The Stroke needs to be completed
when the user releases the input device or leaves the InkPresenter. For this reason,
you need to handle two events: MouseLeave and MouseLeftButtonUp. These two
events perform the tasks of nullifying the Stroke and releasing the input device, as
shown in listing 9.9.
Listing 9.8
Adding points to the InkPresenter
Handlers for 
upcoming 
listings
Capture mouse
Add ink 
stroke
Add points
to stroke

197
Collecting ink drawings
public void ipMouseLeftButtonUp(object sender, MouseButtonEventArgs e)
{
  myInkPresenter.ReleaseMouseCapture();    
  _stroke = null;
}
public void ipMouseLeave(object sender, MouseEventArgs e) 
{
  myInkPresenter.ReleaseMouseCapture();    
  _stroke = null;
}
This completes the process of drawing a Stroke on an InkPresenter. By setting the
Stroke to null, you can determine whether you should build on it when the Mouse-
Move event occurs. 
 In the event that you do draw a Stroke, you should know how to stylize it.
9.4.3
Styling the ink
The Stroke element provides a property called DrawingAttributes that may be used
to alter its appearance. This utility class is defined within the System.Windows.Ink
namespace. It provides four properties that allow you to specify a Stroke element’s
Color, Height, OutlineColor, and Width. Collectively, you can use these values to
deliver truly expressive web content.
 The Color property represents the System.Windows.Media.Color used to paint
the interior of a Stroke. By default, this value is set to Colors.Black. This default
value is different than the default OutlineColor property, which defaults to
Transparent. This property must be set if you wish to specify the Color surrounding
a Stroke. If it’s set, a 2-pixel boundary of the given Color will be added around the
Stroke. The dimensions of the Stroke are just as important as colors.
 The dimensions of a Stroke are defined through the Height and Width properties
of DrawingAttributes. These two double-precision values do exactly what you’d
expect them to do. These properties can be used to help create Stroke elements that
represent different drawing tools. Here’s some code so you can get a feel for all these
DrawingAttributes:
<InkPresenter x:Name="ip" Background="Silver" 
              Height="300" Width="300">
  <InkPresenter.Strokes>
    <Stroke>
      <Stroke.DrawingAttributes>  
        <DrawingAttributes Color="Blue" OutlineColor="Black" 
                           Height="4" Width="6" />
      </Stroke.DrawingAttributes>
      <Stroke.StylusPoints>       
        <StylusPoint X="10" Y="10" />
      <StylusPoint X="10" Y="50" />      
    </Stroke.StylusPoints>
  </Stroke>
Listing 9.9
Completing the stroke 
Release on mouse up
Release on mouse leave

198
CHAPTER 9
Human input
  </InkPresenter.Strokes>
</InkPresenter>
As this code shows, you can define the DrawingAttributes of a Stroke within XAML.
It also shows the one property that the InkPresenter exposes that the Canvas doesn’t:
the Strokes property. As these two properties remain consistent with the relationship
between XAML and code, so too does the StylusPoints collection. This collection
defines the continuous line of a Stroke, which is composed of a series of StylusPoint
elements.
 A StylusPoint, which is found in the System.Windows.Input namespace, repre-
sents an individual point within a Stroke. This point is positioned based on the values
of two properties called X and Y. These values are double-precision values that repre-
sent a coordinate. This coordinate is relative to the containing InkPresenter.
 Like multitouch, ink may not be common in many desktop applications. But as
devices continue to add support for the stylus, supporting ink in your own applica-
tions will become increasingly important. 
9.5
Summary
Without input, an application would be just an automated slide show. Though con-
trols will get you most of the way there, sometimes you just need lower-level access to
the input devices. Luckily, Silverlight doesn’t disappoint.
 Silverlight provides complete access to the keyboard information as the user
presses and releases keys. Constants are provided for the most common and cross-plat-
form keys, and you can always get to the low-level keycode information should you
need to.
 The most common interaction device for many Silverlight applications is the
mouse. Silverlight now provides access to the left and right mouse buttons as well as
normal mouse movement and the scroll wheel. 
 Two other modes of interaction are gaining in popularity. Pen-and-ink input has
been around for a while but hasn’t seen serious interest until new waves of devices
started becoming popular. Multitouch is both new and popular, especially in the
device space.
 Now that you know how input works behind the scenes, including keyboard input,
the next chapter explains how to work with text.

199
Text fundamentals
Most applications you write will display or manipulate text at some point. Even many
games have text input requirements for signing up, registering, or logging a high
score. Media players often have rolling commentary by other viewers and the ability
to add to the social aspects of what you’re watching. In short, working with text is
important. Text is so important that Silverlight dedicated a team to the text system.
 For as long as computers have been around and attached to video displays or
teletypes, the display of text has been an important aspect of user interaction.
Silverlight includes great support for displaying text, with a number of options that
control formatting and other aspects of the display.
 Many designers (and developers with an eye for design) want fine control over
the rendering and display of the fonts onscreen. Silverlight includes the
TextOptions class with its attached properties, which may be used to change text
hinting, formatting, and rendering.
This chapter covers
■
Exploring the text system
■
Displaying text and working with fonts
■
Controlling text rendering with Text Options
■
Using advanced OpenType features

200
CHAPTER 10
Text fundamentals
 Speaking of designers, Silverlight 5 introduced top-notch support for OpenType
fonts. That means you now have access to ligatures, variants, number formats, frac-
tions, and much more. I’m especially fond of the font style sets and variations you can
now use in your Silverlight applications.
 With all these new font features, what do you do if you want to show text using a font
the user doesn’t have? You embed the font. Silverlight supports font embedding to
ensure that your users have the exact experience you’d intended. I’ll describe that and
the support for international text using input method editors before I cover rich text. 
 I’ll start this chapter with a look at the text stack, then move on to the basics of dis-
playing text. Along the way, you’ll learn about text options, font embedding, and the
display and editing of international text. You’ll also learn about the new and exciting
support for OpenType in Silverlight 5.
10.1
The text system
You’d be forgiven if you looked at the title of this section and thought, “System?
Really? It’s just text.” Getting the text from the Unicode string and presenting it on
displays of varying resolutions using different fonts on different systems is actually
fairly complex. It’s also a task we only notice when done poorly.
 In reality, a text stack needs to
■
Read in the source text string.
■
Lay out an overall block of text.
■
Lay out individual lines within that block.
■
Obtain the font information for each character, including combining charac-
ters for certain languages.
■
Figure out how to display bold and italics (and other styles/weights). There may
be a font for it or it may need to generate pseudo-italic and pseudo-bold text.
■
Deal with any text expansion for fonts that support it.
■
Lay out individual characters within that line, including subpixel font rendering.
■
Render it all out to a rendering surface in software or hardware.
Any one of those individual steps is a pretty serious programming effort. Though
interesting, the internals of the text stack are well abstracted away from the work you’ll
normally need to do, but there are some places where the Silverlight team has pro-
vided options you can set.
 Before you move on to the high-level controls and elements that allow you to put
text on the screen, let’s look at how Silverlight handles character rendering using
ClearType, and how it enables you to tweak the rendering using various text options.
10.1.1 Subpixel text rendering
In chapter 7 you learned about the layout system and subpixel layout and rendering.
Silverlight can handle elements aligned on subpixel boundaries, such as having a Left
of 15.76 rather than just 16. This makes layout easier for design professionals and is
also essential for smooth animation.

201
The text system
 Subpixel layout and ren-
dering applies to text as well.
On 
Windows 
machines,
Silverlight uses the ClearType
algorithm, 
provided 
by
DirectWrite, to render text
using the best quality for a given resolution. An example of ClearType rendering is
shown in figure 10.1.
 Silverlight supports subpixel rendering and layout of anything, so the text itself
may already start on a partial pixel boundary (for example, a Left of 10.32). For that
reason and others, the Silverlight ClearType algorithm will produce results slightly dif-
ferent from the base Windows platform. The end result will still be text that’s more
readable and more pleasing to the eye than no antialiasing or the grayscale used in Sil-
verlight 2.
 The ClearType text-rendering algorithm is a relatively expensive subpixel antialias-
ing algorithm that you wouldn’t necessarily want to recalculate 60 times per second.
Also, as a side effect of the antialiasing, you may also see text that jumps around a bit
when you animate it (you’d have to look closely). For those reasons, and to support
other optimizations, Silverlight includes a TextOptions.TextHintingMode attached
property.
10.1.2 Text hinting
ClearType is an excellent text-rendering algorithm, but it’s not something you want to
be calling thousands of times because it’s a complex algorithm with performance
implications. In addition, there are other visual optimizations applied to text that
would be unnecessary if the text were animated.
 Silverlight offers the TextOptions.TextHintingMode attached property to control
how hard Silverlight tries to make the text look great. When set to Fixed, it uses the
quality ClearType rendering and performs the calculations that make static text look
great. When set to Animated, it optimizes for text that’s going to change size, rotation,
or angle, probably multiple times per second. Listing 10.1 shows the setting in action.
Result:
XAML:
<StackPanel Width="150" Height="100">
  <StackPanel Background="White">
    <TextBlock Text="Lorem ipsum (Fixed)"
               Foreground="Black"
Listing 10.1
TextOptions.TextHintingMode
Figure 10.1
ClearType subpixel font rendering in Silverlight

202
CHAPTER 10
Text fundamentals
               TextOptions.TextHintingMode="Fixed" />  
    <TextBlock Text="Lorem ipsum (Animated)"
               Foreground="Black"
               TextOptions.TextHintingMode="Animated" />        
  </StackPanel>
  <StackPanel Background="Black">
    <TextBlock Text="Lorem ipsum (Fixed)"
               Foreground="White"
               TextOptions.TextHintingMode="Fixed" />   
    <TextBlock Text="Lorem ipsum (Animated)"
               Foreground="White"
               TextOptions.TextHintingMode="Animated" />   
  </StackPanel>
</StackPanel>
It’ll be hard to tell in a printed book, but the
Animated text hinting renders the text using
grayscale antialiasing, whereas the Fixed
text hinting (the default) renders using
ClearType rendering. Figure 10.2 shows a
close-up of the first word from each line on
a white background as well as black.
 The rendering optimized for animation
avoids both the costly ClearType calculations
as well as the jumping/jittering effect. If you
use the animation-optimized text in small font sizes for regular text in your applica-
tion, you’ll see it’s noticeably fuzzier than ClearType. In fact, this was an issue with
Silverlight adoption for line-of-business applications in the Silverlight 2 timeframe,
before ClearType was integrated into the stack.
 As of this writing, ClearType isn’t supported on the Mac, so it always uses some
form of grayscale rendering with Silverlight. An interesting limitation of ClearType is
that it’s sensitive to the orientation of the display. Because the modern ClearType
implementation is meant only for LCD displays (if you have an old tube monitor hang-
ing around, don’t enable ClearType on it or the world will end in an explosion of sub-
pixels), it takes into account the position of the actual elements (red, green, blue)
and uses them to make the text more readable. If you tilt the monitor 90 degrees,
those positions are out of whack, and ClearType won’t work correctly.
10.1.3 Text formatting
With the typical computer display, you have a low enough DPI (dots per inch) that
you’re always approximating the font shape on the screen. ClearType attempts to fix
some of that approximation to make it easier to read on a computer. But there’s more
you can do to change how the font shapes are calculated.
 If you had a display with infinite DPI, or perhaps just something high enough that
you’re unlikely to perceive individual pixels, like 1200 dpi or even higher (see http://
www.clarkvision.com/articles/eye-resolution.html to learn more), you can accurately
Fixed text 
rendering
Animated text 
rendering
Figure 10.2
The first line uses Fixed text 
hinting and, therefore, ClearType rendering. 
The second line uses Animated text hinting 
and is, therefore, grayscale.

203
The text system
reproduce the intended shape of the glyphs in the typeface without having anything
fall between pixel boundaries. That’s not the case in the near future, so even in small
devices, you’re stuck with either blurry shapes that conform to the intended glyph
outlines, or you pixel snap the glyphs at the cost of shape, especially at small sizes.
 As a designer, you should be the one to make that decision. For that reason, the
Silverlight team took some inspiration from WPF and added the TextOptions.Text-
FormattingMode attached property. This property enables you to choose between
Ideal (the intended shape) and Display (the pixel-snapped shape).
 For obvious reasons, the effect is best seen on a real screen, as opposed to a book.
To test this, create two TextBlock elements each with a different TextFormattingMode.
<TextBlock Text="Hello World! Ideal"
           TextOptions.TextFormattingMode="Ideal" />
<TextBlock Text="Hello World! Display"
           TextOptions.TextFormattingMode="Display" />
The text will show different ClearType color-
ation, as well as slightly different shapes to the
characters themselves. The Display version
should, for the most part, appear crisper on the
screen than the Ideal version. Figure 10.3 is a
blown-up version of the text.
 Note the width of the “o” and “d” glyphs in
figure 10.3. In the Display version, they’re wider,
snapped more closely to pixel boundaries. 
 In your applications, you’ll typically want to use a TextHintingMode of Fixed and a
TextFormattingMode of Display for maximum clarity at small sizes. But there’s one
more option that can greatly affect the clarity and rendering of the text: Text-
RenderingMode.
10.1.4 Text rendering
The third text option available is TextRenderingMode. As the name suggests, Text-
RenderingMode affects the basic algorithm used to render the text onscreen. The
available choices are Auto, Aliased, ClearType, and Grayscale. With an option for
aliased text, this option can have more impact on the display of the text than any of
the other TextOptions properties.
 Like the previous options, TextRenderingMode is best seen onscreen rather than in
print. Here’s code to see the three main options (more on Auto in a bit):
 <TextBlock Text="Hello World! Aliased"
           TextOptions.TextRenderingMode="Aliased" />
<TextBlock Text="Hello World! ClearType"
           TextOptions.TextRenderingMode="ClearType" />
<TextBlock Text="Hello World! Grayscale"
           TextOptions.TextRenderingMode="Grayscale" />
Figure 10.3
The effects of using 
TextFormattingModes of Ideal and 
Display on a typical DPI desktop or 
laptop LCD, using the default Silverlight 
5 font on Windows 7, at the default size.

204
CHAPTER 10
Text fundamentals
   On Windows, the default is Clear-
Type in most cases. Similarly, on the
Mac, the default is Grayscale as
there’s no supported ClearType imple-
mentation on OS X. When you run the
code, you’ll see a result similar to
figure 10.4.
      You  can  see  from  figure  10.4 that
aliased text is text with no font smooth-
ing applied to it. This may be appropri-
ate for pixel-style fonts in some
applications. More often than not, you’ll want to stay away from it, especially at small
sizes. ClearType and Grayscale are as you’ve seen with the TextHintingMode but don’t
have any other underlying performance implications—in other words, the system
won’t do any other potential animation optimization here.
 Now that you know a little about what’s going on behind the scenes and how to
optimize text rendering for different situations, let’s look at what’s available to you to
push characters onto your display and how you can set the higher-level properties
such as what font to use and what size to use when rendering the text. 
10.2
Displaying text
Displaying text is primarily addressed by an element called TextBlock. This element,
which belongs to the System.Windows.Controls namespace but which itself doesn’t
derive from Control, is designed to flexibly display text within a variety of scenarios.
The following example shows one such scenario, as well as the basic syntax of a Text-
Block:
<TextBlock x:Name="myTextBlock" 
  Text=" My friends are toys. I make them. It's a hobby."/>
This shows a basic way to include text within your Silverlight applications. The Text-
Block can be hosted in any of the panels discussed in chapter 8.
 As you’ve probably guessed, the Text property of a TextBlock is used to set the
text to display. The text direction (right to left or left to right) is controlled via the
FlowDirection property. The TextBlock provides a rich set of other styling options
that mimic or exceed those found in CSS. I’ll cover all of these styling options, includ-
ing setting the font properties, controlling the flow of text, setting the text-related
properties, and specifying the spacing options.
10.2.1 Font properties
The TextBlock has five properties related to the styling of a selected font. These prop-
erties replace a lot of the familiar friends from CSS. Table 10.1 shows a font-related
CSS property and its equivalent Silverlight TextBlock property.
Figure 10.4
Ahh, memories. The first line brings 
me back to the days of Windows 3.1 and even 
Windows 95, where font smoothing happened only 
because your CRT monitor had horrible dot pitch and 
the text was naturally blurry.

205
Displaying text
These items are related specifically to the font capabilities of Silverlight. I’ll cover
each in detail, in the order they appear in the table.
FONTFAMILY
By default, the TextBlock displays text using the Lucida Sans Unicode font on Win-
dows machines. On Apple Macintosh computers, an almost identical font known as
Lucida Grande is used. Alternatively, you can specify a different font.
 The FontFamily property enables you to specify the font. More specifically, this
property represents the name of the top-level font family. This is important to recog-
nize because some fonts share a common family name; the differences between them
lie in their individual features—things such as bold and italic options.
 Figure 10.5  shows the nine TrueType fonts supported natively within Silverlight. In
addition to these, Silverlight has support for Eastern Asian fonts. Collectively, the nine
TrueType and Eastern Asian fonts are guaranteed to look almost identical on all plat-
forms supported by Silverlight as long as someone hasn’t uninstalled the core fonts
for those platforms. If you need to use a custom font, you can do so using font embed-
ding or by referring to a local font on the machine. Previous versions of Silverlight
restricted you to embedding or a white list of fonts, with no support for local fonts.
 In addition to these supported fonts, you can use any compatible font installed on
the user’s machine. Keep in mind, though, that those aren’t guaranteed to exist on
every machine.
 Once the FontFamily has been set, this will be the font used within the TextBlock.
If your users don’t have the font on their machines, the TextBlock will fall back to the
default font. You can set fallback priority by providing a comma-delimited list of font
family names.
Table 10.1
A few font-related properties available in Silverlight, and their CSS equivalents
CSS property name
TextBlock property name
Summary
font-family
FontFamily
A list of font names for an element
font-size
FontSize
The size of the font
font-weight
FontWeight
The weight of the font
font-stretch
FontStretch
Expands or compresses the font
font-style
FontStyle
The style of the font (for example, italics)
Figure 10.5
A sampling of the font 
families natively supported within 
Silverlight. You aren’t restricted to this set, 
but it’s the safest set to use cross-platform.

206
CHAPTER 10
Text fundamentals
FontFamily is one of the more widely used font options. Another widely used option
is the FontSize property.
FONTSIZE
The FontSize property allows you to set the
size of a TextBlock using a double-precision
value. This value is set by default to 14.66 pixels,
which is roughly an 11-point font. This fact is
significant because the FontSize property
always represents a specific number of device-
independent pixels. This can have undesired
effects, because fonts are generally discussed in terms of points (pt). Thankfully, you
can easily convert points to pixels using the formula shown in figure 10.6.
 This formula is based on the fact that Silverlight uses 96 pixels per inch and a point
is defined as 72 points per inch. If you want to use a 24 pt font in a TextBlock, you
need to set the FontSize property to 32 (24 * 96 / 72 = 32): 
<TextBlock Text="I'm a Big Boy Now." FontSize="32" />
This basic line of XAML sets the FontSize to a 24 pt font. There are times when, in
addition to setting the FontSize, you may need to work with the weight of a font.
FONTWEIGHT
The FontWeight property represents the heaviness, or weight, of the displayed text.
This weight is often depicted as a bolding effect, but you can also go the other way and
make text appear lighter or thinner. This is made possible by the fact that the Font-
Weight property accepts any numeric value between 1 and 999. Alternatively, you can
use one of the friendly constants available in the FontWeights class:
■
Thin
■
ExtraLight
■
Light
■
Normal
■
Medium
■
SemiBold
■
Bold
■
ExtraBold 
■
Black
■
ExtraBlack
These values are shown in the order of increasing weight. Note that not all fonts sup-
port varying weights. Most fonts support only two font weights: Normal and Bold. If the
font specified within the FontFamily property doesn’t support a specific weight, it falls
back to the closest weight supported by the font. The fallback support for this prop-
erty is also shared by another property called FontStretch.
Figure 10.6
The formula that converts 
font points to pixels in Silverlight

207
Displaying text
FONTSTRETCH
The FontStretch property gives you the ability to either condense or expand the font
associated with a TextBlock. The CSS equivalent of this property is defined within the
third version of CSS (CSS3), but few browsers currently implement it. For this reason,
this property is one text-related feature not usually seen within a traditional web appli-
cation. But, with Silverlight, you can stylize your text with this feature using one of the
FontStretch values shown in table 10.2.
These values represent the acceptable values for the FontStretch property. The per-
centages represent the proportion by which the normal font size is stretched. Any
value less than 100 percent will condense a font and any percentage greater than 100
percent will expand a font. Either way, the percentage is taken into consideration only
if the selected FontFamily has support for font stretching. Even if a font does have
support for stretching, it may not have support for all stretch values. If the font
doesn’t support the stretch value you’ve selected, the FontStretch property resorts to
using an algorithm that searches the available fonts for one that matches the proper-
ties as closely as possible.
FONTSTYLE
The FontStyle property gives you the ability to switch the text of a TextBlock into
italic mode. As you’ve probably guessed, this property is set to a value of Normal by
default. You can easily change this to Italic to give your text an italic effect:
<TextBlock x:Name="myText" Text="Going Italic" FontStyle="Italic" />
The code shows how to set the FontStyle at design time. Setting the FontStyle dur-
ing runtime involves using a slightly different approach. To set a TextBlock to italic
during runtime, you use the FontStyles class:
myText.FontStyle = FontStyles.Italic;
Table 10.2
Acceptable values for the FontStretch property
Name
Stretch percentage
UltraCondensed 
  50.0%
ExtraCondensed
  62.5%
Condensed
  75.0%
SemiCondensed
  87.5%
Normal
100.0%
Medium
100.0%
SemiExpanded
112.5%
Expanded
125.0%
ExtraExpanded
150.0%
UltraExpanded
200.0%

208
CHAPTER 10
Text fundamentals
Note how this uses a FontStyles static property called Italic. This static property
represents a FontStyle definition. This fact is significant because, even though you
can only set a FontStyle to italic in Silverlight, WPF is a different story. WPF, which is
Silverlight’s parent technology, provides additional FontStyle options. 
FontStyle is but one of five font styling options available within a TextBlock. The
others are FontStretch, FontWeight, FontSize, and FontFamily. Collectively, these
give you a significant amount of control over the font styling of a TextBlock. In addition
to basic font styling, Silverlight gives you the ability to control the overall flow of text. 
10.2.2 Flow control
TextBlock enables you to control the overall flow of text through two nested elements.
These elements, Run and LineBreak, belong to the System.Windows.Documents
namespace. Both elements derive from the Inline class and have built-in support for
the font features discussed in section 10.1.1. Listing 10.2 shows how these elements can
be used.
Result:
XAML:
<TextBlock Text="Scene 1: The Greeting" 
           FontWeight="Bold" FontSize="17">
  <LineBreak />                               
  <Run FontWeight="Bold" FontSize="14"   
       Text="Actor 1:" />                    
  <Run FontWeight="Normal" FontSize="14" 
       Text="Hello, how are you?" />
  <LineBreak />
  <Run FontWeight="Bold" FontSize="14" 
       Text="Actor 2:" />
  <Run FontWeight="Normal" FontSize="14" 
       Text="I am fine, thank you!" />
</TextBlock>
The screenshot in listing 10.2 is from runtime; your design experience may vary. (It
may vary considerably. The Silverlight design experience has improved with each ver-
sion but is still not 100 percent with the runtime experience.) The conversation in this
listing shows one way to use the Run and LineBreak Inline elements. These elements
are appended in succession to the text defined in the Text property of the hosting
TextBlock. In fact, the value inside the Text property itself gets converted to a Run ele-
ment at runtime. This element and all the other Run and LineBreak items are stored
in a collection called Inlines.
Listing 10.2
TextBlock Run and LineBreak Inlines
Line break
Formatted run

209
Displaying text
 Although I did so here, you typically wouldn’t use both the Text property and a
collection of Inline elements. You’ll use one or the other. In fact, the use of both
here is what confuses the designer in Visual Studio 2010. The Inlines collection
stores the Inline elements of a TextBlock. By default, all the items in this collection
use the styling options set by the parent TextBlock. You can override these settings by
specifying new values for them within the Inline item itself. This is the approach used
in listing 10.2. But to fully demonstrate how the LineBreak and Run items can be cus-
tomized, let’s jog through several text properties.
10.2.3 Text properties
Silverlight gives you the ability to further customize your text through five useful prop-
erties. These properties focus on rendering text in combination with the font proper-
ties discussed in 10.2.1. To further control how the text is rendered, you can use the
Foreground, TextDecorations, TextWrapping, TextTrimming, and TextAlignment
properties.
FOREGROUND
The Foreground property allows you to set the color of a block of text. More specifi-
cally, this property represents a Brush, which lets you do a lot more than apply solid
colors. The various Brush options aren’t covered until chapter 24. For now, just know
that you can use the name of a color, as shown here, in an example that changes a
TextBlock from the default black SolidColorBrush to blue:
<TextBlock Text="I'm feeling Smurfy." Foreground="Blue" />
Significantly, you can use the Foreground property with the Inline elements we dis-
cussed in 10.2.2. These Inline elements also have baked-in support for the Text-
Decorations property.
TEXTDECORATIONS
The TextDecorations property gives you the ability to underline text. This can be
accomplished using the Underline TextDecorations property as shown here:
<TextBlock Text="I'm Serious" TextDecorations="Underline" />
Much like the FontStyle property, the TextDecorations property has more options
in WPF—the reason why it has such an abstract name. 
 The next property is more line- or paragraph-oriented: TextWrapping.
TEXTWRAPPING
TextWrapping  enables you to specify how text should wrap across multiple lines
within a TextBlock. By default, Silverlight doesn’t wrap text within a TextBlock. You
can set the TextWrapping attribute to Wrap, and the text will break and resume on the
next line if the Width of the TextBlock is exceeded. This wrapping effect is shown in
listing 10.3.

210
CHAPTER 10
Text fundamentals
Result:
XAML:
<Canvas Width="200" Height="140">
  <TextBlock Text="Eating a lot of fruit can help you live to a 
  ➥ ripe old age." 
             Width="150" 
             TextWrapping="Wrap" />     
</Canvas>
The listing shows how to change the TextWrapping property from its default value of
NoWrap. The value and its destination value of Wrap belong to the TextWrapping enu-
meration. This type is only available to TextBlock elements—you can’t use it in
Inline elements such as Run. The Run element also lacks the ability to specify its own
TextTrimming or TextAlignment, separate from the TextBlock.
TEXTTRIMMING
There are often cases when you want to show only as much text as will fit into a pre-
defined rectangle on the screen. The remaining text should be clipped off. In those
cases, it’s common to provide the user with a visual cue that the text’s been trimmed.
 Rather than have you calculate the trimming manually, Silverlight supports the
TextTrimming property. As shown in listing 10.4, Silverlight supports the WordEllip-
sis style of text trimming, where the ellipsis is shown after the last whole word that
will fit in the rectangle.
Result:
XAML:
<Grid x:Name="LayoutRoot" Background="White">
    <TextBlock Width="150"
               Height="30"
               FontSize="12"                 
               TextTrimming="WordEllipsis"   
               Text="Well, hello there! I'm Pete" />
</Grid>
Listing 10.4 shows the TextTrimming option in place with a regular-sized font. If you
increase the font size, less text will fit in the space. Listing 10.5 shows what happens
when you leave everything else the same but increase the font size.
Listing 10.3
Text wrapping
Listing 10.4
Text trimming with a small font
TextWrapping property
Font size
Text trimming 
option

211
Displaying text
Result:
XAML:
<Grid x:Name="LayoutRoot" Background="White">
    <TextBlock Width="150"
               Height="30"
               FontSize="20"                 
               TextTrimming="WordEllipsis"   
               Text="Well, hello there! I'm Pete" />
</Grid>
Note how the text is still broken at the word boundary. That’s one of the nice things
about WordEllipsis trimming. Breaking at a character boundary looks unprofes-
sional in many cases and can lead to unexpected and inappropriate final words in the
worst cases.
 Another way to control the layout of text is to use the TextAlignment property.
Though text trimming is typically used with left-justified text, it can also be used with
any of the other alignments available to the TextBlock.
TEXTALIGNMENT
The TextAlignment property gives you the ability to align the text within a TextBlock.
You can specify whether information should be aligned to the Left, Center, or Right
of the rectangular region defined by the Height and Width properties of a TextBlock,
as shown in listing 10.6.
Result:
XAML:
<Canvas Width="640" Height="480" Background="White">
  <TextBlock Text="Everybody to the Left side of the TextBlock." 
    TextWrapping="Wrap" 
    Width="75" 
    Canvas.Left="5" Canvas.Top="5" />
  <TextBlock Text="Everybody to the Center of the TextBlock." 
    TextAlignment="Center"                     
    TextWrapping="Wrap" 
    Width="75" 
    Canvas.Left="100" Canvas.Top="5" />
  <TextBlock Text="Everybody to the Right side of the TextBlock." 
Listing 10.5
Text trimming with a larger font
Listing 10.6
Text alignment property values
Font size
Text trimming 
option
Centered text

212
CHAPTER 10
Text fundamentals
    TextAlignment="Right"                     
    TextWrapping="Wrap" 
    Width="75" 
    Canvas.Left="195" Canvas.Top="5" />
</Canvas>
Listing 10.6 demonstrates the TextAlignment options. These options provide one way
to stylize your text. The TextWrapping, TextDecorations, TextTrimming, and Fore-
ground properties enable you to further format this text. There’s one more important
feature that shouldn’t be overlooked: the ability to control text spacing. 
10.2.4 Spacing
Spacing is effective for making text easier to read. Designers working with publishing
and graphics software are used to having fine control over the spacing between charac-
ters and lines in a paragraph of text. This enables them to lay out the text in a way appro-
priate for the specific font, resolution, and usage. To control the spacing of text, the
TextBlock exposes three properties: CharacterSpacing, LineHeight, and Padding.
CHARACTERSPACING
Available on any TextElement (from which text elements Block and Inline are
derived), Control or TextBlock, the CharacterSpacing property controls the amount
of space between individual characters. 
 The value for the Character-
Spacing property is expressed in
thousandths of the font size, with zero
being the default. For example, if the
font size is 20 pixels, and the Charac-
terSpacing is set to 200, the spacing
will be 200/1000 * 20, resulting in 4
pixels between each character of text.
This is illustrated in figure 10.7 which
shows the results of character spacing
varying from 200 to –200, with the
latter being squished and, with this font, illegible. The markup required to create this
example is shown in listing 10.7. 
<StackPanel>
  <TextBlock FontSize="18" CharacterSpacing="200"
             Text="Character spacing 200" />
  <TextBlock FontSize="18" CharacterSpacing="100"
             Text="Character spacing 100" />
  <TextBlock FontSize="18" CharacterSpacing="0"
             Text="Character spacing 0" />
  <TextBlock FontSize="18" CharacterSpacing="-100"
             Text="Character spacing -100" />
Listing 10.7
Controlling character spacing
Right-aligned text
Figure 10.7
The effect of the CharacterSpacing
property with values from 200 to –200

213
Displaying text
  <TextBlock FontSize="18" CharacterSpacing="-200"
             Text="Character spacing -200" />
</StackPanel>
The code in listing 10.7 has several TextBlock elements with the specified character
spacing. Note that you could’ve also used Run elements, Paragraphs, or anything else
that derives from TextElement.
CharacterSpacing is all about horizontal space. Designers and typography aficio-
nados will certainly use it, but a more commonly used text layout property is Line-
Height.
LINEHEIGHT
The LineHeight property determines the height of the bounding box that a single
line of your text will be contained within. This height is represented as the number of
pixels and specified as a double-precision value. Listing 10.8 demonstrates this prop-
erty as well as its relationship to FontSize.
Result:
XAML:
<Canvas Height="450" Width="485">
  <TextBlock Width="110" LineHeight="1"           
             FontSize="14" TextWrapping="Wrap">
    Just testing some line height related 
    stuff.  This could actually
    be pretty interesting.
  </TextBlock> 
  <TextBlock Width="110" LineHeight="24"        
             FontSize="14"                    
             TextWrapping="Wrap" Canvas.Left="125">        
    Just testing some line height related 
    stuff.  This could actually
    be pretty interesting.
  </TextBlock>                                                            
  <TextBlock Width="110" LineHeight="44"       
             FontSize="14" 
             TextWrapping="Wrap" Canvas.Left="250">
Listing 10.8
Line height for vertical spacing
Ignored LineHeight
Slightly larger 
LineHeight
Large LineHeight

214
CHAPTER 10
Text fundamentals
    Just testing some line height related 
    stuff.  This could actually
    be pretty interesting.
  </TextBlock>
</Canvas>
As the listing illustrates, the LineHeight property often alters the layout of wrapped
text. Notably, if the LineHeight is smaller than the FontSize, the LineHeight value is
ignored. If the LineHeight is larger than the FontSize, some extra padding is gener-
ated around the text. The LineHeight doesn’t affect the FontSize.
TIP
Did you notice in listing 10.8 that text was directly inserted between the
TextBlock tags, without using the Text property? In Silverlight, you can do
this and have whatever you enter there automatically map to the Content
property. In this case, the content resolves down to some simple text. Some
people find this harder to read. I recommend using it when you have a lot of
text but using the Text property itself in all other cases.
Although LineHeight works on individual lines in the TextBlock and only controls
vertical spacing, Padding controls the overall spacing within the outside border of a
TextBlock.
PADDING
The Padding property represents the amount of cushion to use within a TextBlock.
This space represents the area between the border of the TextBlock and the text of
the element. By default, this property doesn’t specify any spacing. Using a double-pre-
cision value, you can provide a consistent buffer between the text and the virtual bor-
ders of a TextBlock, as shown in listing 10.9.
Result:
XAML:
<StackPanel x:Name="myStackPanel" Background="LightGray">
  <TextBlock Text="Give Me Some Space!" />
  <TextBlock Text="I've got your space right here!" 
             Padding="20.2" />                 
</StackPanel>
Listing 10.9 shows how a Padding of 20.2 pixels creates a nice bubble around some
text. You’ll probably notice that the size of this buffer is the same on each side of the
content. The Padding property also enables you to use a more granular approach
when defining the buffer, as shown in listing 10.10.
Listing 10.9
Uniform padding in a TextBlock
Padding

215
OpenType font support
Result:
XAML:
<StackPanel x:Name="LayoutRoot"
            Background="White"
            Margin="10">
    <Border Background="LightGray"
            BorderBrush="Black"
            HorizontalAlignment="Left"
            VerticalAlignment="Top">
        <TextBlock Text="HELLO"
                   Padding="3.5 6 9.7 12" />     
    </Border>
</StackPanel>
The listing shows the Padding property using a space-delimited list of values. The val-
ues can also be comma delimited. This list of values represents the amount of spacing
to use on each side of the text, within the outer limits of the TextBlock element. The
first value in the list represents the thickness of the spacing on the left side of the text.
The subsequent values represent the top, right, and bottom thicknesses of the buffer.
As you can see, these values specify the thicknesses in a clockwise order. This granular
approach gives the Padding property a significant amount of flexibility.
 The Padding property represents a basic feature of the TextBlock, which is one of
the most basic elements in Silverlight. This element will be used in most Silverlight
applications you write. 
 One feature new to Silverlight 5, and useful in the TextBlock as well as most text-
based elements, is OpenType font support. This involves far more than just allowing
you to use OpenType fonts, as you’ll see in the next section.
10.3
OpenType font support
Text formatting and rendering options aside, typically what you see with a typeface is
what you get. There are no provisions for special relationships between characters or
embellishments around words. For most uses, that’s fine; for example, ligatures aren’t
super important in that data entry form. 
 But what about those cases when you do want to kick things up a notch? Or what
about the more mundane things like displaying superscript/subscript for references
and formulas, and representing fractions using something that looks better than the
side-by-side 3/4 approach? Rest assured, fellow typography geeks, Silverlight has
you covered. 
Listing 10.10
Per-side padding in a TextBlock
Padding

216
CHAPTER 10
Text fundamentals
In this section, you’ll learn about OpenType support, including ligatures, alternatives
and stylistic sets, font capitals, fractions and number formats, and variants, including
superscript and subscript.
10.3.1 Ligatures
A ligature is one or more characters joined together as a single glyph. Typically this is
done with two characters linked together based on context. In traditional printing,
the ligature would be a single printing block. In computer typography, the font
defines how the ligature is handled. Not only does this look more refined, it often
increases readability.
 The most common ligatures revolve around the letters following the letter “f.” Fig-
ure 10.8 shows both the no-ligature version and the version using OpenType ligatures
using the Gabriola font included in Windows 7.
 The use of ligatures removes the awkward splicing of the cross bar on the lower-
case “f” and “t” characters (a combination I see often due to typing out my employer’s
name “Microsoft”). It also removes the dots on the lowercase “i” and “j” characters,
because those mash up against the “f.” Also, you’ll notice that the top of the “f” is han-
dled differently when followed by other tall characters such as “f” and “l.”
 If the font supports it, Silverlight enables or disables the use of standard ligatures
such as those shown here through the Typography.StandardLigatures attached
property. Listing 10.11 shows the markup required to set this property.
<Grid x:Name="LayoutRoot" Background="White">
  <StackPanel>
    <TextBlock Text="ft fi fj fl ff ffi ffj ffl"
               HorizontalAlignment="Center"
               FontSize="100"
               FontFamily="Gabriola"
               Typography.StandardLigatures="False" />  
    <TextBlock Text="ft fi fj fl ff ffi ffj ffl"
               HorizontalAlignment="Center"
               FontSize="100"
               FontFamily="Gabriola"
               Typography.StandardLigatures="True" />  
  </StackPanel>
</Grid>
Listing 10.11
Using ligatures
Figure 10.8
Standard ligatures in the 
OpenType Gabriola font. Pay particular 
attention to the dots on the “i” and “j” 
characters, the cross bar in the “t” and “f,” 
and the tops of the lowercase “f” characters 
and how they connect to the next character.
Disabled
Enabled

217
OpenType font support
In addition, if the OpenType font supports them, Silverlight enables contextual
ligatures, discretionary ligatures, and historical ligatures through the Contextual-
Ligatures, DiscretionaryLigatures, and HistoricalLigatures properties, respec-
tively. You use these properties in the same way you use the StandardLigatures
property.
 Historical ligatures are ones that were once standard but are no longer commonly
used. If you’re looking to make your app appear classical (or maybe steampunk), and
the font supports them, historical ligatures can add real character.
 Contextual ligatures are ones that the font designer believes are appropriate for
use with the font. Enabling both standard and contextual ligatures will give you the
complete set the font designer felt were appropriate for normal use.
 Discretionary ligatures are ones that the font designer included for specific situa-
tions, and which may not apply to general use throughout the entire body of your text.
 Ligatures can help increase the readability and aesthetics of your text. Another way
to really fancy things up is to use contextual alternates and stylistic sets.
10.3.2 Stylistic sets
Stylistic sets are alternate representations of glyphs in a font. They can range from
subtle variations of characters, suitable for more formal documents, all the way up to
fancy and fantastic renderings of the loops, as
well as decorative elements. It’s up to the
designer to create them in such a way as to stay
consistent with the rest of the font but provide
some interesting variation.
 A font designer may include up to 20
optional stylistic sets in a font, and each stylistic
set may include any subset of the characters of
the font. The Gabriola font I’m using here
includes seven stylistic sets. Figure 10.9 shows
the base style, followed by all seven Gabriola sty-
listic sets displayed in Silverlight.
 The sets get progressively fancy, with sets 6
and 7 showing some real flare. Even sets 4 and 5
start to get going with the Mister Rogers’ Neigh-
borhood–style “R” and “K” descenders. I partic-
ularly like the treatment given to the lowercase
“g” character.
Figure 10.9
The base style plus the stylistic sets for the
Gabriola font as rendered by Silverlight. Note not only the
obvious changes, but also the subtle treatment given to the
“S” and “g” characters, the top of the “O,” as well as the
“l” and “h” characters. It’s like having seven fonts in one.

218
CHAPTER 10
Text fundamentals
 Listing 10.12 shows how to enable the various stylistic sets from markup. 
<Grid x:Name="LayoutRoot" Background="White">
  <StackPanel>
    <StackPanel.Resources>
      <Style TargetType="TextBlock">              
        <Setter Property="Text" Value="Silverlight ROCKS" />
        <Setter Property="FontFamily" Value="Gabriola" />
        <Setter Property="FontSize" Value="75" />
        <Setter Property="HorizontalAlignment" Value="Center" />
      </Style>
    </StackPanel.Resources>
    <TextBlock />
    <TextBlock Typography.StylisticSet1="True"/>     
    <TextBlock Typography.StylisticSet2="True" />
    <TextBlock Typography.StylisticSet3="True" />
    <TextBlock Typography.StylisticSet4="True" />   
    <TextBlock Typography.StylisticSet5="True" />
    <TextBlock Typography.StylisticSet6="True" />
    <TextBlock Typography.StylisticSet7="True" />
  </StackPanel>
</Grid>
This listing uses an implicit style to avoid repeating the same properties for every
TextBlock. I’ll cover styles in detail in chapter 14, but for now, think of a style as sim-
ply repeating the declared values for each and every TextBlock on the page, so they
all have the same Text, FontFamily, FontSize, and HorizontalAlignment properties.
 Selecting the stylistic set is as simple as setting its numbered StylisticSetN prop-
erty to true. If there’s no set in that spot, you’ll receive the default font. If you want to
check for support for alternates, you can open Microsoft Word, right-click the text,
and select the advanced font properties. You’ll be able to easily browse many of the
OpenType features of the font, including stylistic sets. Set only one stylistic set prop-
erty to true at a time.
 Although not required, the ContextualAlternates property is often used with sty-
listic sets in order to fine-tune the relationships between the characters. The effects of
setting this property to true are typically more subtle than a stylistic set. Alternates are
glyphs that can be substituted for a standard glyph. Contextual alternates are ones
that are automatically substituted based on the context of the original glyph. For
example, picture the relationship between characters in a handwritten cursive type-
face—characters following a lowercase “o” often start differently compared to ones
following, say, a lowercase “l.”
Listing 10.12
A number of stylistic sets for the Gabriola font
Style
Stylistic set

219
OpenType font support
10.3.3 Font capitals
Another way to modify the appearance of text is to convert it to all caps. You could do
this simply by using all caps when you type the text, but many fonts include alternate
representations for small caps, petite caps, titling case, and others. In Silverlight, this
is supported by the Typography.Capitals attached property.
 Silverlight supports the following optional
types of capitals via the Capitals property:
Normal, 
AllPetiteCaps, 
AllSmallCaps,
PetiteCaps, SmallCaps, Titling, and Uni-
case. The appearance of the type is depen-
dent on how the font designer created it and
could vary significantly from one font to the
next. Figure 10.10 shows how Normal and
AllSmallCaps appear in Gabriola.
 You can see that the word “ROCKS” is
smaller in the All Small Caps version, as is
expected. In addition, you can see some slight differences in spacing, like between the
“O” and “C,” and the “K” and “S.” It’s not necessarily the same as an algorithmic resiz-
ing of the letters; the designer has control over how the smaller letters appear.
 Listing 10.13 shows how to use AllSmallCaps and Normal to create the text shown
in figure 10.10.
<Grid x:Name="LayoutRoot" Background="White">
  <StackPanel>
    <StackPanel.Resources>
      <Style TargetType="TextBlock">
        <Setter Property="Text" Value="Silverlight ROCKS" />
        <Setter Property="FontFamily" Value="Gabriola" />
        <Setter Property="FontSize" Value="75" />
        <Setter Property="HorizontalAlignment" Value="Center" />
      </Style>
    </StackPanel.Resources>
Looking for other OpenType fonts?
Gabriola happens to be a personal favorite, but you can also find several other fonts
included with the Windows SDK and the Sample OpenType Font Pack. This pack
includes Kootenay, Lindsey, Miramonte, Miramonte Bold, Pericles, Pericles Light,
Pescadero, and Pescadero Bold. Each of these fonts implements various OpenType
features.
Listing 10.13
Displaying text as all caps using OpenType
Figure 10.10
A comparison between 
normal text with capital letters and the 
AllSmallCaps OpenType setting

220
CHAPTER 10
Text fundamentals
    <TextBlock Typography.Capitals="Normal"/>
    <TextBlock Typography.Capitals="AllSmallCaps" />  
  </StackPanel>
</Grid>
As in the previous listing, listing 10.13 uses the same resource block to eliminate repe-
tition throughout the code. The key thing to notice here is the Typography.Capitals
attached property on the TextBlock.
10.3.4 Fractions and numbers
Numbers, and in particular fractions, present unique challenges when formatting
text for display. Numbers have different alignment needs than plain text, especially
when displaying a table of numbers to be added together. Numbers in fractions also
need to be displayed differently when they’re the numerator or denominator. Even
that changes if you consider side-by-side fractions versus the traditional top over bot-
tom fractions.
 Silverlight supports the different number alignment values through the Numeral-
Alignment and NumeralStyle attached properties of the Typography object. It even
supports turning slashed zeros on or off using the SlashedZero attached property.
Gabriola doesn’t do anything special in those instances, so you’ll leave them alone for
this example.
 If the OpenType font supports differ-
ent fraction representations, so does
Silverlight. Fortunately, Gabriola also
supports two of the three fractional repre-
sentations, as shown in figure 10.11.
 Unlike say, typing a lengthy document
in Microsoft Word and having auto-
substitution of fractions happen as you
type, in Silverlight, you still have separate
characters for each part of the fraction and aren’t limited to the basic less-than-one
fractions you normally get with substitution.
 When formatting, Silverlight and OpenType automatically figure out the numera-
tor and denominator based on the position of the slash character. That keeps your
markup clean. The following listing shows how to use this feature.
<Grid x:Name="LayoutRoot" Background="White">
  <StackPanel>
    <StackPanel.Resources>
      <Style TargetType="TextBlock">
        <Setter Property="FontFamily" Value="Gabriola" />
        <Setter Property="FontSize" Value="75" />
Listing 10.14
Representing fractions using OpenType
All caps
Figure 10.11
Normal and side-by-side slashed 
representations of fractions. I prefer the slashes 
over the normal.

221
OpenType font support
        <Setter Property="HorizontalAlignment" Value="Center" />
      </Style>
    </StackPanel.Resources>
   
    <TextBlock Text="1/2 2/3 5/4 6/8 112/37 Normal"   
               Typography.Fraction="Normal" />
    <TextBlock Text="1/2 2/3 5/4 6/8 112/37 Slashes" 
               Typography.Fraction="Slashed" />
    </StackPanel>
</Grid>
Listing 10.14 simplifies the style and removes the Text property setter; here you want
slightly different text in each TextBlock. The markup creates the text shown in figure
10.11. Note how you don’t need to specify numerator, denominator, or even super-
script and subscript to make the numbers line up. That’s all done automatically.
10.3.5 Variants, superscript, and subscript
Sometimes fractions are approximated using superscript and subscript text. That’s not
particularly accurate and can be a real pain to do in some cases. It’s much better to let
Silverlight handle that for you automatically. 
 Yet there are certainly times when you want to have control over superscript and
subscript text. Footnotes and chemistry are two places where superscript and subscript
prevail. 
 Superscript and subscript are supported by the Typography.Variants attached
property. Those aren’t the only two variants supported, though. Some fonts, eastern
fonts in particular, include support for several other variants, including Inferior,
Ordinal, and Ruby. You also have Normal for plain-old text.
 Figure 10.12 shows both Superscript and Subscript as well as Normal. Gabriola
doesn’t support any of the other variants.
 Unlike with fractions where the sizing is automatic, when using variants you need
to explicitly set the Typography.Variants property for each run of text you want
affected. Listing 10.15 shows the markup required for this example.
Normal
Slashes
Figure 10.12
This shows the use 
of superscript and subscript in text 
using the Typography.Variants 
attached property.

222
CHAPTER 10
Text fundamentals
<Grid x:Name="LayoutRoot" Background="White">
  <StackPanel>
    <StackPanel.Resources>
      <Style TargetType="TextBlock">
        <Setter Property="FontFamily" Value="Gabriola" />
        <Setter Property="FontSize" Value="75" />
        <Setter Property="HorizontalAlignment" Value="Center" />
      </Style>
    </StackPanel.Resources>
    <TextBlock>     
      <Run Text="H" Typography.Variants="Normal" />     
      <Run Text="2" Typography.Variants="Subscript" />    
      <Run Text="O" Typography.Variants="Normal" />
    </TextBlock>
    <TextBlock>
      <Run Text="i" Typography.Variants="Normal" />     
      <Run Text="2" Typography.Variants="Superscript" /> 
    </TextBlock>
    <TextBlock>
      <Run Text="This is text with a pithy footnote"
           Typography.Variants="Normal" />     
      <Run Text="27"
           Typography.Variants="Superscript" />
    </TextBlock>
    <TextBlock FontSize="40">
      <Run Text="27 "
           Typography.Variants="Superscript" />     
      <Run Text="This is the pithy footnote"
           Typography.Variants="Normal" />
    </TextBlock>
  </StackPanel>
</Grid>
As in the other examples, listing 10.15 uses a style to keep the listing short. You over-
ride the font size in the TextBlock that represents a footnote—another cool feature
of styles you’ll learn about in chapter 14.
 This example had a good bit more markup because, as mentioned, I had to set the
Normal, Superscript, or Subscript variant for each block of text. Also note how
these properties are available on the Run object inside a TextBlock as well. They’re
portable to just about anything using text.
 OpenType opens up a whole new world of typography options from the mundane
to the super fancy. Silverlight’s support for OpenType is excellent, supporting all
major features that a developer or designer could ask for. Although they won’t be
used in every application, you’ll find yourself able to use many of the features, espe-
cially variants and fractions, in business applications and more design-oriented appli-
cations alike.
 The text system always renders text using the specified font, a specified fallback or
a default fallback if unspecified or if the font is unavailable. If the font you’re using in
Listing 10.15
Superscript and subscript variants
Subscript
Superscript

223
Embedding fonts
your TextBlock or other control isn’t a standard font, you may want to consider
embedding it with your application. 
10.4
Embedding fonts
Sometimes you want to use a special font in your application. Maybe it’s the typeface
in use in your company logo. Sometimes it’s a slick headline font. Or perhaps it’s just
a sharp and readable font you want to use in your news reading application. I had this
issue when I built the trivia application that ran on the screens at the Microsoft Profes-
sional Developers Conference 2009. I had to use the PDC font but couldn’t guarantee
it’d be on the machines.
 What do you do when you can’t guarantee that end users will have that font on their
machines? One way to tackle this problem is to embed the font into the application.
Silverlight supports embedded fonts—whole fonts and subsets—in applications.
When not using font subsetting, you simply add the font to your project and mark it as
a resource. You can then refer to it by name using the format FileName#FontName:
<TextBlock FontFamily="Fonts/MSPDC.TTF#Microsoft PDC Squared" … />
The folder name Fonts is the location where the original TrueType font (TTF) file is
placed in the project. The name MSPDC.TTF is the name of the font file on disk, and
Microsoft PDC Squared is the name of the actual font.
 Packaging with font subsetting requires Expression Blend. Even if you use Visual
Studio, the required build action is supplied by Expression Blend and can be com-
piled in Visual Studio but must be created the first time in Blend. This makes sense,
because font subsetting and font embedding are designer-oriented tasks; most of us
programming grunts just default to Comic Sans MS and call it a day.
 To support subsetting—reducing the number of glyphs to only those used in the
application—the font is packaged up into a zip file and later referred to by its embed-
ded location. For example:
<TextBlock FontFamily="Fonts/Fonts.zip#Microsoft PDC Squared" … />
I’m not a lawyer
But that’s not going to stop me from giving pseudo-legal advice. Before you go and
embed that font, check its license. Most fonts don’t legally allow embedding in appli-
cations. In fact, most font designers haven’t even caught up with the idea that fonts
can be used outside of documents. 
Once the font foundries get out of the 1980s and start allowing more font embedding
in applications, UIs will start to shine.
In the meantime, I suggest you consult someone with a legal background before em-
bedding that font in your application.

224
CHAPTER 10
Text fundamentals
The folder name Fonts is the location where the original TTF file is placed in the proj-
ect. The zip name is the name Expression Blend generated for the archive, and the
name after the hash tag is the name after the font. Note that this can be different from
the TTF filename itself.
 The issue isn’t the technical aspect of embedding itself (it’s just a zip file embed-
ded into the DLL as a resource); it’s the act of subsetting the font that makes embed-
ding legal for those fonts that support it. Expression Blend creates a subset font that
has only the glyphs (characters) you use in your application.
 In short, though you may find a way to manually embed the fonts, you’re better off
trusting Expression Blend to do it for you.
 Once you have fonts embedded in your application, they can be used anywhere
you’d use a regular typeface. For example, you can use them in text boxes for gather-
ing text, which is the subject of the next chapter. 
10.5
Summary
Text handling is one of the most basic and important functions of any presentation
layer. Silverlight has a complete text stack, including support for subpixel rendering
and ClearType and grayscale font smoothing. Silverlight also includes the TextBlock
element, which may be used to display read-only text. 
 Though typically used for things such as field labels and description paragraphs,
the TextBlock supports multiple Runs of text, each with its own distinct attributes. 
 Silverlight can sometimes guess your intent, but as a UI designer who knows better
than you how the text will be used in your applications? Silverlight enables you to opti-
mize the performance, hinting and rendering of your text using the TextOptions
object and the attached properties it exposes. This gives you fine-grained control over
the rendering of text in your UI.
 OpenType fonts have an amazing amount of flexibility built into them. You proba-
bly use OpenType fonts all the time and don’t realize all the tweaking that goes on
automatically behind the scenes, and all the additional tweaking you could do. Silver-
light has excellent support for OpenType, including things like ligatures, variants,
style sets, alternates, and much more. It even has good support for eastern language
OpenType fonts—a must for great international applications.
 Any text element in Silverlight can take advantage of embedded fonts. Embedded
fonts are useful for situations where you have a custom font or one that’s unlikely to
be on end-user machines. Rather than compromise and use a different font, you can
embed the font or a subset of the glyphs in the font directly into your application.
 In the next chapter, you’ll further explore the text stack and learn how to enter
and edit plain text, as well as how to enter, edit, and display rich text.

225
Editing plain and rich text
Collecting and displaying text is a vital part of almost every web application. Silver-
light provides several controls designed to make this important task easy. Silverlight
supports standard keyboard text input as well as input from input method editors
(IMEs).
 The most basic text input control is the TextBox. For most forms and other sim-
ple data, this is the control you’ll use to capture input. TextBox supports all the
usual text entry functions, as well as multiline input.
 Similar to the TextBox but optimized for sensitive data is the PasswordBox. The
PasswordBox is what you should use when collecting passwords or other data you
want masked from view.
This chapter covers
■
Handling basic text input
■
Understanding input method editors
■
Moving text to and from the clipboard
■
Entering and editing rich text
■
Working with multicolumn and linked text 
layouts

226
CHAPTER 11
Editing plain and rich text
 Of course, if all that the platform supported were the display of text, you’d be pretty
limited in the types of applications you build. In addition to its display capabilities, Sil-
verlight includes first-class support for editing text, both plain and rich text formats.
 If you can enter and edit text, you may find yourself wanting to copy and paste it
between various applications. Silverlight also includes facilities to enable program-
matic manipulation of the clipboard to share data within the same application and
across applications.
 Plain text is useful in many typical editing scenarios, especially those you’d find
when working with fields in a business application. But for others such as free-form
comments, posts, and document creation, you may want richer text with embedded
formatting, images, and even UI elements. Silverlight includes the RichTextBox con-
trol, which can be used for both the display and editing of rich text, and the Rich-
TextBlock control, which is useful for displaying read-only rich text without the
overhead of editing capabilities.
 In the print world, it’s rare to find a magazine or newspaper article that spans the
entire page without using a column layout. Columns make it easier to read the text as
your eye muscles don’t have as far to move to scan a line of text. It also enables more
text layout options, more room for ads and sidebars, and more. Silverlight 5 intro-
duced support for multicolumn and free-form text layout.
 In this chapter, you’ll learn how to handle basic text entry with the TextBox. In
addition, you’ll see how to collect sensitive information, such as passwords, with the
PasswordBox. I’ll look at the ways to collect and format text simultaneously using the
RichTextBox and RichTextBlock controls, wrapping up with using the RichText-
Block to display multicolumn and linked text.
11.1
Handling basic text input
The TextBox control enables your users to edit and view text. As basic as this may
sound, it’d be difficult to consider a UI technology that didn’t include this type of
functionality. When a user enters text in a TextBox, it gets stored as a string in the
Text property. This property can be programmatically set at runtime, giving you the
ability to prepopulate a form. Optionally, this property value can be set at design time
if you have a more static value.
XAML:
<TextBox x:Name="NameField" Text="Pete Brown" />
C#:
TextBox nameField = new TextBox();
nameField.Text = "Pete Brown";
This example shows the XAML and C# definitions for a TextBox with a preset Text value.
This value will change if a user decides to change the contents of a TextBox. This
change will cause the TextChanged event to fire asynchronously, which gives you the
opportunity to respond to characters after they’re entered. You can also limit how many

227
Handling basic text input
characters a user can enter by setting the MaxLength property. Limiting the number of
characters can be useful for ensuring that data isn’t truncated when it’s sent back to a
data source. In addition, some of the values from a data source should only be seen, not
edited. In these cases, you can change the IsReadOnly property to true to prevent a
user from editing a TextBox. These basic members of a TextBox are useful, but the mul-
tiline and text selection features are perhaps even more interesting.
11.1.1 Enabling multiline text support
The TextBox has built-in support for handling multiline text input. By default, this fea-
ture is turned off. You can turn it on by toggling two of the properties of a TextBox con-
trol. These two properties, AcceptsReturn and TextWrapping, are shown in listing 11.1.
Result:
XAML:
<Grid>
  <Grid.RowDefinitions>
    <RowDefinition Height="Auto" />
    <RowDefinition />
  </Grid.RowDefinitions>
  <TextBlock Text="Description:" FontFamily="Verdana" FontSize="14" />
  <TextBox x:Name="myTextBox" AcceptsReturn="True" TextWrapping="Wrap" 
    FontFamily="Verdana" FontSize="14" 
    Grid.Row="1" Height="150" Width="450" />
</Grid>
Listing 11.1 shows a multiline TextBox enabled through the AcceptsReturn and
TextWrapping properties. The AcceptsReturn property is a bool that tells the Text-
Box whether to show and permit newline characters. This property is important
because it enables a user to press the Enter key and go to a new line within a TextBox.
A true multiline TextBox isn’t complete until the TextWrapping property is set to
Wrap. I discussed this property in relation to the TextBlock element in chapter 10;
those same rules apply with the TextBox. With this property and the AcceptsReturn
property, you can easily implement a multiline TextBox.
 Implementing a multiline TextBox in Silverlight is simple. This approach is slightly
different than the approach used in HTML, which requires a separate element alto-
gether (the TextArea). The Silverlight approach simplifies the overall API and pro-
vides exciting text selection features not found in HTML.
Listing 11.1
Multiline TextBox

228
CHAPTER 11
Editing plain and rich text
11.1.2 Mastering text selection
The TextBox has built-in support for
selecting portions of text within a
TextBox. A user can highlight informa-
tion and you can programmatically
retrieve it through three properties,
appropriately named SelectedText,
SelectionStart, 
and 
Selection-
Length. These properties can also be
programmatically set, which is espe-
cially useful when implementing incremental search and autocomplete functionality
in a TextBox. Each is shown in figure 11.1.
 The figure shows the three properties associated with text selection. The first prop-
erty is a string called SelectedText that represents the content currently selected
within a TextBox. This content has a specific length, which is available through the
SelectionLength property. This int gives you the number of characters currently
selected within a TextBox. These characters begin at a specific index, which is accessi-
ble through the SelectionStart property. When text isn’t selected, the Selection-
Start property will return the index of the carat. The selection properties are read/
write and allow you to programmatically change their values.
 Not all applications are written for the en-US market. If you’re writing applications
for other markets, especially where the languages have different characters, you’ll
want to understand IMEs and how they work with Silverlight. 
11.2
Understanding input method editors
IMEs are OS components or added programs
that allow, among other things, multiple key-
strokes to be composited into a single charac-
ter. This supports languages where there are
more possible characters than keys on the
keyboard or where the keyboard doesn’t have
the required character.
   IME text is important for handling text
from most Eastern languages. Figure 11.2
shows an example of a typical Japanese
Romaji-based IME in operation. 
    In this section, you’ll learn what IMEs are and
how to use them in Silverlight. You’ll even see
Figure 11.2
Operation of a typical Japanese 
Romaji-based IME (source: Wikimedia Commons)
Figure 11.1
The text selection parts: 
SelectedText, SelectionStart, and 
SelectionLength

229
Understanding input method editors
how to change your Windows keyboard settings to allow you to test the functions that
support IME in Silverlight.
 In Silverlight, the TextBox and other controls handle IME-entered text through
events defined at the UIElement-level. In particular, if you want your application to
work in IME situations, don’t respond to KeyDown/KeyUp events of the TextBox.
Instead, if you do use editing based on keystrokes, use the TextInput, TextInput-
Start, and TextInputUpdated events. Note that, depending on the IME mode in use
and the control you’re interacting with, some of these events may be handled by the
control and not otherwise bubbled up.
TIP
In Windows 7, to change your keyboard layout to US International (if
you’re in the United States) to test basic IME, use Start > Control Panel >
Region and Language. Then select the Keyboards and Languages tab and
click Change Keyboards.
If you already have the United States International keyboard listed, select it.
Otherwise click Add to add it, and then select it from the list.
From there, you can type diacritic characters. For example, to type the é in
Claudé, you’d select the US International keyboard from your system tray,
and type the single quote followed by the letter e. 
In addition, if you want finer control over IME in your application, use the Input-
Method class and the attached properties it exposes. For space reasons and to stay on
topic, I won’t cover those numerous options, but you’ll see an example of the differ-
ences between the keyboard and text input events. 
 To do that, you may want to set the InputMethod.IsInputMethodEnabled to true
on your TextBox. Although the underlying value of the IsInputMethodEnabled prop-
erty is true, its value is influenced by the state of available input methods at runtime.
Setting it to true isn’t essential but helps convey your intent, especially if you’ll be
handling IME events in code.
 Listing 11.2 shows the difference between the keyboard events and the text input
events. For example, to type the accented e in the first word, you must hit Shift-6 and
then the letter e.
Result:
Debug window output (shortened for clarity):
Down:A, TextInputStart:a, Up:A
Down:R, TextInputStart:r, Up:R
Down:R, TextInputStart:r, Up:R
Down:Shift, Down:D6, Up:D6, Up:Shift, Down:E, InputStart:ê, Up:E
Down:T, TextInputStart:t, Up:T,
Listing 11.2
Wiring up the TextInputStart event

230
CHAPTER 11
Editing plain and rich text
Down:E, TextInputStart:e, Up:E, 
Down:Z, TextInputStart:z, Up:Z
XAML:
<Grid x:Name="LayoutRoot" Background="White">
  <TextBox x:Name="FirstName"
           InputMethod.IsInputMethodEnabled="True"  
           Width="150"
           Height="24" />
</Grid>
C#:
public MainPage()
{
    InitializeComponent();
    FirstName.KeyDown += new KeyEventHandler(FirstName_KeyDown);
    FirstName.KeyUp += new KeyEventHandler(FirstName_KeyUp);
    FirstName.TextInputStart += 
       new TextCompositionEventHandler(FirstName_TextInputStart);
}
void FirstName_TextInputStart(               
           object sender, TextCompositionEventArgs e)
{
  Debug.WriteLine("InputStart:" + e.Text);
}
void FirstName_KeyUp(object sender, KeyEventArgs e) 
{
  Debug.WriteLine("Up:" + e.Key.ToString());
}
void FirstName_KeyDown(object sender, KeyEventArgs e) 
{
  Debug.WriteLine("Down:" + e.Key.ToString());
}
If you have an IME installed on your system or have changed your keyboard layout to
do so, you’ll be able to type diacritic characters using an IME.
 If you live and work in the United States, it can be tempting to create applications
that work only with US keyboards. But if you want to move your product to an interna-
tional market or at least understand what’s necessary to support those markets, you’ll
want to read up on internationalization, including input method editing on Windows
and the Mac.
 Input method editing is something not every application needs, but it’s a staple of
Windows development. Another staple of modern application development is the
clipboard. Think about how isolated our applications would be if we didn’t have a way
to get data from one to another! Luckily, Silverlight allows you to programmatically
access the clipboard to move text between applications. 
Optional IME 
enable
IME event
Standard
key events

231
Copying text with the Clipboard API
11.3
Copying text with the Clipboard API
Silverlight 4 added a new API for use with transferring text via the clipboard. Though
currently limited to just Unicode strings, the clipboard is an excellent way to enable
your Silverlight application to integrate with the rest of the applications on the host-
ing system.
 The Clipboard object is your Silverlight application’s interface to the system clip-
board. This section takes a quick look at the clipboard API and its capabilities, starting
with the three member functions of the Clipboard class. Table 11.1 shows the static
member functions exposed by this object.
Clipboard exposes static members, so you don’t need to instantiate it to use it. For
example, to place text on the clipboard, simply call Clipboard.SetText:
Clipboard.SetText("This text will be on the clipboard.");
Similarly, to retrieve this text or another application placed on the clipboard, call the
GetText method:
string text = Clipboard.GetText();
Note that, in both cases, you’ll receive a security exception if you’re running in
the standard (not elevated) permissions mode and either you didn’t initiate the
action from a user event or the user didn’t allow access to the clipboard when
prompted to do so. Figure 11.3 shows the prompt the user sees when you initiate a
clipboard operation.
 The prompt helps to protect the user from potentially malicious applications that
may try to steal data from the clipboard or fill the clipboard with garbage.
Table 11.1
The Clipboard type’s static member functions 
Member
Description
ContainsText
Queries the clipboard and returns true if the clipboard contains compatible text
GetText
Returns the Unicode text from the clipboard
SetText
Places Unicode text on the clipboard
Figure 11.3
The clipboard access 
prompt. When running in standard 
permissions (sandboxed) mode, 
Silverlight displays this when you 
attempt to access the clipboard 
from the application.

232
CHAPTER 11
Editing plain and rich text
One thing you probably won’t want to allow on the clipboard is a user’s password. For
that and for masking reasons, Silverlight includes a specialized PasswordBox.
11.4
Collecting sensitive data
Silverlight provides a special control called PasswordBox which is designed to hide
information from someone who may be lurking behind a user. This is accomplished
by hiding the contents of a PasswordBox behind asterisks (*), which serve as familiar
reminders to end users that they’re entering a password. But if you’d like to use some-
thing other than an asterisk, you’re free to use any character you like by setting the
PasswordChar property. This property, as well as the syntax of a PasswordBox, is shown
in listing 11.3.
Result:
XAML:
<Grid>        
  <Grid.RowDefinitions>
    <RowDefinition Height="Auto" />
    <RowDefinition Height="Auto" />
  </Grid.RowDefinitions>
  <Grid.ColumnDefinitions>
    <ColumnDefinition Width="Auto" />
    <ColumnDefinition Width="Auto" />
  </Grid.ColumnDefinitions>
  <TextBlock Text="Password: " FontFamily="Verdana" />
  <PasswordBox Width="200" Grid.Column="1" />            
  <TextBlock Text="Confirm: " FontFamily="Verdana" Grid.Row="1" />
  <PasswordBox PasswordChar="#" Width="200"        
    Grid.Column="1" Grid.Row="1" /> 
</Grid>
This example shows a default PasswordBox and a custom PasswordChar to show how
Silverlight takes a small step beyond the masking approach used in HTML. Still, once a
user enters information into these fields, you’ll probably need to retrieve it. Doing so
is possible thanks to the Password property.
 The Password property is a string that represents the value in a PasswordBox.
This property can be programmatically set and retrieved. Interestingly, this value can’t
be copied or cut at runtime by a user. This restriction is designed to ensure a user’s
password remains protected, short of hacker heroics such as wiring a debugger to the
code and inspecting values. To provide this feature, along with the general input con-
trol features, the PasswordBox needs to derive from the Control class instead of the
TextBox class. 
Listing 11.3
The syntax for the PasswordBox—note the mask used in each field
Default mask 
character
Custom mask 
character

233
Entering and displaying rich text
 The PasswordBox and TextBox are two controls used for capturing user input. But
they’re limited in how the text can be formatted. Unlike the TextBox, the RichText-
Box allows the user to have a true document experience with multiple fonts and styles. 
11.5
Entering and displaying rich text
From email composition to document creation, I’ve gotten so used to the simplicity of
creating text with multiple fonts, colors, and font styles that, when I see a multiline
text box with no formatting control, it simply looks strange. Prior to the introduction
of the RichTextBox in Silverlight 4, Silverlight had no way of allowing the user to
enter formatted text. 
 The RichTextBox follows many of the same patterns as the regular TextBox but
enhances it with the ability to store the formatting information such as fonts and col-
ors. The RichTextBox also takes it one step further by allowing the embedding of
images and other UI elements, even controls, into the text.
 In our tour of the RichTextBox control, I’ll show you how to format text using dif-
ferent fonts and colors, how to embed hyperlinks in rich text, and even how to embed
other controls such as the Button and ComboBox. You’ll want your users to actually
work with your text, so I’ll explain what it takes to work with the text the user has
selected or text you select from code and then change its attributes.
 Because the main reason the RichTextBox exists is to enable the display and edit-
ing of text with multiple fonts, colors, and other visual attributes, let’s start there.
11.5.1 Formatting and inline elements
The RichTextBox enables you to format text and add elements inline. This includes
formatting tags, text spans, other controls, and—perhaps the most important and
most basic of these elements—the Paragraph.
PARAGRAPHS
The Paragraph element enables you to break the text in the RichTextBox into one or
more separate paragraphs. Each paragraph can have its own formatting independent
of the overall control. 
 Listing 11.4 shows three different paragraphs, each with separate formatting inde-
pendent of the overall control’s formatting.
Result:
Listing 11.4
RichTextBox showing paragraphs with different formatting and alignment

234
CHAPTER 11
Editing plain and rich text
XAML:
<RichTextBox x:Name="RichText"
             Width="350"
             Height="200">
  <Paragraph>                  
    This is the first paragraph of the text I'm going to place 
    in this RichTextBox. It has two sentences. Actually, it has
    three sentences.
  </Paragraph>
  <Paragraph TextAlignment="Justify"
             FontWeight="Bold">
    This is the second paragraph, and its text is set to 
    justify, as you can tell from the pretty screen shot. 
    Please note that the last sentence in the paragraph is not 
    justified.
  </Paragraph>
  <Paragraph TextAlignment="Right">
    One ring to rule them all, one ring to bind them. One ring 
    to bring them all, and in the darkness bind them, in the 
    land of Mordor where the Shadows lie.
  </Paragraph>
</RichTextBox>
Listing 11.4 shows several interesting features. First, the text in a RichTextBox can be
easily broken apart into separate paragraphs. The second feature is that each of those
paragraphs can have formatting separate from the others. In this case, I used different
text alignment on each of them and also set the middle paragraph to be bold.
 In addition to setting the styles at a paragraph level, you can surround blocks of
text with formatting markup, called inline styles.
INLINE STYLES AND SPANS
If formatting could be applied only at the paragraph level, the RichTextBox wouldn’t
be all that useful. Luckily, formatting can be applied at a much finer-grained level
using inline formatting elements such as Bold, Italic, and the versatile Span. Listing
11.5 shows several formatting approaches in a single paragraph.
Result:
XAML:
<RichTextBox x:Name="RichText"
             Width="350"
             Height="125">
  <Paragraph TextAlignment="Left">
    One <Bold>ring</Bold> to <Span Foreground="Red">rule them all</Span>, 
Listing 11.5
Inline styles and spans in the paragraph text
Paragraph

235
Entering and displaying rich text
    one ring to find them. <Italic>One</Italic> ring to bring them all, 
    and in the darkness bind them, <Span FontSize="18">in the land of 
    Mordor where the Shadows lie.</Span>
  </Paragraph>
</RichTextBox>
The listing shows the use of the Bold and Italic inline styles, as well as Span. Bold
and Italic are handy shortcuts, but Span is the most flexible of the three, supporting
myriad formatting options. Span itself inherits from Inline and from that gets a num-
ber of useful properties. Chapter 10 goes into detail about the commonly used prop-
erties shared by the Span, TextBlock, and Run elements. (The screenshot here is of
the runtime result.)
 In addition to these inline styles, the RichTextBox supports LineBreaks via the
LineBreak element: 
One ring to rule them all,<LineBreak />
one ring to find them.<LineBreak />
As expected, the LineBreak element causes the text following it to start on a new line.
You can think of the paragraph tag like the HTML <p></p> pair, and the LineBreak
element much like the HTML <br /> tag.
 One thing that the other text-display controls can’t include is a hyperlink. The
RichTextBox is currently unique in its ability to display active Hyperlink controls.
INLINE HYPERLINKS
The RichTextBox has the ability to host any UIElement, but it has first-class support
for hosting Hyperlinks without requiring any special containers or other work on
your part while keeping them active even for editable text. This makes it easy to dis-
play HTML-like text with embedded links.
 Listing 11.6 shows two Hyperlink elements embedded in the RichTextBox control.
Result:
XAML:
<RichTextBox x:Name="RichText"  
             IsReadOnly="True"            
             Width="350"
             Height="125">
  <Paragraph TextAlignment="Left">
    One ring to <Hyperlink NavigateUri="http://manning.com">rule 
    them all, one ring to find</Hyperlink> them. <Italic>One
    </Italic> ring to bring them all, and in the darkness bind them,
    <Hyperlink NavigateUri="http://10rem.net"><Span FontSize="18">in 
Listing 11.6
Hyperlink support in the RichTextBox
Read only

236
CHAPTER 11
Editing plain and rich text
    the land of Mordor where the Shadows lie.</Span></Hyperlink>
  </Paragraph>
</RichTextBox>
The listing shows the use of two hyperlinks embedded in the paragraph text. Note how
the hyperlinks also have support for cleanly nesting Spans and other formatting ele-
ments. For the HyperLink element to work, the RichTextBox must be set to read-only.
The Hyperlink element in the RichTextBox is a fully functional Silverlight Hyperlink
control, but it’s not the same as the one you’d place in regular XAML. Instead, it
derives from Span. You can still wire up Click events, supply a NavigateUri as done
here, and otherwise do everything you’d expect to be able to do with a Hyperlink.
The Hyperlink control itself is covered in more detail later in this chapter.
 In addition to the Hyperlink control, RichTextBox includes support for hosting
any other UIElement through the use of InlineUIContainer.
INLINE IMAGES AND ELEMENTS
The RichTextBox control allows you to embed any UIElement inline into the text, as
long as you contain it in an InlineUIContainer.
 The catch is that the elements won’t be active; they’ll only show their disabled rep-
resentation unless the RichTextBox is set to read-only mode via the IsReadOnly prop-
erty, as shown in listing 11.7.
Result:
XAML:
<RichTextBox x:Name="RichText" IsReadOnly="True"
             Width="350" Height="150">
  <Paragraph TextAlignment="Left">
    One 
    <InlineUIContainer>
Error when clicking the hyperlink
You’ll find descriptions of errors with the HyperLink element all over the web. In gen-
eral, it has to do with cross-scheme navigation (the same thing that can prevent images
from loading). If you aren’t hosting your Silverlight application in a website, you can’t
have a http:// URL in a hyperlink in the RichTextBox. Yet another great reason to
always let Visual Studio create a website to host your Silverlight project!
Listing 11.7
A mad-lib of a RichTextBox showing embedded controls

237
Entering and displaying rich text
      <Button Content="Ring" />
    </InlineUIContainer>
    to rule them all, one ring to find
    <InlineUIContainer> #A
      <ComboBox SelectedIndex="0">
        <ComboBox.Items>
          <ComboBoxItem Content="Mr. Book" />
          <ComboBoxItem Content="Mr. Hand" />
          <ComboBoxItem Content="Deckard" />
        </ComboBox.Items>
      </ComboBox>
    </InlineUIContainer>
    One ring to bring them all, and in the 
    <InlineUIContainer> #A
      <ComboBox SelectedIndex="0">
        <ComboBox.Items>
          <ComboBoxItem Content="darkness bind them" />
          <ComboBoxItem Content="darkness find them" />
          <ComboBoxItem Content="snarkiness unwind them" />
        </ComboBox.Items>
      </ComboBox>
      </InlineUIContainer>
      in the land of 
      <InlineUIContainer> #A
        <StackPanel>
          <RadioButton Content="Mordor" />
          <RadioButton Content="Dark City" />
          <RadioButton Content="Tatooine" />
        </StackPanel>
      </InlineUIContainer>
      where the
      <InlineUIContainer>   
        <TextBlock Text="shadows lie.">
          <TextBlock.Effect>
            <DropShadowEffect BlurRadius="2" />
          </TextBlock.Effect>
        </TextBlock>
      </InlineUIContainer>
    </Paragraph>
</RichTextBox>
As listing 11.7 shows, you can do some neat things with the inline UIElements, includ-
ing adding items with effects such as drop shadows. The example shown may be a
complete mess of a UI, but the ability to embed controls of any sort into a rich text
interface opens up the options for creating your own UI, especially for scripted ques-
tionnaires and similar free-flowing interfaces.
 Getting back to basic text manipulation, one thing you may need to do is program-
matically select text or work with a selection a user has made. The nature of rich text
makes this slightly more complex than plain text, as you’ll see in the next section.
11.5.2 Working with selected text
Programmatic manipulation of the RichTextBox beyond reading or writing the entire
contents requires that you work with selections. The selections may be set in code, or
InlineUIContainer

238
CHAPTER 11
Editing plain and rich text
you may be taking an action based on a selection the user has made. Either way, the
methods are consistent.
SELECTION
There may be times when you need to programmatically select content in the Rich-
TextBox. For example, if you’re doing a search and replace, the Find Next function
should search the content for the next occurrence of the search term and automati-
cally select it. The RichTextBox exposes the Selection property, which has a Select
function to support programmatic selection.
 The Select method takes two parameters, both of type TextPointer: the anchor-
Position and the movingPosition. If you think about how you select text with a
mouse, you start with one point that stays fixed in place, and you move the mouse cur-
sor, changing the selection relative to that point. Similarly, the anchorPosition
remains fixed and the movingPosition is the second or movable point.
 Figure 11.4 shows the three main data
points of interest. The first, the Selection
.Text property, is a public read/write prop-
erty that enables you to read or modify the
text inside the two points.
 The anchorPosition is the place where
you or the user (or your code) started the
selection. The movingPosition is the end
of the selection.
 Note that, unlike the case with the
TextBox, you’re not dealing with numeric
values for the start points and endpoints.
Instead, you have pointers to the text. Though this approach can make the RichText-
Box slightly more complex to work with, it supports the addition of nonvisible markup
and the flexibility of adding text between points when the replacement character
count isn’t the same as the number of characters being replaced in the original text.
For example, you can replace 3 characters with 5—or 1—using this approach.
 Listing 11.8 shows how to use the anchorPosition and movingPosition Text-
Pointer objects to programmatically select text in the control.
Result:
Listing 11.8
Programmatically selecting text in the RichTextBox
Figure 11.4
RichTextBox selection 
information, assuming the user selected left to 
right, starting with the first T in “turtles”

239
Entering and displaying rich text
XAML:
<StackPanel>
  <RichTextBox x:Name="RichText" Margin="10"
               Width="350" Height="150">
    <Paragraph TextAlignment="Left">
      <Bold>We're off to outer space</Bold><LineBreak />
      We're leaving Mother Earth<LineBreak />
      To save the human race<LineBreak />
      <Italic>Our Star Blazers</Italic>
    </Paragraph>
    <Paragraph TextAlignment="Left">
      <Bold>Searching for a distant star</Bold><LineBreak />
      Heading off to Iscandar<LineBreak />
      Leaving all we love behind<LineBreak />
      Who knows what danger we'll find?
    </Paragraph>
  </RichTextBox>
  <Button Content="Select Next 10" Click="SelectNext_Click"
          Width="150" Margin="10" />
</StackPanel>
C#:
private void SelectNext_Click(object sender, RoutedEventArgs e)
{
  TextPointer start = RichText.Selection.Start;  
  TextPointer end = start; 
  end = start.GetPositionAtOffset(10, LogicalDirection.Forward);
  RichText.Selection.Select(start, end);            
  RichText.Focus(); 
}
The code in listing 11.8 takes the Selection.Start, which by default is where the
caret is currently positioned, and adds 10 characters and ends the selection. The end
result is the visible text selection.
 Selecting text itself is interesting, but it’s more interesting to manipulate the con-
tents of the selection.
CHANGING SELECTION PROPERTIES
Once either the user or code has made a selection, you can alter the properties of that
selection via code. For example, you can change the font face, the weight, the fore-
ground, and other properties for the selection.
 If you want to set the foreground color of the 10 characters to Red, alter the code
in listing 11.8 to add the following ApplyPropertyValue call, passing the Foreground
dependency property and a brush with the color red:
RichText.Selection.Select(start, end);
RichText.Selection.ApplyPropertyValue(
    TextElement.ForegroundProperty, new SolidColorBrush(Colors.Red));
RichText.Focus();
Similarly, you can call GetPropertyValue to get the value of a dependency property
for the selected text.
Start is 
current 
position
Start is 
current 
position X
Perform selection

240
CHAPTER 11
Editing plain and rich text
REPLACING TEXT
Once you have a valid selection, you can also replace the text with your own plain text.
The Selection.Text property is a two-way street: you can read the text that’s in the
selection and you can assign new text to it. Again modifying listing 11.8, this will
replace the 10 characters with haha!!:
RichText.Selection.Select(start, end);
RichText.Selection.Text = "haha!!";
RichText.Focus();
Replacing text is a good common operation, but what about inserting new text with-
out overwriting something else? For that, you’ll want to use the Selection.Insert
method.
INSERTING NEW TEXT
In addition to replacing the selected text, you can insert new text anywhere you create
a selection start point. In this example, you’ll modify listing 11.8 and insert text wher-
ever the caret happens to be positioned:
private void SelectNext_Click(object sender, RoutedEventArgs e)
{
  Run run = new Run();
  run.Text = "This is some text we're going to insert";
  RichText.Selection.Insert(run);
  RichText.Focus();
}
Although Runs can be implicit in XAML, the Insert method requires a Run element,
or something that derives from Run. You can click the button as many times as you’d
like and it’ll happily insert new text wherever the caret is positioned.
RETRIEVING RICH TEXT AS XAML
Because it’s Silverlight, you’d expect to have some way to get the XAML representation
of the selected text—and you’d be right. The Selection type exposes a Xaml property
that returns the XAML for the selection. Modify listing 11.8 to include the following
code to see the XAML representation of the text:
RichText.Selection.Select(start, end);
Debug.WriteLine(RichText.Selection.Xaml);
RichText.Focus();
If you wish to get the XAML for the entire control, first call the SelectAll method,
then retrieve the XAML.
RichTextBox is a powerful control that allows you to create applications with seri-
ous text editing requirements. It builds on the concepts from the TextBlock and
TextBox, and combines them with inline formatting, Hyperlinks, and UIElements to
create a versatile Silverlight control for both the display and editing of rich text. Simi-
lar to the RichTextBox but read-only is the RichTextBlock control, which may also be
used for multicolumn and free-form text layout.

241
Multicolumn and free-form linked text
11.6
Multicolumn and free-form linked text
One feature that has been requested in HTML and XAML since the beginning of time1
(WPF Flow Documents notwithstanding) is the ability to have linked and multicolumn
text. This enables magazine and newspaper-style layouts, and gives designers more
flexibility when laying out the content in applications.
 In Silverlight, multicolumn and free-form linked text both build on the RichText-
Block control, which is itself a lightweight read-only RichTextBox control like that dis-
cussed in section 11.5. Though the same in core implementation, multicolumn and
free-form layout are usually considered separate layout models by designers, so I’ll
treat them separately here.
11.6.1 Multicolumn text
The easiest way to use linked text is to have multiple columns. Fortunately, this is also
one of the most commonly requested text scenarios for Silverlight and for web appli-
cations in general.
 The implementation in Silverlight doesn’t limit you to an arbitrary number of col-
umns. Instead, a RichTextBlock may be linked to a single RichTextBlockOverflow
element.
 In figure 11.5, you can see two columns of text. The text freely flows from the first
column to the second should you resize the screen or otherwise change the size of the
1 Yes, the Beginning of Time. The request for multicolumn text in HTML originally appeared on a cave wall in
southern France, apparently painted during the time the HTML 2 spec was being drafted.
Figure 11.5
Two columns 
created using a single 
RichTextBlock and a 
single RichTextBlock-
Overflow element

242
CHAPTER 11
Editing plain and rich text
first column. Listing 11.9 shows the markup required to create the two-column layout
with text overflow.
<Grid x:Name="LayoutRoot" Background="White" Margin="10">
  <Grid.ColumnDefinitions>
    <ColumnDefinition Width="*" />
    <ColumnDefinition Width="*" />
  </Grid.ColumnDefinitions>
        
  <RichTextBlock Grid.Column="0" Margin="4"
       OverflowContentTarget="{Binding ElementName=SecondColumnText}"
       FontSize="15">
    <Paragraph>
      Good morning. In less than an hour, aircraft from 
      here will join others from around the world. And 
      you will be launching the largest aerial battle 
      in this history of mankind.
      <LineBreak />
    </Paragraph>
    <Paragraph>
      Mankind - that word should have new meaning for all of us today.
     <LineBreak />
    </Paragraph>
...
    <Paragraph>
      Today, we celebrate our Independence Day!
      <LineBreak />
    </Paragraph>
  </RichTextBlock>
  <RichTextBlockOverflow x:Name="SecondColumnText"   
                       Grid.Column="1"
                       Margin="4"/>
</Grid>
For brevity, I left out most of the paragraphs of text in this example. The two things to
focus on are the OverflowContentTarget property of the RichTextBlock and the
name assigned to the RichTextBlockOverflow. Notice how the listing uses element
binding (covered in chapter 16) to link the RichTextBlock to the RichTextBlock-
Overflow. This is the standard way to link the two elements together in markup.
 For a given stream of text, you’ll only have one RichTextBlock, which holds the
actual text. But you may have as many RichTextBlockOverflow elements chained
together as you want. In fact, that’s what makes free-form text layout possible.
11.6.2 Free-form text layout
If you have a magazine handy, put this book down for a moment and go grab it. I’ll
wait. Now flip through the pages and take a hard look at how text is laid out. You’ll
notice that the text often wraps around ads, callouts, photographs, and other incur-
sions into the column layout. 
Listing 11.9
Multicolumn text using a RichTextBlock
Overflow
Overflow 
target

243
Multicolumn and free-form linked text
Free-form text layout is based on the same concepts and basic implementation as
multicolumn text. Instead of having just two linked blocks, though, you’ll end up
with as many as you need to smoothly wrap around the elements on the page (see
figure 11.6).
 In the example figure, there is
one RichTextBlock for the callout
in the middle, one RichTextBlock
for the text at the top left, and five
RichTextBlockOverflow elements
containing the remaining text. Fig-
ure 11.7 illustrates the layout of the
various elements.
 Are you can see, the more com-
plex the shape, the more elements
you’ll need to link together to wrap
around them. Incidentally, if you
refer to figure 11.6, you can see
that text selection works between
overflow elements, making them
transparent to the end user, so
there’s no usability penalty for this
type of layout.
Figure 11.6
This free-form 
layout shows five RichText-
BlockOverflow elements 
linked to a single RichText-
Block control to provide free-
form layout around a callout in 
the middle of the page. Note 
that text selection correctly 
spans multiple linked elements.
RichTextBlock
RichTextBox
Figure 11.7
The arrangement of RichTextBlock
and RichTextBoxOverflow elements required to 
wrap around the central callout text, which happens to 
be a RichTextBox, although a RichTextBlock 
could’ve been used there as well

244
CHAPTER 11
Editing plain and rich text
Listing 11.10 shows the markup required to create this free form layout illustrated in
figures 11.6 and 11.7. You can adapt this code to handle just about any text layout
situation.
<UserControl x:Class="FreeFormLinkedTextDemo.MainPage"
      xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
   xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
  <Grid x:Name="LayoutRoot" 
        Margin="10" Height="640" Width="650"  Background="White">
    <Grid.ColumnDefinitions>
      <ColumnDefinition Width="*" />
      <ColumnDefinition Width="*" />
    </Grid.ColumnDefinitions>
        
    <Line X1="315" X2="315" Y1="0" Y2="600" Stroke="Black" />
    <RichTextBlock Margin="4,4,14,0"             
           FontSize="13"
           OverflowContentTarget="{Binding ElementName=Overflow1}"
           Height="122" VerticalAlignment="Top">
      <Paragraph>
        Look again at that dot. That's here. That's home...
      </Paragraph>
      ...
      <Paragraph>
        It has been said that astronomy is a humbling ...
      </Paragraph>
    </RichTextBlock>
    <RichTextBlockOverflow x:Name="Overflow1"
        OverflowContentTarget="{Binding ElementName=Overflow2}"
        Margin="4,120,0,0" Height="178" Width="154"
        VerticalAlignment="Top" HorizontalAlignment="Left" />
    <RichTextBlockOverflow x:Name="Overflow2"
        OverflowContentTarget="{Binding ElementName=Overflow3}"
        Margin="4,291,14,17" />
    <RichTextBlockOverflow x:Name="Overflow3"
        OverflowContentTarget="{Binding ElementName=Overflow4}"
        Grid.Column="1" Margin="15,4,4,0" Height="122"
        VerticalAlignment="Top" />
    <RichTextBox x:Name="Callout"     
        BorderThickness="0"
        Background="Beige"
        Padding="8" FontSize="15"
        Grid.ColumnSpan="2" Margin="164,123,164,351"
        HorizontalScrollBarVisibility="Disabled"
        VerticalScrollBarVisibility="Disabled">
      <Paragraph FontStyle="Italic" 
                 FontFamily="Times New Roman" FontSize="18">
        I've seen things you people wouldn't believe. Attack ships on fire 
Listing 11.10
Two columns free-form wrapping around a central callout
Source text
Callout not linked

245
Summary
off the shoulder of Orion. I watched C-beams glitter in the dark near the 
Tannhauser gate. All those moments will be lost in time... like tears in 
rain.
      </Paragraph>
    </RichTextBox>
    <RichTextBlockOverflow x:Name="Overflow4"
        OverflowContentTarget="{Binding ElementName=Overflow5}"
        Margin="0,118,12,0"
        Grid.Column="1" Height="171" Width="138"
        VerticalAlignment="Top"
        HorizontalAlignment="Right" />
    <RichTextBlockOverflow x:Name="Overflow5"       
        Margin="15,291,4,11" Grid.Column="1" />
  </Grid>
</UserControl> 
As before, I’ve left out most of the text in order to keep the listing relatively brief. In
this markup, the source RichTextBlock is the start of an overflow chain that flows—in
order—to Overflow1 through Overflow5 elements.
 The addition of the RichTextBlockOverflow element and the OverflowContent-
Target property have made a variety of new layout scenarios possible, from multicol-
umn text to a carefully crafted free-form text layout. Although not quite at the level of
convenience something like dedicated publishing software provides, these new capa-
bilities are a welcome addition to Silverlight’s text-handling stack.
11.7
Summary
Silverlight, as you have learned in this chapter, has several ways for entering and dis-
playing text. There’s significant overlap between them, but each has its own niche
where it performs best. Table 11.2, adapted from information from MSDN, summarizes
how you should think of each control or element when trying to decide between them.
Table 11.2
Recommended uses for the various text display and editing elements
Scenario
Recommended element
Display unformatted text in a single font
TextBlock
Display formatted text including paragraphs, hyperlinks, images, 
multiple fonts, and styles
RichTextBlock
Enter or edit formatted text including paragraphs, hyperlinks, images, 
multiple fonts, and styles
RichTextBox
Enter or edit plain text, such as that used for data entry of a single 
field like a person’s name
TextBox
Layout text in multiple columns, or a free-form layout, with automatic 
text overflow
RichTextBlock, 
RichTextBlockOverflow
Enter sensitive information, such as a password, which must be 
masked for display
PasswordBox
Final overflow

246
CHAPTER 11
Editing plain and rich text
Choosing the correct one for any given situation means balancing the runtime
resources required with the features desired. In general, the elements from lightest to
heaviest in terms of runtime resource requirements are:
1
TextBlock
2
TextBox
3
RichTextBlock
4
RichTextBox
So, although replacing all the TextBlock elements in your application with read-only
RichTextBox controls or the new RichTextBlock controls in order to allow for select-
able formatted text may seem appealing, you need to test that substitution in your spe-
cific scenario and see if the runtime trade-off is worth the additional functionality. All
three controls can display multibyte and right-to-left text and support the use of IMEs.
 The TextBlock lives in the System.Windows.Controls namespace, but unlike
TextBox, RichTextBox, and RichTextBlock, it’s not actually a Control. This keeps it
lightweight but means that some properties have to be duplicated between TextBlock
and System.Windows.Control.Control. In the next chapter, you’ll learn about the
various types of controls in the Silverlight runtime and how they all fit together.

247
Control basics and
UserControls
The previous chapter covered the basics of text, including how to display and edit
it. Two of the items discussed—TextBox and RichTextBox—are controls. The
TextBlock isn’t.
 If you’re coming from another technology, you may assume that anything you
can see or interact with is a control, and you’d be partially right. Interaction gener-
ally requires a Control, but seeing something such as a TextBlock requires only
that it be a UIElement (covered in chapter 7).
 In this chapter you’ll explore the base control types Control and Content-
Control, then dive into the various types of controls, including Button controls
and ItemsControls. In your Silverlight travels, you’ll find that understanding these
This chapter covers
■
Understanding the control base types
■
Working with button controls
■
Working with items controls
■
Creating your own UserControls
■
Implementing dependency properties

248
CHAPTER 12
Control basics and UserControls
categories of controls will be pretty much all you need to make sense of any new
control you run across.
 Toward the end of this chapter, you’ll also take your first trip into creating controls
of your own. In this case, you’ll follow the simple reuse model: the UserControl. I cov-
ered the UIElement and FrameworkElement in chapter 7, so let’s continue our walk up
the stack and take a look at the base Control type.
12.1
Control
Almost every element you’ll deal with that accepts input in some form derives from
Control. Even the pages and user controls you create in your application ultimately
end up deriving from this type. It’s also the lowest-level type you can typically get away
with when trying to share styles (see chapter 14) between different elements.
 The System.Windows.Controls.Control abstract class derives from Frame-
workElement. Along with a number of protected methods that the derived controls
can override to provide additional functionality, Control adds a number of new pub-
lic properties and methods. I’ll break these up into several logical groups and cover
them separately, starting with appearance, then navigation and state, then the support
for control templating.
12.1.1 Appearance
Controls are visual by definition. For that reason, several properties can be shared as a
baseline implementation for anything visual and potentially interactive. The appear-
ance-related properties for Control are shown in table 12.1.
The Background property is used to hold the background brush of the control. This
can be a simple color or a complex gradient. Similarly, the BorderBrush property does
the same for the brush used to paint the border. The BorderThickness is a size to be
used to control the pen weight or thickness of the border for the control. The Fore-
ground brush should be used when displaying text or other content for which the user
Table 12.1
Visual style properties for the Control abstract type 
Member
Description
Background
The brush used to paint the background
BorderBrush
The brush used to paint the border
BorderThickness
The thickness of the border line
Foreground
The color used for foreground elements
Padding
The amount of space to reserve between the control’s 
exterior and interior
HorizontalContentAlignment
Controls how the internal control content is aligned
VerticalContentAlignment
Controls how the internal control content is aligned

249
Control
hasn’t provided a specific color in a child element. The last three—Padding,
HorizontalContentAlignment, and VerticalContentAlignment—all control how the
content will be displayed.
 It’s important to know that no specific UI is implied by these properties. The con-
trol author (or person creating the style/template) is required to apply these proper-
ties to specific elements in the template in order to make them meaningful. Common
sense would say that a BorderBrush should control the color of the outline of the con-
trol, but you won’t get a compile-time error if you go against that.1
 Two other common traits that controls share are the ability to be navigated to via
mouse and keyboard and the ability to be set as either enabled or disabled.
12.1.2 Tab navigation and control state
Silverlight controls also support Tab-key navigation as well as manual focusing via the
mouse or API. The properties and methods that support that functionality are shown
in table 12.2.
IsEnabled controls the enabled state for the control. If IsEnabled is false, the
expected behavior is that the control won’t accept any keyboard, mouse, or other
human input and isn’t considered a tab stop. It should also display itself using a faded
or grayed-out look to convey this state.
 The Focus method may be used to attempt to manually set focus to a control via
code. If the control can’t receive focus (for example, IsEnabled is false), the method
will return false.
 Three properties control tab navigation for the control. The first—IsTabStop—
controls whether the Tab key can be used to access the control. The TabIndex con-
trols the order within the container that the Tab key will navigate between controls.
Lower-numbered controls come earlier in the tabbing sequence. The TabNavigation
property controls how tabbing works for elements hosted inside this control. The pos-
sible values and their meanings are listed in table 12.3.
1  Going against convention is a good way to exercise your telephone support staff. 
Table 12.2
Navigation and state members for the Control abstract type 
Member
Description
IsEnabled
Set to true if this control is in a state where it can accept user interaction.
IsTabStop
True if the user can tab into this control.
TabIndex
The tabbing position of this control, relative to its peers in the same panel.
TabNavigation
Controls how the Tab key navigates in this control. It can cycle, be local, or be 
a one-stop navigation. 
Focus method
Calling this method attempts to set focus to the control.

250
CHAPTER 12
Control basics and UserControls
If you were to create a composite control, such as the LockableListBox at the end of
this chapter, Local tab navigation would be the expected behavior. But if you cre-
ated a ListBox-like control, you’d expect the Once behavior because you’d use the
arrow keys to navigate between the individual items.
 The next key area of support in the Control type is templating. Templates give
Silverlight controls their appearance and user experience.
12.1.3 Templating
One important feature that the controls add over the base type is the ability to tem-
plate the control. As you’ll learn in section 14.3, a template is a definition for the visual
representation of the control. By default, controls in Silverlight are defined by their
model and functionality. The UI elements can be completely replaced; they’re consid-
ered lookless controls. Table 12.4 shows the properties and methods that support
templating.
The Template property enables this flexible control templating. The DefaultStyle-
Key property is used by control authors to wire up the control to a default style and
template, something that may be overridden by consumers of the control. Controls
override the ApplyTemplate method with the code used to rebuild the visual tree for
the control, using the supplied template.
Table 12.3
Possible values for the TabNavigation property 
Member
Description
Local
Your control is tabbed into. The next tab starts going through the child elements. Once the 
last child element is focused and the user hits Tab, the next element outside of your main 
control receives focus.
Cycle
Once this control is tabbed into, individual controls inside this control may be navigated to 
using Tab. When the last child control has been reached and the user hits Tab, the first one 
will receive focus again. Doing this effectively traps the user inside your control until he 
clicks elsewhere. Give strong consideration to not using this unless you have to.
Once
Individual child elements other than the first one don’t receive focus via the tab control.
Table 12.4
Styling and templating properties for the Control abstract type 
Member
Description
DefaultStyleKey
This is the key of the style to be used when no other style is assigned. 
Typically, it’s set to the type of the class and, therefore, uses an implicit 
style.
Template
Reference to the template that makes up the control’s visuals.
ApplyTemplate method
It attempts to rebuild the visual tree from the template. It returns true
if it succeeds.

251
ContentControl
Control also supports the FontFamily, FontSize, FontStretch, FontStyle, and
FontWeight properties covered in chapter 10. For more detail on the text-related
properties of Control, please refer back to section 10.2.
 It’s rare that you’ll create new controls that derive directly from UIElement or
FrameworkElement. Instead, you’ll usually derive from Control or one of its descen-
dants, such as ContentControl. ContentControl provides functionality above and
beyond Control by enabling the containment and templating of arbitrary content.  
12.2
ContentControl
In older technologies, the content of a control was usually very specific: a button
could hold a text string in a caption property; an ImageButton could hold an image
and text split across two properties; and so forth. Silverlight and WPF demanded a
more flexible content model where a control could indicate that it supports the inclu-
sion of arbitrary content rather than a specific atomic item of known type. From this
requirement, the ContentControl was born.
ContentControl is a descendant of Control. As such, it inherits all of the proper-
ties, methods, and behaviors Control provides. It also adds the key concept of
Content. Table 12.5 shows the two content-related properties that ContentControl
adds to the Control type.
The Content for a ContentControl can be any arbitrary object. But if the type isn’t
something that can be natively added to the visual tree (a UIElement) and there’s no
explicit or implicit template, Silverlight will call the object’s ToString method to dis-
play it. This allows you to add any other Silverlight visual elements or a string value
without having to do any additional work. If you’ve wondered why a button can have a
simple string or a complex tree of elements as the content property, this is why.
 The ContentTemplate is an explicit data template that can be used to format the
content. Consider that you may assign a complex object, such as a Person, to the con-
tent property. The ToString approach will leave you with something like
MyLib.MyNamespace.Person as the actual text—probably not what you want. The
ContentTemplate uses binding to format the object for display. I’ll cover data tem-
plates (both implicit and explicit) in detail in chapter 16.
Table 12.5
Properties for the ContentControl abstract type
Member
Description
Content
Assign the content (anything that can be rendered) to this property. If the con-
tent isn’t a UIElement and there’s no ContentTemplate or implicit data 
template associated with the type, Silverlight will call the object’s ToString
method to display it.
ContentTemplate
This is a data template used to display the content assigned via the Content
property. You’ll learn more about data templates in chapter 16 when I discuss 
binding.

252
CHAPTER 12
Control basics and UserControls
 Table 12.6 shows the flexibility of the content control even without relying on a
content template. Note how you can have anything inside the button, including a
TextBox and a video. You can even type in the TextBox and watch the video because
they’re real, live elements. 
This table shows the flexibility provided with a ContentControl, in this case a Button.
The first example shows a simple string for content. The second shows the explicit set-
ting of the content property. This is optional, as you see in the third example, where
the Content property is omitted but the StackPanel is still assigned to it.
 As you progress through this book, you’ll learn how to make the contents of a
ContentControl look how you want. For now, note how the innards of a Content-
Control are specified through the Content property.
 Most controls that inherit from ContentControl use a ContentPresenter to do
that actual display work in their control template. I’ll cover templates again in section
14.3 but, for now, a brief introduction to the ContentPresenter is in order.
12.2.1 The ContentPresenter
The ContentPresenter is a descendant FrameworkElement that exists primarily to
support the display of content in a ContentControl. Rather than having to put a
TextBlock, Image, or other strongly typed content presentation element into your
control template, you can use a ContentPresenter to bind to and display the content
Table 12.6
The flexibility of a ContentControl as displayed by three buttons
Button
XAML
<Button Width="150" Height="75"
        Content="Hello!" />
<Button Width="150" Height="75">
  <Button.Content>
    <TextBox Height="24" Text="TextBox"
             Width="100" />
  </Button.Content>
</Button>
<Button Width="200"  Height="100">
  <StackPanel>
    <TextBlock Text="Playing"
               HorizontalAlignment="Center" />
      <MediaElement Height="75" Width="125"
               Stretch="Uniform" 
               Source="PeteAtMIX10ch9.wmv" />
  </StackPanel>
</Button>

253
Button controls
from the Content property. Table 12.7 shows the properties of the ContentPresenter
element.
Without the ContentPresenter, the ContentControl can’t do much of anything excit-
ing. The ContentPresenter holds the logic to try to render the object passed into it.
In fact, in a typical control template, the ContentPresenter is assigned values from
the ContentControl via template binding, as shown here:
<ContentPresenter 
  Content="{TemplateBinding Content}"
  Margin="{TemplateBinding Padding}"
  HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}"   
  VerticalAlignment="{TemplateBinding VerticalContentAlignment}" />
I’ll cover TemplateBinding in chapter 14 when you’ll be working with control tem-
plates. For now, understand that TemplateBinding is used to bind an element in
XAML to a dependency property in the control’s implementation. The Content prop-
erty of the ContentPresenter in the preceding code is bound to the Content property
of the containing ContentControl.
 Together, Controls, ContentControls, and the associated ContentPresenter
make up the core of the control tree in Silverlight. Another type of control, Items-
Control, is equally as important. But before I show you the various types of
ItemsControls, let’s look at some concrete implementations of ContentControls—
specifically, those based on Button. 
12.3
Button controls
A button is a type of control that responds to a single-click event, which can be triggered
by mouse, touch, or keyboard. With a mouse, a user can click a button by pressing and
releasing the left mouse button while hovering over it. With touch, a single tap is all you
need. With the keyboard, a button can be clicked by pressing Enter or the spacebar
when the button has the focus. Whatever way you choose, the general implementation
of a button is spread across two classes, ButtonBase and ContentControl.
ButtonBase is an abstract base class used by all buttons in Silverlight. This class
provides three members that are directly related to a user’s interaction with a button:
IsPressed, Click, and ClickMode. IsPressed  returns whether a button is currently
pressed. By default, this bool property is set to false. If a user clicks and holds a but-
ton, this property will change to true. But once a user releases the mouse button, the
IsPressed property will change back to false. At that point, the Click event will fire,
assuming the default ClickMode is used.
Table 12.7
Properties for the ContentPresenter element
Member
Description
Content 
The value assigned from the same property of a ContentControl
ContentTemplate 
The template value assigned from the same property of a ContentControl

254
CHAPTER 12
Control basics and UserControls
 The ClickMode property specifies when the Click event will fire. Setting this prop-
erty can be useful if you want to fully customize a user’s experience with your buttons.
This experience can be set to any of the options available within the ClickMode enu-
meration. These options are shown and described in table 12.8.
The ClickMode enumeration can be used to define a small part of the behavior of a
button. The rest of the behavior is defined in the ButtonBase class itself.
 You can omit the explicit <Button.Content> reference (because it’s the default
content property for the content control), and simply nest the content, as shown in
the third example in the table. This property is available on all ContentControl ele-
ments, a category that naturally includes all ButtonBase elements such as the Button,
HyperlinkButton, RadioButton, and CheckBox elements.
12.3.1 The Button
The traditional Button is a simple ContentControl that a user can click to perform an
action. This control is defined by the Button class, which derives directly from the
ButtonBase class. The Button automatically exposes the Click event. The thing that
makes the Button class special is the default appearance it creates around the
Content. This appearance and the syntax of a Button are shown in listing 12.1.
Result:
XAML:
<Button x:Name="myButton" Content="Save" Height="30" Width="90" />
As you can see, the buttons in table 12.6 are slightly more complex than the one
shown in this example, but it’s intended to show only the basic syntax and look of a
Button. This appearance includes a small container that makes a Silverlight Button
look similar to the buttons seen in other technologies. This container is designed to
hold a Button element’s Content. Occasionally, you may want this Content to behave
more like a hyperlink. For these situations, you should look to the HyperlinkButton.
Table 12.8
Options available within the ClickMode enumeration 
Option
Description
Hover
Fires the Click event when the user moves the mouse pointer over a button
Press
Causes the Click event to execute when the user presses a button
Release
Triggers the Click event when the user releases the left mouse button within 
the bounds of the button
This is the default ClickMode used for a button.
Listing 12.1
The syntax for a button

255
Button controls
12.3.2 The HyperlinkButton
The HyperlinkButton control is designed to create a button that looks and behaves
like a hyperlink. This behavior is provided through two publicly visible properties
called NavigateUri and TargetName, which are shown here:
<HyperlinkButton x:Name="myHyperlinkButton" 
  Content="Search in a New Window" 
  NavigateUri="http://10rem.net"  
  TargetName="_blank" />            
The HyperlinkButton control uses the NavigateUri property to determine which
page to load. By default, this Uri will be loaded in the current window, forcing your
Silverlight application to unload. As you can imagine, this side effect may not be desir-
able. But you can take control of this behavior with the TargetName property.
 The TargetName property is a string that represents the name of the frame or
window to load the NavigateUri within. By default, the TargetName value will be an
empty string. You can use any of the values in table 12.9 to create the intended
experience.
This table describes the values that can be assigned to the TargetName property. If you
happen to assign an unrecognized value to the TargetName property, one of two things
will happen. If the value has one or more whitespace characters, an InvalidOperation-
Exception will be thrown. If the TargetName doesn’t have any whitespace characters,
the NavigateUri will load in a new window (or an existing window if one with that name
is currently open), just like it would in HTML. It’s important to remember that, despite
its behavior as a hyperlink, the HyperlinkButton is still a type of button.
 The HyperlinkButton class derives from the ButtonBase class; it still acts like a
button and supports the Click event. In the case of a HyperlinkButton, the Click
event will fire before the NavigateUri is evaluated so you can dynamically change the
location of the NavigateUri just before it gets loaded. In addition, this event can be
useful for performing cleanup operations if you’re redirecting the user away from
your Silverlight application. 
12.3.3 The RadioButton
A RadioButton represents a choice within a group of options. For instance, imagine
having to choose your favorite pizza topping or flavor of ice cream. Each of these
Table 12.9
The acceptable options for the TargetName property 
Target Value
Description
_blank, _media, or search
Launches the URL specified in the NavigateUri property in a new 
browser window
_parent, _self, or top
Loads the URL specified in the NavigateUri property in the current 
browser window

256
CHAPTER 12
Control basics and UserControls
situations requires one and only one choice to be selected. To properly deliver this
kind of functionality, you need to familiarize yourself with the selection and grouping
behaviors of the RadioButton.
RADIOBUTTON SELECTION
A RadioButton is a kind of ToggleButton. A ToggleButton represents a button that
can change states. For a RadioButton, this state can change between a checked state
and the default unchecked state. The state can be set at design time through the Bool-
ean-based IsChecked property, the value of which affects both behavior and appear-
ance, as shown in listing 12.2.
Result:
XAML:
<StackPanel>
  <TextBlock Text="What is your favorite flavor of ice cream?" />
  <RadioButton Content="Chocolate"
               IsChecked="true" />
  <RadioButton Content="Vanilla"
               IsEnabled="False"/>
  <RadioButton Content="Chocolate Chocolate" />
  <RadioButton Content="More Chocolate" />
</StackPanel>
This example shows four answers for a single question, one of which is disabled. You
can see that the first option is selected by default when the application starts because
it has its IsChecked property set to true. Note also that it’s chocolate. If it’s not choco-
late, it’s not dessert. 
 Once a RadioButton has been selected, it can’t be deselected by clicking it again. A
RadioButton can only be deselected by using one of two approaches: setting the
IsChecked property to false at runtime using code or selecting a different Radio-
Button within the same group.
RADIOBUTTON GROUPING
A grouping of RadioButton items represents the choices available for a single situa-
tion. In the previous listing, you saw a StackPanel that grouped together a couple of
ice cream flavor choices. These choices were grouped because the StackPanel was the
immediate parent of both of the RadioButton items. A problem begins to emerge if
you add unrelated RadioButton items in the same panel. For these situations, you use
the GroupName property.
Listing 12.2
Default appearances of a checked and unchecked RadioButton

257
Button controls
 The GroupName property allows you to control how RadioButton elements are
grouped together. By default, this string-typed property is set as an empty string, indi-
cating there’s no group. Because of this, all RadioButton elements with a direct par-
ent will belong to the same group. By explicitly setting this property, you can control
the groupings. You can even do this for RadioButton elements that share the same
parent, as shown in listing 12.3.
Result:
XAML:
<StackPanel>
  <TextBlock Text="What is your favorite flavor of ice cream?" />
  <RadioButton Content="Chocolate" IsChecked="true" />
  <RadioButton Content="Vanilla" />
  <TextBlock Padding="0,15,0,0" 
    Text="What is your favorite pizza topping?" />
  <RadioButton Content="Green Peppers" GroupName="pizza" />
  <RadioButton Content="Onions" GroupName="pizza" />
  <RadioButton Content="Pepperoni" IsChecked="true" 
               GroupName="pizza" /> 
</StackPanel>
Listing 12.3 shows how the GroupName property can be used to force RadioButtons to
work together. A close relative of the radio button, but one that doesn’t handle mutu-
ally exclusive choices and, therefore, needs no grouping, is the CheckBox. 
12.3.4 The CheckBox
The CheckBox control enables a user to select whether an option is chosen. Unlike the
RadioButton, the CheckBox control allows you to select multiple elements that belong
to the same logical grouping (or in the same panel), so you could do something like
select multiple pizza toppings (see listing 12.4).
Result:
Listing 12.3
Manually controlling RadioButton groupings
Listing 12.4
A basic CheckBox setup

258
CHAPTER 12
Control basics and UserControls
XAML:
<StackPanel>
  <TextBlock Text="Please select your favorite pizza toppings:" />
  <CheckBox Content="Green Peppers" IsChecked="true" />
  <CheckBox Content="Onions" />
  <CheckBox Content="Pepperoni" IsChecked="true" />
</StackPanel>
Selecting multiple CheckBox elements at the same time is possible because the Check-
Box isn’t bound to a specific group. In fact, the CheckBox does little more than extend
the ToggleButton class. Because the CheckBox does extend the ToggleButton class,
you can use three-state checkboxes by switching the IsThreeState bool property to
true. What happens to the IsChecked property? Well, this property is a nullable type
so it also supports three states. These states and the look of a three-state CheckBox are
shown in listing 12.5.
Result:
XAML:
<StackPanel>
  <CheckBox IsThreeState="True" IsChecked="False" Content="Unchecked" />
  <CheckBox IsThreeState="True" IsChecked="True" Content="Checked" />
  <CheckBox IsThreeState="True" IsChecked="" Content="Indeterminate" />  
</StackPanel>
Listing 12.5 shows the look and syntax of a three-state CheckBox. The fact that the
CheckBox can support three different states demonstrates one way in which Silver-
light is an improvement over HTML. Another improvement is found in the flexibility
of the ContentControl class in general. This class, discussed at the beginning of sec-
tion 12.2, can be used in the CheckBox, RadioButton, HyperlinkButton, and Button
controls. In addition, the flexibility of the ContentControl can be used with Silver-
light’s item controls.
 This section discussed the controls derived from the ButtonBase class that repre-
sent buttons available within Silverlight. Often, these controls are used to trigger an
action. Occasionally, you may need to present a list of items rather than a single item.
This type of functionality can be delivered through an ItemsControl.
12.4
ItemsControls
An ItemsControl is a type of control designed to show a collection of items. This con-
trol exposes the collection of items through a publicly visible property called Items.
This property represents an ItemsCollection where each element in the collection is
some kind of object. This object can be added at design time through XAML or at
Listing 12.5
Using three-state mode with the CheckBox control

259
ItemsControls
runtime through code. Three controls in the Silverlight API are descendants of the
ItemsControl class: the ListBox, the ComboBox, and the TabControl.
 Though you’ll most often use one of its derived classes, the base ItemsControl can
be used whenever you want to present a list of items and don’t need any selected item
tracking. You’ll get similar results from using a StackPanel, but if you need to bind
items, the ItemsControl is the way to go.
 The ItemsControl adds a few properties above and beyond what you’d get from a
regular Control. These properties are shown in table 12.10.
You’ll see these properties in use with the ListBox, ComboBox, and TabControl. But
they could be just as easily used with a plain old ItemsControl.
12.4.1 The ListBox
The ListBox is one of the most commonly used items controls. Though much of its
functionality is directly inherited from ItemsControl, it adds the important distinc-
tions of exposing a selected item and including scrolling in its default template. This
control enables you to show multiple items from a collection of items at the same
time. If there are more items than the space allowed for the control, the ListBox will
display scrollbars to allow scrolling through the content. An example of a ListBox is
shown in listing 12.6.
Result:
XAML:
<ListBox x:Name="myListBox">
  <ListBox.Items>
Table 12.10
Key ItemsControl members 
Member name
Description
Items 
The collection of items to be displayed in the control.
ItemsPanel 
The panel to be used to display the items.
By default, this is a StackPanel, but you could change it to a WrapPanel
or anything else you’d like.
ItemsSource 
Used in binding, this is the source of the items, typically a collection.
ItemTemplate 
The data template used to display a single item.
Listing 12.6
A ListBox that displays the days of the week

260
CHAPTER 12
Control basics and UserControls
    <ListBoxItem><TextBlock Text="Sunday, June 1"/></ListBoxItem>      
    <ListBoxItem><TextBlock Text="Monday, June 2"/></ListBoxItem>
    <ListBoxItem><TextBlock Text="Tuesday, June 3"/></ListBoxItem>
    <ListBoxItem><TextBlock Text="Wednesday, June 4"/></ListBoxItem>
    <ListBoxItem><TextBlock Text="Thursday, June 5"/></ListBoxItem>
  </ListBox.Items>
</ListBox>
This ListBox uses the Items property to load options at design time. You also have the
option of binding to a data source to make this list of items more dynamic. Binding to
a data source will be covered in the next chapter. Regardless of whether you’re bind-
ing to a data source or defining items at design time, each item in the control is a
ListBoxItem. A ListBoxItem is a type of ContentControl so you can use any visual
tree you want for an item, as shown in listing 12.7.
Result:
XAML:
<ListBox x:Name="myListBox">
  <ListBox.Items>
    <ListBoxItem>                                
      <StackPanel Height="80" Orientation="Horizontal">
        <Canvas Width="87" Height="77">
          <Image Source="http://www.silverlightinaction.com/month.png" />
          <TextBlock Width="77" TextAlignment="Center" FontFamily="Arial" 
            FontWeight="Bold" FontSize="32" Padding="30" Text="1" />
        </Canvas>
        <TextBlock FontFamily="Arial" FontWeight="Bold" FontSize="44" 
          Padding="20">Sunday</TextBlock>
      </StackPanel>                    
    </ListBoxItem>     
    <ListBoxItem>                               
      <StackPanel Height="80" Orientation="Horizontal">
        <Canvas Width="87" Height="77">
          <Image Source="http://www.silverlightinaction.com/month.png" />
          <TextBlock Width="77" TextAlignment="Center" FontFamily="Arial" 
            FontWeight="Bold" FontSize="32" Padding="30" Text="2" />
        </Canvas>
        <TextBlock FontFamily="Arial" FontWeight="Bold" FontSize="44" 
          Padding="20">Monday</TextBlock>
      </StackPanel>
    </ListBoxItem>
    <ListBoxItem>                                
      <StackPanel Height="80" Orientation="Horizontal">
        <Canvas Width="87" Height="77">
Listing 12.7
Using a ListBoxItem as a ContentControl
ListBoxItem
ListBoxItem
ListBoxItem

261
ItemsControls
          <Image Source="http://www.silverlightinaction.com/month.png" />
          <TextBlock Width="77" TextAlignment="Center" FontFamily="Arial" 
            FontWeight="Bold" FontSize="32" Padding="30" Text="3" />
        </Canvas>
        <TextBlock FontFamily="Arial" FontWeight="Bold" FontSize="44" 
          Padding="20">Tuesday</TextBlock>
      </StackPanel>
    </ListBoxItem>
    <ListBoxItem>                                   
      <StackPanel Height="80" Orientation="Horizontal">
        <Canvas Width="87" Height="77">
          <Image Source="http://www.silverlightinaction.com/month.png" />
          <TextBlock Width="77" TextAlignment="Center" FontFamily="Arial" 
            FontWeight="Bold" FontSize="32" Padding="30" Text="4" />
        </Canvas>
        <TextBlock FontFamily="Arial" FontWeight="Bold" FontSize="44" 
          Padding="20">Wednesday</TextBlock>
      </StackPanel>
    </ListBoxItem>
  </ListBox.Items>
</ListBox>
This listing shows a ListBox control with much richer ListBoxItem elements than
those shown in listing 12.6. Ultimately, one of the main reasons for using a ListBox is
to enable your users to select an item from it. Luckily, the ListBox exposes some prop-
erties for this.
The ListBox exposes two properties and an event—SelectedIndex, SelectedItem,
and SelectionChanged respectively—all of which help you handle item selection. The
SelectedIndex is a zero-based int that reflects the index of the currently selected
item in the ListBox. If no item is selected, this property will return –1. Even more
informative is the SelectedItem property, which returns the current selection in
object form. This property type is a powerful improvement over the value-text prop-
erty of items in HTML. Regardless, whenever an item is selected, whether by the user
or programmatically, the SelectionChanged event will fire. This event, as well as the
SelectedItem and SelectedIndex properties, is also available using the ComboBox. 
Selector controls
The ListBox and ComboBox are controls that inherit from Selector. Selector en-
hances ItemsControl by adding the SelectedIndex and SelectedItems properties,
as well as the underlying infrastructure to manage them. If you want to create your
own ListBox-like class, such as a dedicated carousel control or perhaps a simple
menu, you should probably inherit from Selector as your starting point.
The ItemsControl by itself can be useful to show a list of elements on a page as
long as you don’t need to support the selection of one of those items. Note that, unlike
ListBox, it doesn’t include scrolling in its presentation.
ListBoxItem

262
CHAPTER 12
Control basics and UserControls
12.4.2 The ComboBox
The ComboBox gives users the ability to select a single option from a list of choices.
These choices are visible to a user as long as the ComboBox is in an open state, which is
set when a user interacts with a ComboBox. Alternatively, this state can be set program-
matically through the IsDropDownOpen property. This bool property is by default set
to false so a ComboBox starts in a compacted, closed state, as shown in listing 12.8.
Result:
XAML:
<ComboBox x:Name="myComboBox" Height="28" Width="180">
  <ComboBox.Items>
    <ComboBoxItem><TextBlock Text="Sunday, June 1"/></ComboBoxItem>
    <ComboBoxItem><TextBlock Text="Monday, June 2"/></ComboBoxItem>
    <ComboBoxItem><TextBlock Text="Tuesday, June 3"/></ComboBoxItem>
    <ComboBoxItem><TextBlock Text="Wednesday, June 4"/></ComboBoxItem>
    <ComboBoxItem><TextBlock Text="Thursday, June 5"/></ComboBoxItem>
  </ComboBox.Items>
</ComboBox>
This listing shows the appearance of a closed ComboBox with the second item selected
by the user. This control resembles the DropDownList found in ASP.NET and the
select element used in HTML. But, unlike those controls, each item in the ComboBox
can have a fully customized appearance; each item is a ComboBoxItem, which happens
to be a kind of ContentControl. This fact enables you to recreate the list shown in list-
ing 12.7 in the more compact form of a ComboBox.
 The ComboBox also provides three members that make it unique from the other list
controls. The first member is a double property called MaxDropDownHeight that allows
you to customize the maximum height of the drop-down list. The second is an event
named DropDownOpened that fires when the drop-down list is shown. The third is an
event that triggers when the drop-down list closes. This event is called DropDown-
Closed. Collectively, these three members make the ComboBox special—they won’t be
found on the third and final type of ItemsControl, the TabControl.
12.4.3 The TabControl
The TabControl is another ItemsControl available within Silverlight. This Items-
Control is designed to show multiple content items in the same physical space on the
screen using a tab metaphor to switch between them. Each of these pieces of content
is defined within a TabItem, which happens to be a ContentControl. Because of this,
you can define the complete visual tree for each TabItem. Before you can do this, you
must reference the System.Windows.Controls assembly. The tab-related controls are
Listing 12.8
A ComboBox that has been used to select an item

263
ItemsControls
extended controls like the GridSplitter mentioned in chapter 8, so the sdk prefix
will be used once again throughout this section, as shown in listing 12.9.
Result:
XAML:
<UserControl x:Class="Listing10_9.Page"
  xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" 
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" 
  xmlns:sdk="http://schemas.microsoft.com/winfx/2006/xaml/presentation/sdk"
  Width="400" Height="300">    
  <StackPanel x:Name="LayoutRoot" Background="White"
    HorizontalAlignment="Left">
    <TextBlock Text="My Grocery List" />            
      <sdk:TabControl x:Name="myTabControl" Height="200" Width="240">
        <sdk:TabItem>
          <ListBox>
            <ListBoxItem Content="Apples" />
            <ListBoxItem Content="Bananas" />
            <ListBoxItem Content="Grapes" />
          </ListBox>
        </sdk:TabItem>
        <sdk:TabItem>
          <StackPanel Orientation="Vertical">
            <ListBox>
              <ListBoxItem Content="Beef" />
              <ListBoxItem Content="Pork" />
              <ListBoxItem Content="Chicken" />
            </ListBox>
            <TextBlock TextWrapping="Wrap" Width="200" 
              Text="NOTE: You may want to pick up some barbeque sauce." />
          </StackPanel>
        </sdk:TabItem>
      </sdk:TabControl>        
    </StackPanel>
</UserControl>
This listing shows an entire page, which includes a basic TabControl. Because TabCon-
trol is an extended control and is part of the System.Windows.Controls.dll, I’ve
shown the entire page’s XAML to demonstrate the use of the ext namespace. Now that
you can use a TabControl, it’s important to understand the behavior of the headers.
Listing 12.9
The basic syntax of a TabControl

264
CHAPTER 12
Control basics and UserControls
 Each of the tab headers in listing 12.9 is hardly visible because each header is set by
a TabItem property called Header. This property represents the object used when
rendering the Header, so you should consider using some UIElement such as a Panel
for the Header. Listing 12.10 shows a TextBlock used for one Header and a Stack-
Panel for the other.
Result:
XAML:
<StackPanel x:Name="LayoutRoot" Background="White"             
            HorizontalAlignment="Left">
  <TextBlock Text="My Grocery List" />            
  <sdk:TabControl x:Name="myTabControl" Height="200" Width="240">
    <sdk:TabItem Header="Fruits">
      <ListBox>
        <ListBoxItem Content="Apples" />
        <ListBoxItem Content="Bananas" />
        <ListBoxItem Content="Grapes" />
      </ListBox>
    </sdk:TabItem>
    <sdk:TabItem>
      <sdk:TabItem.Header>
        <StackPanel Orientation="Horizontal">
          <Image Source="http://www.silverlightinaction.com/meat.png" />
          <TextBlock Text="Meats" />
        </StackPanel>
      </sdk:TabItem.Header>
      <StackPanel Orientation="Vertical">
        <ListBox>
          <ListBoxItem Content="Beef" />
          <ListBoxItem Content="Pork" />
          <ListBoxItem Content="Chicken" />
        </ListBox>
        <TextBlock TextWrapping="Wrap" Width="200" 
          Text="NOTE: You may want to pick up some barbeque sauce." />
      </StackPanel>
    </sdk:TabItem>
  </sdk:TabControl>
</StackPanel>
The listing shows a TabControl with two TabItem elements. Each has a Header. Note
that, if a TabItem has its Header property set, the HasHeader  property of the TabItem
Listing 12.10
Customizing the header of a TabItem

265
Creating UserControls
will change to true. This bool property defaults to false and is useful in the event
you need to check whether a TabItem has a header at runtime. For situations where
you want to change the location of the tabs, there’s another property.
 The TabStripPlacement property determines how the tabs align in relation to the
tab content area. This property represents an enumeration that can be set to Bottom,
Left, Right, or Top. By default, this property value is set to Top on a TabControl.
TabControl, ComboBox, and ListBox represent three ItemsControl elements avail-
able in Silverlight. ItemsControl elements give you the flexibility to allow a user to
select from any kind of content. ItemsControls are the key type of control to use
whenever you need to display lists of content: menus, list boxes, tab strips, carousels,
and more.
 Together with the content controls such as Buttons, the ItemsControls help make
up the majority of the UI elements you’ll use in Silverlight. Chances are, if you create
your own custom control, it’ll derive from one of those core types.
 Creating your own custom controls is a deep topic, and one that’ll need to wait for
the discussion of styling, templating, binding, and the Visual State Manager—all cov-
ered in later chapters. But there’s one type of control you can create that doesn’t
require all this additional complexity. In fact, it was designed for simple reuse and UI
composition of existing controls such as those discussed in this chapter. That type of
control is the UserControl. 
12.5
Creating UserControls
There may be times when none of the controls provided within Silverlight contain the
functionality you need. For these situations, you may want to consider creating a reus-
able control. A reusable control can be useful when you want something more than UI
enhancements. After all, these types of enhancements can be provided with the style
and template features discussed in chapter 14. A reusable control allows you to reuse
functionality not found in a preexisting control. For instance, imagine wanting to cre-
ate a TextBox that can be locked by a user and looks like figure 12.1.
 The figure shows a control that provides functionality
beyond a basic TextBox. This control adds an image that
projects whether the TextBox can be edited. Although
the desired functionality is easy to implement, you may
not want to recreate it every time; this provides an excel-
lent opportunity to create a reusable control. Now, imag-
ine wanting to name this control LockableTextBox to use it in other projects. To do
this, you must create an instance of the UserControl class.
UserControls are intended for simple reuse. You want to be able to compose a con-
trol in the designer but not to worry about enabling templating or other advanced con-
trol functionality. I’ll discuss templating in greater detail in section 14.3 but, for now,
understand that the template for a UserControl is the XAML file you create with it.
Figure 12.1
A TextBox
that can be locked

266
CHAPTER 12
Control basics and UserControls
 The UserControl type itself is similar to ContentControl. Like ContentControl, it
can have only a single item of content in the Content property. In the default item
template in Visual Studio, that content is a grid, as shown in listing 12.11.
<UserControl x:Class="SilverlightApplication36.LockableTextBox"
  xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
  xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
  xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
  mc:Ignorable="d"
  d:DesignHeight="300" d:DesignWidth="400">
  <Grid x:Name="LayoutRoot" Background="White">  
  </Grid>
</UserControl>
If they’re so similar, why doesn’t the UserControl derive directly from ContentCon-
trol? The ContentControl type allows you to provide a custom template for the Con-
tent. In a UserControl, that would be redundant because the content template is the
XAML file created when you created the UserControl. 
 The UserControl also provides compile-time code generation for all the named
(using x:Name) elements in the XAML file. The InitializeComponent function, called
from the constructor, handles associating the elements in the XAML file with the gen-
erated properties. There’s no magic; the code is simply loading the associated XAML
using the equivalent of XamlReader.Load, and calling FindName for each expected ele-
ment and assigning the result to the named property.
 You could do this in your own code if you prefer. If you create the more flexible
but marginally more difficult custom controls, you’ll perform many of these steps.
 The UserControl class is designed to represent a new control or extend an exist-
ing one. This class gives you the ability to organize small portions of a UI into more
manageable components, which can then be used in your application or shared
with other applications. The process to provide this kind of functionality involves
these steps:
1
Defining the appearance of the control
2
Defining the behavior of the control
3
Calling the control
This three-step process forms the ABCs of user-control development (appearance,
behavior, and call). Over the course of this section, as you create a LockableTextBox,
you’ll see how these three steps relate to one another.
12.5.1 Defining the appearance
Defining the appearance of a UserControl involves creating the XAML for the UI.
This process is the same as defining the UI for a page in Silverlight because every page
Listing 12.11
The default UserControl template
Content

267
Creating UserControls
in Silverlight is a UserControl. The XAML for the UserControl (LockableTextBox) is
shown in listing 12.12.
<UserControl x:Class="MyClassLibrary.LockableTextBox"
  xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" 
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" > 
  <StackPanel x:Name="LayoutRoot" Orientation="Horizontal">
    <TextBox x:Name="myTextBox" Height="24" Width="120" />
    <Image x:Name="myImage" Height="24"  Margin="5,0,0,0" 
           Cursor="Hand" MouseLeftButtonUp="myImage_MouseLeftButtonUp" 
      Source="http://www.silverlightinaction.com/unlocked.png" />
  </StackPanel>
</UserControl>
The listing shows the XAML that makes up the default appearance of the Lockable-
TextBox. This UI defines a TextBox and an Image within a StackPanel. The Stack-
Panel is important because, as mentioned earlier, each UserControl can have only
one UIElement as a child, so you’ll almost always use one of the Panel elements dis-
cussed in chapter 8 as the content of a UserControl.
 Also note that, in order to make the control truly reusable, you put it into a sepa-
rate Silverlight class library project named MyClassLibrary. This project is referenced
from your main Silverlight application.
 Setting the Content of a UserControl is an important first step in creating a reus-
able control. This step defines the static parts of the UI, but the real value in creating a
reusable control is to provide some kind of new functionality. This functionality is gen-
erally delivered when you define the behavior of a control.
12.5.2 Defining behavior of a control
The functionality of a reusable control is also known as the control’s behavior. This
behavior is defined in the code-behind file of the XAML file, which will contain a class
that derives from the UserControl class. It’s your responsibility to make sure this class
provides the events, methods, and properties that detail the behavior of the control.
Look at the code for the LockableTextBox control shown in listing 12.13. This listing
uses a DependencyProperty, which was covered in chapter 2.
public partial class LockableTextBox : UserControl
{
  public LockableTextBox()
  {
    InitializeComponent();                           
  }
  private void myImage_MouseLeftButtonUp(object sender,
    MouseButtonEventArgs e)
  { 
Listing 12.12
The UI for the LockableTextBox UserControl
Listing 12.13
The LockableTextBox class definition

268
CHAPTER 12
Control basics and UserControls
    IsLocked = !this.IsLocked;        
  }                         
  public void UpdateUI()
  {
    if (IsLocked)
    {
      myImage.Source = new BitmapImage (
        new Uri("http://www.silverlightinaction.com/locked.png",
        UriKind.Absolute)); 
    }
    else
    {
      myImage.Source = new BitmapImage(
        new Uri("http://www.silverlightinaction.com/unlocked.png",
        UriKind.Absolute));
    }
    myTextBox.IsReadOnly = IsLocked;
  }
  public bool IsLocked                          
  { 
    get { return (bool)(GetValue(IsLockedProperty)); }
    set { SetValue(IsLockedProperty, value); }
  }
  public static readonly DependencyProperty IsLockedProperty = 
    DependencyProperty.Register(
     "IsLocked",
     typeof(bool),
     typeof(LockableTextBox),
     new PropertyMetadata (new PropertyChangedCallback (OnIsLockedChanged))
     );
  private static void OnIsLockedChanged(DependencyObject o, 
    DependencyPropertyChangedEventArgs e)
  {
    LockableTextBox textBox = (LockableTextBox)(o);
    textBox.UpdateUI();
  }
}
The class in this listing includes the call to InitializeComponent inside the construc-
tor. If left out, your control references (to the TextBox and the Image, for example)
would be null at runtime.
 The class also includes the creation of a DependencyProperty for IsLocked. I
introduced dependency properties in chapter 2, but let’s dive a bit deeper into what’s
required to create them in your own class.
REGISTERING DEPENDENCY PROPERTIES
To register a property as a DependencyProperty, you must call the statically visible
DependencyProperty.Register method. This method requires the name of the CLR
IsLocked toggle
 CLR property wrapper
Dependency 
property
Changed
handler

269
Creating UserControls
wrapper, the type of the property value, and the type of the object that owns the prop-
erty. Listing 12.14 shows how to register the IsLocked property.
C#:
public static readonly DependencyProperty IsLockedProperty = 
  DependencyProperty.Register( 
    "IsLocked",                        
    typeof(bool), 
    typeof(LockableTextBox), 
    new PropertyMetadata(                                    
         new PropertyChangedCallback(OnIsLockedChanged))
  )
  public bool IsLocked                  
  { 
    get { return (bool)(GetValue(IsLockedProperty)); }
    set { SetValue(IsLockedProperty, value); }
  }
This listing shows how to register a property as a DependencyProperty. Note the name
of the DependencyProperty itself. This name can be anything, but it generally follows
a naming template of [CLR Wrapper Name]Property. This DependencyProperty serves as
a key in the property dictionary used by the GetValue and SetValue methods of a CLR
property wrapper. Also note the fourth parameter, which allows you to define behav-
ioral aspects and automatically respond to property value changes.
 Although the rest of the runtime uses the dependency properties directly, the CLR
property wrapper is required because it’s used by direct property assignments in XAML
or from your own code. Note that, unlike with a normal CLR property, you’ll assign the
value to and read it from the dependency property system. In addition, because the
binding system and underlying framework do not use the setter, you won’t perform any
other logic in the setter; you’ll do that inside the changed callback instead.
RESPONDING TO PROPERTY VALUE CHANGES
Dependency properties have the ability to automatically respond to property value
changes in a way that you determine. To stay connected with a value change, the
PropertyChangedCallback passes along a DependencyPropertyChangedEventArgs
instance, which gives you three properties to help you react to a change as necessary.
These three properties are described in table 12.11.
Listing 12.14
Registering a DependencyProperty with the property system
Table 12.11
The properties of the DependencyPropertyChangedEventArgs structure
Property
Description
NewValue 
The value of the property after the change has completed
OldValue 
The current value of the property
Property 
The DependencyProperty that triggered the change
Property name
CLR property 
wrapper

270
CHAPTER 12
Control basics and UserControls
This table shows the properties of the DependencyPropertyChangedEventArgs struc-
ture. This structure is associated with the dependency property that was changed. To
get the object that this property is associated with, you must rely on the first parameter
passed from the PropertyChangedCallback. This parameter represents the
DependencyObject whose property value was changed, so you’ll most likely need to
perform a conversion, as shown here:
private static void OnIsLockedChanged(DependencyObject o,
    DependencyPropertyChangedEventArgs e)
{
    LockableTextBox textBox = (LockableTextBox)(o);
    textBox.UpdateUI();
 }
This example shows the event handler for the PropertyChangedCallback delegate
specified earlier. As you can see, this is an event handler that updates the UI of the
UserControl. This optional event handler completes the implementation for the
IsLocked dependency property.
 At first glance, it seems that a lot of additional coding is associated with creating a
dependency property. But considering the fact that only dependency properties can
be animated or used in styling, it’s clear that understanding dependency properties is
an important part of UserControl development. Once the behavior of a UserControl
is completed, you can use the control by calling it.
12.5.3 Calling the control
To include a UserControl in your application, you must do two things. First, you must
add an XML namespace that references the location of the UserControl and you must
add an instance of that control within your XAML. These two steps are the same for
any UserControl. Listing 12.15 shows how to reference the LockableTextBox control
built over the past two sections.
<UserControl x:Class="MySilverlightApp.Page"
  xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" 
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
  xmlns:my="clr-namespace:MyClassLibrary;assembly=MyClassLibrary" 
  Width="400" Height="300">
  <StackPanel x:Name="LayoutRoot" Margin="10">
    <my:LockableTextBox x:Name="myLockableTextBox" />  
  </StackPanel>
</UserControl>
The example in the listing shows how to add the LockableTextBox to a basic Silver-
light page. The my namespace is used to tell Silverlight where to look for the
LockableTextBox definition. This definition is used to build the control, which is ref-
erenced later. That’s all there is to it.
Listing 12.15
Using the LockableTextBox
Namespace
definition
LockableTextBox

271
Summary
 Creating a reusable control in Silverlight is as simple as defining a UserControl
that consists of an appearance and a behavior. These two items generally represent a
small component within a Silverlight application. Alternatively, a UserControl can
represent a component as large as an entire page. This fact is important because it can
affect how you decide to share your content.
UserControls are intended for simple reuse. They’re great for those times when
you need to compose a number of existing elements and reuse them within your
application. But they’re generally not the best approach for creating controls for
broader reuse, which often require binding support and styling flexibility. In those
instances, you need to create a custom control, which I’ll cover in chapter 15—once
you get styling and visual state management under your belt. 
12.6
Summary
The Control, ContentControl, and ItemsControl types form the base for almost
everything you’ll interact with on a page in Silverlight. 
 The Control is a basic type, providing core interaction logic for controls. The
ContentControl expands on that base to provide a type of control that can hold a sin-
gle item of content. The Button-based controls derive from ContentControl.
ItemsControls are the place to turn to should you ever need to create or use a
control that shows a list of items. Remember, it doesn’t need to be a traditional list; it
could be something like a tab strip, or a carousel, or even a menu. In all of those cases,
the ItemsControl base type provides the binding and templating support you need to
work with lists of items.
 The intent behind the first part of this chapter was to provide enough background
so that you can both understand how existing controls function and apply that knowl-
edge to new controls as they appear. New Silverlight controls appear almost daily, but
they’re almost always variations on one of the control models shown here.
 In the latter part of this chapter, I introduced the concept of a UserControl. User-
Controls are great for your own simple reuse scenarios, but you’ll also find them
handy for creating pages and encapsulating data templates. Though you may never
create your own LockableTextBox control, you certainly will work with Pages and the
other Silverlight items based on the humble UserControl.
 In the next chapter, you’ll learn about something many controls in Silverlight use:
animation.

272
Animation and behaviors
Believe it or not, there once was a time when I had to cower in my high-wall cube at
a client site, trying to make sure no one saw me designing icons in a graphics pro-
gram, or hand-coding subtle timer-based animation for an application UI. Often-
times, the only way I could make real progress on the UX assets was when I worked
from home. Working with those things was looked upon as “not real work.” At the
same time, the clients expected icons and application UI to magically appear as
though someone just pressed the “Make it Awesome” button on an IDE.1
 Gladly, for most companies, those days are gone. The value of good graphics,
good UX, and for the most part, good animation has become mainstream in all but
This chapter covers
■
Providing interactive animations
■
Using keyframes
■
Using and creating easing functions
■
Working with and creating behaviors
1 Of course, these same clients would block access to newsgroups and anything with a forum, because they
considered that productivity-wasting. Most of the developers did their problem searches at home, wasting
entire days without peer support.

273
Animating a value over time
the most conservative organizations. The last of those, and probably the least broadly
accepted, is animation.
 Animation is a relative newcomer to the world of application development. Yes,
creative types have been doing it for years, but many of us haven’t seen much anima-
tion in our own applications, web or otherwise. Flash, WPF, Silverlight, and jQuery, not
to mention the vastly improved motion graphics on TV and in movies, have all helped
to finally make animation mainstream.
 Before the platforms incorporated high-level animation constructs like story-
boards and keyframes, animation was a tedious business. Often, it required forcing a
redraw based on a timer, tracking “dirty” regions on the screen, and manual manipu-
lation of the property being animated. No wonder it was rare!
 Although animation is now more popular, it’s a double-edged sword. Silverlight
will make it simple for you to use animation as much as you want, even if that’s overdo-
ing it so much that your entire application UI appears to be suspended from a bed of
Slinky springs over a field of dancing hamsters and spinning email icons. If you go
that route, I won’t judge, honestly.2 I’ll show you how to use the awesome capabilities
Silverlight gives you.
 You’ll begin by exploring the basics of animation, of how animation is a change in
the value of a property over time. Then you’ll work with the timeline and storyboards.
Once you know how to group animations in a storyboard, you’ll learn how to create
keyframes to allow Silverlight to interpolate the values between different points in
time. Of course, keyframes would be pretty boring without easing functions, so that
comes next. You’ll even see how to create your own easing functions. Finally, I’ll wrap
up the chapter with some examples of using and creating behaviors.
13.1
Animating a value over time
An animation  within Silverlight boils down to changing the value of a single property
over a period of time. Without the concept of time,3 an animation would be a static
graphic, and there’d be no need for this chapter. By gradually changing a visual prop-
erty over the course of a time period, you can make elements appear, move, or even
change color. One such effect is shown in figure 13.1.
2 OK, to be honest, I’ll probably be judging you on the inside, quietly mocking your sprung hamster UI.
3 I’d appreciate it if all theoretical physicists and Stephen Hawking fans would kindly keep quiet.
Figure 13.1
An image fading 
into view over the course of 
one second

274
CHAPTER 13
Animation and behaviors
This figure shows the relationship between the Opacity property of an Image and the
duration of an animation. As this animation progresses over the course of a single sec-
ond, the Opacity value gradually increases. As the Opacity value increases, the Image
gradually becomes more and more opaque. You create this dramatic animation by
using the code in the following listing.
<Grid x:Name="LayoutRoot" Background="White" Margin="10">
  <Image x:Name="myImage"
         Source="Assets/man.png">
    <Image.Triggers>
      <EventTrigger RoutedEvent="Image.Loaded">
        <BeginStoryboard>
          <Storyboard x:Name="myStoryboard">
            <DoubleAnimation Duration="0:0:1"
                             Storyboard.TargetName="myImage"
                             Storyboard.TargetProperty="Opacity"
                             From="0"
                             To="1" />
          </Storyboard>
        </BeginStoryboard>
      </EventTrigger>
    </Image.Triggers>
  </Image>
</Grid> 
The example in listing 13.1 shows the XAML responsible for fading an image into view.
A lot of new elements are presented within this small example; to gain an understand-
ing of how these elements relate to one another, here’s an overview of the items seen
in the previous listing:
■
The EventTrigger element initiates an action when the Image is loaded. This
action is represented as the BeginStoryboard element. A trigger is one way to
start an animation. It’s not the most common way, but it’s arguably the simplest.
If you’re familiar with WPF, note that the Trigger system in Silverlight is much
smaller.
■
The Storyboard object is responsible for organizing and controlling the anima-
tions defined within it. Because of the BeginStoryboard action, this Story-
board is automatically started when the EventTrigger is fired.
■
The DoubleAnimation element specifies that you’re going to animate a double-
precision value. I’ll cover other animation types throughout this chapter. 
■
The value to animate is referenced through the Storyboard.TargetProperty
and Storyboard.TargetName attached properties.
These elements work together to allow you to animate a value over a period of time.
In this case, the duration of the timeline is one second and is specified at the Double-
Animation level.
Listing 13.1
XAML for fading in an Image over the course of one second

275
Mastering the timeline
13.2
Mastering the timeline
At its base, every animation is a specialized type of Timeline object. This object is
defined within the System.Windows.Media.Animation namespace and is used to rep-
resent a period of time. During this period of time, you have the opportunity to
change the value assigned to a visual property. To specify which property value should
be changed, you answer the following:
■
What type of property are you animating?
■
Where are you starting from, and where are you going?
■
How long should the animation run?
Although these questions sound fairly basic, there are a significant number of details
surrounding each one. For this reason, I’ll cover each question in detail, beginning
with the first one.
13.2.1 What type of property are you animating?
To create an animation, you first select a single visual attribute of a single element.
This item is guaranteed to have a data type associated with it. This data type will serve
as the guiding light throughout the animation process. Ultimately, it’s what will decide
the type of animation that should be used. Imagine having a basic Ellipse that you
want to animate. The XAML for this sample is shown in listing 13.2.
XAML:
<UserControl x:Class="EllipseAnimation.Page"     
  xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" 
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" 
  Width="400" Height="400">
<Canvas x:Name="LayoutRoot" Background="White" Margin="15">
    <Canvas.Triggers>
        <EventTrigger RoutedEvent="Canvas.Loaded">
            <BeginStoryboard>
                <Storyboard x:Name="myStoryboard"> 
                </Storyboard>
            </BeginStoryboard>
        </EventTrigger>
    </Canvas.Triggers>
    <Path x:Name="myEllipse" Fill="Yellow" Stroke="Black"
          StrokeThickness="2" Height="270" Width="370">
        <Path.Data>
            <EllipseGeometry x:Name="EllipseGeometry"
                             Center="25,25" RadiusX="25" RadiusY="25" />
        </Path.Data>
    </Path>
</Canvas>
</UserControl>
The example in the listing shows an Ellipse named myEllipse. This Ellipse will be
used in the remainder of this section to describe animating properties. Silverlight
Listing 13.2
The XAML for a basic Ellipse
Animations 
will go here

276
CHAPTER 13
Animation and behaviors
provides three types of animations to assist you in creating dramatic visual effects.
These types differ in regard to the type of property being animated. Silverlight has the
ability to animate double, Point, and Color values via the DoubleAnimation, Point-
Animation, and ColorAnimation types. I’ll begin by discussing the most useful type,
the DoubleAnimation.
DOUBLEANIMATION
A DoubleAnimation enables you to animate a single property value from one double-
precision floating-point value to another. This is probably the most widely used type of
animation. To illustrate a DoubleAnimation, this example shows how you could fade
out the Ellipse defined in listing 13.2 over one second:
<DoubleAnimation Storyboard.TargetName="myEllipse" 
                 Storyboard.TargetProperty="Opacity" 
                 From="1" To="0" 
                 Duration="0:0:1" />
As this markup illustrates, delivering a fade effect is incredibly simple. The Double-
Animation element prepares Silverlight to generate double-precision values between
the From and To values. As you can imagine, this opens the door to tons of animation
scenarios, but not every opened door should necessarily be entered.
 Attempting to animate the FontSize property of a TextBlock can be a resource-
consuming task. Even though this property is implemented as a double-precision
value, animating it can quickly lead to poorly performing applications because the
text will be smoothed on every frame—an expensive process, even when the text is
using animation-optimized smoothing. For this reason, if you need to animate your
text, you may want to consider creating your TextBlock as a Path instead and using a
ScaleTransform.
 Regardless, the DoubleAnimation is still applicable in a variety of scenarios: creat-
ing fades, moving elements around a Panel, and performing transformations, among
other things. However useful the DoubleAnimation is, there still may be situations
where you need to animate Point-related values.
POINTANIMATION
The PointAnimation type enables you to animate from one pair of x and y coordi-
nates to another. As the name implies, this type of animation enables you to animate
any property that represents a System.Windows.Point. And although this type isn’t as
widely used throughout the Silverlight APIs as the double type, it still has its place. For
instance, you may need to animate the center of an EllipseGeometry object or
dynamically change the presentation of a brush. Regardless of the need, it’s nice to
know that you can rely on the PointAnimation, which is illustrated here:
<PointAnimation Storyboard.TargetProperty="Center"
                Storyboard.TargetName="EllipseGeometry"
                Duration="0:0:1"
                From="100,100"
                To="200,200" />
The animation in this example changes the origin of any transforms applied to the
Ellipse in listing 13.2. Generally, a PointAnimation will only be used in association

277
Mastering the timeline
with transforms from chapter 7 and the Geometry elements mentioned in chapter 24.
But for a more subtle animation, you may consider using a ColorAnimation.
COLORANIMATION
A ColorAnimation enables you to create smooth transitions from one color to
another. These transitions can be performed between any two System.Windows
.Media.Color property values. For this reason, this type of animation is used primarily
with a brush, as shown in this example:
<ColorAnimation Storyboard.TargetName="myEllipse"
           Storyboard.TargetProperty="(Fill).(SolidColorBrush.Color)"
           Duration="0:0:1" 
           From="Yellow" To="Red" />
This XAML shows an assumed Ellipse shifting from Yellow to Red over the course of
one second. This animation, along with the others mentioned, shows how easy it is to
animate a property. Up to this point, I’ve only focused on animation related to a prop-
erty type. In reality you also need to know how to specify the exact property you’re
animating.
 Each of the animation types that I’ve discussed exposes two attached properties
that specify the target of an animation. Appropriately, these attributes are called
Storyboard.TargetProperty and Storyboard.TargetName. These properties work in
coordination to determine which property of a specific element will be animated. This
is a simplified description of these properties; a more detailed definition will be pro-
vided in section 13.3.2. For now, let’s turn our focus to the second question in our
animation journey.
13.2.2 Where are you starting from and where are you going?
As figure 13.1 illustrated, an animation has a beginning and an end, whether inferred
or explicit. The end of an animation can be specified using one of two properties. I’ll
discuss each in detail later in this section. Before I can describe the end of an anima-
tion, let’s discuss the beginning.
WHERE IS THE ANIMATION COMING FROM?
There’s a saying that you can’t know where you’re going until you know where you’ve
been. In regard to animation, this phrase should be changed to you can’t know where
you’re going unless you know where you’re from. To identify where an animation is
coming from, you rely on the aptly named From property.
 The From property is accessible from all the animation types I’ve discussed. This
value determines where an animation will begin. Listing 13.3 shows the From property
in action to help jump-start this discussion.
<Grid x:Name="LayoutRoot" Background="White" Margin="10">
  <Image x:Name="myImage"
         Opacity="0.25"                          
         Source="Assets/man.png">
Listing 13.3
The From property in a DoubleAnimation
Opacity

278
CHAPTER 13
Animation and behaviors
    <Image.Triggers>
      <EventTrigger RoutedEvent="Image.Loaded">
        <BeginStoryboard>
          <Storyboard x:Name="myStoryboard">
            <DoubleAnimation Duration="0:0:1"
                             Storyboard.TargetName="myImage"
                             Storyboard.TargetProperty="Opacity"
                             From="0"             
                             To="1" />
          </Storyboard>
        </BeginStoryboard>
      </EventTrigger>
    </Image.Triggers>
  </Image>
</Grid>
This example is preparing to animate the Opacity property of an assumed Image. The
Opacity property of this Image is initially set to 0 when the animation starts. This is
determined by the value provided within the From property. Once the animation
begins, the Opacity value gradually increases over the course of one second to the value
of 1. The Opacity will start at 0 even though the image itself has an opacity of 0.25.
 This value is compatible with the animation type. The 0 may look like an integer,
but at runtime it’s automatically converted into a double-precision value. If you’d
attempted to set the From property value to Yellow, an exception would’ve been
thrown because Yellow isn’t a valid double-precision value. Alternatively, you can skip
this potential problem altogether by not defining a From property value; the From
property is an optional attribute.
 If a From value isn’t provided, the animation will automatically choose the starting
point. To decide where to begin, the animation will examine the target specified by
the Storyboard.TargetName and Storyboard.TargetProperty attributes. Once these
are examined, the From property will be set to the current property value associated
with the target, as shown in this example (replace the DoubleAnimation in listing 13.3
with this one):
<DoubleAnimation Storyboard.TargetName="myImage"
                 Storyboard.TargetProperty="Opacity" 
                 To="1"  Duration="0:0:1" />
When the animation in this markup begins, it automatically determines that the
Opacity value within the animation should begin at 0.25. This is the current value of
the Opacity property, which is defined as the target. This approach can help create
smoother, more fluid animations that don’t have an ugly jump to the initial value
when they start. 
 In contrast to the To value, explicitly setting the From value can cause your anima-
tions to jump or jerk between iterations because the animation may need to reset the
target property back to the value set within the From property. If you want more fluid
animations and plan to repeat the animations, consider having them end at or just
before the value specified within the From value: “End where you started.” Alternatively,
From 
property

279
Mastering the timeline
you may choose to skip setting the From value altogether. Either way, you need to know
where the animation is going.
WHERE AM I GOING?
One way to predetermine where an animation is going is by setting the To property.
The To property is exposed within the ColorAnimation, DoubleAnimation, and
PointAnimation types. This value represents the destination of a specific animation.
Like the From property, the value associated with the To property must be compatible
with the type of animation. To get a better feel for this property, examine its use in this
example, which replaces the DoubleAnimation in listing 13.3:
<DoubleAnimation Storyboard.TargetProperty="Opacity"
                 Storyboard.TargetName="myImage" 
                 Duration="0:0:1" 
                 From="0.75" To="0" />
This XAML shows the Opacity of the Image changing from .75 to 0 when the anima-
tion begins. Over the course of one second, the Opacity of the Image will change to 0.
If you’ve defined a value for the From attribute, you don’t have to set the To property.
Instead, you can rely on the use of the By property.
HOW AM I GOING TO GET THERE? 
The By property is a special shortcut that provides an alternate to the To property.
Instead of having to know where you want to go initially, you can conveniently specify
a value in the By attribute. When the animation is run, Silverlight adds the value
defined in the From field to the By value to automatically determine the To value. To
get a firmer understanding of how this can be used, take a look at this markup:
<DoubleAnimation Storyboard.TargetName="myImage"
                 Storyboard.TargetProperty="Opacity" 
                 From="0.25" By="0.50" 
                 Duration="0:0:1" />
This example defines the animation for an assumed Image. When the animation
begins, the Opacity property of the Image is set to .25. Over the course of one second,
you want this animation to increase the Opacity value by .50. When this animation has
started, the To value will essentially be .75. You can also decrease the Opacity value by
providing a negative value, as shown in this XAML fragment:
<DoubleAnimation Storyboard.TargetName="myImage"
                 Storyboard.TargetProperty="Opacity" 
                 From="1.00" By="-0.40" 
                 Duration="0:0:1" />
This markup shows the alternative to increasing a value. Note that the By property
itself is an alternative to the To property. If both properties are defined, the To prop-
erty will take precedence and the By property will be ignored.
 The By and To properties enable you to provide guidance for your animations.
These animations begin at the value provided within the From field. To determine how
long the animation should take to get to the destination, you have one final question
to address.

280
CHAPTER 13
Animation and behaviors
13.2.3 How long should the animation run?
As mentioned earlier, each animation is a Timeline object, so a number of valuable
time-related traits are shared among all animations. The most important of these
items is the Duration property.
HOW LONG?
The Duration property specifies how long it’ll take for a Timeline to complete a sin-
gle episode. This value can be defined using the TimeSpan syntax or it can use a pre-
defined value, defined within the Duration struct and described in table 13.1.
This table illustrates that you have two options when it comes to controlling the Dura-
tion of an animation. To control the playback speed of an animation, call on the
SpeedRatio property.
THROTTLING THE ANIMATION
The SpeedRatio property represents the throttle for a Timeline. By default, this dou-
ble-precision value is set to 1.0. This value can be set to any positive double-precision
value and act as a multiplier to the Duration property value. Figure 13.2 shows the
Duration, SpeedRatio, and time values for a completed Timeline.
 As the figure illustrates, the SpeedRatio property can have a pretty significant
impact on the Duration of a Timeline. These results show that any value less than 1.0
will slow down an animation. At the same time, any value greater than 1.0 will speed
up the animation.
Table 13.1
Options for the Duration property
Property
Description
Automatic
Means that a Timeline will automatically end when all child elements have been 
completed. This (and Forever) really only makes sense at the storyboard level, or 
when using keyframe animation, or when the RepeatBehavior is set.
Forever
Indicates that an animation will run continuously unless stopped from code.
Figure 13.2
The effects of 
the SpeedRatio on a 
Timeline with a 
Duration of 10 seconds

281
Mastering the timeline
Besides adjusting the speed of an animation, you may need to repeat its performance.
For this reason, there’s a RepeatBehavior property.
PLAY IT AGAIN
The RepeatBehavior property is an interesting animal that may act differently than
you’re anticipating. This property enables you to specify how many times an anima-
tion should be played back to back. This property also enables you to specify how long
the animation should run regardless of the Duration value—the animation will play
back to back until the time specified in the RepeatBehavior property has elapsed. To
get a further grasp of how this property works, examine the following figure.
 Figure 13.3 illustrates the effects of the RepeatBehavior property in relation to an
animation’s Duration. The first three bars illustrate how to use the RepeatBehavior to
specify the total number of times a Timeline should run. The last three bars show how
to use the RepeatBehavior to specify a specific length of time for a Timeline.
 As shown in the first three bars, you can append an x as the suffix to a positive,
double-precision value. This suffix informs Silverlight that you want an animation to
run a specific number of times, effectively looping by that count. The total number of
times is represented as the value before the x. If the RepeatBehavior is set to 2.0x, the
animation will run two times; if the value is set to 5.0x, it’ll run five times.
 If the value before the x is greater than 1.0, you may notice a jerk between the iter-
ations of the animation because, unless your animation ends with the same value that
it started with, it’ll need to jump to the start to be reset. If the value before the x is less
than 1.0, you’ll notice that the animation will stop before the animation has com-
pleted because the RepeatBehavior takes precedence over the Duration property.
This can have significant implications if you specify a time value as shown in the last
three bars of figure 13.3.
Figure 13.3
The effects of the RepeatBehavior on a Timeline with a Duration of 10 seconds

282
CHAPTER 13
Animation and behaviors
By specifying a specific length of time for the RepeatBehavior, you’re informing the
Timeline to repeat as many times as possible until the time has elapsed. This length of
time is specified using the TimeSpan HH:MM:SS format, or you can use the Forever
value to make the Timeline run until you programmatically force the animation to
stop. Either way, at times you may want a more cyclical animation in combination with
the RepeatBehavior. For these situations, consider the AutoReverse property.
TURN IT AROUND
The AutoReverse property enables you to automatically play a Timeline in reverse
after it has played once forward. This Boolean property is, by default, set to false.
Changing this property value to true can enable you to deliver, for example, a pulsat-
ing effect. Note that changing this property to true can have residual effects on the
overall playback of a Timeline.
 By setting the AutoReverse property to true, you can double the overall playback
time of a Timeline. When the AutoReverse property is true, a Timeline isn’t
deemed finished until it plays once forward and once backward. If you’re specifying a
number of iterations within the RepeatBehavior property, a single iteration will take
twice as long. 
 Once an iteration has completed, you should have the ability to decide how it
should behave.
HOW WILL IT END?
When an animation reaches the end of a Timeline, it normally stays (or holds) at the
end value, but the FillBehavior property gives you the opportunity to determine
what to do. When the end is reached, you can tell the playback what to do using one
of the options provided by the FillBehavior enumerator. These options and their
descriptions are shown in table 13.2.
You have two options: stay at the end or reset to the beginning. But the beginning of a
Timeline isn’t necessarily what it may seem. This beginning of a Timeline can be
altered by the BeginTime property.
FROM THE TOP
The BeginTime property represents when to start playing a Timeline. In reality, this
property behaves as an offset, which can be set using the familiar TimeSpan format. By
default, the BeginTime property’s value is set to null, which translates to 0:0:0. This
setting is why animations begin playing immediately when told to do so. You can set
Table 13.2
Available FillBehavior options
Value
Description
HoldEnd
When completed, a Timeline will stay at the end until told otherwise. This 
is the default value for the FillBehavior property.
Stop
Once the Timeline has completed, the playback position will automatically 
reset to the beginning.

283
Storyboards
this value to another TimeSpan value to provide an offset, as shown in this example,
which builds on listing 13.3:
<DoubleAnimation Storyboard.TargetName="myImage"
                 Storyboard.TargetProperty="Opacity" 
                 From="0" To="1"
                 BeginTime="0:0:1" Duration="0:0:2" />
This code shows an Image that fades in over the course of two seconds. Unlike the pre-
vious animations, this one won’t start immediately. Instead, once the animation begins
to play, it waits until the time specified within the BeginTime property has elapsed.
Once this time period has elapsed, the image begins to fade into view. Because of this,
you can assume the entire animation in this example takes six seconds to complete.
 The BeginTime property may seem somewhat odd. It is sort of odd if you consider
it only in regard to a single animation, but this property provides a significant amount
of value when you have multiple animations working together. To make use of multi-
ple animations, you must take advantage of the required Storyboard element. 
13.3
Storyboards
Every animation created within Silverlight must be defined within a Storyboard. The
concept of a storyboard is very commonly used in visual media arts, such as 3D anima-
tion, and even movie and TV production. In Silverlight, a Storyboard enables you to
organize multiple animations that work together simultaneously. Often, these anima-
tions work on different properties across different UI elements. 
 Consider, for example, moving both the X and Y values of an element’s location.
You could do that with a point animation, or with two separate animations each target-
ing a Canvas X/Y property. Imagine now that you also want to fade the element in over
the same time. Coordinating all two or three of these animations would be difficult if
they were completely autonomous. 
 Storyboards provide another benefit: abstraction. You’ll sometimes need to refer
to animation within code. Encapsulating that animation into a storyboard provides a
layer of abstraction between the code and the user experience design, allowing
designers the freedom to change the actual animations all they want, as long as they
stay within the named storyboard.
 Given these scenarios, it makes sense to have a way to collectively organize and
control them. Thankfully, the Storyboard enables you to do just that.
13.3.1 Understanding the storyboard
A Storyboard is an umbrella under which multiple animations can be defined to
address a common scenario. From a development perspective, a Storyboard can be con-
sidered a collection or grouping of animations. This grouping provides you with a way
to easily target and control one or more animations. The syntax is shown this example:
<Storyboard x:Name="myStoryboard">
  <!-- The common animations -->
</Storyboard>

284
CHAPTER 13
Animation and behaviors
This Storyboard element could have any number of animations placed inside it. You
can place other Storyboard elements within it if you so desire because the Children
property of a Storyboard is a collection of Timeline elements. You can add any type
of animation or other Storyboard elements because they derive from the Timeline
class. Listing 13.4 shows how you can intertwine types within a single Storyboard.
<Grid x:Name="LayoutRoot" Background="White">
  <Grid.Triggers>
    <EventTrigger RoutedEvent="Canvas.Loaded">
      <BeginStoryboard>
        <Storyboard x:Name="myStoryboard"              
                    Storyboard.TargetName="myRectangle">
          <DoubleAnimation x:Name="myDoubleAnimation"
                           Duration="00:00:03"
                           Storyboard.TargetProperty="Opacity"
                           From="0" To="1" />
          <ColorAnimation x:Name="myColorAnimation"
                          Storyboard.TargetProperty=
                              "(Shape.Fill).(SolidColorBrush.Color)"
                          Duration="00:00:03"
                          From="Red" To="Blue" />
        </Storyboard>
      </BeginStoryboard>
    </EventTrigger>
  </Grid.Triggers>
  <Rectangle x:Name="myRectangle"
             Width="180" Height="60"
             Fill="Red"
             Opacity="0" />
</Grid>
This listing shows a Storyboard that changes a Rectangle from red to blue as it fades
into view. This small sample begins to show the power of the Storyboard. Before I dis-
cuss the other powerful features of the Storyboard, let’s look at how to define the tar-
get of your animations.
13.3.2 Storyboard target
As mentioned earlier, the Storyboard exposes two attached properties that can be
used to set the target of an animation. The first is TargetName, and the second is
TargetProperty. These two property values are codependent—both are required to
create an animation. Without these values, your animations won’t know what to ani-
mate. If you define these two values within a Storyboard, you can share their values
across the child Timeline elements.
 You can specify the TargetName and TargetProperty either at the Storyboard
level or the Timeline (animation) level. You can also split the values across the two
objects, depending on what saves you the extra typing.
Listing 13.4
Syntax of Storyboard element with multiple animations
Storyboard

285
Storyboards
 As shown in the previous listing, the Storyboard uses the TargetName attached
property to specify the target of the animation. Each of the child animations uses the
same target element. If one of these animations needs to use a different element, you
can trump this value by providing a different TargetName value, using the approach
shown in the following listing.
<Grid x:Name="LayoutRoot" Background="White">
  <Grid.Triggers>
    <EventTrigger RoutedEvent="Canvas.Loaded">
      <BeginStoryboard>
        <Storyboard x:Name="myStoryboard"
                    Storyboard.TargetName="OuterRectangle"
                    Duration="0:0:5">          
          <ColorAnimation Storyboard.TargetProperty=
                         "(Shape.Fill).(SolidColorBrush.Color)"
                         From="Red" To="Blue" />
          <DoubleAnimation Storyboard.TargetName="InnerRectangle"
                           Storyboard.TargetProperty="Opacity"
                           From="0" To="1" />      
          <DoubleAnimation Storyboard.TargetProperty="Width" 
                           To="400" />
          <DoubleAnimation Storyboard.TargetProperty="Height" 
                           To="300" />
        </Storyboard>
      </BeginStoryboard>
    </EventTrigger>
  </Grid.Triggers>
  <Rectangle x:Name="OuterRectangle"
             Width="180" Height="120" Fill="Red" />
  <Rectangle x:Name="InnerRectangle"
             Width="90" Height="30" Opacity="0" Fill="Pink" />
</Grid>
Listing 13.5 shows a storyboard with animations that all share a common duration.
This is typical but not required, because the durations could be overridden at the ani-
mation level. This listing also defines the primary target of the Storyboard as Outer-
Rectangle. This target is used by color and opacity animations. The Width and Height
animations use InnerRectangle as the target instead of OuterRectangle. This is
accomplished by overriding the TargetName value set in the storyboard itself. Note
that each animation targets a separate property. To target a property within an anima-
tion, you use the TargetProperty attached property. As you’ve probably guessed, this
attribute allows you to specify which property of the target element should be ani-
mated. You can specify the name of this property in a couple of ways.
Listing 13.5
Animation overriding target of its parent Storyboard
Common 
duration
Opacity
Width
Height

286
CHAPTER 13
Animation and behaviors
 The first and most explicit approach involves setting the name of the property you
intend to animate. This approach is used by the Opacity, Width, and Height anima-
tions. Generally, this approach will work for most of the properties throughout the
Silverlight APIs, but it won’t always be enough.
 Consider the situation where you want to change the color of a Brush. Generally,
the color of a Brush is defined as a property within a property within a property. This
is shown in the myColorAnimation animation of listing 13.5. Although at first this may
not seem possible within XAML, there’s a way.
XAML supports a flexible property path model that enables you to access nested
properties. This model allows you to access the individual properties by drilling
through the hierarchy using element types. To drill down through the hierarchy, you
begin at an element type. From there, you access a specific property by using a period
as a delimiter. If the property represents a collection, you can access the individual
items by using an indexing syntax. To gain a firmer understanding of these syntactical
details, review listing 13.6.
<Grid x:Name="LayoutRoot" Background="White">
  <Grid.Triggers>
    <EventTrigger RoutedEvent="Canvas.Loaded">
      <BeginStoryboard>
        <Storyboard x:Name="myStoryboard"
                    Duration="0:0:5"
                    Storyboard.TargetName="Rect">
        <ColorAnimation Storyboard.TargetProperty=
"(Shape.Fill).(GradientBrush.GradientStops)[0].(GradientStop.Color)"
                        To="White" />
        <ColorAnimation Storyboard.TargetProperty=
"(Shape.Fill).(GradientBrush.GradientStops)[2].(GradientStop.Color)" 
                        To="Black" />
      </Storyboard>
    </BeginStoryboard>
  </EventTrigger>
</Grid.Triggers>
<Rectangle x:Name="Rect" Width="120" Height="60">
  <Rectangle.Fill>
    <LinearGradientBrush EndPoint="1,0.5"
                         StartPoint="0,0.5">
      <GradientStop Color="Red" Offset="0.25" />  
      <GradientStop Color="Green" Offset="0.5" />
      <GradientStop Color="Yellow" Offset="0.75" />  
    </LinearGradientBrush>
  </Rectangle.Fill>
</Rectangle>
</Grid>
The previous listing shows how to use the property path syntax to access the individual
colors used within the LinearGradientBrush. An index of 0 is used within the first
ColorAnimation to reference the first GradientStop in the brush. At the same time,
Listing 13.6
Complex property paths in XAML Storyboards
Index 0
Index 1
Index 2

287
Storyboards
an index of 2 is used in the second ColorAnimation to change the color of the third
GradientStop. In addition to the indexing syntax, it’s important to recognize the use
of the parentheses around each property.
 Parentheses are used in the property path syntax to group a property with an ele-
ment. As shown in listing 13.6, you can’t begin by drilling into a property; instead, you
begin with an element type. From there, you specify the name of the property you
want to animate and continue by delimiting with a period. This syntax is depicted in
figure 13.4.
 The figure shows the general syntax used for referencing properties using this
property path syntax. This approach makes it easy to access items that haven’t been
explicitly named. This syntax enables you to readily take control of the properties
within an element without having to name the element explicitly. Equally important is
the way that Silverlight enables you to take control of the Storyboard itself.
13.3.3 Controlling the Storyboard
The Storyboard class exposes a number of valuable methods that enable you to pro-
grammatically control an animation. These methods, shown in the next table, reflect
many of the features you may have seen within the MediaElement. I’ll cover the Media-
Element in appendix B of the ebook. 
The methods described in this table enable you to programmatically interact with a
Storyboard. In doing so, you can easily deliver a dynamic animation experience. This
experience may involve leaping forward to a later part in an animation or giving
the user control via interactive playback features. Either way, an important part of
interacting with an animation involves knowing when it’s finished. Thankfully, the
Storyboard exposes the Completed event.
Table 13.3
Methods associated with the Storyboard object
Method
Description
Begin (...)
This method starts the animations that are the Children of the Storyboard.
Pause (...)
Halts the playback of the animations associated with a Storyboard and preserves 
the current position.
Resume (...)
Continues the animations associated with a Storyboard from a previous position.
Seek (...)
Skips to a new position within a Storyboard. The position is represented as a 
TimeSpan value.
Stop (...)
Halts the playback of the animations associated with a Storyboard and resets the 
playback position to the beginning of the Storyboard.
Figure 13.4
The property path 
syntax in action

288
CHAPTER 13
Animation and behaviors
 The Completed event is the only event exposed by the Storyboard element. In
reality, this event is part of the Timeline. Regardless, the Completed event is triggered
when the assigning Storyboard has finished naturally (calling Stop won’t raise the
event). A Storyboard is deemed finished once all its child Timeline elements have
completed. Listing 13.7 shows how to chain animations by first showing the Image per-
forming one complete rotation when a user clicks it. Once this animation has com-
pleted, it’ll use the Completed event to chain in another animation to fade the Image
out of view.
<Grid x:Name="LayoutRoot" Background="White" Margin="10">
  <Image x:Name="myImage"
         RenderTransformOrigin="0.5,0.5"
         Source="Assets/man.png"
         MouseLeftButtonUp="myImage_MouseLeftButtonUp">
    <Image.Resources>
      <Storyboard x:Name="RotateImage"
                  Completed="RotateImage_Completed">   
        <DoubleAnimation Storyboard.TargetName="myImage"
                              Storyboard.TargetProperty=
        "(UIElement.RenderTransform).(RotateTransform.Angle)"
                           Duration="0:0:2"
                           From="0" To="360" />
      </Storyboard>
      <Storyboard x:Name="FadeOut">
        <DoubleAnimation Storyboard.TargetName="myImage"
                         Storyboard.TargetProperty="Opacity"
                         Duration="0:0:2"
                         From="1" To="0" />
    </Storyboard>
  </Image.Resources>
            
  <Image.RenderTransform>
    <RotateTransform Angle="0" />
  </Image.RenderTransform>
  </Image>
</Grid>
C# 
private void RotateImage_Completed(object sender,   
                                   EventArgs e)
{
  FadeOut.Begin();                      
}
private void myImage_MouseLeftButtonUp(object sender,  
                                       MouseButtonEventArgs e)
{
  RotateImage.Begin();
}
Listing 13.7
Using the Playback methods and Completed event
Completed event
 Completed handler
Chain Storyboard
Button event handler

289
Storyboards
Listing 13.7 shows how you can programmatically use the Completed event as well as
one of the interactive playback methods. When the user clicks the Image, the Story-
board defined as RotateImage will begin playing. Once this Storyboard has finished
playing, the Completed event associated with it will be triggered. This event handler
will then start the animation defined in FadeOut. This example also shows how you
can define an animation as a resource. I’ll cover resources in depth in chapter 14, but
in the specific context of animations, it bears a little diving into here. 
13.3.4 Resources
Storyboard elements enable you to create complex and intricate animations. These
animations may be used in response to an event or to something that has occurred
behind the scenes. Because of this, you need multiple ways to interact with a Story-
board. Thankfully, Silverlight gives you two approaches for organizing Storyboard
elements. You can define a Storyboard as either a resource or a trigger.
STORYBOARD AS A RESOURCE
The first approach for organizing a Storyboard involves defining it as a resource. A
resource is an easy way to set aside a commonly used item for reuse, as you’ll see in
detail in the next chapter. This item—in our case, a Storyboard—can be defined as a
resource by creating it within the Resources collection of a UIElement. This can be
accomplished by either programmatically adding it through code or creating it within
XAML, as shown in listing 13.8.
<Grid x:Name="LayoutRoot" Background="White" Margin="15">
  <Canvas>
    <Canvas.Resources>
      <Storyboard x:Key="myStoryboard">
        <DoubleAnimation Duration="00:00:01"
                         Storyboard.TargetName="myImage"
                         Storyboard.TargetProperty="Opacity"
                         From="1"To="0" />
      </Storyboard>
    </Canvas.Resources>
    <Image x:Name="myImage"
           Source="Assets/man.png" />
  </Canvas>
</Grid>
This example shows how easy it is to define a Storyboard as a resource in XAML. The
definition of the Storyboard is placed within the Resources collection of the root Can-
vas. The root element of a Silverlight page is generally where you’ll place your
resources because it makes the resources accessible to all the elements within the page.
Thankfully, the Resources collection can store as many or as few resources as you need.
 Once a Storyboard is defined as a resource, it’s your responsibility to start it. You
must first programmatically retrieve it. This step involves retrieving the Storyboard by
Listing 13.8
Defining a Storyboard as a resource

290
CHAPTER 13
Animation and behaviors
key. The following example shows the Storyboard from listing 13.8 being retrieved
from the Resources collection, then programmatically started via the Begin method:
var myStoryboard = (Storyboard)(myCanvas.Resources["myStoryboard"]);
myStoryboard.Begin();
This code illustrates how simple it is to programmatically start a Storyboard defined
as a resource. 
 There are times when you know that a specific action should automatically start a
Storyboard. For these situations, Silverlight provides an elegant shortcut that enables
you to automatically start a Storyboard when a defined event occurs.
STORYBOARD AS A TRIGGER
The second approach for defining a Storyboard involves setting it as an event han-
dler, an approach illustrated several times in this chapter. An EventTrigger is a spe-
cial element that enables you to declaratively define a response for a specified event.
When this event occurs, the EventTrigger automatically starts the defined Story-
board. To accomplish this, you follow a few simple steps.
 First you decide which event you want to respond to. Currently, the only event sup-
ported within the EventTrigger is the Loaded event. To specify this event as the trig-
gering event, you must identify the type of object responsible for the event. Once it’s
identified, you can set it, as well as the event, through the RoutedEvent property, as
shown in this example:
<EventTrigger RoutedEvent="Canvas.Loaded">
  <!-- Insert Actions here -->
</EventTrigger>
As this code shows, the RoutedEvent property uses a syntax that resembles elementType-
Name.eventName. The type name comes from the parent type. Generally, you’ll be able
to retrieve this type name from the attached property containing the trigger. This
attached property is called Triggers, and it’s available from all UIElement objects. If
you were to expand on the previous code example, you should have something like
this XAML fragment:
<Canvas.Triggers>
  <EventTrigger RoutedEvent="Canvas.Loaded">
    <!-- Insert Actions here -->
  </EventTrigger>
</Canvas.Triggers>
This example shows how the EventTrigger has been added to a Canvas. Significantly,
this doesn’t mean that the target of the Storyboard will be the Canvas. Instead, as dis-
cussed earlier, the target of the Storyboard is set within the Storyboard itself. To set
the target of the Storyboard, you first define the Storyboard.
 If you’re defining a Storyboard within an EventTrigger, you must associate it with
an action. Currently, Silverlight only provides one action called BeginStoryboard,
which starts a Storyboard when called. You must use this action if you’re creating an

291
Keyframing
EventTrigger. To put all the pieces together, defining a Storyboard as a trigger would
look like this listing.
<Grid x:Name="LayoutRoot" Background="White" Margin="15">
  <Canvas Width="100" Height="100">
    <Canvas.Triggers>
      <EventTrigger RoutedEvent="Canvas.Loaded">
        <BeginStoryboard>
          <Storyboard x:Name="myStoryboard">
            <DoubleAnimation Duration="00:00:01"
                             Storyboard.TargetName="myImage"
                             Storyboard.TargetProperty="Opacity"
                             From="0" To="1" />
          </Storyboard>
        </BeginStoryboard>
      </EventTrigger>
    </Canvas.Triggers>
            
    <Image x:Name="myImage" Source="Assets/man.png" />
  </Canvas>
</Grid>
Listing 13.9 shows a Storyboard defined as a trigger. Although this approach is great
for use in quick examples like those you’ve seen so far, the official Silverlight docu-
mentation recommends against using a trigger, as visual states (covered in chapter 14)
and behaviors (covered in section 13.7) are often better ways to start the animation.
 The animations contained in storyboards, regardless of where they’re defined or
how they’re started, are all about changing a dependency property over time. As
you’ve seen, this process works in a linear fashion interpolating between the From and
To values in, quite frankly, a rather boring way. If you want to create more realistic and
organic animations, you’ll need to first learn about a technique known as keyframing. 
13.4
Keyframing
In the realm of traditional cell animation (think Disney), the top animators will often
present a high-level overview of a story by drawing out the main images. These images
generally represent key points in some sort of movement, also known as the keyframes
of an animation. More junior (or often, outsourced) animators then fill in the blanks,
as the hard work has been done, and the rest is just a long, boring march to fill in the
missing frames.
 Once the keyframes are created, the process of creating the animation in between
them is fairly straightforward. Within software, this process of creating the in-between
frames is known as interpolation, or tweening.
 In motion graphics and 3D animation, as well as platforms like Silverlight, the ani-
mator creates these keyframes and lets the system interpolate the in-between frames
using a variety of possible formulas. In fact, a key selling point of many animation sys-
tems is the breadth and quality of the formulas and functions provided. If the frame
Listing 13.9
Defining a Storyboard as an event trigger

292
CHAPTER 13
Animation and behaviors
rate changes (to have greater or fewer frames per second), the platform can easily
recalculate the in-between frames, requiring no additional work on the part of the
animator.
 To firmly grasp the concept of how keyframe animations can be used, consider the
task of animating a bouncing ball. If you were to attempt to animate an ellipse to try to
approximate a bounce, the ball may look like that in figure 13.5 over some period of
time.
 The arrows shown in the previous figure represent two things within the anima-
tion: the direction in which the ball is bouncing and the parts of the animation cre-
ated via interpolation. This process of interpolation enables you to ignore having to
define the To, From, and By property values you were using earlier. Instead, you must
create a KeyFrame for each discrete location within an animation. Listing 13.10 shows
the XAML to reproduce the animation shown in figure 13.5.
<Canvas x:Name="LayoutRoot" Background="White">
  <Canvas.Triggers>
    <EventTrigger RoutedEvent="Canvas.Loaded">
      <BeginStoryboard>
        <Storyboard x:Name="myStoryboard">
          <DoubleAnimationUsingKeyFrames 
                       Storyboard.TargetName="myEllipse"   
                       Storyboard.TargetProperty="(Canvas.Left)">
            <LinearDoubleKeyFrame KeyTime="00:00:00" Value="0" />
            <LinearDoubleKeyFrame KeyTime="00:00:01" Value="77" />
            <LinearDoubleKeyFrame KeyTime="00:00:02" Value="148" />
            <LinearDoubleKeyFrame KeyTime="00:00:03" Value="223" />
            <LinearDoubleKeyFrame KeyTime="00:00:04" Value="315" />
            <LinearDoubleKeyFrame KeyTime="00:00:05" Value="397" />
          </DoubleAnimationUsingKeyFrames>
          <DoubleAnimationUsingKeyFrames 
                       Storyboard.TargetName="myEllipse"  
                       Storyboard.TargetProperty="(Canvas.Top)">
Listing 13.10
Creating a bouncing ball using keyframes
Figure 13.5
A bouncing ball over some 
variable amount of time

293
Interpolation
            <LinearDoubleKeyFrame KeyTime="00:00:00" Value="0" />
            <LinearDoubleKeyFrame KeyTime="00:00:01" Value="132" />
            <LinearDoubleKeyFrame KeyTime="00:00:02" Value="42" />
            <LinearDoubleKeyFrame KeyTime="00:00:03" Value="132" />
            <LinearDoubleKeyFrame KeyTime="00:00:04" Value="81" />
            <LinearDoubleKeyFrame KeyTime="00:00:05" Value="132" />
          </DoubleAnimationUsingKeyFrames>   
        </Storyboard>
      </BeginStoryboard>
    </EventTrigger>
  </Canvas.Triggers>
  <Ellipse Width="50" Height="50" x:Name="myEllipse"
           Fill="Maroon" Stroke="Black" />
</Canvas>
The listing illustrates the general syntax of a KeyFrame. This example uses two key-
frame animations to move an Ellipse around the Canvas. The new position of the
Ellipse is interpolated between the values specified within the Value property of
each KeyFrame. The KeyFrame determines how to interpolate by the formula imple-
mented in the specific type of KeyFrame, in this case, a LinearDoubleKeyFrame.
 The type of KeyFrame always follows a naming template that mimics [interpolation-
Type]propertyTypeKeyFrame. This syntax specifies the type of property that’s the target of
the animation. The syntax also specifies what type of interpolation should be used to
generate the in-between values. To simultaneously address both important items, Sil-
verlight provides the keyframe types shown in the following table.
Each type of keyframe helps to address specific animation scenarios. To understand
when a specific type of animation is relevant, it’s important to understand the various
types of interpolation.
13.5
Interpolation
An interpolation type gives you control over how an animation will accelerate or deceler-
ate as it progresses. The interpolation type signals how an animation should estimate
the values in between keyframes. To estimate the values as you see fit, Silverlight pro-
vides three interpolation types: linear, spline, and discrete.
Table 13.4
The keyframe types available within Silverlight
Discrete keyframe types
Linear keyframe types
Spline keyframe types
DiscreteColorKeyFrame 
LinearColorKeyFrame 
SplineColorKeyFrame 
DiscreteDoubleKeyFrame
LinearDoubleKeyFrame 
SplineDoubleKeyFrame 
DiscreteObjectKeyFrame 
DiscretePointKeyFrame 
LinearPointKeyFrame
SplinePointKeyFrame

294
CHAPTER 13
Animation and behaviors
13.5.1 Linear interpolation
Linear interpolation constructs the most direct transition between two keyframes and
happens to be the default in Silverlight. The “linear” name is used because the change
between two keyframes occurs at a constant or linear rate. Figure 13.6 shows an object
moving between several points using this type of interpolation.
 The idea of using an animation that occurs at a constant, predictable rate at first
seems appealing. But, as the previous figure shows, you can easily end up with an ani-
mation with lots of pointy bits as opposed to smooth transitions, like robots making
exact 90-degree turns instead of cutting the corners a little. This effect occurs because
the transition between two linear keyframes occurs in distinct stages without any eas-
ing in or out. These stages may be desirable in some cases, but if they aren’t, there’s a
way to create even smoother transitions thanks to spline interpolation.
13.5.2 Spline interpolation
Splines are generally used to create smooth, seamless transitions. These transitions
occur by estimating the values as if they were generated along a Bézier curve. This
curve represents the values to use within a time segment. To illustrate, figure 13.7
shows a curved interpolation.
 If you compare figure 13.7 to figure 13.6, you can see how using splines allows you
to create much smoother transitions between keyframes. Note that the line in this figure
Figure 13.6
How linear interpolation is 
determined. Note the straight 
lines between points.
Figure 13.7
An example using spline 
interpolation for approximation

295
Interpolation
doesn’t represent the path that the ball travels along. Instead, the line gives the illusion
of varying speeds. These varying speeds are controlled through the KeySpline property.
 The KeySpline property enables you to control the progress of an animation
through two control points, which determine the curve that the values are interpo-
lated along. By default, this curve resembles a straight line. To generate values along
something other than a line, you must understand how the KeySpline relates values
to points in time. This relationship, as well as the KeySpline syntax, is shown in the
following figure.
 Figure 13.8 shows the default curve defined by the KeySpline property. The two
control points used in this figure are specified as 0.0,0.0 1.0,1.0. These control
points always follow the format x1,y1 x2,y2. In addition, each coordinate within each
point is specified as a positive double-precision value between 0.0 and 1.0. Anything
outside of this range will create a runtime error.
 The first point defined within the
KeySpline property determines how
values will be generated along the first
half of the curve. The second point
defined within the KeySpline prop-
erty determines how values will be cre-
ated along the second half of the
curve. Either way, if the y value is
greater than the x value, the animation
will run more quickly. Alternatively, if
the x value is greater than the y value,
the animation will run slower. Figure
13.9 shows sample curves along with
their respective KeySpline values.
Figure 13.9
Sample time/value curves
used by the KeySpline property
Figure 13.8
The relationship 
between time and value as used 
by the KeySpline property

296
CHAPTER 13
Animation and behaviors
The curves shown in the previous figure represent potential curves you can use for
interpolating values. In reality, you’ll need to play with these values until your key-
frame animation feels right—something best done using Expression Blend, not just
tinkering with numbers in XAML. Once you let the tool do the hard work, you’ll find
that creating smooth animations is pretty straightforward. On the opposite end of the
smoothness scale from spline interpolation is discrete interpolation.
13.5.3 Discrete interpolation
Occasionally, you may have to create an animation that jumps between values. These
rifts seem counterintuitive within the realm of animation because animations are gen-
erally considered to be smooth. But what if you were creating an animation that
depicted a Whack-a-Mole game?4 In a Whack-a-Mole game, small critters appear at
random from dark holes. This surprising effect can be effectively recreated using dis-
crete interpolation.
 When discrete interpolation is used, Silverlight generates sudden changes between
two keyframes. These sudden changes make it appear as if the interpolation doesn’t
occur at all. That’s because it doesn’t! Figure 13.10 illuminates how the discrete
method interpolates.
 The illustration in the figure is difficult to make sense of. Everything seemingly
occurs at random, just like Whack-a-Mole. 
 Although randomness has its place, you often need control over when a keyframe
occurs. Luckily, there’s a property that allows you to do just that—KeyTime.
13.5.4 KeyTime
The KeyTime property of a KeyFrame represents the time at which the value specified
within a KeyFrame will be reached. In a sense, the KeyTime sort of represents a book-
mark within an animation. But the position of this bookmark is completely dependent
on the TimeSpan value you use.
4 Yes, this is a stretch. But I can tell you that in years of working with Silverlight, and in the couple years of look-
ing at what everyone else has done, I’ve never seen anyone use discrete interpolation in the wild.
Figure 13.10
An example using discrete 
interpolation for approximation

297
Easing functions
By providing a TimeSpan value, you can specify the exact point in time when a Key-
Frame should be reached. This point in time is relative to the beginning of the anima-
tion that the KeyFrame is defined within, so the order of the keyframe elements is
irrelevant. But this value still has to be assigned to the KeyTime property, as shown in
the next listing. In addition, the example illustrates how the animation would be ren-
dered.
Result:
XAML:
<Canvas x:Name="LayoutRoot" Background="White">        
  <Canvas.Triggers>
    <EventTrigger RoutedEvent="Canvas.Loaded">
      <BeginStoryboard>
        <Storyboard x:Name="myStoryboard" 
                    Storyboard.TargetName="myImage" 
                    Storyboard.TargetProperty="(Canvas.Left)">
          <DoubleAnimationUsingKeyFrames Duration="00:00:08">
            <LinearDoubleKeyFrame Value="50" KeyTime="00:00:01" />  
            <LinearDoubleKeyFrame Value="250" KeyTime="00:00:03.5" />
            <LinearDoubleKeyFrame Value="325" KeyTime="00:00:06" />
            <LinearDoubleKeyFrame Value="500" KeyTime="00:00:08" />
          </DoubleAnimationUsingKeyFrames>
        </Storyboard>
      </BeginStoryboard>
    </EventTrigger>
  </Canvas.Triggers>
  <Image x:Name="myImage" Source="Assets/car.png" />
  </Canvas>
Listing 13.11 shows the typical approach for defining KeyFrame elements within an
animation. The KeyTime value in each KeyFrame is set to a TimeSpan value. This
approach provides a convenient and verbose way to perform an animation. This
example shows how important the KeyTime property is in keyframe animations, which
are the types of animations created by Expression Blend.
 These animations have been interesting, but they’ve all lacked a certain amount of
“pop” we’ve come to expect from modern applications. That’s because they’re not
using any sort of easing functions with the keyframes. Let’s fix that next. 
13.6
Easing functions
Easing functions provide a way to liven up what would otherwise be pretty flat and bor-
ing animation. They provide acceleration/deceleration, and even bounce or spring to
the approach into (or departure from) a keyframe in an animation. They are both
easier to use and more realistic than spline interpolation.
Listing 13.11
Using a TimeSpan value to specify the KeyTime

298
CHAPTER 13
Animation and behaviors
 If you’ve found animation to be a
little too computer-generated so far,
you’ll appreciate the more organic
effect that easing functions provide.
Easing functions perform a function
f over time t. Time is provided by the
animation system; the easing func-
tion returns a value, normally
between zero and one (it can over-
and undershoot) that indicates
progress toward the final value speci-
fied in the animation. I’ll cover
more of the inner workings in the
second half of this section when you
create your own easing function.
 Easing functions have three
modes of use: EaseIn, EaseOut, and
EaseInOut. The modes affect how
the easing function is applied to the
animation over time. These modes
are easier seen than read. Figure
13.11 illustrates what the built-in
ElasticEase easing function looks
like in all three of its modes.
 From figure 13.11, you can see
that EaseIn and EaseOut are oppo-
sites; EaseOut is the EaseIn function
in reverse. EaseInOut is a little trick-
ier. In that mode, the overall time
remains the same, but the function
used is a combination of EaseIn and
EaseOut. 
 In this section, I’ll first describe how to use the great library of built-in easing func-
tions. Then, because customization is especially important when it comes to some-
thing as design-sensitive as how an animation functions over time, I’ll show you how to
build your own easing functions.
13.6.1 Using easing functions
Easing functions are used with special keyframes that start with the word Easing.
These keyframes provide a property named EasingFunction, which accepts an easing
Figure 13.11
The three modes: EaseIn, EaseOut, 
and EaseInOut for the ElasticEase easing 
function

299
Easing functions
function to be used on that specific keyframe. Silverlight includes 11 built-in easing
functions, which are listed in table 13.5.
MSDN has great documentation on the easing functions, including graphics showing
each of the modes and the actual functions in use. You can find the additional infor-
mation in the MSDN online library here: http://bit.ly/MSDNEasing. 
 To use an easing function, you need to set up an animation using storyboards and
keyframes. Listing 13.12 shows an easing function attached to two animations.
<UserControl.Resources>
  <Storyboard x:Key="AnimateTarget">
    <DoubleAnimationUsingKeyFrames Storyboard.TargetName="Transform"
                                   Storyboard.TargetProperty="ScaleX">
      <EasingDoubleKeyFrame KeyTime="0:0:0" Value="0.0" />
      <EasingDoubleKeyFrame KeyTime="0:0:3" Value="5.0">
        <EasingDoubleKeyFrame.EasingFunction>
          <ElasticEase EasingMode="EaseOut"
                       Oscillations="3" Springiness="2" /> 
        </EasingDoubleKeyFrame.EasingFunction>
Table 13.5
Built-in easing functionsa 
a. If you’re not sure what things like Cubic, Quartic, and Qunitic mean, and don’t have a good math book handy, try them 
out. Either that or just think “Cool, nonlinear acceleration for my animation.” 
Easing function
Description
BackEase
Retracts the motion of an animation slightly before it begins to animate in 
the path indicated.
BounceEase 
Creates a bouncing effect, like a rubber ball.
CircleEase 
Accelerates or decelerates using a circular function.
CubicEase
Accelerates or decelerates using a cube function (time cubed).
ElasticEase 
An animation that resembles the oscillation of a spring. The lower the sup-
plied Springiness parameter, the more elastic the bounce. You can go 
crazy with this and create some really fun animation.
ExponentialEase
Accelerates or decelerates using a formula based around the supplied 
exponent.
PowerEase 
Accelerates or decelerates using a formula based on the supplied power.
QuadraticEase 
Accelerates or decelerates using a squaring function.
QuarticEase 
Accelerates or decelerates using a power of 4 function.
QuinticEase 
Accelerates or decelerates using a power of 5 function.
SineEase
Accelerates or decelerates using the sine function.
Listing 13.12
Using the ElasticEase for some crazy animation
Easing function 
parameters

300
CHAPTER 13
Animation and behaviors
      </EasingDoubleKeyFrame>
    </DoubleAnimationUsingKeyFrames>
    <DoubleAnimationUsingKeyFrames Storyboard.TargetName="Transform"
                                   Storyboard.TargetProperty="ScaleY">
      <EasingDoubleKeyFrame KeyTime="0:0:0" Value="0.0" />
      <EasingDoubleKeyFrame KeyTime="0:0:3" Value="5.0">
        <EasingDoubleKeyFrame.EasingFunction>
          <ElasticEase EasingMode="EaseOut"
                       Oscillations="3" Springiness="2" /> 
        </EasingDoubleKeyFrame.EasingFunction>
      </EasingDoubleKeyFrame>
    </DoubleAnimationUsingKeyFrames>
  </Storyboard>
</UserControl.Resources>
<Grid x:Name="LayoutRoot" Background="White" Margin="15">
  <Rectangle Height="20" Width="20" Fill="BlueViolet"
             RenderTransformOrigin="0.5,0.5">
    <Rectangle.RenderTransform>
      <ScaleTransform x:Name="Transform" />    
    </Rectangle.RenderTransform>
  </Rectangle>
  <Button x:Name="StartAnimation" Content="Start"
          HorizontalAlignment="Center" VerticalAlignment="Bottom"
          Width="100" Height="25" Margin="5"
          Click="StartAnimation_Click"/>    
</Grid>
Listing 13.12 contains a single rectangle to be animated. The things you’ll be animat-
ing are the ScaleX and ScaleY properties of the ScaleTransform attached to the rect-
angle. The result is a spring-type animation, which looks like you’re sitting directly
below a block suspended from a rubber band. 
 To start the animation, use a button with the event handler wired up in markup.
The code-behind code in the event handler is a single line:
private void StartAnimation_Click(object sender, RoutedEventArgs e)
{
  ((Storyboard)Resources["AnimateTarget"]).Begin();
}
The line of code in the event handler finds the resource named AnimateTarget and,
assuming it’s a Storyboard, calls the function to start animating. With this code in
place, run the application and click the button. You’ll see the rectangle bounce in and
out until it comes to a quick rest. Try changing the Oscillations or Springiness
parameters in the easing function for very different effects: Oscillations controls the
number of bounces; Springiness controls the depth of the bounces.
 The built-in easing functions will serve the vast majority of your needs; you can cre-
ate just about any typical effect using them. What about atypical effects? What if you
want to include physics, or a function the team didn’t think of? For those situations,
the Silverlight team had the foresight to open up the API to enable you to create your
own easing functions. 
Easing function 
parameters
Event handler

301
Easing functions
13.6.2 Creating a custom easing function
The WPF and Silverlight teams put together a comprehensive set of standard easing
functions. Most folks will never need or want to write one of their own. 
 That said, you may come up with a specialized function and want to package it in a
way that enables others to use it from XAML or code in their own animation.
 To create your own easing function, you derive from EasingFunctionBase and
override the EaseInCore function.
EASINGFUNCTIONBASE
EasingFunctionBase provides the structure of an easing function. It includes the
EasingMode and its dependency property, as well as the Ease function, which is called
by the animation system. The Ease function, in turn, calls EaseInCore, the function
you provide.
EASEINCORE
This is where your easing code goes. You provide the implementation for EaseIn via
the EaseInCore code, and the runtime will automatically infer EaseOut and Ease-
InOut from that. EaseOut will be the reverse of EaseIn, and EaseInOut will be the two
together.
EaseInCore takes a double representing normalized time and expects you to
return the progress for that point in time. If you think of time as the x-axis on a graph
and progress as the y-axis, you’re taking in x as a parameter and returning y as the
result.
 A standard linear ease would return the value passed in: f(x) = x. Instantaneous
movement would be f(x) = 1. No movement (ever) would be f(x) = 0. The interesting
stuff happens when the result is between those numbers.
 Listing 13.13 shows a randomizing ease. This code uses the built-in Random object
to provide a random value that approaches the final value. The end result is a stutter-
ing animation that eventually gets to the right place.
C#:
public class RandomEase : EasingFunctionBase
{
  private Random _random = new Random();
  protected override double EaseInCore(double normalizedTime)
  {
    return normalizedTime / 2.0 + 
           _random.Next(0, 100) / 100.0 * (normalizedTime / 2.0);
  }
}
XAML:
<EasingDoubleKeyFrame.EasingFunction>
  <local:RandomEase EasingMode="EaseIn"/>
</EasingDoubleKeyFrame.EasingFunction>
Listing 13.13
A custom randomizing ease

302
CHAPTER 13
Animation and behaviors
To use this function, take the XAML from the ElasticEase demonstration and
replace the two easing functions with the XAML fragment here. Be sure to map an
XML namespace to the local application—I called mine “local.”
 Easing functions help liven up animation, providing a sometimes more organic
but always more interesting way to move a value between two bounds. The built-in eas-
ing functions cover almost every need you’ll have when animating in Silverlight. For
those cases when the built-in functions aren’t quite what you want, you can create your
own easing functions as long as you can express the equation in code.
 Easing functions were originally designed with Expression Blend in mind. Design-
ers love to be able to specify an easing function to use on a keyframe; they can do it
right from the Blend UI. Another technology that came about due to Blend, this time
from the Blend team itself, is the behavior. Behaviors are fascinating ways to add ani-
mation, code, or other reusable logic to your elements in XAML. 
13.7
Behaviors, triggers, and actions
Behaviors, triggers, and actions are odd things. They can be virtually anything and do
virtually anything. Between stock behaviors and community-created ones, I’ve seen
everything from TextBox edit masks, to drag and drop, to physics, to effects, auto-
matic animations, and even ICommand substitutes for calling methods on events.
Because behaviors and animation are so closely tied to Expression Blend, I figured I’d
pop them in here. They’re reusable designer-friendly components. They interact with
the UI, but they aren’t controls.
 Although lumped together, behaviors, triggers, and actions are conceptually differ-
ent. Behaviors are self-contained units of functionality that act as a bit of a sidecar to an
existing object. They go along for the ride and respond to the environment in which
the object exists. Triggers are much like the built-in triggers you’ve seen in this chapter
but are more flexible in their applications. Actions are simpler in concept; they’re
attached to an object and provide a way to invoke some functionality. The common way
to refer to all three is by calling them behaviors, so that’s what I’ll do in this chapter.
 The scope and power of behaviors are best understood by example. To try them
out, you need to first perform a bit of project setup to pull in the right core bits.
 To work with behaviors, you’ll need to reference two Expression Blend SDK librar-
ies. If you have Blend already installed, the SDK will be under Program Files\Microsoft
SDKs. If you don’t have Blend installed, you can still download the SDK from http://
silverlight.net; it’s free and doesn’t require Blend on the machine.
 Once you have the SDK installed, reference the two Blend libraries as shown in
figure 13.12.
 The final step is to add the appropriate namespaces into your XAML files. You’ll be
working with MainPage.xaml for the remaining examples, so place the following two
namespace declarations in the top element of that file:
xmlns:i="http://schemas.microsoft.com/expression/2010/interactivity"
xmlns:ei="http://schemas.microsoft.com/expression/2010/interactions"

303
Behaviors, triggers, and actions
With all the pieces in place, you’re ready to start playing around with behaviors. Next
you’ll  look at existing out-of-box functionality and see how to use it in your own appli-
cations. Then, because behaviors facilitate reuse and sharing, you’ll build your own
simple behavior for Silverlight.
13.7.1 Using existing behaviors
Behaviors are bits of designer-friendly packaged interactivity introduced in Silverlight
3, originally tied to Expression Blend to make it easy to drag functionality directly
onto the design surface and associate it with controls. Behaviors included capabilities
such as physics, sound, automatic shadows, drag and drop, and even nonvisual behav-
iors such as one that’s used to wire up the window-close events to a view model in WPF.
The appeal was much broader than just Blend users, though, so the functionality was
released for all Silverlight and WPF developers to enjoy.
 An interesting behavior is the DataTrigger. This performs actions when the
bound data meets a specified condition. One of my favorite behaviors is the Fluid-
MoveBehavior. Not only does that behavior have a great visual effect at runtime, but it
also builds on much of what you’ve learned about animation in this chapter.
Figure 13.12
Adding the Expression Blend SDK assemblies as references. On my machine, the 
Microsoft.Expression.Interactions library and the System.Windows.Interactivity library were 
both located in C:\Program Files\Microsoft SDKs\Expression\Blend\Silverlight\v5.0\Libraries\. 
Use the latest versions on your machine.

304
CHAPTER 13
Animation and behaviors
USING THE FLUIDMOVEBEHAVIOR
The FluidMoveBehavior helps get past abrupt layout changes. It listens to the layout
system, and when it finds a layout change, it smoothly animates from the old value to
the new value. This is extremely useful in panels such as wrap panels where resizing
may move several elements around at once.
 Listing 13.14 shows how to use the FluidMoveBehavior on a single element in the UI.
XAML:
<Grid x:Name="LayoutRoot" Background="White">
  <Rectangle x:Name="PurpleSquare" 
             Height="20" Width="20"
             HorizontalAlignment="Left" VerticalAlignment="Top"
             Margin="20" Fill="BlueViolet">
    <i:Interaction.Behaviors>
      <ei:FluidMoveBehavior Duration="0:0:4">
        <ei:FluidMoveBehavior.EaseX>
          <ElasticEase EasingMode="EaseOut"    
                       Oscillations="3" Springiness="4" />
        </ei:FluidMoveBehavior.EaseX>
        <ei:FluidMoveBehavior.EaseY>
          <ElasticEase EasingMode="EaseOut"            
                       Oscillations="3" Springiness="4" />
        </ei:FluidMoveBehavior.EaseY>
      </ei:FluidMoveBehavior>
    </i:Interaction.Behaviors>
  </Rectangle>
  <Button x:Name="StartMove"
          Content="Start"
          HorizontalAlignment="Center" VerticalAlignment="Bottom"
          Width="100" Height="25" Margin="5"
          Click="StartMove_Click" />
</Grid>
C#:
private void StartMove_Click(object sender, RoutedEventArgs e)
{
    Thickness margin = PurpleSquare.Margin;
    margin.Left += 100;
    margin.Top += 100;
    PurpleSquare.Margin = margin;            
}
The previous listing shows how to smoothly move an element from one location to
another. What would normally have been an abrupt change in location is now a four-
second animation with an elastic easing function applied. These are the same easing
functions discussed earlier in the chapter.
 Behind the scenes, this behavior builds an animation whenever layout-affecting
properties (margins, top, left, size, and so forth) are changed, and uses that animation
to move between the original layout value and the one specified.
Listing 13.14
Using the FluidMoveBehavior with an element
Easing 
function
Move square

305
Behaviors, triggers, and actions
 Other behaviors attach to objects in similar ways. The parameters may change, but
the approach is generally the same. In fact, you’ll see that when you create your own
behavior next.
13.7.2 Creating your own behavior
The System.Windows.Interactivity library includes the base classes you’ll typically
want to inherit from when creating your own behavior. There are additional special-
case base classes in the Blend library, including some that make it easier to work with
animation from within a behavior. 
 For this example, you’ll use the core Interactivity DLL and inherit from
Behavior<T> to provide a behavior that’ll allow it to be attached to certain types of
elements.
Behavior<T> has two main methods you must override in your implementation.
The first is OnAttached. OnAttached is called when the behavior is attached to an ele-
ment of type T. That element is referenced by the AssociatedObject property. The
second method is OnDetaching. This method allows you to perform any cleanup, such
as removing event handlers.
 Listing 13.15 shows the behavior attached to a button. This behavior will display a
MessageBox whenever the button is clicked. You’ll use the same FluidMoveBehavior
XAML as the previous section and attach this behavior to the Start button. 
C#:
public class CustomBehavior : Behavior<Button>
{
  protected override void OnAttached()
  {
    base.OnAttached();
    AssociatedObject.Click += new RoutedEventHandler(OnButtonClick);
  }
  protected override void OnDetaching()
  {
    base.OnDetaching();
    AssociatedObject.Click -= OnButtonClick;     
  }
  void OnButtonClick(object sender, RoutedEventArgs e)
  {
    MessageBox.Show("Button was Clicked!");
  }
}
XAML:
<Button x:Name="StartMove" Content="Start"
        HorizontalAlignment="Center" VerticalAlignment="Bottom"
        Width="100" Height="25" Margin="5"
        Click="StartMove_Click">
    <i:Interaction.Behaviors>
Listing 13.15
A behavior that displays a MessageBox when a Button is clicked
Event handler 
cleanup

306
CHAPTER 13
Animation and behaviors
        <local:CustomBehavior />
    </i:Interaction.Behaviors>
</Button>
When you run the application and click the button, you’ll first see the MessageBox
from the behavior. Then, because it’s a blocking call, once you close the box you’ll see
the FluidMoveBehavior in action.
 Once you’ve created a behavior or action that you like, be sure to share it on the
Expression Gallery at http://gallery.expression.microsoft.com. There are a ton of
interesting behaviors there; you may learn from some, and you may contribute others.
It’s a great community.
 Behaviors, triggers, and actions—collectively “behaviors”—provide an excellent
way to package reusable bits of functionality without the overhead of a custom con-
trol. The Blend SDK comes with a number of important behaviors, providing a broad
spectrum of capabilities. The Expression Gallery includes a number of other behav-
iors that you can download and use in your own applications. Already, a large number
of individuals and companies have developed and shared their own useful behaviors
with the community. And, if the existing behaviors are insufficient for your needs, you
can build your own behaviors using the same building blocks the Expression team and
community use. 
13.8
Summary
Throughout this chapter, you saw the details associated with animating elements
within Silverlight. When it comes down to it, it’s about manipulating a single property
over a time interval. This time interval can be specified within either an animation, or
higher up the tree, a Storyboard. The Storyboard enables you to organize and con-
trol multiple animations simultaneously, so you can create incredibly dramatic and
engaging effects. With the help of keyframes, these effects can be developed quickly
and efficiently. When you add easing functions into the mix, the results are visually
stunning and can provide that “pop” your application needs.
 Behaviors provide reusable packages of functionality that can span a broad spec-
trum of capabilities. Some interact with animation and easing functions; others inter-
act with code; still others enable you to play sounds or provide special movement to
elements on a page. The community at the Expression Gallery has created a large
number of reusable behaviors that you can incorporate into your own applications. If
you want to create your own from scratch or contribute to that community, you
already have all the tools you need with Visual Studio 2010 and the Blend SDK. 
 Providing an engaging user experience is no longer a luxury but is instead a hard
requirement for most applications. Providing an internally consistent user experience
is perhaps equally, if not more, valuable. Silverlight has a variety of style and template
features to help provide a consistent user experience. These features are discussed in
detail in chapter 14.

307
Resources, styles,
and control templates
Chapter 13 described the powerful animation features available in Silverlight.
These features are useful for creating entertaining illustrations and for adding a
degree of richness to your application. This richness can also be applied to con-
trols, as you’ll see in this chapter.
 Throughout this chapter, you’ll see how to apply rich styles to your application.
These styles are similar to the CSS features you may have seen in the HTML world.
In general, a Style declaration will be part of a resource, so I’ll cover resources
first. From there, you’ll learn how to manage resources in dictionaries before mov-
ing on to creating rich visual Styles themselves. I’ll discuss both explicit and
implicit styles. Then you’ll see how to expand on the definition of a Style to
define a ControlTemplate, enabling you to redefine the visual structure of a
This chapter covers
■
Using application resources
■
Controlling styling
■
Building control templates
■
Using the Visual State Manager

308
CHAPTER 14
Resources, styles, and control templates
Control. Once I’ve covered that subject, you’ll learn how to use the VisualState-
Manager to deliver engaging visual states and transition animations within your
Control elements. 
14.1
Being resourceful
In general, it’s a good idea to share project assets rather than duplicate them. This
practice makes your application more maintainable. In fact, creating reusable compo-
nents is a common idea within object-oriented languages such as C#. But sometimes
you may have items that represent nonexecutable pieces of data—for instance, an
image, a media file, or some XAML. These types of content generally fall into one of
three categories: declarative resources, loose resources, and bundled resources. This
section discusses all three of these categories, beginning with declarative resources,
which are fairly different compared to the other two.
14.1.1 Declarative resources
Declarative resources are items intended to be shared across multiple elements in your
project. They can be any object you want to share. For instance, a resource can be
used to define a DataTemplate or Storyboard, as hinted at earlier in this book.
Resources are also a vital part of the styling and templating features discussed later in
this chapter. Before you see those features, let’s examine the basic syntax and usage of
a declarative resource.
Result:
XAML:
<StackPanel>
  <StackPanel.Resources>                               
    <LinearGradientBrush x:Key="myGradientBrush"                
      StartPoint="0,0" EndPoint="1,1"> 
      <GradientStop Color="#FF575757"/>
      <GradientStop Color="#FFCDCDCD" Offset="1"/>
    </LinearGradientBrush>
  </StackPanel.Resources>
  <TextBlock Text="DECLARATIVE" FontWeight="Bold" 
    FontFamily="Verdana" FontSize="40"
    Foreground="{StaticResource myGradientBrush}" />            
  <TextBlock Text="RESOURCES" FontWeight="Bold"
    FontFamily="Verdana" FontSize="40"
    Foreground="{StaticResource myGradientBrush}" />            
</StackPanel>
Listing 14.1 shows a basic declarative resource scoped to a StackPanel in the form of
a LinearGradientBrush. This GradientBrush is used by both TextBlock elements
defined in this listing. This shared approach is possible because the resource is within
Listing 14.1
The basic syntax and usage of a resource
Resource dictionary

309
Being resourceful
the same scope as the two TextBlock elements. Within this section, you’ll learn about
resource scoping in further detail. In addition, you’ll see how to use declarative
resources at design time. This task will demonstrate the meaning behind the x:Key
attribute and StaticResource items shown in listing 14.1. This section will end with a
discussion of using declarative resources at runtime.
DEFINING DECLARATIVE RESOURCES
Resources must be defined within an appropriately named collection called
Resources. This collection is a ResourceDictionary, a specialized dictionary contain-
ing resources identified by implicit or explicit keys. These resources and their associ-
ated keys can be defined at both design time and runtime. Both approaches are
shown in the following listing.
XAML:
<Grid x:Name="LayoutRoot" Background="White" Margin="15">
  <StackPanel x:Name="myStackPanel">
    <StackPanel.Resources>
      <SolidColorBrush x:Key="theSolidColorBrush"
                       Color="Green" />
      </StackPanel.Resources>
  </StackPanel>
</Grid>
C#:
SolidColorBrush brush = new SolidColorBrush();
brush.Color = Colors.Green;
myStackPanel.Resources.Add("theSolidColorBrush", brush);
Listing 14.2 shows how to define a resource at design time and runtime—in this case,
mutually exclusive approaches. Both approaches require you to specify two items. The
first item is the key, which in this case is the SolidColorBrush. The other is the
resource itself, which in this case is a SolidColorBrush.
 The key of a resource is a string that uniquely identifies it. At runtime, this identi-
fier is set when you add a resource to a ResourceDictionary. Because the Resource-
Dictionary class implements the IDictionary interface, you can add a resource
using the Add method. The first parameter of this method represents a key. The
ResourceDictionary implements the IDictionary interface, so you should use the
x:Key attribute to identify a resource at design time. Keys are only necessary when you
want to explicitly use a resource, as shown in the examples so far. When I discuss
styles, you’ll see how an implicit key can be useful as well. Once you’ve selected a key,
you may move on to the details of the resource.
 The resource itself is the reason for this section. This item can be virtually any
object that Silverlight allows to be shared. For example, controls and visuals can’t be
shared. In general, you’ll most likely use Storyboard, Style, and Template items as
resources with the occasional low-level int or double type and maybe even instances
Listing 14.2
SolidColorBrush defined as a resource at design time and runtime

310
CHAPTER 14
Resources, styles, and control templates
of your own classes for data. Regardless of the type of resource, the item can only be
used within its respective scope. 
ALL ABOUT SCOPE
So far, you’ve seen resources placed into various on-page elements. That’s great for
nonstyle resources such as references to data objects and whatnot. When used with
styles, though, it’s similar to placing CSS styles directly into your HTML page—it works,
but it’s not a best practice. In most cases, your resources are going to be placed in a
central location, such as in App.xaml.
 Resources defined in App.xaml are available to the entire application. The syntax
is the same as defining resources locally. After a resource has been defined, either
locally or through App.xaml, it can be referenced at design time through the Static-
Resource markup extension:
<TextBlock x:Name="myTextBlock" Text="Hello, World" 
  Foreground="{StaticResource theSolidColorBrush}" />
The StaticResource extension expects a single value that must match a key from an
in-scope ResourceDictionary. The resource must also be defined syntactically before
it’s referenced. Because of this requirement, listing 14.3 won’t work.
<Grid x:Name="LayoutRoot" Background="White" Margin="15">
  <StackPanel x:Name="myStackPanel">
    <TextBlock x:Name="myTextBlock" Text="Hello World!"
               FontSize="24"
               Foreground="{StaticResource theSolidColorBrush}" />
    <StackPanel.Resources>
      <SolidColorBrush x:Key="theSolidColorBrush" 
                       Color="Green" />
    </StackPanel.Resources>
  </StackPanel>
</Grid>
The listing shows an invalid use of a resource; the resource is used before it’s defined.
If you attempt to run this example, it’ll throw an XamlParseException. The designer
in Visual Studio, however, is more forgiving because it wants to do whatever it can to
show you the UI without crashing. The order in which entries appear is especially
important once you start working with independent resource dictionaries and have to
merge them in the correct order.
MERGING RESOURCE DICTIONARIES
Though App.xaml may ultimately be the aggregation point for your resources, a com-
mon strategy is to place resources into individual resource dictionary files. The files
are typically groups of related resources or entire application themes. Those resource
dictionary files are then compiled into the application (build action of Page, Custom
Tool set to MSBuild:Compile) and merged in from App.xaml or into the dictionaries
of individual pages.
Listing 14.3
How not to be seen
Resource 
definition

311
Being resourceful
 Listings 14.4 through 14.7 show how to merge two different resource files into your
application using App.xaml as the aggregation point but also referencing from within
the dictionaries. Listing 14.4 shows the first resource file, StandardColors.xaml.
<ResourceDictionary
  xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" 
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
  <SolidColorBrush x:Key="TextColor" Color="#FF303030" />
  <SolidColorBrush x:Key="HeadlineTextColor" Color="Black" />
  <LinearGradientBrush x:Key="PageBackgroundColor"
                       StartPoint="0,0"
                       EndPoint="0,1">
      <GradientStop Offset="0" Color="#FFFFFFFF" />
      <GradientStop Offset="1" Color="#FFD0D0D0" />
  </LinearGradientBrush>
</ResourceDictionary>
The StandardColors.xaml resource dictionary is your base dictionary. It has no depen-
dencies on others but is used in several other places. This dictionary defines three
Brush resources, two of which are simple SolidColorBrush instances; the third is a
LinearGradientBrush.
 The StandardColors.xaml resource dictionary is used by the ControlStyles.xaml
resource dictionary shown in listing 14.5.
<ResourceDictionary
  xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" 
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
  <ResourceDictionary.MergedDictionaries>
    <ResourceDictionary Source="StandardColors.xaml" />
  </ResourceDictionary.MergedDictionaries>
  <Style TargetType="TextBlock">
    <Setter Property="FontFamily"
            Value="Segoe UI" />
    <Setter Property="Foreground"
            Value="{StaticResource TextColor}" />    
    </Style>
  <Style x:Key="HeadlineTextStyle"
         TargetType="TextBlock">
    <Setter Property="FontFamily"
            Value="Segoe UI" />
    <Setter Property="Foreground"
            Value="{StaticResource HeadlineTextColor}" /> 
    <Setter Property="FontSize"
            Value="20" />
    <Setter Property="Margin"
            Value="0 0 0 10" />
  </Style>
</ResourceDictionary>
Listing 14.4
Merging resource dictionaries—colors dictionary
Listing 14.5
Merging resource dictionaries—control styles dictionary
Defined
in colors 
dictionary

312
CHAPTER 14
Resources, styles, and control templates
The standard colors dictionary is merged into the control styles dictionary. This is
required because the control styles dictionary uses resources defined in the color dic-
tionary. As you’ll see in the next listing, dependencies can’t be chained; they don’t rip-
ple “upward” and must be explicitly defined in each XAML file. Listing 14.6 shows
App.xaml where the dictionaries are made available to the whole application.
<Application 
xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" 
        x:Class="MergeExample.App">
  <Application.Resources>
    <ResourceDictionary>
      <ResourceDictionary.MergedDictionaries>    
        <ResourceDictionary Source="StandardColors.xaml" />
        <ResourceDictionary Source="ControlStyles.xaml" /> 
      </ResourceDictionary.MergedDictionaries>
    </ResourceDictionary>
  </Application.Resources>
</Application>
Both StandardColors.xaml and ControlStyles.xaml are merged into App.xaml to
make their included resources available to the rest of the application. As I mentioned
earlier, you can’t merge resources and expect the dependencies to flow through. For
example, StandardColors.xaml is merged into ControlStyles.xaml. That’s not suffi-
cient to make the resources in StandardColors.xaml available outside on the control
styles; they’re in a private dictionary. To expose them to the rest of the application,
they’re all merged into the applicationwide dictionary in the Application object, as
shown in the next listing.
<UserControl x:Class="MergeExample.MainPage"
  xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
  xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
  xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
  mc:Ignorable="d"
  d:DesignHeight="300" d:DesignWidth="400">
  <Grid x:Name="LayoutRoot" 
        Background="{StaticResource PageBackgroundColor}"> 
    <StackPanel>
      <TextBlock Text="This is a Headline"
                 Style="{StaticResource HeadlineTextStyle}" /> 
      <TextBlock Text="This is normal text. It is implicitly styled.
      ➥ We'll get to implicit styling in just a bit." />              
Listing 14.6
Merging resource dictionaries—App.xaml
Listing 14.7
Merging resource dictionaries—main page
Merged 
dictionaries
Resource

313
Being resourceful
    </StackPanel>
  </Grid>
</UserControl>
Finally, listing 14.7 gets you to your main page. MainPage.xaml is using a resource
defined in StandardColors.xaml. It’s also using a control style defined in Control-
Styles.xaml. The TextBlock is using an implicit style defined in ControlStyles.xaml.
 If you’re coming from a CSS background, the way the resources are nested may
seem odd to you because each goes into a discrete dictionary instead of a global sheet.
In the next section, you’ll learn how to access those discrete dictionaries, whether
they’re at an element or an application level.
USING DECLARATIVE RESOURCES AT RUNTIME
Referencing resources at design time is useful for setting up the initial state of an
application. As an application runs, you may need to work with those resources
dynamically. To help you accomplish this feat, Silverlight enables you to search for,
insert, edit, and remove resources at runtime.
 Searching for a resource at runtime involves referencing the Resources property,
which is a ResourceDictionary available on every FrameworkElement and Applica-
tion. Because of this, you can readily search for a declarative resource by using its key.
If the resource isn’t found, null will be returned; if the resource is found, its object
representation will be returned. Because the return value may be an object, you may
need to cast the value to another type, as shown in this example:
var brush = 
   myStackPanel.Resources["theSolidColorBrush"] as SolidColorBrush;
if (brush != null)
   brush.Color = Colors.Blue;
This code retrieves the SolidColorBrush defined as a resource in listing 14.2. Once it’s
retrieved, this Brush is changed from Green to Blue. This small but interesting change
occurs at runtime. When this code is executed, the TextBlock in listing 14.2 changes to
Blue without any additional code because the Silverlight system automatically listens
for those changes. But it doesn’t necessarily listen for when resources are removed.
 Accessing resources in elements uses the same syntax for any given element. To
access resources defined in the application, it’s slightly different:
var brush = 
   Application.Current.Resources["theSolidColorBrush"] as SolidColorBrush;
if (brush != null)
   brush.Color = Colors.Blue;
Rather than specifying an element like myStackPanel, you need to specify Applica-
tion.Current. Once you move beyond that, the syntax is the same. This will also pick
up any merged-in resources, so there’s no special step required to navigate down into
any other dictionaries. (Note that in XAML, the difference is abstracted away by the
StaticResource extension.)

314
CHAPTER 14
Resources, styles, and control templates
 Resources may be removed at runtime through the Remove method. This method
takes a string that represents the key of the resource, to delete. Once it’s deleted, this
resource can’t be used. If the resource was applied to any items in your Silverlight
application, the Resources attributes will still be in use; if you remove a resource, you
may want to manually update any elements using the declarative resource.
 Declarative resources are those defined within your Silverlight application. These
resources can be created at either design time or runtime. In addition, declarative
resources can be added, edited, and removed at runtime through the readily available
Resources property. In addition to declarative resources, Silverlight has another type
of resource known as loose resources. 
14.1.2 Accessing loose resources
In addition to using resources defined within your XAML,
Silverlight enables you to access loose resources. A loose
resource is an external entity, which may represent some-
thing such as an image hosted on some server on the inter-
net or some publicly visible JSON data. Regardless of the
type of content, Silverlight provides the ability to access
loose resources. To demonstrate accessing a loose
resource, imagine an ASP.NET web application with the
structure shown in figure 14.1.
 Figure 14.1 shows the structure of a basic ASP.NET web
application. This web application has one web page named
Default.aspx. Assume that this web page hosts the
Silverlight application defined within the MySilverlight-
Application.xap file, which is nestled within the ClientBin
directory. This will become important in a moment. Also
note the four image files that are part of this web applica-
tion structure: image01.png, image02.png, image03.png, and image04.png. These
images represent the loose resources that you’ll use throughout this section.
 You’ll learn two different ways to access loose resources. The first approach
involves referencing loose resources whose location is relative to the Silverlight appli-
cation. The second approach involves using an absolute URI.
REFERENCING RELATIVE LOOSE RESOURCES
Silverlight allows you to access loose resources relative to the site of origin—the location
where the requesting Silverlight application resides. In many cases, your Silverlight
application will be stored within a subdirectory. For instance, in figure 14.1 the Silver-
light application (MySilverlightApplication.xap) is stored within the ClientBin direc-
tory, so this directory can be considered the site of origin. If you want to access
image01.png in figure 14.1, you could use the Source shown here:
<Image x:Name="myImage" Source="image01.png" />
Figure 14.1
A sample 
website project structure. 
Note the four PNG files.

315
Being resourceful
This code accesses a resource in the same directory as MySilverlightApplication.xap.
This directory represents the site of origin. If you change the Source property to refer-
ence /image01.png, you’ll get the same result because the site of origin represents the
root directory when a relative URI is used. This syntax will still allow you to reference
loose resources in subdirectories. For instance, you could reference image02.png in
figure 14.1 using the Source in this example:
<Image x:Name="myImage" Source="directory/image02.png" />
This markup shows how to reference a loose resource in a subdirectory, demonstrat-
ing that you can use subdirectories with relative references. If you reference a XAP file
on a remote server, all your references will be relative to that remote reference. This is
important because you can’t use a relative URI to access loose resources in directories
that are ancestors to the site of origin. This restriction is a security measure to help
ensure that preexisting loose resources can’t be used unless you explicitly allow it. To
allow this use, you must expose them through the cross-domain policy file covered in
chapter 19 and use an absolute URI.
RETRIEVING LOOSE RESOURCES WITH AN ABSOLUTE URI
Silverlight gives you the flexibility to access loose resources via an absolute URI. This
gives you the flexibility to access resources from anywhere across the internet as long
as the target server allows it in its cross-domain policy file. This requirement is also
necessary if you want to access a resource located up the directory tree from your XAP
file. For instance, if the Silverlight website structure in figure 14.1 is hosted at http://
www.silverlightinaction.com, you could access image03.png by using the Source
shown here:
<Image x:Name=
   "myImage" Source="http://www.silverlightinaction.com/image03.png" />
This example shows how to access a loose resource via an absolute URI. This URI points
at the location of the resource, and this location will be loaded as a loose resource.
There’s also a way to bundle resources along with your Silverlight application. 
14.1.3 Bundled resources
The third kind of resource used in Silverlight is referred to as a bundled resource. A bun-
dled resource is an item included in the XAP file of a Silverlight application. The term
“bundled resource” is a made-up expression used solely for the sake of communica-
tion. Bundled resources give you a way to include resources specific to a Silverlight
application.
 In this section, you’ll learn about the two types of bundled resources that can be
used in Silverlight. The first is known as a content file—a file that’s added to the XAP file
and deployed alongside a Silverlight application. The other type of resource is known
as an embedded file, which represents an item that gets embedded into a Silverlight
assembly. This kind of resource can be useful for helping to hide your valuable
resources.

316
CHAPTER 14
Resources, styles, and control templates
USING CONTENT FILES
A content file is one that’s added to a XAP file and deployed alongside a Silverlight
application within the XAP. If you define an image as a content file, that image will be
included within the resulting XAP file when the Silverlight application is built. In fact,
any file with a build action of Content will be bundled into the resulting XAP file. Fig-
ure 14.2 shows a PNG and an XML file being bundled into a XAP file as content files.
 The figure shows two files that have been added and marked as content files. The
first, xmlData.xml, is a basic XML file. Once the project is built, this file ends up in the
root of the XAP file structure. The second, image.png, belongs to a nested directory
called images. When the project is built, this relative directory structure is carried over
to the final XAP file, which can be accessed using a relative path reference. All content
files can be referenced by providing a path relative to the application assembly. This
approach can be used at design time, as shown in this markup:
<Image x:Name="myImage" Source="/images/image.png" />
This example shows the syntax used to reference a content file at design time. The
leading forward slash (/) tells Silverlight to begin looking at the same level as the
Figure 14.2
Defining a file 
as a content file. When it’s 
compiled, the content file is 
added to a XAP file.

317
Giving your elements style
application assembly. This approach is the recommended way to include content with
a Silverlight application because it makes things more easily accessible. Sometimes,
you may come across somebody who does things the old-school way—the content files
will be embedded within the Silverlight assembly. You’ll now see how to access these
embedded files.
USING EMBEDDED FILES
An embedded file is a file embedded within a Silverlight assembly, which may be
either an application or a library. Either way, an embedded file becomes a part of an
assembly by changing the build action to Resource. This file can be retrieved at design
time or runtime by providing a special URL structure.
 Embedded resources are accessible through a URL that has three parts. The first
part names the assembly to which the resource belongs. The second piece is a special
keyword called Component that declares a resource as being retrieved. The final part is
a relative URL that maps to the location of the resource within the assembly. These
three items come together to form a URL template that looks like the following:
[AssemblyName];component/[RelativePath]
This template can be used at design time or runtime. The design-time implementa-
tion relies on the element type to convert the resource. At runtime, you must manu-
ally convert the resource. First, you retrieve the embedded resource from the
assembly through the Application class, as shown in this line of code:
StreamResourceInfo resource = Application.GetResourceStream(
  new Uri("SilverlightApp1;component/embedded.png", UriKind.Relative));
This example shows how to retrieve the resource from the assembly. This resource is
represented as a StreamResourceInfo, which is part of the System.Windows.
Resources namespace. This class instance must be converted to the type appropriate
for your situation. As I mentioned earlier, you shouldn’t come across this scenario
often. When it comes to content files, you’ll probably encounter a loose resource. In
XAML, you’ll most likely use declarative resources. This approach is especially useful if
you’re styling your elements. 
14.2
Giving your elements style
As you saw in section 14.1, resources are the nonexecutable parts of your application.
These parts are useful for creating items that can be reused multiple times. In addi-
tion to being reused, resources can be shared by multiple elements. These two charac-
teristics make resources a natural fit for styling.
Styling is a way to consistently share the same property values across multiple ele-
ments. To see why this is a good idea, imagine needing to create a typical forms-based
application. This application must use TextBox elements that have a bold 12-point
Verdana font for input. In addition, you want to give the TextBox elements a subtle

318
CHAPTER 14
Resources, styles, and control templates
gradient background to make them more appealing. Without styles, you may decide
to implement these visual enhancements as shown in the next listing.
Result:
XAML:
<Grid x:Name="myGrid">
  <Grid.RowDefinitions>
    <RowDefinition Height="Auto"/>
    <RowDefinition Height="Auto" />
  </Grid.RowDefinitions>
  <Grid.ColumnDefinitions>
    <ColumnDefinition Width="Auto"/>
    <ColumnDefinition Width="Auto"/>
  </Grid.ColumnDefinitions>
  <TextBlock Text="First Name: " />
  <TextBox Height="24" Width="180" Grid.Column="1"
    FontFamily="Verdana" FontSize="12" FontWeight="Bold">
    <TextBox.Background>
      <LinearGradientBrush EndPoint="0.5,1" StartPoint="0.5,0"> 
        <GradientStop Color="#FFFFFFFF" Offset="1"/>
        <GradientStop Color="#FFD0D0D0" Offset="0"/>
      </LinearGradientBrush>       
    </TextBox.Background>
  </TextBox>
  <TextBlock Text="LastName: " Grid.Row="1" />
  <TextBox Height="24" Width="180" Grid.Row="1" Grid.Column="1"
    FontFamily="Verdana" FontSize="12" FontWeight="Bold">
    <TextBox.Background>
      <LinearGradientBrush EndPoint="0.5,1" StartPoint="0.5,0"> 
        <GradientStop Color="#FFFFFFFF" Offset="1"/>
        <GradientStop Color="#FFD0D0D0" Offset="0"/>
      </LinearGradientBrush>       
    </TextBox.Background>
  </TextBox>
</Grid>
Listing 14.8 shows the brute-force approach to defining the visual properties of multi-
ple elements. It defines two TextBox elements with the same values for the Height,
Width, FontFamily, FontSize, and FontWeight properties. In addition, the same
complex LinearGradientBrush definition is used for the Background of both TextBox
elements. Unfortunately, this approach isn’t scalable. For instance, if you need to
change the font of the TextBox items, you’d have to make the change to each item,
but you can overcome this minor inconvenience using a Style.
 A Style is a way to share the same property values across multiple elements. In this
section, you’ll learn how to create and use a Style. This approach will help you avoid
Listing 14.8
Brute-force approach to applying common properties

319
Giving your elements style
the maintenance nightmare shown in listing 14.8. You’ll first see how to define the
visual properties of a control through a Style. Then, you’ll learn how to share a Style
definition across multiple elements.
14.2.1 Defining the look
To define the look of an element using a Style, you set the Style property. This
instruction may sound redundant, but the property name is the same as the type
name. The Style property is available on every FrameworkElement, so virtually every
control in the Silverlight framework can be styled. You can do so by taking advantage
of the Style class’s Setters collection.
 The Setters collection stores the entire definition of a Style. This definition is
made up of individual property/value pairs similar to those seen in CSS in the HTML
world. In Silverlight, each combination is defined within a Setter element, which lets
you assign a value to a single visual property. Interestingly, this approach can be used
to set both simple and complex property values.
SETTING SIMPLE PROPERTY VALUES
A simple property is a property that can be set at design time with a primitively typed value.
A primitively typed value is something like an int or string value. These kinds of val-
ues can be used at design time to set the values for properties such as FontSize and
FontFamily. Listing 14.9 shows how to use five simple properties as part of a Style.
Result:
XAML:
<TextBox x:Name="myTextBox">
  <TextBox.Style>                         
    <Style TargetType="TextBox">                           
      <Setter Property="FontFamily" Value="Verdana" />
      <Setter Property="FontSize" Value="12" />
      <Setter Property="FontWeight" Value="Bold" />
      <Setter Property="Height" Value="24" /> 
      <Setter Property="Width" Value="180" />
    </Style>
  </TextBox.Style>
</TextBox> 
The example shows how to define a Style that uses five simple properties, each of
which is defined within a Setter element. When used in this way, these elements are
added to the Style object’s Setters collection and made available to the style. Each
of the Setter elements in a style is defined by two publicly visible attributes.
 The two attributes that define a Setter are named Property and Value. The
Property attribute determines which property the Value will be used with. The
Listing 14.9
A basic style definition
Style property

320
CHAPTER 14
Resources, styles, and control templates
Property must be a DependencyProperty, but the Value property can be set to any
object. Because of this fact, the Setter element is flexible, making it a natural fit for
simple properties. In addition, it’s a natural fit for complex properties.
SETTING COMPLEX PROPERTY VALUES
A complex property is a property whose value is a general-purpose object. In general,
these kinds of properties have nested properties that must be set. For example, a
LinearGradientBrush could be considered a complex property value because it has
the additional stops broken out using property element syntax. Imagine trying to use
this LinearGradientBrush as part of a Style. You must use an approach similar to
that shown in listing 14.10.
Result:
XAML:
<TextBox x:Name="myTextBox">
  <TextBox.Style>                                             
    <Style TargetType="TextBox">
      <Setter Property="FontFamily" Value="Verdana"/>
      <Setter Property="FontSize" Value="12"/>
      <Setter Property="FontWeight" Value="Bold"/>
      <Setter Property="Height" Value="24"/>
      <Setter Property="Width" Value="180"/>
      <Setter Property="Background"> 
        <Setter.Value>                                              
          <LinearGradientBrush EndPoint="0.5,1" StartPoint="0.5,0">
            <GradientStop Color="#FFFFFFFF" Offset="1"/>         
            <GradientStop Color="#FFD0D0D0" Offset="0"/>       
          </LinearGradientBrush>                                 
        </Setter.Value>                                        
      </Setter>
    </Style>
  </TextBox.Style>
</TextBox>
The listing shows how to define a more complex property as part of a Style. There
aren’t any new elements here, but it does show you how to break out the Set-
ter.Value into a nested property itself. This approach gives you the flexibility to use
something as complex as a LinearGradientBrush. 
 The approaches shown in both of these examples haven’t solved the problem of
scalability; they’ve just illustrated the syntax of a Style used inside of an element
instead of explicit properties. To solve the problem of scalability, you must understand
how to target your Style definitions so they can be reused.
Listing 14.10
A complex property in a style definition
Complex 
Value

321
Giving your elements style
14.2.2 Explicitly keyed style definitions
In CSS, one way to define styles is to include two parts. One part represents the name
of the style; the other is the name of the HTML tag the style is applicable to. An
explicit Style in Silverlight also uses these two parts.
 The first part of a Style uniquely identifies a Style definition. As shown in the
previous two examples, this part is optional. It becomes a requirement only if you cre-
ate a Style as a resource and want to refer to it explicitly. If you choose this approach,
you must specify the x:Key attribute to uniquely identify the Style, and you must
specify the other part—the TargetType.
 The TargetType property declares which System.Type a Style is applicable to.
This property doesn’t need to be set if you define a Style within an element, as shown
in the previous examples. If you define a Style as a resource, you must set this prop-
erty as shown here.
<Grid x:Name="myGrid" Background="White">
  <Grid.Resources>
    <Style x:Key="textStyle" TargetType="TextBox"> 
      <Setter Property="FontWeight" Value="Bold" />
      <Setter Property="FontFamily" Value="Verdana" />
      <Setter Property="FontSize" Value="12" />
      <Setter Property="Height" Value="24" />
      <Setter Property="Width" Value="180" />
      <Setter Property="Background">
        <Setter.Value>
          <LinearGradientBrush EndPoint="0.5,1" StartPoint="0.5,0">
            <GradientStop Color="#FFFFFFFF" Offset="1"/>
            <GradientStop Color="#FFD0D0D0" Offset="0"/>
          </LinearGradientBrush>
        </Setter.Value>
      </Setter>
    </Style>
  </Grid.Resources>
  <Grid.RowDefinitions>
    <RowDefinition Height="Auto" />
    <RowDefinition Height="Auto" />
  </Grid.RowDefinitions>
  <Grid.ColumnDefinitions>
    <ColumnDefinition Width="Auto" />
    <ColumnDefinition Width="Auto" />
  </Grid.ColumnDefinitions>
  <TextBlock Text="First Name: " />
  <TextBox Grid.Column="1" 
           Style="{StaticResource textStyle}" />
  <TextBlock Text="LastName: " Grid.Row="1" />
  <TextBox Grid.Row="1" Grid.Column="1" 
           Style="{StaticResource textStyle}" />  
</Grid>
Listing 14.11
Defining the TargetType of a Style
Style in use

322
CHAPTER 14
Resources, styles, and control templates
Listing 14.11 shows a Style defined as a resource. The Style in this case is configured
to be used with TextBox elements as set through the TargetType property. If you were
to attempt to use this Style with an element of another type, an error would occur. It
can be used with any types that might derive from TextBox.
CSS supports implicit styles, where you specify the type (a DIV, for example) and CSS
applies it to all DIV elements within a certain scope. Silverlight supports a similar type
of implicit styling. 
14.2.3 Implicit style definitions
In the previous example, you saw how a style may be reused by applying it to each con-
trol. In a large application with many controls, this procedure can be both tedious and
error prone. Silverlight 4 introduced implicit styles.
 Implicit styles look exactly like their explicit cousins, except they omit the key. If
you define a style with a TargetType and omit the key, the TargetType becomes the key
and the style becomes implicit.
 The following listing shows the previous example but converted to an implicit style.
XAML:
<Grid x:Name="myGrid" Background="White">
  <Grid.Resources>
    <Style TargetType="TextBox">             
      <Setter Property="FontWeight" Value="Bold" />
      <Setter Property="FontFamily" Value="Verdana" />
      <Setter Property="FontSize" Value="12" />
      <Setter Property="Height" Value="24" />
      <Setter Property="Width" Value="180" />
      <Setter Property="Background">
        <Setter.Value>
          <LinearGradientBrush EndPoint="0.5,1" StartPoint="0.5,0">
            <GradientStop Color="#FFFFFFFF" Offset="1"/>
            <GradientStop Color="#FFD0D0D0" Offset="0"/>
          </LinearGradientBrush>
        </Setter.Value>
      </Setter>
    </Style>
  </Grid.Resources>
  <Grid.RowDefinitions>
    <RowDefinition Height="Auto" />
    <RowDefinition Height="Auto" />
  </Grid.RowDefinitions>
  <Grid.ColumnDefinitions>
    <ColumnDefinition Width="Auto" />
    <ColumnDefinition Width="Auto" />
  </Grid.ColumnDefinitions>
  <TextBlock Text="First Name: " />
  <TextBox Grid.Column="1" />                     
  <TextBlock Text="LastName: " Grid.Row="1" />
  <TextBox Grid.Row="1" Grid.Column="1" />    
</Grid>
Listing 14.12
Defining the TargetType of a Style
Implicit style
Style in use

323
Creating templates
Just as you saw in the previous example, listing 14.12 defines a style that targets the Text-
Box type. But you’ve omitted the x:Key, so this is an implicit style. Note the TextBox con-
trols at the bottom of the listing: they now pick up the style without requiring any
StaticResource setting. This is a huge timesaver for applications of any real complexity.
 Styling, both explicit and implicit, is a powerful way to define the UI standards for
your application. Design professionals (or integrators, depending on how your team is
set up) spend a good bit of their time defining styles, just as they would with HTML/
CSS. They can work with them directly in XAML as you have here or use Expression
Blend to make the process easier. 
 Once you’ve mastered styling, you’re ready to take a step beyond setting simple
properties and into working with the control templates themselves. 
14.3
Creating templates
The styling features shown in section 14.2 are a welcome addition to the Silverlight
world. These items allow you to quickly create a consistent look throughout an appli-
cation. This look can be shared across the application by defining the styles as
resources. But occasionally, the styling options can be somewhat limiting. To over-
come these limitations, you can use a template.
 A template empowers you to redefine the entire visual representation of an ele-
ment, giving you the flexibility to make any Control look the way you want it to look.
When doing this, you don’t sacrifice the behavior of the Control. You could create a
Button that looks and feels like an octagon and still reacts to the Click event. Over
the course of this section, you’ll experience the full power of a template by building a
control template. You’ll also see how to elegantly create a reusable template.
14.3.1 Building a control template
When you build a control template, it’ll ultimately be used with a Control. Every Con-
trol in Silverlight exposes a property called Template. This property is a Con-
trolTemplate that lets you take complete control over what a Control looks like. In a
sense, when you set this property, you’re resetting the control’s appearance, giving
you a clean slate to work with. From there, you can make a Control look like whatever
you want it to look like. Listing 14.13 changes the look of a Button to make it look
more like a sphere.
Result:
XAML:
<Button x:Name="myButton" Content="Hello">
  <Button.Template>                      
    <ControlTemplate>                                    
Listing 14.13
Changing the look of a Button through a Template
Template property

324
CHAPTER 14
Resources, styles, and control templates
      <Ellipse Height="90" Width="90" Stroke="Black" StrokeThickness="2">
        <Ellipse.Fill>                                     
          <RadialGradientBrush GradientOrigin="0.3,0.2">
            <RadialGradientBrush.RelativeTransform>
              <TransformGroup>
                <ScaleTransform CenterX="0.5" CenterY="0.5"
                  ScaleX="1.075" ScaleY="1.141"/>
                <SkewTransform CenterX="0.5" CenterY="0.5"/>    
                <RotateTransform CenterX="0.5" CenterY="0.5"/>
                <TranslateTransform X="-0.04" Y="0.07"/>
              </TransformGroup>
            </RadialGradientBrush.RelativeTransform>
            <GradientStop Color="#FFD9D9D9" Offset="0.004"/>  
            <GradientStop Color="#FF2103BA" Offset="1"/> 
          </RadialGradientBrush>
        </Ellipse.Fill>
      </Ellipse>
    </ControlTemplate>
  </Button.Template> 
</Button>
The listing shows a basic ControlTemplate which is associated with a Button through
its Template property. Notably, if you were to define a ControlTemplate as a resource,
you’d associate the template with a specific type through the TargetType property.
This property behaves the same way as it did with the Style class. Interestingly, when a
template is used with a ContentControl, the Content property doesn’t behave the
same way.
 Over the course of this section, you’ll learn how to display content within a
ControlTemplate. This content will generally be placed inside a Panel or Border
because a ControlTemplate can have only one root element. This root element can
then be used to house the contents of a ContentControl or an ItemsControl. You’ll
also see how to customize the way in which the Items of an ItemsControl are
arranged. But first, you’ll see how to use properties that are part of the target control
in your templates.
CONSIDERING CONTROL PROPERTIES
Ultimately, the purpose of a ControlTemplate is to define the appearance of a
Control. This Control may have properties set that should be used within your tem-
plate. For instance, you may want to use the Background or FontFamily property val-
ues of a Control in your ControlTemplate. In these types of situations, you should use
a TemplateBinding.
 A TemplateBinding is a special type of data binding used within a Control-
Template. This data binding uses the Control to which the ControlTemplate is
applied as its data source. The data source is identified as a specific property within
that Control. This property is referenced by name when you create a Template-
Binding. An example of such a reference is shown next.

325
Creating templates
Result:
XAML:
<Button x:Name="myButton" Content="Hello" Height="45" Width="45">
  <Button.Template>
    <ControlTemplate>                       
      <Ellipse Fill="#FF2103BA" Stroke="Black" StrokeThickness="2" 
        Height="{TemplateBinding Height}"                          
        Width="{TemplateBinding Width}" />                         
    </ControlTemplate> 
  </Button.Template>
</Button>
Listing 14.14 shows the basic syntax of a TemplateBinding. This syntax mimics the
data-binding syntax explained in chapter 16. In this case, the binding causes the
Height and Width property values of the Button to be used by the Ellipse in the
ControlTemplate. These property values are simple in comparison to what the value
of the Content property could be, though. If you’re going to display the Content of a
ContentControl in a ControlTemplate, you may want to consider using another
approach.
DISPLAYING THE CONTENT
You may have noticed that the Content of the Button elements in the past two listings
hasn’t been shown because, when you define a ControlTemplate, you must tell Silver-
light where to place that Content. To help you do this task, Silverlight provides two
FrameworkElement instances: ContentPresenter and ItemsPresenter.
 The ContentPresenter class empowers you to specify where the Content of a
ContentControl should be shown. It may be easiest to think of this element as a place-
holder for some piece of Content. Beyond that, the syntax of a ContentPresenter is
the element itself, as shown in listing 14.15.
Result:
XAML:
<Button x:Name="myButton" Content="Hello" Height="20" Width="60">
  <Button.Template>
    <ControlTemplate>
      <Border Width="{TemplateBinding Width}" 
Listing 14.14
Using a TemplateBinding for the target element’s properties
Listing 14.15
Using a ContentPresenter to display content
Control 
template

326
CHAPTER 14
Resources, styles, and control templates
              CornerRadius="8"
              BorderThickness="1" 
              BorderBrush="Black" 
              Background="Blue">
        <ContentPresenter HorizontalAlignment="Center" /> 
      </Border>
    </ControlTemplate> 
  </Button.Template>
</Button>
This listing shows the general usage of a ContentPresenter. As you can see, this object
is a placeholder designed to be used inside a ControlTemplate. This element is gener-
ally limited to ContentControl scenarios and isn’t usually used in ItemsControl situa-
tions. For these scenarios, you may want to consider an ItemsPresenter such as the
one shown next.
Result:
XAML:
<ListBox x:Name="myListBox">
  <ListBox.Template>
    <ControlTemplate>                                           
      <Border CornerRadius="20,7,20,7" 
              BorderThickness="4,2,4,2" 
              BorderBrush="LimeGreen"  
              Padding="10">
        <ItemsPresenter />                 
      </Border>
    </ControlTemplate>
  </ListBox.Template>
  <ListBox.Items>
    <ListBoxItem><TextBlock>Item 1</TextBlock></ListBoxItem>
    <ListBoxItem><TextBlock>Item 2</TextBlock></ListBoxItem>
    <ListBoxItem><TextBlock>Item 3</TextBlock></ListBoxItem>
  </ListBox.Items>
</ListBox>
Listing 14.16 shows a ListBox with a ControlTemplate applied to it. The Items of that
ListBox are positioned according to the ItemsPresenter. This element is important
because it determines where the Items will be positioned in a ControlTemplate, but
the ItemsPresenter doesn’t determine how the Items will be arranged. That’s the
role of the ItemsPanel.
Listing 14.16
Using an ItemsPresenter to display the Items of an ItemsControl
Content 
presenter
Items 
presenter

327
Creating templates
CONTROLLING ITEM ARRANGEMENT
The Items of an ItemsControl control are arranged according to the ItemsPanel
property. This property is a special kind of template that defines the Panel that will be
used to lay out the Items. By default, this property is set to use a StackPanel with a
Vertical Orientation. In reality, you’re free to use any of the Panel elements dis-
cussed in chapter 8. You could use a Horizontal StackPanel, as shown in listing 14.17.
Result:
XAML:
<ListBox x:Name="myListBox">
  <ListBox.Template>
    <ControlTemplate> 
      <Border CornerRadius="20,7,20,7" BorderThickness="4,2,4,2" 
        BorderBrush="LimeGreen"  Padding="10">
        <ItemsPresenter /> 
      </Border>  
    </ControlTemplate>
  </ListBox.Template>
  <ListBox.ItemsPanel>                       
    <ItemsPanelTemplate>
      <StackPanel Orientation="Horizontal" />       
    </ItemsPanelTemplate>
  </ListBox.ItemsPanel>
  <ListBox.Items>
    <ListBoxItem>
      <TextBlock Padding="5">Item 1</TextBlock>
    </ListBoxItem>
    <ListBoxItem>
      <TextBlock Padding="5">Item 2</TextBlock>
    </ListBoxItem>
    <ListBoxItem>
      <TextBlock Padding="5">Item 3</TextBlock>
    </ListBoxItem>
  </ListBox.Items>
</ListBox>
The listing uses a Horizontal StackPanel as the ItemsPanel to arrange the Items in
the ListBox horizontally. It’s highly likely that you’ll only use a StackPanel or a Wrap-
Panel as an ItemsPanel. Although you can technically use any other Panel element,
the other options often require actual code. This code will be based entirely on your
particular situation, so we won’t cover that topic in this section.
Listing 14.17
Declaring the ItemsPanel to arrange the Items of an ItemsControl
Items panel

328
CHAPTER 14
Resources, styles, and control templates
The ControlTemplate class enables you to redefine the way a Control looks. This new
definition can use the target Control property values through a TemplateBinding.
When it comes to displaying the Content of a ContentControl, you should use a
ContentPresenter within a ControlTemplate. If this ControlTemplate is associated
with an ItemsControl, you may need to use an ItemsPresenter to show the Items.
These Items can be rendered in new ways thanks to the ItemsPanel property. 
 Once you’ve settled on a ControlTemplate, you may want to use it across multiple
controls. Thankfully, Silverlight makes it easy to create reusable templates.
14.3.2 Creating reusable templates
Creating individual templates can be useful when you want to give individualized
attention to your controls; templates can also be useful for creating a truly unique yet
consistent user experience. To help make it easier to deliver a consistent user experi-
ence, Silverlight allows you to define a ControlTemplate as part of a Style.
Result:
XAML:
<StackPanel x:Name="LayoutRoot" Background="White" Margin="10" Width="170">
  <StackPanel.Resources>
    <Style x:Key="buttonStyle" TargetType="Button">            
      <Setter Property="Template"> 
        <Setter.Value> 
          <ControlTemplate>                         
            <Ellipse Fill="#FF2103BA" Stroke="Black" 
                     StrokeThickness="2" 
                     Height="{TemplateBinding Height}"
                     Width="{TemplateBinding Width}" /> 
          </ControlTemplate> 
Why would ItemsPanel require code?
StackPanel and WrapPanel handle layout regardless of the number of children. You
simply need to add the items to their Children collection. In contrast, something like
a Grid requires additional information (rows and columns) to lay out its children, some-
thing that must be added via code to account for the number of items added. In general,
if the panel can be completely defined here and will work with just adding 0 to n children
to it, it’s a good candidate for use as the ItemsPanel.
Listing 14.18
Using a ControlTemplate within a Style
ControlTemplate 
in Style

329
Dealing with visual states
        </Setter.Value>
      </Setter>        
    </Style>
  </StackPanel.Resources>
  <Button x:Name="myButton1" Height="30" Width="30"
    Style="{StaticResource buttonStyle}" />
  <Button x:Name="myButton2" Height="70" Width="70"
    Style="{StaticResource buttonStyle}" />        
</StackPanel>
Listing 14.18 shows a ControlTemplate defined within a Style. Though this is a sim-
ple template, you can also define a ControlTemplate as complex as you need it to be.
You can even go as far as defining a ControlTemplate that considers visual states
expressed as storyboards and animations. 
14.4
Dealing with visual states
Templates give you the flexibility to dictate what a Control looks like, but the template
explanation given in section 14.3 is only useful for defining the default look of a
Control. This default look represents the Control’s normal state. In reality, most con-
trols have multiple states. For instance, a Button can be in a pressed or disabled state.
To enable you to manage what a Control looks like in such a state, Silverlight provides
something known as the VisualStateManager.
 The VisualStateManager is an element that manages the states and the transition-
ing between states. This element belongs to the System.Windows namespace. Because
the VisualStateManager is in this namespace, it’s ready to be utilized in your Control
definitions. Before you can fully utilize the VisualStateManager, you must gain an
understanding of components involved in state and transition management. Once
you understand these components, you can leverage the power of the VisualState-
Manager itself. As you’ll see in the conclusion of this section, this power can be
wielded across multiple elements with the help of a Style.
14.4.1 Understanding the components
The VisualStateManager relies on a variety of components to do its job. These com-
ponents make up something referred to as the parts and states model. This model is
designed to separate a Control element’s appearance from its behavior, ensuring that
you can customize the visual pieces of a Control without having to change its underly-
ing logic. To enable this feat, the parts and states model relies on three components:
states, transitions, and parts.
STATES
A state is used to reflect a particular aspect of a control. For instance, the Button has
one state that defines what it looks like by default. If a user moves the mouse over this
Button, it’ll enter another state. If the Button is pressed, it’ll change to yet another
state. These three states are shown in table 14.1.

330
CHAPTER 14
Resources, styles, and control templates
Table 14.1 shows three of the states exposed by the Button class. In reality, the Button
class has many more states. These states are exposed to the VisualStateManager with
the help of the TemplateVisualStateAttribute. This attribute can be used by a
Control to identify the states a Control can be in. In addition, because a Control can
simultaneously be in multiple states, the TemplateVisualStateAttribute exposes the
group that a state belongs to. The states and groups available on the Button class are
listed in table 14.2.
Each state is identified by a Name property, which is part of the TemplateVisualState-
Attribute. This property is complemented by another called GroupName, which
determines the grouping for the state. The purpose of this property is to logically
group together visual states. This is necessary because a Control can be in multiple
states at the same time. For instance, a Button can simultaneously be in a Focused
state as well as a Pressed state because the Pressed state is in a different group than
the Focused state. Perhaps a better example is a CheckBox being in a Checked state
while also being in a Disabled state. Either way, the main thing to understand is that
groups are exclusive—a Control can be in multiple states as long as those states
belong to different groups. States that are part of the same group have the ability to
transition between one another.
TRANSITIONS
A transition defines the way a Control looks as it changes from one state to another.
This change is represented as a Storyboard, so you’re free to implement a smooth
shift between two states. You can even do this at a fine granular level because of the
inclusion of parts.
Table 14.1
Several states of a Button. Each state has a slightly different visual appearance.
Normal
MouseOver
Pressed
Table 14.2
The states and groups of the Button class
State
GroupName
Disabled
CommonStates
MouseOver
CommonStates
Normal
CommonStates
Pressed
CommonStates
Focused
FocusStates
Unfocused
FocusStates

331
Dealing with visual states
PARTS
A part represents a specific element
within a ControlTemplate. A part is
generally used when some underly-
ing logic may need to change an
area of a ControlTemplate. For
instance, the thumb on a Slider
will change any time a user clicks the track. This event will cause some underlying
logic to move the position of the thumb. Both the thumb and track are defined as
parts, as shown in figure 14.3.
 The previous figure shows the two main parts of a Slider, which has more parts.
These parts are defined by the TemplatePartAttribute, which enables you to specify
the name and type of a UIElement that represents a part within a Control. This attri-
bute is used to transmit data about the element that represents the part within the
parts and states model. Now that this model has been explained, let’s see how to lever-
age it with the VisualStateManager.
14.4.2 Leveraging the VisualStateManager
The VisualStateManager is used by a ControlTemplate to manage the change
between states. This change can be used to generate two different kinds of effects.
The first is known as a state-based effect, which can be useful for doing something such
as creating an enlarged Button if a user moves the mouse over it. The other type is
known as a transitioning effect, which is useful for creating a fluid interface for controls
that may change between states of the same group. Both kinds of effects will be cov-
ered in this section.
CREATING STATE-BASED EFFECTS
A state-based effect is a transition that occurs at the moment a Control enters a
VisualState.When this happens, the Storyboard associated with the VisualState
begins. This Storyboard is defined as part of a ControlTemplate. The Storyboard
can be useful for creating a glowing effect or a ballooning effect.
XAML:
<Button x:Name="myButton" Width="75" Height="75" Content="Push Me">
  <Button.Template>                                 
    <ControlTemplate TargetType="Button">
      <Grid RenderTransformOrigin=".5,.5">
        <Grid.RenderTransform>
          <ScaleTransform x:Name="myTransform"/>
        </Grid.RenderTransform>
        <Ellipse x:Name="myEllipse" RenderTransformOrigin=".5,.5" 
                 Height="{TemplateBinding Height}" 
                 Width="{TemplateBinding Width}">
          <Ellipse.Fill>
Listing 14.19
Creating a Button that enlarges when a user hovers over it
Figure 14.3
The required parts of a Slider are the 
thumb and the track. The actual appearance of the 
Slider isn’t important as long as it has the parts that 
form the UI contract.
Template

332
CHAPTER 14
Resources, styles, and control templates
            <RadialGradientBrush GradientOrigin="0.3,0.2">
              <RadialGradientBrush.RelativeTransform>
                <TransformGroup>
                  <ScaleTransform CenterX="0.5" CenterY="0.5" 
                    ScaleX="1.075" ScaleY="1.141"/>
                  <SkewTransform CenterX="0.5" CenterY="0.5"/>
                  <RotateTransform CenterX="0.5" CenterY="0.5"/>
                  <TranslateTransform X="-0.04" Y="0.07"/>
                </TransformGroup>
              </RadialGradientBrush.RelativeTransform>
              <GradientStop Color="#FFD9D9D9" Offset="0.004" />
              <GradientStop Color="#FF2103BA" Offset="1" />
            </RadialGradientBrush>
          </Ellipse.Fill>
        </Ellipse>
        <ContentPresenter HorizontalAlignment="Center"
                          VerticalAlignment="Center" />
        <VisualStateManager.VisualStateGroups>          
          <VisualStateGroup x:Name="CommonStates">   
            <VisualState x:Name="MouseOver">         
              <Storyboard>
                <DoubleAnimation From="1.0" To="1.25"
                  Storyboard.TargetName="myTransform"
                  Storyboard.TargetProperty="ScaleX" />
                <DoubleAnimation From="1.0" To="1.25"
                  Storyboard.TargetName="myTransform"
                  Storyboard.TargetProperty="ScaleY" />
              </Storyboard> 
            </VisualState>
          </VisualStateGroup>
        </VisualStateManager.VisualStateGroups>
      </Grid>
    </ControlTemplate>
  </Button.Template>
</Button>
Listing 14.19 defines an effect that occurs when a user triggers the MouseOver Visual-
State for the Button. All of the items in this listing have been described in the previ-
ous chapters. You should note three main things. First, the VisualStateGroups,
element tells the ControlTemplate that some custom Storyboard is going to be used
for a state. Second, this state belongs to a predefined group, which is described by the
VisualStateGroup element. Third, the VisualStateitems associated with this group
are detailed inside the element. This approach is useful for creating effects when a
Control enters a state. But the effect created in listing 14.19 would be better defined
as a VisualStateTransition.
DEFINE TRANSITIONING EFFECTS
In addition to state-based transitions, the VisualStateManager enables you to define
a transition between states. You can trigger this transition in code by calling the GoTo-
State method or by using a DataStateBehavior or GoToStateAction behavior. You’ll
use GoToState here because it’s the most useful to control authors.
Visual states
MouseOver 
state

333
Dealing with visual states
 To define a transition in XAML, you must use an element called VisualState-
Transition, which allows you to associate a Storyboard with a change between two
states. The beginning state is identified by a string property named From. The state
being transitioned to is specified by a string property called To. Listing 14.20 defines
a transition that changes the Button in the previous listing back to a Normal state.
XAML:
<Button x:Name="myButton" Width="75" Height="75" Content="Push Me">
  <Button.Template>
    <ControlTemplate TargetType="Button">
      <Grid RenderTransformOrigin=".5,.5">
        <Grid.RenderTransform>
          <ScaleTransform x:Name="myTransform"/>
        </Grid.RenderTransform>
        <Ellipse x:Name="myEllipse" RenderTransformOrigin=".5,.5" 
          Height="{TemplateBinding Height}" 
          Width="{TemplateBinding Width}">
          <Ellipse.Fill>
            <RadialGradientBrush GradientOrigin="0.3,0.2">
              <RadialGradientBrush.RelativeTransform>
                <TransformGroup>
                  <ScaleTransform CenterX="0.5" CenterY="0.5" 
                    ScaleX="1.075" ScaleY="1.141"/>
                  <SkewTransform CenterX="0.5" CenterY="0.5"/>
                  <RotateTransform CenterX="0.5" CenterY="0.5"/>
                  <TranslateTransform X="-0.04" Y="0.07"/>
                </TransformGroup>
              </RadialGradientBrush.RelativeTransform>
              <GradientStop Color="#FFD9D9D9" Offset="0.004" />
              <GradientStop Color="#FF2103BA" Offset="1" />
            </RadialGradientBrush>
          </Ellipse.Fill>
        </Ellipse>
        <ContentPresenter HorizontalAlignment="Center"
                          VerticalAlignment="Center" />
        <VisualStateManager.VisualStateGroups>                      
          <VisualStateGroup x:Name="CommonStates">
            <VisualState x:Name="Normal">         
              <Storyboard>
                <DoubleAnimation To="1.0"
                  Storyboard.TargetName="myTransform"
                  Storyboard.TargetProperty="ScaleX" />
                <DoubleAnimation To="1.0"
                  Storyboard.TargetName="myTransform"  
                  Storyboard.TargetProperty="ScaleY" />
              </Storyboard>
            </VisualState>
            <VisualState x:Name="MouseOver">      
              <Storyboard> 
                <DoubleAnimation To="1.25"
Listing 14.20
Creating a Button that transitions when a user hovers or leaves it
Normal state
MouseOver state

334
CHAPTER 14
Resources, styles, and control templates
                  Storyboard.TargetName="myTransform"
                  Storyboard.TargetProperty="ScaleX" />
                <DoubleAnimation To="1.25"
                  Storyboard.TargetName="myTransform"
                  Storyboard.TargetProperty="ScaleY" />
              </Storyboard>
            </VisualState>
            <VisualStateGroup.Transitions>
              <VisualTransition From="Normal" 
                                To="MouseOver">     
                <Storyboard Duration="00:00:01">
                  <DoubleAnimation From="1.0" To="1.25"
                    Storyboard.TargetName="myTransform"
                    Storyboard.TargetProperty="ScaleX" />
                  <DoubleAnimation From="1.0" To="1.25"
                    Storyboard.TargetName="myTransform"
                    Storyboard.TargetProperty="ScaleY" />
                </Storyboard>                                        
              </VisualTransition>
              <VisualTransition From="MouseOver" To="Normal"> 
                  <DoubleAnimation From="1.25" To="1.0"
                    Storyboard.TargetName="myTransform"
                    Storyboard.TargetProperty="ScaleX" />
                  <DoubleAnimation From="1.25" To="1.0"
                    Storyboard.TargetName="myTransform"
                    Storyboard.TargetProperty="ScaleY" />
                </Storyboard>
              </VisualTransition>
            </VisualStateGroup.Transitions>
          </VisualStateGroup> 
        </VisualStateManager.VisualStateGroups>  
      </Grid>
    </ControlTemplate>
  </Button.Template>
</Button>
The listing shows the definitions of two VisualTransition elements. The first
VisualTransition scales the Button up as it changes from the Normal VisualState to
the MouseOver VisualState. The second VisualTransition scales the Button down
as it goes from the MouseOver VisualState back to the Normal VisualState. These
two transitions are necessary because, otherwise, the Button would be stuck looking
like it did in a MouseOver state. There are two other interesting tidbits in this example.
Learning from others
Often, the most complex part of a control template is the VisualState section. In
Expression Blend, you can edit a control template for a stock control and view its states
both graphically and via the XAML source editor. This is a great way to learn how to
create your own visual states.
Transition
Transition 
back

335
Summary
First, you’ll also notice the addition of the two VisualState definitions. These are
necessary to keep the transition animations in place. Without these definitions, the
transition animations would be lost. The other interesting piece in this example is the
use of the VisualStateGroup element. You can only create transitions between states
that belong to the same group because, as I stated earlier, a Control can be in multi-
ple states as long as those states belong to different groups. Creating transitions
between states empowers you to create deeper and richer controls, so it’s only natural
to want to share these effects with multiple Control instances. 
14.5
Sharing your visual states
Because the visual states you create with the VisualTransition and VisualState ele-
ments are part of a ControlTemplate, you can define them as part of a Style. For the
sake of completeness, listing 14.21 shows the transitions from the previous example
defined as part of a Style.
XAML:
<Grid x:Name="LayoutRoot" Background="White">
  <Grid.Resources>
    <Style x:Key="buttonStyle" TargetType="Button">
      <Setter Property="Template">
        <Setter.Value>
          <ControlTemplate TargetType="Button">
           ...                          
          </ControlTemplate>
        </Setter.Value>       
      </Setter>                
    </Style>
  </Grid.Resources>
  <Button x:Name="myButton" Width="75" Height="75" Content="Push Me" 
    Style="{StaticResource buttonStyle}" />            
</Grid>
The listing shows how the previously defined Button ControlTemplate can be
included in a Style. This ControlTemplate uses the VisualState and Visual-
Transition elements from listing 14.20. This example puts everything from this chap-
ter together. The main thing to note is that you can leverage the VisualStateManager
within a Style declaration. This is exciting news because there can be a lot of XAML
involved in creating effects for the various states and transitions of a Control. These
states and transitions are part of something known as the parts and states model,
which is supported by Expression Blend. Because of this convenience, you’re empow-
ered to create some of the richest controls available on the internet.
14.6
Summary
Resources in Silverlight come in many flavors. The ones most associated with the word
resource are those you put in XAML, inside resource dictionaries. Those dictionaries
Listing 14.21
Creating a button that enlarges when hovered over
Visual state info 
goes here

336
CHAPTER 14
Resources, styles, and control templates
can be parts of controls in App.xaml or in separate files merged into existing resource
dictionaries. Resources defined this way can be just about anything from data source
or view model classes, to styles, to brush and color definitions.
 The most common uses of XAML resources are styles and control templates. Styles
provide a way to factor out the common property settings for controls and store them
in a location where they can be shared among many instances. Building upon styles
are control templates. Control templates go a step beyond what you can do with the
public properties affected with styles; they let you completely change the visual repre-
sentation of a control, including its visual states and transitions.
 Another common type of resource is a file resource, accessed as a loose file,
embedded into the compiled DLL, or copied into the zipped-up XAP. You’ll use these
whenever you want a file to be delivered with the application itself.
 Understanding resources, styles, templates, and visual states are all prerequisites to
building your own controls. I’ve covered user controls previously. In the next chapter,
you’ll take on building truly lookless controls as well as extending XAML, using every-
thing you’ve learned so far.

337
Extensions, converters,
custom controls, and panels
Now that you know the structure and rules for XAML files, let’s look at something
that allows you to bend those rules a little: extensions.
XAML allows you to represent almost anything using the object element and
property attribute syntaxes. But some things can get cumbersome to do that way. For
that reason, XAML includes the concept of extensions in the form of markup exten-
sions and type converters. Silverlight also includes the concept of a value converter,
but because that’s used almost exclusively with binding, I’ll cover it in chapter 16.
 You’ll want to internalize both concepts to understand what’s happening when
XAML is parsed or what those curly braces mean. 
 New in Silverlight 5 is the ability to create your own custom markup extensions.
This is especially useful when creating your own toolkits for patterns like Model
This chapter covers
■
Using markup extensions
■
Understanding type converters
■
Creating a custom panel
■
Creating a custom control

338
CHAPTER 15
Extensions, converters, custom controls, and panels
View ViewModel (MVVM). It’s also a great escape chute if the functionality XAML pro-
vides out of the box isn’t meeting your needs.
 In addition to markup extensions, type converters give you a powerful way to
extend XAML using your own code, especially if you’re considering creating your own
mini-language to succinctly represent what would normally be a more complex block
of XAML. The power of templating in Silverlight means you rarely have to create cus-
tom panels and controls. More often than not, an existing element provides the
behavior you require and a custom template will provide the appearance. But there
are times when you really need something that behaves differently than any of the
stock panels or controls. For those cases, Silverlight provides a way for you to create
your own fully featured panels and controls, supporting all the same things that the
built-in ones support.
 Custom panels enable you to create your own specialized layout algorithms. For
example, you may want a panel that lays out its children using concentric circles
rather than a box model. Implementing custom panels also has a nice educational
benefit: they help you visualize and understand the layout process. Once you’ve cre-
ated a few panels of your own, you’ll find you understand how the built-in ones work
and can better debug issues.
 Also due to the power of templating and the use of UserControls, custom controls
are rarer than custom panels. But there will be times when a custom control is exactly
what you need to differentiate your application or support a critical bit of functional-
ity. Silverlight supports the creation of custom controls, including full templating and
visual state management, making it a cinch to create your own.
 In this chapter, you’ll start by learning how to create custom markup extensions
and type converters. To continue the theme of extending XAML, you’ll create a cus-
tom panel named OrbitPanel. As you may have guessed, it’ll be a panel that lays out
its children in concentric circles or orbits. You’ll use that panel to learn how to man-
age measuring and arranging, and how to bend the layout cycle to your will. With the
custom panel completed, you’ll turn your attention to creating a custom control. This
will be an expander control, with support for a header and content, all of which can
be fully styled and templated.
15.1
Markup extensions
When viewing XAML of any complexity, you’re going to come across things such as
Style="{StaticResource MyStyle}" or Text="{Binding LastName}". The braces
indicate that you’re looking at a markup extension. Markup extensions are code that
can provide a value to a dependency property. In the case of the Style example, the
markup extension provides a full style object to the Style property. 
 In addition to the ability to create your own markup extensions, you’ll find your-
self heavily relying on the built-in set, which currently consists of StaticResource,
Binding, and TemplateBinding, for day-to-day development. Listing 15.1 illustrates
the use of the StaticResource and Binding markup extensions.

339
Markup extensions
<UserControl x:Class="MarkupExtensionExample.MainPage"
  xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" 
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" 
  Width="400" Height="300">
  <UserControl.Resources>
    <Style x:Key="TextBlockStyle"          
           TargetType="TextBlock">
      <Setter Property="FontSize"
              Value="25" />
      <Setter Property="Foreground"
              Value="DarkGray" />
    </Style>
  </UserControl.Resources>
  <StackPanel x:Name="LayoutRoot">
    <TextBlock Text="{Binding LastName}"        
               Style="{StaticResource TextBlockStyle}" /> 
    <TextBlock Text="{Binding FirstName}"
               Style="{StaticResource TextBlockStyle}" />
    <TextBlock Text="{Binding MiddleInitial}"
               Style="{StaticResource TextBlockStyle}" />  
  </StackPanel>
</UserControl>
In the case of the Text example in the listing, the markup extension is providing a
value from the data binding engine. I’ll cover data binding in chapter 16.
15.1.1 Creating a simple custom markup extension
The code in listing 15.2 shows the simplest of markup extensions, an extension that
takes no parameters and returns a fixed value. The code exists in the namespace Cus-
tomMarkupExtensions.
public class HelloExtension : MarkupExtension
{
  public HelloExtension() { }
  public override object ProvideValue(
                  IServiceProvider serviceProvider)
  {
    return "Hello";
  }
}
As shown in this example, to create a markup extension, you need only inherit from
MarkupExtension and override the ProvideValue method. The empty constructor is
necessary for use in XAML, specifically when you include additional parameterized
constructors. 
Listing 15.1
The Binding and StaticResource markup extensions in XAML
Listing 15.2
A simple markup extension
Style resource
Binding 
extension
Reused 
style

340
CHAPTER 15
Extensions, converters, custom controls, and panels
 When you use the markup extension, you must declare the namespace as
explained in section 2.1.2, and use the class name in your XAML. The following XAML
uses the HelloExtension markup extension you just created:
<Grid xmlns:ext="clr-namespace:CustomMarkupExtensions">
  <TextBlock Text="{ext:Hello}" />
</Grid>
Because you followed the convention of naming your markup extension with the suf-
fix Extension, you refer to it simply as Hello not HelloExtension. The convention is
helpful but not required.
15.1.2 Creating a parameterized markup extension
Typically, markup extensions will be more complex and include the ability to accept
parameters. As you previously saw, the built-in examples such as Binding take in a
number of discrete parameters that are used to provide key values and to alter their
behavior.
 Listing 15.3 shows how to create an interesting markup extension that will always
return the maximum of two provided values.
public class MaxValueExtension : MarkupExtension
{
  public MaxValueExtension() { }
  public MaxValueExtension(object value1, object value2)
  {
    Value1 = value1;
    Value2 = value2;
  }
Extensions as elements
Almost mostly seen as curly brace extensions, markup extensions can also be ele-
ments inside XAML. The previous Hello example could be written like this in XAML:
<Grid xmlns:ext="clr-namespace:CustomMarkupExtensions">
  <TextBlock>
    <TextBlock.Text>
      <ext:Hello />
    </TextBlock.Text>
  </TextBlock>
</Grid>
The effect is the same. This format is useful when the markup extension takes complex
types as parameters. But it also makes it a little difficult to tell what in your XAML is
a markup extension or a regular CLR object. Luckily, the distinction is rarely important
once you test the functionality of your extension.
Listing 15.3
A markup extension with parameters
Constructor

341
Markup extensions
  [ConstructorArgument("value1")]      
  public object Value1 { get; set; }
  [ConstructorArgument("value2")]        
  public object Value2 { get; set; }
  public override object ProvideValue(IServiceProvider serviceProvider)
  {
    if (Value1 is IComparable && Value2 is IComparable)
    {
      IComparable val1 = Value1 as IComparable;
      IComparable val2 = Value2 as IComparable;
      if (val1.CompareTo(val2) >= 0)
        return Value1.ToString();     
      else
        return Value2.ToString();       
    }
    else
    {
      return string.Empty;
    }
  }
}
Compare this listing to the previous one and you’ll notice a few new elements. First,
you have a constructor accepting two parameters. Those two parameters are also pro-
vided as two new discrete properties. Note that the properties have been marked up so
they map to the parameters; this is used by XAML serialization and, though not
required, is a good practice. 
 Arguably, there’s at least one cheat in this code: you coerce the final returned
value to a string. That limits its usefulness for anything other than a Text or Content
property, but it keeps this example simple.
 If you want to use the markup extension, the syntax is similar. There’s a subtle bug
in this approach, which I’ll explain after the example:
<Grid xmlns:ext="clr-namespace:CustomMarkupExtensions">
  <TextBlock Text="{ext:MaxValue Value1=200,Value2=25}" />
</Grid>
In this code, you’d expect the TextBlock to display 200, but it displays 25. This is
because the values, in the absence of any other type cues, are treated as strings. One
way to force them to be treated as numbers is to break the statement out using the
property element syntax described in section 2.1.3. Listing 15.4 shows the verbose
approach to using the markup extension.
<Grid xmlns:ext="clr-namespace:CustomMarkupExtensions"
      xmlns:sys="clr-namespace:System;assembly=mscorlib">
  <TextBlock>
    <TextBlock.Text>
      <ext:MaxValue>                 
Listing 15.4
Using the markup extension as an element
Constructor
argument 
parameter
Conversion 
string
Markup 
extension

342
CHAPTER 15
Extensions, converters, custom controls, and panels
        <ext:MaxValueExtension.Value1>
          <sys:Int32>200</sys:Int32>
        </ext:MaxValueExtension.Value1>
        <ext:MaxValueExtension.Value2>
          <sys:Int32>25</sys:Int32>
        </ext:MaxValueExtension.Value2>
      </ext:MaxValue>
    </TextBlock.Text>
  </TextBlock>
</Grid>
Listing 15.4 shows the expanded approach. Although this listing is significantly longer
than the previous example, it does provide complete control over the parameters.
Note also that the MaxValue markup extension uses its full name, MaxValueExtension,
when referencing its own parameters. 
 Markup extensions are a great way to get additional functionality out of XAML,
without needing to use a verbose object syntax. With Silverlight 5, you can even create
them yourself. Two other types of extensions you can create yourself are type convert-
ers and value converters. 
15.2
Custom type converters
In section 2.3 you learned that type converters are used to convert from one type to
another during a binding operation. Because you can create your own types in .NET, it
naturally seems that being able to create your own type converters would also be use-
ful. In XAML, you’ll typically convert from a string to some custom type.
 In this section, you’ll create a custom type converter to convert a XAML string of a
specific format to a border object.
15.2.1 Creating the converter
First, because you have to decorate your type with a type converter attribute, you’ll need
access to the source. If you don’t have access to the type source and can specify the con-
verter just for a single property of your own class, that’ll work too. The difference is that
a converter specified at the property level will only work for that one property in that
one class and not in all instances of that type in all properties and in all classes.
 Next, you’ll need to decide on a string format. The options are wide open, with the
exception that you can’t use the braces—{}—because they initialize the processing of
markup extensions (discussed earlier in this chapter). Listing 15.5 shows a sample
type converter that converts a string into a Border object. The format for the border is
<color> <thickness>, where color is a named color or an eight-digit hex color and thickness
is a number greater than or equal to zero.
public class BorderTypeConverter : TypeConverter           
{
  public override bool CanConvertFrom(  
    ITypeDescriptorContext context, 
Listing 15.5
A custom type converter that converts a string to a border

343
Custom type converters
    Type sourceType)
  {
    return sourceType == typeof(string);     
  }
  public override object ConvertFrom(
    ITypeDescriptorContext context, 
    CultureInfo culture, 
    object value)
  {
    string val = value as string;
    if (val == null) return null;
    string[] parts = val.Split(' ');      
    if (parts.Length < 2)                      
      return null;
    SolidColorBrush brush = (SolidColorBrush)XamlReader.Load(
      "<SolidColorBrush " + "xmlns=" +
         "'http://schemas.microsoft.com/winfx/2006/xaml/presentation'"
      + " Color='" + parts[0] + "' />");     
    double d;
    double.TryParse(parts[1], out d);     
    Thickness thick = new Thickness(d);
    Border border = new Border();       
          #G
    border.BorderThickness = thick;             
    border.BorderBrush = brush;            
    return border;    
  }
}
Note that the example in listing 15.5, in order to be production-ready, would require
additional guard conditions and the ability to delimit on commas as well as spaces.
 To create a custom type converter, you must first inherit from the TypeConverter
base class. For the type converter to be used in XAML, you only need to support con-
verting from the string type. More general-purpose converters will support additional
types.
 Note the hack used to get the color information—it allows you to use any color rep-
resentation that the XAML parser can parse. XamlReader.Load is a nifty function that
has lots of uses, not only for its intended purpose of creating branches of the object tree
at runtime but also for simply invoking the parser as you did here. Some things in Sil-
verlight are easier to parse in XAML than they are in code—color is one of them. 
NOTE
The Silverlight color enumeration understands only a few of the many
named colors, and the Silverlight Color class has no parse method to get the
remaining colors or the hex representation. Using the XAML parser via Xaml-
Reader.Load() in listing 15.5, you reduce hundreds of lines of parsing code
down to a single line.
15.2.2 Using the converter
Listing 15.6 illustrates a simple example of your custom type converter. Note that this
example also shows how to declare a dependency property—something I’ve touched
on in previous chapters and will cover in more detail shortly.
XAML only 
understands strings
Code to guard against 
malformed strings
XamlReader.Load
hack to parse color
Border creation

344
CHAPTER 15
Extensions, converters, custom controls, and panels
public class TestClass : Control
{
    [TypeConverter(typeof(BorderTypeConverter))] 
    public Border Border
    {
        get { return (Border)GetValue(BorderProperty); }
        set { SetValue(BorderProperty, value); }
    }
    public static readonly DependencyProperty BorderProperty =
        DependencyProperty.Register("Border", typeof(Border), 
        typeof(TestClass), null);
}
The TypeConverterAttribute that specifies the type converter to use for this specific
property in this class is shown in listing 15.6. The attribute is applied to the public
property because that’s what is  used by XAML. The converter is declared on the single
property so it will apply only there and not to all instances of the Border type. It’s also
important to note that the border isn’t actually used for anything other than illustrat-
ing how to use a type converter.
 Listing 15.7 shows the type converter implicitly in use in XAML.
<UserControl x:Class="TypeConverterExample.MainPage"
  xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
  xmlns:local="clr-namespace:TypeConverterExample">
  <Grid x:Name="LayoutRoot">
    <local:TestClass Border="Red 5" />   
  </Grid>
</UserControl>
Because you used the XamlReader.Load method, you could easily use any valid color
string such as "LemonCream" or "#C830019F". Bonus points if you caught the Star Wars
reference in listing 15.7.
Listing 15.6
A simple class that uses your custom type converter 
Listing 15.7
XAML showing the custom Border type converter in use
Colors in XAML
You may have given the color string #C830019F a double-take if you’re used to six-
digit HTML hex colors. Colors in Silverlight are typically expressed as eight-digit hex
numbers, the first pair representing the alpha component and the remaining three
pairs the red, green, and blue components in that order. In the color #C830019F, the
values are Alpha: 0xC8, Red: 0x30, Green: 0x01, and Blue: 0x9F. The alpha compo-
nent is optional, so you may use an HTML-style hex color if you wish. For consistency
across the application, I recommend you specify the alpha value and use all eight
digits without any shortcuts. Type converters are a great way to extend the flexibility
of XAML to include types you create yourself or new representations of existing types.
I’ve used them in projects to provide serialization support for legacy format strings
stored in databases and to extend the known representations of existing types.
TypeConverterAttribute
Type converter 
in use

345
Creating a custom panel
Being able to create your own custom type converters enables you to create your own
mini-languages inside Silverlight. If there’s a complex object that could be more easily
represented as a string, you can probably write a type converter for it.
 Together, custom markup extensions and type converters let you work around just
about any real limitation in XAML. They are ways for you to extend XAML to work bet-
ter for your own scenarios. Though not always thought of in this way, custom controls
and custom panels are two other ways you can extend XAML. I’ll cover them next. 
15.3
Creating a custom panel
In chapter 7, I covered the layout system where the primary responsibility for position-
ing and sizing controls falls to the panel the controls reside in. Some panels, such as
the Canvas, position using simple Left and Top coordinates. Others, such as the
StackPanel, lay out children based on a series of measurements and a placement
algorithm.
 In this section, you’re going to build a panel that doesn’t currently exist in Silver-
light: the OrbitPanel. This Panel will lay out elements in a circle rather than the hor-
izontal and vertical options available with the stock StackPanel or the box layout of a
Grid. The new panel in action can be seen in figure 15.1.
Figure 15.1
The OrbitPanel in action. The inner (first) orbit has nine buttons. The outer 
(second) orbit has five buttons.

346
CHAPTER 15
Extensions, converters, custom controls, and panels
The OrbitPanel control supports an arbitrary number (greater than zero) of orbits.
Each orbit is a concentric circle starting at the center point. The amount of space allo-
cated to an orbit is a function of the number of orbits and the size of the panel itself.
If there are many orbits, the space will be narrower.
 The layout is done starting at angle 0 and equally dividing the remaining degrees
by the number of items in the specific orbit. Items added to the panel may specify an
orbit via the use of an attached property.
 In this section, you’ll build this panel, starting with project creation, including the
addition of a library project specifically made for this panel and for the custom con-
trol you’ll build later in the chapter. You’ll create a dependency property as well as an
attached property, both because they’re useful and because creating them is a neces-
sary skill for panel and control builders. Next, you’ll learn how to perform the mea-
sure and arrange steps described in chapter 7 to lay out the control. I’ll wrap up this
section with a guide for potential enhancements should you desire to take the panel
further on your own.
15.3.1 Project setup
For this example, create a Silverlight project with a name like “CustomControls” or
whatever you prefer. Once the solution is up with the Silverlight application and test
website, add another project; this second project will be a Silverlight class library
named “ControlsLib.” Though I could’ve put the custom panel into the same project
as the Silverlight application, that’s almost never done in real-world scenarios.
 From the Silverlight application, add a project reference to the ControlsLib proj-
ect. Do so by right-clicking the Silverlight application, selecting Add Reference, navi-
gating to the Projects tab, and selecting the project. While you’re in the project,
remove the default class1.cs file that came with the template.
 With the project structure in place, let’s work on the OrbitPanel class.
15.3.2 The OrbitPanel class
The implementation of your panel will be in a single class named OrbitPanel. Inside
the ControlsLib project, add a new class named OrbitPanel. This class will contain all
the code for the custom panel. Derive the class from the Panel base type as shown here:
namespace ControlsLib
{
  public class OrbitPanel : Panel
  {
  }
}
Panel is the base type for all layout panels in Silverlight, including Canvas, Grid, and
StackPanel. The class itself derives directly from FrameworkElement, so it’s a pretty
low-level class, lacking the extras you’d find in something like Control. What it does
include is important to Panels: the Children property. 

347
Creating a custom panel
 The Children property is a UIElementCollection—it’s a specialized collection of
child elements placed inside this panel. This is the key property that makes a Panel a
Panel.
 In addition to the Children property, the Panel class provides a Background brush
property and a Boolean IsItemsHost, which is used in concert with the ItemsControl
class. Deriving from Panel allows you to substitute your panel for the StackPanel in a
ListBox, for example.
 The OrbitPanel class will have two dependency properties, used to control how it
functions.
15.3.3 Properties
The OrbitPanel class will need to have two properties. The first, Orbits, will control
the number of concentric circles, or orbits, available for placing items. The second is
an attached property, Orbit, to be used on items placed into the panel; it controls
which circle the item is to be placed in. 
ORBITS DEPENDENCY PROPERTY
In general, controls and panels should expose properties as dependency properties. If
there’s any possibility that they’ll be used in binding or animation, a dependency
property is the way to go. In fact, when the Silverlight team exposes properties as
straight CLR properties, more often than not they get feedback that it should’ve been
a dependency property because a customer or someone in the community tried to use
it in binding or animation.
 Dependency properties are specified at the class level using a static property and
DependencyProperty.Register call. For use in code and XAML, they’re also wrapped
with a standard CLR property wrapper that internally uses the dependency property as
the backing store. Optionally, the dependency property may specify a callback func-
tion to be used when the property changes. 
 Listing 15.8 shows the complete definition for the Orbits property, with all three
of these items in place.
public int Orbits                  
{
  get { return (int)GetValue(OrbitsProperty); }
  set { SetValue(OrbitsProperty, value); }
}
public static readonly DependencyProperty OrbitsProperty =
  DependencyProperty.Register("Orbits", 
                              typeof(int), 
                              typeof(OrbitPanel), 
                              new PropertyMetadata(1, OnOrbitsChanged));
private static void OnOrbitsChanged(DependencyObject d,
                                    DependencyPropertyChangedEventArgs e)
{
Listing 15.8
The Orbits property
CLR wrapper 
property

348
CHAPTER 15
Extensions, converters, custom controls, and panels
  if ((int)e.NewValue < 1)
  {
    throw new ArgumentException(
                    "Orbits must be greater than or equal to 1.");
  }
}
The first thing you’ll notice in listing 15.8 is the Orbits CLR property. This is a standard
CLR wrapper, used for simple property access in code and required for property access
in XAML. The property code uses the GetValue and SetValue methods, provided by
DependencyObject, to access the backing dependency property. Though not required
at a compiler or framework level (unless you want to use the property in XAML), pro-
viding the CLR wrapper is a standard practice when defining dependency properties.
TIP
Visual Studio 2010 includes a snippet for declaring dependency proper-
ties for WPF. With a slight change to rename UIPropertyMetadata to Proper-
tyMetadata in the last parameter, this works well for Silverlight applications
and saves you from remembering the exact syntax.
The next chunk of code in listing 15.8 defines and registers the dependency property.
The single line both defines the property and registers it with the property system.
The first parameter is the string name of the property. By convention, the name of the
dependency property variable is this string plus the word Property. The second parame-
ter is the type of the property itself—in this case, an int. The third parameter is the
type you’re registering the property on. The fourth and final parameter is a
PropertyMetadata object.
 The PropertyMetadata object can be used to specify a default value, a property
changed callback, or as seen here, both. When providing the default property value,
be very specific with the type. For example, a property value of 1 won’t work with a
double type; you must specify 1.0 or face the wrath of an obscure runtime error.
 The property changed callback function enables you to hook into the process to
perform actions when the dependency property changes. Note that you’d never want
to do this inside the CLR wrapper, because that would catch only a few of the scenarios
under which the property could change. The callback function takes in an instance of
the object that owns the property, as well as an EventArgs-derived class that has both
the new and old values available for inspection.
 All three pieces—the CLR wrapper, the dependency property definition and regis-
tration, and the callback function—make up the implementation of a single depen-
dency property in Silverlight. Though verbose, the benefits provided by dependency
properties are great, as seen throughout this book. When creating your own proper-
ties for panels and controls, err on the side of implementing them as dependency
properties.
 A specialized type of DependencyProperty, the attached property is used when you
want to provide a way to enhance the properties of another object. That’s exactly what
you need to do with the Orbit property.

349
Creating a custom panel
ORBIT ATTACHED PROPERTY
Each item added to the OrbitPanel needs to be assigned to a specific circle or orbit.
This is similar in concept to how a Grid needs items to specify rows and columns, or
how the Canvas needs Left and Top for each element. The way those properties are
specified is to use the type name (Grid or Canvas) and the property name together in
the element, like this:
<TextBox Grid.Row="0" Grid.Column="1" />
<TextBox Canvas.Left="100" Canvas.Top="150" />
In these examples, the TextBox doesn’t contain a Row, Column, Left, or Top property;
instead, it relies on another type (the Grid or Canvas) to attach them. You’ll do the
same with the Orbit property of the OrbitPanel. Listing 15.9 shows the implementa-
tion of the Orbit attached property in the OrbitPanel class.
public static int GetOrbit(DependencyObject obj)
{
  return (int)obj.GetValue(OrbitProperty);
}
public static void SetOrbit(DependencyObject obj, int value)
{
  obj.SetValue(OrbitProperty, value);
}
public static readonly DependencyProperty OrbitProperty =
    DependencyProperty.RegisterAttached("Orbit", 
                                        typeof(int), 
                                        typeof(OrbitPanel), 
                                        new PropertyMetadata(0));
Note that attached properties in listing 15.9 don’t use a CLR wrapper. Instead, you
provide Get and Set methods to allow the properties to be used in code and XAML.
 The RegisterAttached method is similar to the Register method seen in listing
15.9, with the parameters being identical. In this case, you didn’t use a callback
method, but rather provided a default value of zero.
 With this property in place, you’ll now be able to write markup like this:
<TextBox x:Name="FirstNameField" clib:OrbitPanel.Orbit="1" />
(The namespace declaration clib is assumed to be valid in the XAML file in which this
bit of markup lives.) To inspect the value of the attached property from code, use the
Get function defined in listing 15.9:
if (OrbitPanel.GetOrbit(FirstNameField) > 0) ...
In this way, you can now set and retrieve properties associated with objects, without
those objects having any provision for the properties in the first place. This is a power-
ful way to augment types to track additional data.
 Dependency properties—and the special type of dependency property, the
attached property—are essential and often use parts of the property system in
Listing 15.9
The Orbit attached property in the OrbitPanel class

350
CHAPTER 15
Extensions, converters, custom controls, and panels
Silverlight. When creating your own panels and controls, you’ll almost certainly rely
on them as the primary means of providing “knobs” your users can use to control the
behavior of your custom classes.
 In the case of the OrbitPanel, both of these properties will come into play when
performing your custom layout. 
15.3.4 Custom layout
The primary responsibility of a panel is the layout of its child controls. In truth, this is
what makes a panel a panel; a panel that performed no custom layout wouldn’t be
particularly useful.
 As you learned in chapter 7, the layout pass involves two primary steps: measure
and arrange. The measure step measures all the children of the panel, as well as the
overall panel itself. The arrange step performs final placement of the children and siz-
ing of the panel. As the author of a custom panel, it’s your responsibility to provide
this critical functionality. Listing 15.10 shows the measure step, implemented in the
MeasureOverride method of the OrbitPanel class.
protected override Size MeasureOverride(Size availableSize)
{
  var sortedItems = SortElements();
  double max = 0.0;
  foreach (List<UIElement> orbitItems in sortedItems)
  {
    if (orbitItems.Count > 0)
    {
      foreach (UIElement element in orbitItems)
      {
        element.Measure(availableSize);       
        if (element.DesiredSize.Width > max)
          max = element.DesiredSize.Width;
        if (element.DesiredSize.Height > max)
          max = element.DesiredSize.Height;
      }
    }
  }
  Size desiredSize = new Size(max * Orbits * 2, max * Orbits * 2);
  if (double.IsInfinity(availableSize.Height) || 
      double.IsInfinity(availableSize.Width))
        return desiredSize;                  
    else
        return availableSize;                     
}
The measure pass starts by getting a list of all items, grouped by their orbit. The code
for this function, SortElements, is included in listing 15.10. You loop through each
orbit, then through each item in the orbit, and measure that item. You get the largest
Listing 15.10
The measure step
Measure 
each child
Return panel 
measurements

351
Creating a custom panel
dimension (either width or height) from that element and compare it to the current
max. This is admittedly a bit of a hack, because the size allotted to each item is, in the-
ory, a pie slice, not a rectangle. In addition, due to the simplified nature of the orbit
sizing, you didn’t need to group the children by orbit. Nevertheless, it’ll work for this
example.
 Once you’ve looped through every child item, you then calculate the desired size
for this panel. The size is calculated by taking the number of orbits, multiplying by two
to account for the circular nature, then multiplying by the maximum item size. If the
original size passed in was unlimited, you return the desired size; otherwise, you
return the size provided to the control.
 The most important step in this function is the step that measures each child.
That’s what sets the desired size for each child in preparation for the arrange step
shown in listing 15.11.
protected override Size ArrangeOverride(Size finalSize)
{
  var sortedItems = SortElements();
  double orbitSpacing = CalculateOrbitSpacing(finalSize);
  foreach (List<UIElement> orbitItems in sortedItems)
  {
    int count = orbitItems.Count;
    if (count > 0)
    {
      double circumference = 2 * Math.PI * orbitSpacing * (i + 1);
      double slotSize = Math.Min(orbitSpacing, circumference / count);
      double maxSize = Math.Min(orbitSpacing, slotSize);
      double angleIncrement = 360 / count;
      double currentAngle = 0;
      Point centerPoint = 
                 new Point(finalSize.Width / 2, finalSize.Height / 2);
      foreach (UIElement element in orbitItems)
      {
        double angle = Math.PI / 180 * (currentAngle - 90);
        double left = orbitSpacing * (i + 1) * Math.Cos(angle);
        double top = orbitSpacing * (i + 1) * Math.Sin(angle);
        Rect finalRect = new Rect(              
              centerPoint.X + left - element.DesiredSize.Width / 2,
              centerPoint.Y + top - element.DesiredSize.Height / 2, 
              element.DesiredSize.Width, 
              element.DesiredSize.Height);
        element.Arrange(finalRect);
        currentAngle += angleIncrement;
      }
    }
  }
  return base.ArrangeOverride(finalSize);
}
The arrange step is where the real layout happens. It’s in this function that the indi-
vidual children are placed in their final locations. This function requires digging way
back to high school trigonometry.
Listing 15.11
The arrange step
Place child in
final location

352
CHAPTER 15
Extensions, converters, custom controls, and panels
 This function, like the previous one, starts by sorting the children into their
respective orbits. This is done via the SortElements function, the body of which is
shown in listing 15.12. The code then runs through each orbit, calculating the size of
the circle and the angular offset of each item. The angle chosen is based on the num-
ber of items in that orbit; it’s 360 degrees evenly divided by the item count.
 Then, you calculate the left and top position given the angle. This left and top will
be used for the center point of the element being placed. With that calculated, you
call Arrange on the element to move it to its final location.
 Listings 15.10 and 15.11 relied on common functions. The code for both,
CalculateOrbitSpacing and SortElements, is included in listing 15.12, wrapping up
the code for the OrbitPanel class.
private double CalculateOrbitSpacing(Size availableSize)
{
  double constrainingSize = Math.Min(
              availableSize.Width, availableSize.Height);
  double space = constrainingSize / 2;
  return space / Orbits;
}
private List<UIElement>[] SortElements()
{
  var list = new List<UIElement>[Orbits];
  for (int i = 0; i < Orbits; i++)
  {
    if (i == Orbits - 1)
      list[i] = (from UIElement child in Children
                 where GetOrbit(child) >= i
                 select child).ToList<UIElement>();
    else
      list[i] = (from UIElement child in Children
                 where GetOrbit(child) == i
                 select child).ToList<UIElement>();
  }
  return list;
}
CalculateOrbitSpacing uses the size of the panel to figure out the spacing of the
individual concentric circles. This is done by evenly dividing the total space. The
SortElements function takes each of the children and puts it into a list by orbit.
 Note that the SortElements function has special logic to group any elements in an
invalid orbit into the highest orbit. It doesn’t handle any cases where a negative
(invalid) orbit number was specified, but that functionality is easy enough to add.
 These three listings make up the full implementation of the OrbitPanel class.
With the code in place, it is time to test the panel on a page.
TEST MARKUP
To test the new panel, you’ll use a simple bit of markup that creates a number of but-
ton controls and places them into two different orbits. A third orbit is defined but not
Listing 15.12
Supporting functions

353
Creating a custom panel
used. Listing 15.13 shows the markup to be placed in MainPage.xaml. Before adding
this code, build the project to get the ControlsLib namespace to resolve and the
OrbitPanel IntelliSense to show.
<Grid x:Name="LayoutRoot" Background="White">
  <Grid.Resources>
    <Style TargetType="Button">
      <Setter Property="Width" Value="100" />
      <Setter Property="Height" Value="30" />
    </Style>
  </Grid.Resources>
  <clib:OrbitPanel Orbits="3">        
    <Button Content="Button 1" Background="Orange"
            clib:OrbitPanel.Orbit="0" />
    <Button Content="Button 2" Background="Orange"
            clib:OrbitPanel.Orbit="0" />
    <Button Content="Button 3" Background="Orange"
            clib:OrbitPanel.Orbit="0" />
    <Button Content="Button 4" Background="Orange"
            clib:OrbitPanel.Orbit="0" />
    <Button Content="Button 5" Background="Orange"
            clib:OrbitPanel.Orbit="0" />
    <Button Content="Button 6" Background="Orange"
            clib:OrbitPanel.Orbit="0" />
    <Button Content="Button 7" Background="Orange"
            clib:OrbitPanel.Orbit="0" />
    <Button Content="Button 8" Background="Orange"
            clib:OrbitPanel.Orbit="0" />
    <Button Content="Button 9" Background="Orange"
            clib:OrbitPanel.Orbit="0" />
    <Button Content="Button 10" Background="Blue"
            clib:OrbitPanel.Orbit="1" />
    <Button Content="Button 11" Background="Blue"
            clib:OrbitPanel.Orbit="1" />
    <Button Content="Button 12" Background="Blue"
            clib:OrbitPanel.Orbit="1" />
    <Button Content="Button 13" Background="Blue"
            clib:OrbitPanel.Orbit="1" />
    <Button Content="Button 14" Background="Blue"
            clib:OrbitPanel.Orbit="1" />
  </clib:OrbitPanel>
</Grid>
Listing 15.13 produces the image (figure 15.1) from the opening of this section, with
two orbits of buttons. In order for this listing to work, you must define the following
namespace:
xmlns:clib="clr-namespace:ControlsLib;assembly=ControlsLib"
Listing 15.13
Using the OrbitPanel from XAML
Panel with 
3 orbits

354
CHAPTER 15
Extensions, converters, custom controls, and panels
Panels are all about measuring and arranging their children. Measuring is used to ask
each child what size it wants to be, and to provide the overall size for the panel.
Arranging is used to calculate the final location of each of the child elements.
 This panel has been a simple implementation both for space reasons and to keep
to the essentials of what you need to learn. If you want to take it further, there are
some enhancements I recommend. 
15.3.5 Enhancements
The panel you created in this section is a good starting point for your own panel
design. There are a number of places you could take this panel. Three enhancements
I recommend are using start and stop angles, defining orbits using a grid-like
approach, and item clipping.
START AND STOP ANGLES
Currently the panel starts calculating layout at zero degrees and completes at 360
degrees. A simple change is to provide dependency properties for StartAngle and
StopAngle and use them in the layout calculation. Doing so will allow arcs of controls
rather than full orbits.
DEFINING ORBITS
Another potential change is to make the orbit definitions more flexible. Rather than
only providing a number of orbits, you can use orbit definitions in the same way the
Grid panel uses RowDefinitions. An example of the markup looks like this:
<clib:OrbitPanel>
  <clib:OrbitPanel.OrbitDefinitions>
    <clib:OrbitDefinition StartAngle="25" StopAngle="40" Width="100" />
    <clib:OrbitDefinition StartAngle="340" StopAngle="270" Width="Auto" />
    <clib:OrbitDefinition StartAngle="90" StopAngle="180" Width="*" />
  </clib:OrbitPanel.OrbitDefinitions>
  ...
</clib:OrbitPanel>
This code enables you to support different arcs for each orbit, as well as set widths
(optionally using grid units) for each orbit. 
 You can accomplish this by creating a custom collection type to hold the orbit def-
initions, then creating an OrbitDefinition class. The collection will be exposed by
the panel. The measure and layout calculations will change to use the provided sizes
rather than calculating sizes.
ITEM CLIPPING
The third enhancement is item clipping. I didn’t implement this in the OrbitPanel
because, frankly, it doesn’t make a lot of sense to do so. But clipping the individual
child elements is often essential to the functioning of a panel.
 When an item is clipped, the portion of the element that would normally lie out-
side the allotted space isn’t shown. This is accomplished by setting the size of the rect-
angle in the arrange step to be smaller than the size of the element. For example, to

355
Creating a custom control
modify listing 15.11 to clip all elements to 30 x 30-pixel rectangles, change the final-
Rect to be calculated like this:
double maxWidth = 30;
double maxHeight = 30;
Rect finalRect = new Rect(centerPoint.X + left - maxWidth / 2,
                          centerPoint.Y + top - maxHeight / 2, 
                          maxWidth, maxHeight);
In a real panel, you’d calculate the maxWidth and maxHeight based on available space
in the layout slot. In addition to this calculation change, be sure to apply the same
measurement to the call to the measure step, so the child has the ability to resize itself
if possible.
 Creating a custom panel in Silverlight is a straightforward process once you decide
on a layout algorithm. The majority of the work is performed inside the measure and
arrange steps. The measure step is where the panel calculates the size of each element
and the size of the panel itself. The arrange step is where the panel performs the
actual positioning (and optional clipping) of the child elements.
 Creating a custom control is similar to creating a panel; many of the same steps
apply. In the next section, you’ll create a control that supports styling and visual states.  
15.4
Creating a custom control
In the previous section, you built a custom panel. Panels differ from controls in that
they typically participate in the opposite side of layout: panels are responsible for lay-
ing out controls; controls are responsible for measuring themselves.
 When creating controls in Silverlight, you have two choices: you can write a User-
Control or create a custom control. User controls, covered in chapter 12, are more
about composing other controls, whereas custom controls are about defining new
behavior to make available to developers. It’s far more common for application devel-
opers to create UserControls. But control and framework developers, and those look-
ing for something special in their application, should be comfortable with creating
custom controls.
 Custom controls differ from user controls in that they’re lookless by default—
they’re expected to work with a completely different control template as long as cer-
tain contracts are adhered to. User controls bring their templates along with them in
the form of the XAML file; they support limited templating and styling capabilities.
 In this section, you’re going to build a custom control that can show grouped con-
tent with a header that, when clicked, shows or hides the content. There are already
controls that can do this, but building it will show you how to inherit from a base class
and support templating and visual states.
15.4.1 Choosing the base type
In chapter 12 you learned about the different types of controls available in Silverlight.
Many of the controls had common base types. When creating your own control, the

356
CHAPTER 15
Extensions, converters, custom controls, and panels
choice of base type will greatly impact how the control can be used and how other
developers will expect it to work. Table 15.1 shows the common base types you can
derive from.
When choosing a control, try to pick the richest one possible. If you’re building some-
thing that naturally fits the Selector model, that’s a better choice than picking Item-
sControl or Control. The more you use built-in functionality, the more your control
will behave like others in Silverlight without extra effort on your part.
 For the control you’re building, you’ll start with ContentControl and build from
there. In the ControlsLib project, add a new class named Expander:
namespace ControlsLib
{
  public class Expander : ContentControl
  {
  }
}
The ContentControl base class provides the ability to use properties such as Content
and ContentTemplate. You’ll definitely make use of those, but you also need to aug-
ment with your own properties for the header.
15.4.2 Properties
When supporting arbitrary content, the pattern is to have a content property of type
object and a template property of type DataTemplate. That way, the developer
Table 15.1
Common control base types
Type
Description
Control 
This is a generic base control. If none of the specialized variants 
has what you need, derive from this class.
ContentControl 
A control that contains a single child item for display. The Button
and Label controls are examples of ContentControl.
ItemsControl
A control that contains multiple child items for display. The control 
supports adding individual items or binding to a list to obtain items. 
The items are displayed using a supplied panel.
Selector
An ItemsControl that supports selecting an item. An example of 
this is a ListBox.
RangeBase
A control that supports minimum, maximum, and current values. 
One example is the Slider control; another is the ScrollBar.
ButtonBase
A control that can be clicked to fire an event. Button and 
HyperlinkButton are two examples.
ToggleButton
A button-type control that supports keeping its state when clicked. 
Examples include the ToggleButton when used as is, the
RadioButton, and the CheckBox.

357
Creating a custom control
can customize the presentation of the content without having to retemplate the
entire control. 
 The ContentControl base type supplies the Content and ContentTemplate prop-
erties that perform this function for the primary content. You’ll add Header and
HeaderTemplate to support the same for the top header. Both properties are defined
as dependency properties, as shown in listing 15.14.
public object Header
{
  get { return (object)GetValue(HeaderProperty); }
  set { SetValue(HeaderProperty, value); }
}
public static readonly DependencyProperty HeaderProperty =
    DependencyProperty.Register("Header", 
                                typeof(object), 
                                typeof(Expander), 
                                new PropertyMetadata(null));
public DataTemplate HeaderTemplate
{
  get { return (DataTemplate)GetValue(HeaderTemplateProperty); }
  set { SetValue(HeaderTemplateProperty, value); }
}
public static readonly DependencyProperty HeaderTemplateProperty =
    DependencyProperty.Register("HeaderTemplate", 
                                typeof(DataTemplate), 
                                typeof(Expander), 
                                new PropertyMetadata(null));
Using object as the type for the header enables you to use anything from a string to a
Grid full of controls as the header. If a template is supplied, Silverlight will render
using that. If no template is supplied, Silverlight will render it natively if it’s a
UIElement, or using ToString if it’s any other type (such as an integer, string, or your
custom class).
 In addition to the simplicity of class inheritance, one of the main differentiators
for a custom control over a user control is the control template.
15.4.3 The control template contract
When creating a custom control, it’s important to define the contract with the control
template. The contract consists of the things that must be in the control template in
order for your control to work.
 In general, you want this contract to be as small as possible. Think long and hard
about what things you must have in the contract, as opposed to what could be accom-
plished with binding.
 In your control, the contract can be kept small: just a single toggle button. You
need the toggle button, in this case, because you’re going to use it to expand and
Listing 15.14
The Header and HeaderTemplate properties

358
CHAPTER 15
Extensions, converters, custom controls, and panels
collapse the bottom section of the expander control. Listing 15.15 shows the class with
the contract in place.
[TemplatePart(Name=Expander.ExpanderButtonName, 
              Type = typeof(ToggleButton))]
public class Expander : ContentControl
{
  private const string ExpanderButtonName = "ExpanderButton";
  private ToggleButton _expanderButton;
  public Expander()
  {
    DefaultStyleKey = typeof(Expander);
  }
  public override void OnApplyTemplate()    
  {
    base.OnApplyTemplate();
    _expanderButton = 
         GetTemplateChild(ExpanderButtonName) as ToggleButton;
    if (_expanderButton != null)
    {
      _expanderButton.Checked += 
            new RoutedEventHandler(OnExpanderButtonChecked);
      _expanderButton.Unchecked += 
            new RoutedEventHandler(OnExpanderButtonUnchecked);
    }
  }
  void OnExpanderButtonUnchecked(object sender, RoutedEventArgs e)
  {  }
  void OnExpanderButtonChecked(object sender, RoutedEventArgs e)
  {  }
}
The contract is defined both explicitly and implicitly. The explicit contract definition
is the TemplatePart attribute on the class. Though not enforced in code, this attri-
bute is used by Expression Blend to enforce the contract in the tool. The attribute
specifies the name of the required element as well as its type. A best practice is to use a
constant for the name, because it’ll also be used elsewhere in the code.
 The implicit contract is enforced by the OnApplyTemplate function. In this func-
tion, you’re going to look for the various template parts and attempt to resolve them
into variables you can use elsewhere in the class. OnApplyTemplate is called when the
control template is loaded for this instance of the control. 
 In OnApplyTemplate, you’ll typically find the control instances by name using Get-
TemplateChild (which does a FindName equivalent on the template) and wire up any
events or other hooks.
 Note also the constructor. The constructor specifies the default style key to be
used. This looks a little odd because it’s setting the key to the type of this class. As
you’ll see next, that’s exactly what you want.
Listing 15.15
Contract with the control template
Template part
OnApplyTemplate

359
Creating a custom control
15.4.4 The default template
Custom controls are designed to support templating by the designers and developers
using them. But every control should provide a default template to be used when no
other template has been applied.
 The default template is kept in a resource dictionary file named generic.xaml in
the themes folder of the assembly containing the control. In your project, that’s the
ControlsLib assembly. Add the themes folder and the generic.xaml file. Listing 15.16
shows the style to be included inside the ResourceDictionary tags.
<Style TargetType="clib:Expander">           
  <Setter Property="Template">
    <Setter.Value>
      <ControlTemplate TargetType="clib:Expander">
        <Grid>                            
          <Rectangle Stroke="{TemplateBinding BorderBrush}"
                     StrokeThickness="1" />
          <Grid>
            <Grid.RowDefinitions>
              <RowDefinition Height="Auto" />
              <RowDefinition Height="Auto" />
            </Grid.RowDefinitions>
            <Grid x:Name="HeaderGrid" Grid.Row="0">
              <Rectangle Fill="DeepSkyBlue" />
              <ContentPresenter 
                     Content="{TemplateBinding Header}"
                        ContentTemplate="{TemplateBinding HeaderTemplate}" 
                     VerticalAlignment="Center"
                     Margin="5"/>
              <ToggleButton x:Name="ExpanderButton"
                            HorizontalAlignment="Right"
                            VerticalAlignment="Center"
                            Content="#" IsChecked="True"
                            Width="30" />
            </Grid>
            <Grid x:Name="ContentGrid" Grid.Row="1">
              <ContentPresenter 
                    Content="{TemplateBinding Content}"
                    ContentTemplate="{TemplateBinding ContentTemplate}" />
            </Grid>
          </Grid>
        </Grid>
      </ControlTemplate>
    </Setter.Value>
  </Setter>
</Style>
Note that this style doesn’t have a key. The key is the type it targets; that’s why the con-
structor in listing 15.15 specifies the class type as the default style key. 
Listing 15.16
The control template
Note target type 
and no key
Place visual
states here

360
CHAPTER 15
Extensions, converters, custom controls, and panels
 Listing 15.16 shows the default style and template for the Expander control. The
template is defined just like the control templates you saw in chapter 14. In this case, I
use a grid to hold both the header and the content. Both are implemented using
ContentPresenter elements. The ContentPresenter, when bound to appropriate
content and content template properties, takes care of all the dirty work associated
with presenting arbitrary content. Without it, there’d need to be some way to use a
TextBlock when it’s text, and other specialized types otherwise.
 For this listing to work, the ResourceDictionary tag will need the following
namespace added:
xmlns:clib="clr-namespace:ControlsLib"
Listing 15.16 left room for the spot where the visual states will go. The final piece of a
custom control is the support and definition of VisualStateManager controlled state
management.
15.4.5 Visual states
Visual states describe the UI modes or states a control can be in. One visual state may
be when the mouse is over the control, another when the mouse button is clicked,
and yet another when something is considered selected.
 In our control, the visual states will be Expanded and Collapsed. Using visual states
rather than hard-coding expand and collapse logic allows the designer or developer
to customize what it means for the control to be expanded or collapsed. Remember,
controls are lookless—they define behavior, not appearance.
 Listing 15.17 shows the parts of the Expander class required for supporting visual
states. 
[TemplatePart(Name=Expander.ExpanderButtonName, 
              Type = typeof(ToggleButton))]
[TemplateVisualState(Name = Expander.ExpandedStateName,   
                     GroupName = "ExpanderStates")]  
[TemplateVisualState(Name = Expander.CollapsedStateName, 
                     GroupName = "ExpanderStates")]
public class Expander : ContentControl
{
    private const string ExpanderButtonName = "ExpanderButton";
    private const string ExpandedStateName = "Expanded";
    private const string CollapsedStateName = "Collapsed";
    void OnExpanderButtonUnchecked(object sender, RoutedEventArgs e)
    {
        VisualStateManager.GoToState(this, CollapsedStateName, true);
    }
    void OnExpanderButtonChecked(object sender, RoutedEventArgs e)
    {
        VisualStateManager.GoToState(this, ExpandedStateName, true);
    }
...
}
Listing 15.17
Supporting visual states
Visual state
contract

361
Creating a custom control
Just as was the case with template parts, template visual states have both an explicit
and implicit contract. The explicit contract is handled by the TemplateVisualState
attribute. This allows Blend and other design tools to know what visual states are sup-
ported by this control.
 The implicit contract is handled by calls to VisualStateManager.GoToState. This
call works under the assumption that a particular visual state exists. If it exists, the con-
trol is put into that state. In this example, when the expander button (a template
part) is checked, you enter the Expanded state. When it’s unchecked, you enter the
Collapsed state.
 Using states like this allows you to define the appearance of each state completely
in XAML. Of course, you’ll need to provide a default implementation in the control
template in generic.xaml.
15.4.6 Visual states in template
Visual states are designed for XAML. They’re based on storyboards and references
within the same XAML file. For more in-depth information on creating states, check
out chapter 14.
 Listing 15.18 shows the visual states definition for the Expander control. Place this
markup into the spot called out in listing 15.17.
<VisualStateManager.VisualStateGroups>
  <VisualStateGroup x:Name="ExpanderStates">
    <VisualState x:Name="Expanded">        
      <Storyboard>
        <ObjectAnimationUsingKeyFrames 
                        Storyboard.TargetName="ContentGrid"
                        Storyboard.TargetProperty="Visibility">
          <DiscreteObjectKeyFrame KeyTime="00:00:00">
            <DiscreteObjectKeyFrame.Value>
              <Visibility>Visible</Visibility>
            </DiscreteObjectKeyFrame.Value>
          </DiscreteObjectKeyFrame>
        </ObjectAnimationUsingKeyFrames>
      </Storyboard>    
    </VisualState>
    <VisualState x:Name="Collapsed">       
      <Storyboard>
        <ObjectAnimationUsingKeyFrames 
                        Storyboard.TargetName="ContentGrid"
                        Storyboard.TargetProperty="Visibility">
          <DiscreteObjectKeyFrame KeyTime="00:00:00">
            <DiscreteObjectKeyFrame.Value>
              <Visibility>Collapsed</Visibility>
            </DiscreteObjectKeyFrame.Value>
          </DiscreteObjectKeyFrame>
        </ObjectAnimationUsingKeyFrames>
      </Storyboard>
Listing 15.18
Visual states in the control template
Expanded state
Collapsed state

362
CHAPTER 15
Extensions, converters, custom controls, and panels
    </VisualState>
  </VisualStateGroup>
</VisualStateManager.VisualStateGroups>
Listing 15.18 provides the markup for two different visual states: Expanded and
Collapsed. Both refer by name to elements defined in listing 15.16. Using visual states
like this allows you to have a control that has no real dependency on elements inside
XAML. Instead, the control’s behavior specifies which state to enter, and the markup
(which can be changed by a developer or designer without access to the control’s
source) can completely define what it means to be in that state.
TESTING
The final step is to test the control. I used it to wrap the OrbitPanel from the first sec-
tion, but you could use it with any type of content. Here’s the MainPage.xaml markup
with the new control in place:
<Grid x:Name="LayoutRoot" Background="White">
  ...
  <clib:Expander Header="This is an Expander Control" 
                 Margin="20" BorderBrush="Black">
    <clib:OrbitPanel Orbits="3">
    ...
    </clib:OrbitPanel>
  </clib:Expander>
</Grid>
The result of the combination of both controls is shown in figure 15.2. The expander
encloses the OrbitPanel and its contents.
Figure 15.2
The expander control with the custom layout panel included as content

363
Summary
Writing custom controls in Silverlight can be a rewarding experience. The templating
approach means you don’t have to consider every possible way someone may want to
present your control; instead, you can focus on the required behavior.
 Controls in Silverlight are lookless. The code you write shouldn’t make assump-
tions, other than what’s in the explicit contract, about what the UI contains or how it’ll
behave. The use of template binding, template parts, and template visual states helps
keep this separation clean and understandable.
 In general, before you create a custom control, consider whether templating an
existing control will provide what you’re looking for. I’ve seen menu systems created
entirely from ListBox controls (I’m even responsible for one of them). Once you’re
sure that the behavior of existing controls doesn’t provide what you’re looking for,
you can embark on creating your own control.  
15.5
Summary
Silverlight has a highly extensible layout system. Imagine if other technologies allowed
you to easily create your own elements with completely custom layout algorithms.
HTML, for one, would be much more creative if you could encapsulate all that div
manipulation into something that works as a first-class citizen on any page, cross-
browser. It gets close, but it’s still not as clean as XAML.
 As the name suggests, you can extend XAML using custom markup extensions.
They’re a powerful way to add virtually anything you could want to XAML. The bind-
ing system, resource system, and others are all built on markup extensions. If you
wanted to build your own super incredible binding replacement, you could do that.
More commonly, markup extensions are used as parts of toolkits to provide optimized
functionality and get rid of a lot of the ceremony you’d normally have to do when
wiring up.
XAML has tags that represent the types it has access to. You can load your own types
into XAML just by referencing the right namespace and ensuring the object has a
default constructor. Using type converters, you can even provide shorthand ways to
instantiate your objects: mini-languages and shorthand. 
 Custom panels and custom controls provide another way to extend XAML: the abil-
ity to augment Silverlight with your own requirements and your own ideas of how
things should work in the UI. They provide a way to extend the system, building on
the same foundations used in all of the other built-in elements. They let you do things
the designers and developers of Silverlight may not have considered when building
the platform.
 Creating a custom panel is easy once you learn to express the layout algorithm as a
pair of measure and arrange steps. Silverlight handles calling these steps when
needed, so all you need to concern yourself with is the functionality directly related to
your own custom layout algorithm. The sky’s the limit!
 Custom controls are equally powerful. If you’ve searched through the built-in con-
trols, the SDK, and the toolkit, and you haven’t found a control with the behavior you

364
CHAPTER 15
Extensions, converters, custom controls, and panels
want, you can build your own from scratch. Silverlight provides strong building blocks
in the form of specialized base classes and the templating and state management pat-
terns you leverage in the creation of your controls. You don’t even need to worry
about how it looks; once you define the behavior and the contracts, a designer can
make the control look any way she wants. That’s the power of the lookless control
model.
 The next chapter dives into something else you’ll see often in XAML: binding state-
ments.

Part 3
Working with data
and services
Most Silverlight applications, especially business-oriented ones, need to
interact with data. Oftentimes, that data comes from a remote service on an
internal network or the public internet.
 Part 3 looks first at how to use binding, an essential XAML feature, to commu-
nicate data from your data layer or model to the UI. You’ll also explore the fea-
tures and controls that build on binding, such as the DataGrid and DataForm
and data annotations. Wrapping up the discussion on binding, I’ll cover input
validation and show you how to extend the validation system to perform your
own data validation at the UI layer in a robust and reusable way.
 Binding isn’t just about business data, so I cover the binding system in depth.
You’ll see how it may be used to bind various UI elements together to avoid the
“glue code” you might otherwise need.
 With the consumption of data covered, I then turn to how to get that infor-
mation to the client. First, I’ll discuss the Silverlight networking stack in depth,
paying particular attention to the asynchronous operations and how to simplify
them using Reactive Extensions, tasks, and more. 
 Once you know the basics of networking, I’ll expand on that topic to include
SOAP web services (both ASMX and WCF); REST services using the WCF Web API;
and parsing XML, JSON, and RSS data.
 Part 3 wraps up with a look at some of the more advanced networking fea-
tures, including sockets and WCF duplex services. When you finish part 3, you’ll
have built a strong and practical understanding of how to use binding, data, and
networking in your own Silverlight applications. 


367
Binding
If I included a top-three list of the most important features to learn in depth in
Silverlight or WPF, binding would be on that list. Binding—specifically, data bind-
ing—tends to conjure up images of the old Visual Basic VCR control bound directly
to tables in an Access database, mishandled lost-focus events, and circular valida-
tion problems. In more recent times, binding tends to be associated with special-
ized data controls on web forms. In both cases, binding is associated with
traditional business or application data on its way to or from a persistent data store.
 Though binding is most commonly thought of in relation to persistent applica-
tion or business data, it’s used for much more than that in Silverlight and WPF. 
 In Silverlight and WPF, you can bind properties such as IsEnabled to bool val-
ues hanging off any arbitrary object. You can also bind controls to each other so
that, for example, a slider controls the z-axis rotation of an object in 3D space.
This chapter covers
■
Mastering binding with a binding source
■
Binding UI elements together
■
Using value converters
■
Creating data templates

368
CHAPTER 16
Binding
Neither of those properties (IsEnabled or z rotation) would normally be thought of
as “data” in a data binding sense, but in the strictest sense of the term, they are.
 Want to show the number of characters entered in a TextBox? You guessed it: bind-
ing will help you do that with no code required.
 What if you want to set up a ListBox so each item displays a photo on the left
along with a name and description stacked on the right? Binding and data templates
are essential for that type of UI customization. Data templates provide the structure
for the ListBox items, and use binding to tie in your data. When combined, the two
are more powerful than just about any other way to format the presentation of a List-
Box in any other platform.
 Data-driven applications are an exciting area of business application develop-
ment. Oftentimes, the mere mention of a data-driven application brings groans from
all the developers in the room. In Silverlight, that was primarily because applications
with model properties defined in a database couldn’t make effective use of the bind-
ing system. With Silverlight 5 and support for ICustomTypeProvider, that’s no longer
a limitation.
 In chapter 33, when I cover the MVVM pattern, you’ll see just how essential binding
can be for good application architecture. This chapter prepares the foundation by
covering the mechanics of binding the input controls discussed in chapter 11 with in-
memory objects, as well as how to bind controls to each other. Then, because data may
come in any format, you’ll learn how to format and convert it using value converters
and binding expressions. You’ll also see what it takes to define object properties at
runtime while still supporting the binding system. The chapter ends with a discussion
about data templates, both explicit and implicit.
16.1
Binding basics
Binding is a powerful way to create a connection between your UI and a source of
data. This simple technique can be used to create a clean separation between your
user interface and its underlying data and is essential for good application architec-
ture, as you’ll see in chapter 33. Regardless of the reason, you can use data binding in
your application by creating an instance of the Binding class.
 The Binding class is used to define a connection between a CLR object and a UI
component. This connection is defined by three essential elements: the source of the
data (the CLR object), the binding mode, and the target for the data (the dependency
property; see section 2.1.4 for more information). These three items are part of a con-
ceptual model that explains binding, which is shown in figure 16.1.
Figure 16.1
A conceptual view of data binding. The source owns the data; the 
target operates on (displays, edits, and so forth) the data.

369
Binding basics
The illustration uses the situation of binding the current time of day to a TextBox to
give a high-level overview of what data binding looks like. This conceptual binding sets
the Text property of a TextBox to the current TimeOfDay. To create a binding like this,
you must use one of the two available binding syntaxes. These syntaxes require you to
define both the source and the target of a binding. Each approach is appropriate at a
different time, so I’ll cover each in its own right in section 16.1.1. Once you’ve
decided which syntax is appropriate for your situation, you must decide how data can
pass between the source and the target. This is the responsibility of the BindingMode,
which I’ll describe in section 16.1.2.
16.1.1 Mastering the binding syntax
Silverlight gives you the ability to create a Binding using two different approaches.
The first allows you to dynamically create a binding at runtime. The second gives you
the opportunity to specify a binding at design time. The scenario from figure 16.1 will
be used to show both approaches.
BINDING AT RUNTIME
Binding to a data source at runtime is a common approach used in event-driven appli-
cation development. For instance, you may decide to display a list of basketball games
based on a date selected by a user. Or you may decide to show the current time when
an application is loaded. Either way, creating a Binding at runtime follows a common
pattern, which is shown here. First, the XAML in the page:
<TextBox x:Name="myTextBox" />
Next the code to create the binding source and the binding itself:
DateTime currentTime = DateTime.Now;
Binding binding = new Binding("TimeOfDay");
binding.Source = currentTime;
binding.Mode = BindingMode.OneWay;
myTextBox.SetBinding(TextBox.TextProperty, binding);
This code shows how to bind the value of a CLR property to a UI element at runtime.
The preceding code binds the current time of day to the TextBox created in XAML. You
first retrieve the DateTime object that represents the current moment in time. This
object is then bound to the UI element (the TextBox) in just four lines of code. These
four lines of code specify the source, the binding mode, and the target of a binding.
 The source of a binding is made up of two codependent items that specify which
property of a CLR object to bind to. The name of the property to bind to is set when you
create a Binding instance through the constructor. This constructor takes a single
string parameter, which represents the name of the property to bind to. This property
belongs to a CLR object that must be associated with a Binding through the Source
property. Once this happens, the source of the binding is officially set. You can then
choose a BindingMode, which I’ll cover in section 16.1.2 (in this case, OneWay). Once the
source and binding mode have been set, you need to turn your focus to the target.

370
CHAPTER 16
Binding
 The target element of a binding will always derive from the DependencyObject
class. Virtually every visual element in Silverlight can be a target because the
DependencyObject class exposes a method called SetBinding. This method associates
a target property, which must be a dependency property, with a Binding instance.
After this method is called, the source will be bound to the target.
 Occasionally, you may want to unbind a data source. Fortunately, data binding can
be halted by manually setting the target property of a binding. For example:
myTextBox.Text = "Binding Removed";
This feature is only available at runtime because that’s the only time it makes sense.
Using a Binding at runtime is a powerful option. Equally as powerful and more often
used is the ability to create a Binding at design time in XAML.
BINDING AT DESIGN TIME
Binding to a data source at design time is a common feature in declarative markup
languages such as XAML. You’ve probably seen the power of this data-binding
approach if you’ve used ASP.NET or WPF. If you haven’t, don’t worry. In essence, this
approach allows you to keep your code separate from its presentation so that you can
take advantage of the developer/designer workflow available within Silverlight. It also
helps to keep your code clean and maintainable, as seen in this markup:
<TextBox x:Name="myTextBox" Text="{Binding TimeOfDay, Mode=OneWay}" />
This code shows how to create a binding at design time in XAML. The binding is asso-
ciated with a target through the use of the XAML markup extension syntax, which uses
braces ({}). These braces, along with the use of the Binding extension name, inform
a property that a data source will be bound to it. This data source will be a CLR object
that has a TimeOfDay property, which may provide or receive a value, depending on
the binding mode. The other properties associated with the binding are set using a
propertyName=propertyValue syntax (Mode=OneWay).
 The curly brace syntax is helpful, but it’s simply shorthand. You’ll use the short-
hand syntax throughout XAML in the rest of this book, but it can be helpful to under-
stand the fuller version of the syntax. The longer form (using property element
syntax) of the earlier TextBox binding looks like this:
<TextBox x:Name="myTextBox">
  <TextBox.Text>
    <Binding Path="TimeOfDay" Mode="OneWay" />
  </TextBox.Text>
</TextBox>
The markup in this example does the very same thing as the previous but doesn’t
invoke the markup extension triggered by the brace. Obviously, the syntax is much
more verbose and would be cumbersome to use for all values. If Silverlight ever gets

371
Binding basics
MultiBinding (a concept currently in use in WPF), understanding the full binding
syntax will be essential to its use.
NOTE
All parameters in a binding expression may be set using name=value
syntax. The binding expression {Binding TimeOfDay} is shorthand for {Bind-
ing Path=TimeOfDay}. Though you’ll find that certain tools, such as Expres-
sion Blend and Visual Studio 2010, prefer one syntax over the other, both
may be used interchangeably and are equally valid.
When creating a binding in XAML, you may set the source in procedural code. This
code is responsible for setting the context in which a data source can be used via the
appropriately named DataContext property. This property will be explained in fur-
ther detail in section 16.2.2. For now, know that this is how a CLR object can be bound
to a DependencyObject. In this case, the code-behind would have the following code
to set the DataContext for the TextBox:
DateTime currentTime = DateTime.Now;
myTextBox.DataContext = currentTime;
The DataContext may also be set in markup using a StaticResource, if the type being
used supports it. This approach is sometimes used for binding to a view model, which
you’ll see in chapter 33.
 Binding at design time is a valuable option when it comes to working with data. It
empowers you to separate UI from code. This functionality allows a designer to
enhance a UI without worrying about where the data is coming from. In a similar
light, binding at runtime enables you to create a more dynamic form of data binding.
Regardless of where you define the binding, both approaches define a bridge between
a source and a target. Data can flow in multiple directions across this bridge. To con-
trol the direction of that flow, you must learn about the various binding modes.  
16.1.2 Choosing a binding mode
The Binding class gives you the ability to determine how data can flow between the
source and the target. This flow can be controlled by setting the Binding instance’s
Mode property. This property represents one of the three options available in the
BindingMode enumerator—OneTime, OneWay, and TwoWay.
ONETIME
The OneTime option sets the target property to the source property when a binding is
initially made. When this BindingMode is used, any changes to the data source won’t
be automatically sent to the target.
Instead, the target will be set only
when the source is initialized, as
shown in figure 16.2.
 The figure shows the simplistic
nature of the OneTime BindingMode.
Figure 16.2
A conceptual view of OneTime
binding to a data source. The value is initially read 
from the source and is never updated again.

372
CHAPTER 16
Binding
As you can imagine, this BindingMode is appropriate in situations where you only care
about the initial value of a property. For instance, you may want to display the cre-
ation date of a database record. Because this value shouldn’t change, the OneTime
BindingMode is a great choice. For property values that will change, such as the date/
time when a database record was last modified, you may want to use the OneWay
binding option.
ONEWAY
The OneWay BindingMode is the default when you create a Binding. This option gives
you the ability to automatically receive changes from a source property. Whenever the
binding source property changes, the target property will automatically change, but
the source property won’t change if the target is altered. 
 Figure 16.3 shows how the OneWay BindingMode works at a high level. An example
of real-world one-way binding is a thermometer. If you change your body temperature,
the thermometer changes. But if you somehow change the thermometer indicator
manually (hold a match to the tip), your body temperature won’t change. That’s one-
way binding from your body to the thermometer. Just about any instrument or indica-
tor will work this way. This inability to send a change from the target back to the
source shows how OneWay binding works. For situations where you do want to send
changes in the target back to the source, you use the TwoWay option.
TWOWAY
TwoWay binding enables two properties that are bound to change each other. This may
sound recursive, but it’s not. A TwoWay binding changes the target when the source
changes. If the target changes, the source is updated. 
 Figure 16.4 shows a conceptual view of the TwoWay binding. This binding approach
is useful for data entry forms using Silverlight because forms generally allow users to
add as well as edit data. This process of editing the preexisting data practically begs for
TwoWay binding.
 The TwoWay BindingMode is one of the options available to control the flow of your
data. The other alternatives are available through the OneWay and OneTime options.
Collectively, these options are an important part of setting up a binding. 
Figure 16.3
A conceptual view of OneWay binding to a data source. The value is updated each 
time the source changes, but changes to the value in the target control don’t make it back to 
the source.

373
Understanding your binding source
You spent this section looking at the basics of binding because understanding the
basics is key to moving forward through the rest of this chapter, and most of the rest of
the book as well. Throughout the remaining examples, I’ll make use of binding to get
data into elements on the UI.
 So far, you’ve looked at the general concept of binding. I discussed this concept in
the limited scope of binding to an individual property on an existing object. This
approach is useful, but to understand and harness the power of data binding, you
must build a better understanding of the different types of binding sources.
16.2
Understanding your binding source
You’ve seen that binding has two sides: a source and a target. The target is typically
(but not necessarily) a UI element in the XAML for your page. The source is anything
that can provide a value to the binding system.
 If that seems to you a little too simple to be complete, you’re right. Although Sil-
verlight can use most anything as a read-only one-time binding source, it works much
better, and you open up new options, if the source provides additional information to
the binding system, such as notifications when the value has been updated. In UI ele-
ments such as the TextBox, this is handled by making the source a dependency prop-
erty. In non-UI objects (or anything that doesn’t derive from DependencyObject),
there’s a little more work to be done to notify of property changes.
 In this section, I’ll discuss what it takes to bind to a property of a CLR object. I’ll
expand upon the previous section and explain what it takes to bind to individual
properties as well as how to bind to entire CLR objects. As a part of that, I’ll investigate
the INotifyPropertyChanged interface, a necessary part of making your classes bind-
ing-friendly and supporting change notification.
Figure 16.4
A conceptual view of TwoWay binding to a data source. The target control reflects 
changes to the source, and the source is updated with any changes made in the target.

374
CHAPTER 16
Binding
 I’ll cover how to bind UI elements to each other and even how to bind a UI ele-
ment to itself. If you’ve ever wanted to display the number of characters typed in a
TextBox, without writing any code other than a simple binding statement in XAML,
you’ll love this part of the section. Finally, I’ll talk about binding to keyed and indexed
elements in a collection as well as binding list or ItemsControl-based elements to
entire collections of objects using the ObservableCollection<T> class. 
16.2.1 Binding to a property
Silverlight gives you the flexibility to bind to any CLR property you want. You saw this
with the examples using the TimeOfDay property in section 16.1. If you ran the appli-
cation, you saw that, once the time was displayed, it just sat there. It didn’t automati-
cally update with each passing second because, by default, CLR properties don’t
broadcast their value changes—that and because the TimeOfDay property doesn’t
automatically continue ticking. To update the target with a change in the CLR prop-
erty, you must create a change-notification handler.
 A change-notification handler notifies a binding target that a change has been
made. This enables a target to automatically respond to changes. Dependency proper-
ties already have this feature built in, but CLR properties don’t. If you want your CLR
properties to broadcast their changes, you must implement the INotifyProperty-
Changed interface, which is demonstrated in listing 16.1.
public class Emoticon : INotifyPropertyChanged   
{
  public event PropertyChangedEventHandler PropertyChanged; 
  private string _name;
  public string Name
  {
    get { return _name; }
    set 
    { 
      _name = value; 
      NotifyPropertyChanged("Name"); 
    } 
  }
  private ImageSource _icon = null;
  public ImageSource Icon
  {
    get { return _icon; }
    set
    {
      _icon = value;
      NotifyPropertyChanged("Icon");
    }
  }
  public Emoticon(string name, string imageUrl)
  {
    _name = name;
Listing 16.1
Implementing the INotifyPropertyChanged interface
INotifyPropertyChanged
interface
PropertyChanged
event

375
Understanding your binding source
    _icon = new BitmapImage(
           new Uri(imageUrl, UriKind.RelativeOrAbsolute));
  }
  public void NotifyPropertyChanged(string propertyName) 
  {
    if (PropertyChanged != null)
    { 
      PropertyChanged(this, 
         new PropertyChangedEventArgs(propertyName));     
    }
  }
}
This is how to implement the System.ComponentModel namespace’s INotify-
PropertyChanged interface on a class. This class represents an emoticon (such as a
smiley face) that uses the INotifyPropertyChanged interface as a guide for broadcast-
ing changes in property values. The interface can be used to ensure that your UI com-
ponent and desired CLR property are in sync during OneWay and TwoWay binding. This
synchronization effort will take effect as long as you’ve implemented the Property-
Changed event.
 The PropertyChanged event is what keeps things in sync, so you must make sure
this event is triggered whenever a property value has changed. You can accomplish
this by firing the event in a property’s setter. Alternatively, if you plan on keeping mul-
tiple properties in sync, you may want to refactor the PropertyChanged event to a
common method—as shown in listing 16.1. 
 In my own applications, I typically take this a step further and implement an
abstract base class named Observable.
public abstract class Observable : INotifyPropertyChanged
{
  public event PropertyChangedEventHandler PropertyChanged;
  protected void NotifyPropertyChanged(string propertyName)
  {
    if (PropertyChanged != null)
      PropertyChanged(this, 
          new PropertyChangedEventArgs(propertyName));
  }
}
In the case of our emoticon example, you’d use the Observable class shown in listing
16.2 by simply changing the declaration to inherit from it:
public class Emoticon : Observable
Refactoring into a class like this makes it easier to use INotifyPropertyChanged
throughout your code. Of course, because this is a class, it can’t be used in cases where
you already need to inherit from another base class. In those instances, you’ll revert to
using the interface. 
Listing 16.2
Refactoring the INotifyPropertyChanged code into Observable
Notification

376
CHAPTER 16
Binding
 Many MVVM and other utility toolkits have their own implementation of this class,
often using reflection approaches to avoid requiring the string name of the property
to be used in code. Those classes have enough code to justify pulling out into a sepa-
rate base class or even a helper class.
 Regardless of your approach, the binding system’s PropertyChanged event handler
uses reflection to examine the value of a property and pass it on to the binding target.
This is why the PropertyChangedEventArgs type takes a string parameter that repre-
sents the name of the CLR property that changed.
 Binding to a CLR property is a powerful way to work with your objects. These
objects generally represent real-world entities that may also need to be bound to. For-
tunately, Silverlight also provides an elegant way to bind to a CLR object.  
16.2.2 Binding to an object
Up to this point, I’ve primarily focused on binding individual properties to UI compo-
nents. This technique is simple, but it can also be somewhat tedious if you need to
bind multiple properties of an object to a UI. You can make this task less tiresome by
using the DataContext property.
The DataContext property allows you to share a data source throughout a Dependen-
cyObject. This data source can be used by all the child elements of a DependencyOb-
ject that define a Binding. Binding uses the most immediate ancestor’s DataContext
unless another data source is set to it. If another data source is set, that source is used
for the Binding. Either way, by relying on the DataContext of an ancestor, you can eas-
ily bind several properties of an object to a UI. This approach is shown next. 
XAML:
<UserControl x:Class="BindingExample.MainPage"         
  xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"     
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
  <Grid x:Name="LayoutRoot" Background="White">     
    <Grid.RowDefinitions>
      <RowDefinition Height="Auto" />
Emoticons in your project
Each emoticon example in this chapter and the subsequent chapters requires you to
have a Silverlight application with an Icons folder. The Icons folder must contain seven
graphics files: Angry.png, Happy.png, Sad.png, Sick.png, Straight.png, Surprised.png,
and Hipster.png, each set with a build action of “resource” (resource is the default if
you drag the images into your project, but double-check). The graphics are part of the
downloadable source for this book. You can also find copies of the graphics files at
http://10rem.net/pub/emo/<filename> (such as http://10rem.net/pub/emo/
happy.png). You can also find them all in a single zip file, emo.zip, at the same URL.
Listing 16.3
Binding an Emoticon object to a Grid
LayoutRoot

377
Understanding your binding source
      <RowDefinition Height="Auto" />
    </Grid.RowDefinitions>
    <Grid.ColumnDefinitions>
      <ColumnDefinition />
      <ColumnDefinition />
    </Grid.ColumnDefinitions>
    <TextBlock Text="Name:" />
    <TextBlock Text="Image:" Grid.Column="1" />
    <TextBox Text="{Binding Name, Mode=TwoWay}" Grid.Row="1" />       
    <Image Source="{Binding Icon}" 
           Stretch="None"
           Grid.Row="1" Grid.Column="1" />     
  </Grid>
</UserControl>
C#:
var emoticon = new Emoticon("Smiley Face", "icons/happy.png");
LayoutRoot.DataContext = emoticon;             
Listing 16.3 shows how an object can be bound to elements within a Dependency-
Object. The TextBox and Image elements in this example show their intent to bind to
two different properties of an object. These elements don’t have their DataContext
property set in the code-behind, so the elements look to their immediate parent,
myGrid, and try to use its DataContext. This DataContext has been set in the code-
behind. The object assigned to the DataContext serves as the data source for the Grid
and its children. If the DataContext of the Grid hadn’t been set, the elements
would’ve continued up the tree and checked the UserControl element’s Data-
Context. If that DataContext were set, it would’ve been used. Either way, this example
shows how much more succinct and maintainable the DataContext approach can be.
Setting the DataContext in XAML
In the previous section, I mentioned that you can set the data context using a static
resource, all from within XAML. Though the DateTime example didn’t fit that model,
the Emoticon example can. 
Recall from chapter 2 that XAML is, in essence, a way to represent and initialize CLR
objects in markup. To support binding this way, you’ll add in a resources section (cov-
ered in chapter 14), which holds a reference to a single Emoticon object in the local
namespace:
<UserControl x:Class="BindingExample.MainPage"         
  xmlns="http://schemas.microsoft.com/winfx/2006/xaml
  ➥ /presentation"     
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
  xmlns:local="clr-namespace:BindingExample">
  <UserControl.Resources>
    <local:Emoticon x:Key="emoticon"
       Name="SmileyFace" 
       Icon="icons/happy.png"/>
  </UserControl.Resources>
Binding 
statements
LayoutRoot’s 
DataContext

378
CHAPTER 16
Binding
When the DataContext changes, the control will raise the DataContextChanged event.
This is a useful event to handle if you wish to synchronize other changes to changes in
the data context, especially if you’re a framework or toolkit author.
 So far, this chapter’s examples have fallen squarely in the zone I tend to think of as
traditional data binding. But Silverlight also supports the ability to bind controls to
each other simply as a way to reduce plumbing code. 
16.2.3 Binding to a UI element
Binding one or more properties of a UI element to the values on an entity, view
model, or business object is a compelling use of binding. Sometimes, though, you
want to use binding for things you wouldn’t traditionally consider “data”—things
within the UI. You may want to bind the height of two controls together so that they
resize equally, or perhaps you want to bind three sliders to the x-, y-, and z-axes rota-
tions of a plane (see section 7.5 for more information on 3D rotation in Silverlight).
Rather than binding to gather input or display data to the user, you’re binding to
avoid writing extra plumbing code.
 Let’s say that you want to display a count of
characters entered into a TextBox in real
time, something like figure 16.5.
 You could do that in code, but that’d be
fairly uninteresting code to write. It would
need to refer to XAML elements by name or
have event handlers wired in XAML, introduc-
ing a dependency on the specific page’s code-
(continued)
The Emoticon in the resources section is initialized directly on the page when the
rest of the elements are constructed. But as written, the Emoticon class requires
parameters in its constructor, something that isn’t supported in the .NET 4 version
of XAML used by Silverlight 4. This is remedied by adding a default (parameterless)
constructor to the class:
public Emoticon() {}
Finally, you set up the relationship via the DataContext using the StaticResource
markup extension and referring to the x:Key of the resource that corresponds to your
emoticon:
<Grid x:Name="LayoutRoot" 
      DataContext="{StaticResource emoticon}" …
The end result is a binding relationship set entirely from within XAML in a tool-friendly
and designer-friendly way. You’ll see more examples of this when I discuss WCF RIA
Services in appendix D of the ebook and some of the optional XAML data source con-
trols it provides.
Figure 16.5
Using element binding to 
count characters as you type into a 
TextBox

379
Understanding your binding source
behind and making it less portable and potentially more brittle. In addition, you’d
find yourself doing it enough that you’d either wrap the TextBox in your own
CountingCharsTextBox control or add a helper buddy class or something.
 Or if you prefer a XAML approach, which I hope I’ve sold you on by now, you’d use
the element binding introduced in Silverlight 3. Element binding allows you to bind the
properties of one FrameworkElement to another. The usual restrictions apply (the tar-
get must be a DependencyProperty; the source must notify of changes), so you can’t
use element binding quite everywhere.
 To produce the TextBox shown in figure 16.5 with the automatic count of characters
using element binding, the markup is pretty straightforward and entirely self-contained.
<StackPanel Orientation="Vertical" Margin="50">
  <TextBlock Text="Tweet (max 140 characters)" />
  <TextBox x:Name="tweetText"
           MaxLength="140"
           Text="Right now I'm writing a book" />
  <StackPanel Orientation="Horizontal">
    <TextBlock Text="{Binding Text.Length, ElementName=tweetText}" />    
    <TextBlock Text="/" />
    <TextBlock Text="{Binding MaxLength, ElementName=tweetText}" />
  </StackPanel>   
</StackPanel>
The XAML in listing 16.4 will show a TextBox with a count of characters underneath it.
The character count will update in real time to show the number of characters typed
into the TextBox. Note also that the MaxLength displayed under the text box is actu-
ally coming from the TextBox itself (the 140 in the label isn’t). The key item that
makes this happen is the ElementName parameter in the binding expression. Element-
Name is, as it suggests, the name of another element on the XAML page.
 Sometimes, you’ll want to bind two elements together, as you’ve done here. Other
times, you may want to bind an element to a value on itself using something called rel-
ative source binding.
USING A RELATIVE SOURCE
WPF supports a number of types of relative source bindings. In Silverlight, it’s used for
two things: binding an element to itself or to an ancestor in the visual tree. Let’s
assume that we have a simple property in our user control’s code-behind. It could
(and should) be a DependencyProperty but, to keep it short, you’re going to declare a
good old CLR property and assume it’s set only in the constructor. You can then refer
to that property in XAML but, without somehow telling the binding system that the
source of the data is the control hosting the XAML, you’d be stuck.
WARNING
Here be dragons. RelativeSource Self binding can not only
encourage bad application practices, such as binding to things defined in
code-behind instead of following a pattern such as ViewModel, but can also
be hard to debug, especially when you get into changes to DataContext set by
Listing 16.4
Element binding

380
CHAPTER 16
Binding
external consumers of your user control. Use RelativeSource Self binding,
but understand that your debugging workload will probably go up for the
choice. Don’t use RelativeSource Self binding just to avoid creating an
appropriate container or abstraction for your data.
This is where RelativeSource Self binding comes in. RelativeSource can be set
anyplace you’d normally have a binding statement, including the DataContext. List-
ing 16.5 shows how to bind a TextBlock in the UI to a simple CLR property in the
code-behind.
C# code-behind:
private string _pageTitle = "Silverlight 5 in Action";
public string PageTitle
{
  get { return _pageTitle; }
  set { _pageTitle = value; }
}
XAML:
<UserControl x:Class="RelativeSourceExample.MainPage"
  xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" 
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    
  mc:Ignorable="d" 
  d:DesignHeight="300" 
  d:DesignWidth="400"       
  DataContext="{Binding RelativeSource={RelativeSource Self}}"> 
  <Grid x:Name="LayoutRoot" Background="White">
    <TextBlock Text="{Binding PageTitle}" />     
  </Grid>
</UserControl>
RelativeSource Self binding is useful for those occasions when you need to bind to
a property of the control or need to bind a property of a control to itself. Use it spar-
ingly and not as a part of the overall application architecture and you’ll find it helps
enable those few scenarios where other solutions are just too cumbersome.
RelativeSource Ancestor binding is specified similarly to RelativeSource Self,
except that you specify a level and a type. Doing so requires deep knowledge of the
visual tree, or some assumptions about who else might be further up the tree.
Although this can be a useful escape hatch in many instances, I don’t recommend that
new developers use it. 
 When specifying RelativeSource binding to an ancestor, supply the Ancestor-
Level, which is a value from 1 (closest to this object) to n levels up. Also supply the
AncestorType. An example of both is shown in this XAML fragment:
Width="{Binding Width, RelativeSource=
          {RelativeSource AncestorType=Button, AncestorLevel=2}}"
Listing 16.5
Binding elements in XAML to properties in the code-behind
RelativeSource
Self
Binding to 
property

381
Understanding your binding source
Useful indeed, but it can be difficult to trace and debug in your own code. Use with
knowledge and use with caution.
 Another quiet addition to Silverlight binding is the ability to bind to a specific ele-
ment in an array or list.  
16.2.4 Binding to an indexed element
Silverlight has the ability to bind to a numerically indexed element in a collection.
This can be useful in instances where you may have an indexed property bag hanging
off a class or you want to get just a specific element out of a larger collection without
prefiltering it in code.
 Assume that you have a class Repository that exposes a collection of Emoticon
objects through a property named Emoticons. You can set up a static resource for
pure XAML binding or set the DataContext from the page or within the code-behind,
as shown in the previous examples. Once that’s set up, you’ll be able to refer to indi-
vidual elements in the collection using the index syntax within the binding statement.
C#:
public class Repository
{
  public Repository()
  {
    _emoticons = new ObservableCollection<Emoticon>();
    Load();
  }
  private void Load()
  {
    _emoticons.Add(new Emoticon("Smiley Face", "icons/happy.png"));
    _emoticons.Add(new Emoticon("Straight Face", "icons/straight.png"));
    _emoticons.Add(new Emoticon("Angry Face", "icons/angry.png"));
    _emoticons.Add(new Emoticon("Sick", "icons/sick.png"));
    _emoticons.Add(new Emoticon("Surprised", "icons/surprised.png"));
    _emoticons.Add(new Emoticon("Hipster", "icons/hipster.png"));
  }
  private ObservableCollection<Emoticon> _emoticons;
  public ObservableCollection<Emoticon> Emoticons  
  {
    get { return _emoticons; }
  }
}
XAML:
<UserControl.Resources>
  <local:Repository x:Key="repository" />
</UserControl.Resources>
<Grid x:Name="LayoutRoot"
      DataContext="{StaticResource repository}">
  <StackPanel Width="100"
              HorizontalAlignment="Center"
              VerticalAlignment="Center">
Listing 16.6
Binding to a specific element in a collection, using a numeric index
Collection 
to bind to

382
CHAPTER 16
Binding
    <Image Source="{Binding Emoticons[2].Icon}"    
           Stretch="None" />
    <TextBlock Text="{Binding Emoticons[2].Name}" />  
  </StackPanel>
</Grid>
In listing 16.6, the TextBlock will resolve its text property to be the value in
repository.Emoticons[2].Name (“Angry Face”) and display that on the screen. Simi-
larly, the image will, at runtime, show the icon. The syntax is consistent with C# index-
ing conventions.
 Binding to a single element in a collection using a numeric index in a binding
expression is useful, but often you want to bind using a string key instead.
16.2.5 Binding to a keyed (string indexed) element
Property bags and datasets are commonplace in the desktop application world. Silver-
light 4 introduced the ability to bind to these types of structures by introducing keyed
or string-indexed binding expressions.
 Listing 16.7 shows the same example as listing 16.5 but now the collection is being
accessed via a string key.
C#:
public class Repository
{
  public Repository()
  {
    _emoticons = new Dictionary<string, Emoticon>();
    Load();
  }
  private void Load()
  {
    emoticons.Add("Smiley",        
            new Emoticon("Smiley Face", "icons/happy.png"));
   _emoticons.Add("Straight", 
            new Emoticon("Straight Face", "icons/straight.png"));
 _  emoticons.Add("Angry", 
            new Emoticon("Angry Face", "icons/angry.png"));
   _emoticons.Add("Sick", 
            new Emoticon("Sick", "icons/sick.png"));
   _emoticons.Add("Surprised", 
            new Emoticon("Surprised", "icons/surprised.png"));
 _  emoticons.Add("Hipster", 
            new Emoticon("Hipster", "icons/hipster.png"));
}
    private Dictionary<string, Emoticon> _emoticons;
    public Dictionary<string, Emoticon> Emoticons  
    {
      get { return _emoticons; }
    }
  }
Listing 16.7
Binding to a specific element in a collection, using a  key
Indexed 
binding
Item with
“Smiley” key
Dictionary 
to bind to

383
Understanding your binding source
XAML:
<UserControl.Resources>
  <local:Repository x:Key="repository" />
</UserControl.Resources>
<Grid x:Name="LayoutRoot"
      DataContext="{StaticResource repository}">
  <StackPanel Width="100" 
              HorizontalAlignment="Center"
              VerticalAlignment="Center">
    <Image Source="{Binding Emoticons[Smiley].Icon}"    
           Stretch="None" />
    <TextBlock Text="{Binding Emoticons[Smiley].Name}" /> 
  </StackPanel>
</Grid>
Listing 16.7 works assuming your Emoticons dictionary has an element with the key
Smiley. This feature enables a ton of must-have scenarios in Silverlight, specifically
around binding to the data of a shape unknown at design time. As in the previous list-
ing, both the name and icon will display at runtime. 
 Binding to a single element in a collection using a numeric index or string key in a
binding expression is useful, but it’s more common to bind to an entire collection
rather than a single element within that collection. That’s the situation you’ll run into
when you want to populate a ListBox or other ItemsControl.
16.2.6 Binding to an entire collection
Binding to a collection is an important task in a lot of applications. There are numer-
ous times when you need to show a list of the items in a collection. You may want to
display a collection of emoticons, or you may want to show a list of the days of the
week. Either way, these lists are made up of individual items, so it’s only natural to use
a control derived from ItemsControl.
 An ItemsControl is a basic control used to show a collection of items. I discussed
this control in chapter 12, but I didn’t talk about the process of binding data to the
control. Instead, you saw the manual approach of adding items one by one to the
Items collection. Although this technique is useful in some situations, ItemsControl
provides a more elegant approach through the ItemsSource property.
Result:
Listing 16.8
Binding a collection of Emoticon objects to a ListBox
Keyed/string-
indexed binding

384
CHAPTER 16
Binding
XAML:
<Grid x:Name="LayoutRoot" Margin="10">
    <ListBox x:Name="myListBox" Height="150" />
</Grid>
C#:
public MainPage()
{
  InitializeComponent();
  Loaded += new RoutedEventHandler(MainPage_Loaded);
}
void MainPage_Loaded(object sender, RoutedEventArgs e)
{
  List<Emoticon> emoticons = GetEmoticons();
  myListBox.ItemsSource = emoticons;    
}
private List<Emoticon> GetEmoticons()
{
  List<Emoticon> emoticons = new List<Emoticon>(); 
  emoticons.Add(new Emoticon("Smiley Face", "icons/happy.png"));
  emoticons.Add(new Emoticon("Straight Face", "icons/straight.png"));
  emoticons.Add(new Emoticon("Angry Face", "icons/angry.png"));
  emoticons.Add(new Emoticon("Sick", "icons/sick.png"));
  emoticons.Add(new Emoticon("Surprised", "icons/surprised.png"));
  emoticons.Add(new Emoticon("Hipster", "icons/hipster.png"));
  return emoticons;
}   
Listing 16.8 shows how to bind a collection of objects to an ItemsControl—in this
case, a ListBox control (which derives from ItemsControl). Using the ItemsSource
property, this ListBox loads a collection of Emoticon objects from the earlier exam-
ples using the GetEmoticons function.
 The ItemsSource property is used solely for the sake of data binding. This prop-
erty can be used to bind to any collection that implements IEnumerable. This prop-
erty is necessary because the Items collection of the ItemsControl class isn’t a
DependencyProperty, and only DependencyProperty-typed members have support for
data binding.
 The ItemsSource property can only be used if the Items collection of an Items-
Control is empty. If the Items collection isn’t empty, your application will throw an
InvalidOperationException when you try to set the ItemsSource property. If you
intend to use this property, you should also consider using the DisplayMemberPath
property.
 The DisplayMemberPath property determines which CLR property value to use for
the text of a list item. By default, each list item will use the ToString method of the
object it’s bound to for the display text—the reason each of the items in listing 16.6 is
shown as MyLibrary.Emoticon. You can override the ToString method to fully
ItemsSource 
binding target
Binding 
source

385
Understanding your binding source
customize the text shown for an item. If you want to go a step further, you can custom-
ize the entire look of an item using the data template information discussed in section
16.3.2. But for the quickest approach, you can use the DisplayMemberPath as shown
in listing 16.9.
Result:
XAML:
<Grid x:Name="LayoutRoot" Margin="10">
  <ListBox x:Name="myListBox"
           DisplayMemberPath="Name"
           Height="150" />
</Grid>
C#:
(same as previous listing)
This shows the impact of the DisplayMemberPath property on binding items. As you
can see, this property makes the items in a list much more meaningful. This approach
allows you to easily display information from a CLR property, an object, or a collection.
The DisplayMemberPath approach is limited and is rarely used in real applications.
Data templates are a much better way to display items in a ListBox. I’ll look at those
shortly.
16.2.7 Deciding when to update binding
Imagine for a moment that the user is typing his full name into a TextBox on a form.
Depending on what you wish to do with the input, you may want to get an update for
every character typed, or only when he leaves the field (when the field loses focus). If
you’re implementing an incremental search or similar function, updating on every
character makes sense. If you’re simply storing the data in a database, and perhaps
doing some validation on it first, you only care about the final value entered in the
field. In that case, getting an update on every character could result in a flurry of data-
base hits, performance issues, validation errors, and more.
 Silverlight provides the UpdateSourceTrigger binding property to help control
when the source is updated. The three possible values for this property are shown in
table 16.1.
Listing 16.9
Using the DisplayMemberPath to improve the display of a list of items

386
CHAPTER 16
Binding
In most cases, you won’t need to change from the default UpdateSourceTrigger. Like
all binding properties, you may set this in code, but it’s more common to set it in
markup. For example:
<TextBlock Text="{Binding LastName, Mode=TwoWay, 
                  ➥ UpdateSourceTrigger=PropertyChanged}" />
The approaches I’ve talked about so far work well when you need to bind a single value
to a single property without modifying the display format of the values in any way. I cov-
ered how to bind to simple values, how to get individual values by index or key, and how
to set the display member when it’s different from the data member. I also looked at
how to tweak the event that causes the actual update on the binding source.
 One thing all of the examples have had in common is that they bind to properties
that are known at runtime. They’re concrete properties statically defined on concrete
types. There are times, however, when binding to a dynamic property is more
appropriate. 
16.3
Binding to dynamic properties
The majority of the time, the objects you work with in Silverlight will have their prop-
erties defined at compile time. For example, a customer may have a last name, first
name, address, and more. These properties are all known at compile time, and they’re
easy for the binding system to resolve using .NET reflection and property metadata.
 Sometimes, however, you run into cases where you need to define the properties at
runtime. Perhaps you have a data-driven system where some or all of the properties of
the customer are configured in the database, such as many CRM and sales systems. Or
perhaps you’re working with data returned in JSON format from a RESTful web ser-
vice, and you don’t know exactly what fields will be in the returned data.
 In these cases, you need Silverlight to bind to dynamic properties—properties
defined at runtime in code. Normally Silverlight can’t do this because it needs type
information to reflect on in order to enable the conversion in the binding system.
Without that type information, Silverlight can’t tell what conversion it needs to apply
to the data when reading it from or writing it back to the binding source.
 This leaves you with a problem. Silverlight needs type information, but System
.Reflection only provides type information for properties defined at compile type.
Table 16.1
Possible values for UpdateSourceTrigger
Value
Description
Default
The type of source update depends on the default settings for the property. For 
the TextBox.Text property, this means to update on lost focus. 
Explicit
Requires a code call to BindingExpression.UpdateSource before the 
value is committed to the source.
PropertyChanged
Update the source for each change to the property—for example, for each key-
stroke when the user is entering data into the Text property of a TextBox.

387
Binding to dynamic properties
What’s needed is a way to provide the same reflection metadata but based on runtime-
generated data.
 The surfacing of this runtime metadata is enabled by using the ICustomType-
Provider interface and a good bit of System.Reflection types. In this section, you’ll
explore the ICustomTypeProvider interface and learn how it can be used to create a
class with dynamic properties to which you can bind using the Silverlight binding sys-
tem. The scenario you’ll consider is a system with metadata-driven properties, perhaps
stored in a database, perhaps in a configuration file. You’ll mock the source so the
actual storage location isn’t particularly important. What’s important is understanding
how to generate properties using code at runtime and then provide to the binding sys-
tem the metadata for those properties.
16.3.1 ICustomTypeProvider overview
ICustomTypeProvider is an interface whose sole purpose in Silverlight is to enable
binding to a type whose properties may not be known until runtime. Silverlight’s data
binding engine checks for the presence of this interface in any binding source. If the
class implements it, Silverlight uses ICustomTypeProvider to get the type information
instead of simply reflecting on the System.Type for the class.
 The interface is simple, consisting of a single method:
public interface ICustomTypeProvider
{
  public Type GetCustomType();
}
If you can generate a type and return it from that method, then your work is done.
Unfortunately, as is so often the case, the devil’s in the details. Creating a complex
type at runtime involves a fair bit of System.Reflection code to return information
about properties, assemblies, types, and more.
 You can, of course, put all of the System.Reflection support code directly into
the dynamic class. Although that may be marginally easier to write in a book, it simply
isn’t how you’ll use this functionality in the real world. Due to the amount of reflec-
tion code you need to do this correctly, it’s best encapsulated in one or more helper
classes.
16.3.2 Creating the helper classes
A complete set of helper classes that supports everything you could need would entail
several continuous pages of code listings. I wouldn’t type that much code in from a
book, and neither should you. For that reason, I’ll concentrate here on the important
parts but include the full set of helper classes in the freely downloadable source code
available at www.manning.com/Silverlight5inAction. The source code printed in this
section isn’t the complete class or set of classes, and isn’t meant to be combined into
the same project with the previous examples in this chapter.
 Now is a good time to acknowledge my sources. Alexandra Rusina on the Silver-
light team has been a huge help when it comes to using ICustomTypeProvider. Her

388
CHAPTER 16
Binding
blog post at http://bit.ly/AlexandraICTP is more than a small inspiration for the
approach taken here; the original helper class is her work and is available at that URL
(and in the book’s downloadable source). This set of classes may end up as part of the
Silverlight toolkit, so it’s about as official as you can get from a sample.
 Because the ICustomTypeProvider approach relies on reflection, there’s a fair bit
of code to something as simple as implement a property. Luckily, the code is all reus-
able. There are three main classes in play. 
Of the three classes shown in table 16.2, only CustomTypeHelper has functionality that
merits discussion. The other two classes are nice wrappers around relatively simple
reflection methods.
CUSTOMTYPEHELPER CLASS OVERVIEW
The CustomTypeHelper class has a number of responsibilities. Its main ones are:
■
Store the definitions for the runtime-added properties
■
Store the values for the properties
■
Raise PropertyChanged event notifications when the properties change
Listing 16.10 shows a version of the helper class. I made the single modification of
using my own Observable base class rather than sticking with INotifyProper-
tyChanged. Otherwise, the class is identical to the one Alexandra had on her site at
the time of this writing.
public class CustomTypeHelper<T> : Observable, ICustomTypeProvider
{
  private static List<CustomPropertyInfoHelper> _customProperties = 
    new List<CustomPropertyInfoHelper>();
  private Dictionary<string, object> _customPropertyValues;
  private CustomType _ctype;
  public CustomTypeHelper()
  {
    _customPropertyValues = new Dictionary<string, object>();
    foreach (var property in this.GetCustomType().GetProperties())
    {
      _customPropertyValues.Add(property.Name, null);  
    }
  }
Table 16.2
The helper classes
Class
Description
CustomTypeHelper<T>
The main class you’ll use for implementing your own custom type
CustomType
A private class used to represent the type 
CustomPropertyInfoHelper
Wrapper for the property-oriented reflection code
Listing 16.10
The helper class structure
Add existing 
properties

389
Binding to dynamic properties
  public static void AddProperty(string name)     
  public static void AddProperty(
                     string name, Type propertyType) 
  public static void AddProperty(
                     string name, Type propertyType,
                        List<Attribute> attributes)
  private static bool CheckIfNameExists(string name)
  public void SetPropertyValue(
                     string propertyName, object value)   
  public object GetPropertyValue(
                     string propertyName)
  private bool ValidateValueType(object value, Type type)
  public PropertyInfo[] GetProperties()
  public Type GetCustomType()
  private class CustomType : Type
  { ... }
  private class CustomPropertyInfoHelper : PropertyInfo
  { ... }
}
I removed almost all the code from this class before creating the listing. I left the
property signatures in place for the main class and the class definitions for the private
classes.
 Of all the methods included in the helper class, the AddProperty, SetProper-
tyValue, and GetPropertyValue methods are the most interesting and most impor-
tant. Listing 16.11 shows each of them. Note that AddProperty has several overloads—
I show only one of them here.
public static void AddProperty(string name)
{
  if (!CheckIfNameExists(name))            
  _customProperties.Add(
     new CustomPropertyInfoHelper(name, typeof(String)));
}
public void SetPropertyValue(string propertyName, object value)
{
  CustomPropertyInfoHelper propertyInfo = 
   (from prop in _customProperties 
   where prop.Name == propertyName
   select prop).FirstOrDefault();
  if (!_customPropertyValues.ContainsKey(propertyName))
    throw new Exception("There is no property " + propertyName);
  if (ValidateValueType(value, propertyInfo._type))
  {
    if (_customPropertyValues[propertyName] != value)
Listing 16.11
AddProperty, SetPropertyValue, and GetPropertyValue 
Add property
Set property 
value
Look up property 
name

390
CHAPTER 16
Binding
    {
      _customPropertyValues[propertyName] = value;
      NotifyPropertyChanged(propertyName);
    }
  }
  else 
    throw new Exception(
      "Value is of the wrong type or null for a non-nullable type.");
  }
public object GetPropertyValue(string propertyName)  
{
  if (_customPropertyValues.ContainsKey(propertyName))
    return _customPropertyValues[propertyName];
  else
    throw new Exception("There is no property " + propertyName);
}
The AddProperty method first checks to see if the class is tracking a property by that
name. If it isn’t, it adds the property. In this case, the type added will be a string—the
other overloads allow for specifying a type.
 Because the properties don’t exist at compile time, the SetPropertyValue is what
you use when setting the property value from within code. The syntax looks a little
cumbersome, but this class isn’t really optimized for code use; it’s for binding.
 The final method, GetPropertyValue, is what you can use from code to get the
current value of the property of the specified name.
 Keep in mind that listing 16.11 is truncated. The full listing for the helper class is
over 400 lines of C# code. Next I’ll show you how to use this class in your own code.
16.3.3 Using the helper class
Remember that ICustomTypeProvider helps you only with creating custom proper-
ties, not with defining types themselves. For that reason, to use the helper class, you’ll
need a type to begin with. That type (class) may have existing properties, or it may
simply be an empty shell.
 Let’s assume you’re going to work with a Customer type that contains only an ID
field, and then a bunch of dynamic fields that will be defined in the database—a
somewhat typical CRM scenario. Listing 16.12 shows the simple Customer class.
namespace CustomTypeDemo.Model
{
  public class Customer : CustomTypeHelper<Customer> 
  {
    private int _id;
    public int ID
    {
      get { return _id; }
      set
      {
Listing 16.12
The Customer class
Get property 
value
Inherit from 
CustomTypeHelper

391
Binding to dynamic properties
        _id = value;
        NotifyPropertyChanged("ID");
      }
    }
  }
}
With the helper class Alexandra created, you have two options for how you use it. The
first is to inherit from CustomTypeHelper as in listing 16.12. The second is to imple-
ment ICustomTypeProvider and forward or delegate the GetCustomType and other
methods to an internal CustomTypeHelper instance. The only advantage to delegation
is that it lets you preserve the current inheritance hierarchy in place in your Customer
class. That’s not a concern here, so you’ll use the easier inheritance method as shown
in listing 16.12.
 As mentioned, the custom properties of the Customer class are LastName and
FirstName. The ID property is a compile-time defined property. Let’s imagine that the
LastName and FirstName properties are stored as name-value pairs in a database. Typ-
ically then, those would be added to your model object somewhere in or near your data
layer. For simplicity, I’ve created a class named CustomerRepository that will simulate
the actions which would normally happen in that layer, specifically, the modification of
the Customer type and the loading of data. Listing 16.13 has the code for this class.
namespace CustomTypeDemo.Repository
{
  public class CustomerRepository
  {
    static CustomerRepository()            
    {
      Customer.AddProperty("LastName", typeof(string));
      Customer.AddProperty("FirstName", typeof(string));
    }
    private static ObservableCollection<Customer> _customers =
        new ObservableCollection<Customer>();
    public static ObservableCollection<Customer> Customers
    {
      get { return _customers; }
    }
    public static void LoadCustomers()      
    {
      Customer cust1 = new Customer();
      cust1.ID = 1;
      cust1.SetPropertyValue("LastName", "Brown");
      cust1.SetPropertyValue("FirstName", "Pete");
      Customers.Add(cust1);
      Customer cust2 = new Customer();
      cust2.ID = 2;
Listing 16.13
The CustomerRepository class
Static constructor
Load mock data

392
CHAPTER 16
Binding
      cust2.SetPropertyValue("LastName", "Galloway");
      cust2.SetPropertyValue("FirstName", "Jon");
      Customers.Add(cust2);
        
    }
  }
}
The repository methods are static. In the static constructor, I initialize the Customer
type by adding the two new properties to the type. Both properties are strings.
 The class also exposes a Customers collection, which is filled by the LoadCustomers
method. I’ve used dummy data here, but you can substitute in your database code,
XML parsing, JSON parsing, or anything you’d like. For tips on parsing data, see chap-
ter 22.
 The next step is to create something to bind to. I like to put my binding sources in
a ViewModel class. I’ll keep it really basic—you won’t learn about the MVVM pattern
until chapter 33. Listing 16.14 shows the ViewModel class, which, in this case, passes
through calls to the repository. It may seem like extra work here, but trust me, you
want this later for anything more complex than a simple book demo.
namespace CustomTypeDemo.ViewModels
{
  public class CustomerListViewModel : Observable
  {
    public ObservableCollection<Customer> Customers
    {
      get { return CustomerRepository.Customers; }
    }
    public void LoadData()
    {
      CustomerRepository.LoadCustomers();    
    }
  }
}
The CustomerListViewModel is what the UI will bind to. In listing 16.15, you can see
that I bind to the Customers property of this class from the ItemsSource property of
the CustomerList ListBox.
<UserControl x:Class="CustomTypeDemo.MainPage"
  xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
  xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
  xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
  mc:Ignorable="d"
  d:DesignHeight="300" d:DesignWidth="400">
Listing 16.14
The CustomerListViewModel class
Listing 16.15
The MainPage.xaml user interface
Repository
method

393
Binding to dynamic properties
  <Grid x:Name="LayoutRoot" Background="White">
    <Grid.RowDefinitions>
      <RowDefinition Height="*" />
      <RowDefinition Height="Auto" />
    </Grid.RowDefinitions>
    <ListBox x:Name="CustomerList"                
             Grid.Row="0" Margin="15"
             ItemsSource="{Binding Customers}">
      <ListBox.ItemTemplate>
        <DataTemplate>
          <Grid>
            <Grid.ColumnDefinitions>
              <ColumnDefinition Width="25" />
              <ColumnDefinition Width="75" />
              <ColumnDefinition Width="75" />
            </Grid.ColumnDefinitions>
         
            <TextBlock Text="{Binding ID}" Grid.Column="0" />
            <TextBlock Text="{Binding LastName}" Grid.Column="1" />
            <TextBlock Text="{Binding FirstName}" Grid.Column="2" />
          </Grid>
        </DataTemplate>
      </ListBox.ItemTemplate>
    </ListBox>
    <Button x:Name="LoadData"                     
            Grid.Row="1" Height="25" Width="80"
            Margin="10" Content="Load Data"
            Click="LoadData_Click" />
  </Grid>
</UserControl>
The UI markup defines a ListBox and a single button. The ListBox contains a
DataTemplate to format the data in the ListBox. I’ll cover data templates near the end
of this chapter. The key thing to note in the markup is I’m binding to the LastName and
FirstName properties just like I would any other property, despite the fact that they
won’t be defined until the repository constructor creates them at runtime. Neat!
 The Button will be used to call the LoadData ViewModel method to populate the
ListBox with available customers. Listing 16.16 shows the button handler code, as well
as the rest of the code-behind.
namespace CustomTypeDemo
{
  public partial class MainPage : UserControl
  {
    private CustomerListViewModel _vm;
    public MainPage()
    {
      InitializeComponent();
Listing 16.16
The MainPage.xaml.cs code-behind
CustomerList 
ListBox
LoadData button

394
CHAPTER 16
Binding
      _vm = new CustomerListViewModel();
      DataContext = _vm;                
    }
    private void LoadData_Click(object sender, RoutedEventArgs e)
    {
      _vm.LoadData();                  
    }
  }
}
The code-behind instantiates the ViewModel and sets it as the data context for the
page. As you learned earlier, this means that all binding statements will be relative to
that data context. So, when you bind the ItemsSource property of the ListBox to
“Customers,” it is like saying _vm.Customers.
 Run the application and click the Load Data button. You should see a screen that
looks like figure 16.6.
 As you saw in this section, once you understand the interface and the helper class,
using runtime-defined properties is easy. It takes only a single line of code to define a
property and a single line of code to set its value. Beyond that, the binding statements
for both accessing and updating the value look like they would for any normal stati-
cally defined property in a class.
ICustomTypeProvider opens new doors for Silverlight applications. No longer do
you need to decide between having highly customizable objects and using the built-in
binding system.
 In the next two sections, you’ll learn more about the binding system and how to
customize the display of single values and aggregate several values up into a single
data template to be repeated for each entry in a collection.  
Set DataContext
Load data
Figure 16.6
The application 
showing two Customer objects 
loaded into the ListBox. In 
both cases, the LastName and 
FirstName properties were 
defined at runtime using 
ICustomTypeProvider.

395
Customizing the display
16.4
Customizing the display
As you saw in section 16.2, data binding is a powerful way to show data. Occasionally,
this information may be stored in a format not suitable to display in a UI. Imagine ask-
ing your user, “Does two plus two equal four?” This question clearly demands a yes or
no response. The problem begins to arise when the response is saved to a more persis-
tent data source.
 Many times, a piece of data such as a property will be saved one way but needs to
be presented in another. In the case of a yes-or-no question, the answer may be stored
in a bool CLR property. This property may run under the assumption that “yes” is
equivalent to true and “no” is the same as false. This assumption can become a prob-
lem if you need to bind to that data because, by default, data binding calls a type’s
ToString method. Your users could see a statement that looks like “Does two plus two
equal four? True.” when, in reality, it’d be better to show “Does two plus two equal
four? Yes.” This small but common problem demands a better approach.
 If Silverlight couldn’t handle the simple task of formatting values for display, bind-
ing wouldn’t be particularly useful. Luckily, Silverlight has everything you need to for-
mat display values, convert both inbound and outbound values, provide special
handling for null values, and even provide fallbacks for cases when binding fails. In
this section, you’ll see how to customize the visual representation of your data using
these powerful features.
16.4.1 Formatting values
When writing code, you can format values using the string.Format function. But
until Silverlight 4, there was no good way to do the equivalent during a binding opera-
tion. You could write a custom value converter, but that gets old quickly and becomes
another testing and maintenance point.
 Silverlight 4 introduced the ability to use string formatting when binding. The syn-
tax is essentially the same as the string.Format function. For example, this will set
the value of the TextBlock to “DOB: May 18, 2007” assuming the DateOfBirth prop-
erty on your binding source contains the value 5/18/2007:
<TextBlock Text="{Binding DateOfBirth, StringFormat=DOB:\{0:D\}}" />
Similarly, this binding expression will set the value of the TextBlock to be $1,024.10
assuming the decimal BilledAmount field contains the value 1024.10m:
<TextBlock Text="{Binding BilledAmount, StringFormat=\{0:C\}}" />
Sometimes, simply formatting the value isn’t enough. In those cases, you may need to
perform a real data conversion and write your own custom value converter.
16.4.2 Converting values during binding
Silverlight allows you to dynamically convert values during data binding. You can
accomplish this by first creating a custom class that implements a value converter. This
value converter can then be referenced directly in XAML. I recommend this approach

396
CHAPTER 16
Binding
instead of custom setter/getter code because it helps keep the design separate from
the code. Let’s begin by discussing how to create a value converter.
CREATING A VALUE CONVERTER
To create a value converter, you must create a class that implements the IValue-
Converter interface, which enables you to create custom logic that transforms a value.
This transformation may take place in one of two methods depending on the flow of
your data. The first method, Convert, is used when the data is moving from the source
to the target—for example, from your object to a TextBox. If the data is flowing from
the target back to the source, such as when the value entered in a TextBox goes back
to your object, a method called ConvertBack is used. Both methods are members of
the IValueConverter interface. 
public class YesNoValueConverter : IValueConverter
{
  public object Convert(object value, Type targetType,  
    object parameter, System.Globalization.CultureInfo culture)
  {  
    bool isYes = bool.Parse(value.ToString());
    if (isYes)
      return "Yes";
    else
      return "No";
  }
public object ConvertBack(object value, Type targetType,  
    object parameter, System.Globalization.CultureInfo culture)  
  { 
    string boolText = value.ToString().ToLower();                         
    if (boolText == "yes") 
      return true;
    else if (boolText == "no")
      return false;  
    else 
      throw new InvalidOperationException("Please enter 'yes' or 'no'.");
  }
}
Listing 16.17 shows a value converter that converts between a bool and "Yes" or "No".
Value converters use the Convert method to convert from (in this case) the UI to the
CLR object. It’s this method that converts a bool to "Yes" or "No". When the UI (or
any other binding target) is passing data back to its source (TwoWay binding), the
ConvertBack method is used. This method converts Yes to true and No to false.
These methods control the conversion process. To assist in this process, both these
methods give you the opportunity to provide custom information.
 Both the Convert and ConvertBack methods allow you to use two optional pieces
of information. The first is an arbitrary object called parameter that can be used by
your conversion logic. By default, this object will be null, but you can set it to any
value that you find useful. The other piece of information specifies the CultureInfo
Listing 16.17
A value converter that converts a Boolean to "Yes" or "No" 
Convert function
 ConvertBack 
function

397
Customizing the display
object to use when converting the values. I’ll discuss both parameters in a moment.
But, to set the CultureInfo or pass along a custom parameter, you first must know
how to use a value converter from markup.
USING A VALUE CONVERTER
Using a value converter involves setting the Converter property of a Binding object.
This property determines which IValueConverter to use when transforming data. By
default, this property isn’t set to anything (null), but you can set it to reference an
IValueConverter you’ve created. Before you can reference an IValueConverter, you
must add it as a resource. You can reference an IValueConverter by first adding it to
the Resources collection, as shown next.
<UserControl x:Class="ValueConverterExample.MainPage"
  xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" 
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" 
  xmlns:local="clr-namespace:ValueConverterExample"
  Width="400" Height="300">
  <UserControl.Resources>
    <local:YesNoValueConverter x:Key="myConverter" />
  </UserControl.Resources>
  <Grid x:Name="LayoutRoot"
        Background="White">
    
    <TextBlock x:Name="myTextBlock"
     Text="{Binding IsCorrect, Converter={StaticResource myConverter}}" />
  </Grid>
</UserControl>
Listing 16.18 shows how to introduce a custom value converter to the XAML world.
The local prefix is assumed to be defined as a namespace (see chapter 2). The key
myConverter is used to reference the YesNoValueConverter in XAML. The following
is an example of referencing a value converter:
<TextBlock x:Name="myTextBlock" 
  Text="{Binding IsCorrect, Converter={StaticResource myConverter}}" />
This example shows a basic Binding that uses a custom converter which alters the dis-
played text of a bool property called IsCorrect. The example shows that the custom
converter is referenced through the Converter property. This property uses the curly-
brace markup extension syntax just like the Binding syntax because it’s the syntax
used to reference a resource. You can also pass a custom parameter or the culture
information if you need to.
TIP
A statement such as the binding statement shown in the previous exam-
ple can seem to be a jumble of curly braces. Think of each matched set of
braces as a separate statement, substituted in when parsed and evaluated. For
Listing 16.18
Referencing a value converter as a page resource

398
CHAPTER 16
Binding
example, the {StaticResource myConverter} statement is a complete Stat-
icResource markup extension statement itself, the result of which, after eval-
uation, is passed in to the Converter parameter of the Binding statement.
The Binding class exposes an object property called ConverterParameter, which can
be used to pass an arbitrary value to an IValueConverter. The value converter uses
the value of the ConverterParameter in the Convert and ConvertBack methods. By
default, this value is null, but you can use it to pass along any data you want, such as a
format string or an index. If you need to pass along culture-related data, I recommend
using the ConverterCulture property.
 The ConverterCulture property of the Binding class allows you to set the culture.
This culture is passed along as a CultureInfo object that can be used by the Convert
and ConvertBack methods. By default, the CultureInfo object reflects the value of
the Language attribute of the calling FrameworkElement. The Language attribute is
used for localization and globalization. This value uses a string that defaults to en-
US, which represents U.S. English.
Creating and using a value converter can be valuable when working with data, as
shown with our basic yes/no example. Value converters can be useful in even more
complex scenarios. For instance, Silverlight doesn’t have support for HTML tags in
regular text controls, so you may consider using a value converter to scrub the HTML
tags from a string before binding it to your UI. 
Value converter tricks
Value converters are powerful and allow you to extend binding to support scenarios
not natively supported in Silverlight or let you manipulate object data for objects that
may otherwise have schemas you can’t touch.
For example, a colleague created a value converter that has a field name as a param-
eter and then implements binding to a dictionary of fields, much like a DataSet. At
the time, Silverlight had no support for binding to indexed values or any support for
dynamic properties, so this was a huge time-saver and allowed our team to use existing
business objects (which included a dictionary of additional values) in case we couldn’t
alter the implementation of the existing objects.
Because MultiBinding (the ability to bind two fields to a single control) isn’t sup-
ported in Silverlight, in another instance we used a purpose-built value converter to
combine all the address fields in an object into a single string to be displayed in a
grid column. In that case, the binding source was the entire object and the value con-
verter looked for specific fields in that object. The ConvertBack method was left empty
in that case, because it supported only OneWay binding.
Though you don’t want value converters to be the solution to all your binding woes (in
many cases, an alternate design may serve you better), they’re powerful enough to
provide lots of options in situations where you may be otherwise tempted to write a
bunch of code in your code-behind.

399
Customizing the display
 Value converters were often used to format values for binding. We’ve already seen
a way to format strings for display. Let’s now look at how to handle fallback values and
null value display. 
16.4.3 Providing default fallback values
Things can go wrong during binding. The property path may be unable to be resolved
or an exception may be thrown when getting the value. Perhaps the index or key
doesn’t exist. In those cases, it can be helpful to have a fallback value defined in your
binding expression. These values are provided using the FallbackValue property.
 In this example, assuming you have an ApprovalCode field in your object but it
throws an exception in the getter (odd, I know) or is otherwise unavailable, the Text-
Block will display the value "Unavailable":
<TextBlock Text="{Binding ApprovalCode, FallbackValue=Unavailable}" />
In many cases, I think it’s preferable to have default values and fallbacks defined in
your model or view model, especially because that’ll make it easier to test. But fallback
values in binding can help in a pinch or in cases where you need to handle an excep-
tion condition happening between your view model and view.
 More common than fallback values is custom null value handling.
16.4.4 Handling null values
Similar to fallback values but more useful, in my opinion, is the TargetNullValue
property of the binding expression. TargetNullValue allows you to display a custom
value when the value you’ve bound to is null.
 In many applications, a value of null truly means something different than the
value of empty or zero. In the former, it means that no value has been entered. The
latter indicates that a value has been entered but it’s blank or zero. To make it easier
to work with, many applications disregard the null value and replace it with the
default value for the type. This makes it easier to display in the UI but at the cost of los-
ing the distinction.
 Starting with Silverlight 4, you can preserve the null value and still have a friendly
UI. Simply provide a TargetNullValue in your binding expression:
<TextBlock Text="{Binding ApprovalCode, TargetNullValue=(missing)}" />
In this example, when the ApprovalCode returns null, the TextBlock will display the
text "(missing)".
 These techniques all handle the formatting and display of a single bound value.
Though powerful on their own, often you’ll want to display something more complex,
perhaps containing multiple bound values in a list. That’s where a data template
comes into play. Happily, data templates build on everything you’ve learned so far, so
you’ll find their implementation easy to understand. 

400
CHAPTER 16
Binding
16.5
Creating explicit data templates
In section 16.2, you learned how to bind individual properties and entire collections. I
covered how to provide formatting and conversion for single-bound values in section
16.3. What about those cases when you need to have even more control over the pre-
sentation of your list-based data? What about something like a ListBox item that con-
tains three or four pieces of data in each row? That’s where data templates come in.
 A data template is a way to define how a piece of information will be shown. Imag-
ine looking at a message on Twitter.1 Although these messages can be easily viewed in
tabular format, it’s much more interesting to look at them in more of a card layout.
For an example, see table 16.3.
The table demonstrates the general idea of a data template: it gives your data a face.
The value in this approach is that it allows you to quickly change the way your data
looks without changing your code, the very reason to separate code from UI markup.
Styles change, and what looks great today will look dated in a year. Data templates
allow you to make this change easily, without affecting the underlying model. To take
advantage of this feature, you must create a DataTemplate object.
 A DataTemplate object describes the visual representation of a piece of informa-
tion. This object can be used with two types of controls within the Silverlight class
library. The first is a ContentControl. More interesting and probably more commonly
used is the ItemsControl. In this section, you’ll see how to create a data template with
each of these control types.
16.5.1 Using a DataTemplate with a ContentControl
A ContentControl is a type of control defined by a single piece of content, which I dis-
cussed in chapter 12. Every ContentControl exposes a property called Content-
Template, which specifies the DataTemplate to use when displaying the content of a
ContentControl. This content can be styled with a DataTemplate using an approach
similar to that shown next.
1 What? You’re not on Twitter? That’s okay. Twitter is a place where people who join are instantly more pro-
ductive, make three times the salary of non-tweeters (on average), keep their hair longer, are more fit, and
enjoy life more than people who don’t use Twitter. No big deal.
Table 16.3
One example of a data template, using a Twitter message
Data
Presentation via data template
ID: 87795764549529601
FromUser: Grumpydev
Message: If I end up buying a Netduino Plus 
then the blame lies solely with @Pete_Brown
Timestamp: 7/4/2011 5:00am
PostedFrom: TweetDeck

401
Creating explicit data templates
Result:
XAML:
<Grid x:Name="LayoutRoot">
  <Button x:Name="myButton"
          Height="70" Width="210">
    <Button.ContentTemplate>                    
      <DataTemplate>
        <StackPanel Orientation="Horizontal">
          <Image Source="{Binding Icon}"
                 Height="40" Margin="10" />
          <TextBlock Text="{Binding Name}"
                     FontSize="20"
                     VerticalAlignment="Center" />
        </StackPanel>
      </DataTemplate>
    </Button.ContentTemplate>
  </Button>
</Grid>
C#:
public partial class MainPage : UserControl
{
  public MainPage()
  {
    InitializeComponent();
    Loaded += new RoutedEventHandler(MainPage_Loaded);
  }
  void MainPage_Loaded(object sender, RoutedEventArgs e)
  {
    var emoticon = new Emoticon("Smiley Face","icons/happy.png");
    myButton.Content = emoticon;
  }
}
Listing 16.19 shows a DataTemplate applied to a Button. This DataTemplate is applied
to an assumed Emoticon (from the previous examples in this chapter) assigned to the
Button object’s Content property. This property must be set at runtime when using a
DataTemplate. If the Content property is set at design time, it’ll be trumped by the
DataTemplate, resulting in no data being shown in your UI. In addition, if you set the
DataContext property at runtime instead of the Content property, your data won’t be
shown. When you’re binding data to a ContentControl, keep the following in mind:
■
When assigning your data source to the DataContext property, use the binding
syntax within the control’s Content.
■
When assigning your data source to the Content property, use a DataTemplate
instead.
Listing 16.19
A DataTemplate used with a ContentControl
Data template

402
CHAPTER 16
Binding
These two points make it seem like you’re running in circles. You may be wonder-
ing why you should use a DataTemplate. Well, a DataTemplate can be defined as a
resource, which makes it usable across multiple ContentControl elements simultane-
ously. The DataTemplate approach is much more flexible. In reality, you probably
won’t use a DataTemplate with a ContentControl often, but you should expect to use
data templates frequently with ItemsControl elements.
16.5.2 Rendering an ItemsControl with a DataTemplate 
The ItemsControl element is designed to display a collection of items, which are
bound to a control through the ItemsSource property. By default, each item is dis-
played by using an object’s ToString method. By setting the DisplayMemberPath
property, you can use a specific CLR property for the text of an item, but you can go
one step further using the ItemTemplate property.
 The ItemTemplate property of the ItemsControl class allows you to fully control
how each item will be displayed. This property uses a DataTemplate to determine how
to show each item in an ItemsControl. A basic ItemTemplate for a collection of Emot-
icon objects is shown in listing 16.20. This shows a basic DataTemplate associated with
an ItemTemplate. There’s nothing complex about this example—the main thing is to
understand that this DataTemplate is used with the items bound through the Items-
Source property. In addition, this example begins to show the power of using data
templates.
Result:
XAML:
<ListBox x:Name="myListBox">
  <ListBox.ItemTemplate>
    <DataTemplate>                       
      <StackPanel Orientation="Horizontal">      
        <Image Source="{Binding Icon}" Height="40" Margin="5" />
        <TextBlock Text="{Binding Name}" FontSize="20" 
          VerticalAlignment="Center" />
      </StackPanel>
    </DataTemplate>
  </ListBox.ItemTemplate>
</ListBox>
Listing 16.20
An ItemTemplate used in an ItemsControl
DataTemplate
Child

403
Creating implicit data templates
C#:
public MainPage()
{
  InitializeComponent();
  Loaded += new RoutedEventHandler(MainPage_Loaded);
}
void MainPage_Loaded(object sender, RoutedEventArgs e)
{
  List<Emoticon> emoticons = GetEmoticons();       
  myListBox.ItemsSource = emoticons;                    
}
private List<Emoticon> GetEmoticons()  
{
  List<Emoticon> emoticons = new List<Emoticon>();
  emoticons.Add(new Emoticon("Smiley Face", "icons/happy.png"));
  emoticons.Add(new Emoticon("Straight Face", "icons/straight.png"));
  emoticons.Add(new Emoticon("Angry Face", "icons/angry.png"));
  emoticons.Add(new Emoticon("Sick", "icons/sick.png"));
  emoticons.Add(new Emoticon("Surprised", "icons/surprised.png"));
  emoticons.Add(new Emoticon("Hipster", "icons/hipster.png"));
  return emoticons;
}
Listing 16.20 shows the DataTemplate assigned to the ItemTemplate property of the
ListBox control. Note that a DataTemplate must have only one child, typically a
panel. In that panel you may have any number of other controls.
 Explicit data templates are a powerful way to use everything you’ve learned about
binding to provide a top-notch customized display for your list-based data and content
control–hosted content. In technologies before WPF and Silverlight, the idea of hav-
ing complete control over what’s displayed in a ListBox was a dream at best. Now,
using binding and templates, it’s an easy reality. 
 Explicit data templates are excellent for one-off designs or for including in styles.
There are other times, though, when you want to have the templates applied automat-
ically application-wide, you need to look at implicit data templates.
16.6
Creating implicit data templates
Implicit data templates enable you to provide data templates that are tied to rendering
a specific .NET type. Everything you learned in the previous section about how to create
data templates also applies to creating implicit data templates. The differences are:
■
An implicit data template applies to a single specific .NET data type.
■
Implicit data templates apply to all content controls and ItemsControl ele-
ments within the scope in which they’re defined and are automatically applied.
Previously, if you had more than one data type in a collection, bound to a list box, you
had to apply the same rendering (the same XAML template) to each of them. That
ItemsSource binding 
to list of emoticons

404
CHAPTER 16
Binding
meant you had to rely on common properties across the objects or had to let binding
fail when the properties didn’t exist. With implicit templates, you can apply a com-
pletely different template to each type in the collection.
NOTE
Implicit data templates must be associated with a class or a value type,
either concrete or abstract. You can’t associate an implicit template with an
interface, because the runtime wouldn’t know how to handle classes that
implement more than one interface, each with its own template.
Once the Twitter example is complete, you’ll have a screen that looks like figure 16.7,
with each type of message shown with separate templates, all in the same ListBox.
Each of the types (Tweet, FollowerAnnouncement, DirectMessage) has an implicit
template associated with it.
 Due to the number of classes required to have a meaningful example, I’ll break
this up across several listings. For starters, listing 16.21 shows a number of model
classes that derive from TwitterItem, as well as a TwitterUser class.
public class TwitterUser                  
{     
  public string NickName { get; set; }     
  public string FullName { get; set; }     
  public Uri UserImageUrl { get; set; } 
}
Listing 16.21
The Twitter model classes
Figure 16.7
A single ListBox with 
several different types of data, each with 
its own implicit template
Twitter user

405
Creating implicit data templates
public abstract class TwitterItem     
{     
  public int ID { get; set; }     
  public DateTime TimeStamp { get; set; }     
  public TwitterUser FromUser { get; set; } 
}
   
public class Tweet : TwitterItem 
{     
  public string Message { get; set; }     
  public string PostedFrom { get; set; }     
  public int InReplyTo { get; set; } 
}
   
public class DirectMessage : TwitterItem 
{     
  public string Message { get; set; }     
  public TwitterUser ToUser { get; set; } 
}
   
public class FollowerAnnouncement : TwitterItem 
{     
  // Yes, this is really empty 
}
With the model created, the next thing you need is a way to load Twitter items into a
collection. Rather than rely on the actual Twitter service, I mocked up a TwitterSer-
vice class and hard-coded the messages. The downloadable code for this book
includes the full source of the service. For space reasons, I’ll pare down the number of
messages to just the essentials here. Listing 16.22 shows the TwitterService class with
dummy data.
public class TwitterService
{
  public IList<TwitterItem> GetLatestData()     
  {
    var pete = new TwitterUser() { NickName = "pete_brown", 
        FullName = "Pete Brown",
        UserImageUrl = new Uri("images/pete.png", UriKind.Relative) };
    var joe = new TwitterUser() { NickName = "MisfitGeek", 
        FullName = "Joe Stagner",
        UserImageUrl = new Uri("images/joe.jpg", UriKind.Relative)};
    var jon = new TwitterUser() { NickName = "jongalloway", 
        FullName = "Jon Galloway",
        UserImageUrl = new Uri("images/jon.jpg", UriKind.Relative)};
    var jesse = new TwitterUser() { NickName = "JesseLiberty", 
        FullName = "Jesse Liberty",
        UserImageUrl = new Uri("images/jesse.jpg", UriKind.Relative)};
    var items = new List<TwitterItem>()
    {
Listing 16.22
The TwitterService class
Common 
base class
Service method

406
CHAPTER 16
Binding
      new Tweet() {ID=102, TimeStamp=new DateTime(2011,04,05, 23,05,33), 
            FromUser=joe, PostedFrom="web", 
            Message="I just posted a 437 part series ..."},
      new FollowerAnnouncement() {ID=280, FromUser=jon,
            TimeStamp=new DateTime(2011,04,06, 00,05,47)},
      new Tweet() {ID=490, TimeStamp=new DateTime(2011,04,06, 04,18,45), 
            FromUser=pete, PostedFrom="c64twit", 
            Message="@pete_brown I'm talking to myself." },
      new DirectMessage() {ID=547, 
            TimeStamp=new DateTime(2011,06,23, 10,05,12), 
            FromUser=jon, ToUser=pete, 
            Message="Send me teh codez pls."},
      new Tweet() {ID=605, TimeStamp=new DateTime(2011,04,06, 06,56,57), 
            FromUser=jesse, PostedFrom="a number of phones", 
            Message="I have 99 phones, but they're all on ignore :)"},
    };
    return items;
  }
}
Though I haven’t yet introduced the MVVM pattern in this book (I will, in chapter 33),
it wouldn’t hurt to keep this example structured using a little slice of a ViewModel.
This is the class that provides the glue between your model, your service, and the user
interface. Listing 16.23 shows the ViewModel code.
public class TweetViewModel
{
  private ObservableCollection<TwitterItem> _twitterItems = 
          new ObservableCollection<TwitterItem>();
  public ObservableCollection<TwitterItem> TwitterItems
  {
    get { return _twitterItems; }
  }
  public void LoadTwitterItems()
  {
    TwitterService service = new TwitterService();
    var items = service.GetLatestData();
    foreach (TwitterItem item in items)
    {
      TwitterItems.Add(item);
    }
  }
}
The next step is to create the UI. The presentation itself is very simple: just a ListBox
with a little code to wire up the ViewModel.
Listing 16.23
The ViewModel

407
Creating implicit data templates
XAML:
<Grid x:Name="LayoutRoot" Background="White" Margin="15">
  <ListBox Margin="12,42,12,12"
           ItemsSource="{Binding TwitterItems}" 
           HorizontalContentAlignment="Stretch"
           ScrollViewer.HorizontalScrollBarVisibility="Disabled">
  </ListBox>
</Grid>
C#:
public partial class MainPage : UserControl
{
  private TweetViewModel _vm = new TweetViewModel();
  public MainPage()
  {
    InitializeComponent();
    Loaded += new RoutedEventHandler(MainPage_Loaded);
  }
  void MainPage_Loaded(object sender, RoutedEventArgs e)
  {
    DataContext = _vm;
    _vm.LoadTwitterItems();
  }
}
The reason the ListBox is so simple is because the real meat of the display is built into
the implicit data templates. For each of the types of objects in the collection, there
exists one template that’s responsible for rendering it.
 Listing 16.25 shows a subset of the templates, specifically the follower announce-
ment and the tweet. Each of these templates goes in the UserControl.Resources sec-
tion, which is between the UserControl opening tag and the LayoutRoot Grid
opening tag.
<UserControl.Resources>
<DataTemplate DataType="model:FollowerAnnouncement">  
  <Grid Background="BlanchedAlmond"
        Width="350" Margin="2">
    <StackPanel Orientation="Horizontal" Margin="3">
      <TextBlock Text="{Binding FromUser.FullName}" />
      <TextBlock Text=" started following you " />
      <TextBlock Text="{Binding TimeStamp, StringFormat='dddd hh:mm'}" />
    </StackPanel>
  </Grid>
</DataTemplate>
<DataTemplate DataType="model:Tweet">       
  <Grid Margin="2" Width="350"
        HorizontalAlignment="Left" Background="#FFEFEFEF">
Listing 16.24
MainPage.xaml and its code-behind
Listing 16.25
Implicit template for follower announcement and tweet
Binding
Follower 
announcement
Tweet

408
CHAPTER 16
Binding
    <Grid.ColumnDefinitions>
      <ColumnDefinition Width="56" />
      <ColumnDefinition Width="*" />
    </Grid.ColumnDefinitions>
    <Image Source="{Binding FromUser.UserImageUrl}"
           HorizontalAlignment="Left" VerticalAlignment="Top"
           Stretch="UniformToFill"
           Margin="4" Width="48" Height="48" />
    <Grid Grid.Column="1" Margin="3">
      <Grid.RowDefinitions>
        <RowDefinition Height="Auto" />
        <RowDefinition Height="Auto" />
        <RowDefinition Height="Auto" />
      </Grid.RowDefinitions>
    <ContentControl Content="{Binding FromUser}" />  
    <TextBlock Text="{Binding Message}"
               TextWrapping="Wrap" Grid.Row="1" />
    <StackPanel Grid.Row="2" Orientation="Horizontal">
      <TextBlock Text="{Binding TimeStamp, StringFormat='dddd hh:mm'}" />
      <TextBlock Text=" via " />
      <TextBlock Text="{Binding PostedFrom}" />
    </StackPanel>
  </Grid>
 </Grid>
</DataTemplate>
</UserControl.Resources>
Of course, implicit templates aren’t limited to collections and list boxes. Some appli-
cations may want to reuse a bit of UI (the rendering for an address, for example)
across the entire application. In the past, the approach to handle this typically
involved creating a custom user control that contained the fields that made up the
address. This approach worked fine but was a little heavy and required touching each
page where the address type was used.
 With Silverlight 5 and later, you can define a template for the Address type in the
App.xaml (or a related resource dictionary) and use a content control to display
addresses in the application. 
 Another example is reuse of formatting of the sender’s name in a Twitter message.
If you’ve been typing in the code, you’ll see that the names aren’t displaying. Instead,
the full type name of the TwitterUser class is displayed. Listing 16.26 builds on listing
16.25 to use the ContentControl assigned the FromUser as its content to properly dis-
play the user’s name and nickname.
<Style x:Key="NameHeadingStyle"               
       TargetType="TextBlock">
  <Setter Property="FontSize" Value="12" />
Listing 16.26
Reusing UI through a globally defined implicit template
User content 
control
Style

409
Summary
  <Setter Property="Foreground" Value="#FF6495ed" />
  <Setter Property="FontWeight" Value="Bold" />
</Style>
        
<!-- User name template -->
<DataTemplate DataType="model:TwitterUser"> 
  <StackPanel Orientation="Horizontal">
    <TextBlock Text="{Binding NickName}"
               Style="{StaticResource NameHeadingStyle}" />
    <TextBlock Text=" / " />
    <TextBlock Text="{Binding FullName}"
               Style="{StaticResource NameHeadingStyle}" />
  </StackPanel>
</DataTemplate>
The data template and the style it uses together make up the reusable template, which
is applied to all model:TwitterUser objects assigned to ControlControls within the
scope in which this is defined. In this case, I defined the template as a resource on the
page, so it will apply only to TwitterUser classes on this page. It’s sufficient to apply
the formatting to all the Twitter items in the list box—a case of an implicit template
nested into several other implicit templates.
 Data templates provide a great way to format any type of object using XAML.
Implicit templates expand on those to provide a way not only to support multiple
types of data in a single ListBox, but also reuse UI templates throughout the entire
application.
16.7
Summary
In this chapter, you’ve seen the power of the Binding object and the vast tree of func-
tionality that grows from it. This object gives you the flexibility to bind to individual
entities, to collection of entities, to indexed entries in a collection, and even to other
UI elements. If you need to massage the data, either coming or going, Silverlight pro-
vides a way for you to create your own value converters to do that. If you simply need
to format the display, Silverlight provides a way for that too.
 In most cases, your classes are defined at compile time. But for data-driven applica-
tions, or applications where you want to work with strongly typed return values from
various services on the internet, that’s not always possible. ICustomTypeProvider and
System.Reflection enable you to define class properties at runtime and use them
transparently in the binding system.
 In this chapter, you’ve seen how to fully customize the look of your data with data
templates. Data templates, both implicit and explicit, are an amazingly powerful way
to control the presentation of your list-based and content control data.
 Most important, you’ve seen binding in action. Binding rises to the near top of the
most critical topics to understand when you’re getting into Silverlight. Once you master
binding, you may find that you’ll never again write another line of control.property
= value code.
 Silverlight includes two complex and useful controls that were designed to work well
with binding: the DataGrid and the DataForm. I’ll discuss those in the next chapter.
Reusable 
template

410
Data controls:
DataGrid and DataForm
In chapter 16, you learned about binding. I believe binding to be one of the most
important topics for Silverlight developers. One reason behind my belief is that the
DataGrid and DataForm, as well as data annotations for display, all require binding
in order to be useful.
 Silverlight 2 included the DataGrid, and Silverlight 3 added the DataForm to the
mix of data-centric controls. The DataGrid provides tabular Microsoft Excel–like
data view and editing—a mainstay of business applications. The DataForm is like a
DataGrid rotated 90 degrees. Where the DataGrid is all about rows and columns
for multiple visible entries, the DataForm is about fields and labels for a single visi-
ble entry.
 Once I cover the DataGrid and DataForm, you’ll see how to annotate properties
with simple attributes to control display within the DataGrid and DataForm. You’ll
learn about the related input validation attributes in chapter 18.
This chapter covers
■
Learning about the DataGrid
■
Turning the grid on its side with the DataForm
■
Controlling binding display through attributes

411
The DataGrid
 When used together, the DataForm, DataGrid, and the related data annotations
can form the heart of the UI for any forms-over-data or business application and can
save you a ton of implementation time. Of the three, the DataGrid is the most often
used, so let’s start there.
17.1
The DataGrid
DataGrid is a list-style control that belongs to the System.Windows.Controls
namespace. This control provides capabilities for displaying a collection of entities in
a tabular format. In addition, it enables users to add, edit, delete, select, and sort
items from a binding data source. This data source is bound to a DataGrid through
the ItemsSource property just like an ItemsControl, so the data binding features
you’ve seen so far are applicable within the realm of the DataGrid. Before you can
bind data to a DataGrid, you must first reference the correct assembly.
 The DataGrid control is defined in its own assembly called System.Windows
.Controls.Data.dll. This assembly can be found within the Silverlight SDK, which is
available at www.silverlight.net. Note that the DataGrid control’s assembly isn’t part of
the default Silverlight runtime installation; it’s an extended control, so you must refer-
ence the assembly within your Silverlight application. The process of referencing an
assembly like this and referring to it from XAML was discussed in chapter 2. Part of
this process involves choosing a prefix in order to use the control at design time. 
 Throughout this section, you’ll use the XAML prefix data when referencing the
DataGrid control’s namespace. You’ll first see how easy it is to use the DataGrid to dis-
play data. From there, you’ll learn how to leverage the built-in features to enable a
user to edit the data within a DataGrid. Finally, you’ll see how to enable your users to
sort the data in a DataGrid.
17.1.1 Displaying your data
The DataGrid was designed to make it simple and efficient to display and edit a lot of
data. The easiest way to display data from an ItemsSource is to use the AutoGenerate-
Columns property. This Boolean property defaults to true, causing the content within
the ItemsSource to be rendered in tabular format. 
Result:
XAML:
<UserControl x:Class="EmoticonExample.MainPage"
  xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" 
Listing 17.1
The DataGrid—assume the ItemsSource property is set in code

412
CHAPTER 17
Data controls: DataGrid and DataForm
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" 
xmlns:data="clr-namespace:System.Windows.Controls;
[CR] assembly=System.Windows.Controls.Data">
  <Grid x:Name="LayoutRoot" Background="White" Margin="15">
    <data:DataGrid x:Name="myDataGrid" />     
  </Grid>
</UserControl>
C#:
List<Emoticon> emoticons = GetEmoticons();
myDataGrid.ItemsSource = emoticons;
Voilà! This example relies on the System.Windows.Controls.Data assembly to
deliver the DataGrid. This Control instance relies on its default behavior to automat-
ically create columns based on the data that it’s bound to. This approach is the fastest
way to show the data bound to a DataGrid, and it also has some details that are worth
examining.
Let’s look at what makes a bound column tick. From there, you’ll learn how to cus-
tomize the columns, rows, and headers of a DataGrid.
EXPLORING BOUND COLUMNS
When the AutoGenerateColumns property is set to true, the columns in a DataGrid are
automatically ordered and rendered based on the type of the underlying data. Regard-
less of the type of data, the column type will always derive from the abstract base class
DataGridBoundColumn, which serves as the base for the two types shown in table 17.1.
The DataGrid isn’t an ItemsControl
The DataGrid takes advantage of a feature known as UI virtualization. UI virtualization
means that only the items visible to the user are created in memory. This performance
enhancement ensures that the DataGrid can support millions of rows of data. In Sil-
verlight 2, the ItemsControl elements mentioned in chapter 12 didn’t have support
for UI virtualization. But in Silverlight 3 and beyond, virtualization is built into some
controls such as the ListBox.
Table 17.1
Types of columns that can be automatically generated within a DataGrid
Type
Description
DataGridTextColumn
This type of column is used to display textual data. Most of the data 
from a binding source will be rendered in a DataGridTextColumn
through calling the binding property’s ToString method. This col-
umn type won’t show the default Silverlight TextBox, but the ren-
dered content can be edited as if it were in a visible TextBox.
DataGridCheckBoxColumn
This column type generates a CheckBox within a cell. When the 
AutoGenerateColumns property is true, any bool will be ren-
dered using this column type.
DataGrid

413
The DataGrid
Table 17.1 shows the kinds of columns that can be automatically generated within a
DataGrid. If you want to manually create a column, you can also use these types. But
when you’re manually defining your columns, you must set the Binding property,
which represents the Binding associated with a column (the property name and the
type name are the same). Because of this, you can use the Binding syntax explained in
chapter 16. This Binding declaration may be necessary because by default, when you
use a DataGridBoundColumn, a TwoWay binding is used.
 The DataGridBoundColumn is one of the main types of DataGrid columns. The
other is a DataGridTemplateColumn, which uses a DataTemplate to determine how to
render the binding source. Note that every type of column that can be added to a
DataGrid derives from the DataGridColumn class, which is used to represent the col-
umn of a DataGrid. Objects of this type can be manually added to a DataGrid at
design time and managed at runtime.
MANUALLY WORKING WITH COLUMNS
The DataGrid can use any column that derives from DataGridColumn. These columns
can be added to a DataGrid at design time through the Columns property. 
Result:
XAML:
<data:DataGrid x:Name="myDataGrid" AutoGenerateColumns="False">
  <data:DataGrid.Columns>                              
    <data:DataGridTextColumn Binding="{Binding Name, Mode=OneWay}" />
    <data:DataGridTemplateColumn>
      <data:DataGridTemplateColumn.CellTemplate>
        <DataTemplate>
          <Image Source="{Binding Icon}" />
        </DataTemplate>
      </data:DataGridTemplateColumn.CellTemplate>
    </data:DataGridTemplateColumn>                
  </data:DataGrid.Columns>
</data:DataGrid>
Listing 17.2 shows how to add columns manually to a DataGrid at design time. These
columns are added to the Columns property. The items of this read-only collection will
be displayed in the order they appear in XAML, but you can change this through the
DisplayIndex property.
Listing 17.2
Manually adding columns to a DataGrid
Columns 
property

414
CHAPTER 17
Data controls: DataGrid and DataForm
 The DisplayIndex property represents the position of a DataGridColumn in a
DataGrid. This zero-based integer can be set at design time to override the default
ordering approach. Alternatively, the DisplayIndex property can be set at runtime.
This property makes it possible to create a truly dynamic DataGrid, but the features
don’t stop there. They also continue at the row level.
CUSTOMIZING THE ROWS
A row within a DataGrid will most likely represent a summarized view of an item. In
these situations, it’s not unusual to redirect the user to another page to get the details
associated with the item, but the DataGrid provides the ability to display these details
within the row itself. This approach can reduce the strain of waiting for another page
to load for the user. To make this happen, you define the RowDetailsTemplate.
 The RowDetailsTemplate is a DataTemplatethat can be used to show the finer
points of a specific row. This information may be shown if the RowDetailsVisibility-
Mode property is set accordingly. You’ll learn more about that in a moment. For now, just
assume that a row will show its details when a user selects it. When this occurs, the
DataGrid will reveal the details using a smooth sliding animation. The details can take
up as much or as little space as needed. To demonstrate how this works, imagine adding
a string property called Keys to the Emoticon class defined earlier in this chapter. This
property represents the keyboard shortcut to use for an emoticon. 
Result:
XAML:
<data:DataGrid x:Name="myDataGrid" AutoGenerateColumns="False"
  RowDetailsVisibilityMode="VisibleWhenSelected">     
  <data:DataGrid.Columns>
    <data:DataGridTextColumn Binding="{Binding Name, Mode=OneWay}" />
    <data:DataGridTemplateColumn>
      <data:DataGridTemplateColumn.CellTemplate>
        <DataTemplate>
          <Image Source="{Binding Icon}" />
        </DataTemplate>
      </data:DataGridTemplateColumn.CellTemplate>
    </data:DataGridTemplateColumn>                
  </data:DataGrid.Columns>
  <data:DataGrid.RowDetailsTemplate>              
Listing 17.3
Using RowDetailsTemplate to show the per-item keyboard shortcut 
RowDetailsVisibilityMode

415
The DataGrid
    <DataTemplate>                             
      <StackPanel Orientation="Horizontal">                    
        <TextBlock Text=" Keyboard Shortcut: " FontSize="11" />   
        <TextBlock Text="{Binding Keys}" FontSize="11" />      
      </StackPanel>                                           
    </DataTemplate>                                   
  </data:DataGrid.RowDetailsTemplate>
</data:DataGrid>
Listing 17.3 shows how to use the RowDetailsTemplate property. This property uses a
DataTemplate to display additional details about a row in a way dependent on the
value of the RowDetailsVisibilityMode property.
 The RowDetailsVisibilityMode property determines when the details associated
with a row are shown. By default, this property is set to Collapsed, but you can change
this value to any option available within the DataGridRowDetailsVisibilityMode
enumeration. This enumeration provides three options. All are shown in relation to
the DataGrid with the emoticons.
Table 17.2 shows the options available within the DataGridRowDetailsVisibility-
Mode enumeration. These options, coupled with the RowDetailsTemplate property,
Table 17.2
Options available within the DataGridRowDetailsVisibilityMode enumeration 
Option
Example
Description
Collapsed
When this option is used, the content 
in the RowDetailsTemplate won’t 
be shown.
Visible
This option forces the content in the 
RowDetailsTemplate to be shown 
for every row. The content will be 
shown regardless of user interaction.
VisibleWhenSelected
This option will show the content in 
the RowDetailsTemplate for each 
selected row.
RowDetailsTemplate

416
CHAPTER 17
Data controls: DataGrid and DataForm
give you the ability to customize the experience with item-level details. The DataGrid
extends the same type of power to the column headers.
CUSTOMIZING THE HEADERS
The DataGrid gives you the ability to customize every part of it, including the headers.
The headers of a DataGrid are split across two separate categories: row and column.
By default, your DataGrid will show both, but you can control this by changing the
HeadersVisibility property. This property uses one of the options available in the
DataGridHeadersVisibility enumeration, which are shown in table 17.3.
The DataGridHeadersVisibility enumeration is used to set whether a header type is
visible. You can also customize what the header looks like and how it behaves through
the DataGridColumn class’s Header property. This property represents the column
Table 17.3
The options available through the DataGridHeadersVisibility enumeration 
Option
Example
Description
All
This option displays both row and column headers. 
Column
This option displays only the column headers. This is 
the default value.
None
This option displays neither the row nor column 
headers.
Row
This option displays only the row header.

417
The DataGrid
header content, so it uses the same content-related information you’ve already
learned about.
 As you’ve seen, the DataGrid empowers you to fully customize how your data is
presented. These customizations can be applied at the header, row, and column levels.
Note that you don’t have to make any of these adjustments. If you’re looking for a
quick way to show your data in a tabular format, you can rely on the fact that the
AutoGenerateColumns property defaults to true. Either way, once your data is loaded,
you can enable your users to edit the data directly within the grid. 
17.1.2 Editing grid data
In addition to presenting data, the DataGrid has the ability to edit data. Users will be
able to edit the contents of a DataGrid as long as the IsReadOnly property  is set to
false. By default it is, so your users have the flexibility to interact with their data in a
familiar interface. As they do so, you can watch for the beginning of the editing pro-
cess through two events. These events are triggered by the DataGrid and are called
BeginningEdit and PreparingCellForEdit.
 The BeginningEdit event gives you the opportunity to make last-minute adjust-
ments just before users do their thing. In some situations, you may want to prevent a
user from editing a cell due to previous inputs. For these occasions, the Beginning-
CellEdit event exposes a bool Cancel property within its DataGridBeginningEdit-
EventArgs parameter. By setting this property to true, you ensure that the event will
stop running. If the event does complete in its entirety, the PreparingCellForEdit
event will also be fired.
 The PreparingCellForEdit is fired when the content of a DataGridTemplate-
Column enters the editing mode. This event exists to give you the opportunity to over-
ride any changes that may have been made in the BeginningEdit event. Once this
event and/or the BeginningEdit event have completed without cancellation, users
will be given the reins. After they’re done editing the data in the DataGrid, they may
decide they want to resort the data.
17.1.3 Sorting items
The DataGrid has built-in support for sorting collections that implement the IList
interface. This interface is a part of the System.Collections namespace and is heav-
ily used throughout the Silverlight .NET Framework so you can readily sort almost any
collection of objects. If you don’t like the way that the DataGrid sorts your collection,
you’re free to customize the sorting by binding to a collection that implements the
ICollectionView interface. Either way, the DataGrid can be used to sort these collec-
tions via the SortMemberPath property.
 The SortMemberPath property is a string available on the DataGridColumn class, so
this property can be used by any of the options shown in table 17.3. Regardless of
which option you use, the user will be empowered to sort the column in either ascend-
ing or descending order.

418
CHAPTER 17
Data controls: DataGrid and DataForm
Result:
XAML:
<data:DataGrid x:Name="myDataGrid" AutoGenerateColumns="False">
  <data:DataGrid.Columns>
    <data:DataGridTextColumn Binding="{Binding Name}"
      Header="Name" SortMemberPath="Name" />     
    <data:DataGridTextColumn Binding="{Binding Keys}" 
      Header="Shortcut" SortMemberPath="Keys" />   
    <data:DataGridTemplateColumn>
      <data:DataGridTemplateColumn.CellTemplate>
        <DataTemplate>
          <Image Source="{Binding Icon}" />
        </DataTemplate>
      </data:DataGridTemplateColumn.CellTemplate>
    </data:DataGridTemplateColumn>
  </data:DataGrid.Columns>
</data:DataGrid>
Listing 17.4 shows two DataGridColumn instances enabling the user to sort the under-
lying ItemsSource. The first DataGridColumn enables the user to sort the Emoticon
objects by their Name property. The other DataGridColumn lets the user sort by the
Keys property. If the user were to select a column header, it would first be sorted in
ascending order. If the column header were to be selected again, it would be sorted in
descending order. The SortMemberPath property is what makes this feature of the
DataGrid possible.
 As you’ve just seen, the DataGrid has an incredibly rich development model. This
model is important because it can help you assist your users in their data entry tasks,
which may include editing data or simply viewing it. Either way, the DataGrid provides
the ability to efficiently deliver items from a data source in a tabular format. 
 The DataGrid is great for tabular data, but what do you do when you want similar
functionality in a form-based layout model? Introduced in Silverlight 3 and originally
considered part of WCF RIA Services (covered in appendices D, E, and F of the ebook),
the DataForm is the DataGrid’s form-based counterpart.  
17.2
The DataForm
Silverlight 3 introduced a control that does for forms what the DataGrid does for lists:
the DataForm. The DataForm can be thought of as a single-row DataGrid turned on its
side. It shares similar capabilities in that it can be read-only or editable and can infer
Listing 17.4
Built-in DataGrid sorting
SortMemberPath

419
The DataForm
column names and edit controls based on the types bound to it. Like the DataGrid, it
also provides full customization of the representation of each of the bound fields.
 Like the DataGrid, the DataForm can work with multiple rows of data. The presen-
tation differs in that you’ll see only one row at a time, as is typical in a details form.
The DataGrid and DataForm are sometimes used together to show a master-detail rela-
tionship where the DataGrid contains all the records and the DataForm is used to
show an editable form for the DataGrid row.
 The DataForm was originally developed for Silverlight by the same team that
brought us WCF RIA Services. To support continued iteration on the control, it was
moved from the SDK, where the now-mature DataGrid resides, and placed in the Sil-
verlight Toolkit in the System.Windows.Controls.Data.DataForm.Toolkit assembly,
with the well-known XML namespace http://schemas.microsoft.com/winfx/2006/
xaml/presentation/toolkit. The Silverlight Toolkit can be thought of as an agile
extension of the Silverlight SDK, with the bonus that you have access to the source
code for the controls and tests it contains.
 Though not all applications will use the DataForm, it’s much richer and more cus-
tomizable than it initially appears. Virtually any forms-over-data application can use this
control to show a UI that can be as simple as a list of fields or as complex as a customized
layout with specific field styles, sizes, and positioning. How it looks is up to you.
 In this section, you’ll take a tour through the capabilities of the DataForm, starting
with a simple binding to a single object and then to a collection of objects. Next, you’ll
work with the command buttons for canceling updates and submitting data. Once you
have the functional mechanics down, you’ll customize the display of fields by using
properties and then by using richer data templates for the edit, add, and display
modes. The section will wrap up with a discussion of IEditableObject and how that
interface can make working with the DataForm even easier.
17.2.1 Displaying your data
The easiest thing to do with the DataForm is to bind it to an object and watch it gener-
ate all the fields you need. You’ll step away from the Emoticon class for the remaining
examples here to observe the breadth of controls the DataForm understands. Let’s cre-
ate a simple Person class. (The Required attribute, used in this class, will be covered
in chapter 18, which focuses on validation.)
public enum MaritalStatus
{
    Unknown,
    Married,
    Single,
    Divorced
}
public class Person
{
Listing 17.5
The Person class

420
CHAPTER 17
Data controls: DataGrid and DataForm
    [Required]
    public string LastName { get; set; }
    [Required]
    public string FirstName { get; set; }
    public bool IsRegistered { get; set; }
    public MaritalStatus MaritalStatus { get; set; }
    public DateTime DateOfBirth { get; set; }
    [Required]
    public string EmailAddress { get; set; }
    [Required]
    public int NumberOfChildren { get; set; }
}
You’ll then bind to it in XAML using a static resource, much as you have in other
examples. Instead of individual controls, you’ll use the entire object as your data
source for the new DataForm control.
<UserControl.Resources>
  <local:Person x:Key="me" 
</UserControl.Resources>
<Grid x:Name="LayoutRoot" Margin="30">
  <toolkit:DataForm CurrentItem="{StaticResource me}" />
</Grid>
The property that’s used to generate the form is the CurrentItem property, in this
sample case bound to a single object sitting in the Resources section of this control.
The resulting DataForm, as seen in figure 17.1, is impressive in the breadth of controls
it has autogenerated for you. Not only did you not have to write any code specific to
the DataForm, you also didn’t have to place any edit controls in the markup.
Note that the DataForm displayed a CheckBox for the bool property, a ComboBox for
the enum (populated with all the possible values defined in the enumeration, of
course), and a DatePicker for the DateTime property. Not bad for a default form, and
certainly workable for a simple utility application.
 So far you’ve been binding one discrete object to the DataForm. To harness the
true power of the DataForm, you’ll want to bind it to a list of objects much as you
would a DataGrid.  
Listing 17.6
Binding the DataForm to a single Person object
Figure 17.1
DataForm
showing generated edit 
controls bound to a single 
object without a backing 
collection. Note that there’s 
no toolbar or set of navigation 
buttons. Not all fields are 
shown, so your form will look 
slightly different.

421
The DataForm
17.2.2 Binding to lists of data
If you want to support the ability to add new records, you’ll need to provide a place to
put them. For this example, you’ll create a simple class that holds dummy data. You
could wire this to a service to load a collection of Person objects, should you desire. 
 Listing 17.7 shows a class named PeopleRepository that will hold your Person
objects. Note that this doesn’t follow the formal Repository pattern; it’s closer to a
ViewModel (covered in chapter 33).
public class PeopleRepository
{
  private ObservableCollection<Person> _people =  
    new ObservableCollection<Person>(); 
  public ObservableCollection<Person> People
  {
    get { return _people; }
  }
  public PeopleRepository()
  {
    _people.Add(new Person()
    {
      FirstName = "Captain", LastName = "Avatar",
      IsRegistered = true,
      MaritalStatus = MaritalStatus.Unknown,
      DateOfBirth = DateTime.Parse("1912-01-01")
    });
    _people.Add(new Person()
    {
      FirstName = "Derek", LastName = "Wildstar",
      IsRegistered = true,
      MaritalStatus = MaritalStatus.Single,
      DateOfBirth = DateTime.Parse("1954-11-15")
    });
  }
}
Once you have a suitable repository for the data (whether it’s a ViewModel or some-
thing else), one of the easiest things to do is to supply an ObservableCollection<T>
to the ItemsSource property.
<UserControl.Resources>
  <local:PeopleRepository x:Key="repository" />             
</UserControl.Resources>
<Grid x:Name="LayoutRoot" Margin="30">
  <toolkit:DataForm 
           DataContext="{StaticResource repository}" 
           ItemsSource="{Binding People}"                  
           CurrentIndex="0">
Listing 17.7
The PeopleRepository class 
Listing 17.8
Binding the DataForm to the PeopleRepository class
Observable 
collection 
of Person
Dummy data 
loaded
Repository 
reference

422
CHAPTER 17
Data controls: DataGrid and DataForm
  </toolkit:DataForm>
</Grid>
Listing 17.8 uses the PeopleRepository class from listing 17.7 with a collection of
Person objects exposed through a property named People. In XAML, you create a
resource to hold a reference to that repository and set the DataContext of the Data-
Form to that StaticResource. (You could also create the repository and set the Data-
Context from code.) You then bound the ItemsSource to the collection of Person
objects. The resulting DataForm looks like figure 17.2.
 Note the new toolbar at the top of the DataForm. This provides navigation as well
as Add (the plus sign) and Delete (the minus sign) capabilities. For each of the opera-
tions (Add, Delete, Validate, and so on) appropriate events are raised with the capabil-
ity to cancel operations based on criteria you set in your code.
VCR control?
Ack! Was that the dreaded VCR binding control I just saw in that screenshot? 
Yes—but this is Silverlight, which means you have control over what that toolbar looks
like, where it’s displayed (if at all), and how a user navigates through the records.
You also get good event support when you move from record to record, as well as the
ability to properly validate the data.
So, yes, it looks like the same old VCR control we grew up with in old VB, but it bears
about as much technical resemblance to the old VB data binding controls as Blu-ray
does to VHS.
Figure 17.2
A DataForm bound 
to a collection of objects. Note 
the presence of the toolbar 
including the add/remove and 
navigation buttons, sometimes 
called the VCR control. (Display 
annotations, covered in 17.3, 
were used in this example.)

423
The DataForm
The toolbar can be customized both by templating and via the CommandButtons-
Visibility property, whose possible values are shown in table 17.4.
Figure 17.3 shows what the toolbar looks like with all of the command buttons visible.
The OK and Cancel buttons at the bottom are the commit and cancel buttons. The
pencil in the upper right (currently disabled) is the edit button. The other buttons
are as described earlier.
 To alter the appearance of the OK and Cancel buttons without retemplating the
DataForm, you can use CommitButtonContent and CancelButtonContent to set the
contents of the buttons and CommitButtonStyle and CancelButtonStyle to restyle
the buttons.
Table 17.4
DataForm CommandButtonsVisibility values
Template property
Description
All
Show all buttons.
Add
Show the add new item button.
Cancel
Show the cancel edit button. If the underlying item implements 
IEditableObject, this calls the CancelEdit function.
Commit
Show the commit edit button. If the underlying item implements 
IEditableObject, this calls the EndEdit function.
Delete
Show the delete button.
Edit
Show the edit button. This button is typically not necessary if 
AutoEdit is set to true.
Navigation
Show the VCR control navigation buttons.
None
Don’t show any command buttons.
Figure 17.3
The DataForm
with all command buttons 
displayed. The OK and Cancel 
buttons are the commit and 
cancel buttons, respectively.

424
CHAPTER 17
Data controls: DataGrid and DataForm
As with just about everything else in Silverlight, you can completely style the way the
DataForm looks. You may want to change not only the style but also the field label dis-
play and the data type controls. 
17.2.3 Customizing display
The DataForm provides multiple levels of UI customization, ranging from how to dis-
play field labels and descriptions all the way to providing your own complete Data-
Template for each of the modes of the control.
CUSTOMIZING FIELD LABELS
In addition to the ability to change the text of the field labels, the DataForm provides
the ability to change the position of the labels relative to the edit control. This capabil-
ity is exposed through the LabelPosition property, the values of which are shown in
table 17.5.
The field label provides the primary way you should indicate the expected contents of
a field. Should the user require additional information, it may be provided via the
field description.
CUSTOMIZING FIELD DESCRIPTIONS
Field description elements are the small icons and related tooltips that typically
appear to the right of any control bound to a property that has an associated display
description. Later in this chapter, you’ll learn how to set the description text for indi-
vidual fields on the form using the DisplayAttribute. 
 The DataForm provides the property DescriptionViewerPosition, which enables
you to set the relative location of the description viewer icon. The possible values are
described in table 17.6.
Table 17.5
Possible values for LabelPosition and the resulting display 
Value
Result
Left
Top
Auto
When there is a parent DataForm, the label position will be 
inherited. When there’s no additional parent DataForm, this 
value is treated as Left.

425
The DataForm
With the label and description covered, let’s turn our attention to the field controls
and edit them using the three available template properties. 
17.2.4 Customizing edit, add, and display templates
The no-code/no-markup out-of-the-box experience is good, but those types of solu-
tions only get you so far before they break down. The DataForm gets you further than
most controls, but if you couldn’t completely customize the DataForm, you know it’d
be a nonstarter for production-ready real-world applications. Luckily, the DataForm
supports customization of the associated data templates for the three values of the
Mode property: AddNew, Edit, and ReadOnly.
 In chapter 16, you learned how to use data templates. The DataForm control pro-
vides three places where you can insert your own data templates: the EditTemplate,
NewItemTemplate, and ReadOnlyTemplate, all described in table 17.7.
Table 17.6
Possible values for DescriptionViewerPosition and the resulting display 
Value
Result
BesideContent
BesideLabel
BesideLabel (with 
LabelPosition set to Top)
Auto
When there is a parent DataForm, the position will be inherited. 
When there’s no additional parent DataForm, this value is 
treated as BesideContent.
Table 17.7
DataForm templates corresponding to the DataForm mode
Template property
Description
EditTemplate 
Corresponds to the Edit value of the Mode property. This template is used 
when the user or application code puts the form in edit mode or when 
AutoEdit is true.

426
CHAPTER 17
Data controls: DataGrid and DataForm
The mechanics of defining the data templates for the three different modes are the
same, so you’ll concentrate on just the EditTemplate in the following examples.
CREATING THE DATATEMPLATE
Most of you will create your data forms yourselves, with your own aesthetics accounted
for. Supplying your own data templates enables you to do a few primary things:
■
You have complete control over the layout of the form and can, therefore, make
it look as the designer intended.
■
You can customize the individual field edit control types.
■
You can change the binding characteristics to include your own value converters.
What you give up is the magic. Unlike the case when you started manually adding
fields to the DataGrid, the DataForm provides a nice assortment of capabilities when
adding fields. You’ll still need to add a field in markup for each field you want on the
form, but in reality, this is no more work than you would’ve had to do if you created
the forms without the help of the DataGrid, with some significant savings in applica-
tion plumbing code.
 In a departure from its DataGrid cousin, the DataForm takes a more flexible
approach to specifying the individual fields. Rather than have built-in field types you
must choose from or use a template for the remaining, you simply need to wrap edit
controls within a DataField content control.
<toolkit:DataForm.EditTemplate>            
  <DataTemplate>
    <StackPanel>
      <toolkit:DataField>                        
        <TextBox Text="{Binding LastName, Mode=TwoWay}" />
      </toolkit:DataField>
      <toolkit:DataField>
        <TextBox Text="{Binding FirstName, Mode=TwoWay}" />
      </toolkit:DataField>
      <toolkit:DataField LabelVisibility="Collapsed">
        <CheckBox IsChecked="{Binding IsRegistered, Mode=TwoWay}"
                  Content="Is Registered" />
      </toolkit:DataField>
    </StackPanel>
NewItemTemplate 
Corresponds to the AddNew value of the Mode property. This template is 
used when the user or application code adds a new item.
ReadOnlyTemplate 
Corresponds to the ReadOnly value of the Mode property. This template is 
used when the current item is read-only.
Listing 17.9
Wrapping the controls in an edit template
Table 17.7
DataForm templates corresponding to the DataForm mode (continued)
Template property
Description
EditTemplate 
property
DataField 
definition

427
The DataForm
  </DataTemplate>
</toolkit:DataForm.EditTemplate>
The resulting DataForm edit con-
trols look like figure 17.4. Note that
I hard-coded the CheckBox content
property to IsRegistered and hid
the associated DataField label so I
could demonstrate how to use the
built-in CheckBox content property.
 The DataField content control has a number of properties that mirror those on
the DataForm itself. These are used for controlling where or if the description displays,
where to put the field label, and so on. Those may all be set on a field-by-field basis in
order to override the DataForm-level settings. 
 If you don’t want the additional support provided by the DataField control, you can
omit it and add the TextBlocks and TextBoxes (and other controls) directly to the tem-
plate and bind them to the appropriate fields, without wrapping in DataField controls.
 That’s how you control the editing experience at a field and form level. Now let’s
look at how to control the overall editing and commit experience from a workflow
standpoint.
17.2.5 Finer control over editing and committing data
The DataForm and similar controls provide several other settings and hooks that may
be used to customize the overall editing workflow. These range from altering the
object state based on whether or not it’s about to go into the edit mode, how to com-
mit changes, and how to manually check if the form includes only valid data.
IEDITABLEOBJECT
System.ComponentModel.IEditableObject is an interface that allows controls such as
the DataForm to make method calls into an object when it’s about to be edited. Specif-
ically, the interface defines the three methods listed in table 17.8.
Table 17.8
IEditableObject interface
Template property
Description
BeginEdit
Called when the object is put into the edit mode.
This is where you may want to cache undo information. If the DataForm’s 
AutoEdit property is set to true, this is called as soon as an edit field 
receives focus. Otherwise, it’s called as a result of the user clicking the edit 
button on the toolbar. 
CancelEdit
Called when the object was previously in the edit mode but now is to be put 
back into the read-only mode, reverting any changes.
On the DataForm, this is called when the user clicks the Cancel button.
EndEdit
Called when the edit is complete and the changes should be committed.
If the DataForm’s AutoCommit property is set to true, this will happen 
when the user navigates off the item and the item is both dirty and valid.
Figure 17.4
Customized EditTemplate showing the 
CheckBox label to the right of the CheckBox

428
CHAPTER 17
Data controls: DataGrid and DataForm
Those three functions allow you to control what happens to the object’s data when it’s
put in the edit mode, the edit mode is canceled, and the edits are committed. Though
the sky’s the limit with what you might do in these functions, common approaches are
versioning, single or multiple-level undo, storing a history of changes, and lazy-load-
ing data required for the edit process.
 The Silverlight DataForm control respects these methods and calls them at the
appropriate times if your class implements the IEditableObject interface. Another
place where the DataForm allows customization in the object workflow is in checking
the item state.
CHECKING FOR DIRTY STATE AND VALIDITY
The DataForm also provides a way to check the object’s changed state, often called its
dirty state, from within the DataForm itself. This doesn’t require any dirty tracking
infrastructure in place within the entity being edited; the DataForm takes care of all of
that. To check whether the current item has been changed, refer to the IsItem-
Changed property as follows:
if (dataForm.IsItemChanged) {…}
If the item has changed, you’ll probably be interested in knowing if it’s valid. Luckily,
the DataForm provides a property for that as well: the IsItemValid property. This
property returns true if the currently edited item, the item visible on the DataForm,
has met all associated validation rules (covered in chapter 18). The syntax for the
read-only IsItemValid property is shown here:
if (dataForm.IsItemValid) {…}
The DataForm by itself is a nice way to handle data entry in your applications. Without
sacrificing the capabilities it offers, you have a great deal of control over how the con-
tent is rendered and how navigation is handled. The DataForm will help do for forms
what the DataGrid did for tabular data.
 The DataGrid and DataForm are two powerful controls for displaying and editing
data. If you’re writing a line-of-business application or something that’s otherwise very
data-heavy, I strongly recommend you consider using these controls. Both provide com-
monly understood UI metaphors in an easy-to-use package. You can do pretty much any-
thing you’d need to do with them more efficiently than writing analogous controls from
scratch, especially when you consider the annotations I’ll cover in the next section.
 Now that you’ve seen how to edit data in the DataGrid and DataForm, you’ll want
to impose some parameters for how the data is displayed. You can do this in code, but
it’s typically more efficient to use data annotations.  
17.3
Annotating for display
The DataForm and DataGrid both offer the ability to set the properties of columns
and labels, including things such as the display caption and tooltips. But if you share
the data between many instances of the controls, instances that may vary in their
display properties in other ways, it can be tedious and a maintenance burden to have
to repeat this configuration in multiple places.

429
Annotating for display
 Autogeneration of columns and labels often leaves you with even uglier results.
Sadly, many internal applications go into production with programmer-friendly but
user-unfriendly display properties because it was too much effort to keep the UI
updated and in sync with the data model.
 The System.ComponentModel.DataAnnotations assembly and namespace found
in the Silverlight SDK provide a number of attributes designed to make data validation
and display hinting easier for controls such as the DataForm and DataGrid and some
third-party controls. The approach taken by these attributes is to mark up the proper-
ties in your entities using attributes in code rather than require code within the prop-
erties or external to your entities.
 The two main attributes that I’ll cover are Display and Editable. In chapter 18,
you’ll take a look at the validation attributes and how they can further enhance the
DataGrid and DataForm.
17.3.1 The Display attribute
Both the DataGrid and the DataForm provide the capability to automatically generate
display and edit controls, and associated labels or column headers, at runtime. Though
the controls themselves offer a number of ways to customize the field information, there
are times when you’d be better served by a centralized definition of that metadata.
 One way to centralize that metadata is to annotate the properties on the entities
themselves. The assembly System.ComponentModel.DataAnnotations  provides a
number of attributes designed specifically for this purpose.
public class Person
{
...
  [Display(Name = "Registered",
    Description = "Check if this person has registered with us.")]
  public bool IsRegistered { get; set; }
  [Display(Name = "Marital Status",
    Description = "Optional marital status information.")]
  public MaritalStatus MaritalStatus { get; set; }
...
}
The result of including the Display attribute with the name and description can be
seen in figure 17.5. Note that the MaritalStatus field has its correctly formatted dis-
play name shown in the label, and the Registered field shows the information icon
with the associated tooltip containing the Description property.
Listing 17.10
The Person class with Display attributes attached
Figure 17.5
Portion of a DataForm showing the tooltips with the Description property of the 
Display attribute and the field captions pulled from the Name property of the same attribute

430
CHAPTER 17
Data controls: DataGrid and DataForm
The DisplayAttribute enables you to control a number of aspects of the onscreen
representation of the control, above and beyond the field label and the tooltip. It can
control whether the field is automatically generated as a column in the DataGrid or
field in the DataForm. It can also control the order the fields are displayed in or infor-
mation on the string to use when localizing. Table 17.9 lists the properties available. 
In several instances in table 17.9, I wrote that a property is “typically used as” some-
thing or other. The DisplayAttribute simply contains data; it doesn’t provide behav-
ior or any enforcement of proper use. It’s up to the consuming control—typically a
DataGrid, DataForm or a third-party control—to decide how that data will be used.
 In addition to the DisplayAttribute and its properties, one final important attri-
bute-based setting you have as a developer is the ability to mark individual properties
as editable or read-only.
17.3.2 The Editable attribute
On occasion, you may want to designate certain properties as read-only from a UI
point of view but still allow them to be manipulated via code. One way to handle that
is to provide an accessor (property get) with no corresponding property set and then
Table 17.9
DisplayAttribute properties and their uses
Property
Description
AutoGenerateField 
Set this value to false if you don’t want controls like the DataForm to 
automatically generate a control for this property.
AutoGenerateFilter 
Set to true if you want the filtering UI automatically displayed for this field. 
It’s currently unused by the DataGrid and DataForm controls.
Description 
A resource name or regular text that will be displayed by the rendering con-
trol. In the case of the DataForm, this shows up in a tooltip over the infor-
mation icon.
GroupName 
A resource name or regular text to display as the heading for a group of 
related fields. Currently unused by the DataGrid and DataForm controls.
Name 
A resource name or regular text to display as the name of this field. This is 
typically used in field labels.
Order 
Relative order for this field in display. By default, fields are displayed in the 
order they’re defined in the class. This property allows you to override that 
behavior.
Prompt 
Specifies a prompt, such as a watermark, to use when displaying this field. 
Currently unused by the DataGrid and DataForm controls.
ResourceType 
If you intend to use localized resources, specify the type container for 
those resources here.
ShortName 
A resource name or regular text to display as the name of this field. This is 
typically used in column headers.

431
Summary
provide an explicit mutator method. Unfortunately, that makes the programming
interface more cumbersome. 
 Another approach is to provide a normal property getter and setter but mark the
property as read-only at the UI level. Like the Display attribute discussed in the previ-
ous section, you could certainly do this on a form-by-form basis. But you may want to
instead centralize this information on the entity itself, as shown next.
public class Person
{
...
  [Display(Name = "Marital Status",
      Description = "Optional marital status information.")]
  [Editable(false)]                          
  public MaritalStatus MaritalStatus { get; set; }
...
}
In this example, you’ve marked the Marital Status field as read-only by applying an
EditableAttribute with the editable flag set to false. The result will be an onscreen
field that’s disabled, as shown in figure 17.6.
 The figure shows the Marital Status field disabled. Note also that its information
icon isn’t displayed, even though you’ve included a display description. The display of
the field control itself will depend on the disabled state for the control in use. This is
something that may be easily changed by editing the control template, as shown in
chapter 14.
 There are a number of other attributes in the DataAnnotations namespace,
including some specifically geared toward object-relational mapping (ORM). Take a
look around in there and you may find other attributes that can help with specific
challenges you’re facing in your applications.  
 Annotations are a powerful way to provide metadata for your entities. When com-
bined with annotation-aware controls like the DataForm and DataGrid, you can pro-
vide UI information such as field labels and help text, and control whether fields are
editable on forms and in grids. WCF RIA Services, covered in appendices E and F of
the ebook, provides other options for surfacing this metadata. 
17.4
Summary
For business and forms-over-data applications, the DataGrid and DataForm often form
the heart of the UI. Even nontraditional applications sometimes use heavily styled
Listing 17.11
Controlling editability using the Editable attribute
Editable 
attribute
Figure 17.6
The Marital 
Status field has been 
disabled because its 
underlying property is 
marked as read-only.

432
CHAPTER 17
Data controls: DataGrid and DataForm
DataGrids due to their rich programming model. Though the controls are complex,
they’re equally powerful and worth the time it takes to master them.
 The DataGrid is great for tabular data, whether it’s flat grid-style or contains
images or richer content. There are lots of options for the types of content it contains
as well as how you style both the content and the columns and rows that contain it.
When you need to display and edit data in a tabular form, look first to the DataGrid.
 The DataForm is the 90-degrees-off equivalent of the DataGrid, with columns shown
as fields rather than columns. Like the DataGrid, it can work on multiple rows of data,
but unlike the DataGrid, it shows only one at a time. Though certainly useful on its own,
the DataForm is often combined with the DataGrid for master-detail layouts.
 The DataGrid and DataForm both understand the display annotations such as the
Display and Editable attributes. These allow you to mark up your classes or buddy
partial classes to control the rendering of the controls in the grid and the form.
 Now that you’ve learned about binding (chapter 16) and the DataGrid and Data-
Form, let’s move on to validation. When you combine the grid, form, binding, and val-
idation, you’ll be well on your way to having a set of tools that cover the majority of the
data manipulation needs of a business application UI.

433
Input validation
The previous two chapters covered the binding system and some of its important
uses within Silverlight. The binding system is also so important because of the input
validation approaches in Silverlight built directly on it.
 Validation is something almost every nontrivial application with a TextBox will
need to do at some point. Often, you punt and do simple checking in the code-
behind. But if you want to truly leverage binding, take advantage of patterns such
as the ViewModel pattern, and have better structure to your code, you’ll want to use
one of the established validation mechanisms provided by Silverlight.
 Silverlight provides several ways to validate data. The simplest and oldest
approach is to use exception-based validation. In that approach, property setters
throw exceptions when the validation doesn’t pass. This is the code equivalent of
This chapter covers
■
Validating properties in code using exceptions
■
Using IDataErrorInfo and 
INotifyDataErrorInfo for validation
■
Controlling DataGrid and DataForm validation 
through attributes

434
CHAPTER 18
Input validation
my toddler’s spitting out the food she doesn’t like and, like that, anything more com-
plex than a couple of peas is going to get pretty messy.
 It wasn’t well-known, but Silverlight 2 included basic exception-based validation
capabilities. With the releases of Silverlight 3 and 4, these capabilities became more
advanced and the exception-based approach was looked at as more of a stopgap, use-
ful in only the simplest of validation scenarios. For those reasons, the majority of this
chapter focuses on the more modern approaches to validation, such as IDataError-
Info and INotifyDataErrorInfo.
 The IDataErrorInfo and INotifyDataErrorInfo interfaces are the newer
approach for validating data introduced in Silverlight 4. They’re a bit more complex
to implement. (When working with them, start out by creating helper classes to han-
dle all the goo. You’ll thank me for it; and, if you do want to thank me, donations and
chocolate are always welcome.) 
 One main difference with these interfaces, as opposed to an exception-based
approach, is how far you allow invalid data to get. With exception-based validation,
the accepted approach was to not complete the set operation if the validation fails.
Using the new interfaces, invalid data will often make it into the class and will need to
be removed or otherwise handled during the final validation or save processes.
 Due to the more flexible nature as well as decoupling from the property setters,
these interfaces also allow for cross-field validation, where changing the value of one
field can invalidate the value of another.
 The final approach to validation is geared to work with the DataGrid and Data-
Form covered in chapter 17—data annotations. In chapter 17, you saw that data anno-
tations can be used to control various aspects of display and even editability. This
chapter investigates the use of data annotations specifically for validation.
 First, you need to do a little setup work and establish a baseline class to use as your
source for the data in the UI: the Employee class. Once you have that set, you’ll learn
about exception-based validation and the shared validation presentation, and then
tackle synchronous and asynchronous validation with IDataErrorInfo and INotify-
DataErrorInfo. This chapter ends with a look at attribute-based validation as used by
the DataForm and DataGrid.
18.1
The validation example source and UI
Throughout this chapter, you’ll refer to the Employee class defined here, which will be
used as your binding data source. This class represents a fictional employee in a
human resources management system. 

435
The validation example source and UI
 The Employee class contains the public properties shown in table 18.1.
The class source code is shown in listing 18.1. Note that the Employee class imple-
ments the INotifyPropertyChanged interface to support binding change notifica-
tion, discussed in chapter 16.
public class Employee : INotifyPropertyChanged
{
  private string _lastName;
  public string LastName
  {
    get { return _lastName; }
    set 
    { 
      _lastName = value;
      NotifyPropertyChanged("LastName");
    }
  }
  private string _firstName;
  public string FirstName
  {
    get { return _firstName; }
    set 
    { 
      _firstName = value;
      NotifyPropertyChanged("FirstName");
    }
  }
  private int _level;
  public int Level
  {
    get { return _level; }
    set
    {
      _level = value;
      NotifyPropertyChanged("Level");
Table 18.1
Employee class properties
Property
Description
Last Name
The employee’s last (or family) name
First Name
The employee’s first (or given) name
Level
The employee’s salary level
 This puts the employee into specific salary “buckets.”
Salary
The salary, in USD, for this employee
Listing 18.1
Employee class to be used in the validation examples

436
CHAPTER 18
Input validation
    }
  }
  private decimal _salary;
  public decimal Salary
  {
    get { return _salary; }
    set 
    { 
      _salary = value;
      NotifyPropertyChanged("Salary");
    }
  }
  #region INotifyPropertyChanged Members
  public event PropertyChangedEventHandler PropertyChanged; 
  protected void NotifyPropertyChanged(string propertyName)
  {
    if (PropertyChanged != null)                  
      PropertyChanged(this, 
                new PropertyChangedEventArgs(propertyName));
  }
  #endregion
}
I included the INotifyPropertyChanged implementation here to help these exam-
ples stand on their own, but you could build off the Observable class introduced in
the previous chapters.
 You won’t see validation in action unless you wire up some UI, so you’ll build a
basic user interface that works against a single instance of the Employee class. You’ll
keep it simple and use code-behind, but I refer you to appendix C of the ebook for
best practices on structuring your application using the ViewModel pattern. The
XAML and C# for the UI are shown next.
XAML:
<UserControl x:Class="ValidationExample.MainPage"
     xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
  xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
  xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
  mc:Ignorable="d"
  d:DesignHeight="190"
  d:DesignWidth="350">
  <UserControl.Resources>                         
    <Style TargetType="TextBlock">
      <Setter Property="VerticalAlignment" Value="Center" />
      <Setter Property="HorizontalAlignment" Value="Right" />
      <Setter Property="Margin" Value="4" />
    </Style>
    <Style TargetType="TextBox">
      <Setter Property="VerticalAlignment" Value="Center" />
      <Setter Property="HorizontalAlignment" Value="Left" />
Listing 18.2
User interface XAML and code-behind to use for validation examples
PropertyChanged 
event
Property Changed 
helper code
Styles

437
The validation example source and UI
      <Setter Property="Margin" Value="4" />
      <Setter Property="Height" Value="22" />
      <Setter Property="Width" Value="200" />
    </Style>
  </UserControl.Resources>
  <Grid x:Name="LayoutRoot" Background="White" Margin="20">
    <Grid.ColumnDefinitions>
       <ColumnDefinition Width="*" />
       <ColumnDefinition Width="2*" />
    </Grid.ColumnDefinitions>
    <Grid.RowDefinitions>
       <RowDefinition Height="Auto" />
       <RowDefinition Height="Auto" />
       <RowDefinition Height="Auto" />
       <RowDefinition Height="Auto" />
       <RowDefinition Height="Auto" />
    </Grid.RowDefinitions>
    <TextBlock Grid.Row="0" Grid.Column="0"
               Text="Last Name" />
    <TextBox Grid.Row="0" Grid.Column="1"
             Text="{Binding LastName, Mode=TwoWay}" />                  
    <TextBlock Grid.Row="1" Grid.Column="0"
               Text="First Name" />
    <TextBox Grid.Row="1" Grid.Column="1"
             Text="{Binding FirstName, Mode=TwoWay}" />                 
    <TextBlock Grid.Row="2" Grid.Column="0"
               Text="Level" />
    <TextBox Grid.Row="2" Grid.Column="1"
             Text="{Binding Level, Mode=TwoWay}" /> 
    <TextBlock Grid.Row="3" Grid.Column="0"
               Text="Salary" />
    <TextBox Grid.Row="3" Grid.Column="1"
             Text="{Binding Salary, Mode=TwoWay}" />  
    <Button x:Name="SubmitButton" Grid.Row="4" Grid.Column="1" 
            Content="Submit"
            Margin="4"
            HorizontalAlignment="Left"
            Width="100"/>
  </Grid>
</UserControl>
C#:
public partial class MainPage : UserControl
{
  private Employee _employee = new Employee();
  public MainPage()
  {
    InitializeComponent();
    Loaded += new RoutedEventHandler(MainPage_Loaded);
  }
  void MainPage_Loaded(object sender, RoutedEventArgs e)
  {
    this.DataContext = _employee;
  }
}
Binding 
statements

438
CHAPTER 18
Input validation
The UI includes four text boxes, each with a
label. There’s also a Submit button, but it’s
there only for aesthetic purposes; all of your
validation will happen on lost focus (blur for
you web folks). The resulting form should
look like figure 18.1. Note that Level and Sal-
ary both show 0; this shows that binding is
working for those fields.
 That sets up a basic single-entity data
entry form you can use for the validation
examples included in this chapter minus the ones specific to the DataForm and
DataGrid. Throughout this chapter you’ll modify various aspects of the Employee
class, as well as the binding statements in the form XAML. As you move through the
examples, it may be helpful to refer back to these listings.
 The first type of validation you’ll look at is also the simplest and the one with the
most history: exception-based validation. 
18.2
Exception-based property validation
Although Silverlight 2 included basic exception-based validation capabilities, subse-
quent releases built on that to provide much more advanced, standardized, and flexi-
ble mechanisms for validating bound data, in an easy-to-template way. The binding
syntax continues to use the ValidatesOnExceptions parameter to enable the display
of validation messages when a property setter raises an exception, but the built-in con-
trol templates have been updated to provide appropriate display of error state.
 It’s worth covering exception-based validation, although it’s not widely used, for
those times when it really is the most appropriate approach. It’s also necessary to
understand so you can respond to the built-in type validation exceptions. 
 In this section, you’ll look at the basics of using exception-based validation both for
your own errors and built-in system errors and then move on to custom validation code
and combining multiple validation messages. I’ll wrap up this section with a look at the
built-in Validation UI in Silverlight, something that applies to all forms of validation.
18.2.1 Handling exception validation errors
Even if you don’t plan to have your own exception-based validation errors, it’s worth
handling them in order to get the benefits of automatic type checking. Binding with
exception-based validation enabled, in its simplest form, looks like this:
<TextBox Grid.Row="0" Grid.Column="1"
         Text="{Binding LastName, Mode=TwoWay, 
               ➥ ValidatesOnExceptions=True}" />
The example binds the TextBox to the LastName property of the object that’s the cur-
rent data context. The ValidatesOnExceptions parameter tells the binding system to
report any binding exceptions to the TextBox.
Figure 18.1
Runtime view of the 
validation form

439
Exception-based property validation
 One nice side effect of this is that you get data type validation for free. For exam-
ple, if you try to enter letters into a decimal property such as the Salary field, you’ll
get a type mismatch validation error. 
 In addition to simple data type validation, you can perform virtually any type of val-
idation you want by writing a little code inside the property setter.
18.2.2 Custom validation code
Referring to the Employee class from listing 18.1, let’s modify the LastName property
to perform some basic validation. You’ll make the last name a required field and then
make sure it has a length of at least two characters:
public string LastName
{
  get { return _lastName; }
  set
  {
    if (string.IsNullOrEmpty(value))
      throw new Exception("Last Name is a required field.");
    if (value.Trim().Length < 2)
      throw new Exception("Name must be at least 2 letters long.");
    _lastName = value;
    NotifyPropertyChanged("LastName");
  }
}
For brevity, you’re using the base Exception class for your validation errors. In prac-
tice, you’ll want to be less generic with your exception types, just as you would when
throwing exceptions for hard errors in code. In order for this code to work, you’ll
need to run without debugging (or ensure the appropriate IDE debugging break
options are set, now a default in Visual Studio 2010); otherwise, you’ll hit a break in
the property setter. 
COMBINING VALIDATION MESSAGES
In your setter, you have two guard conditions that throw exceptions when unmet.
Because these are real exceptions, the first one hit will pop out of the setter. If you
want to have more than one validation rule checked simultaneously, you’ll need to
combine your checks and throw only a single exception, perhaps like this:
private string _lastName;
public string LastName
{
    get { return _lastName; }
    set
    {
        string message = string.Empty;
        bool isOk = true;
        if (string.IsNullOrEmpty(value))
        {
            message += "Last Name is a required field. ";
            isOk = false;
        }

440
CHAPTER 18
Input validation
        if (value.Trim().Length < 5)
        {
            message += "Last Name must be at least 2 letters long. ";
            isOk = false;
        }
        if (isOk)
        {
            _lastName = value;
            NotifyPropertyChanged("LastName");
        }
        else
        {
            throw new Exception (message.Trim());
        }
    }
}
Admittedly, that’s a hack, especially once you have more than a couple of rules associ-
ated with a single field. If you want to stick with exception-based validation, you’re
forced to live with the limitations imposed by an exception-based system, including
both single checks and the debugging hassles.
18.2.3 Validation error display
When you bind the TextBox to the instance of the Employee class with the simple (one
message) exception-based validation code in-place, change the binding statement to
validate on exceptions as shown earlier, and try to enter data that violates the rules,
you’ll get an experience like that shown in figure 18.2 when you tab off the field.
 Like almost everything else in Silverlight, the display of the validation error tooltip
and the error state of the TextBox are both completely customizable by editing the
control template. Chapter 14 covered styling and control templates. 
 Validation using exception code inside properties can be convenient, but it cer-
tainly doesn’t look clean. It makes debugging sometimes difficult because there are
exceptions on the stack. Another issue is that validation errors can only be raised
when a setter is called, not in response to another action such as the changing of a
value in a related field. And, truthfully, many of us just have an aversion to using
exceptions for business or validation rules.
 Silverlight 4 introduced the IDataErrorInfo and INotifyDataErrorInfo inter-
faces. These interfaces help eliminate some of the issues present with exception-based
validation because they have a completely different exception-free implementation.
The same styling guidelines and error display features still apply. In addition, they
offer some features, such as asynchronous validation, that would be cumbersome or
impossible to implement in an exception-based model.  
Figure 18.2
Default binding validation error display for the Last Name TextBox, 
illustrating a custom error message

441
Synchronous validation with IDataErrorInfo
18.3
Synchronous validation with IDataErrorInfo
IDataErrorInfo was introduced in order to address some of the concerns raised by
exception-based validation. Unlike exception-based validation, there are no excep-
tions on the call stack when validation fails. This approach is also more flexible when
it comes to setting validation errors for individual fields, regardless of whether their
setters are called.
 I’ll start the discussion of IDataErrorInfo by taking a look at the interface mem-
bers and the binding statement. Then you’ll learn how to handle simple validation
errors. Once you have the right approach for handling simple validation errors, I’ll
show you something that IDataErrorInfo can do that was difficult with exception-
based validation: cross-field validation errors. Finally, because you’ll want to combine
the built-in type checking with your custom validation errors, you’ll see what it takes to
combine IDataErrorInfo validation with exception-based validation.
18.3.1 The IDataErrorInfo interface
Located in the System.ComponentModel namespace, the IDataErrorInfo interface is
meant to be implemented by any class you want to use as a binding source and also
want to have surface validation errors.
 The IDataErrorInfo interface contains two properties: Error and Item, described
next.  
You can already see how this is going to provide more options than the exception-
based approach. With a simple collection of messages, you can add and remove them
using code in any place in your class. In addition, the class-scoped error message lets
you provide errors that are difficult to attach to any single property. 
BINDING WITH VALIDATESONDATAERRORS
In return for this flexibility, you’ll need to write a bit more code. Before you do that,
though, you need to modify the form XAML so that it responds to the IDataErrorInfo
errors rather than the exception-based errors. The binding statement for each Text-
Box should look like this:
Text="{Binding LastName, Mode=TwoWay, ValidatesOnDataErrors=True}"
Note the ValidatesOnDataErrors property versus the ValidatesOnExceptions prop-
erty. As the name suggests, setting ValidatesOnDataErrors to true tells the binding
Table 18.2
IDataErrorInfo members
Property
Description
Error 
Set this to have a single error message that 
applies to the entire object.
Item, [] 
A collection of errors, indexed by property name. 
Set these to have errors specific to individual 
fields. This is also the indexer for the class.

442
CHAPTER 18
Input validation
system to watch the IDataErrorInfo interface on your class and respond to any errors
reported.
 Now that the binding is set up for each of the TextBox instances on the form, you
can get to the actual validation code. You’ll put the validation code inline in the
Employee class. Once you have experience with it, you may want to pull the common
validation helper code out into a separate class, called from your entities.
18.3.2 Simple validation with IDataErrorInfo
The first thing to do is to implement IDataErrorInfo in the class. The modifications
to the Employee class to do this look like listing 18.3.
public class Employee : INotifyPropertyChanged, IDataErrorInfo
{
  ...
  #region IDataErrorInfo Members
  private string _dataError = string.Empty;
  string IDataErrorInfo.Error            
  {
    get { return _dataError; }
  }
  private Dictionary<string, string> _dataErrors = 
                       new Dictionary<string,string>();
  string IDataErrorInfo.this[string columnName] 
  {
    get                                                
    {
      if (_dataErrors.ContainsKey(columnName))
        return _dataErrors[columnName];
      else
        return null;
    }
  }
  #endregion
}
The Dictionary of strings holds the field-level error messages, whereas the single
string property holds the class-level error message. To keep the Employee class imple-
mentation somewhat cleaner, I implemented the interface explicitly. This avoids show-
ing the error-related properties to code using the Employee class directly. To try out
the interface, you’ll implement the same validation you did in the simple exception-
based validation example and check the length of the LastName field:
public string LastName
{
  get { return _lastName; }
  set
  {
    if (string.IsNullOrEmpty(value))
Listing 18.3
Implementing IDataErrorInfo in the Employee class
Class-level error
property
Field-level error 
property

443
Synchronous validation with IDataErrorInfo
      _dataErrors["LastName"] = "Last Name is required";
    else if (value.Trim().Length < 2)
      _dataErrors["LastName"] = 
             "Last Name must be at least 2 letters long.";
    else
      if (_dataErrors.ContainsKey("LastName"))
        _dataErrors.Remove("LastName");
    _lastName = value;
    NotifyPropertyChanged("LastName");
  }
}
There are two primary differences in the structure of this rule-checking code as
opposed to the exception-based code. First, you needed to include a branch that
clears the error when valid, and second, the rules as written let potentially bad data
into the class. The second difference is a matter of preference and business rules; you
may easily change it so the data is only set when valid. The former check is required
because the only thing the binding system uses to check for the presence of an error is
whether employee["FieldName"] returns a string or null.
 Running the application produces the same results as the exception-based version,
as it should. You changed only your implementation of validation at the business
object level, not the UI elements that display the results.
18.3.3 Cross-field validation with IDataErrorInfo
What about cases when you want to validate more than one field? Let’s say that you
need to ensure that an employee’s salary is in range when related to his or her level.
The valid salary ranges for each level are listed in table 18.3.
You could put this validation code in the setter for one of the fields, but unless you
include the check in both, you’re making the mistake of assuming the field data will
be input in a specific order. In cases like this, it’s better to pull the validation code out
into a common function and call it from both setters, as shown here.
private int _level;
public int Level
{
    get { return _level; }
    set
Table 18.3
Validation rules for salary and level
Level
Allowable salary range
100
50,000–64,999
101
65,000–79,999
102
80,000–104,999
Listing 18.4
Cross-field validation code using IDataErrorInfo

444
CHAPTER 18
Input validation
    {
        if (ValidateSalaryAndLevel(value, Salary))
        {
            _level = value;
            NotifyPropertyChanged("Level");
        }
    }
}
private decimal _salary;
public decimal Salary
{
    get { return _salary; }
    set 
    {
        if (ValidateSalaryAndLevel(Level, value))   
        {
            _salary = value;
            NotifyPropertyChanged("Salary");
        }
    }
}
private bool ValidateSalaryAndLevel(int level, decimal salary)
{
    if (level < 100 || level > 102)
    {
        _dataErrors["Level"] = "Level must be between 100 and 102";
        return false;
    }
    bool isValid = false;
    switch (level)                    
    {
        case 100:
            isValid = (salary >= 50000 && salary < 65000);
            break;
        case 101:
            isValid = (salary >= 65000 && salary < 80000);
            break;
        case 102:
            isValid = (salary >= 80000 && salary < 105000);
            break;
    }
    if (isValid) 
    {
        if (_dataErrors.ContainsKey("Level"))    
            _dataErrors.Remove("Level");                   
        if (_dataErrors.ContainsKey("Salary"))          
            _dataErrors.Remove("Salary");           
    }
    else                 
    {
        _dataErrors["Level"] = "Level does not match salary range";
        _dataErrors["Salary"] = "Salary does not match level";
    }
    return isValid;
}
Call validation 
function
Check for 
valid salary
Clear existing errors
Set new errors

445
Synchronous validation with IDataErrorInfo
In listing 18.4, you aren’t allowing invalid values into the class. Validation using this
interface makes that a simple choice to make. The code that makes that decision is
inside the properties themselves. 
 The ValidateSalaryAndLevel function is the meat of the validation for these two
properties. It takes in both the salary and the level (one of which will always be the
current value and the other an entered but not set value) and first validates the level,
and then validates that the salary falls within the correct range for the level. If so, it
clears any previous errors. If not, it sets new errors.
 One thing you may have noticed is the proliferation of magic strings (the property
names). When implementing this in your own code, you’ll want to either use con-
stants for the string names or use reflection to dynamically pull property names from
the classes. The former is quicker both to develop and at runtime; the latter is more
robust but slower.
 When run, the cross-field validation looks like figure 18.3. If not, you may have for-
gotten to add the ValidatesOnDataErrors property to your binding statement.
IDataErrorInfo is great, but one thing you lost in the process was the automatic
errors when validating the data types. To continue to support that, you’ll need to
return to exception-based validation.  
18.3.4 Combining exceptions and IDataErrorInfo
When you turned on ValidatesOnDataErrors, you removed the ValidatesOn-
Exceptions parameter. That’s used not just by your code but also by the built-in type
checking. For example, when you try to assign a string like "dfdf" to an int, you’ll
get an exception. That exception bubbles up, and if not handled by the binding sys-
tem, it disappears. 
 Luckily, this is easy to fix. Simply modify the binding statement to include both
parameters:
Text="{Binding Level, Mode=TwoWay, 
➥ ValidatesOnDataErrors=True, 
➥ ValidatesOnExceptions=True}"
When run, the result will look like figure 18.4. Note that, because the exception will
be thrown before your property setter code executes, this exception takes precedence
over your own validation code.
Figure 18.3
Cross-field validation showing errors for both salary and level
Figure 18.4
Built-in exception-based checking takes precedence over your code.

446
CHAPTER 18
Input validation
Using both modes gives you the best of both worlds: you don’t need to handle basic
type checking, and you get more robust validation support for your own custom code.
IDataErrorInfo is a powerful interface for surfacing your own validation errors. It
provides a way to surface errors for the entire class or for individual fields. It also
makes it possible to perform cross-field validation or multifield validation without
invoking all involved property setters through the binding system. 
 It’s not without its faults, though. String-based property access can get you into
trouble when you refactor (or have a typo), and the validation code is all synchronous,
run on the client. There are tricks for working around the string-based problem (con-
stants, reflection), but what do you do when you want to validate through a service or
do some other long-running validation call? For those instances, you have INotify-
DataErrorInfo.   
18.4
Asynchronous validation with INotifyDataErrorInfo
IDataErrorInfo is a synchronous operation validation approach. Though you can
bend it to surface errors in an asynchronous way, it’s not optimized for that. In addi-
tion, IDataErrorInfo doesn’t support having multiple errors for a single property.
INotifyDataErrorInfo solves both of these issues. Though similar in concept to
IDataErrorInfo, its design specifically supports asynchronous validation and the
method for returning validation errors supports multiple errors for a single field. 
 I’ll start our coverage of INotifyDataErrorInfo with the interface members and
show you how to implement them in your own class. Then you’ll move on to the mod-
ifications required in the binding statement. Next, because you’ll need to show asyn-
chronous validation, you’ll implement a simple WCF-based web service. Finally, you’ll
implement an asynchronous validation function to call the service and call that from
your class.
18.4.1 The INotifyDataErrorInfo interface
Like the IDataErrorInfo interface, the INotifyDataErrorInfo interface is located in
the System.ComponentModel namespace. The interface has only three members, as
shown in table 18.4, and is conceptually similar to IDataErrorInfo but optimized for
asynchronous operation.
Table 18.4
INotifyDataErrorInfo members
Member
Description
GetErrors
This is a method that returns all of the validation errors for a specific field. If the 
propertyName parameter is null or string.Empty, the method returns 
errors for the entire object.
HasErrors
This is a property that returns true if the object has errors; false otherwise.
ErrorsChanged
This is an event similar to the PropertyChanged event in binding. Whenever 
you add, remove, or change errors, you must raise this event to notify the 
binding system.

447
Asynchronous validation with INotifyDataErrorInfo
One difference from IDataErrorInfo you’ll immediately notice is the addition of the
event ErrorsChanged. Because INotifyDataErrorInfo is meant to be used in asyn-
chronous validation scenarios, it uses an event-based mechanism for notifying listen-
ers of new validation errors.
GetErrors will require the most setup because you need a backing store with a col-
lection of validation error messages for each field you’ll validate.
NOTE   Silverlight will call GetErrors on each public member of your class, even
if you don’t explicitly support listening to INotifyDataErrorInfo in every
given binding statement. Be sure to handle this situation in your own code.
18.4.2 Implementing the interface
As was the case with IDataErrorInfo, the increase in flexibility means an increase in
code. The interface itself is simple enough, but behind that, you must maintain sev-
eral collections in order to surface the errors. 
public class Employee : INotifyPropertyChanged, INotifyDataErrorInfo
{
...
  #region INotifyDataErrorInfo Members
  private Dictionary<string, ObservableCollection<string>>
                _validationErrors;     
  private ObservableCollection<string> 
                _classValidationErrors;          
  public event EventHandler<DataErrorsChangedEventArgs> ErrorsChanged;
  public Employee()                                
  {
    _validationErrors = 
      new Dictionary<string, ObservableCollection<string>>();
    _classValidationErrors =
      new ObservableCollection<string>();
    CreateErrorsCollection("Level");
    CreateErrorsCollection("Salary");
  }
  private void CreateErrorsCollection(string propertyName)
  {
    if (!_validationErrors.ContainsKey(propertyName))
    {
       _validationErrors.Add(propertyName, 
         new ObservableCollection<string>());
    }
  }
  IEnumerable INotifyDataErrorInfo.GetErrors(string propertyName)
  {
    if (!string.IsNullOrEmpty(propertyName))
    {
      if (_validationErrors.ContainsKey(propertyName))
Listing 18.5
INotifyDataErrorInfo implementation
Declare field and class
error collections
Create errors 
collections

448
CHAPTER 18
Input validation
        return _validationErrors[propertyName];   
      else
        return null;
    }
    else
    {
      return _classValidationErrors;
    }
  }
  bool INotifyDataErrorInfo.HasErrors
  {
    get                                      
    {
      return _classValidationErrors.Count > 0 ||
        _validationErrors.Values.Any(errs => errs.Count > 0);    
    }
  }
  #endregion
}
Listing 18.5 shows all that’s needed for the interface. I included the code for it but I
rarely—if ever—bother with class-level errors, preferring instead to light up specific
fields. Your mileage may vary.
18.4.3 Binding support
In addition to implementing the interface, you must modify the binding on the fields
to support listening to the INotifyDataErrorInfo interface, just as you did with the
other validation approaches:
Text="{Binding LastName, Mode=TwoWay,
➥ ValidatesOnNotifyDataErrors=True}"
The next step is to create code to do the actual validation. Let’s assume that the salary
and level validation requires a web service call rather than a simple in-code lookup
table. The web service may call out to a rules engine or may simply look up values in
the database.
18.4.4 Building the WCF web service
In the web project associated with this Silverlight project, add a folder called Services
and add to it a new Silverlight-enabled WCF service called ValidationService. The
template is essentially a SOAP web service served up using WCF. You’ll find it easier to
use than full-blown WCF and more functional than an ASMX service. 
 Inside the service code, create a ValidateSalaryAndLevel method that looks like
listing 18.6; I’ll cover web services in more detail in chapter 20.
[OperationContract]                           
public bool ValidateSalaryAndLevel(int level, decimal salary)
{
  bool isValid = false;
Listing 18.6
WCF service code for ValidateSalaryAndLevel 
Return errors 
field
Check for 
existing errors
WCF operation 
contract

449
Asynchronous validation with INotifyDataErrorInfo
  switch (level)
  {
    case 100:
      isValid = (salary >= 50000 && salary < 65000);
      break;
    case 101:
      isValid = (salary >= 65000 && salary < 80000);
      break;
    case 102:
      isValid = (salary >= 80000 && salary < 105000);
      break;
  }
  return isValid;
}
For simplicity, I chose the simple route of returning a Boolean and left it up to the cli-
ent to assign the appropriate messages to the controls. You may decide instead to
return a class that has a Boolean indicating whether validation passed and then a col-
lection of error messages with field names or a couple of strongly typed properties
with the error messages for each field.
18.4.5 Adding the client service code
The next step is to add a service reference in your Silverlight project to the WCF web
service in the web project. Right-click the Silverlight project, select Add Service Refer-
ence, click Discover, and name the reference ValidationServices.
 Once the reference is added, add the client code from listing 18.7 into the
Employee class. 
private void ValidateSalaryAndLevelAsync(int level, decimal salary)
{
  var client = new ValidationServices.ValidationServiceClient();
  client.ValidateSalaryAndLevelCompleted += (o, e) =>
    {
      _validationErrors["Level"].Clear();          
      _validationErrors["Salary"].Clear();       
      if (e.Result)                  
      {
        _level = level;
        _salary = salary;
        NotifyPropertyChanged("Level"); 
        NotifyPropertyChanged("Salary");
      }
      else
      {
        if (level < 100 || level > 102)
        {
          _validationErrors["Level"]
          ➥ .Add("Level must be between 100 and 102.");
        }
Listing 18.7
ValidateSalaryAndLevelAsync in the Employee class
Clear existing errors
Set fields 
only if valid

450
CHAPTER 18
Input validation
        _validationErrors["Level"]       
        ➥ .Add("Level does not match salary range.");
        _validationErrors["Salary"]
        ➥ .Add("Salary does not match level.");
      }
      if (ErrorsChanged != null)               
      {
        ErrorsChanged(this, new DataErrorsChangedEventArgs("Level"));
        ErrorsChanged(this, new DataErrorsChangedEventArgs("Salary"));
      }
  };
  client.ValidateSalaryAndLevelAsync(level, salary);  
}
The ValidateSalaryAndLevelAsync class calls out to the web service and validates the
salary and the level. If the web service says the values are valid, the underlying fields
are updated. If it says the values are invalid, it sets up error messages for the fields. On
an invalid return, it also validates the level number itself. 
 There are other ways to handle this type of validation. For instance, you could have
a separate local level evaluation client method which you would call either asynchro-
nously or synchronously from the client. You could also have the web service return
error messages as part of the normal service call. 
 For simplicity, the web service client code is in the Employee entity class. I strongly
encourage you to separate this code out into a separate service client layer that’s, at
most, loosely coupled to the Employee entity. See chapter 33 on the MVVM pattern for
guidance on this and other topics.
18.4.6 Property modifications
The last step is to add the calls to ValidateSalaryAndLevelAsync. The following code
handles the property setting and the change notification inside the async method so
the setters are significantly simplified:
private int _tempLevel;
private int _level;
public int Level
{
  get { return _level; }
  set 
  { 
    _tempLevel = value;
    ValidateSalaryAndLevelAsync(value, Salary); 
  }
}
private decimal _tempSalary;
private decimal _salary;
public decimal Salary
{
  get { return _salary; }
  set 
  { 
Set error 
messages
Notify that 
errors changed
Call service 
method

451
Annotating for validation
    _tempSalary = value;
    ValidateSalaryAndLevelAsync(Level, value); 
  }
}
Note the _tempSalary and _tempLevel variables. Due to the asynchronous nature of
the validation, you need a place to store the possibly invalid values; otherwise, you could
never jump out of the validation error condition (one of the properties would always be
the default value during validation) and correct the data. These properties are where
you store the temporary values. Consider them “draft” or “unverified” values.
 Some caveats to the code I presented here. I don’t propose that these are best
practices or even stable for production code. The code has been simplified to show
the core concepts and stay within the reasonable bounds of a chapter. For example, in
the preceding code you may run into race conditions for multiple property changes
that happen during a slow-running web service call. If they happen to get queued out
of order, you can end up with skewed validation and entry. 
 The INotifyDataErrorInfo class implementation is more complex than the other
methods presented here. For that reason, you may prefer to implement it only on some
fields and use either exception-based or IDataErrorInfo on the remaining fields. The
choice is up to you; all the methods coexist nicely in the same class. The binding system
will know which ones to use based on the properties of the binding statement.
INotifyDataErrorInfo fills in the missing gap left by the other methods by
enabling you to provide asynchronous validation error reporting and supply multiple
validation messages for a single field.
IDataErrorInfo and INotifyDataErrorInfo are the premier ways of handling val-
idation in Silverlight, but they require a fair bit of code to implement. What if you want
to do something more lightweight? Do you need to turn to exceptions? No. If you’re
using the DataForm or DataGrid, you can annotate your data using validation attributes.    
18.5
Annotating for validation
There are innumerable ways to validate data and an equally diverse number of ways in
which to store that validation information, including the rules logic and the messages.
In section 18.2, you used exceptions in property setters to expose validation informa-
tion to the UI. In sections 18.3 and 18.4, you used specialized interfaces to support
additional forms of validation.
 Though you can continue to code validation directly into properties setters or use
interfaces, the System.ComponentModel.DataAnnotations assembly and namespace
found in the Silverlight SDK provide a number of attributes designed to make data val-
idation and display hinting easier for controls such as the DataForm, DataGrid, and
some third-party controls. The approach taken by these attributes is to mark up the
properties in your entities using attributes in code rather than require code within the
properties or external to your entities.
 If your scenario supports their use, validation attributes are simple to implement
and easy to use. In our discussion of these attributes, I’ll first go over the available set
of attributes and how to implement a select set of them in your own classes. Then,

452
CHAPTER 18
Input validation
you’ll extend the reach of the attributes to call out to external validation functions in
your code. Finally, you’ll create your own custom validators to handle situations not
easily handled by the built-in set. All of these techniques help you create validation
code that’s cleaner and easier to read than many of the other methods.
18.5.1 Validation attributes
Previously you saw how to provide property-level validation using exceptions and syn-
chronous and asynchronous interfaces. Though those work in almost any situation,
they’re not a very clean approach and lead to a significant amount of branch/check
code inside the property setters in your entities. They also require significant code
modification to your entities—a luxury you don’t always have. One better way to tackle
basic validation is to use attributes tied to the properties in the class. 
 To support attribute or annotation-based validation, the DataAnnotations
namespace includes the validation attributes shown in table 18.5.
Note that this namespace also defines the ValidationException type. You’ll recall
that in our earlier example you simply used System.Exception. With the introduction
of this DLL, you can now use the ValidationException rather than the base System.
Exception. But because this DLL provides so many other ways to handle validation, I
encourage you to try packaging your validation code either in a function used from a
CustomValidationAttribute or as a class derived from ValidationAttribute.
 I’ll only cover a handful of these attributes because the pattern is the same across
the set. In addition, only the DataGrid and DataForm (and a handful of third-party
Table 18.5
Validation attributes in System.ComponentModel.DataAnnotations
Validation attribute class
Validation capabilities
EnumDataTypeAttribute
Specifies that the value must be parsable as one of the mem-
bers of a specified enum.
RangeAttribute
Specifies that the value must be between two other values. The 
type can be any type that implements IComparable.
RegularExpressionAttribute
Enables you to associate a regular expression to validate a 
value. This is useful for things such as phone numbers and 
email addresses, as well as any other data that must adhere to 
one or more specific formats.
RequiredAttribute 
Specifies that the value for this property must be non-null and 
not empty.
StringLengthAttribute
Enables you to check the length of the value—it must be 
between the specified minimum and maximum length.
CustomValidationAttribute
A catchall validator that allows you to call custom code to per-
form the validation.
ValidationAttribute 
The abstract base class for all other validators. You can create 
your own validation attributes by deriving from this class.

453
Annotating for validation
controls) support these annotations, so these attributes aren’t necessarily a solution
for all applications.
18.5.2 Annotating your entity
If you take the same Person class you used for the DataForm examples in the previous
chapter, you can now mark it up to include basic validation capabilities. You’ll also add
two new properties: EmailAddress and NumberOfChildren. The final class, with appro-
priate validation attributes in place, looks like listing 18.8.
public class Person
{
  [Required]
  [StringLength(25)]
  public string LastName { get; set; }
  [Required]
  [StringLength(25)]
  public string FirstName { get; set; }
  [Required]
  public DateTime DateOfBirth { get; set; }
  public bool IsRegistered { get; set; }
  public MaritalStatus MaritalStatus { get; set; }
  [Required]
  [StringLength(320)]
  [RegularExpression(@"^[a-zA-Z][\w\.&-]*[a-zA-Z0-9]@[a-zA-Z0-9]
  ➥ [\w\.-]*[a-zA-Z0-9]\.[a-zA-Z\.]*[a-zA-Z]$")]
  public string EmailAddress { get; set; }
  [Range(0, 20)]
  public int NumberOfChildren { get; set; }
}
Note that email address validation
is complicated, and I don’t pres-
ent the regular expression used
here as a fully correct version of
an email validation expression,
just as an example. 
 If you then load up the Data-
Form you used in the earlier exam-
ples and let it autogenerate the
fields based on the updates to the
Person class, you get the result
shown in figure 18.5.
 The validation attributes may
be used both with the DataGrid
and with the DataForm and with
some third-party controls. There
are workarounds to use some of
Listing 18.8
The Person class with validation attributes in place
Figure 18.5
The DataForm with validation rules in 
place, showing the validation summary and default 
validation messages

454
CHAPTER 18
Input validation
the attributes in your own code, without altering the controls themselves, but they’re
neither robust nor fully implemented, so I won’t include them here.
18.5.3 Calling external validation functions
One of the validation attributes that could be used in your entities is the Custom-
ValidationAttribute. This attribute takes as parameters a .NET type and the string
name of a method to call on that type. 
 If you wanted to extend your Person class to only allow names that begin with B,
you could create a simple validation method and class like listing 18.9.
public class CustomValidationMethods
{
  public static ValidationResult NameBeginsWithB(string name)
  {
    if (name.StartsWith("B"))
      return ValidationResult.Success;
    else
      return new ValidationResult("Name does not begin with 'B'");
  }
}
The static method simply needs to take in the appropriate type and return a
ValidationResult indicating whether the value passed validation. You then wire it up
to your Person class using the CustomValidationAttribute like this:
[CustomValidation(typeof(CustomValidationMethods),
    "NameBeginsWithB"]
public string LastName { get; set; }
The ValidationResult class is defined in the same namespace where the other data
annotations are defined: the System.ComponentModel.DataAnnotations namespace.
The class is interesting in that it contains all the information needed to represent the
result of a validation function. Table 18.6 shows the members of this class.
Listing 18.9
A simple custom validation function
Table 18.6
ValidationResult members
Member
Description
ErrorMessage
Property that represents the single error message from the validation function.
MemberNames
A collection of one or more properties of the class that was validated. Use this 
to allow the binding system to associate the error message with the correct 
on-screen fields. Optional but recommended when the validation affects more 
than one member.
Success
A static property that’s used to indicate success. In code, this looks almost 
like an enumeration, but it’s simply there to allow you to always return a 
ValidationResult, even when there’s no error message. Always return 
Success when validation succeeds, and never return a null 
ValidationResult.

455
Annotating for validation
You’ll use the Validation-
Result class in this chapter
when creating custom valida-
tion functions. It’s useful in
that the binding and valida-
tion systems understand how
to work with it.
 When validation is per-
formed on the field, your cus-
tom function will be called and
you’ll get a validation error
message that contains the text
supplied in the Validation-
Result or, if provided, the
custom error message tied to
that instance of the Custom-
ValidationAttribute. Figure
18.6 shows an example.
 The custom validation
function has an alternate sig-
nature that’s worth consideration. In addition to taking in the value to be validated, it
can take as a parameter a value of type ValidationContext. ValidationContext pro-
vides additional information that the validation function may wish to use either in
building the error message or in performing the actual validation. Taking the previ-
ous example and adding the context property results in the validation function shown
in listing 18.10.
public static ValidationResult NameBeginsWithB(
    string name, ValidationContext context)
{
    if (name.StartsWith("B"))
        return ValidationResult.Success;
    else
        return new ValidationResult(
            string.Format("{0} does not begin with 'B'", 
            context.DisplayName));
}
You used the DisplayName from the context to make the error message a little more
meaningful. The resulting error on the DataForm looks like figure 18.7.
Listing 18.10
A custom validation function with ValidationContext
Figure 18.6
The Last Name field failed our custom validation 
check, as indicated in the error message at the bottom. Note 
that the field name isn’t included in the error message.
Figure 18.7
The enhanced 
error message with field 
name courtesy of the 
ValidationContext

456
CHAPTER 18
Input validation
As shown in the listing, the ValidationContext class1 can provide useful information
that will help you during validation. Table 18.7 shows the important members of the
ValidationContext class.
Because ValidationContext also supplies you with the parent object to which the
member being validated belongs, you can use custom validation functions to effec-
tively extend the validation system to support cross-field validation checks. You’ll need
to be careful so that you don’t find yourself in the circular dependency hole that many
cross-field checks ultimately end in. 
 Custom validation functions are a nice way to extend the validation system.
They’re simple to use and simple to create. Their main downside is they have external
dependencies and, therefore, aren’t entirely self-contained. In addition, the method
name is a string and can be prone to typos or errors resulting from refactoring. To cre-
ate more robust validation code, you’ll want to create a custom validator.  
18.5.4 Creating custom validators
Similar in concept to custom validation functions, custom validators are classes you
write that inherit from ValidationAttribute in the System.ComponentModel. Data-
Annotations namespace. The code itself is almost identical to what you’d write in a
custom validation method. Listing 18.11 shows our custom validation code packaged
into a custom validation attribute.
public class NameBeginsWithBAttribute : ValidationAttribute
{
  protected override ValidationResult IsValid(    
    object value, ValidationContext validationContext)
  {
    if (!(value is string))              
1 The ValidationContext class was introduced by the RIA Services team, but proved so useful, it was incorpo-
rated into the Silverlight product itself.
Table 18.7
The ValidationContext class
Member
Description
DisplayName
The display (user-friendly) name of the property being validated.
Items
Dictionary containing the items associated with the validation context. This 
is an arbitrary property bag that you can use to maintain state required for 
validation.
MemberName
The property name of the property being validated.
ObjectInstance
This is a pointer to the object being validated.
ObjectType
The Type of the object in the ObjectInstance property.
Listing 18.11
Custom validation attribute
Check for 
correct type

457
Comparison of validation approaches
      return new ValidationResult(
        "Incorrect data type. Expected string");  
        
    if (string.IsNullOrEmpty((string)value))       
      return ValidationResult.Success;
    if (((string)value).StartsWith("B"))        
      return ValidationResult.Success;
    else
      return new ValidationResult(
        string.Format("{0} does not begin with 'B'", 
        validationContext.DisplayName));
  }
}
The only thing you’re required to do is override the IsValid function and return an
appropriate ValidationResult. Once you do that, you can use the validator just like
you would any other:
[NameBeginsWithB()]
public string LastName { get; set; }
The end result is the same error message display you saw with the custom validation
function approach. But your validator is both simpler to use and less prone to break-
ing because it’s self-contained inside a custom validator attribute class.
 That’s attribute-based validation in a nutshell. If you can use the DataGrid and
DataForm as your primary controls, attribute-based validation is, by far, the easiest
approach to getting validation into your classes. Not only does the markup avoid code
in your class, but you can also add buddy classes (partial classes) to mark up existing
entities from your ORM.
 I’ll cover the enhanced cross-tier validation features brought by WCF RIA Services
in appendices E and F of the ebook. Until then, keep in mind that binding and valida-
tion are core Silverlight features and work without the addition of a framework such
as WCF RIA Services or a pattern such as MVVM (see chapter 33). 
18.6
Comparison of validation approaches
Let’s wrap up our discussion of validation by summarizing what I consider to be the
pros and cons of each validation method.
Table 18.8
Validation approach summary
Method
Pros
Cons
Exceptions
ValidatesOnExceptions=True
Free type validation
Simple inline code; no inter-
faces
Only invoked when property 
set; cross-field validation 
difficult or impossible
Only one error per field
Allow empty/null
Validate entry

458
CHAPTER 18
Input validation
These three main approaches to validation are universally supported in Silverlight,
requiring no special client-side control code or styles. Most third-party controls will
also respect these forms of validation.
 My recommendation are as follows:
■
Always support exceptions, so you get type checking.
■
Use attributes if you’re doing everything in a DataForm or DataGrid.
■
Use IDataErrorInfo if you’re doing all your validation on the client.
■
Use INotifyDataErrorInfo if you need to call out to services to perform the
validation.
Your specific situation may dictate a different solution, but the guidelines here will
apply to most applications. 
18.7
Summary
Input validation is a core requirement of almost every application with a TextBox.
Though Silverlight contains a number of different approaches, evolved over the ver-
sions, these are at least structured ways to handle validation. 
 For general Silverlight applications, exception-based validation is one of the easiest
approaches to use. It’s also limited, but if your validation requirements aren’t heavy, it
can often handle the job.
 For more robust implementations, turn to IDataErrorInfo and INotifyData-
ErrorInfo. The two can be complex to implement, especially the latter, but you’re
provided with pretty much everything you’d need to implement your own validation
framework on top of the base interfaces.
IDataErrorInfo
ValidatesOnDataErrors=True
Cross-field validation
No exceptions on the stack
Doesn’t handle type validation
Only one error per field
Slightly more complex imple-
mentation than exceptions
INotifyDataErrorInfo
ValidatesOnNotifyDataErrors
=True
Cross-field validation
No exceptions on the stack
Asynchronous validation
Multiple errors per field (note: 
current Silverlight UI tem-
plates only support showing 
the first error)
Doesn’t handle type validation
More complex implementation 
than exceptions
Validation attributes
No exceptions on the stack
Multiple validators per field
Simple
No code other than attribute
Only works with DataForm, 
DataGrid, and some third-
party annotation-aware controls
Table 18.8
Validation approach summary (continued)
Method
Pros
Cons

459
Summary
 When combined with the DataGrid and DataForm, attribute-based validation,
along with the UI hinting provided by the display annotations covered in chapter 17,
provides an incredibly simple and powerful way to create capable user interfaces with
little plumbing code required.
 Now that I’ve covered binding in chapter 16 and validation in this chapter and
introduced the concept of a web service, it’s time you dove right into the communica-
tions and networking stack that drives most Silverlight applications. The next five
chapters will cover how to use web and REST services as well as how to implement
other forms of communication in your applications. 

460
Networking basics
It’s truly rare these days to find an application that doesn’t use the network for
something. Client-side applications often phone home to check for updates, con-
nected applications rely on services for significant functionality, games check for
banned users and cheats across the wire, and business applications almost always
rely on data coming from a server somewhere.
 In chapter 1, I introduced networking in Silverlight by showing you how to cre-
ate a simple Twitter application. That example showed some of the simplest net-
work interactions used to call a REST-style service to grab some data. I hope that
example whetted your appetite to learn how networking works.
 Silverlight wouldn’t be a particularly useful product if it didn’t include excellent
networking support. Networking is so important that this area is one of the only
This chapter covers
■
Asynchronous communication and Reactive 
Extensions
■
The web request and response pattern
■
Cross-domain concerns and data security
■
The browser and client networking stacks
■
Connectivity

461
The web request/response pattern
places in Silverlight where there are two parallel code branches that accomplish
approximately the same thing: two complete networking stacks.
 The two stacks included in Silverlight are known as the browser HTTP stack and the
client HTTP stack. As their names indicate, the browser HTTP stack goes directly
through the browser for all networking calls, whereas the client HTTP stack doesn’t.
 Most networking operations, and certainly those using HTTP, are made up of a
request to the endpoint and a response from it. Silverlight formalizes this via the
WebRequest and WebResponse classes and their derivatives, as well as with the classes
that build on them, such as the WebClient.
 Web applications follow the request/response pattern with any resource. There
are specific concerns when it comes to whether the application is speaking to its own
site of origin or to another site on the network/internet. In Silverlight, like Flash and
Ajax, those concerns fall under the heading of cross-domain networking.
 Like cross-domain networking concerns, asynchronous communication isn’t
unique to Silverlight. Unless you’ve been a really advanced desktop app developer, or
you’ve done serious work with Ajax, you probably haven’t run across asynchronous
communication before. Silverlight, like many other web client technologies, requires
you to use an async pattern when accessing network resources. Because this is one of
the most fundamental concepts in Silverlight networking, I’ll start there.
 In this chapter, I’ll introduce in detail the underlying networking concepts and
objects on which the rest of Silverlight networking is built. I’ll discuss how to work
with asynchronous network calls using the request and response pattern. Because
asynchronous code can be a real bear to work with, I’ll investigate several approaches
to simplifying it. Then I’ll cover cross-domain networking, something that often trips
up first-time Silverlight developers. From there, I’ll dive into the two networking
stacks Silverlight offers: the browser stack and the client stack. Finally, I’ll look at how
to check to see if your application is online and connected to a network, a must for
out-of-browser and offline applications.
 By the end of this chapter, you’ll have the background information you need to
proceed to the next several chapters, which cover service calls and advanced network-
ing scenarios.
19.1
The web request/response pattern
When you visit a site on the web, your browser sends a request to the web server asking
for a specific resource, typically an HTML page. It also sends a request for each of the
images, JavaScript files, CSS files, background “Wind Beneath My Wings” MIDI files,
dancing hamster GIFs, and anything else referenced from the page.
 For each request, the server sends
back a response. That response is typically
the contents of the resource but could
also be an empty response with a status
code like 404 – Not Found. Figure 19.1
shows how networking on the web works. 
Client
Endpoint
Server
Endpoint
Request
Response
Figure 19.1
The web request/response pattern

462
CHAPTER 19
Networking basics
Network activities in Silverlight typically consist of the same two parts:1 the request
and the response. The request is the call you make to the network resource; the
response is what the network resource sends back to you. In Silverlight, that’s imple-
mented in the (Http)WebRequest and (Http)WebResponse classes using an asynchro-
nous pattern.
19.1.1 WebRequest and HttpWebRequest
The base class for most networking in Silverlight is the abstract WebRequest class. In
Silverlight, the only other class that inherits from WebRequest is the concrete Http-
WebRequest class, which resides in the same System.Net namespace. The full desktop
framework supports other derived classes, including FileWebRequest and FtpWeb-
Request.
 The WebRequest class serves as a factory for creating new instances of its descen-
dant classes. For example, to create an HttpWebRequest instance, you’d use the
Create or CreateHttp method. Primarily the Create method exists for compatibility
with the full .NET Framework. But CreateHttp guarantees an HttpWebRequest
whereas the former leaves open the possibility of other types of classes in the future.
 Listing 19.1 shows two ways to create a concrete HttpWebRequest. 
private void InitiateWebRequest()
{
    string uri = "http://localhost:47498/helloWorld.xml";
    var request = HttpWebRequest.Create(uri);
    var request2 = HttpWebRequest.CreateHttp(uri);
}
In listing 19.1, you have the Silverlight application running on the Visual Studio web
server on localhost, port 47498. In that same web server project, you have a file named
helloWorld.xml. These two methods look like they’d return the same type, because
they have the same endpoint URL.
 But unless you change the networking stack selection criteria, you’ll see that
request is returned as a BrowserHttpWebRequest and request2 is returned as a
ClientHttpWebRequest. This is true for both in-browser and out-of-browser applica-
tions. Both request objects are HttpWebRequests, but the underlying implementation
between the two is completely different. This can lead to difficult-to-diagnose bugs in
your application, so you’ll want finer control. I’ll go into more depth about creating a
specific networking stack in section 19.5.
1 Conceptually, sockets-based communication is a bit different, as you’ll learn in chapter 23. If you limit yourself
to HTTP communications, the request/response approach is king.
Listing 19.1
Two ways to create an HttpWebRequest

463
The web request/response pattern
19.1.2 WebResponse and HttpWebResponse
On the other side of the pattern lies the WebResponse, which like WebRequest, has
only a single directly derived class in the Silverlight subset of the .NET Framework:
HttpWebResponse.
 The WebRequest object represents the request sent to the server, and the Web-
Response object represents what the server sends back to you as a result. The Http-
WebResponse adds to the base class the properties shown in table 19.1.
In addition to those listed in the table, the HttpWebRequest class includes a number of
other properties and methods, all inherited from the WebRequest class. Of those, the
most important is the GetResponseStream method.
 The GetResponseStream method is used to get the byte stream containing the data
returned from the server. The data can be an image, a text file, or anything that can
be shipped over HTTP. What you do with the stream is entirely up to you.
Forcing Visual Studio to keep the web server port constant
When working with networking in Visual Studio, you’ll often have the endpoint address,
(including the port if it’s not the default 80 or 443) hard-coded in code, or as you’ll
see in the next chapter, stored in a configuration file. Normally, web projects in Visual
Studio dynamically allocate the endpoint port at localhost based on what’s available. 
In cases where you hang the web server and the port stays in use, the port will change
the next time you run the project. When that happens, it can be hard to diagnose why
you’re suddenly receiving 404 or other errors.
To get around this issue, right-click the web project in Visual Studio, and go to the
properties page. On the Web tab, you’ll see an option to either autoassign the port
or choose a specific port. Set it to use the specific port, and you can now guarantee
your port numbers won’t change.
Note that if you manage to hang the web server, your project won’t start because the
port will remain in use from the last run. In those cases, you’ll need to manually kill
the server by right-clicking the icon in your system tray.
Table 19.1
The HttpWebRequest additional properties
Property
Description
Cookies
Gets the collection of cookies sent back with the response
Method
Gets the HTTP method (for example, GET) that’s used to return the response
StatusCode
Gets the HTTP Status code returned from the web server; for example: OK
StatusDescription
Gets the description associated with the status code

464
CHAPTER 19
Networking basics
 You won’t create the HttpWebResponse instance directly. Instead, it will be
returned to you from the EndGetResponse method on the HttpWebRequest object.
Listing 19.2 shows the flow starting with creating the request all the way through to
calling EndGetResponse and displaying the results returned in the response.
public class RequestState                 
{
  public WebRequest Request { get; set; }
}
public partial class MainPage : UserControl
{
   public MainPage()
   {
      InitializeComponent();
      InitiateWebRequest();
   }
   private void InitiateWebRequest()
   {
      string uri = "http://localhost:47498/helloWorld.xml";
      var request = HttpWebRequest.Create(uri);
      request.BeginGetResponse((asynchronousResult   
      {
         var response = (HttpWebResponse)
                request.EndGetResponse(asynchronousResult); 
         var stream = response.GetResponseStream(); 
         using(var reader = new StreamReader(stream))
         {
            string xmlFileText = reader.ReadToEnd();  
            Debug.WriteLine("Status Code: " + 
                            response.StatusCode);
            Debug.WriteLine("Status Description: " + 
                            response.StatusDescription);
            Debug.WriteLine(xmlFileText);
         }
      }, null);
   }
}
This example shows how to send the request to the web server and handle the
response that comes back. I also included the RequestState class because it’s a best
practice to have your own state object rather than simply pass in the request itself as
the state.
Listing 19.2
The full request and response code
Define state class
Get response async
Get file contents
Convert to string

465
Simplifying the request/response pattern with WebClient
 Once inside the InitiateWebRequest method, you create the request as shown
earlier, create the custom state object, then initiate the asynchronous request, passing
in the state and a pointer to the ResponseCallback method.
 When the response is ready, the anonymous response callback method specified
via a lambda expression in the BeginGetResponseCall is called. Inside that method,
you finish receiving the rest of the response, and then get the stream containing the
file contents and read it into a string, which you then display in the output window
along with the status.
Run the application and look at the output window; you should see a status code of
OK and the contents of the XML file. If you receive a SecurityException instead, that
means you ran into a cross-domain problem.2 In that case, which I’ll cover in more
detail in a moment, you need to both make sure your port number is correct, and that
the web project, not the Silverlight project, is the startup project.
19.2
Simplifying the request/response pattern with WebClient
The HttpWebRequest and HttpWebResponse approach to networking is extremely
powerful. There will be times when it’s the easiest way (or the only way) to accomplish
a networking task.
 For typical service interactions and file downloads, though, there’s a slightly easier
class to use: the WebClient class. Rather than the callback approach, the WebClient
class uses a friendly event-driven approach to reporting the completion of the task. It
has simple methods for downloading a string, as well as getting a stream of the data
from the endpoint. The WebClient even has upload and download progress report-
ing, enabling you to report this information back to the user.
19.2.1 String operations
The simplest way to get text data from the web is to use the DownloadStringAsync
method. Listing 19.3 shows the WebClient version of listing 19.2, downloading a sin-
gle XML file from our local web project.
HTTP status codes
When using the browser networking stack, Silverlight returns only 404 and 200 status
codes regardless of the actual status code returned from the web server. If the server
has a 500 error, it will come back translated as a 404. This can be pretty hard to
debug, because you’re not always sure the error isn’t an actual 404. In these cases,
Fiddler (http://fiddler2.com) is your friend.
2 Actually, you more likely received a cross-scheme exception. That can happen when you run the Silverlight
application from a file:// URL and it tries to hit a site via the http:// scheme. But if you got the port number
wrong, you hit a true cross-domain problem.

466
CHAPTER 19
Networking basics
public partial class MainPage : UserControl
{
  public MainPage()
  {
    InitializeComponent();
    InitiateWebClientRequest();
  }
  public void InitiateWebClientRequest()
  {
    var client = new WebClient();
    client.DownloadStringCompleted += (s, e) => 
      {
        string xmlFileText = e.Result;
        Debug.WriteLine(xmlFileText);
      };
    var address = new Uri("/helloWorld.xml", UriKind.Relative);
    client.DownloadStringAsync(address);    
  }
}
This takes advantage of the DownloadStringAsync method to download the contents
of the XML file and report them back as a string. A huge portion of the content on the
web is text, so this method simplifies many of your typical network calls. 
 One other nice feature you get when using DownloadStringAsync is download
progress. Listing 19.4 adds another event handler to listing 19.3 to report progress to
the output window. Note that unless you have a huge file, you won’t see much of inter-
est here because it’ll download in a single chunk.
public void InitiateWebClientRequest()
{
  var client = new WebClient();
  client.DownloadStringCompleted += (s, e) =>
    {
      string xmlFileText = e.Result;
      Debug.WriteLine(xmlFileText);
    };
  client.DownloadProgressChanged += (s, e) =>  
    {
      Debug.WriteLine("Bytes Received: " + 
        e.BytesReceived + "/" + e.TotalBytesToReceive);
Listing 19.3
Downloading a file with the WebClient
Listing 19.4
Reporting download progress
Completed event
Start of download
Download progress

467
Simplifying the request/response pattern with WebClient
      Debug.WriteLine("Percentage: " + e.ProgressPercentage);
    };
  var address = new Uri("/helloWorld.xml", UriKind.Relative);
  client.DownloadStringAsync(address);
}
Adding download progress reporting to the listing was extremely simple. All you had
to do was sync one more event, and the information became immediately available.
Normally, you’d use this to display information on a progress bar or similar UI con-
struct. On my machine, with this small file, the output window shows the following:
Bytes Received: 79/79
Percentage: 100
Bytes Received: 79/79
Percentage: 100
<?xml version="1.0" encoding="utf-8" ?>
<entry>
  Hello World!
</entry>
Why are there are two calls with identical output? There are two calls to the progress
event because one is for the chunk and one is for the whole file. Because the whole
file came down in one pop, the values are identical.
 The DownloadStringAsync method has a corresponding UploadStringAsync,
which enables you, as you may have guessed, to send a string to a specific URI. Table
19.2 shows the main methods and properties of interest.
Table 19.2
Interesting properties and methods of the WebClient
Member name
Description
AllowReadStreamBuffering
AllowWriteStreamBuffering
Property that enables buffering for the OpenReadAsync and 
OpenWriteAsync methods covered in this section. Defaults 
to true.
Base Address
The base URI for all requests (optional property).
CancelAsync
Function that enables you to cancel a request. The completed 
event for the request will still be raised. Check the Cancelled
property in the event args to see if the request was canceled.
Credentials
An ICredentials-implementing object that contains the creden-
tials to be sent with the request. Use UseDefaultCredentials
to send in the credentials of the currently authenticated user (client 
HTTP stack only).
DownloadStringAsync
UploadStringAsync
Enables downloading and uploading text information to an HTTP 
endpoint. This could be a page, or a REST service, or SOAP ser-
vice, or anything else you desire.
Encoding
Sets the encoding for uploading and downloading strings. Defaults 
to UTF-8.

468
CHAPTER 19
Networking basics
Logically, REST results and even SOAP envelopes are just strings. You can use the Web-
Client to create your own complete higher-level protocol client if you wish. As you’ll
see in chapters 20 and 21, you probably don’t want to reinvent that, but it’s still possible.
19.2.2 Stream operations
Not everything on the web is text. There will be times when you want to download a
binary file, such as a zip file containing application extensions or assets. In those cases,
you’ll want to use the OpenReadAsync method.
public void InitiateWebClientStreamRequest()
{
  var client = new WebClient();
  client.AllowReadStreamBuffering = true;       
  client.OpenReadCompleted += (s, e) =>
    {
      Stream stream = e.Result;
      byte[] bytes = new byte[stream.Length];
      stream.Read(bytes, 0, (int)stream.Length);  
      string xmlFileText = 
          Encoding.UTF8.GetString(bytes, 0, bytes.Length);
      Debug.WriteLine(xmlFileText);
    };
  var address = new Uri("/helloWorld.xml", UriKind.Relative);
  client.OpenReadAsync(address);
}
In listing 19.5, you download the same XML file as in the previous listings but do so
using a stream. Because it’s coming back as a stream of bytes, there are a few extra
steps you must take in order to get it into a string format. First, get the bytes from the
stream, and second, convert those bytes to a string using the proper encoding. In this
Headers 
ResponseHeaders
The headers to be sent up with the request, and the headers 
returned with the response. By default, optional headers are not 
sent with requests; if you need them, add them to the Headers
collection.
OpenReadAsync
OpenWriteAsync
The stream equivalents to DownloadStringAsync and 
UploadStringAsync. Note that these two methods don’t report 
progress.
Listing 19.5
Download a file as a stream
Table 19.2
Interesting properties and methods of the WebClient (continued)
Member name
Description
Set buffering
Read from stream

469
Asynchronous communication
case, the XML file is encoded using UTF-8, so you converted that properly. You can also
use a StreamReader to pull the stream contents into a string.
 Unlike the DownloadStringAsync method, which gets the entire string unless you
call CancelAsync, OpenReadAsync can be either buffered or unbuffered, as set by the
AllowReadStreamBuffering property of the WebClient. Note that if you don’t allow
buffering, stream seek and count operations will be limited. Luckily, buffering is
enabled by default.
 Just as with the DownloadStringAsync and UploadStringAsync methods, Open-
ReadAsync has a corresponding OpenWriteAsync method. It also has a corresponding
AllowWriteStreamBuffering, which has the same relative effect as the AllowRead-
StreamBuffering property.
 The WebClient is a nice and easy way to handle typical web requests in your appli-
cation. Internally, it uses the (Http)WebRequest class to do the heavy lifting, so it sur-
faces many of the same capabilities.
 You’ll have noticed that HttpWebRequest and WebClient handle all calls using
asynchronous callbacks or events. Why is it that networking in Silverlight is asynchro-
nous, and what can we do to make it easier? 
19.3
Asynchronous communication
Have you ever used an application that “froze” while it was accessing the network or
the file system? I sure have. In fact, I can think of a few even by my own employer
(<cough>Outlook</cough>) that occasionally block the UI during some operations
that really have no UX reason to be blocking operations. I’ve also used a ton of third-
party applications, especially Twitter clients, that have real issues with blocking on net-
work calls.
 One reason that happens is when you make a call of indeterminate length from
the same thread that’s handling user input, the UI is blocked while the system is wait-
ing for a response. This is what happens with any function call on the UI thread; it’s
just that most of those calls are relatively quick. It’s only when you get to long-running
calls that you encounter this issue, and networking calls tend to be the longest run-
ning of them all.
 All communication from within the Silverlight application is done asynchronously
because of the Silverlight development team’s decision to originally use the browser’s
networking API, which would block the entire browser’s UI if called from a synchro-
nous method in a plug-in. That means if they didn’t require asynchronous calls, a
Silverlight application could block the browser, as well as any other plug-ins running
in it. In the days before isolated processes for each tab, this could bring a lot of open
tabs to a screaming halt.
 The most common way of making asynchronous calls requires a few simple steps,
which you saw with the WebClient in section 19.2. Typically, all you need to do is cre-
ate an event handler to be executed when the call returns. In that same section, you
also saw the lower-level and slightly more complex approach using HttpWebRequest/

470
CHAPTER 19
Networking basics
HttpWebResponse in order to give you the knowledge you need when the other
approaches break down. In this section, I’ll show you how reactive extensions and
tasks can help make easier the complex sequencing of asynchronous operations.
19.3.1 When async methods attack
Doing one-off network calls using async methods is fairly straightforward. Where it
becomes difficult is when you have to deal with call chaining: when one network calls
relies on the results of another network call. That can quickly turn ugly as you have
nested callbacks or event handlers peppering your otherwise well-designed application.
 Let’s imagine you have an application that needs to make the following calls, in
order, upon signing in a user:
1
Call 1 authenticates the username and password.
2
If call 1 succeeded, call 2 gets the role information for the user.
3
Based on the roles returned, the system calls either the FlunkyCubeWarrior
web service or the SuperAwesomeManager web service.
The set of calls is fairly typical for an in-house business application. If this were regular
old synchronous networking, you’d have code that looks something like the fictional
code in listing 19.6.
private bool LoginUser(string username, string password)
{
    var auth = new AuthorizationUtility();
    string token = auth.AuthenticateUser(username, password);
    if (token != null)
    {
        _roles = auth.GetRoles(token);
        var services = new BusinessServicesProxy();
        if (_roles.Contains("Manager"))
            services.CallSuperAwesomeManagerService();
        else
            services.CallFlunkyCubeWarriorService();
        return true;
    }
    else
        return false;
}
Most of us have written similar code so many times, we can write it in our sleep.3 Now
imagine what that code looks like if each of those calls has to be asynchronous. Yeah,
Listing 19.6
Example synchronous network calls to authenticate a user
3  Which is good, as writing this type of code is guaranteed to put me to sleep.

471
Asynchronous communication
it gets nasty, even when using tricks to shorten the code as I do here. This is one way it
might look, in our fictional scenario.
private void LoginUserAsync(string username, string password)
{
  var auth = new AuthorizationUtility();
  auth.AuthenticateUserAsyncCompleted += (s, e) => 
  {
    if (e.Result != null)
    {
      _loginSuccess = true;
      string token = e.Result;
      auth.GetRolesAsyncCompleted += (s1, e1) =>  
      {
        _roles = e1.Result;
        var services = new BusinessServicesProxy();
        if (_roles.Contains("Manager"))
          services.CallSuperAwesomeManagerService();
        else
          services.CallFlunkyCubeWarriorService();
      };
      auth.GetRoles(token);
    }
  };
  auth.AuthenticateUserAsync(username, password); 
}
The code in listing 19.7 is more challenging to understand at a quick glance. If I had
written it out long hand, using separate methods rather than inline delegates and
lambda expressions, it’d be even harder to keep track of, and it’d pollute your class
with lots more methods.
19.3.2 Saving your sanity with Rx
One approach is to use Reactive Extensions (Rx) to link the calls together using LINQ.
Rx is available for free download. The easiest way to get it is to use the NuGet package
manager4 for Visual Studio and simply get the package and install it into your current
project. Before invoking the manager, be sure you have your Silverlight project
selected (figure 19.2).
Listing 19.7
An asynchronous version of the same authentication path
4 Grab NuGet for free from http://nuget.org and then pick Reactive Extensions using the package manager
GUI as shown here, or type install-package Rx-Silverlight from the package manager console.
Wire up auth 
handler
Wire up roles 
handler
Kick it all off

472
CHAPTER 19
Networking basics
Figure 19.2
Installing the Reactive Extensions for Silverlight from the NuGet library package manager 
UI. Make sure you have the latest version of NuGet, available from nuget.org, installed first.
Once Rx is installed in your Silverlight project, you’ll be able to simplify the code. List-
ing 19.8 shows the same workflow but now using Reactive Extensions.
private void LoginUserAsyncRx(string username, string password)
{
  var auth = new AuthorizationUtility();
  var q1 = Observable.FromEventPattern<     
      AuthenticateUserCompletedEventArgs>(
      auth, "AuthenticateUserAsyncCompleted");
  var q2 = Observable.FromEventPattern<     
      GetRolesCompletedEventArgs>(
      auth, "GetRolesAsyncCompleted");
  q1.Subscribe(r => 
      auth.GetRolesAsync(r.EventArgs.Result));
What is NuGet?
NuGet (pronounced New-Get) is an easy way to install dependencies for a single proj-
ect. It handles downloading the latest binaries, installing them into your project, and
checking that all dependencies are met. Initially adopted primarily by ASP.NET MVC
developers and only for open source projects, NuGet is quickly becoming the standard
package manager for all types of .NET projects. It’s also a great way to make you crave
candy bars while coding. Curse you, 1980s Snickers commercials!
Listing 19.8
Simplifying the async calls using Reactive Extensions 
Wire up auth 
handler
Wire up roles 
handler

473
Asynchronous communication
  q2.Subscribe(r =>                          
  {
      _roles = r.EventArgs.Result;
      _loginSuccess = true;
      var services = new BusinessServicesProxy();
      if (_roles.Contains("Manager"))
        services.CallSuperAwesomeManagerService();
      else
        services.CallFlunkyCubeWarriorService();
  });
  auth.AuthenticateUserAsync(username, password);   
}
Rx offers several ways to write this code, each with its own pros and cons. I showed
only one—one which happens to rely on an event name as a string, something you
may feel strongly about.5 There are other slightly more complex statements that take
action expressions to avoid this, as you’ll see next.
 You may look at this example and think, “This is no less code than the previous list-
ing.” I wouldn’t blame you if you did because, in fact, it’s slightly more code. So let’s
look at one more Rx example. Listing 19.9 takes what you did in listing 19.8, chains
the subscribe calls, adds in exception handling with an error message display, and also
eliminates the magic strings.
private void LoginUserAsyncRx2(string username, string password)
{
  var auth = new AuthorizationUtility();
  var o1 = Observable.FromEventPattern<     
      AuthenticateUserCompletedEventArgs>(
      h => auth.AuthenticateUserAsyncCompleted += h,
      h => auth.AuthenticateUserAsyncCompleted -= h)
      .Subscribe(r => auth.GetRolesAsync(r.EventArgs.Result),
                 ex => MessageBox.Show(ex.Message));
  var o2 = Observable.FromEventPattern<     
      GetRolesCompletedEventArgs>(
      h => auth.GetRolesAsyncCompleted += h,
      h => auth.GetRolesAsyncCompleted -= h)
      .Subscribe(
      r =>
      {                                      
a Yes, of course this is a Doctor Who reference. Did you expect anything else from me? Exterminate!
5 You should, anyway. String representations of event names in code almost always end up as maintenance prob-
lems down the road. If you change the event name, the string isn’t automatically updated to reflect it. Here
there be dragons. If you still don’t care, just pretend you do, so you won’t be drawn and quartered by other
developers.
Listing 19.9
The evolution of the Rxa
Retrieve roles
Kick it all off
Wire up auth 
handler
Wire up roles 
handler
Retrieve roles

474
CHAPTER 19
Networking basics
        _roles = r.EventArgs.Result;
        _loginSuccess = true;
        var services = new BusinessServicesProxy();
        if (_roles.Contains("Manager"))
          services.CallSuperAwesomeManagerService();
        else
          services.CallFlunkyCubeWarriorService();
      },
      ex => MessageBox.Show(ex.Message));
  auth.AuthenticateUserAsync(username, password);   
}
In both the authentication handler and roles handler event wire-up, I provided
lambda expressions for adding and removing the handlers. This is a required part of
this use of FromEventPattern. It’s this wire-up specification that allows you to skip
using magic strings, because the runtime doesn’t have to use reflection to figure out
how to add and remove handlers.
 Also, in this version, I chained the lambda expressions together. Rather than make
different calls to q1.Subscribe and q2.Subscribe, I combined them into the main
call. This ability to chain calls can be both powerful and confusing.
 Rx and lambda expressions (and LINQ in general) can be a bit much to wrap your
head around at first—I know, I’m still working on them myself. I show them to you not
to profess any expertise, but to show they can potentially simplify much of your
code—not just in networking. For more information on Reactive Extensions,6 please
see the Rx forum on MSDN, http://social.msdn.microsoft.com/Forums/en-US/rx/
threads, and the Reactive Extensions Team Blog, http://blogs.msdn.com/b/rxteam/.
 In Silverlight 5, you gain another option for dealing with all that asynchronous nas-
tiness: tasks from the Task Parallel Library.
19.3.3 Simplifying with tasks
The Task Parallel Library (TPL) is a section of the full .NET 4 Framework that includes
the ability to manage asynchronous and parallel operations. The subset of what’s
included in Silverlight 5 specifically targets the asynchronous part of the TPL, leaving
out the parallel bits for now.
 The Task class, which exists in the System.Threading.Tasks namespace, is
included as part of the runtime (no additional references required). It’s a core Silver-
light feature. Like Rx, tasks weren’t created specifically to deal with networking, but
they’re very useful in this space in Silverlight, especially when you’re working with
HttpWebRequest and HttpWebResponse using the async request/response pattern.
The Task class is where all the goodness lies.
6 In fact, by the time this book comes out in full, a new version of Rx will likely be out as well. Interesting func-
tions like ForkJoin and Case, assuming they come out for Silverlight like they did for full .NET and Windows
Phone, can make the code here even more compact.
Kick it all off

475
Asynchronous communication
 Taking the same project you created in listings 19.1 and 19.2 on the request/
response pattern, you can simplify the InitiateWebRequest code and eliminate the
ResponseCallback code using tasks, as shown in listing 19.10.
private void InitiateWebRequest()
{
  string uri = "http://localhost:47498/helloWorld.xml";
  var request = HttpWebRequest.Create(uri);
  var webTask = Task.Factory.FromAsync<WebResponse>(  
    request.BeginGetResponse, request.EndGetResponse, null)
    .ContinueWith(                                
      task =>
      {
        var response = (HttpWebResponse)task.Result;
        var stream = response.GetResponseStream();
        using (var reader = new StreamReader(stream))
        {
          string xmlFileText = reader.ReadToEnd();
          Debug.WriteLine("Method: " + response.Method);
          Debug.WriteLine("Status Code: " + response.StatusCode);
          Debug.WriteLine("Status Description: " +
                           response.StatusDescription);
          Debug.WriteLine(xmlFileText);
        }
      });
}
Look at listing 19.2 again and compare the code to what appears in listing 19.10.
You’ll see this is a significant reduction in code and number of functions when com-
pared to the original listing. The function that makes that possible is the built-in
Task.Factory.FromAsync method. That function has knowledge of the async
request/response pattern, which just happens to be what’s used by WebRequest and
WebResponse when you’re making your networking calls.
 In this listing, you start by creating the request just as you did before. After that,
you take a turn and instead of calling any other request functions yourself, you create
a task. The task, because it knows about the async pattern, needs to be provided with
the begin and end functions and, optionally, a state object. Because you don’t need to
access the request yourself, you’re able to get rid of the state object you had in the pre-
vious version of this code.
 When the task completes, the code in the .ContinueWith statement is executed.
This is what you can use to chain networking calls, similar to what you did with Rx, but
arguably even cleaner. In this example, you get the response stream and display the
XML file results to the debug window.
 Just as was the case with Rx, this example only scratches the surface of what you
can do with tasks, and with the TPL in general. 
Listing 19.10
Using tasks to handle asynchronous operations
Task factory
Task completed

476
CHAPTER 19
Networking basics
 Now, all this may seem like a little much for a “basics” chapter, but it’s important to
understand that there are ways to manage this whole async thing that don’t involve los-
ing all your hair and your sleep. I won’t use Rx or tasks in the examples in this book
because they’re layers between you and learning the fundamentals. But in your real
code, you’ll almost certainly want to turn to them for nontrivial networking operations.
 All of our examples so far either have used networking to a web project in the same
solution or have eschewed networking completely to simply simulate the asynchro-
nous operations. Once you start accessing services on other sites, you’ll run into cross-
domain restrictions. 
19.4
Trust and cross-domain network access
The concept of trust applies to cross-domain access. If your application is hosted at
http://10rem.net and you’re attempting to access a web service hosted at http://
silverlight.net, the request is made cross-domain. That’s because your application’s site
of origin (the site that served up the XAP) is different from the site it’s trying to access.
In the case of cross-domain access, it isn’t a matter of whom your application trusts,
but of who trusts your application. In the vein of increased security, Silverlight, like
Flash before it, has restricted client applications to connecting only to the site of ori-
gin. For those familiar with web services, this approach seems counterproductive, so
the Silverlight team also worked in an exemption that requires the involvement of the
server hosting the web service. Administrators of web servers can create policy files to
give access to only the resources they want exposed to the requesting domains they
trust. A simple XML file is added that tells the Silverlight application what it has access
to on the foreign server.
NOTE
Cross-domain policy files aren’t required for elevated trust (trusted)
applications, including out-of-browser trusted applications as described in
Site of origin
The site of origin is the source of the XAP that represents your application. Note that
this can be different from the page itself. For example, a page hosted at http://
www.10rem.net that hosts a XAP from http://apps.10rem.net would result in a site
of origin of http://apps.10rem.net. 
When determining whether a call is a cross-domain call, Silverlight takes into account
not just the domain name, but the port number and the server name as well. When
calling from an application served up from http://www.10rem.net, the following are
all cross-domain calls:
■
http://api.10rem.net
■
http://www.10rem.com 
■
http://www.10rem.net:8080
The following, on the other hand, would work just fine and not be a cross-domain call:
http://www.10rem.net/apps/foo/bar.

477
Trust and cross-domain network access
chapter 5 and 6. Normal-trust out-of-browser applications and normal-trust
in-browser applications still require them. Cross-domain policy files typically
aren’t required for images and media.
19.4.1 Structuring the cross-domain file
The clientaccesspolicy.xml file defines these policies; it needs to be placed at the root
of the domain hosting any web service that’s allowed to be accessed from a different
domain. Even if there’s a valid policy file, if it’s located anywhere other than the root
of the hosting domain, your application won’t find it and the request will fail. If the
file is in place and has the proper attributes, your application is considered trusted,
and the call will return as expected. So, what does a properly formatted policy file
look like? Take a look at this code:
<?xml version="1.0" encoding="utf-8"?>
<access-policy>
    <cross-domain-access>
        <policy>
            <allow-from http-request-headers="*">
                <domain uri="*"/>
            </allow-from>
            <grant-to>
                <resource path="/" include-subpaths="true"/>
            </grant-to>
        </policy>
    </cross-domain-access>
</access-policy>
This example shows the minimum needed in a clientaccesspolicy.xml file to allow
HTTP access to all web services hosted on the current domain. If you want to have dif-
ferent rights for different services or to allow for socket access to the server, you can
make additions to that file. Sockets are described in chapter 23. 
 The example is as open as possible—requests from any domain can access any
resource in the host domain, and host headers are allowed. Table 19.3 shows the ele-
ments and attributes that make up a clientaccesspolicy.xml file. Attributes are shown
after the element they apply to. 
Table 19.3
Elements and attributes allowed in clientaccesspolicy.xml
Element/attribute
Required
Description
access-policy 
Yes
Root element for the policy file.
cross-domain-policy 
Yes
Container for one or more policy elements.
policy 
Yes
Defines rules for a single domain or a group of domains.
allow-from 
Yes
Container for permitted domains. If it contains no domain ele-
ments, no cross-domain access is granted.
http-request-headers
No
Defines which headers are allowed to be sent to the web ser-
vices hosted at the current domain. If absent, no headers are 
allowed.

478
CHAPTER 19
Networking basics
You can make the policy file as open or as restrictive as you desire. By changing the
domain element, you can limit access to a single domain. You can also add multiple
policy elements to apply different rules to requests from different domains, as shown
in the next example. 
 Two separate policies are defined in this example. The first allows any request com-
ing from a Silverlight application hosted at sometrusteddomain.com to have unre-
stricted access to the entire application; the second forces requests from any other
domain to be restricted to the API folder and to have HTTP headers denied:
<?xml version="1.0" encoding="utf-8"?>
<access-policy>
  <cross-domain-access>
    <policy>
      <allow-from http-request-headers="*">      
        <domain uri="http://sometrusteddomain.com”/>
      </allow-from>      
      <grant-to>      
        <resource path="/" include-subpaths="true"/>
      </grant-to>      
    </policy>
    <policy>
      <allow-from>      
domain 
Yes
Defines domains affected by the policy element in which the 
domain is a child.
uri 
Yes
Specifies the exact domain allowed for the current policy.
grant-to
Yes
Container for one or more resource elements.
resource
Yes
Required for WebClient or HttpWebRequest classes. 
Defines server resources affected by the current policy.
Path 
Yes
Required for WebClient or HttpWebRequest classes. 
Identifies individual files or services allowed or denied by the 
current policy. Format is a URI relative to the root of the 
domain.
include-subpaths 
No
Optional for WebClient or HttpWebRequest classes. If 
absent, subfolder access is denied.
socket-resource
Yes
Required for socket access. Defines socket resources 
affected by the current policy.
Port 
Yes
Required for socket access. Defines a port or range of ports, 
which must fall between 4502 and 4534, affected by the cur-
rent policy.
Protocol 
Yes
Required for socket access. Defines what protocols are 
allowed under the current policy. The only protocol currently 
allowed is TCP.
Table 19.3
Elements and attributes allowed in clientaccesspolicy.xml (continued)
Element/attribute
Required
Description

479
Trust and cross-domain network access
        <domain uri="*”/>
      </allow-from>      
      <grant-to>      
        <resource path="/api"/>
      </grant-to>      
    </policy>
  </cross-domain-access>
</access-policy>
The elements and attributes shown apply for connecting to any HTTP-based resource.
Modifications are needed if you’re using TCP sockets, which are described in
chapter 23.
19.4.2 Other cross-domain policy files
Even if the clientaccesspolicy.xml file isn’t in place, you may still be in luck. Silverlight
will also use policy files created for use with Adobe Flash, known as crossdomain.xml
files, for cross-domain access. There are two restrictions when using a crossdomain
.xml file:
■
It may only be used for WebClient, HttpWebRequest, or service reference proxy
access. Socket access isn’t permitted.
■
The entire domain must be allowed access for Silverlight to use a crossdo-
main.xml file. Silverlight doesn’t parse the advanced properties of crossdo-
main.xml.
If the domain hosting the web service you’re calling has either a clientaccesspolicy
.xml or a crossdomain.xml file with the correct attributes in place, it’s considered
trusted and will return a result. 
 It’s necessary to have an outside source trust your application, but should you trust
everyone else? Let’s look at a few ways to ensure that your application is as safe and
secure as possible.
Why have cross-domain policies at all?
Any old native client or server application can access any service it wants to, so you
may wonder why you have to jump through hoops when contacting network services
through Silverlight.
Let’s say, for example, that some services in your company include sensitive data.
Maybe you work at a bank, an insurance company, or a government institution. The
services are open to anyone authenticated on the LAN.
You then browse to a site that has a cool Silverlight (or Flash) game you want to try
out, and you run that and start enjoying a fine game of malware-tris, firewall-poker, or
steal-your-data-bobble. While you’re playing, the application sniffs for services in your
local network (or uses a known lookup table from a disgruntled employee, or perhaps
even something standard like UDDI) and starts downloading data from one of those
services and uploading it to its own server.

480
CHAPTER 19
Networking basics
19.4.3 Locating your cross-domain policy
Let’s say you have a relatively complex website, with different subdomains for different
features. Your main application and content site is http://www.10rem.net while your
XAP is served up from http://apps.10rem.net and your web services are located at
http://api.10rem.net. Where should you put your cross-domain files?
 First, for security reasons, you never want to have a cross-domain file in a location
that contains your UI. So, don’t put the cross-domain file at http://www.10rem.net.
 You don’t need to have a cross-domain file in the location that serves up your XAP.
Although that’s the site of origin, it doesn’t contain any services. Scratch http://
apps.10rem.net off your list.
 Finally, you have the services subdomain http://api.10rem.net. This is the site
where you want to have your cross-domain file located. It needs to be placed in the
root of that site so that Silverlight will find it when it tries to access the network
resources there. Cross-domain policies were created primarily for security reasons, but
they’re clearly not all you need to consider.
(continued)
Because you’re executing the application and you’re already authenticated locally, this
malware has no problem grabbing data from any service you’re authorized to and that
it has the technology to access (SOAP, REST, and so forth)—that is, unless you have
a client that respects cross-domain policies. In that case, the Silverlight client can’t
connect to your local services because those servers presumably don’t have a cross-
domain policy file that will open the sensitive data to the world.
That’s one of the main reasons cross-domain policy files are required by Flash and
Silverlight, and why you need to carefully consider when and where you place cross-
domain policy files on your own properties. 
Data integrity and security
The cross-domain policy helps protect the server from potentially malicious clients,
but it does nothing to protect the data being sent, nor does it protect from eavesdrop-
ping or interception.
Never trust that your data source will return pure, clean data every time. It’s possible
that, either purposefully or as a result of an error on the part of the service creator,
harmful data may be returned to your application. You should always take steps to
validate that the data you receive is compatible with the use you intend.
Any time you’re passing sensitive data, you should use HTTP over Secure Sockets
Layer (HTTPS), which encrypts the message to prevent eavesdropping. If you want to
access cross-scheme services and data (HTTP to HTTPS or HTTPS to HTTP), the cross-
domain policy file must permit that access.

481
The browser HTTP stack
Asynchronous operations, the request/response pattern, cross-domain, and site-of-ori-
gin checks are three constants in Silverlight networking. Security and data integrity is
also very important. As you’ll see in a moment, all four of these concepts apply
whether you use the browser networking stack or the client networking stack. 
19.5
The browser HTTP stack
When Silverlight 2 was released, there was only a single networking stack included: the
one that uses the browser’s networking under the covers. As you’ll see in the next sec-
tion, Silverlight 3 expanded on that.
 It’s important for both security and functional reasons to understand how Silver-
light interacts with the cookies otherwise handled by the browser. Developers used to
client-side development without the benefit of browser-hosting may find cookie han-
dling brand-new to them, and in most cases, a welcome feature.
 Although using the networking stack made the initial implementation very easy,
and made automatic use of browser features such as caching possible, it came with a
number of limitations. Some of the limitations, such as requiring asynchronous calls,
I’ve covered already. There’s one limitation I haven’t yet covered: the connection
count limit.
19.5.1 Connection count limit
The number of concurrent connections to a single subdomain (for example, http://
10rem.net and http://images.10rem.net are two different subdomains) is limited in
most browsers to two. This limit was increased first in Internet Explorer 8 to six con-
current connections, but because Silverlight runs in multiple browsers, you should
still be aware of it. Because Silverlight uses the browser’s networking stack for its com-
munications by default, it’s bound by the same limits. You may need a combination of
resources or other approaches to ensure that this doesn’t create unnecessary delays in
your application. Keep in mind that the browser may be loading objects outside the
scope of the Silverlight application as well, such as style sheets, images, and JavaScript
files. All these objects count toward the limit of two concurrent connections. You
should keep this fact in mind, particularly when performing duplex communication
as described in chapter 23.7
7 There are other things you can do to reduce connection requests: batch your operations by putting many web
service calls behind a single web service façade, package constant (or seed) data within the XAP itself, use
image sprite sheets and creative clipping for handling many small images, and background downloading/
preloading of key assets.

482
CHAPTER 19
Networking basics
19.5.2 Cookies
When using the browser networking stack, cookies for the current domain automati-
cally get added to requests from your Silverlight application. This is good if you’re
hosting your Silverlight component in an authenticated application that uses tokens
stored in a cookie, because Silverlight will share the same authentication cookie as the
hosting page. In this case, the token also authenticates the requests originating from
your Silverlight application, ensuring that you can access the resources you’re autho-
rized for.
 One potential problem using this method is that when a user has a cookie-based
token for a given domain, any Silverlight request to that domain contains the authen-
tication cookie, even if the request is from a different Silverlight application than the
one you intend. Another issue is that this method of authentication relies on the cli-
ent browser having session cookies enabled—which isn’t always true. 
19.5.3 Caching
When you use the browser networking stack, the local cache is handled automatically
by the browser you’re using. Any browser-imposed restrictions (private mode, for
example) will apply and potentially affect how downloaded files or assets are treated.
Increasing effective connections
A common trick to increase the throughput for your application, especially now that
clients often have significant bandwidth at their disposal, is to spread the application
network requests across separate subdomains. Take these, for example:
■
api.10rem.net hosts the web services and the cross-domain file.
■
images.10rem.net has the image resources.
■
www.10rem.net serves up the web pages.
Each subdomain has at least two simultaneous connections available per browser.
In that way, calls to the API won’t cause image downloads to stall and vice versa,
assuming the client and server both have sufficient bandwidth. Providing for a separate
subdomain for the API as well provides a better way to segment out the API and there-
fore be sure that you aren’t running into issues with granting cross-domain access to
areas that host UIs.
You can play with those as best suits your application or follow completely different
approaches that round-robin (from the client) to a pool of identical servers. You’ll have
more options for redirecting to different servers, as well as increase your effective
connection limit.
This assumes you want people to have six open connections to your network. If you
don’t want that, another approach is to package requests into chunky calls: reduce
chattiness in service calls, and package assets such as images into zip files rather
than individual image URIs.

483
The client HTTP stack
 You should feel reasonably comfortable with testing endpoints using your browser
directly and know they (cross-domain issues aside) will respond the same way there as
they do from within Silverlight. How this works may vary between browsers; that’s one
risk with depending on the browser’s networking stack.
 Once you venture outside the browser stack, things get a lot more flexible, and a
bit trickier to verify, but more consistent in behavior. The client HTTP stack is another
entirely parallel networking stack inside Silverlight. 
19.6
The client HTTP stack
When Silverlight 3 was in the planning stages, the team realized that using the
browser networking stack for out-of-browser applications was a nonstarter. So, Silver-
light 3 introduced a second networking stack, meant primarily for use when running
out-of-browser but accessible in in-browser scenarios as well. This stack eliminates
some of the restrictions of the browser-based HTTP stack.
 This opens up a plethora of new capabilities, such as additional verbs like PUT and
DELETE, as well as getting around the limitations on simultaneous connections. There
are caveats which I’ll discuss after I explain the mechanics of using the stack.
 This section first looks at how to manually create the client stack. Then, because
manually creating the stack every time can be a real chore, and impossible with gener-
ated code, you’ll see how to automatically select the stack at runtime. Along the way,
you’ll look at some of the capabilities of the client stack, such as setting headers and
credentials. Finally, you’ll look at one important difference from the browser stack:
cookie management.
19.6.1 Manually creating the client stack
One way to create an instance of the ClientHttp network stack is to use the System.
Net.Browser.WebRequestCreator object. That object serves as a kind of a factory and
includes two static properties: BrowserHttp and ClientHttp. Call the Create method
on the ClientHttp property as shown here:
private void CallNetwork_Click(object sender, RoutedEventArgs e)
{
  HttpWebRequest request = 
    (HttpWebRequest)WebRequestCreator.ClientHttp.Create(
    new Uri("http://api.10rem.net/Authors"));
  request.Method = "PUT";
  ...
}
This approach to creating the stack is usable only when you’re using the low-level
HttpWebRequest class. That’s helpful, but what if you want it to automatically be used
by any WebRequest-derived classes?

484
CHAPTER 19
Networking basics
19.6.2 Automatically using the client stack
A second way to use the client stack is to have it automatically selected based on spe-
cific URLs or schemes. That way, any call to the specified URL or scheme will use the
stack you specify. The FTP, FILE, HTTP, and HTTPS schemes are already assigned to the
browser stack, but you can override them or go a more specific route and specify that
the client stack should be used for any HTTP[S] calls to a specific website, or a specific
service at a known URL. For example, if you want all calls to 10rem.net, both regular
and SSL, to use the client stack, you’d put the following early in your code:
WebRequest.RegisterPrefix(
    "http://10rem.net", WebRequestCreator.ClientHttp);
WebRequest.RegisterPrefix(
    "https://10rem.net", WebRequestCreator.ClientHttp);
After this is done, any classes that use WebRequest or a class that derives from it will
automatically use the client HTTP stack you have specified.
 The client stack brings along a number of enhancements, including the ability to
automatically and manually set some HTTP header values previously unavailable to you.
19.6.3 Automatically setting the HTTP Referer and other headers
When a HTTP request is sent across the wire, it includes a number of headers that you
typically don’t see. For example, if I open up Yahoo! in my browser, the request con-
tains the following information:
GET http://www.yahoo.com/ HTTP/1.1
Accept: */*
Accept-Language: en-us
User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; 
➥ Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; 
➥ .NET CLR 3.0.30729; Media Center PC 6.0; Tablet PC 2.0; 
➥ .NET CLR 3.0.30618; .NET CLR 3.5.21022; InfoPath.2; 
➥ Media Center PC 5.0; MS-RTC LM 8; SLCC1; WWTClient2; Zune 4.0; 
➥ .NET4.0C; .NET4.0E; MS-RTC LM 8)
Accept-Encoding: gzip, deflate
Connection: Keep-Alive
Host: www.yahoo.com
Cookie: [lots of cookie stuff]
The first line is the verb and the target. In this case, I’m GETting the Yahoo! home
page. Most of the stuff after that is pretty standard. Internet Explorer 8 is sending
some information about the browser in use, what formats it’ll accept, the cookies, and
so on. Collectively, those are called HTTP headers. New to Silverlight 4, and unique to
the client networking stack, was the ability to send the HTTP Referer8 header with all
requests, including out-of-browser network requests.
8 In the English language, it’s spelled Referrer, with the double “r” in the middle. Blame Philip Hallam-Baker,
who said “…I got nothing but grief for my choice of spelling. I am now attempting to get the spelling cor-
rected in the OED since my spelling is used several billion times a minute more than theirs.”

485
The client HTTP stack
REFERRING SITE HEADER
The HTTP Referer header is a web standard used to indicate the origin of a request.
Often, this is used to figure out what other pages are linked to your page, or what
other pages are attempting to post to your form.
NOTE
Don’t use the HTTP Referer header to implement any type of impor-
tant security check. Some browsers include utilities that allow users to elimi-
nate the referer or replace it with one they manually input.
When using the client stack, Silverlight automatically sets the HTTP Referer to the
base URL of the XAP file where the out-of-browser application originated. This is use-
ful, because an out-of-browser application doesn’t really have a URL and certainly
doesn’t have a hosting web page.
 For example, if I access my website from a trusted out-of-browser application
(remember, in trusted applications, there’s no check for a client access policy), the
request headers look like this:
GET http://10rem.net/ HTTP/1.1
Accept: */*
Accept-Language: en-US
Referer: http://localhost:21597/ClientBin/RefererTest.xap
Accept-Encoding: identity
User-Agent: ...
Host: 10rem.net
Connection: Keep-Alive
I removed the user-agent for brevity; it’s the same as the previous example. But note the
value of the HTTP Referer header. I ran this example from Visual Studio, so the host is
localhost:21597. The full path of the XAP is included as the Referer automatically.
NOTE
Currently, Firefox doesn’t set the HTTP Referer header for any HTTP
GET requests from plug-ins running in-browser. If you must have a HTTP Ref-
erer set for GET requests, you’ll need to use the client stack as shown here.
POST requests are handled properly.
You can’t manually set the HTTP Referer header; it’s one of a number of restricted
headers. In addition to the Referer, Silverlight sets headers such as the Content-
Length, User-Agent, and others. Some of those, such as Content-Length, Content-
Type, and Authentication, have dedicated request properties that map to the appro-
priate headers. It’s unusual to change Content-Length and Content-Type, but setting
authentication credentials is a must for any serious web application.  
19.6.4 Authentication credentials
Many endpoints on the web, and even more on internal networks, are protected by
some sort of authentication scheme. To access those endpoints, you must be able to
provide authentication information along with the request. 
 The client networking stack supports NTLM, basic, and digest authorization, allow-
ing you to pass credentials to the endpoint of a request via the Credentials property

486
CHAPTER 19
Networking basics
of the HttpWebRequest and WebClient. Listing 19.11 shows how to use credentials
with the client networking stack.
private void SendRequest()
{
  HttpWebRequest.RegisterPrefix(
    "http://", WebRequestCreator.ClientHttp);     
  HttpWebRequest req = (HttpWebRequest)HttpWebRequest.Create(
     new Uri("http://10rem.net")); 
  req.UseDefaultCredentials = false;
  req.Credentials = 
    new NetworkCredential("Pete", "password");  
  req.BeginGetResponse(OnRequestCompleted, req);
}
private void OnRequestCompleted(IAsyncResult asyncResult)
{
  HttpWebRequest request =
    (HttpWebRequest)asyncResult.AsyncState;
  HttpWebResponse response =
    (HttpWebResponse)request.EndGetResponse(asyncResult);
    ...
}
Optionally, you can pass a third parameter to the NetworkCredential constructor: the
domain name. Passing a domain name is required for some forms of authentication,
including NTLM. To modify listing 19.10 to work with those forms, change the Net-
workCredential constructor call to include the domain, like this:
... new NetworkCredential("Pete", "password", "domain");
Of course, you’d use a real username, password, and domain name in the call. It’s also
important to note that you have no client-side control over what type of authentica-
tion is used. If the server challenges with basic authentication, the credentials will be
sent across in plain text. Unlike the full desktop API, there’s no CredentialCache class
that can be used to hold credentials by challenge type.
 With the additional capabilities offered by this stack, such as security and the avoid-
ance of cross-domain checks for trusted applications, it may seem like a no-brainer to
use it in place of the browser stack. But there are important differences to keep in
mind. For example, the location of the download cache may be different depending
on the operating system and whether you were using the default OS browser to begin
with. One of the biggest and most important differences is the way in which cookies
are handled.
19.6.5 Managing cookies with the CookieContainer
In the browser stack, the browser handles all cookie management automatically. The
browser automatically sends up, with each request, the cookies appropriate to that
domain and page.
Listing 19.11
Passing credentials along with a request, using the client stack
Client stack
New credentials

487
The client HTTP stack
 When using the client stack, you need to manually manage the cookies that are
sent up with each request. The HttpWebRequest class contains a CookieContainer
property that’s used for managing the cookies for that specific request.
 Listing 19.12 shows how to use the CookieContainer with the HttpWebRequest
class, combined with the Register prefix function described in the previous section.
private void SendRequest()
{
  WebRequest.RegisterPrefix(
    "http://", WebRequestCreator.ClientHttp);         
  WebRequest.RegisterPrefix(
    "https://", WebRequestCreator.ClientHttp); 
  HttpWebRequest req = (HttpWebRequest)HttpWebRequest.Create(
    new Uri("http://api.10rem.net"));
  CookieCollection cookies = new CookieCollection();
  cookies.Add(new Cookie("firstName", "Pete"));
  cookies.Add(new Cookie("lastName", "Brown"));
  cookies.Add(new Cookie("lastAccess", DateTime.Now.ToString()));
  req.CookieContainer = new CookieContainer();
  req.CookieContainer.Add(
    new Uri("http://api.10rem.net"), cookies); 
  req.BeginGetResponse(OnRequestCompleted, req);
}
private void OnRequestCompleted(IAsyncResult asyncResult)
{
  HttpWebRequest req =
    (HttpWebRequest)asyncResult.AsyncState;
  HttpWebResponse response =
    (HttpWebResponse)req.EndGetResponse(asyncResult);
    ...
  foreach (Cookie cookie in response.Cookies)  
  {
    Debug.WriteLine(cookie.Name + ":" + cookie.Value);
  }
}
Managing cookies manually is easy, as you saw in this example. But keep in mind that
the cookies won’t be shared between the two stacks. Take, for example, an application
in which the user is authenticated using ASP.NET forms-based authentication. The web
pages handle the authentication before the Silverlight application is displayed. Many
web applications, and even larger platforms such as SharePoint, can use this model.
 After the user is authenticated via the browser, the Silverlight application is dis-
played. If the Silverlight application then makes a network request, using the client
stack, to the hosting server, the request will fail. Why? Because the ASP.NET authentica-
tion cookie, which is automatically sent up with all browser stack requests, isn’t sent up
by the client stack request.
Listing 19.12
Using the CookieContainer with a request and response
RegisterPrefix
Cookies in request
Cookies in response

488
CHAPTER 19
Networking basics
 You’ve looked at two different ways to instantiate the client stack. You have the
option of setting the stack preferences globally in your application or handling it on a
request-by-request basis. You also learned how to manage cookies for each request.
When you’re working with the client stack for all but the most basic requests, this
knowledge is essential.
 The client stack was originally designed for use in out-of-browser situations, but
despite its limitations, it’s found use in in-browser Silverlight applications as well. The
stack definitely has advantages but only if you understand the limitations and how it
compares to the browser stack.
19.6.6 When to use the client stack
So far, I’ve shown you how to handle basic networking, and then how to use two simi-
lar but (in implementation) completely different networking stacks. When should you
pick the client stack? That depends on what your specific needs are. It’s uncommon,
but not impossible, to even mix and match both stacks within the same application.
 Table 19.4 provides a summary of major differences between the client and
browser stack. 
Table 19.4
Major differences between the client and browser networking stacks
Capability
Browser stack
Client stack
Remarks
Site of origin calls
Yes
Yes
You can always phone home.
Cross-domain calls
Yes
Yes
Subject to the presence of a client 
access policy.
Standard and custom HTTP 
headers
Yes
Yes
Must be allowed in client access policy.
GET and POST verbs
Yes
Yes
DELETE and PUT verbs
No
Yes
Must be allowed in client access policy.
200 OK or 404 Not Found 
status codes
Yes
Yes
On browser stack, all errors mapped to 
404 and success to 200.
Additional status codes, 
response headers, and 
response body
No
Yesa
a. In theory, this is true. It’s in the specs, MSDN, and more. But I’ve never been able to get anything but a 404 in my 
testing.
Cookies automatically trans-
ferred with each request
Yes
No
The browser handles this. You can’t 
prevent it from sending cookies up as it 
normally would.
Cookies manually managed 
and transferred
No
Yes
More power! But it comes with the cost 
of having to manually manage all 
cookies.
HTTP Referer send with 
requests
Sometimes
Yes
Browser support depends on specific 
browser configurations and add-ins.

489
Checking the network state
You must consider several basic concepts when using the communication APIs in Sil-
verlight. These concepts—trust, security, and the limitations of the browser—apply to
all methods of communication discussed in this chapter.
 Before I wrap up, there’s one last, and very useful, piece of information you’ll need
to write robust network-enabled applications: you need to know if you’re actually on
the network. 
19.7
Checking the network state
“Hello? I can hear you. Are you still there?”9 Knowing if you’re connected to the net-
work is a prerequisite for making network calls. Yes, when running on a web page, it’s
fairly low-risk to assume you’re actually connected to a network. But for out-of-browser
applications, and even pinned applications, you’ll want to pop a few lines of code into
your application to check connectivity.
 You’ll use two mechanisms to check the network state in your Silverlight applica-
tion: the GetIsNetworkAvailable method and the NetworkAddressChanged event.
Both are available in- and out-of-browser but are more commonly used in out-of-
browser scenarios.
 The NetworkInterface and NetworkChange classes included in the System
.Net.NetworkInformation namespace provide access to the network state informa-
tion. Typically, you’ll use them together, as shown in listing 19.13.
NetworkChange.NetworkAddressChanged += new
   NetworkAddressChangedEventHandler(OnNetworkAddressChanged);
...
void OnNetworkAddressChanged(object sender, EventArgs e)
{
  if (NetworkInterface.GetIsNetworkAvailable())
  {
    // Connected to some network
  }
  else
  {
    // Not connected to any network
  }
}
Listing 19.13 illustrates handling a network address change as well as checking for
connectivity. They’re typically used together at the start of the application but don’t
need to be—you can check for network availability without an address change.
 The call to GetIsNetworkAvailable will tell you only that there’s some sort of net-
work connection. It doesn’t guarantee that you can access required services or even
the internet in general. On machines with network connections between the host and
9 I ripped through Portal 2 and Most of Portal in between this book and the previous edition. Serious fun. Stop
reading and go play Portal 2 right now. Even if you’re at work. (Actually, if you’re at work, play Portal 2 co-op.)
Listing 19.13
Checking for network connectivity

490
CHAPTER 19
Networking basics
a virtual PC (VPC), which is typical in development environments, this may even detect
the VPC connection as a valid network connection and return true. 
 Rather than rely just on this call, you should first check to see whether any network
is available and, if so, ping or call a known service on the server you plan to reach
before assuming you’re connected. Because the network state can change during the
application runtime, you may want to call these methods on a timer or in the excep-
tion handlers in your network service interface layer.
19.8
Summary
In this chapter, I covered the basics of networking in Silverlight. Silverlight has some
capabilities and limitations that may seem strange at first but that add to the security
and responsiveness of the applications you build.
 Of those, the biggest one is asynchronous networking. Every network call in Silver-
light must be asynchronous; you aren’t allowed to block a thread while waiting for the
response from the network resource. The code to manage async networking can get a
bit ugly at times, but luckily you have lambda expression anonymous delegates, tasks,
and even Reactive Extensions to lean on to help make the code more compact and
somewhat easier to follow—especially in complex call chaining scenarios.
 Every network interaction I covered is conceptually made up of a request and a
response. Silverlight handles the implementation of this in the (Http)WebRequest,
(Http)WebResponse, and WebClient classes. The HttpWebRequest and HttpWeb-
Response classes are the most powerful, but they lack the simplicity of the event-driven
approach provided by the WebClient. Together, these classes form the core on which
the rest of the higher-level networking classes covered in the next chapters are built.
 Regardless of which class you use, the site-of-origin and cross-domain checks apply.
Silverlight isn’t allowed, except in the case of elevated trust applications, to access net-
work resources on a domain other than the site of origin without permission from
that site. The permission comes in the form of one of two possible cross-domain per-
missions files.
 Silverlight has two completely different networking stacks: the browser HTTP stack
and the client HTTP stack. The former predates the latter in that the client network-
ing stack came about only as a necessity as part of out-of-browser applications in Silver-
light 3. The APIs are interchangeable, but you must be aware of which stack you’re
using, so you don’t get caught by cookie or caching differences. 
 Finally, you have connectivity itself. When building a connected application, check
to see if you actually have network access. In-browser applications can get away with
leaving this step out with only a small likelihood of complete and catastrophic failure,
but out-of-browser applications should always check and assume a disconnected status
otherwise.
 Networking is essential to most every application you’ll build. This chapter pro-
vided some insight into the core networking features in Silverlight 5. The next chap-
ter looks at how to build on this to interact with various types of web services,
including SOAP and REST services.

491
Working with SOAP services
Nearly every application built today, even using Silverlight, needs remote data to
accomplish its goal. Business applications have to manipulate data directly, games
often need to store high scores or submit achievements, and social clients must
interact with their hub services.
 Traditional desktop applications could handle some of those calls by directly
connecting to a database. But Silverlight can’t directly connect to a client-server
database. Instead, it must handle all transactions through an intermediary service.
 Chapter 19 looked at the basics of networking, including how to access
resources across the web. In this chapter, you’ll build upon that knowledge to deal
with a specific type of network resource: the SOAP service.
 This chapter begins by looking at the simplest type of SOAP service: the ASP.NET
web service. ASP.NET web services are great for learning the basics. From there,
This chapter covers
■
ASP.NET SOAP services
■
WCF SOAP services
■
The WCF configuration files
■
Error handling with WCF

492
CHAPTER 20
Working with SOAP services
you’ll move on to the type of service that has been seeing increased adoption: the WCF
SOAP Service. You’ll use this service to explain how to connect to services and pass
complex data, as well as how to deal with error handling.
 By the end of this chapter, you’ll have the information you need to transmit and
receive data and messages to SOAP services either inside your organization or across
the internet. 
20.1
Introducing ASP.NET SOAP services using ASP.NET
When you think of a classic web service, you’re probably thinking about SOAP. SOAP
services follow a strict protocol that defines the format in which messages are passed
back and forth. Silverlight has great support for these services, supporting the WS-I
Basic Profile 1.0 (SOAP 1.1 over HTTP), SOAP 1.2, and WS-Addressing 1.0, as well as a
small subset of WS-Security. Using SOAP services in Silverlight allows for both the sim-
plest implementation and most powerful data-transfer mechanism of any service type
through the use of the service reference. Over the next few pages, you’ll create a
proxy object for the service, call a method on it, and download the results. After
you’ve created and used a proxy to connect to a SOAP service, you’ll be amazed at how
simple yet powerful this capability is.
NOTE
SOAP originally stood for Simple Object Access Protocol, but that definition
fell into disuse and was officially dropped with version 1.2 of the W3C SOAP
standard.
20.1.1 Silverlight-compatible SOAP services
Your typical ASP.NET SOAP service is going to be Silverlight-compatible. You have to go
a bit out of your way to make the service incompatible with Silverlight. As mentioned
earlier, Silverlight doesn’t support all the WS-* standards, it does support what it typi-
cally found in the wild.1
 An ASP.NET web service consists of two parts:
■
An ASMX endpoint
■
The implementation code-behind
For basic services, no additional configuration is needed. You can combine the ASMX
code and markup in the same file if you want to. In practice, the two are separate.
 To create an ASP.NET web service, pick a suitable location in your web project (I
like to have a “Services” folder) right-click it, and select Add New Item. When pre-
sented with the list of templates, pick the Web Service template from the Web cate-
gory. Figure 20.1 shows the dialog with this template selected.
1 If your organization bought into the SOA (Service-Oriented Architecture) approach that was the hammer-du-
jour some years back, you’ll find that many of the services won’t work with Silverlight due to their use of the
more advanced WS-* protocols. In those cases, create a wrapper/proxy service, convince someone to add
another endpoint, implement your own version using the client networking stack, or simply curl up under
your desk and avoid your project manager.

493
Introducing ASP.NET SOAP services using ASP.NET
Once you add the project item, you’ll have a basic ready-to-use web service in your web
project. Listing 20.1 shows the service, with two small modifications.
[WebService(Namespace = "http://services.10rem.net")] 
[WebServiceBinding(ConformsTo = WsiProfiles.BasicProfile1_1)]
[System.ComponentModel.ToolboxItem(false)]
public class TestService : System.Web.Services.WebService
{
    [WebMethod]
    public string HelloWorld(string name)
    {
        return "Hello World, " + name;
    }
}
Listing 20.1 shows the service created when you add a new service. I changed the
default web service namespace from tempuri.org2 to services.10rem.net. This change
is optional, but doing so is considered a best practice, especially when you’re working
with large numbers of services inside an organization, some of which may potentially
have the same name. You’ll also have the warm fuzzy of sticking with the W3C standard
for XML.3
 The second change I made was to add a name parameter to the method. I did this
in order to show how it’s exposed in the WSDL (Web Service Description Language)
document produced by this service.
Listing 20.1
A Silverlight-compatible ASP.NET web service
2  That’s read as Temp URI, not tempura like the tasty battered food at your local Japanese restaurant.
3  http://www.w3.org/TR/REC-xml-names/ 
Figure 20.1
Creating a new ASP.NET web service using the Web Service template
Namespace

494
CHAPTER 20
Working with SOAP services
 To view the WSDL, build the project, right-click the ASMX file, and choose View in
Browser. Once you do that, you’ll be presented with a web page (creation of this page
can be turned off via web.config) that has a link to the method and to the service
description. Click the Service Description link.
 Listing 20.2 shows the generated WSDL, the full description of the contract for this
service. I’ve left out most of the large namespace declarations as well as a fair amount
of cruft (important cruft, but cruft) from the middle of the file. Note that I don’t
expect you to type this in.
<?xml version="1.0" encoding="utf-8"?>
<wsdl:definitions ...>
  <wsdl:types>
    <s:schema elementFormDefault="qualified"
              targetNamespace="http://services.10rem.net">
      <s:element name="HelloWorld">      
        <s:complexType>
          <s:sequence>
            <s:element minOccurs="0" maxOccurs="1" 
               name="name" type="s:string" />     
          </s:sequence>
        </s:complexType>
      </s:element>
      <s:element name="HelloWorldResponse"> 
        <s:complexType>
          <s:sequence>
            <s:element minOccurs="0" maxOccurs="1" 
                       name="HelloWorldResult" type="s:string" />
          </s:sequence>
        </s:complexType>
      </s:element>
    </s:schema>
  </wsdl:types>
...
  <wsdl:service name="TestService">
    <wsdl:port name="TestServiceSoap" 
               binding="tns:TestServiceSoap">
      <soap:address                                 
      location="http://localhost:22894/Services/TestService.asmx" />
    </wsdl:port>
    <wsdl:port name="TestServiceSoap12" 
               binding="tns:TestServiceSoap12">
      <soap12:address                              
location="http://localhost:22894/Services/TestService.asmx" />
    </wsdl:port>
  </wsdl:service>
</wsdl:definitions>
WSDL allows clients to understand how to send information to and receive informa-
tion from a web service. When you add a service reference, behind the scenes the tool
Listing 20.2
WSDL for the ASP.NET web service
Method
Parameter
Return
SOAP 1.1 
endpoint
SOAP 1.2
endpoint

495
Introducing ASP.NET SOAP services using ASP.NET
is downloading the WSDL and parsing it to create a client-side proxy that understands
the types and methods listed within.
20.1.2 Service references
In the previous chapter, all of your networking requests went through the low-level
HttpWebRequest and WebClient classes, regardless of what you were accessing. But the
easiest way to connect to a SOAP service is through a service reference proxy—a gener-
ated class that internally uses those classes to handle the network operations. If the
web service you’re connecting to supports WSDL, Visual Studio can read that informa-
tion and create a proxy in your application for you in three simple steps:
1
In Visual Studio 2010, right-click your Silverlight project and choose Add Ser-
vice Reference.
2
This brings up the Add Service Reference dialog box. On this form, you can
either type in the URI of the service you wish to connect to and click the Go but-
ton, or if the services are part of the same solution, click the Discover button.
Either option tells Visual Studio to poll the chosen location for available ser-
vices and analyze their signatures. When the services have been displayed, you
can open them and look at what methods are available on each service. You can
then enter in the text box a namespace by which you want to refer to the service
and click OK to create the proxy.
3
You can modify more advanced settings either by clicking the Advanced button
in the previous dialog or by right-clicking the service reference and selecting
Configure Service Reference. One particularly useful capability of this form is
the ability to change the collection types returned by the service. The default
collection type can vary depending on the service you’re connecting to, but you
can also change it to use other collection types, even generics.
When the service reference is created, Visual Studio also adds references to the
System.Runtime.Serialization and System.ServiceModel assemblies. These are
used by Silverlight in connecting to web services and in serializing and deserializing
the SOAP message.
 Go ahead and add that service reference to your Silverlight project. Name it
SilverService. This will generate the client proxy you’ll use to call the service.
 When you’ve created your service reference, it’s easy to use for both sending and
receiving data. First, let’s talk about calling SOAP services using the service reference
you just created.
20.1.3 Receiving data with the proxy
Connecting to and downloading data from a simple SOAP service is easy. In Silverlight,
all client-side SOAP calls go through the WCF client service stack, so you need to add
two using statements to your page, one for System.ServiceModel and another for
System.ServiceModel.Channels. Next, you need to create a proxy to the service
using the service reference as created in the previous section. Because you named the

496
CHAPTER 20
Working with SOAP services
service reference SilverService for this example, add a third using statement for
[projectname].SilverService. Then, add an event handler to catch the return of
the asynchronous call to the exposed method on the service. 
Result:
XAML:
<Grid x:Name="LayoutRoot" Margin="20">
  <Grid.ColumnDefinitions>
    <ColumnDefinition Width="Auto" />
    <ColumnDefinition Width="*" />
  </Grid.ColumnDefinitions>
  <StackPanel Grid.Column="0">
    <Button x:Name="GetTime" Click="GetTime_Click"
            Content="Get Time" Height="33" Width="90" />
  </StackPanel>
  <TextBlock x:Name="Results" Grid.Column="1"
             FontSize="25" Margin="5" />
</Grid>
C#-SampleAsmx.asmx service in web project:
[WebService(Namespace = "http://services.10rem.net/")]
[WebServiceBinding(ConformsTo = WsiProfiles.BasicProfile1_1)]
[System.ComponentModel.ToolboxItem(false)]
public class TestService : System.Web.Services.WebService
{
  [WebMethod]
  public DateTime GetTime()               
  {
    return DateTime.Now;
  }
  [WebMethod]
  public string HelloWorld(string name)
  {
    return "Hello World, " + name;
  }
}
C#-Silverlight:
private void GetTime_Click(object sender, RoutedEventArgs e)
{
  var binding = new BasicHttpBinding();
  var uri = new Uri("/TestService.asmx",          
                    UriKind.Relative);
  var endpoint = new EndpointAddress(uri);
  var proxy = new TestServiceSoapClient(binding, endpoint); 
  proxy.GetTimeCompleted += (s, ea) => 
  {
Listing 20.3
Calling an ASP.NET ASMX SOAP service
New GetTime 
method
Service URI
Proxy

497
Introducing ASP.NET SOAP services using ASP.NET
    Results.Text = ea.Result.ToLongTimeString();
    var client = s as TestServiceSoapClient;
    client.CloseAsync();
  };
  proxy.GetTimeAsync();                     
}
Listing 20.3 shows the entire process of creating the proxy, adding an event handler
(an anonymous delegate via a lambda expression, as I sometimes prefer to do), calling
an asynchronous method and handling the results. In this example, you added a Get-
Time method to the SOAP service you started with. This method accepts no arguments
and returns a DateTime representing the time on the server at the time of the call.
 Because you added a new method to the service, you’ll need to first build the web
project after updating the service, then right-click and update the service reference
on the client project. Doing so will ensure the web project is generating new WSDL
and the client project has the new WSDL when building the client proxy.
 Although this service happens to be an ASP.NET ASMX service, the same steps apply
to using Silverlight-enabled WCF services because the client code is identical.
You first create a Binding of type BasicHttpBinding. Doing so tells the proxy that the
service you’re connecting to uses SOAP. The default constructor for BasicHttp-
Binding creates a Binding with no security mode. An optional parameter on the con-
structor accepts a BasicHttpSecurityMode, which allows you to tell the binding how
to secure itself; for example, you can tell the binding to use SSL when transmitting the
SOAP message. You also create an EndpointAddress that points to the URI of the ser-
vice you’re about to call. Finally, you create the proxy using the service reference
WCF or ASP.NET for services?
As far as the Silverlight developer is concerned, the two are almost identical. However,
WCF SOAP services have much broader marshaling support versus ASMX ASP.NET
web services. WCF services can support a broader set of types for input and return
from the service.
Regardless of which type you pick, the client stack is based on WCF.
When working with WCF (which is my recommendation), it’s easiest if you use the
Silverlight-Enabled WCF Service template because it creates a simple SOAP service
without all the extra WCF ceremony. If you instead want the full spectrum of what WCF
offers, you can go the full route and provide a Silverlight (SOAP) compatible endpoint
instead.
In either case, you may host the services on an ASP.NET website either remotely or
using the Visual Studio web server.
In the end, as you’ll see later in this chapter, I prefer to use WCF SOAP services,
especially when working with complex types.
Service method call

498
CHAPTER 20
Working with SOAP services
created earlier and pass into it the binding BasicHttpBinding and the initialized
EndpointAddress objects.
 Next, you need to add an event handler to be called when your asynchronous
method call returns. You can do so by using the Visual Studio shortcut of pressing the
+ key, then the = key, then pressing Tab twice after selecting the GetTimeCompleted
event on your proxy. Using this shortcut automatically finishes the event handler dec-
laration for you and creates a stubbed method as the event handler. Finally, you call
the GetTimeAsync() method on the proxy to begin the asynchronous call to the ser-
vice. IntelliSense will show you a [servicemethod]Completed event and a [service-
method]Async() method for each method exposed by the SOAP service. When you
created the service reference in the previous step, Visual Studio queried the service to
see what methods were available and made proxy methods for each of them.
 After the service returns, the method declared as the event handler—proxy_
GetTimeCompleted—gets called with the results. Because the method is outputting the
results as a Datetime object, you can convert it to a string using standard .NET conver-
sion methods, which you can then assign to the Text property of a TextBlock. The
only other task to perform in the return method is to close out the connection using
the CloseAsync() method on the proxy. Garbage collection will technically come
through and close any old connections, but it’s generally considered good program-
ming practice to close any connection when you’re done using it.
 Table 20.1 summarizes the bits of code used for connecting to the service and
retrieving data.
And that’s all there is to it—you’ve now connected to a SOAP service, called a method
on it, and received and displayed the results. Sending parameters to a service is just
as easy.
Table 20.1
Summary of the components of a Silverlight SOAP service call
Component
Description
Binding
The protocol you’re going to use in the service call.
URI
The address of the service to be used as the endpoint.
Endpoint
Representation of the endpoint itself. In practice, this is typically just a wrap-
per around the single URI, but it does support additional functionality.
Proxy
An instance of the proxy generated when you added the service reference. 
The proxy contains generated async methods corresponding to the exposed 
methods on the service.
[service method 
name]Completed Event 
Handler
The service proxy exposes an event, which is called when the service method 
returns. The strongly typed EventArgs.Result property contains the 
return value from the service.
In my examples, I used lambda expressions with anonymous event handlers 
instead, but this approach is equally valid.
Service Methods
The ASP.NET or WCF service contains one or more service methods, exposed 
to the public. These are the services that may be called via the proxy.

499
Introducing ASP.NET SOAP services using ASP.NET
20.1.4 Sending data using the proxy
If you’re thinking that all you need to do to send parameters to a SOAP service using a
service reference is to include a parameter in the method call, you’re right. 
Result:
XAML:
<Grid x:Name="LayoutRoot" Margin="20">
  <Grid.ColumnDefinitions>
    <ColumnDefinition Width="Auto" />
    <ColumnDefinition Width="*" />
  </Grid.ColumnDefinitions>
  <StackPanel Grid.Column="0">
    <Button x:Name="GetTime" Click="GetTime_Click"
            Content="Get Time"
            Margin="5" Height="33" Width="90" />
    <Button x:Name="GetString" Click="GetString_Click"
            Content="Get String"
            Margin="5" Height="33" Width="90" />
  </StackPanel>
  <TextBlock x:Name="Results" Grid.Column="1"
                FontSize="25" Margin="5" />
</Grid>
C#-Silverlight client:
private void GetString_Click(object sender, RoutedEventArgs e)
{
  var binding = new BasicHttpBinding();
  var uri = new Uri("/SampleAsmx.asmx", UriKind.Relative);
  var endpoint = new EndpointAddress(uri);
  var proxy = new SampleAsmxSoapClient(binding, endpoint);
  proxy.GetCoolTextCompleted += (s, ea) =>
    {
      Results.Text = ea.Result;
      var client = s as SampleAsmxSoapClient;
      client.CloseAsync();
    };
  proxy.GetCoolTextAsync(42);       
}
C#-web service:
[WebMethod]
public string GetCoolText(int number)  
{
Listing 20.4
Sending data to an ASP.NET SOAP service
Service called 
with 42
Method with 
parameter

500
CHAPTER 20
Working with SOAP services
  switch (number)
  {
    case 0:
      return "zero";
    case 1:
      return "one";
    case 2:
      return "two";
...
    case 42:
      return "What is, The answer to the life, " +  
             "the universe, and everything, Alex?";
    case 420:
      return "Huh? What? Got any snacks?";
    case 3263827:
      return "One thing's for sure: " +
             "we're all going to be a lot thinner.";
    case 8675309:
      return "Jenny? Is that you?";
    default:
      return "I'm afraid I can't do that.";
  }
}
Listing 20.4 builds on the code from listing 20.2 by adding an additional button to the
UI, an event handler to the code-behind, and another method to the ASMX web ser-
vice. Together, this is an example of sending of a single int as a parameter to the Get-
CoolText method on the web service. Like the previous example, there’s also a return
value that you display on the page. 
TIP
If you’re typing in this code as you go along, make sure you rebuild (or
at least build) your web project before you update the service reference in
your Silverlight project. That way, Visual Studio has what it needs in order to
generate the new proxy on the client. To update the service reference, right-
click the reference in the Service References folder in your Silverlight project
(it’s in the Solution Explorer) and select Update Service Reference.
You can expand this example to take in almost any number of parameters. This
approach is fine for sending a few simple data values, but it quickly breaks down when
the data becomes more involved. In that case, you’ll want to send and receive complex
data types: objects. At the same time, this looks to be a good point to switch over to
using WCF. I have nothing personal against ASP.NET web services, except that I like
WCF services better. It’s okay. I told ASP.NET web services that we should definitely still
be friends, and that we’ll have coffee sometime. 
20.2
Using WCF services and complex data types
So far, you’ve sent and received simple data types, such as int and string. The major-
ity of the SOAP services you’ll deal with will return and possibly take more complex
types: instances of classes. The complexity, in this case, comes from sharing the class
Result

501
Using WCF services and complex data types
definition. If you define the class on your server project, how can you use it in your cli-
ent project?
 When you created the service reference, the signatures for objects used in the
SOAP message were automatically analyzed and a client-side proxy made for those as
well. When this happened, the client side was given copies of the class definitions.
With this proxy, you can instantiate objects of that type in your application.
 For this example, you’re going to switch over to using WCF services and stop using
ASP.NET web services. Though it’s not necessary, I’m going to spin up a separate solu-
tion to do this. The solution is named WcfServiceExample and contains both the usual
Silverlight project and the default ASP.NET web project. 
 Most cases will work just fine with ASMX web services, but when working with com-
plex types, you’ll find WCF services much more flexible. 
 The first step is to create the Silverlight-enabled WCF service using the template.
20.2.1 Creating the Silverlight-enabled WCF service
Creating a Silverlight-enabled WCF service is a similar process to creating an ASP.NET
ASMX service. To create one, follow these simple steps:
■
Right-click your web project and choose Add > New Item. Note that I typically
create a folder named Services first and place the services in there.
■
From the Silverlight category list, select Silverlight-Enabled WCF Service and
give it a meaningful name. In this case, call it CustomerService.
Figure 20.2 shows the template for creating a Silverlight-enabled WCF service. Note
that although you’re working in the web project, the template itself is located in the
Silverlight category.
Figure 20.2
Creating a Silverlight-enabled WCF Service. Name yours “CustomerService.”

502
CHAPTER 20
Working with SOAP services
Listing 20.5 shows the default code generated from the Silverlight-Enabled WCF Ser-
vice template. In this case, the web project’s name is WcfServiceExample.Web.
using System;
using System.Linq;
using System.Runtime.Serialization;
using System.ServiceModel;
using System.ServiceModel.Activation;
namespace WcfServiceExample.Web.Services
{
  [ServiceContract(Namespace = "")]
  [SilverlightFaultBehavior]
  [AspNetCompatibilityRequirements(
    RequirementsMode = AspNetCompatibilityRequirementsMode.Allowed)]
  public class CustomerService
  {
    [OperationContract]
    public void DoWork()
    {
      // Add your operation implementation here
      return;
    }
    // Add more operations here and mark them with [OperationContract]
  }
}
Whereas the ASP.NET ASMX project used the [WebMethod] attribute to identify service
methods, WCF uses [OperationContract]. The template also has helpful comments
to let you know where to put other methods, as well as a reminder to mark them with
the OperationContract attribute.
 The Silverlight-enabled WCF service also adds a number of entries to the web.con-
fig. Listing 20.6 shows these entries.
<system.serviceModel>
  <behaviors>
    <serviceBehaviors>
      <behavior name="">
        <serviceMetadata httpGetEnabled="true" />
        <serviceDebug includeExceptionDetailInFaults="false" />
      </behavior>
    </serviceBehaviors>
  </behaviors>
  <bindings>
    <customBinding>
      <binding name=
"WcfServiceExample.Web.Services.CustomerService.customBinding0">
        <binaryMessageEncoding />                   
Listing 20.5
An empty Silverlight-enabled WCF service
Listing 20.6
The web.config entries for the CustomerService WCF service
Binary 
Serialization

503
Using WCF services and complex data types
        <httpTransport />
      </binding>
    </customBinding>
  </bindings>
  <serviceHostingEnvironment aspNetCompatibilityEnabled="true"
        multipleSiteBindingsEnabled="true" />
  <services>
    <service name="WcfServiceExample.Web.Services.CustomerService">
      <endpoint address="" 
                binding="customBinding" 
                bindingConfiguration=
"WcfServiceExample.Web.Services.CustomerService.customBinding0"
                contract=                             
                "WcfServiceExample.Web.Services.CustomerService" />
      <endpoint address="mex" binding="mexHttpBinding"
                contract="IMetadataExchange" />
    </service>
  </services>
</system.serviceModel>
The web.config entries aren’t something you’ll typically need to change, unless you
get into the more advanced features of WCF. I show them here to illustrate two key
things: binary message encoding and the contract name.
 Binary message encoding is supported in Silverlight 3 and later. This is a band-
width-saving measure that encodes the SOAP message in binary format. You can see
significant gains if you have a large amount of data to share, so this option is on by
default. But if you need to share this SOAP service with another type of client and
adhere to WS-* standards, you may need to remove the binaryMessageEncoding ele-
ment. In practice, it’s best to have a second endpoint pointing to the same service
implementation in those cases.
 The contract name is important should you decide to change the name of your ser-
vice class or namespace. Changing it in code isn’t sufficient; you’ll need to change it
in this configuration file as well (and remove and re-add any service references).
 Now that you’ve looked at the template-created items, it’s time to add functionality.
Listing 20.7 replaces the default-generated “DoWork” method in the WCF service class.
[OperationContract]
public Customer GetCustomerByID(int id)
{
  return new Customer()         
    {
      ID = id,
      Balance = 200.50M,     
      FirstName = "Pete",   
      LastName = "Brown"       
    };
}
Listing 20.7
The GetCustomerByID Service Method
Contract
Customer object 
(next listing)
Mocked data

504
CHAPTER 20
Working with SOAP services
In this case, the GetCustomerByID method returns a dummy customer with the speci-
fied ID. In a real application, you’d look up the customer in a database or other repos-
itory—something you’ll learn more about in appendices E and F in the ebook and
chapter 34.
TIP
In order for your service method to show up in the generated proxy, it
must be public, be marked with [OperationContract], and be successfully
compiled before you add the reference.
Note that the service method returns a strongly typed customer object. In a service
used by Silverlight, you don’t want to return a DataRow, DataSet, DataTable, or other
ADO data type. That’s generally a best practice anyway; those are proprietary .NET
types, but I’ve seen a lot of services that use them. In any case, Silverlight knows noth-
ing of the ADO types and works best if you use strongly typed entities.
 In this case, you have a Customer class, an instance of which is returned by this ser-
vice method. Where is this class defined? One place you can define it is in the same
WCF service project, even in the same .cs file as the service. Listing 20.8 shows the
Customer class, defined in the same service file, right after the CustomerService class.
namespace WcfServiceExample.Web.Services
{
  public class CustomerService
  {
  ...
  }
  [DataContract]
  public class Customer             
  {
      public int ID { get; set; }
      public string FirstName { get; set; }
      public string LastName { get; set; }
      public decimal Balance { get; set; }
  }
}
The Customer class is marked with the DataContract attribute, an attribute that says
to include it in the service description (and ultimately, the WSDL for a SOAP service)
when generating the client proxy, and to serialize data to and from it when making a
service call. In .NET 4, by default, each of the public properties are serializable and
don’t need separate attributes in order to be included in the generated client proxy.
In some earlier versions of .NET, you need to mark each of the members with the
DataMember attribute. You can also mark with the IgnoreDataMember attribute if you
want to keep a property out of the contract. Some consider it a best practice to indi-
vidually mark each property to avoid any ambiguity.
Listing 20.8
Adding the type definitions to the service
Customer class

505
Using WCF services and complex data types
 Now, having the type definitions right in the same project or even the same file cer-
tainly makes things easy, but it can quickly get messy, especially when you want to be
able to separate your model for mocking or testing, or you want to share the model
types with other projects in your solution. For those scenarios, there’s another
approach I like to use.
20.2.2 Sharing type definitions
Although it’s a little more work, I much prefer the approach of having a separate proj-
ect with the model used by the service. This doesn’t have to be the same model that
your view model uses in an MVVM application (but that often turns out to be the case).
 One nice feature about this approach is you can pro-
vide additional platform-specific functionality by using
conditional compilation or partial classes, with only the
necessary code compiled into each platform’s copy of
the class definitions.
 The way this approach works is by having separate
projects: one compiled for Silverlight and one compiled
for full .NET, with both sharing the same source files via
a Visual Studio feature known as linked files.
 Modify your solution by adding two new projects:
■
A .NET 4 Class library named WcfServiceExample
.Model.Net
■
A Silverlight 5 Class library named WcfService-
Example.Model.Silverlight
Delete the default Class1.cs file from each project.
When complete, you should have a solution which looks
like figure 20.3.
 The two projects are in place, each targeting the
appropriate platform. But they have different default
namespaces, something that will bite you later when adding classes. To fix this, right-
click each of the two projects and select Properties. On the main tab, you’ll see an
Assembly Name field and a Default Namespace field. Leave the assembly name alone,
but remove the platform suffix from the default namespace so it contains only Wcf-
ServiceExample.Model. Figure 20.4 shows a portion of the property page with the
correct namespace.
Figure 20.3
The solution with 
the two model projects, default 
classes removed
Figure 20.4
Setting the default namespace on the project property page

506
CHAPTER 20
Working with SOAP services
 Synchronizing the default namespaces isn’t strictly necessary, but it saves you from
obscure errors later on. You want to be able to share the source files without worrying
about namespace differences on the server and client. If you don’t change the default
namespace, you’ll need to manually check and edit the classes to synchronize the
namespace.
 Next, you’ll want to add the Customer class. I typically use the Silverlight project as
the master project, but you can pick either one; it doesn’t matter as long as you’re
consistent. Stick with me on this one and add a new class named Customer to the Wcf-
ServiceExample.Model.Silverlight project.
 Paste the Customer class you previously had directly into this class file. Remove the
DataContract attribute. Right-click the using statements and select Organize Usings
> Remove Unused Usings. In this case, it should remove all the using statements. This
step is important because, by default, the class template includes a bunch of Silver-
light/WPF-specific stuff you don’t want in your model.
 Listing 20.9 shows the completed Customer class in the Silverlight class library
project.
namespace WcfServiceExample.Model
{
  public class Customer
  {
    public int ID { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public decimal Balance { get; set; }
  }
}
With the master file in place, the next step is to add a link to it to the .NET model proj-
ect. Right-click the WcfServiceExample.Model.Net project and select Add > Existing
Item.
 Navigate to the location of the Customer.cs in the Silverlight project. Rather than
clicking Add, click the drop-down arrow on the right of the button. You’ll be pre-
sented with a menu that includes the default Add function, as well as a second Add as
Link function. As you may have guessed, Add as Link is what you want. Figure 20.5
shows this menu.
 The two projects will both point to the same physical source file; changes to the file
in one project will automatically be made in the second project. You’ll notice a small
shortcut icon overlaid on the linked file to remind you that it is, in fact, linked.
Listing 20.9
The Customer model class

507
Using WCF services and complex data types
You won’t have to do anything special to the linked file in order to maintain this rela-
tionship. But if you add any additional shared files, you’ll need to manually add them
as links in the project.
 The next steps are to remove the Customer definition from the CustomerService
file in the ASP.NET project, add a project reference from the Silverlight application to
the .Model.Silverlight project, and add a reference from the ASP.NET application to
the .Model.Net project. Finally, right-click and resolve the Customer class reference in
Linked files and cross-compilation
I’ve worked on projects where I had to share source between WPF and Silverlight, as
well as Silverlight and Windows Phone 7. For some demos, I’ve even shared source
between ASP.NET, WPF, Silverlight, and WP7. This is all accomplished using linked
files.
This works because .NET is supported on so many platforms. Of course, you have to
restrict yourself to the subset of .NET that will work across all targeted platforms. If
you have functionality that requires specific features of a platform, use either condi-
tional compilation or partial classes to add those features to a specific implementa-
tion. I prefer the partial class approach because it’s nice and clean, and it easily allows
completely different implementations of the same functions across all targeted plat-
forms.
Figure 20.5
Adding an existing file to a project using the Add as Link feature

508
CHAPTER 20
Working with SOAP services
the CustomerService class. Doing so will automatically generate the appropriate
using statement for you. Build the solution to make sure everything compiles.
 Make sure you do this before moving on to the next step.
20.2.3 Adding the service reference
Now that you have a web project pointing to your full .NET model and a Silverlight
application pointing to the Silverlight model, you can add a service reference and
generate the proxy.
 The reason you must add the project references before doing anything else is due
to how the client proxy generator decides whether to generate a copy of the model
class. If the model class doesn’t already exist on the client, it’ll create a copy—some-
thing you want to avoid.
 Right-click the Silverlight client project and select Add Service Reference. Click
the Discover button and you should see your CustomerService WCF service show up.
Change the namespace to Services and rather than click OK, click the Advanced but-
ton. Figure 20.6 shows the Service Reference Settings dialog that displays.
Figure 20.6
The Advanced Settings available when adding a service reference

509
Using WCF services and complex data types
Note the Reuse Types in Referenced Assemblies check box. In Silverlight, this option
is checked by default. For WPF and other full .NET projects, it isn’t. This setting allows
you to avoid creating a copy of the types used in the WCF Service.
 Click OK in this dialog and then in the main Add Service Reference dialog to cre-
ate the service reference and generate the proxy. Doing so also generates the client
configuration file, which you’ll look at shortly. First, you’ll need to create some basic
UI to test the service.
20.2.4 Using the service
To test the service, you’ll create a sim-
ple UI that has a field for the ID to
search for, a button to execute the ser-
vice call, and individual TextBlock
fields bound to the resulting Customer
object. Figure 20.7 shows how this UI
will look on the design surface.
 Listing 20.10 shows the XAML for
the MainPage in this project. The
structure of the UI is a main table with
two nested tables. The first table con-
tains the search controls; the second
contains four rows with data fields.
<Grid x:Name="LayoutRoot" Background="White" Margin="15">
  <Grid.RowDefinitions>
    <RowDefinition Height="Auto" />
    <RowDefinition Height="Auto" />
  </Grid.RowDefinitions>
  <Grid Grid.Row="0" Margin="10">           
    <Grid.ColumnDefinitions>
      <ColumnDefinition Width="Auto" />
      <ColumnDefinition Width="Auto" />
      <ColumnDefinition Width="90" />
    </Grid.ColumnDefinitions>
    <TextBlock Text="Search for ID"
               VerticalAlignment="Center" Grid.Column="0" />
    <TextBox x:Name="SearchID" VerticalAlignment="Center"
               Margin="5" Text="42" Width="100" Grid.Column="1" />
    <Button x:Name="Search"
            VerticalAlignment="Center" Margin="5" 
            Content="Search" Grid.Column="2"
            Click="Search_Click" />
  </Grid>
  <Grid Grid.Row="1" Margin="10">        
Listing 20.10
User interface XAML
Figure 20.7
The UI to use in testing the WCF service
Search interface
Data fields

510
CHAPTER 20
Working with SOAP services
    <Grid.ColumnDefinitions>
      <ColumnDefinition Width="100" />
      <ColumnDefinition Width="*" />
    </Grid.ColumnDefinitions>
    <Grid.RowDefinitions>
      <RowDefinition Height="Auto" />
      <RowDefinition Height="Auto" />
      <RowDefinition Height="Auto" />
      <RowDefinition Height="Auto" />
    </Grid.RowDefinitions>
    <TextBlock Text="ID" Grid.Row="0" Grid.Column="0" />
    <TextBlock Text="{Binding ID}" Grid.Row="0" Grid.Column="1" />
    <TextBlock Text="First Name" Grid.Row="1" Grid.Column="0" />
    <TextBlock Text="{Binding FirstName}" Grid.Row="1" Grid.Column="1" />
    <TextBlock Text="Last Name" Grid.Row="2" Grid.Column="0" />
    <TextBlock Text="{Binding LastName}" Grid.Row="2" Grid.Column="1" />
    <TextBlock Text="Balance" Grid.Row="3" Grid.Column="0" />
    <TextBlock Text="{Binding Balance}" Grid.Row="3" Grid.Column="1" />
  </Grid>
</Grid>
To keep things simple, you’ll have a single code-behind event handler called from the
click event of the Search button. In my production applications, the approach I’ve fol-
lowed is to bind the search field to a property of my view model, and have the search
button wired to a command on the same virtual machine. You’ll see examples of that
approach in chapter 33.
 Listing 20.11 shows the entire code-behind file for the MainPage of this applica-
tion. I did throw a little guard condition in there so it’s not entirely demoware.4
using System.Windows;
using System.Windows.Controls;
using WcfServiceExample.Services;
namespace WcfServiceExample
{
  public partial class MainPage : UserControl
  {
    public MainPage()
    {
      InitializeComponent();
    }
    private void Search_Click(object sender, RoutedEventArgs e)
    {
      int searchId;
Listing 20.11
The service call
4  Okay, I know I’m not fooling anyone. Just nod, wink, and move along. If you don’t keep a happy face, I’ll
have to wish you to the cornfield (or TV, depending on which version you watched).

511
Using the configuration file
      if (int.TryParse(SearchID.Text, out searchId))  
      {
        var client = new CustomerServiceClient();
        client.GetCustomerByIDCompleted += (s, ea) => 
        {
          DataContext = ea.Result;
        };
        client.GetCustomerByIDAsync(searchId);
      }
      else
      {
        MessageBox.Show("Invalid ID. Please enter a number.");
      }
    }
  }
}
You can see from this listing that the same client technology you used with the ASP.NET
web service (the WCF service client) is used when working with a WCF service. This
makes it easy to program against a variety of services, regardless of server technology.
 When you click the Search button, the event handler fires off. The first thing it
does is check to see if the entered ID is a valid integer. If so, it creates an instance of
your CustomerServiceClient, wires up the completed event, and calls the async ser-
vice method.
 Inside the GetCustomerByIDCompleted event handler, you handle populating all
the form fields through data binding. You set the DataContext to the returned
Customer object, and the fields take care of filling themselves.
 You’ll note that in this example, unlike the previous examples, you didn’t set up an
endpoint address. In fact, it’s very little code to make the call. That’s because you’re
relying on the generated client configuration file to contain all the important address-
ing bits. 
20.3
Using the configuration file
So far, you’ve seen the slightly more verbose way of calling a service, where all the end-
point information is handled in code. Silverlight provides another option: you can use
the information in the ServiceReferences.ClientConfig file.
NOTE
ServiceReferences.ClientConfig is an XML file created automatically
when you add a service reference. It’s packaged into the XAP file (see chapter
3 for more on XAP files) and is deployed with your application. You may
update this configuration file at any time by unzipping the XAP, changing the
file, and rezipping it.
An example configuration file is shown in listing 20.12. The configuration file speci-
fies, among other things, the type of encoding, the maximum receive message and
buffer sizes, the binding contract, and endpoint information.
Guard
Event handler
Call service

512
CHAPTER 20
Working with SOAP services
<configuration>
  <system.serviceModel>
    <bindings>
      <customBinding>
        <binding name="CustomBinding_CustomerService">
          <binaryMessageEncoding />                  
          <httpTransport maxReceivedMessageSize="2147483647"
                         maxBufferSize="2147483647"/>
        </binding>
      </customBinding>
      </bindings>
      <client>
        <endpoint                               
        ➥ address="http://localhost:18567/Services/CustomerService.svc"
           binding="customBinding"
           bindingConfiguration="CustomBinding_CustomerService"
           contract="Services.CustomerService"
           name="CustomBinding_CustomerService" />
      </client>
  </system.serviceModel>
</configuration>
This example uses the relatively new WCF binary encoding with a WCF SOAP service on
the server, a feature enabled by default in Silverlight when using the Silverlight-
Enabled WCF Service template.
Listing 20.12
The ServiceReferences.ClientConfig file
What about NetTcp? 
Another protocol option, which like binary SOAP is specific to WCF, is the NetTcp pro-
tocol. Silverlight 4 added support for that protocol using the net.tcp:// scheme. This
is a lighter-weight protocol that eliminates the overhead of HTTP in the transaction.
Although I won’t go into detail here, because it’s not commonly used and requires no
real changes to your code, I do want to mention that even when using NetTcp, you
need to have a policy file on a regular port 80 HTTP server at the same IP address as
your NetTcp service. The protocol to include in the Client Access Policy is tcp:
<grant-to>
  <socket-resource port="4502-4534" protocol="tcp" />
</grant-to>
If you leave the policy file out or don’t have the server mapped correctly, you’ll receive
a rather long-winded CommunicationException that tells you the socket connection
was forbidden.
To test, open your browser and browse to
http://<IpAddressOfYourNetTcpService>:80/clientaccesspolicy.xml
and verify that the file downloads. If it does, you’re good. If not, then you need to check
your IP address and domain names.
Other than that, you use NetTcp just as you would SOAP or SOAP with binary encoding.
From a proxy usage standpoint, there are no important differences.
Binary 
encoding
Buffer/message
size limits
Endpoint 
definition

513
Error handling with WCF
In configuration, you can set the URL to be anything you wish, but you must remem-
ber to change it when moving between servers (such as from development to test to
staging to production). Given that this doesn’t require a recompile and the format is
XML inside a standard zip, there’s little risk to this approach.
 So far your services have been simple, and they’ve always worked. What do you do
when you have exceptions on the service? I’ll look at that next. 
20.4
Error handling with WCF
Services often depend on resources like databases. Databases go down, network con-
nections get lost, dependencies suddenly disappear. All of these situations can lead to
exceptions. You could just ignore them, but being a good developer, you’re going to
look at ways to handle errors and send them back down to the client.
 One of the nice things about WCF is the ability to throw exceptions on a service
call. Unfortunately, Silverlight doesn’t support this natively. Any exception thrown by
the service gets translated by the browser into a 404 File Not Found error. Silverlight
can’t receive the 500 status codes that WCF would normally send back. 
 There are several ways around this. The first is to use an out parameter to contain
the error information. The second is to turn on debug exception information. The
third is to use WCF SOAP Faults. The out parameter approach is good for metadata in
general, not just errors, and requires very little effort to use. The debug exception
information is something you only want to use while developing. WCF SOAP Faults,
though more effort, are a nice standards-based way to expose the service errors.
20.4.1 Using an out parameter
Take the CustomerService example you’ve been working on and add a new class
named ServiceError. Remember to add it as a linked file. When done, the original
should be in the .Model.Silverlight project and the linked file in the .Model.Net
project. 
namespace WcfServiceExample.Model
{
    public class ServiceError
    {
        public string Message { get; set; }
    }
}
Listing 20.13 shows a basic class that contains only the error message. You could
enhance this to include almost anything you’d want: exception details, error codes,
and more. To use this class, pass it as an out parameter on the service call. Listing
20.14 shows the updated service method with the new out parameter and a little
dummy code to force an error.
Listing 20.13
ServiceError class to be used in the service call

514
CHAPTER 20
Working with SOAP services
[OperationContract]
public Customer GetCustomerByID(int id, 
                                out ServiceError serviceError) 
{
  if (id < 1)
  {
    serviceError = new ServiceError() 
             { Message = "Invalid customer ID" };
    return null;
  }
  else
  {
    serviceError = null;
    return new Customer()
      {
        ID = id,
        Balance = 200.50M,
        FirstName = "Pete",
        LastName = "Brown"
      };
  }
}
Before trying to create the client, be sure to build the web project, then right-click the
service reference on the Silverlight client and choose “Update Service Reference.”
When the signature of the WCF service contains an out parameter, you can access it
directly through the EventArgs on the event handler for the completed call, as shown
in listing 20.15.
private void Search_Click(object sender, RoutedEventArgs e)
{
  int searchId;
  if (int.TryParse(SearchID.Text, out searchId))
  {
    var client = new CustomerServiceClient();
    client.GetCustomerByIDCompleted += (s, ea) =>
      {
        var error = ea.serviceError;                    
        if (error != null)
        {
          MessageBox.Show(error.Message);
        }
        DataContext = ea.Result;
      };
    client.GetCustomerByIDAsync(searchId);
  }
Listing 20.14
WCF service with an out parameter
Listing 20.15
Reading an out parameter from a WCF service
Out 
parameter
Out 
parameter

515
Error handling with WCF
  else
  {
    MessageBox.Show("Invalid ID. Please enter a number.");
  }
}
Run the code from this listing and enter the value 0 in the text box. You should get a
message stating that the number is an invalid customer ID.
 The WCF service’s out parameter shows up as a property of the EventArgs passed
into the handler. This makes for a convenient way to pass back optional information
without dirtying your return results with wrapper classes full of metadata.
 Although I show this useful feature in the context of error handling, with .NET 4
and Silverlight 5, you have a more official way of handling back error information
when using the browser networking stack: the WCF service fault. First let’s look at how
the client HTTP stack (introduced in chapter 19) can save you a lot of grief.
20.4.2 Exposing exception information for debugging
When debugging WCF services, there’s an easy way to expose exception (fault) infor-
mation for testing purposes. Simply crack open the web.config and set the include-
ExceptionDetailsInFaults property to true:
<behavior name="">
  <serviceMetadata httpGetEnabled="true" />
  <serviceDebug includeExceptionDetailInFaults="true" />
</behavior>
Once you do that, the exception information will be made available to the client via
the Error property of the returned EventArgs. This can be a little tricky to debug,
though, because the idea will break on code inside service (that’s okay), then on the
generated code in the client proxy (not so useful). You’ll either need to skip those
manually, or run in regular (not debugging) mode.
WARNING
Don’t do this in production. Exposing exception information
directly to the calling client is a bad idea. Often, exception details include
enough information for a hacker to be able to figure out code structure, data-
base structure, or more.
Listing 20.16 shows how to catch the exception information returned as part of the
WCF SOAP fault. 
private void Search_Click(object sender, RoutedEventArgs e)
{
  int searchId;
  if (int.TryParse(SearchID.Text, out searchId))
  {
    var client = new CustomerServiceClient();
Listing 20.16
Catching the WCF fault

516
CHAPTER 20
Working with SOAP services
    client.GetCustomerByIDCompleted += (s, ea) =>
      {
        if (ea.Error != null)
        {
          MessageBox.Show(ea.Error.Message);   
        }
        else
        {
          DataContext = ea.Result;
        }
      };
    client.GetCustomerByIDAsync(searchId);
  }
  else
  {
    MessageBox.Show("Invalid customer ID. Please enter a number.");
  }
}
In this example, you have access to all the exception information via the Error prop-
erty of the AsyncCompletedEventArgs class. Remember, this will work only if you set
the web.config property as previously mentioned.
 That’s all good for debugging, but it can be tempting to leave it in place once you
move to production because it’s so darn easy to implement. Please don’t. Pretty
please.5 There’s a better way to handle exceptions in WCF services.
20.4.3 Error handling with WCF SOAP faults
When you created the WCF service in the ASP.NET project, you may have noticed the
automatic inclusion of a class named SilverlightFaultBehavior. This class was intro-
duced officially with Silverlight 4 with the support for SOAP faults but didn’t make it
into the template itself until later. 
 The SilverlightFaultBehavior class provides a structured way to make the
exception information available to the client in the form of a SOAP fault. Exceptions
in the WCF service are packaged as SOAP faults and sent back to the client. On the cli-
ent, they’re converted from SOAP faults into fault exceptions.
NOTE
There’s a lot of outdated information on the web concerning
SilverlightFaultBehavior. Most are using an older approach that’s harder
to get working. You don’t necessarily need to make web.config entry changes
or move the behavior to a separate assembly to use this fault behavior as an
attribute.
Before you can update the service reference and use your class, you need to use an
attribute on the service method to indicate the custom fault type you’re going to use.
In this case, you’ll reuse the ServiceError class you’d defined earlier. Because you’d
5  http://youtu.be/SMhwddNQSWQ  
Exception 
information

517
Error handling with WCF
already shared that class with the client, the attribute isn’t technically necessary, but
it’s a good practice to include it. Listing 20.17 shows the attributes in use.
[OperationContract]
[SilverlightFaultBehavior]     
[FaultContract(typeof(ServiceError))]
public Customer GetCustomerByID(int id)
{
  if (id < 1)
  {
    var error = new ServiceError() 
               { Message = "Invalid customer ID" };
    throw new FaultException<ServiceError>(error); 
  }
  return new Customer()
    {
      ID = id,
      Balance = 200.50M,
      FirstName = "Pete",
      LastName = "Brown"
    };
}
The FaultContract attribute tells the client proxy generator and the WCF WSDL gen-
erator to include the ServiceError class in the service contract information. The
SilverlightFaultBehavior attribute tells WCF to package any FaultException as a
SOAP fault and send it back to the client.
 With the attributes in place, you can then throw a fault exception, passing in the
ServiceError instance to hold any additional details you wish to pass to the client.
Note that you’re not simply trapping an exception and including that information in
the FaultException directly, because that could expose sensitive information to the
client. Instead, you’re explicitly controlling what will show up in the information sent
to any client.
 To cover all the bases, you could also include a general try/catch block, which
would then pass back a nondescript error message to the client. In practice, that’s
rarely needed if the individual steps in the method each have try/catch blocks that
can then throw a FaultException with nonsensitive details about that specific step.
 Listing 20.18 shows how to access the fault details on the client. Before typing in
this code, build the project and update the service reference.
private void Search_Click(object sender, RoutedEventArgs e)
{
  int searchId;
  if (int.TryParse(SearchID.Text, out searchId))
Listing 20.17
Using the SilverlightFaultBehavior attribute
Listing 20.18
Trapping the fault on the client
Fault behavior
Throw fault 
exception

518
CHAPTER 20
Working with SOAP services
  {
    var client = new CustomerServiceClient();
    client.GetCustomerByIDCompleted += (s, ea) =>
      {
        if (ea.Error != null)
        {
          var fault = ea.Error as FaultException<ServiceError>;
          if (fault != null)
            MessageBox.Show(fault.Detail.Message);   
          else
            MessageBox.Show(ea.Error.Message);
         }
         else
         {
           DataContext = ea.Result;
         }
       };
    client.GetCustomerByIDAsync(searchId);
  }
  else
  {
    MessageBox.Show("Invalid ID. Please enter a number.");
  }
}
In listing 20.18, which builds on the previous listings in this chapter, you check to see
if you’ve received an error form the service. If you have, and the error is a Fault-
Exception with ServiceError details, then you show the details. If not, you show the
error message.
 When you consider that, for the purposes of web services, error information is just
data, there are a number of ways to get the error information back to the client.
Although I recommend standardizing on a single approach in your project, you may
find that using a combination of these methods makes the most sense for your appli-
cations. If in doubt as to which method to use in your large production application,
err on the side of standards, and use the WCF SOAP faults approach.
20.5
Summary
If you want to get remote information to or from a Silverlight application, networking
is a necessity. If you’re writing business applications, that networking will typically take
the form of SOAP services.
SOAP is an easy and very .NET-friendly way to get into services. In fact, ASP.NET web
services were available in the very first versions of .NET and were considered a huge
improvement over DCOM, MTS, COM+, and other remote technologies available at the
time. It had to compete with .NET Remoting, and in the court of public opinion, won
out due to simplicity and internet-friendliness.
FaultException 
details

519
Summary
 When working on a 100 percent .NET stack, you have two primary ways to create
SOAP services: ASP.NET and WCF. For a long time, ASP.NET was considered the easiest to
use, but the introduction of the Silverlight-enabled WCF service removed most of the
ceremony and extra endpoint information in order to create a lean and mean SOAP ser-
vice that anyone can use. The additional flexibility of WCF makes it a no-brainer to con-
sider WCF the primary choice for creating SOAP services on the .NET stack.
 Because SOAP was originally conceived to be platform-independent (in fact, its
largest early use came from Java), error handling with SOAP services can be challeng-
ing. In this chapter, I provided a few approaches you can use when you need to get
faults back to your Silverlight client. Each of them is useful in different situations.
SOAP services, both ASP.NET ASMX services, and WCF services are extremely popular
behind the firewall in your business applications. For a while, they saw uptake on the
broader internet as well. But the day of the massive SOAP API is coming to a close.
There’s a newer and even simpler type of service rising to prominence, used by most of
the API-driven web properties today: REST. I’ll take a look at REST in the next chapter.

520
RESTful services with the
ASP.NET Web API
Representational State Transfer, or REST, means several things; in this case, it refers to
the approach of making services accessible through a set of simple URIs and HTTP
verbs. Before the days of web services and stateful web applications, almost every-
thing on the web was RESTful, meaning that all traffic over HTTP used one of the
HTTP verbs to define its purpose, and calls were complete without requiring server-
side state. Over the years, the use of these verbs dwindled down to nearly all traffic
using only the GET and POST verbs for requesting a page and submitting form data,
respectively. Over the past few years there’s been a trend toward moving from com-
plex web services to a much simpler framework.
 Many web service providers incorrectly use the term REST to mean any service
that isn’t SOAP. The main thing to realize is that the URI, and possibly the HTTP
verb, may change depending on the action being performed. Typically, a creator of
This chapter covers
■
Using the ASP .NET Web API
■
Sharing entities with Silverlight
■
Consuming RESTful Services
■
Enabling additional HTTP verbs

521
RESTful services will try to follow an intuitive structure where the URI first contains
a type followed by an instance. For example, a URI with the structure http://www
.arestfuldomain.com/Users (not a real domain) might return an array of user records,
whereas the URI http://www.arestfuldomain.com/Users/JohnSmith might return a
single user record for John Smith or http://www.arestfuldomain.com/Users/3863827
might return the user with the ID 3863827. Although the most common pattern, struc-
turing the URL in these ways isn’t a hard and fast rule of RESTful services; it’s more of
a guideline.
 Silverlight currently supports only the GET and POST verbs when using the default
browser networking stack (see chapter 19 for more networking stack options). This is
consistent with how browsers work on the web where the vast majority of the data is
read-only. Firing up IE or Chrome and issuing DELETE requests to sites you dislike cer-
tainly sounds like fun, but that’s not generally how browsers work. To use verbs such as
PUT and DELETE (or perhaps even PATCH for you crazy Rails folks), you must switch
over to the client networking stack. 
 In this chapter, you’ll learn how to work with REST services and see how to call meth-
ods to add, update, delete, and retrieve entities from a server. Along the way I’ll touch
on a bunch of interesting techniques you’ll use in real-world applications. You’ll work
with a great toolkit that can be used for creating RESTful services, and you’ll set up an
ASP.NET MVC project to host those services and the Silverlight client application. I’ll
take a brief look at a simplified version of the MVVM pattern, perform some code shar-
ing between ASP.NET and Silverlight, and even do a little conditional compilation. 
 My use of Twitter when discussing APIs is getting a little long in the tooth, so I’ll start
with something I think will be a useful skill: creating your own RESTful service in
ASP.NET. You’ll be forgiven for wondering why on earth I’d dedicate a chunk of the
chapter on creating the server side of services. This book is primarily about Silverlight,
but in the broader sense, it’s here to help you be successful writing real-world applica-
tions. Sometimes that means a little database setup or server-side code to bring it home.
 Just as SOAP services were the thing in the early 2000s, RESTful services are becom-
ing the popular way for exposing data on the internet and intranet. They are insanely
simple to use and friendly to all types of consumers. You may recall that if your plat-
form of choice didn’t have a good SOAP1 toolkit, you had to write a lot of code to cre-
ate and parse SOAP envelopes. The overhead for RESTful services is so much lower
that all you need is a way to call URLs.
 The downloadable source code has everything in this chapter, including the ser-
vice code. That way, you can read about how to implement it, but if you don’t want to
go through the steps, you can use the preconfigured project in preparation for sec-
tion 21.1.4.
 In this chapter, you’ll also put into practice the code sharing approach you learned
in the previous chapter, using conditional compilation to enable you to have client-
1 I was on a project in the early 2000s where we had to make SOAP calls to a mainframe. The mainframe SOAP
services were custom built in COBOL. Yes, COBOL. No toolkit; all custom code. The lobotomy scars still itch.

522
CHAPTER 21
RESTful services with the ASP.NET Web API
specific code in the same source files. Although you won’t explore it in detail until
chapter 35, you’ll also use a basic view model to keep the code clean. There’s a ton of
cool and useful stuff in this chapter, so let’s get to it.
21.1
Creating a RESTful service using the ASP.NET Web API 
Many services expose REST APIs, but I consider it useful and interesting to learn how to
create your own RESTful service using some of the newer features in WCF. For this, you’ll
create a Silverlight application project with an MVC 4 web project in the solution. The
latest version of the ASP.NET Web API provides great integration with MVC 4, and is built
on the same general patterns. This makes sense when you consider that MVC can be
very RESTful to begin with. Once the bits are installed, you’ll create a simple RESTful
service you can use throughout most of the rest of this chapter and the next.
 In the past, if you wanted to create a RESTful service, you had a few options, none
of which were particularly friendly or easy:
WCF—You could create SVC endpoints using older WCF constructs, knowing that
HTTP was more of a transport option than a first-class player. The configuration bur-
den alone turned many people off to that approach.
Custom handlers—You could create HTTP handlers to map URIs to resources. This
approach gave you the most flexibility, but it required you to write code that ran pretty
early in the pipeline and therefore was more difficult to integrate into a larger solution.
MVC controllers—You could create an MVC application and fiddle with routing
enough to forward all the RESTful requests to your own implementation class. This is
the newest manual approach and is certainly one of the easiest. In fact, it’s this
approach that has been formalized as the ASP.NET Web API.
 The first version of the ASP.NET Web API was introduced on CodePlex as the WCF
Web API and made to be easily used from ASP.NET MVC 3 projects and even classic
ASP.NET projects. Reflecting the integration of the actual teams, the latest version is
integrated directly into ASP.NET MVC 4, using MVC routing and controller patterns,
and has been renamed the ASP.NET Web API.
Not just for RESTful services
The ASP.NET Web API is a set of tools to build first-class HTTP services. In most cases,
that will mean RESTful services, but the Web API is by no means limited to that. You
can take REST as far as you want with this toolkit, or you can use the toolkit to im-
plement an entirely different web service protocol.
You can implement just about any HTTP-based protocol on top of the ASP.NET Web
API. RESTful services just happen to be the ones that are closest to base HTTP in
design and function.
In this chapter I’ll use the terms REST and RESTful rather loosely. That is, they’ll be
services that use HTTP verbs to perform actions on server-side resources. I won’t be
taking it to the nth degree and doing something that is fully hypermedia or that explores

523
Creating a RESTful service using the ASP.NET Web API 
That all adds up to a skill that’s useful for .NET developers in general, and because
Silverlight must use services to connect to remote resources, Silverlight developers
specifically. Creating the services here also allows you to have something controlled
that you can call from Silverlight and step into while debugging. We all know how
reliable Twitter is, and who knows if their web API would be the same by the time you
read this chapter.
21.1.1 Solution setup
Your solution is ultimately going to include an ASP.NET MVC 4 project, a Silverlight cli-
ent, and two model projects. The Silverlight client will use one of the model projects
to facilitate easy deserialization of the data, the actual implementation of which will be
in the next chapter. The client will also speak directly to the RESTful services hosted in
the MVC project and perform basic CRUD (Create, Read, Update, Delete) operations
through it. 
 First, install ASP.NET MVC 4. You can find it on the official ASP.NET website http://
www.asp.net/mvc/mvc4. The Web Platform Installer (WebPI) approach offered there
is one of the easiest ways to get MVC installed. (Be sure to shut down Visual Studio
before installing.) Although the version I used when writing this book is MVC 4 Beta, I
expect there to be a later version available by the time you read this. There may be
some code changes with later versions, but I expect them to be minimal.
 If for some reason the WebPI approach doesn’t work on your machine, you can
download the installer and run it manually using the link on the same page. Use
whichever approach works best for you. You don’t need any additional libraries or
templates from WebPI, so exit it after MVC installs. 
 Once MVC is installed, the next step is to create a web project. Create an ASP.NET
MVC 4 Web Application named RestExample.Web in a solution named RestExample.
You’ll need to manually change the solution name in the dialog after typing the proj-
ect name. Figure 21.1 shows the correct template selected in the New Project dialog.
(continued)
the full potential of REST. You may certainly do that in your own applications. If you’re
not familiar with hypermedia, I encourage you to do some investigation—it’s truly an
exciting area with real impact on how you think about APIs and their contracts with
consumers.
My thanks to Howard Dierking from the WCF team for sitting down with me one day
in building 18 in Redmond and absolutely blowing my mind with the potential for REST,
hypermedia, and the (at that time) WCF Web API.
Knowing that there are people who live and breathe this stuff every day, I’ll stick to
the basics of use here and leave the specifics of what makes something truly RESTful
to the experts in that area.

524
CHAPTER 21
RESTful services with the ASP.NET Web API
Figure 21.1
Creating the RestExample.Web project in the RestExample solution using the MVC 4 
template
   When prompted (after clicking
OK), choose the option to create
a Web API project using the Razor
view engine, as shown in figure
21.2.
   When you click OK in this dia-
log, the appropriate packages will
be downloaded via NuGet and
installed into the project. In pre-
vious versions, you had to per-
form this step manually, so this is
a great time-saver.
   Before you go in and add the
service implementation code and
configuration, you want to lock
the web project’s server port to
9090. I showed you how to do this
in chapter 20. To refresh your
memory: right-click the web proj-
ect and select Properties. On the
Figure 21.2
The project template options dialog with the 
appropriate Web API settings

525
Creating a RESTful service using the ASP.NET Web API 
Web tab of the property pages, select the Specific Port option and change the value to
9090. This is a convenience for purposes of testing and publication.
 You now have an ASP.NET MVC project that references the Web API components
and an example API controller. Next you can start creating the services.
21.1.2 Creating the services
Now the exciting part: you’re going to create a set of services you can consume from
your Silverlight application. Taking a cue from chapter 20, you’ll base this API around
a Customer class. Also taking advice from the previous chapter, you’ll create it as a
shared model project, sharing the same source files between Silverlight and ASP.NET.
 The reason behind using a shared model project won’t be apparent until you explore
serialization in the next chapter. But whenever you control both the client-side and the
server-side code, shared model projects are a no-brainer for cutting down on the
amount of code you need. You could also choose to go with Portable .NET class libraries,
but time and again, I find the shared file approach more appropriate and flexible.
 Create both a RestExample.Model.Silverlight Silverlight class library project, and a
RestExample.Model.Net regular .NET class library project. As you did in the previous
chapter, delete the default Class1.cs file from both, and change both default
namespaces to RestExample.Model. The namespace setting is in the project proper-
ties. Leave the assembly name at its default.
 Add a project reference from the MVC site to the full .NET model class library.
You’ll need this reference in order to create the service implementation. You’ll add
the Silverlight client and its own reference shortly.
THE CUSTOMER CLASS
Next, in the RestExample.Model.Silverlight project, add a new class named Customer,
the code for which is shown in listing 21.1. Once you type this code into that class, add
the class file to the RestExample.Model.Net project, as a link, as you did in chapter 20.
If you accidentally add it as a copy, the file will appear in the Solution Explorer with-
out the little arrow shortcut icon—in that case, delete it and try again.
namespace RestExample.Model
{
  public class Customer
  {
    public int ID { get; set; }
    public string LastName { get; set; }
    public string FirstName { get; set; }
    public decimal Balance { get; set; }
  }
}
NOTE Remember to remove all the extra Silverlight-specific namespaces in this
file. You don’t need all that System.Windows stuff in a model project, and it
gets in the way when sharing code. The easiest way to clean up the using
Listing 21.1
The Customer class in the model project

526
CHAPTER 21
RESTful services with the ASP.NET Web API
statements is to right-click on any using statement, select the option Organize
Using Statements and then the option Remove Unused Using Statements. In
our case, it’ll remove them all.
This class should look familiar—it’s the same Customer class you used in chapter 20.
Once you have the Customer class in place, you’ll need to provide a repository of cus-
tomers to handle all the retrieve and update operations. In a regular application, you’d
almost certainly use a database, probably via an ORM (unless you have one of those DBAs
who hate ORMs and require stored procedures and manual calling for everything). 
THE CUSTOMERREPOSITORY CLASS
To cut down on the moving parts for these examples, you’ll hard-code the customer
information data in the repository class and store the data in the ASP.NET in-memory
cache.
WARNING My caching approach here doesn’t support multiple clients. It’s a
quick way for you to see how the client API works with the RESTful service—
the purpose of this chapter. Don’t use this server-side caching approach in
your own applications unless you want to be quickly ushered out the back
door with all of your belongings tossed in a small box.
The Repository pattern is a well-known pattern for working with data sources. A typical
repository contains methods to get, update, and delete data, without requiring the
consumer of the repository to have any knowledge of the underlying data store. 
 Listing 21.2 shows the CustomerRepository class. Add a new folder named Data to
the MVC project and create the class there. If you have a different naming convention
for the repository location, other than Data, feel free to use it and adjust any
namespace declarations or using statements.
using System.Collections.Generic;
using System.Linq;
using System.Web;
using RestExample.Model;
namespace RestExample.Web.Data
{
  public class CustomerRepository
  {
    private List<Customer> _customers;
    private const string _key = "Customers";
    public CustomerRepository()                
    {
      if (HttpContext.Current.Cache[_key] == null)
      {
        _customers = new List<Customer>()
        {
          new Customer { ID=1, LastName="Brown", 
Listing 21.2
The CustomerRepository class
Load dummy data

527
Creating a RESTful service using the ASP.NET Web API 
              FirstName="Pete", Balance=250.07M },
          new Customer { ID=2, LastName="Galloway", 
              FirstName="Jon", Balance=1250.25M },
          new Customer { ID=3, LastName="Stagner", 
              FirstName="Joe", Balance=500.00M },
          new Customer { ID=4, LastName="Schweigert", 
              FirstName="Marc", Balance=1337.00M },
          new Customer { ID=5, LastName="Liberty", 
              FirstName="Jesse", Balance=1890.15M }
        };
        UpdateCache();                       
      }
      else
      {
        _customers = (List<Customer>)HttpContext.Current.Cache[_key];
      }
    }
    private void UpdateCache()
    {
      HttpContext.Current.Cache[_key] = _customers;
    }
    public List<Customer> GetAllCustomers()
    {
      return _customers;
    }
    public Customer GetSingleCustomerByID(int ID)
    {
      return _customers.Where(c => c.ID == ID).FirstOrDefault();
    }
    public Customer AddOrUpdate(Customer customer)
    {
      var existingCustomer = GetSingleCustomerByID(customer.ID);
      if (existingCustomer != null)
      { 
         existingCustomer.FirstName = customer.FirstName;
         existingCustomer.LastName = customer.LastName;
         existingCustomer.Balance = customer.Balance;
      }
      else
      {
        int id = _customers.Max(c => c.ID) + 1;           
        customer.ID = id;
        _customers.Add(customer);
      }
      return customer;
    }
    public void Delete(int id)                       
    {
Store data
Generate new ID
Delete

528
CHAPTER 21
RESTful services with the ASP.NET Web API
      var existingCustomer = GetSingleCustomerByID(id);
      if (existingCustomer != null)
        _customers.Remove(existingCustomer);
    }
  }
}
The repository implements two retrieve methods: one for returning a list of all cus-
tomers, the other for returning a single customer based on its ID. The GetSingle-
CustomerByID method uses a little lambda expression magic and an extension
method to return the Customer with that ID. The way FirstOrDefault works, if no
customer is found, it’ll return null. If you were to use only the First method, you’d
get an error in cases where no customer with that ID exists.
 The repository also implements an AddOrUpdate method. This method checks to
see if the ID exists in the data set. If it doesn’t, it considers it an add operation and
generates a new ID for it. The expected use case here is sending over a new Customer
with an ID of zero.
 Finally, the Delete method takes an ID and removes that Customer from the data set.
THE SERVICE ENDPOINT
The next step is to create the service controller. This is going to be the service end-
point—the equivalent of the SOAP SVC or ASMX in chapter 20. Right-click the Con-
trollers folder and select Add Controller. Figure 21.3 shows the dialog with the correct
options and name.
Figure 21.3
Adding a new API controller for the customer. The naming 
convention is an important part of how ASP.NET MVC works.

529
Creating a RESTful service using the ASP.NET Web API 
Be sure to name the controller correctly. It’s the controller name that implicitly
decides the routing you’ll use for the service. The template code with the addition of
the required operations for the CustomerController is shown in listing 21.3.
using System.Collections.Generic;
using System.Web.Http;
using RestExample.Model;
using RestExample.Web.Data;
namespace RestExample.Web.Controllers
{
  public class CustomerController : ApiController
  {
    // GET /api/customer
    public IEnumerable<Customer> Get()            
    {
      var rep = new CustomerRepository();
      return rep.GetAllCustomers();
    }
    // GET /api/customer/5
    public Customer Get(int id)                    
    {
      var rep = new CustomerRepository();
      return rep.GetSingleCustomerByID(id);
    }
    // POST /api/customer
    public Customer Post(Customer value)              
    {
      var rep = new CustomerRepository();
      Customer cust = rep.AddOrUpdate(value);
      return cust;
    }
    // PUT /api/customer/5
    public Customer Put(int id, Customer value)         
    {
      var rep = new CustomerRepository();
      Customer cust = rep.AddOrUpdate(value);
      return cust;
    }
        
    // DELETE /api/customer/5
    public Customer Delete(int id)                     
    {
      var rep = new CustomerRepository();
      var cust = rep.GetSingleCustomerByID(id);
Listing 21.3
The CustomerController class
GET multiple 
method
GET single 
method
POST method
PUT method
DELETE method

530
CHAPTER 21
RESTful services with the ASP.NET Web API
      if (cust != null)
        rep.Delete(id);
      return cust;
    }
  }
}
The listing shows your API controller class with two REST GET methods, a POST
method, a PUT method, and a DELETE method (you could also implement the newly
approved PATCH method if you want—it’ll work from Silverlight; I checked). The first
GET method returns all customers in the repository. The second method, which
expects an id parameter, returns a single customer based on its ID. It also shows a
POST method used for adding or updating customers, and a DELETE method for
removing customers. Notably, the DELETE method returns the customer to be
removed, because often REST methods return something: a status, a resource, or
something else. The PUT method is functionally equivalent to the POST method, but
the URI format is different. This approach is especially useful in situations where the
resource identifier can be generated from the client. Most API designers will want to
use POST or PUT for adding items, but not both.
 With that in place, you now have a REST service with GET capabilities. You get a
serious amount of functionality, including automatic routing, with only a little code.
Before you add the Silverlight client to the solution, let’s verify that the service works.
21.1.3 Testing the service using the browser
The nature of REST means you should be able to test the GET requests very easily
using an XML browser. When trying something new, it’s always a good idea to test at
several points along the way, so you know where your application is failing (assuming
it fails). 
 Start the web project. In the address bar, with the project running, type the follow-
ing URL:
http://localhost:9090/api/customer
You should get back a JSON representation of the entire set of customers. If you set a
breakpoint in the code, you’ll see it called the first Get method of the Customer-
Controller class. Next, modify the URL to pass in the customer’s ID, and call the
Get(id) method, like this:
http://localhost:9090/api/customer/1
You should get back a single customer, shockingly named “Pete Brown,” also in JSON
format. The api/customers part of the URL comes from the mapping automatically
applied to controllers in MVC. The ability to support an id parameter comes from the
second GET method you implemented in the API class, inferred from the parameter
list in the controller method.

531
Creating a RESTful service using the ASP.NET Web API 
 All the results here were JSON format. It’s also possible to get back XML, something
you’ll see later in this chapter. The ASP.NET Web API is extremely flexible, allowing
you choices in return formats, as well as the ability to support regular API URL struc-
tures or OData structures with minimal changes.
 Later in the chapter, you’ll add other REST operations, but it’s a good time to add
the Silverlight client into the solution and do a little client-side REST work.
21.1.4 Adding the Silverlight project
Another useful skill is learning how to add a new Silverlight client to an existing web
project. Because you had to create this server project as an MVC application, there was
no Silverlight application created as part of the solution. Let’s remedy that now.
 With the same solution open, right-click the solution and select Add > New Project.
When prompted in the dialog, select the basic Silverlight Application template. Name
the project RestClient. 
 You’ll then be prompted for version information as well as whether you want to
add this Silverlight project to an existing website. Yes, you want to add the Silverlight
project to the RestExample.Web web project, and you want a test page added to the
web project.
 You should now have a solution with a Silverlight project and the MVC project. But
you have ugly ASPX and HTML pages in your lovely MVC solution. Because this isn’t a
chapter about MVC, you’ll just deal with those for now.2 Keep in mind that in a regular
MVC project, you likely wouldn’t have those.
NOTE
While you’re here, add a reference from the Silverlight application to
the Silverlight model project you created earlier.
THE TEST XAML
With the project link in place, you’ll create a basic XAML UI that you’ll use to test the
REST services. The XAML needs to show the fields for the Customer object, as well as
have a few buttons for testing the different types of interfaces. 
 The XAML for the Silverlight MainPage is shown in listing 21.4. Replace the exist-
ing LayoutRoot with this markup.
<Grid x:Name="LayoutRoot" Background="White">
  <Grid Margin="10">
    <Grid.ColumnDefinitions>
      <ColumnDefinition Width="150" />
      <ColumnDefinition Width="*" />
    </Grid.ColumnDefinitions>
    <Grid Grid.Column="0" Margin="5">
2 Despite it being an interesting topic, I didn’t want to clutter this chapter with non-API controllers, views, and
other non-Silverlight/REST stuff. But I did write the beginning of a small MVC 3/4 Razor Helper for Silver-
light applications. You can find out more on my blog at http://bit.ly/RazorSLHelper.
Listing 21.4
The Silverlight XAML for testing the REST services

532
CHAPTER 21
RESTful services with the ASP.NET Web API
      <ListBox ItemsSource="{Binding Customers}"
               Margin="0 0 0 35"
               SelectedItem="{Binding SelectedCustomer, Mode=TwoWay}">
        <ListBox.ItemTemplate>
          <DataTemplate>                             
            <StackPanel Orientation="Horizontal">
              <TextBlock Text="{Binding LastName}" />
              <TextBlock Text=", " />
              <TextBlock Text="{Binding FirstName}" />
            </StackPanel>
          </DataTemplate>
        </ListBox.ItemTemplate>
      </ListBox>
      <Button x:Name="AddNewButton"                    
              Content="Add New" Width="80" Margin="5"
              HorizontalAlignment="Right"
              VerticalAlignment="Bottom"
              Click="AddNewButton_Click" />
    </Grid>
    <Grid Grid.Column="1" Margin="5"
          DataContext="{Binding SelectedCustomer}">
      <Grid.ColumnDefinitions>
        <ColumnDefinition Width="100" />
        <ColumnDefinition Width="*" />
      </Grid.ColumnDefinitions>
      <Grid.RowDefinitions>
        <RowDefinition Height="Auto" />
        <RowDefinition Height="Auto" />
        <RowDefinition Height="Auto" />
        <RowDefinition Height="Auto" />
        <RowDefinition Height="Auto" />
      </Grid.RowDefinitions>
      <TextBlock Text="ID" Grid.Row="0" Grid.Column="0" />
      <TextBox Text="{Binding ID, Mode=TwoWay}"
               Grid.Row="0" Grid.Column="1" />
      <TextBlock Text="First Name" Grid.Row="1" Grid.Column="0" />
      <TextBox Text="{Binding FirstName, Mode=TwoWay}"
               Grid.Row="1" Grid.Column="1" />
      <TextBlock Text="Last Name" Grid.Row="2" Grid.Column="0" />
      <TextBox Text="{Binding LastName, Mode=TwoWay}"
               Grid.Row="2" Grid.Column="1" />
      <TextBlock Text="Balance" Grid.Row="3" Grid.Column="0" />
      <TextBox 
Text="{Binding Balance, Mode=TwoWay, ValidatesOnExceptions=True}"
              Grid.Row="3" Grid.Column="1" />
      <StackPanel Grid.Row="4" Grid.Column="1"              
                  Width="120" HorizontalAlignment="Right">
        <Button x:Name="UpdateButton" Click="UpdateButton_Click"
                Margin="5" Content="Update Selected" />
        <Button x:Name="DeleteButton" Click="DeleteButton_Click"
                Margin="5" Content="Delete Selected" />
      </StackPanel>     
Data template
Add New button
Other buttons

533
Creating a RESTful service using the ASP.NET Web API 
    </Grid>
  </Grid>
</Grid>
The XAML UI contains a ListBox with a data template (covered in chapter 16) that
uses binding to display the name of the customer. It’s bound to a collection named
Customers, which you’ll create shortly. The details part of the form contains fields for
each of the properties of the Customer class. It also has buttons to create, save, and
delete a customer. The details form is bound to the SelectedCustomer property of the
data context, which is updated every time you select a different customer from the
ListBox.
 The resulting form, in the Visual Studio designer, looks like figure 21.4. Note that
you’ll see compile errors until you add in the code-behind.
 Admittedly, the user workflow is a little hokey, because I don’t want to have state
tracking in this code. Normally, the entities themselves or a separate entity would store
metadata about which records are new, which are existing, and so forth. I’ll discuss
state tracking when you work with WCF RIA Services in appendix D of the ebook. You’ll
use a simplified form of that: if the ID exists, it’s an update, and if the ID is new or
blank, it’s a new entity. The workflows are as follows:
■
Add: Click Add New, make changes on the right, and click Update Selected.
■
Update: Select the customer from the list, make changes on the right, and click
Update Selected.
■
Delete: Select the customer from the list, and click Delete Selected.
You’re going to have a number of functions here, including working with collections
of objects as well as individual entities. To make that easier, I’ll bite off a small chunk
of the MVVM pattern and include a view model.
Figure 21.4
The UI as seen in the 
designer. The ListBox 
is the rectangle on 
the left, above the 
Add New button.

534
CHAPTER 21
RESTful services with the ASP.NET Web API
THE TEST VIEW MODEL
The MVVM pattern (covered in chapter 33) is useful even when you bite off just a tiny
bit of it. In this case, you’re going to have a simple view model that’ll serve to provide
the UI with the data and functions it needs. You’ll use this view model as the data con-
text for this UI. You won’t bother with commanding, abstracting away your service
calls, or any of the other parts of MVVM I haven’t covered yet.
 Listing 21.5 shows the basic view model. Create this class, named MainViewModel,
in a folder named ViewModels in the Silverlight project.
using System.ComponentModel;
using RestExample.Model;
using System.Collections.ObjectModel;
namespace RestClient.ViewModels
{
  public class MainViewModel : INotifyPropertyChanged
  {
    private Customer _selectedCustomer; 
    public Customer SelectedCustomer                 
    {
      get { return _selectedCustomer; }
      set
      {
        _selectedCustomer = value;
        NotifyPropertyChanged("SelectedCustomer");
      }
    }
    private ObservableCollection<Customer> _customers = 
            new ObservableCollection<Customer>();
    public ObservableCollection<Customer> Customers
    {
      get { return _customers; }
    }
    public void AddNewLocalCustomer()
    {
      var customer = new Customer();
      _customers.Add(customer);
      SelectedCustomer = customer;
    }
    public void LoadCustomers()                       
    {
    }
    public void DeleteSelectedCustomer()         
    {
    }
Listing 21.5
The view model for the test UI
Get/Set 
SelectedCustomer
Load/get 
placeholder
Delete 
placeholder

535
Creating a RESTful service using the ASP.NET Web API 
    public void UpdateSelectedCustomer()               
    {
    }
    public event PropertyChangedEventHandler PropertyChanged;
    protected void NotifyPropertyChanged(string propertyName)
    {
      if (PropertyChanged != null)
        PropertyChanged(this, 
                        new PropertyChangedEventArgs(propertyName));
    }
  }
}
The LoadCustomers, DeleteSelectedCustomer, and UpdateSelectedCustomer meth-
ods are all empty. You’ll fill those out shortly. You’ll modify the code in these methods
several times throughout the remainder of this chapter, so keep the code file handy.
 To support binding with automatic change notification, this class has both an
ObservableCollection property named Customers and a SelectedCustomer prop-
erty that uses INotifyPropertyChanged. Those two bits of plumbing were covered in
chapter 16 on binding. It’s important to remember that if you want change notifica-
tions to fire on the properties when you set the values, you must access the property
itself, not the underlying member variable.
 As I mentioned, you won’t use commands or other MVVM constructs for this exam-
ple. To keep things familiar and simple, you’ll call view model methods from event
handlers in the code-behind. 
using System.Windows;
using System.Windows.Controls;
using RestClient.ViewModels;
namespace RestClient
{
  public partial class MainPage : UserControl
  {
    MainViewModel _vm;                        
    public MainPage()
    {
      InitializeComponent();
      _vm = new MainViewModel();
      DataContext = _vm;                       
      _vm.LoadCustomers();                    
    }
    private void UpdateButton_Click(
                 object sender, RoutedEventArgs e)
    {
Listing 21.6
The code-behind wiring the UI to the view model
Update/post 
placeholder
View model
Data context
Data loading

536
CHAPTER 21
RESTful services with the ASP.NET Web API
      _vm.UpdateSelectedCustomer();
    }
    private void DeleteButton_Click(
                 object sender, RoutedEventArgs e)
    {
      _vm.DeleteSelectedCustomer();
    }
    private void AddNewButton_Click(
                 object sender, RoutedEventArgs e)
    {
      _vm.AddNewLocalCustomer();
    }
  }
}
Listing 21.6 includes the necessary code-behind wire-up for this example. After you
type or paste this in, the application should compile.
 This listing also shows a reference to the view model created in the page’s con-
structor. The view model is just a convenient single object for you to bind to and call
methods on. Also in the constructor, you set the data context of the page to this view
model instance. As you learned in chapter 16, the data context is the object against
which binding statements are relative. Therefore, you can have a statement such as
{Binding SelectedCustomer} in your markup, and it’ll resolve to _vm.Selected-
Customer because _vm is the data context.
 Also in the constructor is the call to load the customer data.3 The intent is to have
the customer data fully populated and on-screen when shown. It’s important to have
the view model creation, data context set, and load call all done after the Initialize-
Component call. Otherwise, the binding system isn’t yet ready, and although it may
work sometimes, on a complex form you’ll likely run into a race condition where your
change notifications happen before the binding system is ready to process them.
 The individual button click handlers are very lean—they simply call methods on
the view model object. In chapter 33 you’ll learn how you can use command objects to
eliminate even this little bit of event handler code, should you wish to.
 Before you wire up the REST service calls, it’s time for more testing.
THE LIMITATIONS OF GENERIC ENTITIES
Compile the application, then right-click and view the RestClientTestPage.html (or
the ASPX—either will work) in the browser. You should be presented with a blank UI
with the fields you’ve defined.
 Click the Add New button on the bottom left. Immediately you should see a blank
entry appear in the ListBox. Complete the First Name and Last Name fields and tab
away from them. Does the ListBox update? 
3 I wouldn’t normally place potentially exception-throwing calls into a constructor. I’m doing it here because
the code listings were getting too long. Normally, it would be in a loaded event, navigation event, or user
action like a button click. If only we could fill our production project code with footnote disclaimers.

537
Creating a RESTful service using the ASP.NET Web API 
 No, it doesn’t. But why is that? Because the entity you’re using, the Customer,
doesn’t implement INotifyPropertyChanged. Is that fixable? Sure is. This is a case
where a little conditional compilation in the class can work wonders. Listing 21.7
shows the updated Customer class in the RestExample.Model.* projects.
namespace RestExample.Model
{
#if SILVERLIGHT
  using System.ComponentModel;                    
  public class Customer : INotifyPropertyChanged
#else
  public class Customer                         
#endif
  {
    private int _id;
    public int ID 
    {
      get { return _id; }
      set
      {
        _id = value;
#if SILVERLIGHT
        NotifyPropertyChanged("ID");
#endif
      }
    }
    private string _lastName;
    public string LastName 
    {
      get { return _lastName; }
      set
      {
        _lastName = value;
#if SILVERLIGHT
        NotifyPropertyChanged("LastName");        
#endif
      }
    }
    private string _firstName;
    public string FirstName 
    {
      get { return _firstName; }
      set
      {
        _firstName = value;
#if SILVERLIGHT
        NotifyPropertyChanged("FirstName");
#endif
      }
    }
Listing 21.7
The Customer class with conditional INotifyPropertyChanged
Silverlight class
Full .NET class
Change notification
for Silverlight

538
CHAPTER 21
RESTful services with the ASP.NET Web API
    private decimal _balance;
    public decimal Balance 
    {
      get { return _balance; }
      set
      {
        _balance = value;
#if SILVERLIGHT
        NotifyPropertyChanged("Balance");
#endif
      }
    }
#if SILVERLIGHT
    public event PropertyChangedEventHandler PropertyChanged;
    protected void NotifyPropertyChanged(string propertyName)
    {
      if (PropertyChanged != null)
        PropertyChanged(this, 
              new PropertyChangedEventArgs(propertyName));
    }
#endif
  }
}
Modify the Customer.cs file located in the RestExample.Model.Silverlight project
(and linked into the RestExample.Model.Net project) to include the new conditional
statements and INotifyPropertyChanged implementation. 
Unfortunately, when you want to implement INotifyPropertyChanged, you can no
longer use the auto properties approach—that is, the approach with the property
name followed by a simple { get; set; } block with no additional code.
 With the new code in place, run the application again, add a new customer, and
start editing it. You’ll see that changes made in the fields are now reflected in the
Conditional compilation
Some project types in .NET come with their own predefined conditional compilation
symbols. In Silverlight, the symbol is, not surprisingly, SILVERLIGHT. You can find the
symbols, and even add your own, using the Build tab of the project property pages.
When the compiler finds a conditional compilation symbol, it processes it and ignores
anything enclosed in blocks that evaluate to false. Although overuse of this can lead
to ugly code, it’s powerful for situations where partial classes and other approaches
aren’t possible or practical.
To visualize what will and won’t be included, open the file first in one project type.
Then close it and reopen it from the other project. The light gray code won’t be com-
piled.

539
Consuming REST services
ListBox. The code is a bit messier now, but by using conditional compilation, you’ve
managed to avoid polluting the compiled server-side code with client-side constructs.
 So far, you’ve learned how to set up an MVC project with an ASP.NET-based REST
service. You’ve also learned how to set up a client with a basic view model used to
expose the data and methods that will interact with that service. You even used a bit of
the code sharing introduced in chapter 20, as well as conditional compilation to make
the data types flow seamlessly across the client and server. Yet the client is still not
using the service. Next, you’ll learn how to consume the REST services in the Silver-
light client. 
21.2
Consuming REST services
In chapter 20, you saw how to use service references to create client proxies to SOAP
services. This is the norm in the world of SOAP services where assembling a message to
the service is a nontrivial activity. RESTful services are simpler, but consuming a REST-
ful service takes a little more work on the side of the Silverlight developer. Silverlight
nicely handles calling RESTful services through the HttpWebRequest object that
you’re already familiar with but doesn’t natively generate proxies.
 In addition to the potential for hypermedia, and the broader range of clients you
can support with RESTful services, another reason why this bit of extra effort is worth
it involves load management on the server. Taken to its logical hypermedia conclu-
sion, as partially described in the sidebar “What is hypermedia?,” RESTful services have
more freedom for locating different resources on different servers for better load bal-
ancing in a way that’s completely transparent to the consumer. SOAP services, without
a lot of extra effort on your part (or dedicated load balancing infrastructure) tend to
be much more strongly tied to specific URLs. Unless you break the SOAP services into
many fine-grained services, you’re stuck with a level of server affinity that takes a lot of
freedom away from the IT folks and server developers.
 For those reasons, the bit of extra effort required to generate a client today makes
sense in your application. In truth, there’s not much to it as you’ll see; it’s little differ-
ent from pulling up any other web resource, like a page, which virtually every client
technology can do. SOAP, on the other hand, requires a large effort if you don’t have a
SOAP client available to you—something many of us had to deal with in the early days
of .NET when the SOAP client stack wasn’t completely compatible with the Java-based
SOAP services out there.4 
NOTE A few services support proxy generation, making them as simple to use
as SOAP services. That’s because they’re offering more metadata than the
standard REST approach normally offers. Try it, but don’t count on having
this functionality available. It’s more common for the creator of the API to
offer some libraries that offer similar functionality to the .NET proxies.
4 I still sometimes wake up in a cold sweat, screaming about Java SOAP services and mainframe semi-SOAP ser-
vices from the .NET 1.0 days. It’s worse than those dreams about showing up to class in your underwear, hav-
ing forgotten to study for the final exam sitting on your desk in front of you.

540
CHAPTER 21
RESTful services with the ASP.NET Web API
There are a few reasons why Silverlight doesn’t normally generate proxies for REST
services. For one, REST itself is about returning documents in JSON, XML, or variant
formats like ATOM/RSS. The return type is selected by having appropriate HTTP
accept headers and possibly a parameter on the URL (this depends on the service).
The second reason is that it’s difficult to programmatically identify the return types of
a service method. REST is flexible and isn’t necessarily tied down to a “one method
equals one return type” approach. Third, take what I just said about methods and
throw the word “method” out the door—that’s SOAP talk right there. REST is about
resources, not methods. More on that as you go through the rest of this section, which
covers how to get data from and push data to a REST service.
21.2.1 REST service GET operations
In relation to Silverlight, although REST may dictate the method in which a resource
is accessed, it shouldn’t dictate the format of the data received. The most common
ways to return data from a RESTful web service are XML and JSON. I’ll discuss how
to parse or serialize both XML and JSON in the next chapter. In this section, you’ll
What is hypermedia?
The achievable utopia of REST is often considered to be hypermedia. In a nutshell,
hypermedia limits the contracts with the client by having only a few known endpoints.
You make calls to those endpoints and get back documents that contain hyperlinks
to other documents or even (for performance reasons) those documents inline.
This is consistent with how you navigate web pages. You land on a page and can nav-
igate to other pages by clicking hyperlinks. You don’t need to know the URLs for those
pages in advance.
Consider the concept of a customer and its invoices. You may get back, from an initial
call, a set of customers. That set of customers includes all the normal attributes like
Last Name, First Name, and so forth. Each customer also includes a hyperlink pointing
to its invoices.
Let’s say, based on web analytics on the server, it turns out that 90 percent of the
calls to get customers are immediately followed up by calls to get their invoices. In
that case, the designer of the API may flip a config option or write a little code to inline
the invoices in the customer list document. Now, instead of each customer having a
hyperlink to the list of invoices, it simply includes a list of invoices with hyperlinks to
the line items.
In a truly hypermedia-aware client, the change is transparent and easily handled. For
the administrator on the server, they’ve made an immediate performance optimization
that improves responsiveness for all the clients. It’s a huge win.
That’s one of the promises of hypermedia, and one that I’m particularly excited about.
It’s bringing the web as we know it to our APIs.

541
Consuming REST services
concentrate on how to call the REST service without worrying too much about serializ-
ing the returned data itself. You’ll just work with raw data for now.
 The basics of calling a REST-based web service from Silverlight involve creating an
HttpWebRequest object or a WebClient object, setting its destination URI, and calling
it asynchronously, as shown in listing 21.8.
using System;
using System.IO;
using System.Net;
using System.Diagnostics;
...
public void LoadCustomers()
{
  string url = "/api/customer";
  Uri uri = new Uri(url, UriKind.Relative);
  var client = new WebClient();
  client.DownloadStringCompleted += (s, e) =>
    {
      Debug.WriteLine(e.Result);
    };
  client.DownloadStringAsync(uri);
}
This code goes in the MainViewModel class you created earlier. In this example, you
used the WebClient to make the network call. As you learned in chapter 19, the Web-
Client is a basic way to get strings or streams of data from an internet resource.
 I ran this example with Fiddler running and inspected the request that went to the
service. This is what I saw:
GET http://localhost:9090/api/customer HTTP/1.1
Accept: */*
Referer: http://localhost:9090/ClientBin/RestClient.xap
Accept-Language: en-US
Accept-Encoding: gzip, deflate
User-Agent: Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; WOW64; 
Trident/6.0)
Host: localhost:9090
Connection: Keep-Alive
By default, the service sends the results back as JSON. When told anything is accept-
able (an accept header of */*), it’s entirely up to the REST service to decide what for-
mat the data will be. Some services support only XML, some only JSON. The ASP.NET
Web API defaults to JSON. It can also return XML.
Listing 21.8
Getting data from a REST service using the WebClient

542
CHAPTER 21
RESTful services with the ASP.NET Web API
 Listing 21.9 shows how to use an HTTP accept header5 to tell the REST service that
you support the XML format in the response.
public void LoadCustomers()
{
  string url = "/api/customer";
  Uri uri = new Uri(url, UriKind.Relative);
  var client = new WebClient();
  client.Headers[HttpRequestHeader.Accept] =  
                    "text/xml";              
  client.DownloadStringCompleted += (s, e) =>
    {
      Debug.WriteLine(e.Result);
    };
  client.DownloadStringAsync(uri);
}
The output of this example isn’t very important. What you want to look at is the actual
call and response in a tool like Fiddler. I ran this example and saw in Fiddler these
headers:
GET http://localhost:9090/api/customer HTTP/1.1
Accept-Encoding: gzip, deflate
Referer: http://localhost:9090/ClientBin/RestClient.xap
Accept-Language: en-US
Accept: text/xml
User-Agent: Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; WOW64; 
Trident/6.0)
Host: localhost:9090
Connection: Keep-Alive
Note that in this case, the accept header is set only to text/xml, as you specified in list-
ing 21.9. You could use application/json if you want to receive only JSON. Your
headers should look very similar, with a different User-Agent if you’re running a
browser other than IE10 on an OS other than Windows 8.
 It’s important to also note that not all REST or REST-like services use the HTTP
accept header to decide the return format. Some use parameters on the query string
such as http://somesite.org/foo?json or ?fmt=json; some use unique URLs like
http://somesite.org/foo/json. But the most RESTful “web correct” way to handle it
is via the accept headers.
 I like the WebClient class due to its simple event-based approach. Once you get
beyond simple GET requests, the WebClient approach quickly breaks down. If you
want to do something like a POST or DELETE, you’ll need to use the HttpWebRequest
5 For the full set of HTTP headers, see http://en.wikipedia.org/wiki/List_of_HTTP_header_fields. 
Listing 21.9
Using HTTP accept headers to return XML rather than JSON
Accept only XML

543
Consuming REST services
class covered in chapter 19. Listing 21.10 takes what you’ve done so far and moves it
over to the HttpWebRequest approach.
public void LoadCustomers()
{
  string url = "http://localhost:9090/api/customer";
  Uri uri = new Uri(url, UriKind.Absolute);
  var request = (HttpWebRequest)WebRequest.Create(uri);
  request.Method = "GET";
  request.Accept = "application/json";          
  request.BeginGetResponse((result) =>
    {
      var req = (HttpWebRequest)result.AsyncState;
      var response = req.EndGetResponse(result);
      var stream = response.GetResponseStream();
      if (stream != null)
      {
        using (var reader = new StreamReader(stream))
        {
          string responseText = reader.ReadToEnd();  
          Debug.WriteLine(responseText);
        }
      }
    }, request);
}
Note that you used the anonymous delegate lambda expression approach in the list-
ing too; it’s not limited to event handlers. You could also break the code out into two
separate methods if you prefer. I find that approach a bit more effort to follow.
 In listing 21.10, you didn’t use the Headers collection as you did with the Web-
Client example. The HttpWebRequest class exposes specific properties for many of
the common headers, including Accept. If the property exists, you must use that for
modifying the value.
 Another important modification you made was to change the URI to have the fully
qualified URI. Why did you do that? The WebRequest Create and CreateHttp meth-
ods don’t support using a relative URI.
NOTE
Many of the classes being used in this chapter implement IDisposable.
For those, you should enclose their creation and use inside a using block, as I
show in a few cases, or at least call Dispose when you’re done with them. I don’t
always do that here because the nested using statements would make the code
impossible to fit on the printed page and the listings are pretty long in any case.
This is a case of publishing best practices not quite meshing with coding best
practices. If it implements IDisposable, dispose it.
Listing 21.10
Calling a REST GET method using HttpWebRequest
Accept header
Response text

544
CHAPTER 21
RESTful services with the ASP.NET Web API
21.2.2 Updating resources by POSTing to the service
Most RESTful services use GET to retrieve data and POST to send it. Because the
default HTTP verb used when using HttpWebRequest is GET, you need to do a few
things differently when you want to perform a POST. Listing 21.11 shows the process
of sending data to a REST service.
public void UpdateSelectedCustomer()
{
  if (SelectedCustomer != null)
  {
    string url = "http://localhost:9090/api/customer";
    Uri uri = new Uri(url, UriKind.Absolute);
    var request = (HttpWebRequest)WebRequest.Create(uri);
    request.Method = "POST";
    request.ContentType = "text/xml";
    request.BeginGetRequestStream((result) =>       
    {
      var req = (HttpWebRequest)result.AsyncState;
      var stream = req.EndGetRequestStream(result);
      if (stream != null)
      {
        string customerTemplate = 
          "<?xml version=\"1.0\" encoding=\"utf-8\"?>" +
          "<Customer>" +
          "<ID>{0}</ID>" + 
          "<LastName>{1}</LastName>" +
          "<FirstName>{2}</FirstName>" +
          "<Balance>{3}</Balance>" +
          "</Customer>";
        string xml = string.Format(customerTemplate,
          SelectedCustomer.ID,
          SelectedCustomer.LastName,
          SelectedCustomer.FirstName,
          SelectedCustomer.Balance);
        Debug.WriteLine("POST: " + xml);
        using (var writer = new StreamWriter(stream))
        {
          writer.Write(xml);
          writer.Close();
        }
        req.BeginGetResponse((requestResult) =>         
        {
          var req2 = (HttpWebRequest)requestResult.AsyncState;
          var response = req2.EndGetResponse(requestResult);
          var responseStream = response.GetResponseStream();
Listing 21.11
POSTing data to a RESTful service
Request
Response

545
Consuming REST services
          var reader = new StreamReader(responseStream);
          string responseText = reader.ReadToEnd();
          Debug.WriteLine("Response: " + responseText);
        }, req);
      }
    }, request);
  }
}
Because REST services don’t have methods but instead deal with resources or entities,
any data to be sent to the service needs to be added to the message being sent. In list-
ing 21.11, rather than calling BeginGetResponse from the initial call, you call Begin-
GetRequestStream. This callback functions allows you to add information to the
stream after it’s created but before it’s sent to the service. After that’s been done, you
call the BeginGetResponse method and provide it with a callback as you did during
the GET operations.
 To test this example, run the application and click the button to add a new cus-
tomer. Then, fill out the customer information (except the ID), and click Update
Selected. You should then see the request and response XML in the output window in
Visual Studio (or in Fiddler if you’re monitoring it that way). Speaking of Fiddler,
here’s what it shows for the request:
POST http://localhost:9090/api/customer HTTP/1.1
Accept: */*
Referer: http://localhost:9090/ClientBin/RestClient.xap
Accept-Language: en-US
Content-Length: 149
Content-Type: text/xml
Accept-Encoding: gzip, deflate
User-Agent: Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; WOW64; 
Trident/6.0)
Host: localhost:9090
Connection: Keep-Alive
Pragma: no-cache
<?xml version="1.0" encoding="utf-8"?>
<Customer>
  <ID>0</ID>
  <LastName>Ketchum</LastName>
  <FirstName>Ash</FirstName>
  <Balance>1337.00</Balance>
</Customer>
The request is what the Silverlight client application sent to the REST service. In that,
you can see the headers, including your content type header showing text/xml. Note
also that the ID of the customer is set to 0, the default. Because no customer with ID 0
exists in your data, this will be treated as an add operation. I know that’s not exactly a

546
CHAPTER 21
RESTful services with the ASP.NET Web API
robust way to manage state (it’s not even as good as using -1!), but it keeps things sim-
ple for these examples. Besides, it’s hardly unusual: you’ll find that many public REST
APIs on the internet were designed by people who obviously slept in late when they
should’ve been attending their data structures and algorithms classes.   
 Here’s what Fiddler shows for the response from the service:
HTTP/1.1 200 OK
Server: ASP.NET Development Server/10.0.0.0
Date: Sun, 25 Mar 2012 18:35:55 GMT
X-AspNet-Version: 4.0.30319
Cache-Control: no-cache
Pragma: no-cache
Expires: -1
Content-Type: text/xml; charset=utf-8
Connection: Close
Content-Length: 248
<?xml version="1.0" encoding="utf-8"?>
<Customer xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
          xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <ID>6</ID>
  <LastName>Ketchum</LastName>
  <FirstName>Ash</FirstName>
  <Balance>1337.00</Balance>
</Customer> 
Many REST APIs will use GET and POST exclusively because they’re the most univer-
sally supported. But something like an add operation is technically better suited for
PUT, and a remove should be handled by the DELETE verb.
 The browser stack only allows POST and GET, not DELETE or PUT. Those limita-
tions, and the need for out-of-browser networking support, prompted the Silverlight
team to create a second separate networking stack: the client HTTP stack. I covered
the basics of this stack in chapter 19, but now you’ll actually use it specifically in the
context of the DELETE operation.  
21.2.3 Removing resources using DELETE
Delete is the “D” in CRUD  and is as essential a part of a good API as any of the other
verbs. It’s often neglected, though. Many APIs offer delete functionality only as a
strangely implemented afterthought. When the HTTP spec was being created, DELETE
was included as a first-class citizen. It didn’t get much use, because browsers are for
browsing, not modifying, resources.
 In our case, you’ll implement a delete method to remove customers from your pre-
tend database. The DeleteSelectedCustomer method takes the ID of the customer
currently selected and sends it to the service using the DELETE verb. The service
returns back the full Customer object that was deleted. A call to delete customer num-
ber 5 would look like this:
http://localhost:9090/api/customers/5

547
Consuming REST services
Note that, with the exception of the ID at the end, this is the same URL you used for
retrieving and updating customers. The main distinction here isn’t in the URL but in
the verb used: DELETE. Because DELETE isn’t supported by the browser networking
stack (browsers don’t need to delete resources; they just view them), you’ll switch over
to the client networking stack in this example. Listing 21.12 shows how to delete a cus-
tomer using the DELETE verb and the client networking stack.
public void DeleteSelectedCustomer()
{
  string uriTemplate = "http://localhost:9090/api/customer/{0}";
  if (SelectedCustomer != null)
  {
    string url = string.Format(uriTemplate, SelectedCustomer.ID);
    Uri uri = new Uri(url, UriKind.Absolute);
    var request = 
      (HttpWebRequest)WebRequestCreator.ClientHttp.Create(uri); 
    request.Method = "DELETE";                        
    request.BeginGetResponse((result) =>
      {
        var req = (HttpWebRequest)result.AsyncState;
        var response = req.EndGetResponse(result);
        var responseStream = response.GetResponseStream();
        if (responseStream != null)
        {
          using (var reader = new StreamReader(responseStream))
          {
            string responseText = reader.ReadToEnd();
            Debug.WriteLine("Response: " + responseText);
          }
        }
      }, request);
  }
}
The approach in the method is similar to the GET requests you started with, with two
main differences. The first difference is that you use the client stack to execute the
call, as evidenced by the WebRequestCreator call (you’ll need to right-click and
resolve the class and namespace or manually add the appropriate using statement).
The second is that you use the DELETE verb rather than the GET verb for the method.
Otherwise, this uses BeginGetResponse and EndGetResponse just like you did before.
 You can test this method using an approach similar to what you did previously. Add
a new item, update it, and then change the ID in the text box to be the ID of that item.
Then finally click the Delete button. That’s pretty convoluted, though, so in the next
Listing 21.12
Using HTTP DELETE on a resource
Client stack
Delete verb

548
CHAPTER 21
RESTful services with the ASP.NET Web API
chapter, you’ll implement the code you need to have to serialize your objects to and
from XML and JSON.
21.3
Summary
Working with RESTful services can be exciting and rewarding. REST is turning out to
be the de facto API style on the internet, used by the major social networking sites and
many others. Its simple format, without the overhead of SOAP, makes it appealing
both for clients with built-in support for serialization like Silverlight, as well as those
that are built from scratch. Quite frankly, with its reliance on the standard HTTP verbs
like GET, POST, PUT, and DELETE, it just works the way the web is supposed to. It’s so
easy to understand and so basic in implementation, it’s even popular on tiny .NET
Micro Framework boards like the Netduino, something I use often when working with
robotics, sensors, and side projects.
 If you’re going to build your own REST API, ASP.NET MVC with the ASP.NET Web
API is a great way to go. The two work well together and have excellent support for
web standards on the modern web. You can incorporate Silverlight into an ASP.NET
MVC site, as you did here.
 What do you know? I even made it through a chapter full of DELETE verbs without
a single Cybermen comment! Well, unless you count that one.
 In the next chapter, you’ll continue your exploration of web APIs with a slight twist:
you’ll learn what it takes to parse the data that comes from those APIs.
REST helper libraries
A number of libraries are available that help with REST and related operations in
Silverlight:
■
Hammock at https://github.com/danielcrenna/hammock
■
Rest# at http://restsharp.org/
■
Json.net at http://json.codeplex.com/ 
I encourage you to check them out. One of the benefits of working in .NET is the huge
community that uses it and helps by building open source libraries you can use in
your own projects. 
I know internal development shops still (yes, even now) face a lot of management
and even developer/architect opposition to open source libraries. Don’t be put off on
using a library just because it doesn’t come from a big name; use what makes your
application better and your development and testing time shorter. If it comes with
source and a license compatible with your project, know you’ll be able to do whatever
you need to do with it in the future. Do be sure to check the license, though.

549
Working with XML,
JSON, RSS, and Atom
With the prevalence of autogenerated proxies created for Soap services, you’ll be
forgiven for considering data serialization and deserialization a magic black box
that’s handled for you automatically. You make a call to a service, and you get back
a .NET object with the properties all filled out.
 But we all know there are several steps that happen to get the data into that
usable format. If you’re working with strongly typed objects from web services, with
automatic serialization, you may not need to concern yourself with those steps. If
you need to work with raw data, or data that’s inconvenient to receive as a known
set of objects, you must know how to work with the underlying representation.
 When I was in college, working part-time as the one-man IT shop1 at a medical
billing company in Massachusetts, I had to deal with a ton of different types of data
This chapter covers
■
Parsing XML
■
Parsing JSON
■
Working with RSS and Atom feeds
1 I held on to that Novell 4 CNA certification forever thinking it would be useful. Luckily, the dBASE,
PowerBuilder, and Visual Basic 3 and 4 skills I gained at that job were slightly more portable.

550
CHAPTER 22
Working with XML, JSON, RSS, and Atom
from our clients. Not only were they on different media, like 9-track tape, a stack of
floppies (the second-to-last disk was always bad, guaranteed), or an upload to our sin-
gle-line DOS-based BBS, but the actual formats were rarely the same between clients
and often differed within even the same client. These days, there are still several types
of data out there, but XML and JSON have generally won the format war. It’s unusual
to talk to someone who has to parse nonlegacy data in tab-delimited, pipe-delimited,
comma-delimited, or even fixed-length record format. Yes, it happens, but it’s the
exception now, not the rule.
 In this chapter, you’ll look at those two main formats and learn how to parse both
XML and JSON in your applications. You’ll do this in the context of networking, but
understand that the source of the data is unimportant—the XML could have come
from the local file system and the JSON from a field in a database. The mechanics of
dealing with the in-memory data are the most important part of the process.
 After a tour of XML and JSON, you’ll take a deeper dive into the use of XML in syn-
dication feed formats like RSS and Atom. Silverlight has built-in support, above and
beyond basic XML, for processing those types of feeds. Though most common in
blogs, they have diverse uses across both the public internet and private enterprise.
 You’ll start with the format that’s commonly the most used with .NET developers:
plain old XML.
22.1
Parsing plain old XML
Plain old XML (POX)2 has been one of the primary data formats on the internet for
over a decade. The fact that it’s human-readable, customizable, and platform-inde-
pendent virtually guaranteed its acceptance. Due to its long life and universal accep-
tance, the Microsoft .NET teams and the Silverlight team built in several ways to use
XML in your application.
 In this section, I’ll describe the major ways to use XML content. The two primary
built-in methods to use XML content are LINQ to XML  and the XmlSerializer. In the
following examples, I’ll demonstrate both ways to read the same data. In all cases, the
code you’ll be modifying will be in the MainViewModel class from chapter 21.
 Because the calls from HttpWebRequest return on a different thread, you’ll also learn
how to use the SynchronizationContext class to communicate back to the UI thread.
 In preparation for this, you’ll go back to the project you set up in the previous chap-
ter. Please ensure that the Silverlight client you’ve been using so far is using the default
HTTP accept headers and isn’t specifically requesting JSON data through the headers.
It should show an accept of either text/xml or */* (the default). In chapter 21, you left
it as JSON; you can simply remove that accept header setting to get back to the default.
22.1.1 LINQ to XML
LINQ is a query language with myriad uses in your code. It and the lambda expression
syntax it’s built on have had an enormous impact on code since they were first
2 Yeah, so that’s a pretty unfortunate acronym. I think I’ll just use XML throughout the chapter.

551
Parsing plain old XML
introduced in C# 3.0. LINQ to XML is a flavor of LINQ used to navigate and parse XML
content. It facilitates both property and query syntax to access the nodes and attri-
butes in a chunk of XML. 
 In preparation for using this, in your Silverlight project add a reference to
System.Xml.Linq located in the Silverlight SDK folder. Figure 22.1 shows the correct
reference. (The important thing is the location, not the runtime version. Make sure
it’s in the Silverlight 5 SDK folder.)
 Next, make sure you have the following using statements in the top of your Main-
ViewModel code:
using System.Linq;
using System.Xml;
using System.Xml.Linq;
using System.Collections.Generic;
Remember, when in doubt, you can right-click an unrecognized class and choose
Resolve to have the using statements added for you automatically. This works with just
about everything except extensions and System.Linq.
RETRIEVING DATA
With reference and using statements in place, let’s start by using LINQ to XML to read
the collection of Customer objects returned by the GET call. Listing 22.1 shows the
LoadCustomers method with the new code.
public void LoadCustomers()
{
  string url = "http://localhost:9090/api/customers";
  Uri uri = new Uri(url, UriKind.Absolute);
Listing 22.1
Parsing the return data using LINQ to XML
Figure 22.1
The System.Xml.Linq reference required for LINQ to XML

552
CHAPTER 22
Working with XML, JSON, RSS, and Atom
  var request = (HttpWebRequest)WebRequest.Create(uri);
  request.Method = "GET";
  request.Accept = "text/xml";                      
  request.BeginGetResponse((result) =>
    {
      var response = request.EndGetResponse(result);
      var stream = response.GetResponseStream();
      if (stream != null)
      {
        var reader = XmlReader.Create(stream);
        XElement set = XElement.Load(reader);       
        IEnumerable<Customer> customers =          
          from XElement item in set.Descendants("Customer")
          select new Customer()
          {
            ID = int.Parse(item.Element("ID").Value),
            FirstName = item.Element("FirstName").Value,
            LastName = item.Element("LastName").Value,
            Balance = decimal.Parse(item.Element("Balance").Value)
          };
        Customers.Clear();
        foreach (Customer customer in customers)
        {
          Customers.Add(customer);                
        }                      
      }                    
    }, null);
}
The listing shows how to extract the individual elements—ID, FirstName, LastName,
and Balance—from the XML representation of the Customer. LINQ to XML is a power-
ful and flexible way to work with XML documents whether they represent single entities,
or as in this case, arrays of entities that you want to load into strongly typed classes.
DEALING WITH CROSS-THREAD ISSUES
If you run this example, you’ll get a cross-thread access exception when accessing the
Customers collection. That’s because the HttpWebRequest returns on a different thread
from the calling thread. That’s something that the event-based approaches like WebCli-
ent shield you from, because they always post back to the calling thread.
 So, you need to do something special to update the UI thread. In this case, you’ll
use the SynchronizationContext object, get the context for the UI thread in the con-
structor, and use it in this method. Listing 22.2 shows the required using statement
and the new constructor for the MainViewModel class.
using System.Threading;
...
private SynchronizationContext _context;
public MainViewModel()
Listing 22.2
Getting the UI thread synchronization context
Expect XML
Get root
Parse
Add to collection

553
Parsing plain old XML
{
    _context = SynchronizationContext.Current;
}      
It’s important to note that this code gets the UI thread only if the MainViewModel is
created on that thread. SynchronizationContext doesn’t have some magical pointer
to the UI thread; it simply stores the context to the thread you ask for when you get
the Current context. If you always create your view model on the UI thread, like most
do, you won’t have any issues.
 Simply getting the context isn’t enough to make a difference. The next thing you
need to do is modify the code so the call to update the items on the UI thread, specifi-
cally the collection of Customer objects, is dispatched to the UI thread. Listing 22.3
shows the modified block inside the LoadCustomers method.
if (stream != null)
{
  var reader = XmlReader.Create(stream);
  XElement set = XElement.Load(reader);
  _context.Post((state) =>                   
  {
    IEnumerable<Customer> customers =
      from XElement item in set.Descendants("Customer")
      select new Customer()
      {
        ID = int.Parse(item.Element("ID").Value),
        FirstName = item.Element("FirstName").Value,
        LastName = item.Element("LastName").Value,
        Balance = decimal.Parse(item.Element("Balance").Value)
      };
    Customers.Clear();
    foreach (Customer customer in customers)
    {
      Customers.Add(customer);
    }
  }, null);
}                    
The Customer objects are created on the UI thread, but given that they don’t imple-
ment INotifyPropertyChanged (and have nothing bound to them anyway), creating
them and setting their properties could’ve happened on the background thread. For
regular objects, only when the PropertyChanged event might be raised do you need to
force things to execute on the UI thread. Collections have similar considerations. The
collection Clear and Add calls must happen on the UI thread because they raise the
CollectionChanged event. 
 When dispatching, you could’ve used _context.Send rather than _context.Post.
The difference is that Send is synchronous while Post is asynchronous. The difference
Listing 22.3
Using the synchronization context to update the UI thread
Dispatch to
UI thread

554
CHAPTER 22
Working with XML, JSON, RSS, and Atom
in this case isn’t important; either would do. Instead of using Synchronization-
Context.Post, you could’ve used the BeginInvoke method of the Deployment
.Current.Dispatcher object. The two approaches are subtly different in use but end
with the same primary result: a call sent to execute on the UI thread.
 When you run the example with the new context code in place, you should see a
ListBox that finally has your Customer data loaded. Figure 22.2 shows how it looks on
my machine.
LINQ to XML is probably my favorite way to handle manual parsing of data. If you
prefer, you could also use an XmlReader directly and iterate through the elements.
This is no longer a popular approach, and it can be troublesome to learn when you’re
working with anything but a simple object. For that reason, let’s skip right over it and
look at XmlSerializer, the automated approach.
22.1.2 XmlSerializer
I like LINQ to XML, but it quickly becomes a chore when the classes had lots of proper-
ties, or even additional nested classes. Seriously, who wants to write all that LHS = RHS3
type code anyway? This just begs for something more automatic.
GETTING DATA
The XmlSerializer provides a way to convert an XmlReader into strongly typed
objects. To use the serializer, add a reference to System.Xml.Serialization (also in
3 Left Hand Side = Right Hand Side. I just wanted to show that I, in fact, did attend my computer science classes.
Well, most of them.
Figure 22.2
The UI with the data parsed and loaded into Customer objects 
using LINQ to XML

555
Parsing plain old XML
the Silverlight SDK folder) to your Silverlight project; then add the using statement
and code in listing 22.4.
using System.Xml.Serialization;
... 
if (stream != null)
{
  var reader = XmlReader.Create(stream);
  _context.Post((state) =>
  {
    var serializer = new XmlSerializer(typeof(Customer[]));
    Customer[] customers = 
           (Customer[])serializer.Deserialize(reader);
    Customers.Clear();
    foreach (Customer customer in customers)
    {
      Customers.Add(customer);
    }
  }, null);
}    
You can see how easy it is to read the XML into strongly typed objects using the XmlSe-
rializer class. It’s easy because the generated XML was created by the server-side
equivalent. In some cases, you may need to provide some help to the serializer using
property attributes, event handlers, or more. 
UPDATING DATA
So far, you’ve read XML into objects. The XmlSerializer can also serialize objects into
XML. In the case of our update method, you need to take an existing Customer object
and send its data across the wire in XML format. To do so, you’ll need to use the Xml-
Writer class, declared in System.Xml. Add a reference to the System.Xml.dll (in the
SDK folder) and then use the code in listing 22.5, which shows how to do this using
the XmlSerializer. (You’ll need to add a using statement for System.Text to get the
Encoding class.)
if (stream != null)
{
  var serializer = new XmlSerializer(typeof(Customer));
  XmlSerializerNamespaces ns = new XmlSerializerNamespaces();
  ns.Add("", "");
  XmlWriterSettings settings = new XmlWriterSettings();
  settings.Encoding = Encoding.UTF8;
Listing 22.4
The Customer retrieve code, using XmlSerializer
Listing 22.5
The UpdateSelectedCustomer method using the XmlSerializer

556
CHAPTER 22
Working with XML, JSON, RSS, and Atom
  settings.Indent = true;
  settings.CloseOutput = true;                           
  using (XmlWriter writer = XmlWriter.Create(stream, settings))
  {
    serializer.Serialize(writer, SelectedCustomer, ns);     
    writer.Close();
  }
  req.BeginGetResponse((requestResult) =>
  {
    var req2 = (HttpWebRequest)requestResult.AsyncState;
    var response = req2.EndGetResponse(requestResult);
    var responseStream = response.GetResponseStream();
    var reader = new StreamReader(responseStream);
    var deserializer = new XmlSerializer(typeof(Customer));
    _context.Post((state) =>
      {
        var customer = 
          (Customer)deserializer.Deserialize(reader);      
        SelectedCustomer.ID = customer.ID;
      }, null);
  }, req);
}
You may notice that the UpdateSelectedCustomer method in the listing has to do
both serialization and deserialization. That’s because it has to both send a customer to
the service as well as get back that customer information. In this example, the serial-
ization happens in the first block to send the Customer to the service. In the second
major block, you deserialize the XML into a temporary Customer object. In this case,
you only pull the returned ID, but you may wish to pull other properties if they could
potentially be updated server-side.
 I had some real problems with this little bit of code on a hot August night. If you
were on Twitter one evening (okay, 2 a.m.) in early August 2011, you may have seen
me ranting about XmlSerializer. That was this little bit of code. As it turns out, the
previous example with the hard-coded XML was closing the output stream. The Xml-
Serializer, though, leaves it open. If you attempt to call EndGetResponse with the
stream still open, you immediately get the not-so-helpful NotSupportedException. It
doesn’t tell you what’s not supported, just that something isn’t.
 A solution to the problem was the settings.CloseOutput = true line. In any
case, the XmlWriterSettings class is useful to see, because it lets you set a number of
options for how you generate the XML. Examples in the previous code include setting
the encoding to UTF-8, automatically indenting the markup, and, of course, closing
the stream when finished.
Required
Serialize
Deserialize

557
Parsing plain old XML
 Also of interest in the previous code, but not required, is the XmlSerializer-
Namespaces class. In this case, you use it to remove the default xsi and xsd
namespaces that clutter the markup. You can use it to insert any other required
namespaces in your XML.
DELETING DATA
For completeness, let’s round out the code to use the XmlSerializer for the delete
method. 
public void DeleteSelectedCustomer()
{
  string uriTemplate = "http://localhost:9090/api/customers/{0}";
  if (SelectedCustomer != null)
  {
    var deletedCustomer = SelectedCustomer;     
    string url = string.Format(uriTemplate, deletedCustomer.ID);
    Uri uri = new Uri(url, UriKind.Absolute);
    var request = 
        (HttpWebRequest)WebRequestCreator.ClientHttp.Create(uri);
    request.Method = "DELETE";
    request.BeginGetResponse((result) =>
      {
        var req2 = (HttpWebRequest)result.AsyncState;
        var response = req2.EndGetResponse(result);
        var responseStream = response.GetResponseStream();
        var reader = new StreamReader(responseStream);
        var deserializer = new XmlSerializer(typeof(Customer));
        _context.Post((state) =>
          {
            var customer = 
                 (Customer)deserializer.Deserialize(reader);
            if (customer.ID == deletedCustomer.ID)
            {
              Customers.Remove(deletedCustomer);     
              if (Customers.Count > 0)
                SelectedCustomer = Customers[0];
              else
                SelectedCustomer = null;
            }
          }, null);
      }, request);
    }
  }
Listing 22.6
The DeleteSelectedCustomer method using the XmlSerializer
Store selected 
customer
Remove from
collection

558
CHAPTER 22
Working with XML, JSON, RSS, and Atom
The DeleteSelectedCustomer method works similarly to the others you’ve seen so far,
but there are a few things you should note. The first is that you keep a pointer to the
Customer that’s selected when this method is called. Because these calls are async, and
you don’t really own the UI, you can’t guarantee that the SelectedCustomer won’t
change by the time the calls return. You want to make sure you remove the correct
one from the collection.
 The second thing is that you take the response from the server, deserialize it into a
Customer object, and see whether that customer ID matches the one you expect to
delete. Because you own both the client and the server, and know the code on both,
that situation isn’t going to happen. In a real application, you’d want to check your
assumptions.
 I like both LINQ to XML and the XmlSerializer class. When you have to deal with
semicompatible XML, or XML that simply can’t be properly parsed by the serializer,
LINQ to XML provides you with all the manual flexibility you need to handle creating
the objects. 
 When I have a choice, I use LINQ to XML for simple objects and the XmlSerializer
for serious work. Between them, you should be able to parse just about any well-formed
XML document.
 I could easily write a whole chapter on the XmlSerializer, but no one would want
to read it. So, let’s move on to working with JSON, the other popular data format. 
22.2
Working with JSON
If you’ve worked with Ajax or jQuery, it’s likely that you’re already familiar with JSON.
JSON provides an easy way to create data objects using JavaScript. Because JSON is
already prevalent in client-side programming and is used as the return type from
many public services, Microsoft has given you a way to convert managed objects into
and out of JSON objects.
 The next example shows what a JSON object looks like. You can accomplish this
conversion in a couple of ways, such as using a DataContractJsonSerializer or even
using LINQ syntax against a JsonObject. You’ve already seen how to change the HTTP
accept headers and the content type to support JSON and XML. You’ve also seen what
the XML returned information and sent payload look like. Here’s a single Customer
object, in JSON format:
{"Balance":250.07,"FirstName":"Pete","ID":1,"LastName":"Brown"}
This example shows a simple but typical JSON object. As you can see, the returned
JSON represents the same object as the XML you’ve been looking at so far but in a
more compact form. Similarly, if you have an array of JSON objects, they’re repre-
sented as shown here, but the entire array is enclosed in brackets, like this:
[{"Balance":250.07,"FirstName":"Pete","ID":1,"LastName":"Brown"},
 {"Balance":1250.25,"FirstName":"Jon","ID":2,"LastName":"Galloway"},
 {"Balance":500.00,"FirstName":"Joe","ID":3,"LastName":"Stagner"},
 {"Balance":1337.00,"FirstName":"Marc","ID":4,"LastName":"Schweigert"},
 {"Balance":1890.15,"FirstName":"Jesse","ID":5,"LastName":"Liberty"}]

559
Working with JSON
(I inserted the carriage returns. In typical use, it’s one long string.)
 Luckily, the methods for converting the JSON object into a useful format are simi-
lar to the XML approaches as well. Let’s start by taking a look at using the JsonObject
syntax.
22.2.1 JsonObject and JsonArray
As with XML, there’s more than one way to use JSON-formatted data returned from a
service. There’s the LoadCustomers method, but rather than expecting an XML docu-
ment, it requests and accepts a JSON formatted data stream and parses it using the
JsonArray and JsonObject types. To use the Json* types, you need to set a reference
to the System.Json DLL, included in the SDK folders. Once you have that, add a using
statement and you’re off to go. 
RETRIEVING DATA WITH JSON
When working with JSON on the client, the easiest thing to do is to receive data in JSON
format and pull the fields into an object. This is called deserialization. Listing 22.7
shows how to deserialize that stream into a set of Customer objects in your view model.
using System.Json;
...
public void LoadCustomers()
{
  string url = "http://localhost:9090/api/customers";
  Uri uri = new Uri(url, UriKind.Absolute);
  var request = (HttpWebRequest)WebRequest.Create(uri);
  request.Method = "GET";
  request.Accept = "application/json";
  request.BeginGetResponse((result) =>
  {
    var req = (HttpWebRequest)result.AsyncState;
    var response = req.EndGetResponse(result);
    var stream = response.GetResponseStream();
    if (stream != null)
    {
      var values = 
          (JsonArray)JsonArray.Load(stream);   
      _context.Post((state) =>
      {
        var customers = from customer in values   
             select new Customer()
               {
                 ID = (int)(customer["ID"]),
                 FirstName = customer["FirstName"],
                 LastName = customer["LastName"],
Listing 22.7
Deserializing JSON into a set of Customers
Load JSON array
Contain array 
of JsonObjects

560
CHAPTER 22
Working with XML, JSON, RSS, and Atom
                 Balance = (decimal)(customer["Balance"])
               };
         Customers.Clear();
         foreach (Customer customer in customers)
         {
           Customers.Add(customer);                 
         }
       }, null);
     }                    
   }, request);
}
The JsonArray type is visible used as the return type from the Load method. What’s
not discernible just from looking at the code is the use of the JsonObject type. In the
LINQ query over the JsonArray, each Customer in values is, in fact, a JsonObject.
The JsonObject then exposes an indexed set of properties, accessed by name.
UPDATING WITH JSON
As was the case when you dealt with XML, there are some differences when sending
data compared to receiving it. Listing 22.8 shows the UpdateSelectedCustomer
method, which must do both.
public void UpdateSelectedCustomer()
{
  if (SelectedCustomer != null)
  {
    string url = "http://localhost:9090/api/customers";
    Uri uri = new Uri(url, UriKind.Absolute);
    var request = (HttpWebRequest)WebRequest.Create(uri);
    request.Method = "POST";
    request.ContentType = "application/json";
    request.Accept = "application/json";         
    request.BeginGetRequestStream((result) =>
    {
      var req = (HttpWebRequest)result.AsyncState;
      var stream = request.EndGetRequestStream(result);
      if (stream != null)
      {
        var c = SelectedCustomer;
        JsonObject o = new JsonObject(             
           new KeyValuePair<string, JsonValue>
                ("ID", new JsonPrimitive(c.ID)),
           new KeyValuePair<string, JsonValue>
                ("FirstName", new JsonPrimitive(c.FirstName)),
           new KeyValuePair<string, JsonValue>
Listing 22.8
UpdateSelectedCustomer using JSON
Add to collection
Send and 
accept JSON
Build JSON

561
Working with JSON
                ("LastName", new JsonPrimitive(c.LastName)),
           new KeyValuePair<string, JsonValue>
                ("Balance", new JsonPrimitive(c.Balance)));
        o.Save(stream);                               
        stream.Close();
        req.BeginGetResponse((requestResult) =>
        {
          var req2 = (HttpWebRequest)requestResult.AsyncState;
          var response = req2.EndGetResponse(requestResult);
          var responseStream = response.GetResponseStream();
          var jsonresponse = 
         (JsonObject)JsonObject.Load(responseStream);
          _context.Post((state) =>
          {
            SelectedCustomer.ID = (int)(jsonresponse["ID"]);
          }, null);
        }, req);
      }
    }, request);
  }
}
Finally, you have the Delete method. This method is pretty old hat by now, and it
requires the same types of changes you made in the previous two listings. The first is
setting the accept header to indicate JSON. The second is to use the JsonObject to
load the return data and pull out the fields. Listing 22.9 has it all.
public void DeleteSelectedCustomer()
{
  string uriTemplate = "http://localhost:9090/api/customers/{0}";
  if (SelectedCustomer != null)
  {
    var deletedCustomer = SelectedCustomer;
    string url = string.Format(uriTemplate, deletedCustomer.ID);
    Uri uri = new Uri(url, UriKind.Absolute);
    var request = 
      (HttpWebRequest)WebRequestCreator.ClientHttp.Create(uri);
    request.Method = "DELETE";
    request.Accept = "application/json";             
    request.BeginGetResponse((result) =>
Listing 22.9
DeleteSelectedCustomer using JSON
Write to stream
Accept JSON

562
CHAPTER 22
Working with XML, JSON, RSS, and Atom
    {
      var req2 = (HttpWebRequest)result.AsyncState;
      var response = req2.EndGetResponse(result);
      var responseStream = response.GetResponseStream();
      var jsonresponse = 
        (JsonObject)JsonObject.Load(responseStream);     
      _context.Post((state) =>
      {
        var ID = (int)(jsonresponse["ID"]);         
        if (ID == deletedCustomer.ID)
        {
          Customers.Remove(deletedCustomer);
          if (Customers.Count > 0)
            SelectedCustomer = Customers[0];
          else
            SelectedCustomer = null;
        }
      }, null);
    }, request);
  }
}
The JsonObject and JsonArray approach is similar to using LINQ to XML in that you
have to manually assign all fields, and you can do so inside a LINQ statement. Simi-
larly, because the serialization is manual, it’s extremely flexible as long as you don’t
mind writing the code. Another approach, one that’s similar in concept to the Xml-
Serializer, is the DataContractJsonSerializer.
22.2.2 DataContractJsonSerializer
An easier way to access returned JSON is to use the DataContractJsonSerializer to
deserialize the stream into objects, just like you did with the XmlSerializer. The JSON
serializer is located in the System.Runtime.Serialization.Json namespace in the
System.ServiceModel.Web assembly. This assembly can be found in the Reference
Assemblies folder, under Silverlight, and is installed automatically by the tools
installer. You can find it easily using the Add Reference dialog. Before we continue, go
ahead and add that reference to your Silverlight project.
 The two methods of the DataContractJsonSerializer are ReadObject and
WriteObject, which deserialize and serialize JSON objects, respectively. 
RETRIEVING DATA
As in the previous examples, your first task is to modify the retrieve/GET Load-
Customers code to use the DataContractJsonSerializer. Listing 22.10 has the code
for that view model method.
Load JSON
Pull field

563
Working with JSON
using System.Runtime.Serialization.Json;
...
public void LoadCustomers()
{
  string url = "http://localhost:9090/api/customers";
  Uri uri = new Uri(url, UriKind.Absolute);
  var request = (HttpWebRequest)WebRequest.Create(uri);
  request.Method = "GET";
  request.Accept = "application/json";
            
  request.BeginGetResponse((result) =>
    {
      var req = (HttpWebRequest)result.AsyncState;
      var response = req.EndGetResponse(result);
      var stream = response.GetResponseStream();
      if (stream != null)
      {
        var serializer =                              
          new DataContractJsonSerializer(typeof(Customer[]));
        _context.Post((state) =>
        {
          var results =                              
             (Customer[])serializer.ReadObject(stream);
          Customers.Clear();
          foreach (Customer customer in results)
          {
            Customers.Add(customer);
          }
        }, null);
      }                    
    }, request);
}
Here you make the same calls as before, telling the server you want JSON as the return
format. When the result comes back, you deserialize it using the DataContractJson-
Serializer. Note, as before, the type you pass in isn’t Customer—it’s Customer[].
That’s an important distinction because this method returns an array of Customer
objects.
UPDATING DATA
Next up is the update method. You’ll recall that this is the most complex of the three
methods because it has to do both a serialization and a deserialization. Listing 22.11
has the code for UpdateSelectedCustomer.
Listing 22.10
LoadCustomers using the DataContractJsonSerializer
JSON serializer
Deserialize

564
CHAPTER 22
Working with XML, JSON, RSS, and Atom
public void UpdateSelectedCustomer()
{
  if (SelectedCustomer != null)
  {
    string url = "http://localhost:9090/api/customers";
    Uri uri = new Uri(url, UriKind.Absolute);
    var request = (HttpWebRequest)WebRequest.Create(uri);
    request.Method = "POST";
    request.ContentType = "application/json";
    request.Accept = "application/json";
    request.BeginGetRequestStream((result) =>
    {
      var req = (HttpWebRequest)result.AsyncState;
      var stream = request.EndGetRequestStream(result);
      if (stream != null)
      {
        var serializer =
          new DataContractJsonSerializer(typeof(Customer));
        serializer.WriteObject(stream, SelectedCustomer);  
        stream.Close();
        req.BeginGetResponse((requestResult) =>
        {
          var req2 = (HttpWebRequest)requestResult.AsyncState;
          var response = req2.EndGetResponse(requestResult);
          var responseStream = response.GetResponseStream();
          _context.Post((state) =>
          {
            var customer =                                   
              (Customer)serializer.ReadObject(responseStream);
            SelectedCustomer.ID = (int)customer.ID;
          }, null);
        }, req);
      }
    }, request);
  }
}
When comparing listing 22.11 to the code in listing 22.10, you can see this requires
quite a bit less code in the deserialization. Just as you saw with the XmlSerializer, the
DataContractJsonSerializer, despite its long name, results in tighter code, espe-
cially when dealing with complex objects with many properties.
Listing 22.11
UpdateSelectedCustomer using the JSON serializer
Serialize
Deserialize

565
Working with JSON
DELETING DATA
Our final stop in the tour of serialization and deserialization approaches is to see the
DeleteSelectedCustomer method using the JSON serializer. 
public void DeleteSelectedCustomer()
{
  string uriTemplate = "http://localhost:9090/api/customers/{0}";
  if (SelectedCustomer != null)
  {
    var deletedCustomer = SelectedCustomer;
    string url = string.Format(uriTemplate, deletedCustomer.ID);
    Uri uri = new Uri(url, UriKind.Absolute);
    var request = 
     (HttpWebRequest)WebRequestCreator.ClientHttp.Create(uri);
    request.Method = "DELETE";
    request.Accept = "application/json";
    request.BeginGetResponse((result) =>
      {
        var req2 = (HttpWebRequest)result.AsyncState;
        var response = req2.EndGetResponse(result);
        var responseStream = response.GetResponseStream();
        var serializer =
          new DataContractJsonSerializer(typeof(Customer));
        _context.Post((state) =>
        {
          var customer =                                     
            (Customer)serializer.ReadObject(responseStream);
          if (customer.ID == deletedCustomer.ID)
          {
            Customers.Remove(deletedCustomer);
            if (Customers.Count > 0)
              SelectedCustomer = Customers[0];
            else
              SelectedCustomer = null;
           }
         }, null);
       }, request);
    }
}
Listing 22.12 shows how to use the DataContractJsonSerializer in the delete
method. When the object is returned from the REST service, you deserialize it to get
the ID and compare it against the SelectedCustomer ID as before.
Listing 22.12
DeleteSelectedCustomer using the JSON serializer
Deserialize

566
CHAPTER 22
Working with XML, JSON, RSS, and Atom
 The DataContractJsonSerializer is extremely easy to use. Unlike XML, you
don’t have namespace issues and other in-your-face standards overhead to worry
about. Also unlike XML, you don’t have as rich support for different data types. But if
your types are fairly simple, or you’re trying to keep them that way for compatibility
with your JavaScript clients, you can’t beat the JSON serializer.
XML and JSON are the most common formats for data on the web. XML has a num-
ber of more tightly typed schemas that are popular formats. In the next section, you’ll
learn how to work with two of them: RSS and Atom. 
22.3
Working with RSS and Atom
Atom and RSS are XML schemas, or formats, that make it easy to share information
that’s potentially updated on a regular basis. This information can be broadcast over a
network via HTTP and is generally referred to as a feed. Each feed can be subscribed to
through an application that has the ability to query for new feed updates and render
feed information. 
 Most blogs publish their feeds in either RSS or Atom formats, with RSS being the
prevalent format for most readers. Silverlight is one such platform that can be used to
work with Atom 1.0 and RSS 2.0 feeds through the System.ServiceModel.Syndication
namespace and the SDK assembly of the same name. 
 Though blogs are the most popular and best known use for these formats, they
aren’t limited to blog updates; they’re good for item feeds of all sorts. Some sites use
them to notify you of new events added to a calendar. Some CMS and portal technolo-
gies, such as SharePoint, even allow you to expose each and every list of data as a feed.
Some services, even RESTful services, offer the ability to return the data formatted as
Atom 1.0 documents.
 In this section, you’ll use the classes in the System.ServiceModel.Syndication
namespace to pull RSS and Atom blog feeds. The code you’d write to work with any
other list would be, at its core, the same.
22.3.1 Reading syndication feeds
Because both Atom and RSS feeds are represented as XML, reading syndicated con-
tent is a very easy process. You can use any of the XML parsing mechanisms described
in this chapter to pull information out of a feed, as long as you understand the differ-
ent schema each uses. You can also use the XmlReader class’s Create method to
quickly read the XML and then load it into a SyndicationFeed to take care of all the
schema parsing for you. 
 The SyndicationFeed class abstracts away the differences between RSS and Atom,
surfacing for you a homogenous view of the feed data.
 Before you dive into the code to load a feed, it’s helpful to understand what prop-
erties the SyndicationFeed class provides you in the way of data about the feed, as
well as how they relate to the different feed types. Table 22.1 shows the main proper-
ties exposed by the class, as well as the Atom 1.0 and RSS 2.0 fields they map to.

567
Working with RSS and Atom
Table 22.1
The main feed properties available through a SyndicationFeed. Each property is shown
with the element or property it corresponds with in the Atom 1.0 and RSS 2.0 specifications. RSS items
identified with a10 are brought over from the Atom specification as an extension.
Property
Atom 1.0
RSS 2.0
Description
Authors
Author
managingEditor
/a10:author
A collection of SyndicationPerson
objects. Each item in the collection repre-
sents an individual who’s considered to be 
an author of the feed. Atom feeds are guar-
anteed to have at least one author. 
Categories
Category
Category
A collection of SyndicationCategory
objects. Each item in the collection is a cate-
gory that the feed can belong to. Categories 
are used by aggregators to logically group 
similar feeds. An RSS or Atom feed can 
belong to multiple categories. Feeds are not 
required to belong to any categories.
Contributors
contributor
a10:contributor
A collection of SyndicationPerson
objects. Each object in the collection repre-
sents someone who has contributed to cre-
ating an Atom feed. A contributor isn’t as 
central to the production of a feed as an 
author.
Copyright
Rights
Copyright
Represents the copyright information related 
to the feed. 
Description
Subtitle
Description
Provides a small summary of the feed.
Generator
generator
Generator
The name of the application used to create 
the feed.
Id
id
a10:id
The unique identifier of an Atom feed repre-
sented as a string. This value will be 
null for RSS feeds. This value may be any-
thing from a URL to a GUID.
ImageUrl
Logo
Image
The URL of the image associated with the 
feed. This image generally represents the 
branding associated with a feed.
Language
Lang
language
This optional value represents the language 
that the feed was written in.
LastUpdated-
Time
updated
lastBuildDate
The time at which the feed was last 
updated.
Links
link
a10:link
A collection of SyndicationLink ele-
ments. Each SyndicationLink repre-
sents a link available for the item. In most 
cases, there will be only one of these. That 
one is the link to the resource the feed item 
represents. (For example, the blog post)
Title
title
Title
The general title of the feed. Required for 
RSS.

568
CHAPTER 22
Working with XML, JSON, RSS, and Atom
Table 22.1 shows the key properties at the feed level. Typically, you’ll only get a few
things from the feed itself, the most important of which are the Title and the Items
collection. The Title is the textual title of the feed; this is typically what’s displayed in
a feed reader to identify a given feed. 
 Like most of the data made available to you, this property is abstracted away as a
TextSyndicationContent item, so you can’t simply refer to it and expect to see text.
Instead, you must refer to the Title.Text property to see the text of the field.
Though seemingly cumbersome at first, this abstraction enables the syndication feed
class to retain attribute information such as the type attribute. You’ll look at the Items
property a bit later.
 Listing 22.13 shows the code required to download my own blog RSS feed4 and
parse it using SyndicationFeed.
using System.Net;
using System.Windows;
using System.Windows.Controls;
using System.Threading.Tasks;
using System.ServiceModel.Syndication;
using System.Xml;
using System.Threading;
namespace FeedReaderExample
{
  public partial class MainPage : UserControl
  {
    public MainPage()
    {
      InitializeComponent();
    }
    private SynchronizationContext _syncContext =   
                       SynchronizationContext.Current;
    private void LoadFeed_Click(object sender, RoutedEventArgs e)
    {
      string uri = FeedUrl.Text.Trim();
      var request = WebRequest.Create(uri);
      var webTask = Task.Factory.FromAsync<WebResponse>(
        request.BeginGetResponse, request.EndGetResponse, null)
        .ContinueWith(
          task =>                                      
4 Hey, I’ll do just about anything for a little blog traffic.
Listing 22.13
Downloading and processing a syndication feed
Async call 
with task

569
Working with RSS and Atom
          {
               var response = (HttpWebResponse)task.Result;
            var stream = response.GetResponseStream();
            using (var reader = XmlReader.Create(stream))  
            {
              var feed = SyndicationFeed.Load(reader);   
              _syncContext.Post((o) =>
              {
                DataContext = feed;
              }, null);
            }
          });
            
    }
  }
}
Be sure to add a reference to System.ServiceModel.Syndication.dll and to add
that namespace to your using statements. 
 Listing 22.13 uses a bit of the task magic from chapter 19 to handle the async
nature of this call. If you’re unfamiliar with the Task class or with creating delegates by
using lambda expressions, revisit that chapter for a refresher.
 The code in listing 22.13 takes the URL from a TextBox on-screen, creates the web
request, and calls that URL. When the response comes back, the code pulls the stream
from the results and loads it into an XmlReader. The XmlReader is the required inter-
mediary between whatever form the data comes in and the SyndicationFeed itself.
 The code then loads the feed from the XmlReader and posts a message to the UI
thread saying to set the DataContext of the UI to the feed itself. As you may recall
from chapter 16, setting the DataContext like this means all binding in the UI will
now be relative to this SyndicationFeed object. Using the DataContext lets you focus
all your feed items work in the XAML binding statements rather than the code-behind.
22.3.2 Working with feed items
The Items collection (actually, an IEnumerable) of the SyndicationFeed contains as
many feed items as the server has configured to send to you. The server is in complete
control, with most returning the last 10 or 25 items from the feed. It’s the responsibil-
ity of the client to determine which ones are new (using the unique IDs) and which
ones are already downloaded.
 Each feed item is presented to you as a single SyndicationItem class. Table 22.2
shows the properties of the SyndicationItem class, as well as the Atom 1.0 and RSS 2.0
elements or attributes they map to, and a description of what each property used for.
XML stream
SyndicationFeed

570
CHAPTER 22
Working with XML, JSON, RSS, and Atom
With an understanding of the properties of both SyndicationFeed and Syndication-
Item in mind, you can now create a basic UI that shows a list of items pulled from the
RSS feed. Listing 22.14 is the XAML for the UI used in the simple RSS viewer.
<UserControl x:Class="FeedReaderExample.MainPage"
  xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
Table 22.2
The properties available for a SyndicationItem
Property
Atom 1.0
RSS 2.0
Description
Authors
author
managingEditor 
or a10:author
A collection of SyndicationPerson
objects. Each item in the collection represents 
an individual who’s considered to be an author 
of the item. Atom feeds are guaranteed to 
have at least one author.
Categories
category
category
A collection of SyndicationCategory
objects. Each item in the collection is a cate-
gory that the item belongs to.  An item can 
belong to multiple categories. But items aren’t 
required to belong to any categories.
Content
content
a10:content
The content of the item.
Contributors
contributor
a10:contributor
A collection of SyndicationPerson
objects. Each object in the collection repre-
sents someone who has contributed to creat-
ing an Atom feed. A contributor isn’t as central 
to the production of a feed as an author.
Copyright
rights
Copyright
Any copyright information for the item.
Id
id
a10:id
Unique ID for the item provided by the feed, 
typically the URL to the post.
LastUpdated-
Time
updated
a10:updated
A DateTimeOffset indicating the last modi-
fied time for the item. 
Links
link
Link
A collection of SyndicationLink elements. 
Each SyndicationLink represents a link 
available within the feed.
PublishDate
published
pubDate
A DateTimeOffset indicating published 
time for the item.
SourceFeed
source
Source
The SyndicationFeed of which the item is 
a member.
Summary
summary
Description
Summary of the item. Be warned that this 
often contains the full text of the post 
because the modern usage of this field 
doesn’t always fit the original spec.
Title
title
Title
The title of the syndicated item.
Listing 22.14
XAML for the reader application

571
Working with RSS and Atom
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
  xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
  xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
  mc:Ignorable="d"
  d:DesignHeight="300" d:DesignWidth="400">
  <Grid x:Name="LayoutRoot" Background="White">
    <Grid.RowDefinitions>
      <RowDefinition Height="Auto" />
      <RowDefinition Height="Auto" />
      <RowDefinition Height="*" />
    </Grid.RowDefinitions>
    <Grid Grid.Row="0">
      <Grid.ColumnDefinitions>
        <ColumnDefinition Width="*" />
        <ColumnDefinition Width="Auto" />
      </Grid.ColumnDefinitions>
      <TextBox x:Name="FeedUrl" Margin="10" Grid.Column="0"  
               Text="http://feeds.feedburner.com/PeteBrown" />
      <Button x:Name="LoadFeed" Grid.Column="1"
              Margin="10" Width="100" Height="25"
              Content="Load Feed" Click="LoadFeed_Click" />
    </Grid>
    <TextBlock Text="{Binding Title.Text}"      
               Margin="10" Grid.Row="1" />
    <ListBox x:Name="FeedItems" Margin="10"            
             Grid.Row="2" ItemsSource="{Binding Items}"> 
      <ListBox.ItemTemplate>
        <DataTemplate>                              
          <Grid>
            <Grid.RowDefinitions>
              <RowDefinition Height="Auto" />
              <RowDefinition Height="Auto" />
              <RowDefinition Height="*"/>
            </Grid.RowDefinitions>
            <TextBlock Text="{Binding Id}" Grid.Row="0" />
            <HyperlinkButton NavigateUri="{Binding Links[0].Uri}"
                             Content="{Binding Title.Text}" 
                             TargetName="_blank" Grid.Row="1"/>
            <TextBlock Text="{Binding PublishDate}" Grid.Row="2" />
          </Grid>
        </DataTemplate>
      </ListBox.ItemTemplate>
    </ListBox>
  </Grid>
</UserControl>
Feed URL
Title display
Items list
Item template

572
CHAPTER 22
Working with XML, JSON, RSS, and Atom
The listing makes use of a number of things you learned in chapter 16. There’s bind-
ing of the Title.Text property—notice how you can “dot down” into the text prop-
erty easily in the binding statement. There’s also the binding of the ListBox and a
DataTemplate used to display the individual SyndicationItem instances. Each
instance displays the item ID, the title as a hyperlink using a collection item binding
statement, and the publish date.
 When you run the application and click the button to load the feed data, you’ll see
a list of my most recent blog posts. The completed miniapplication looks like figure 22.3.
 By looking at figure 22.3, you should be able to roughly calculate when I wrote the
syndication section of this chapter. (Or you could always just look at the downloadable
source code and check the dates there.)
 The RSS feed reader shown here doesn’t show the contents of the RSS item. It’d be
a simple matter to use a little binding to display a WebBrowser control on the right,
loaded up with the contents of that feed item. The only tricky part is that some feeds
use the contents property, whereas others use the summary property. Standards are
open to interpretation, right?
Figure 22.3
The minifeed reader application. Each line of the ListBox shows the item ID (a 
URL in this case), a link to the item represented as the title, and the date/time the item was 
published. The feed title is at the top under the URL TextBox.

573
Summary
 This section focused on the core of the RSS and Atom feed data. Both formats also
support any number of extensions, like additional images and geolocation informa-
tion. You can process that information manually using regular XML processing once
you pull them from the ElementExtensions property of the SyndicationFeed class.
 There are also microformats to consider. Microformats are inline bits of data
inside the contents. Typically these are handled using specific CSS tags and may repre-
sent things like the contact card for the author. You’ll need to either turn to a third
party or do a fair bit of manual parsing of the content if you want to handle these. If
you’re curious about microformats, I encourage you to investigate further at http://
microformats.org/.
 Finally, keep in mind that the SyndicationFeed class, through the use of the
Atom10FeedFormatter and Rss20FeedFormatter classes, can also write feed informa-
tion. It’s unusual for a Silverlight application to write syndication feed information to
a store, but the capability is there.
22.4
Summary
This chapter took a data-centric look at networking. Specifically, you learned what’s
needed to process XML, JSON, and RSS/Atom results from HTTP requests.
 When it comes to consuming data from a REST service or storing data locally, the
two most popular formats are XML and JSON. Silverlight supports several ways to parse
XML, including the popular LINQ to XML approach and the powerful XML serializer. I
What about cross-domain feeds?
Before you think about creating a dedicated RSS reader in Silverlight, keep in mind
that RSS, like any other network call, is subject to the cross-domain restrictions cov-
ered in chapter 19. In fact, Silverlight’s networking stack doesn’t know you’re down-
loading a harmless and usually public RSS feed; it simply knows you’re making a
network request.
For that reason, you have three choices: 
■
Limit yourself to RSS feeds that have a permissive cross-domain policy in
place. Other than on the big aggregators like FeedBurner, this is rare to find.
■
Make the RSS reader application use elevated trust and the client networking
stack to avoid the cross-domain checks.
■
Write a proxy on your own server that passes all calls to external resources
through the Silverlight application’s site of origin. This approach has obvious
traffic and scalability impacts.
I once wrote a Facebook application in Silverlight 2 (or maybe it was 3?). I ended up
using a variation of the third option and passed all requests through the site of origin.
Because the application aggregated only a small set of feeds, I took advantage of
that data knowledge and cached those same feeds on the server to reduce the amount
of traffic. 

574
CHAPTER 22
Working with XML, JSON, RSS, and Atom
tend to use LINQ to XML when doing small tasks and the XML serializer when I have a
serious set of objects to work with.
JSON is an even simpler format than XML. Also like XML, Silverlight supports a few
different ways to parse its data. The JsonObject is great when you want to work with
JSON as though it’s a large property bag—a set of key-value pairs. When you want to do
a significant amount of processing, you can’t beat the DataContractJsonSerializer
for its ability to parse deep JSON objects quickly and with minimal code.
 I wrapped up this chapter with a look at what it takes to pull RSS 2.0 and Atom 1.0
feed information into your applications. In addition to the usual blog feeds, there are
other sources of data formatted using these two specifications. It’s great to see that
Silverlight has built-in support for working with them.
 Now that you’ve handled all the mainstream networking uses, in the next chapter
you’ll look at several lesser used but powerful networking features of Silverlight,
including sockets and duplex services.

575
Duplex, sockets,
and local connections
So far, you’ve explored the basics of networking, how to use ASP.NET and WCF SOAP
services, how to use the WCF Web API for RESTful services, and how to parse the
data that commonly comes from those various types of services. Wow, that’s a lot of
networking coverage!
 That much coverage makes perfect sense, though. As a RIA client used com-
monly both on the internet and increasingly inside organizations, connected Silver-
light applications are the norm, not the exception. For that reason, I thought I’d
take us down one last networking path. This chapter will cover four of the lesser
known but very powerful types of networking supported by Silverlight: WCF polling
duplex services, sockets, multicast sockets, and local connections.
 In those previous chapters, all the networking work you did was fundamentally
unidirectional: a client-initiated request followed up by a server response. The
requests and responses were 1:1. What happens in cases where you need the server
This chapter covers
■
WCF polling duplex services
■
Socket-based communication
■
Silverlight-to-Silverlight local connections

576
CHAPTER 23
Duplex, sockets, and local connections
to contact the client to tell it that key data has been updated or that a record is locked
by another user? Sure, you could throw together a timer and make repeated calls to a
service, but that’s hard to get right. Instead, Silverlight supports two technologies spe-
cifically designed to enable server messaging to the client: WCF polling duplex and
sockets. WCF polling duplex builds on the WCF and SOAP skills you already have to
support bidirectional communication over HTTP. 
 Sockets are something completely different but powerful, giving you low-level con-
trol over the protocol. The code (especially on the server side) for working with sock-
ets tends to be quite a bit more complex than other approaches, but that’s the trade-
off for more power. Media and learning scenarios often use a specialized form of sock-
ets known as multicast sockets. Silverlight includes basic support for this type of com-
munication as well.
 One other type of networking scenario is the one of multiple Silverlight clients on
the same page. In a regular old web page, this isn’t a common occurrence, but on
something like a SharePoint or DotNetNuke portal page, it can be quite common.
Sometimes those different instances need to be able to communicate with one
another to be able to share information. You could write a JavaScript bridge to handle
it, but especially in the portal scenario, that ends up brittle and hard to make work in
all possible configurations of the page. I’ll show you a better approach to connect
multiple Silverlight applications: local connections. 
 Of all the networking technologies mentioned, WCF polling duplex services are
the most commonly used and the closest in theory to the networking covered in previ-
ous chapters. Let’s start there.
23.1
WCF polling duplex services
Duplex services give the server the ability to send, or push, data directly to the client as
it becomes available. Applications have to send a request for updates to the server that
execute on a loop or within a timer. This approach, known as polling, creates over-
head, both in your application and on the network. Balancing the overhead and opti-
mizing the connection usage can be difficult for most developers.
 Silverlight, combined with WCF, introduced the polling duplex service infrastruc-
ture to the world. Unlike the SOAP and REST services you’ve looked at so far, this is a
proprietary type of service and client. The implementation was designed to give the
developer the features of server-pushed messages, which keep the port requirements
to those normally used and the client programming familiar. This is in contrast to
sockets that are real bidirectional communications mechanisms but that also require
special ports to be opened in firewalls, as well as some moderately complex client and
server-side coding to make it all work. You’ll look at sockets in section 23.2.
 In previous versions of Silverlight, the process for using polling duplex services
from the client was complex, because there was no “Add Service Reference” type func-
tionality to generate a proxy. You could still write code that way if you want. But, espe-
cially with Silverlight 5, the client proxy generation is good enough that you don’t
need to. For that reason, I’ll cover the much simpler approach in this section.

577
WCF polling duplex services
There are lots of great uses for polling duplex services: data update notifications,
stock quotes, sensor data, new work queue items, production updates, and more. For
the example in this section, I decided not to use any of those scenarios and instead
create the insult service.
 Much like Henry Stauf did when you were trying to solve puzzles in The 7th Guest,1
the insult service throws random programmer-oriented insults at you while you code.
Just leave it up and running while you program away. Fun shall ensue. Figure 23.1
shows what the application looks like while running.
 Throughout the rest of this section you’ll build both the service and the client. I’ll
first show you how to set up and configure a polling duplex service, along with helper
code for subscription management. Then, you’ll explore the web.config changes
required for polling duplex. Once that’s all set up and the service is compiling nicely,
you’ll create a simple client that allows you to subscribe to and unsubscribe from the
service.
23.1.1 Creating the project and callback contract
Like most of our other examples, this one requires a standard two-project Silverlight
solution. So, create a new Silverlight solution in Visual Studio. I named mine Duplex-
Example. Make sure you leave the option to host the Silverlight application in a new
ASP.NET website at the default value. You should end up with two projects: DuplexEx-
ample and DuplexExample.Web (or whatever name you chose).
 Next, as you learned in chapter 20, go into the project properties for the web proj-
ect, navigate to the Web tab, and set the server to use a specific port. I used 5150. This
1 I realize some of my readers may actually be too young to have played this classic game. It was one of the first
“MultiMedia” CD-ROM games for the PC/DOS. With the reboot of Trilobyte, there are new ports to iOS if
you want to try them out on modern hardware. See http://en.wikipedia.org/wiki/The_7th_Guest. 
Figure 23.1
The insult service, a polling 
duplex service that abuses 
us as we work.

578
CHAPTER 23
Duplex, sockets, and local connections
will ensure that the references you add and the port numbers in code all work fine
without your having to write additional code.
USING THE POLLINGDUPLEX DLL
Most of the code required to run a polling duplex service is already in WCF proper.
But there are some additional types and configurations needed that are specific to the
polling duplex variation. Those are contained in the System.ServiceModel.PollingDu-
plex.dll library.
 On the web project, add a reference to the server version of this library, found in
the Silverlight SDK folder. On my machine, that’s C:\Program Files (x86)\Microsoft
SDKs\Silverlight\v5.0\Libraries\Server\. Make sure you use the server version, not the
client version. Also, add a reference to the server-side System.ServiceModel.dll.
 Once these references are added, you’ll have access to the callback functionality
you need to make the service work.
CREATING THE CALLBACK
WCF polling duplex services work by using a callback. The client calls a method on the
server, and the server, at some point or multiple points in the future, sends a callback
message to the client. It’s the developer’s responsibility to define what this callback
message looks like.
 Figure 23.2 shows the workflow of a typical polling duplex operation. You can see
that you need to have a callback interface, which is used on the server by the WCF ser-
vice and converted to an event on the client to be used by the proxy on the Silverlight
client. This interface can be as complex as you’d like, as long as it can be serialized by
WCF. Listing 23.1 shows the callback interface used. Create this in the Services folder
on the web project. If you don’t already have a Services folder, create one now.
using System;
using System.Web;
using System.ServiceModel;
Listing 23.1
The callback interface
Figure 23.2
The workflow of a typical 
polling duplex operation

579
WCF polling duplex services
namespace DuplexExample.Web.Services
{
  [ServiceContract]
  public interface IInsultCallback
  {
    [OperationContract(IsOneWay = true)]
    void OnInsult(string insult);
  }
}
The callback interface can have multiple methods. Each method will be turned into
an event handler on the client. In our example, you have only one method: OnInsult.
The method takes a single string parameter that contains the new insult text.
 The next step is to create the service itself.
23.1.2 Creating the service
With the callback contract defined, you can now create the service that uses it. The
Services folder will contain your insult service as well as all of its support classes and
the callback interface. You can name it anything you want, but I prefer to use the stan-
dard of placing all services in a folder named Services.
 Inside the Services folder, add a new Silverlight-enabled web service as you did in
chapter 20. I named my service InsultService. I’ll get back to that service in just a
moment.
 The code for the service is in listing 23.2. You’ll define the NewInsultEventArgs
and SubscriberManager classes shortly, so this code won’t yet compile as is.
using System;
using System.ServiceModel;
using System.ServiceModel.Activation;
namespace DuplexExample.Web.Services
{
  [ServiceContract(Namespace = "",
        CallbackContract=typeof(IInsultCallback))]       
  [SilverlightFaultBehavior]
  [AspNetCompatibilityRequirements(
    RequirementsMode = AspNetCompatibilityRequirementsMode.Allowed)]
  public class InsultService
  {
    [OperationContract]
    public bool Unsubscribe()                           
    {
      var result = SubscriberManager.Unsubscribe();
      if (SubscriberManager.Subscribers.Count == 0)
      {
        Insulter.StopInsulting();
        Insulter.NewInsult -= OnNewInsult;
      }
Listing 23.2
The insult polling duplex service
Callback 
declaration
Unsubscribe 
WCF method

580
CHAPTER 23
Duplex, sockets, and local connections
      return result;
    }
    [OperationContract]
    public bool Subscribe()                            
    {
      var result = SubscriberManager.Subscribe();
      if (SubscriberManager.Subscribers.Count == 1)
      {
        Insulter.NewInsult += OnNewInsult;
        Insulter.StartInsulting();
      }
      return result;
    }
    void OnNewInsult(object sender, NewInsultEventArgs e)
    {
      foreach (IInsultCallback callback in SubscriberManager.Subscribers)
      {
        callback.OnInsult(e.Insult);                    
      }
    }
  }
}
Except for a few details, the service in listing 23.2 looks just like any other Silverlight-
enabled WCF Service. In particular, the Subscribe and Unsubscribe methods are sim-
ply standard service methods. What makes this a polling duplex service is the
CallbackContract declaration in the ServiceContract attribute. This tells WCF, and
the Silverlight client, that this will be sending messages back to the client.
 The callback messages are sent inside the OnNewInsult event handler. This event
handler is called from the static Insulter class, which I’ll cover shortly. For a clearer
picture, figure 23.3 shows an updated version of the workflow with the classes involved
in this example.
Subscribe
WCF method
Callback 
operation
Figure 23.3
Updated workflow with classnames for our implementation

581
WCF polling duplex services
From the diagram, you can see that the service uses the SubscriptionManager for
managing Subscribe (and Unsubscribe) operations. It also uses the Insulter class
for getting the actual insults. Before I get to those two classes, I’ll wrap up the WCF
side of things with the web.config entries for polling duplex.
 Listing 23.3 shows the entries that must be made to support polling duplex on the
server. The web.config will have a lot of other stuff in it, so don’t simply paste this over
your existing web.config; instead, add the individual entries in their correct locations
in the file.
<configuration>
...
  <system.serviceModel>
    <extensions>
      <bindingExtensions>
        <add name="pollingDuplexHttpBinding"         
             type="System.ServiceModel.Configuration.
             ➥ PollingDuplexHttpBindingCollectionElement,
             System.ServiceModel.PollingDuplex, 
             Version=5.0.0.0, 
             Culture=neutral, 
             PublicKeyToken=31bf3856ad364e35"/>
      </bindingExtensions>
    </extensions>
     ...
    <bindings>
      <pollingDuplexHttpBinding>
        <binding name="singleMessagePerPollDuplexBinding"    
                 duplexMode="SingleMessagePerPoll" />
      </pollingDuplexHttpBinding>
     ...
    </bindings>
    <services>
      <service name="DuplexExample.Web.Services.InsultService"> 
        <endpoint address="" 
                  binding="pollingDuplexHttpBinding"
                  bindingConfiguration="singleMessagePerPollDuplexBinding"
                  contract="DuplexExample.Web.Services.InsultService" />
        <endpoint address="mex" 
                  binding="mexHttpBinding"
                  contract="IMetadataExchange" />
      </service>
    </services>
    ...
  </system.serviceModel>
</configuration>
The first new entry in listing 23.3 creates a new binding extension. The extension is in
the polling duplex DLL you added a reference to. This section tells the web.config
parser that you’ll have a new type of entry in the bindings section.
Listing 23.3
Updates to web.config for polling duplex
Binding extension
Binding
Service

582
CHAPTER 23
Duplex, sockets, and local connections
 In the bindings section, you’ll use the new extension to create a configuration.
Your configuration has a duplexMode of SingleMessagePerPoll, which means that a
single polling call to the server will return with, at most, a single callback result. The
other possible value is MultipleMessagesPerPoll, which allows it to return with more
than one callback result in a single poll. In a system with a large number of frequent
messages, the multiple messages approach could be a performance boost. But it keeps
the connection open for as long as there are new messages to download, so you could
quickly overload the server if you have many clients. Note also that the multiple mes-
sages approach requires streamed responses, which you’re not using here.2
 Finally, in the services section you’ve replaced the stock service entry with one that
uses the new binding you set up (pollingDuplexHttpBinding) and the new configu-
ration (singleMessagePerPollDuplexBinding). The “mex” entry is the standard
entry added by WCF.
23.1.3 Creating the service logic
The heart and soul of this example is the Insulter class. This class keeps a list of
insults and randomly returns them to any listeners using a timer and an event. This is
a static class, shared by all callers.
 Listing 23.4 shows the Insulter class, which also resides in the Services folder on
the web project.
using System;
using System.Collections.Generic;
using System.Linq;
using System.Timers;
using System.Web;
namespace DuplexExample.Web.Services
{
  public class NewInsultEventArgs : System.EventArgs
  {
    public string Insult { get; internal set; }
  }
  public static class Insulter
  {
    private static List<string> _insults = 
                   new List<string>();
    private static Random _random;
    private static Timer _insultTimer;
    public static event EventHandler<NewInsultEventArgs> NewInsult;
    static Insulter()
2 For more information on WCF-streamed responses, see this MSDN article: http://bit.ly/WCFStreamed
Response.
Listing 23.4
The Insulter class

583
WCF polling duplex services
    {
      BuildInsults();
      _random = new Random();
    }
    public static void StartInsulting()
    {
      if (_insultTimer == null || !_insultTimer.Enabled)
      {
        _insultTimer = new Timer();
        _insultTimer.Interval = 5000;                 
        _insultTimer.Elapsed += OnTimerTick;
        _insultTimer.Enabled = true;
        _insultTimer.Start();
      }
    }
    public static void StopInsulting()
    {
      if (_insultTimer != null)
      {
        _insultTimer.Enabled = false;
        _insultTimer.Stop();
        _insultTimer.Elapsed -= OnTimerTick;
        _insultTimer = null;
      }
    }
  
    private static void BuildInsults()                
    {
      _insults.Clear();
      _insults.Add("Your code smells like old ADA.");
      _insults.Add("You chose...poorly.");
      ...
      _insults.Add("I lost 10 IQ points just reading your code.");
      _insults.Add("Entering the obfuscation contest, I see.");
    }
    private static void OnTimerTick(object sender,      
                                    ElapsedEventArgs e)
    {
      if (NewInsult != null)
        NewInsult(null, 
          new NewInsultEventArgs() { Insult = GetRandomInsult() });
    }
    private static string GetRandomInsult()
    {
      int index = _random.Next(_insults.Count - 1);      
      return _insults[index];
    }
  }
}
New insult every 
5 seconds
Initialization
Timer callback
Random insult

584
CHAPTER 23
Duplex, sockets, and local connections
The class in listing 23.4 contains a list of insults. When the StartInsulting method is
called, it initializes the list of insults and kicks off a timer, which picks a random insult
every 5 seconds. The time is specified in milliseconds and can easily be changed if you
want a less vigorous insulting system. 
 I’ve included only a subset of the insults here; the rest are available in the down-
loadable source code.
 When the timer ticks, a new insult is picked, and the NewInsult event is fired off.
This event is caught by the WCF service, which then sends it to all the subscribed clients.
23.1.4 Managing client subscriptions
In a publish/subscribe-based system like the one you’ve implemented here, it helps to
have a centralized class responsible for managing the subscriptions. You could do this
in the WCF service itself, but that makes the service code more complex than it should
be. In this example, the static SubscriptionManager is responsible for keeping track
of which clients are connected The subscribed clients are held in a simple list of call-
backs, as shown next.
using System;
using System.Collections.Generic;
using System.ServiceModel;
namespace DuplexExample.Web.Services
{
  public static class SubscriberManager
  {
    private static List<IInsultCallback> _subscribers =   
      new List<IInsultCallback>();
    public static List<IInsultCallback> Subscribers
    {
      get { return _subscribers; }
    }
    public static bool Subscribe()
    {
      try
      {
        var callback =                                 
          OperationContext.Current.GetCallbackChannel
          [CA]<IInsultCallback>();
        if (!_subscribers.Contains(callback))
        {
           _subscribers.Add(callback);             
        }
        return true;
      }
      catch
Listing 23.5
 SubscriberManager 
Create 
Subscriber list
Get current 
connection
Add subscriber

585
WCF polling duplex services
      {
        return false;
      }
    }
    public static bool Unsubscribe()
    {
      try
      {
        var callback =
          OperationContext.Current.GetCallbackChannel
          [CA]<IInsultCallback>();
        if (_subscribers.Contains(callback))
          _subscribers.Remove(callback);               
        else
          return false;
        return true;
      }
      catch
      {
        return false;
      }
    }
  }
}
The class in listing 23.5 has two methods, Subscribe and Unsubscribe, which are
called directly from the service. These methods use the GetCallbackChannel method
of the current OperationContext instance in order to get a handle on the current
connection. When subscribing, this class caches the callback channel in the list of sub-
scribers. When unsubscribing, the channel is removed from the list. 
 The list itself is used by the WCF service to iterate through the clients and send
insults to each and every one of them.
 I don’t do a particularly thorough job cleaning up the server in this example. For a
robust service, you’ll want to add checks to see if the channel is disconnected via the
OperationContext.Current.Channel object, make sure it shuts down gracefully when
clients disconnect without unsubscribing, and handles errors differently. Those are all
out of scope for this example, because they’re more specific to WCF and how the service
is hosted. You may also want to avoid using static objects and instead cache singletons.
Again, that depends on your particular server and service implementation.
23.1.5 Using the duplex service
As with any other Silverlight application, you’ll want a little test UI to hit the service.
The UI will consist of a large TextBlock at the top, which will display the current
insult. Below that will be a subscribe button and an unsubscribe button, which will call
the Subscribe and Unsubscribe service methods, respectively.
Remove subscriber

586
CHAPTER 23
Duplex, sockets, and local connections
 Update the MainPage.xaml markup so it looks like what’s shown in listing 23.6.
<UserControl x:Class="DuplexExample.MainPage"
  xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
  xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
  xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
  mc:Ignorable="d"
  d:DesignHeight="300" d:DesignWidth="400">
  <Grid x:Name="LayoutRoot" Background="White">
    <Grid Margin="20">
      <Grid.RowDefinitions>
        <RowDefinition Height="*" />
        <RowDefinition Height="Auto" />
      </Grid.RowDefinitions>
      <TextBlock x:Name="InsultText" Grid.Row="0"       
                 FontSize="30"
                 TextAlignment="Center" 
                 TextWrapping="Wrap" />
      <StackPanel Grid.Row="1" Orientation="Horizontal"
                  HorizontalAlignment="Center">
        <Button x:Name="Subscribe" Content="Subscribe"
                Width="100" Height="25" Margin="10"
                Click="Subscribe_Click" />
        <Button x:Name="Unsubscribe" Content="Unsubscribe"
                Width="100" Height="25" Margin="10"
                IsEnabled="false"                         
                Click="Unsubscribe_Click" />
      </StackPanel>
    </Grid>
  </Grid>
</UserControl>
Note in listing 23.6 that the unsubscribe button is disabled by default. You enable that
in the code-behind only after a successful call to subscribe to the service. 
REFERENCES AND CODE-BEHIND
Before you can work with the service proxy, you need to do a couple things. First, add
a reference to the client version of the System.ServiceModel.PollingDuplex.dll in the
SDK folder. Then, make sure you build the server project and that it compiles without
errors. Next, add a service reference to the insult service. I named mine Services.
Make sure you built the service project before you do this.
 Once those two steps are complete, you can add the code to work with the duplex
service client proxy. Listing 23.7 has the code-behind for MainPage.xaml.cs. 
using System;
using System.ServiceModel;
Listing 23.6
Client UI XAML
Listing 23.7
Code-behind for MainPage.xaml.cs
Insult display
Button disabled

587
WCF polling duplex services
using System.Windows;
using System.Windows.Controls;
using DuplexExample.Services;
namespace DuplexExample
{
  public partial class MainPage : UserControl
  {
    private InsultServiceClient _proxy;
    public MainPage()
    {
      InitializeComponent();
      var binding = new PollingDuplexHttpBinding();
      var address = new
       EndpointAddress("http://localhost:5150/Services/InsultService.svc");
      _proxy = new InsultServiceClient(binding, address); 
    }
    private void Subscribe_Click(object sender, RoutedEventArgs e)
    {
      _proxy.SubscribeCompleted += (s, ea) =>
        {
          if (ea.Result)
          {
            Subscribe.IsEnabled = false;
            Unsubscribe.IsEnabled = true;
            _proxy.OnInsultReceived += OnInsultReceived;  
          }
          else
          {
            MessageBox.Show("Could not subscribe");
          }
        };
      _proxy.SubscribeAsync();
    }
    private void OnInsultReceived(object sender,        
                                  OnInsultReceivedEventArgs e)
    {
      InsultText.Text = e.insult;
    }
    private void Unsubscribe_Click(object sender, RoutedEventArgs e)
    {
      _proxy.UnsubscribeCompleted += (s, ea) =>
        {
          if (ea.Result)
          {
            Subscribe.IsEnabled = true;                
            Unsubscribe.IsEnabled = false;     
            _proxy.OnInsultReceived -= OnInsultReceived;  
          }
Create proxy
Wire callback
Handle callback
Toggle buttons
Clean up handler

588
CHAPTER 23
Duplex, sockets, and local connections
          else
          {
            MessageBox.Show("Could not unsubscribe");
          }
        };
      _proxy.UnsubscribeAsync();                      
    }
  }
}
The code-behind in listing 23.7 creates an instance of the proxy class and gives it the
endpoint of the service (this is why you set the server to use a single port) and the
appropriate binding. 
 When the user clicks the Subscribe button, the code calls the Subscribe method
on the proxy. If the call succeeds, it wires up the OnInsultReceived event, disables the
Subscribe button, and enables the Unsubscribe button. The unsubscribe code does
the opposite.
 The OnInsultReceived event handler is the client side of the callback contract.
The event handler is given a set of event args, which contain members for each param-
eter in the OnInsult method on the contract interface.
CONNECTING MULTIPLE CLIENTS
If you run this code with multiple connected clients, they’ll all receive the same insult
at the same time. This is a typical approach for many client update scenarios. But if
you don’t like this approach or it isn’t appropriate for your scenario, you’ll want to
change the service to deal with individual callbacks and not centralize the subscrip-
tion management.
 Figure 23.4 shows four different clients all connected and receiving the same updates.
Unsubscribe
Figure 23.4
Showing off the newest invention in insulting: 4D insulting by polling duplex!

589
Connecting to sockets
The polling duplex service is a great way to handle scenarios where you want one or
more clients to receive messages from a server without having to manually poll the ser-
vice. In Silverlight 5, it’s much easier to set up than what you had in Silverlight 2. The
majority of the work is no longer in the setup, but more in setting up the appropriate
design for your service so it handles the scenarios you’re trying to cover: different mes-
sages to each client, different timings for each client, or everyone gets the same thing.
WCF has turned out to have just about everything you might want in a networking
stack: it handles SOAP and REST services as you’ve learned, and it even handles duplex
services that can send messages back to the client. As flexible as it is, though, it isn’t
always the correct solution. In some cases, you need true bidirectional communica-
tion without the overhead that polling and HTTP add. In those instances, you’ll want
to consider sockets. 
23.2
Connecting to sockets
Way back before we had HTTP, standardized IP networking was based on the concept
of sockets. Sockets were popularized by BSD (Berkeley Software Distribution) and
their BSD Unix product that came out of UC Berkeley. Modern implementations of
socket APIs, including the ubiquitous WinSock we all dealt with in the 1990s, are based
upon the de facto standard set by Berkeley sockets. On Windows, Silverlight sockets
are based on the WinSock interface. On Mac OS X, sockets are based on BSD sockets.
Silverlight handles the abstraction for you automatically.
 In Silverlight, the socket is the lowest level of network API available to the applica-
tion developer. Building upon sockets, developers can implement just about any pro-
tocol they might want, within the port and security restrictions enforced by Silverlight.
 Sockets are lightweight and extremely fast. They impose very little overheard and
no message structure, giving the developer the ability to handle time-sensitive and
size-sensitive communications. For those reasons, you’ll often find sockets to be the
preferred method of communication in multiplayer games. When you’re transmitting
information as time-sensitive, such as the location of a bullet on a play field, you want
as fast and as light a protocol as possible.
 Unlike WPF Duplex, which uses polling on the client, sockets can be truly bidirec-
tional. Once you establish the communication channel between the endpoints, infor-
mation can flow freely in either direction. The endpoints are usually on separate
machines, such as when using a web browser talking to a web server on port 80. But
this isn’t a hard requirement; in the past, before Silverlight supported p-invoke and
COM automation, some developers implemented servers on the client (in C++ or
other languages) to enable Silverlight to perform additional functions on the OS.
 Silverlight’s implementation of sockets comes with some restrictions and limita-
tions. First, only TCP sockets are supported, so regular UDP is out. Silverlight does sup-
port UDP multicast sockets, important for many media and learning scenarios. It also
supports both IPv4 and IPv6 addressing. Second, for security reasons, Silverlight
restricts port numbers to the range of 4502–4534, so implementing protocols that

590
CHAPTER 23
Duplex, sockets, and local connections
require other ports isn’t something you can do. Also for security reasons, the socket
server must serve up a policy file that specifies what’s allowed. Finally, like all other
networking in Silverlight, socket clients must be implemented using async patterns for
communications.
 In this section you’ll create a socket server and socket client, starting with the server.
For simplicity, you’ll have everything execute on the client machine, although it’s more
typical to have the client and server on different machines. In addition, unlike the other
networking examples, this one won’t run completely based on just the code in the book.
The socket server is a complex and long piece of code. The downloadable source code
for this book contains the full client and server implementations.
 Instead, this section looks at a few of the Silverlight-specific aspects of working with
sockets. First, you’ll explore the policy file, which is required to be served up by the
socket server, regardless of where it resides. Next, you’ll see how to open the client
connection and handle the response from the socket server.
23.2.1 Serving the policy file
Sockets require a clientaccesspolicy.xml file with a few changes. The resource ele-
ment isn’t used and is replaced with the socket-resource element. Both element
types may exist in the file and apply the style to the specific type or request. Listing
23.8 is an example of a simple client access policy giving access to sockets using TCP
over port 4502.
<?xml version="1.0" encoding="utf-8"?>
<access-policy>
  <cross-domain-access>
    <policy>
      <allow-from>
        <domain uri="*"/>
      </allow-from>
      <grant-to>
        <socket-resource port="4502" protocol="tcp"/>
      </grant-to>
    </policy>
  </cross-domain-access>
</access-policy>
Your Silverlight application will typically be served up from port 80, a web server. Sock-
ets, on the other hand, don’t require a web server to be present and are on ports
other than 80. For those reasons, you must serve up a sockets policy file, because every
call is considered cross-domain (or at least cross-port). 
 You have two options for serving up the policy file. You may either host it on a web
server on port 80 on the same IP address as the sockets server, or on the sockets server itself
on port 943. Typically, you’ll set up a separate thread or a separate socket server that
listens for a connection on 943, sends the socket policy file, and closes the connection.
Listing 23.8
An example socket server policy file

591
Connecting to sockets
 Before you move on to opening the connection, you may want to refer to this
book’s web page, www.manning.com/Silverlight5inAction, for the source code for a
simple sockets server.
23.2.2 Opening the connection
Opening a socket connection with a socket server can be done in a few simple steps
that are similar to the other forms of communicating you’ve already seen. The first
step is to open the socket. Listing 23.9 shows how to open the socket on the client.
public void OpenTheSocket()
{
  DnsEndPoint tcpEndpoint = 
    new DnsEndPoint(Application.Current.Host.Source.DnsSafeHost, 4502);
  Socket tcpSocket = new Socket (                  
                          AddressFamily.InterNetwork, 
                          SocketType.Stream, 
                          ProtocolType.Tcp);
  SocketAsyncEventArgs socketArgs = new SocketAsyncEventArgs();
  socketArgs.UserToken = tcpSocket;
  socketArgs.RemoteEndPoint = tcpEndpoint;
  socketArgs.Completed += socketArgs_Completed;
  tcpSocket.ConnectAsync(socketArgs);            
}
The example creates an endpoint and a socket and then uses them to asynchronously
request a connection to the remote socket server. You use Application.Current
.Host.Source.DnsSafeHostto get the IP address of the host of the Silverlight applica-
tion in a form usable for creating a socket endpoint. Using this technique to create
the endpoint is only useful when the socket and the Silverlight application are hosted
in the same location. Without that, you need to hard-code (or user configure) a
socket endpoint address.
23.2.3 Handling the response
Sockets are bidirectional in nature. After you’ve requested the connection, you need
to handle the response. Listing 23.10 shows how to handle the incoming response on
the client.
public void socketArgs_Completed(object sender, 
  SocketAsyncEventArgs receivedArgs)
{
  switch (receivedArgs.LastOperation)
  {
Listing 23.9
Opening the socket connection on the client
Listing 23.10
Handling the socket response
Create socket
Connect

592
CHAPTER 23
Duplex, sockets, and local connections
    case SocketAsyncOperation.Connect:                 
      if (receivedArgs.SocketError == SocketError.Success)
      {
        byte[] response = new byte[1024];
        receivedArgs.SetBuffer(response, 0, response.Length);
        Socket socket = (Socket)receivedArgs.UserToken;
        socket.ReceiveAsync(receivedArgs);
      }
      else
        throw new SocketException((int)receivedArgs.SocketError);
      break;
    case SocketAsyncOperation.Receive: 
      ReceiveMessageOverSocket(receivedArgs);         
      break;
  }
}
The receive operation uses the ReceiveMessageOverSocket method. This method will
be shown in the next listing.
 Listing 23.10 shows two types of operations: connect and receive. You can deter-
mine the type of response by evaluating the value of the LastOperation property of
SocketAsyncEventArgs, as shown in table 23.1.
Now you need to set up the connection to receive data.
public void ReceiveMessageOverSocket(SocketAsyncEventArgs receivedArgs)
{
  string message = Encoding.UTF8.GetString(
                             receivedArgs.Buffer, 
                             receivedArgs.Offset,
                             receivedArgs.BytesTransferred);
  UIThread.Post(UpdateUIControls, message);
  Socket socket = (Socket)receivedArgs.UserToken;
  socket.ReceiveAsync(receivedArgs);
}
When the message comes in, it needs to be converted into the correct format (a
string, in this case); it can then be deserialized using any of the methods described in
chapter 22, depending on the format of the incoming data.
Table 23.1
SocketAsyncEventArgs LastOperation values
Value
Description
None
Connection not yet established
Connect
Connection established
Receive
Packets received
Send
Packets sent
Listing 23.11
Receiving a socket message
Connect 
operation
Receive 
operation

593
Multicast sockets
 In additional to the traditional point-to-point connection offered by the Socket
class, Silverlight supports multicast sockets where there may be many broadcasting
servers or a single broadcasting server, sending to multiple clients. 
23.3
Multicast sockets
The System.Net.Sockets namespace includes another type of socket implementa-
tion: UDP multicast sockets. IP multicast is a component of the core IP protocols, sup-
porting one-to-many communication over IP, most often using UDP. Multicast is an
efficient way for forwarding the IP datagrams to many receivers, enabling the service
to scale out to more connected clients.
IP multicast has a dependency on the routers and other equipment in use between
the service and the connected clients. All of that equipment must support IP multicast
in order for the service to function. Luckily, most modern hardware and firmware
implementations support IP multicast.
 A common scenario for IP multicast is the virtual classroom. In those cases, you
may have hundreds or even thousands of clients connected, watching a single stream-
ing video and receiving updates from virtual whiteboards, teacher notes, and public
discussion streams.
 Silverlight supports two types of multicast protocols, described in table 23.2.
23.3.1 Any-Source Multicast/Internet Standard Multicast
The Any-Source Multicast (ASM) approach enables a single client to receive traffic
from any source in a single multicast group. An example of this might be a virtual
meeting with multiple broadcasters or an event with several cameras and commentary,
all set up as individual servers in the same group.
 When Silverlight first attempts to join a multicast group, it sends out an
announcement message in the form of a UDP packet to port 9430. In the any-source
model, this goes to the group, and any responder in the group can send the okay
back to port 9430.
 Listing 23.12 shows the basics of connecting to a multicast group in preparation
for receiving data. You’ll need to use an actual working group IP address, not the one
in this listing.
Table 23.2
Multicast support in Silverlight
Client
Protocol and description
UdpAnySourceMulticastClient 
Internet Standard Multicast (ISM) or Any-Source 
Multicast (ASM)
This client can receive multicast traffic from any 
source in a multicast group.
UdpSingleSourceMulticastClient 
Source-Specific Multicast (SSM)
This client can receive multicast traffic from a 
single source.

594
CHAPTER 23
Duplex, sockets, and local connections
private void OpenMulticastConnection()
{
  IPAddress groupAddress = IPAddress.Parse("224.156.5.5"); 
  int localPort = 1212;
  var client = new UdpAnySourceMulticastClient(
                                 groupAddress, localPort);
  client.BeginJoinGroup(OnBeginJoinGroup, client);       
}
private void OnBeginJoinGroup(IAsyncResult asyncResult)
{
  UdpAnySourceMulticastClient client =
    (UdpAnySourceMulticastClient)asyncResult.AsyncState;
  client.EndJoinGroup(asyncResult);
  ...
}
In addition to the any-source approach, you can designate that you want to listen only
to a single server using the Source-Specific Multicast (SSM) model.
23.3.2 Source-Specific Multicast
The SSM approach is more common than the any-source model. Of course, as of this
writing, neither is particularly common. The source-specific model has been used for
broadcasting video and even software images on large campuses and in some organi-
zations. The benefit is the massive savings in bandwidth as compared to more tradi-
tional means.
 When Silverlight first attempts to join a multicast group, it sends out an announce-
ment message in the form of a UDP packet to port 9430. Unlike the any-source model,
though, this packet goes directly to the single source IP.
 Opening the connection and joining the multicast group is similar to the any-
source approach, but the constructor takes in the IP address of the single source in
addition to the group information.
 Listing 23.13 shows how to connect to a multicast group and target a single-source
address as the address to be listened to.
private void OpenMulticastConnection()
{
  IPAddress sourceAddress = IPAddress.Parse("192.168.1.1");
  IPAddress groupAddress = IPAddress.Parse("224.156.5.5");
  int localPort = 1212;
  var client = new UdpSingleSourceMulticastClient(     
                           sourceAddress, 
                           groupAddress, 
                           localPort);
  client.BeginJoinGroup(OnBeginJoinGroup, client);
}
private void OnBeginJoinGroup(IAsyncResult asyncResult)
{
Listing 23.12
Opening a connection using ASM
Listing 23.13
Opening a connection to a single source
Set group 
address
Join multicast 
group
Join SSM group

595
Connecting to other local Silverlight applications
  UdpAnySourceMulticastClient client =
    (UdpAnySourceMulticastClient)asyncResult.AsyncState;
  client.EndJoinGroup(asyncResult);
  ...
}
The differences between listing 23.12 and listing 23.13 are minimal, coming down to
the inclusion of the additional IP address in the constructor.
NOTE
MSDN Code Gallery includes examples of both a multicast server and a
multicast client. The full examples are impractical to place in a book due to
their length. You can download the SilverChat examples from http://
code.msdn.microsoft.com/silverlightsdk.
Multicast is just starting to take off in the media, education, and large business sectors.
If you’re looking at streaming media to a large number of clients, streaming stock-
ticker quotes, or building your own webcasting software, you’ll definitely want to learn
more about multicast socket development. Fortunately, Silverlight will be able to sup-
port you as a good client in those scenarios.
 Sockets in general are a great choice when you want to have complete control over
the messaging—for example, when you’re creating a game and you want to have the
tightest possible real-time messaging protocol. WCF duplex is a good choice when
you’re willing to trade wire-level control for the ability to use all the great features,
such as automatic serialization, that WCF provides. Different problems call for differ-
ent solutions, sometimes within the same physical application. It’s nice to see Silver-
light offer such a spectrum of capabilities you can use when connecting applications
to the outside world.
 Sockets and WCF duplex are great for bidirectional communication between a
Silverlight client and a server, or via two machines using the server as a proxy. For
local scenarios, though, Silverlight has another mechanism that you can use to con-
nect two Silverlight applications running on the same client machine. 
23.4
Connecting to other local Silverlight applications
The local connection API in System.Windows.Messaging allows communication
between two or more instances of the Silverlight plug-in, whether they’re on the same
page in the same browser instance, on different pages in different browsers, or even
some in browsers and others running out-of-browser.
 Conceptually similar to sockets, the implementation is much simpler. If you ever
did any Dynamic Data Exchange (DDE) programming in Windows, this will feel some-
what familiar with its string-based point-to-point messaging format. No, unlike DDE,
you don’t need to hack up a TextBox to provide an hWnd to receive the messages.3
 In this example, you’ll set up a pair of applications, the second of which echoes the
text entered into a TextBox on the first. You’ll need to designate one application or
piece of code as a sender and another as a receiver. You’ll start with the receiver.
3  I still have PTSD from my adventures with DDE with Visual Basic 3 on Windows 3.1.

596
CHAPTER 23
Duplex, sockets, and local connections
23.4.1 Creating the receiver
Each receiver has a unique name. Think of it as the address of an endpoint. You
define the name when creating the LocalMessageReceiver object  as shown:
private LocalMessageReceiver _receiver = 
        new LocalMessageReceiver("InAction");
The overload for the constructor enables you to indicate whether you want to listen
only to specific domains or to all domains (what’s called the namescope, not to be con-
fused with XAML namescope), and to provide a list of acceptable domains. Addition-
ally, it provides the same ability to supply a receiver name. 
 In this case, the receiver is named InAction. Remember, this name needs to be
unique within the namescope. If it isn’t, you’ll get a ListenFailedException when
executing the next step, listening for senders. Listing 23.14 shows how to listen for
new messages.
public void Listen()
{
  _receiver.MessageReceived += _receiver_MessageReceived; 
  _receiver.Listen();
}
void _receiver_MessageReceived(object sender, 
                               MessageReceivedEventArgs e)
{
  MessageText.Text = e.Message;
}
Like with the other communications APIs, you first wire up an event handler, call a
method, and wait for a response within the handler. As is often the case, the event args
class specific to this process—MessageReceivedEventArgs—includes a number of
additional properties, shown in table 23.3. 
Listing 23.14
Listening for senders
Table 23.3
MessageReceivedEventArgs properties
Property
Description
Message 
The message from the sender.
NameScope 
A value of either Domain or Global. Domain indicates the receiver is configured 
only to listen to applications from the same domain. Global indicates the receiver 
may listen to all Silverlight applications. This property is also available directly on 
the LocalMessageReceiver object. The default is Domain, but it may be set in 
the constructor.
ReceiverName 
The name of the LocalMessageReceiver tied to this event.
Response 
A response provided by the receiver. This makes it easy to immediately respond to a 
message, perhaps with something as simple as an ACK (acknowledge).
SenderDomain 
The domain of the Silverlight application that sent this message.
Message received
handler

597
Connecting to other local Silverlight applications
After you’ve created the listener, the next step is to create something to send the mes-
sages: the sender.
23.4.2 Creating the sender
The sender is extremely simple to create. All the sender code needs to do is create a
LocalMessageSender object specifying a particular listener and optionally the lis-
tener’s domain, and then start sending messages.
private LocalMessageSender _sender = 
          new LocalMessageSender("InAction");
public MainPage()
{
    ...
  MessageText.TextChanged += 
          new TextChangedEventHandler(OnTextChanged);
}
void OnTextChanged(object sender, TextChangedEventArgs e)
{
  _sender.SendAsync(MessageText.Text);
}
In listing 23.15, whenever the text changes in the TextBox, you send the entire Text-
Box contents across the pipe and to the listener. 
23.4.3 Putting it all together
The next step is to place both Silverlight controls into the same HTML page, using sep-
arate object tags. When run, the application will look something like figure 23.5.
Listing 23.15
Creating a sender
Figure 23.5
Two Silverlight control 
instances on the same page, 
communicating with each other

598
CHAPTER 23
Duplex, sockets, and local connections
Of course, if you want, you can host the two instances in separate browser windows
and still allow them to communicate, as shown in figure 23.6. Create a page for the
sender and one for the receiver. The two browsers don’t need to be the same brand, as
long as they’re both supported by Silverlight.
 You can also have one or both of the applications running out of the browser, as
shown in figure 23.7.
 The new local connection API provides a great way to let two or more Silverlight
applications communicate. Unlike the old methods of using the DOM to send applica-
tion messages, this approach doesn’t rely on the applications being in the same DOM
tree or even in the same browser instance. This new API enables scenarios such as
Figure 23.6
Sender and receiver in separate browser windows, communicating across processes
Figure 23.7
Sender in a browser window, and receiver running out-of-browser

599
Summary
disconnected but coordinating web parts on a SharePoint page, composite applica-
tions, and many more. 
23.5
Summary
Silverlight has great support for networking operations. With the exception of some
of the WS-* protocols used in larger enterprises and SOA-based applications, Silver-
light supports most anything the typical application developer could need.
 In this chapter, you looked at four lesser known networking types: WCF polling
duplex, sockets, multicast sockets, and the local connection. You could argue that
“local connection” isn’t IP networking, but it’s close enough in how it’s used to fall
under the networking header.
 When you want to have the server update the client without having to open up spe-
cial ports, WCF polling duplex is the technology to consider. It runs over HTTP and
uses familiar WCF concepts and tools. It’s using polling from the client, though, so it
can become a performance issue in very large deployments. As always, prototype and
test before you commit to the approach.
 When polling duplex isn’t lean enough and you’re willing to open a few firewall
ports, you can’t beat sockets for closer-to-the-metal network programming. If you’re
writing a game and need to update player movements, sockets are the way to go.
Socket coding, especially on the server, is considerably more complex than WCF poll-
ing duplex, but it gives you the flexibility to implement just about any custom protocol
you might need, within the port restrictions imposed by Silverlight.
 For media and online learning scenarios, multicast sockets are another approach
to consider. Of all the networking types discussed so far, this is the least used. But for
the people who need it, they typically know in advance that they’ll want it.
 Finally, for multiple Silverlight clients that must communicate on the same
machine, hopefully not to pool resources and become self-aware, there’s built-in sup-
port for local connections. This is especially useful in portal scenarios or when you
have a few out-of-browser applications that must be aware of each other.
 This chapter wraps up our coverage of networking. Next, we’ll look at the support
for graphics and effects on the UI side of Silverlight.

 
 
 
 
 

Part 4
2D and 3D graphics
If I had to pick a single place where Silverlight really excels, I’d say graphics.
In fact, the very first version of Silverlight (Silverlight 1.0) was a simple platform
for display of graphics and playback of media. It did almost nothing else. Silver-
light has obviously come a long way since those days in 2006 and 2007, but its
core strengths are as strong as ever.
 In the next four chapters, you’ll explore the graphics capabilities of Silver-
light, starting with vector graphics and GPU effects/shaders. You’ll learn how to
define and manipulate shapes and geometries, as well as how to create things
like blurs and drop shadows. From there, it’s natural to turn your eye to bitmap
images, both the kind you download from a URL and those you create program-
matically.
 Combining concepts from both vector images and bitmaps with more than a
little GPU sugar, you have the XNA-compatible 3D API. You’ll spend some time
exploring how to use this API in Silverlight both to enhance your applications
and even as a central aspect of your entire solution. At the end of the two 3D
chapters, you’ll have implemented a simple 3D keyframe animation system. Oh,
and if you’re a fan of the Amiga or old 8-bit (and 16-bit) computers, you’ll love
what’s in store for you.
 Even if your interest is solely in developing business applications, there are
features and concepts you can use in each of these chapters, from simple screen
design, to 3D manipulation of an onscreen car model, to data visualization. This
is an exciting and rich area to explore. Enjoy!


603
Graphics and effects
In previous chapters, you’ve seen interesting controls that include text, rectangles,
and even more complex shapes. Even the lowly button, for example, has text, a
couple of rectangles, and a gradient background. Controls such as the pop-up
ChildWindow control have drop shadows to enhance their appearance and help
them stand out in the eyes of the user. Those buttons and other controls use vector
graphics, brushes, and effects.
 Graphics within Silverlight are vector-based; they’re mathematically based
objects. They’re ideal for internet distribution because vector-based graphics can
be condensed to a smaller file size than their raster counterparts for images larger
than a thumbnail.
 Vector-based graphics are more than eye candy—they’re an extension to accessi-
bility. In traditional application environments, users with diminished eyesight
generally have to squint to absorb visual content such as text and icons. Through
This chapter covers
■
Creating basic shapes and geometries
■
Painting with brushes
■
Working with effects
■
Creating pixel shader effects

604
CHAPTER 24
Graphics and effects
scalability, these same users can fully enjoy your application with ease. Vector graphics
retain full fidelity when scaled up, something you can’t say about bitmap images. Vec-
tors actually improve in quality when scaled up.
 Silverlight also includes rich support for effects to help make your elements and
graphics stand out. The built-in drop shadow and blur effects have endless uses
throughout the application. When you want to do something more than a shadow or a
blur, there’s also the ability to create your own pixel shader effects, just as you can in
WPF and DirectX/XNA.
 In this chapter, you’ll see the expanse of graphical capabilities within Silverlight.
I’ll start by discussing the most primitive shapes such as lines, rectangles, and ellipses.
After exploring the concept of geometries, I’ll lead you down a new path and show
you how to paint shapes and alter the way in which they’re rendered. From there,
you’ll add a little effect to your elements before venturing into the sometimes arcane
world of custom pixel shaders.
24.1
Shapes
Shapes are probably the most regularly used elements for creating an illustration
because a Shape is the common basis for the Line, Rectangle, and other Shape ele-
ments, which you’ll see shortly. Each Shape is painted by two fundamental Brush ele-
ments. (Brushes are discussed later.) The first Brush, called Stroke, defines the
outline of a Shape. The second Brush, called Fill, describes how everything inside
the boundary of the Shape should be painted. It’s possible to create a Shape without
specifying the Stroke and Fill properties, but if you don’t specify the Stroke or Fill,
you’ll basically paint an invisible shape.
 This section builds on the concept of an abstract Shape to create concrete visual
elements. A lot of these visual elements will resemble shapes you learned on Sesame
Street, and some of these shapes will be a bit more complex. Table 24.1 provides a list
of the shapes you’ll explore.
The following sections describe each Shape listed in the table in greater detail. The
shapes are described in order of relative complexity. The Path element is part of a
Table 24.1
The Shape objects available within Silverlight
Element
Description
Line
A thin, continuous mark that connects two points.
Ellipse 
In layman’s terms, a circle that can be stretched vertically or horizontally.
Path 
A collection of connected curves and lines.
Polygon 
A series of connected lines that make a closed shape.
Polyline 
A series of connected straight lines.
Rectangle 
A four-sided plane with four corners.

605
Shapes
more general category that’ll be covered later in this chapter. First, you’ll learn about
the most rudimentary shape, the Line.
24.1.1 Lines
A Line is, obviously, a continuous line that connects two endpoints.1 Listing 24.1
shows a basic line between two points and the XAML used to define it.
Result:
XAML:
<Canvas x:Name="myCanvas" Height="20" Width="50">
  <Line Stroke="Black" X1="10" Y1="10" X2="30" Y2="30" />       
</Canvas>
Four double-precision floating-point properties (X1, Y1, X2, Y2) specify the x and y
coordinate pairs that define the beginning and ending points of the Line. Without
these properties, your Line will be little more than a figment of your imagination.
 Interestingly, these coordinates don’t represent an absolute position. They specify
a relative position within the coordinate space of the containing layout panel. Note that,
although Silverlight won’t automatically define the endpoints of a Line, the coordi-
nate space of the containing layout panel may be automatically created. Regardless,
the values of the coordinates represent pixel values, whether absolute or relative posi-
tioning is used.
 The Canvas used in listing 24.1 has a specific area. But, as described in chapter 8,
some layout panels provide a more dynamic layout environment. For instance, if this
Line were the second element defined within a StackPanel, it could end up in a
potentially undesirable location because the coordinates within a Line element spec-
ify a relative position.
24.1.2 Rectangle
A Rectangle does exactly what its name implies—it defines a rectangle. The Rectan-
gle in Silverlight provides one interesting tidbit that I’ll discuss after the listing, which
shows the basic syntax of a Rectangle.
Result:
1  I know, technically that’s a line segment, but in computer graphics, it’s a line.
Listing 24.1
A basic Line in black
Listing 24.2
A basic Rectangle in black with no fill

606
CHAPTER 24
Graphics and effects
XAML:
<Rectangle Stroke="Black" Width="104" Height="64" 
  Canvas.Left="8"  Canvas.Top="8"/>
Listing 24.2 shows an archetypal Rectangle. The key properties involved in the defini-
tion of the element are Width and Height. Collectively, these double properties assist
in creating the boundary of the Rectangle. You can determine the area of the Shape
by multiplying these two property values.
 The Rectangle element exposes two properties, RadiusX and RadiusY, which
enable you to easily round off the corners of any Rectangle. The XAML in listing 24.3
shows how simple it is to use these two properties.
Result:
XAML:
<Rectangle Stroke="Black" Width="104" Height="64" 
  Canvas.Left="8" Canvas.Top="8" RadiusX="10" RadiusY="10"/>
The RadiusX and RadiusY double-precision floating-point properties allow you to set
the radius of the ellipse used to round off the corners of the Rectangle. (You’ll see
the Ellipse element shortly.) By lopsidedly setting the RadiusX and RadiusY proper-
ties, you can give a Rectangle a bulging look like a cylinder seen at a slight angle, as
shown in listing 24.4.
Result:
XAML:
<Rectangle Stroke="Black" Width="104" Height="64" 
  Canvas.Left="8"  Canvas.Top="8" RadiusX="15" RadiusY="50"/>
The bulging Rectangle is a fun little option. But occasionally, you may need a fully
rounded shape. This is where the Ellipse comes into play.
24.1.3 Ellipse
An Ellipse defines a basic circular shape. Listing 24.5 shows a basic Ellipse and the
XAML used to define it.
Listing 24.3
A Rectangle with rounded corners
Listing 24.4
A bulging Rectangle

607
Shapes
Result:
XAML:
<Ellipse Stroke="Black" Width="104" Height="64" 
  Canvas.Left="8" Canvas.Top="8"/>
The Ellipse doesn’t provide any properties that alone distinguish it from the
Rectangle. The difference lies in how the two Shape elements are rendered. It’s
important to recognize that Silverlight provides this type of Shape for your graphical
needs—if for nothing else than to know that you can draw a circle. Now, let’s move on
to something a little more interesting: the Polyline.
24.1.4 Polyline
What if you need to create an application that represents an EKG (or ECG) monitor?
How do you go about displaying the electrical impulses projected by a heart? Or per-
haps you need to create a line chart that represents sales or financial trends. These
types of scenarios can involve large amounts of data that may be best illustrated
through intricate line-art drawings.
 You could use several Line elements, but doing so could prove to be cumbersome.
The Polyline provides a nice alternative that allows you to create a series of con-
nected line pieces using a single element. Listing 24.6 shows a Polyline in action.
Result:
XAML:
<Polyline Stroke="Black"
  Points="10,50 20,40 23,44 25,49 40,12 46,50 51,42 55,50" />
The Polyline uses a PointCollection to hold the points that make up the lines. In
XAML, this is typically represented using a space-delimited list of coordinate pairs.
Through the magic of type conversion, this Points “minilanguage” is converted for
you automatically.
 Although each coordinate pair in this example contains integer values, each value
represents a Point. A Point is represented in the form of [X-Coordinate],[Y-Coordinate].
Collectively, all these Point elements are stored in the Points property. In being con-
sistent with the Line, each Point within the list is relative to the containing layout panel.
Listing 24.5
The syntax and look of a basic Ellipse
Listing 24.6
A Polyline

608
CHAPTER 24
Graphics and effects
24.1.5 Polygon
The Polygon goes one step beyond the Polyline by ensuring that the Shape is always
closed. A Polyline creates an open Shape, whereas a Polygon always draws a closed
Shape. Listing 24.7 shows a basic trapezoid created with a Polygon.
Result:
XAML:
<Polygon Stroke="Black" Points="10,40 20,10 60,10 70,40 10,40" />
Like the sibling Polyline, the Polygon also utilizes the Points property. This prop-
erty works in a manner similar to the Points property of the Polyline; but regardless
of your selected coordinates, the Polygon always draws a closed shape.
 Listing 24.8 shows a Polyline and a Polygon using the same coordinates to illus-
trate how Silverlight renders them.
Result:
XAML:
<Polyline 
  Stroke="Black"   
  Fill="White" 
  Points="10,40 20,10 60,10 70,40"
/>
<Polygon 
  Stroke="Black" 
  Fill="White" 
  Points="10,40 20,10 60,10 70,40" 
/>
The available shapes provide a lot of flexibility to give your users valuable graphical
experiences. Occasionally, your requirements may exhaust the abilities of the various
shapes. A Geometry is a much more versatile option that can address the inadequacies
of a Shape.  
Listing 24.7
A Polygon
Listing 24.8
An open shape (Polyline) compared to a closed shape (Polygon)

609
Geometry
24.2
Geometry
At first, a Geometry seems similar to a Shape because they both describe 2D shapes.
Unlike Shape elements, Geometry objects aren’t UIElement entities. UIElement objects
have an intrinsic ability to render themselves and expose graphical properties, such as
Opacity, that Geometry objects don’t have. Why, then, would you consider using a
Geometry? Well, a Geometry allows you to:
■
Define a geometric shape. For example, imagine creating a user-based rating
system. In this scenario, you may want to use a set of five-pointed stars to rate an
item. Although a star isn’t a predefined shape, you could create this element
using a Geometry.
■
Define a region for clipping. Clipping is used to limit the visible area of another
object.
■
Define a region that can be used for hit-testing.
These compelling reasons make examining the Geometry object a worthwhile
endeavor. A Geometry is an abstract concept. In fact, you can’t deliberately create just
a Geometry. Instead, you must rely on the geometrical concepts spread across three
basic categories: simple, path, and composite geometries.
24.2.1 Simple geometries
A simple geometry reflects some of the primitive geometrical shapes that you’ve already
seen. 
Simple 
geometries—such 
as 
LineGeometry, 
RectangleGeometry, 
and
EllipseGeometry—are provided to help you illustrate lines, rectangles, and circles.
 A LineGeometry illustrates the geometry of a basic line. Listing 24.9 shows how to
draw a line using a LineGeometry element. The example also shows what the same
markup would look like if you used the basic Line Shape described earlier.
Result:
Path XAML:
<Path Stroke="Black" StrokeThickness="1" >
  <Path.Data>
    <LineGeometry StartPoint="8,8" EndPoint="72,72" />
  </Path.Data>
</Path>
Line XAML:
<Line X1="8" Y1="8" X2="72" Y2="72" 
  StrokeThickness="1" Stroke="Black" />
Listing 24.9
Comparison between Line and LineGeometry

610
CHAPTER 24
Graphics and effects
From this example, you can see that using the Line Shape XAML is much more com-
pact. But you can use also Geometry objects for clipping and hit-testing.
 In addition to the LineGeometry, a RectangleGeometry is provided. The
RectangleGeometry defines the geometry of a rectangle. Listing 24.10 shows how to
create a rectangle using a RectangleGeometry and also provides the corresponding
definition with the Rectangle Shape.
Result:
Path XAML:
<Path Fill="Navy" Stroke="Black" StrokeThickness="1">
  <Path.Data>
    <RectangleGeometry Rect="8,8,64,64" />
  </Path.Data>
</Path>
Rectangle XAML:
<Rectangle Stroke="Black" StrokeThickness="1" Height="64"  
  Width="64" Canvas.Top="8" Canvas.Left="8" Fill="Navy">
</Rectangle>
Like the Rectangle Shape, the RectangleGeometry also supports corner-rounding via
the RadiusX and RadiusY properties. Finally, let’s look at the EllipseGeometry for the
sake of completeness.
Result:
Path XAML:
<Path Fill="Navy" Stroke="Black" StrokeThickness="1">
  <Path.Data>
    <EllipseGeometry Center="40,40" RadiusX="36" RadiusY="36" />
  </Path.Data>
</Path>
Ellipse XAML:
<Ellipse Canvas.Left="4" Canvas.Top="4" Height="72" Width="72" 
  Fill="Navy" StrokeThickness="1" Stroke="Black" />
The ellipse takes a center point as well as X (horizontal) and Y (vertical) radius values
as its defining values. If X and Y radii are identical, you get a circle.
Listing 24.10
A RectangleGeometry compared to a Rectangle
Listing 24.11
An EllipseGeometry compared to an Ellipse

611
Geometry
 As useful as lines, rectangles, and circles are, occasionally you need to create a
more dynamic shape. For more complex shapes, Silverlight supports the use of the
PathGeometry. 
24.2.2 Path geometries
A PathGeometry enables you to construct complex, detailed illustrations composed of
a variety of arcs, curves, and lines. These intricate depictions consist of a collection of
PathFigure objects, with each PathFigure representing a small section of the overall
illustration. In turn, each PathFigure is made up of a series of PathSegment objects.
Each PathSegment object describes a small piece of the overall figure. Let’s review a
basic example that shows a variety of meaningless squiggly lines for the sake of
illustration.
Result:
XAML:
<Canvas
  Width="100" Height="100" Background="Gray">
  <Path Stroke="Red" StrokeThickness="2">
    <Path.Data>
      <PathGeometry>
        <PathGeometry.Figures>
          <PathFigure StartPoint="5,5">
            <PathFigure.Segments>
              <ArcSegment Size="10,10" RotationAngle="30"
                          Point="20,10" IsLargeArc="False"
                          SweepDirection="Clockwise" />
              <BezierSegment Point1="40,0" Point2="60,60" Point3="75,90"/>
              <LineSegment Point="80,15" />
              <PolyLineSegment Points="50,90 3,7" />
              <QuadraticBezierSegment Point1="90,90" Point2="70,60"/>
            </PathFigure.Segments>
          </PathFigure>
        </PathGeometry.Figures>
      </PathGeometry>
    </Path.Data>
  </Path>
</Canvas>
The example in listing 24.12 uses five different segment types to create random squig-
gles. Each individual segment sequentially connects to the previous one, much like
cars in a freight train. Table 24.2 shows all the available segment types.
Listing 24.12
A PathGeometry

612
CHAPTER 24
Graphics and effects
From the options presented, it’s clear that you have tons of flexibility when it comes to
creating a geometrical shape. Sometimes you may need to explicitly use other geome-
try objects. In these scenarios, you can use a composite geometry.
24.2.3 Composite geometries
You may need to create a complex shape that consists of disconnected entities. Or
maybe you need to use Geometry entities, and you want to combine their area. The
GeometryGroup adequately addresses these scenarios. A GeometryGroup is a collection
of Geometry entities. Listing 24.13 illustrates how to orchestrate a composite geometry.
Result:
XAML:
<Path Stroke="Navy" StrokeThickness="8" Fill="Navy">
  <Path.Data>
    <GeometryGroup FillRule="Evenodd">
      <EllipseGeometry Center="20,40" RadiusX="15" RadiusY="15" />
      <LineGeometry StartPoint="20,40" EndPoint="70,40" />
      <LineGeometry StartPoint="66,38" EndPoint="66,55" />
      <LineGeometry StartPoint="55,38" EndPoint="55,55" />
      <EllipseGeometry Center="14,40" RadiusX="8" RadiusY="8" />
    </GeometryGroup>
  </Path.Data>
</Path>
The example illustrates how to create a key using a complex geometry via the
GeometryGroup. It also introduces a property called FillRule, which determines how
the different areas should be filled. There are two acceptable values: EvenOdd and
Nonzero.
Table 24.2
Available segment types
Segment type
Usage
LineSegment 
A straight line connecting two points
PolyLineSegment
A series of lines
ArcSegment
An elliptical arch between two points
BezierSegment
A cubic Bézier curve between two points
PolyBezierSegment
A series of cubic Bézier curves
QuadraticBezierSegment 
A quadratic Bézier curve
PolyQuadraticBezierSegment 
A series of quadratic Bézier curves
Listing 24.13
A composite geometry to make a key

613
Brushes
EvenOdd, the default used in the previous example, is pretty simple. Imagine a ray
that begins at a point (the point you want to calculate the color for) somewhere
within the defined or calculated bounds of the Path, and heads toward the edge of the
same area (including parts that may be clipped off due to render-time clipping),
counting each line that it intersects along the way. If the count is odd, the point is
inside the shape. If the count is even, the point is outside the shape. This rule deter-
mines how to fill the area. There are optimizations in the rendering code, but in the-
ory, this would be done for each pixel inside the bounds.
 Try it yourself. Put your finger on a point outside the shape and drag it in a straight
line toward a corner or edge. Count how many times you cross the lines that make up
the shape. Now do the same thing from a point inside the shape. 
 Alternatively, if the previous example had used the Nonzero option, the hole to
place the key on a key ring would’ve been filled because Nonzero counts the number
of lines it intersects along the way. But it also considers the direction of the line. Based
on the direction, the count is either incremented or decremented. At the end of
counting, if the total is zero, it’s assumed that the point is inside the overall shape. 
 To take control of how an element is filled, you can use one of Silverlight’s many
brushes. 
24.3
Brushes
Up to this point, you’ve seen how to define the boundaries of Shape elements. It’s
equally important to understand how to fill the area within a Shape. To paint the inte-
rior of a Shape or a variety of other visual elements, you must choose from myriad
Brush options, including SolidColorBrush, LinearGradientBrush, RadialGradient-
Brush, ImageBrush, and VideoBrush.
24.3.1 SolidColorBrush
The SolidColorBrush is without a doubt the most rudimentary of the Brush options.
A SolidColorBrush uses a single, solid color to paint an area. Here’s a basic circle
using a SolidColorBrush.
Result:
XAML:
<Ellipse Stroke="Black" StrokeThickness="3"
  Width="64" Height="64" Canvas.Left="8" Canvas.Top="8">
  <Ellipse.Fill>
    <SolidColorBrush Color="Navy" />
  </Ellipse.Fill>
</Ellipse>
Listing 24.14
A basic SolidColorBrush with the color navy blue

614
CHAPTER 24
Graphics and effects
This SolidColorBrush uses a System.Windows.Media.Color property named Color
to specify which color fills the area. Properties of this type can accept values repre-
sented in one of the following ways:
■
A predefined named color, such as Navy, that matches one of the names supported in
Internet Explorer, .NET Framework, and Windows Forms—Importantly, the Color
class in Silverlight belongs to the System.Windows.Media namespace. In Win-
dows Forms, it belongs to the System.Drawing namespace.
■
A Red, Green, Blue (RGB) hexadecimal string in the format of #RxGyBz—For instance,
in listing 24.14 you could replace Navy with its hexadecimal representation,
#000080.
■
An RGB hexadecimal string with an alpha channel in the format of #aRGB—This for-
mat gives you a greater range than the typical RGB hexadecimal string because
it has built-in support for the opacity channel. For example, you could convert
Navy to #AA000080 to give the color a washed-out appearance.
These color options give you a lot of flexibility when you’re defining a SolidColor-
Brush. If you’re using XAML, it’s much more convenient to explicitly set the Fill
property of a Shape, or any property that’s a Brush, and let Silverlight automatically
convert the value to a SolidColorBrush for you. Because of this, you could condense
the previous markup to this:
<Ellipse Stroke="Black" StrokeThickness="3" Fill="Navy"
  Width="64" Height="64" Canvas.Left="8" Canvas.Top="8">
</Ellipse>
Although this explicit approach is convenient, it’s still important to remember the
SolidColorBrush, because if you’re trying to use solid colors through managed code,
you’ll need to use the System.Windows.Media.SolidColorBrush class. 
 Occasionally, you may want something richer and more vibrant than a solid color.
Thankfully, Silverlight provides several alternatives such as the LinearGradientBrush.
24.3.2 LinearGradientBrush
The LinearGradientBrush paints an area with a gradual interpolation between colors
along a theoretical line. This Brush can shift between one or more colors through the
use of a series of predefined locations represented as GradientStopelements. Each
GradientStop element specifies where one color should shift to another. Listing 24.15
shows a basic LinearGradientBrush that uses two GradientStop elements to shift
from one Color to another.
Result:
Listing 24.15
A LinearGradientBrush rendered on a diagonal

615
Brushes
XAML:
<Ellipse Stroke="Black" StrokeThickness="3"
  Width="64" Height="64" Canvas.Left="8" Canvas.Top="8">
  <Ellipse.Fill>
    <LinearGradientBrush>
      <GradientStop Color="Navy" Offset="0" />
      <GradientStop Color="White" Offset="1" />
    </LinearGradientBrush>
  </Ellipse.Fill>
</Ellipse>
This Ellipse illustrates how the LinearGradientBrush can be used to shift from Navy
in the upper-left corner to White in the lower-right corner. Each GradientStop in the
LinearGradientBrush specifies an Offset property that determines where the color,
specified in the Color property, should be reached within the Brush coordinate space.
But how does the Offset property know that 0 means the upper-left corner and 1
means the lower-right corner?
 The Offset property relies on two other properties,
which are defined within the LinearGradientBrush defi-
nition itself. These two System.Windows.Point-based
properties are StartPoint and EndPoint and ultimately
determine the beginning and ending of a gradient. Col-
lectively, these two properties define a rectangular bound-
ary in which the Offset property works. This coordinate
space can best be visualized as shown in figure 24.1, where
each corner displays a Point value.
 By default, the StartPoint property is set to represent the upper-left corner (0, 0)
of this coordinate space. Conversely, the EndPoint defaults to represent the lower-
right corner (1, 1) of the coordinate space. You can manipulate both property values
to take full control of the range in which the gradient occurs, as well as the direction. 
 Imagine taking the previous example and making the gradient run horizontally
instead of diagonally. This can be accomplished by altering the StartPoint and End-
Point property values, as shown in listing 24.16.
Result:
XAML:
<Ellipse Stroke="Black" StrokeThickness="3"
  Width="64" Height="64" Canvas.Left="8" Canvas.Top="8">
  <Ellipse.Fill>
    <LinearGradientBrush StartPoint="0,0" EndPoint="1,0">
      <GradientStop Color="Navy" Offset="0" />
Listing 24.16
A LinearGradientBrush rendered horizontally
Figure 24.1
The Brush
coordinate space

616
CHAPTER 24
Graphics and effects
      <GradientStop Color="White" Offset="1" />
    </LinearGradientBrush>
  </Ellipse.Fill>
</Ellipse>
Although you could’ve rotated the imaginary gradient line by altering the Offset
property values of each of the GradientStop elements, the StartPoint and EndPoint
properties give you control over the entire range of the gradient. This fact becomes
particularly important when you begin to consider using multiple color transitions.
 Both the LinearGradientBrush and the RadialGradientBrush, which you’ll see
shortly, allow you to define as many GradientStop elements as you want. The more
GradientStop elements that are added, the more important it is to understand the
relationship between the Offset property and the StartPoint and EndPoint proper-
ties. Listing 24.17 shows how to use multiple GradientStop elements by adjusting the
Offset property.
Result:
XAML:
<Rectangle StrokeThickness="0" Width="200" 
  Height="64" Canvas.Left="8" Canvas.Top="8">
  <Rectangle.Fill>
    <LinearGradientBrush StartPoint="0,0" EndPoint="1,0">
      <GradientStop Color="Yellow" Offset="0" />
      <GradientStop Color="Orange" Offset=".45" />
      <GradientStop Color="Blue" Offset=".55" />
      <GradientStop Color="Green" Offset="1" />
    </LinearGradientBrush>
  </Rectangle.Fill>
</Rectangle>
As the previous examples have shown, the LinearGradientBrush provides you with a
lot of opportunity to add richness to your applications. Occasionally, you may want to
add a sense of depth to your graphics. Without turning to 3D graphics, you can deliver
the illusion of depth by using a RadialGradientBrush. 
24.3.3 RadialGradientBrush
The RadialGradientBrush is similar to the LinearGradientBrush except that the
color transitions begin from an originating Point. As the Brush radiates from the cen-
ter, it gradually paints elliptical transitions until a GradientStop is encountered. This
process continues from one GradientStop  to the next until each one has been ren-
dered. Listing 24.18 illuminates a basic RadialGradientBrush.
Listing 24.17
A horizontal LinearGradientBrush with multiple transitions

617
Brushes
Result:
XAML:
<Ellipse Width="75" Height="75" Stroke="Black">
  <Ellipse.Fill>
    <RadialGradientBrush>
      <GradientStop Color="Black" Offset="0"/>
      <GradientStop Color="Black" Offset="1"/>
      <GradientStop Color="Gray" Offset="0.5"/>
    </RadialGradientBrush>
  </Ellipse.Fill>
</Ellipse>
The brush begins at the center of the Ellipse by default. This originating Point can
be customized in one of two ways. The first approach involves specifying a Point value
within the Center property. The Center Point represents the focal point of the outer-
most ellipse of the gradient. Alternatively, or in conjunction with the Center, you can
use the GradientOrigin property to specify the Point that defines where the radial
gradient emanates from.
 As a radial gradient is rendered, it grows from the GradientOrigin in a circular
fashion. Sometimes it’s necessary to use a more elliptical gradient instead of a pure
circular effect. To define an elliptical gradient, you need to utilize the RadiusX and
RadiusY properties, which are consistent with the properties of the same name from
the Ellipse element. Listing 24.19 compares several ellipses using different RadiusX
and RadiusY properties, which both default to 0.5.
Result:
XAML:
<Canvas Width="245" Height="75" Background="White">
  <Ellipse Width="75" Height="75" Stroke="Black">
    <Ellipse.Fill>
      <RadialGradientBrush>
        <GradientStop Color="Black" Offset="0"/>
        <GradientStop Color="Black" Offset="1"/>
        <GradientStop Color="Gray" Offset="0.5"/>
      </RadialGradientBrush>
    </Ellipse.Fill>
  </Ellipse>
  <Ellipse Width="75" Height="75" Canvas.Left="85"  
Listing 24.18
A RadialGradientBrush
Listing 24.19
Comparing uses of the RadiusX and RadiusY properties

618
CHAPTER 24
Graphics and effects
    Stroke="Black">
    <Ellipse.Fill>
      <RadialGradientBrush RadiusX=".25">
        <GradientStop Color="Black" Offset="0"/>
        <GradientStop Color="Black" Offset="1"/>
        <GradientStop Color="Gray" Offset="0.5"/>
      </RadialGradientBrush>
    </Ellipse.Fill>
  </Ellipse>
  <Ellipse Width="75" Height="75" Canvas.Left="170" 
    Stroke="Black">
    <Ellipse.Fill>
      <RadialGradientBrush RadiusY=".25">
        <GradientStop Color="Black" Offset="0"/>
        <GradientStop Color="Black" Offset="1"/>
        <GradientStop Color="Gray" Offset="0.5"/>
      </RadialGradientBrush>
    </Ellipse.Fill>
  </Ellipse>
</Canvas>
As the previous examples show, you can use a RadialGradientBrush to provide basic
linear and radial effects. Although these Brush elements are appropriate in certain sit-
uations, occasionally you need to deliver a richer, more textured effect. Textures are
often delivered via images, which can be painted on visual elements using an Image-
Brush.
24.3.4 ImageBrush
The ImageBrush allows you to fill an area with an image instead of a solid or shifting
color. The ImageBrush utilizes a picture specified within the ImageSource property to
paint a raster graphic. This Brush supports both JPEG and PNG formats to deliver a
textured effect to your visual elements. Listing 24.20 shows a basic ImageBrush using
an image named man.png.
Result:
XAML:
<Ellipse Width="60" Height="60" Stroke="Black">
  <Ellipse.Fill>
    <ImageBrush ImageSource="Assets/man.png" />
  </Ellipse.Fill>
</Ellipse>
As you can imagine, an ImageBrush can easily add a rich, vibrant touch to your paint-
ing surface. Sometimes, you may want your painting surface to be more dynamic and
Listing 24.20
An example of an ImageBrush

619
Brushes
livelier. With the same type of simplicity as the ImageBrush, you can paint a surface
with a video, using the VideoBrush.
24.3.5 VideoBrush
Imagine watching a shooting star speed across the night sky through the elliptical eye-
piece of a telescope. With the VideoBrush in action, you can deliver this type of scene
by drawing an Ellipse and filling it with a MediaElement. Listing 24.21 shows how to
use the VideoBrush.
Result:
XAML:
<MediaElement x:Name="myMediaElement" Opacity="0"
  Source="Assets/video2.wmv" />
<Ellipse Width="100" Height="100" Stroke="Black">
  <Ellipse.Fill>
    <VideoBrush SourceName="myMediaElement" />
  </Ellipse.Fill>
</Ellipse>
As the listing shows, the VideoBrush references a MediaElement through the Source-
Name property. This fact allows you to manipulate the playback functionality of a Vid-
eoBrush by altering the playback of the MediaElement as defined in appendix B of the
ebook. If you want to pause or stop the video displayed within a VideoBrush, you call
the Pause() or Stop() method of the MediaElement that the VideoBrush references.
 Up to this point, the Brush elements have been used in relation to a basic Ellipse.
An Ellipse was chosen for the sake of illustration; you can use all the Brush elements
that I’ve covered in any number of visual elements, including but not limited to a Can-
vas, a TextBox, or even a TextBlock, as listing 24.22 shows.
Result:
XAML:
<MediaElement x:Name="myMediaElement" Opacity="0"
  Source="Assets/video2.wmv" />
Listing 24.21
An example of a VideoBrush
Listing 24.22
An example of a videoBrush within a TextBlock

620
CHAPTER 24
Graphics and effects
<TextBlock Text="HELLO" FontFamily="Verdana" 
  FontSize="80" FontWeight="Bold">
  <TextBlock.Foreground>
    <VideoBrush SourceName="myMediaElement" />
  </TextBlock.Foreground>
</TextBlock>
This example only begins to show the potential allotted by the different Brush ele-
ments. All the Brush options are usable in any property that has a Brush type. You can
have a video paint text, or an image paint shapes or even controls. The sky’s the limit. 
 In addition to these rich Brush options, Silverlight supports an interesting set of
features that can further alter the appearance of your shapes. Collectively, these are
called effects.  
24.4
Effects
As is the case with animation, the subtle and appropriate use of effects can make the
difference between a UI that sits there and one that really pops, drawing your eye to
information that’s important to you.
 Effects in Silverlight come in two primary forms: built-in effects, implemented in the
native Silverlight hardware-accelerated runtime code, and pixel shaders, implemented
by folks like us using a combination of managed code and High Level Shader Lan-
guage (HLSL) and run in software. The former allows for maximum performance for
common effects such as blur and shadows. The latter provides a lot of flexibility to
allow you to provide your own effects while not breaking out of the sandbox.
 This section covers both types of effects. I’ll start by showing you how to use the built-
in effects and follow that up with a primer on creating your own pixel shader effects.
24.4.1 Using built-in effects
Silverlight has two built-in effects: blur and drop shadow. The effects may be used on
any element or group of elements in the visual tree.
 Elements that have effects applied remain as interactive as they did prior to the
effect. Although it may be hard to read the text in a blurred-out TextBox, the TextBox
is still fully functional.
BLUR EFFECT
The blur effect in Silverlight, implemented through the BlurEffect class, provides a
way to shift an element or group of elements out of focus, as though you were looking
at it through frosted glass or a bad lens.
 Blur has only one property of interest: Radius. The Radius property controls how
large an area is sampled when the blur is run: the larger the radius, the blurrier the
result. Note that the larger the radius, the more computations required to achieve the
blur—a potential performance consideration, especially if a large area or animation is
involved.

621
Effects
 Listing 24.23 shows how to use the BlurEffect on a group of UI elements in a
StackPanel.
Result:
XAML:
<StackPanel x:Name="Elements" Margin="10">
  <TextBlock Text="Hello World" Margin="10" />
  <TextBox Text="This is a textbox" Margin="10" />
  <Button x:Name="Button" Content="Button" Margin="10"/>
  <StackPanel.Effect>               
    <BlurEffect Radius="4" />
  </StackPanel.Effect>
</StackPanel>
The blur effect is applied to the entire StackPanel containing all the UI elements.
The net result is to blur everything inside that container. You can also apply a blur to
individual elements. The effect is attached to the StackPanel using the Effect prop-
erty. The Effect property can have only one effect at any point in time. If you want
multiple effects on a single element, you need to use nested panels or borders and
apply the effects one per panel/border.
 The blur effect is useful when combined with things such as a pop-up modal win-
dow (see chapter 28). In that case, a slight blur of the page contents helps drive home
the fact that the pop-up is modal and demands all your attention.
 The second built-in effect is the drop shadow.
DROP SHADOW EFFECT
The drop shadow effect is one of those effects that’s best used in moderation and used
subtly when used at all. Not only is there a performance and rendering quality con-
cern, but aesthetically, those of us who aren’t designers tend to use bold shadows
more often than looks good in an application.
Listing 24.23
A blur with a 4-pixel radius
Effect on 
StackPanel

622
CHAPTER 24
Graphics and effects
 The DropShadowEffect class has several knobs you can use to fine-tune the effect.
Table 24.3 shows the five properties that alter the appearance of the effect.
When playing with shadows, I’ve found it more aesthetically pleasing to have Shadow-
Depth be 0 or close to 0, Opacity set to a value of 0.5 or so, and BlurRadius set to a
value that spreads out the effect—10 usually works well. That gives you a light shadow
that bleeds around all the edges. Listing 24.24 shows these settings in use in the effect.
Result:
XAML:
<Grid x:Name="LayoutRoot" Background="White">
  <Grid Background="White" Width="180" Margin="25">     
    <StackPanel x:Name="Elements" Margin="10">
      <TextBlock Text="Hello World"
                 Margin="10" />
      <TextBox Text="This is a textbox"
               Margin="10" />
      <Button x:Name="Button" Content="Button"
              Margin="10"/>
    </StackPanel>
    <Grid.Effect>
      <DropShadowEffect BlurRadius="10"
                        Opacity="0.5"
                        ShadowDepth="1" />
Table 24.3
Important DropShadowEffect properties
Property
Description
Color 
Specifies the color of the shadow. Default is Black.
ShadowDepth 
Distance in pixels to displace the shadow relative to the element the effect is 
applied to. Default is 5 pixels.
Direction 
An angle in degrees from 0 to 360 (counterclockwise), indicating where the shadow 
lies relative to the element the effect is applied to. The default is 315, which 
places the shadow in the lower-right corner.
BlurRadius 
Controls the blurriness of the shadow. A double value with a default of 5.
Opacity 
Specifies how opaque the shadow is. A double value between 0 and 1, with 1 being 
fully opaque. Default is 1.
Listing 24.24
A subtle drop shadow

623
Effects
    </Grid.Effect>
  </Grid>
</Grid>
Note that the effect is applied to a grid with an
opaque background. If the grid had a transparent
background, the effect would be applied individu-
ally to each of the items inside the grid.
 As described earlier, this example uses a large
blur radius, 50 percent opacity, and a shadow
depth of only 1 pixel. This provides a more pleas-
ing and subtle effect than the default shadow
appearance. Compare that to figure 24.2, with the
properties all left at their default values.
 Most people would find the default appearance a bit jarring, or at least a little out-
dated. Fortunately, the Silverlight team gave you all the tweaks you need to be able to
make the shadow look better.
 In addition to these designer-type recommendations, you should keep a few other
things in mind when using effects.
TRICKS AND CONSIDERATIONS
The built-in effects perform well, but they’ll tax your system resources if you apply
them to a really large area and/or animate any of the values on the effect. For exam-
ple, one thing I did early on was animate the background blur from 0 to 5 when dis-
playing a new dialog. It worked, but it was a processing hog.
 In addition to processing time, another consideration is the quality drop in the
result. Any elements with an effect applied to them are rendered out to a bitmap.
That means you automatically lose ClearType font rendering and fall back to grayscale
rendering. One way to get around this is to apply the effect to a shape of the same size
that sits behind the elements. Listing 24.25 shows how to use a rectangle behind the
grid to ensure that the grid contents stay at top rendering quality.
<Grid x:Name="LayoutRoot" Background="White">
  <Grid Width="180" Margin="25">
    <Rectangle Fill="White">               
      <Rectangle.Effect>
        <DropShadowEffect BlurRadius="10"
                          Opacity="0.5"
                          ShadowDepth="1" />
      </Rectangle.Effect>    
    </Rectangle>
    <StackPanel x:Name="Elements" Margin="10">
      <TextBlock Text="Hello World" Margin="10" />
      <TextBox Text="This is a textbox" Margin="10" />
      <Button x:Name="Button" Content="Button"
                    Margin="10"/>
Listing 24.25
Applying the drop shadow to a background Rectangle
Figure 24.2
The default appearance 
of the DropShadowEffect
Background 
rectangle

624
CHAPTER 24
Graphics and effects
    </StackPanel>
  </Grid>
</Grid>
The example removes the effect from the grid and places it on a background rectan-
gle sitting behind the elements. Because the rectangle isn’t a parent of the elements,
the effect isn’t applied to them. The only thing that’s rasterized in this example is the
Rectangle. The text retains ClearType font rendering.
 The Silverlight team may add more effects over time. Requests include true multi-
pass effects such as glow. In the meantime, it’s possible to create your own single-pass
effects using a little Silverlight code and the shader language. 
24.4.2 Creating custom pixel shaders
Most people who know about pixel shaders have run across them in game develop-
ment. Games and various types of shaders have gone hand in hand because video
cards became powerful enough to offload most or all of the shader calculation and
logic. Most work done with pixel shaders is performed using the DirectX SDK and
optionally XNA.
WPF also supports pixel shaders. Entire libraries of transitions and effects are avail-
able on CodePlex, all built using hardware-accelerated shaders.
 Pixel shaders in Silverlight are a simplified form of the full pixel shaders used in
games or in WPF. For security reasons, the user-created shaders are all run in software
and currently support only Pixel Shader level 2. By not running them directly on
hardware, Silverlight can sandbox the code and avoid someone running malicious
code on your video card.
HOW PIXEL SHADERS WORK
Pixel shaders perform per-pixel processing on input. That input can be anything you
see in the visual tree in Silverlight, including images, video, and controls. Pixel shad-
ers in Silverlight are created using two main files. The first is a .NET class that’s used to
wrap the shader functionality and expose it to the rest of Silverlight. The second is the
pixel shader itself, written in HLSL as an FX file and compiled into a PS file as a
resource in the Silverlight project.
 Pixel shaders are written in HLSL, a C-like language optimized for pixel processing.
The language is geared toward running on video card hardware, so you have to deal
with things such as registers, fixed numbers of variables, and limitations on overall
complexity. In some of those ways, it’s like working in assembly language. You can find
a reference on HLSL syntax on MSDN at http://bit.ly/HLSLReference.
 Pixel shaders in Silverlight are software-rendered but are parallelized. Although
they don’t take specific advantage of capabilities of video hardware, they’re executed
using the CPU’s fast SSE instruction set. 
 Silverlight supports the ps_2_0 profile of the Shader Model 2 specification. A shader
profile is the target for compiling a shader, whereas a shader model is a specification for

625
Effects
capabilities of the shader. You’ll need to understand this when looking at existing
shader implementations to port to Silverlight or learning about HLSL syntax. In the
case of Shader Model 2, the limitation you’re likely to hit is the 96-instruction limit.
That limit is broken down into 64 arithmetic instructions and 32 texture-sample
instructions. The 64 arithmetic instruction limit will almost certainly be a bounding
limit for shaders of any complexity. In addition, if you manually compile the shaders
using the DirectX SDK, you’ll need to know what profile to use.
ENVIRONMENT SETUP
The most difficult part of writing a pixel shader is setting up the environment to allow
them to compile. You have three main options:
■
Download the DirectX SDK, and use the compiler there to build the shader.
■
Repurpose the WPF pixel shader build step.
■
Use a tool such as Shazzam to create and compile the shader.
You can download the DirectX SDK and use its command-line tools to compile the
shader. The SDK is roughly 500 MB and may be a bit much just to compile a shader.
 Option 2 is to repurpose the WPF pixel shader build step. Tim Heuer put together
a great blog post covering the steps required to set up your environment for develop-
ing pixel shaders. It’d be too much to include in this book, so I refer you to his post
here: http://bit.ly/SLPixelShaderCompile. I chose option 2, using a build task. It
involves some configuration as well as a template for the shader development.
 Another option is to use a tool such as Shazzam (http://shazzam-tool.com) to
compile the shader and manually add that into your project. Most Silverlight and WPF
developers doing serious work with pixel shaders use this tool. It also includes a num-
ber of training videos to help you get started with pixel shader development. Finally,
Shazzam includes a bunch of existing shaders in source form that you can learn from.
 Despite its hackish nature, if you want everything to happen inside Visual Studio, I
think you’re better off starting with Tim’s approach for the project structure. If you
don’t need everything integrated into Visual Studio and can add the files manually,
you’ll find that Shazzam is the best long-term solution. In either case, you’ll likely have
Shazzam open while you explore pixel shader development.
 When your environment is set up and you can compile pixel shaders, you’re ready
to develop one of your own. Go ahead and set up your environment now. I’ll wait.
SHADER CODE
Pixel shaders are typically fairly complex; they do things such as alter the visual loca-
tion of pixels based on a complex algorithm. Learning how to write shaders is like
learning any other programming language, but with a heavy focus on performance
and optimization.
 A good place to learn is the WPF Pixel Shader Effects library on CodePlex: http://
wpffx.codeplex.com. Although originally intended for WPF use, Silverlight effects
were added once Silverlight supported HLSL-based pixel shaders.

626
CHAPTER 24
Graphics and effects
 Listing 24.26 shows the HLSL source code for a pixel shader that takes a color and
multiplies every pixel by that color. The result is an image that appears to have been
photographed through a tinted lens.
//-------------------------------------------------------------------
// 
// Silverlight ShaderEffect HLSL -- ShaderEffect1
//
//-------------------------------------------------------------------
//-------------------------------------------------------------------
// Constant register mappings (float,double,Point,Color,Point3D...)
//-------------------------------------------------------------------
float4 colorFilter : register(C0);                                    
//-------------------------------------------------------------------
// Sampler Inputs (Brushes, including ImplicitInput)
//-------------------------------------------------------------------
sampler2D implicitInputSampler : register(S0);                        
//-------------------------------------------------------------------
// Pixel Shader
//-------------------------------------------------------------------
float4 main(float2 uv : TEXCOORD) : COLOR         
{
  float4 color = tex2D(implicitInputSampler, uv);
  return color * colorFilter;                    
}
The shader first maps values into registers supported by the shader model. Each input
and constant must be mapped to a register. A register is a well-known place in hardware
(virtual hardware in the Silverlight case) that can be used to store a value. Registers
are much faster than regular RAM when it comes to accessing values. If you’ve ever
done any x86 assembly language programming, or even any old DOS interrupt pro-
gramming, you know well the concept of registers.
 The section comments aren’t required, but you’ll find them in almost every pixel
shader implementation. Usually I’d leave them out of a code listing in this book, but
the shader is completely naked without them.
 The actual code starts under the Pixel Shader section. Like all pixel shaders in Sil-
verlight, this has a main function that takes in a UV coordinate (a standard way of refer-
ring to an x and y position on a texture or image, but normalized into the range of 0
to 1 rather than absolute pixels) and returns a float4 color.
 When you have the HLSL source for your shader, you’ll need to write a .NET class
to expose it in your project.
WRAPPER CLASS
To use a pixel shader, you have to provide a way for the rest of .NET to interact with it.
The wrapper class (often called just the pixel shader class) is responsible for loading the
compiled shader code and for exposing properties used to tweak the shader. The
Listing 24.26
A simple pixel shader that applies a color filter
Standard main 
function

627
Effects
Pixel Shader file template includes a wrapper class. In addition, Shazzam will generate
the wrapper class for you. The wrapper class for this example is shown in listing 24.27.
public class ShaderEffect1 : ShaderEffect
{
  private static PixelShader _pixelShader = new PixelShader();
  static ShaderEffect1()                 
  {
    _pixelShader.UriSource = new
        Uri("/SilverlightApplication61;component/ShaderEffect1.ps",
        UriKind.Relative);
  }
  public ShaderEffect1()                  
  {
    this.PixelShader = _pixelShader;
    UpdateShaderValue(InputProperty);
    UpdateShaderValue(ColorFilterProperty);
  }
}
public Brush Input                        
{
    get { return (Brush)GetValue(InputProperty); }
    set { SetValue(InputProperty, value); }
}
public static readonly DependencyProperty InputProperty =
    ShaderEffect.RegisterPixelShaderSamplerProperty("Input",
                   typeof(ShaderEffect1), 0);                  
public Color ColorFilter
{
    get { return (Color)GetValue(ColorFilterProperty); }
    set { SetValue(ColorFilterProperty, value); }
}
public static readonly DependencyProperty ColorFilterProperty =
    DependencyProperty.Register("ColorFilter", typeof(Color),
    typeof(ShaderEffect1), new PropertyMetadata(Colors.Yellow, 
                   PixelShaderConstantCallback(0)));            
}
The static constructor loads the pixel shader resource into a static PixelShader typed
property. Note the .ps extension: it’s loading the compiled resource. The PixelShader
is static because only one copy of the compiled code is needed within an application.
 Each of the dependency properties maps to a register in the shader. One of the
properties, of type Brush, is mapped implicitly. Any additional properties must be
mapped directly to registers. In this source, you can see that the ColorFilter-
Property maps to constant register zero in the pixel shader. The PixelShader-
ConstantCallback takes the register number as a parameter. In the HLSL source,
constant register zero is mapped to the variable colorFilter. 
Listing 24.27
A pixel shader wrapper class
Public instance 
constructor
Implicitly 
mapped

628
CHAPTER 24
Graphics and effects
 But how did a Color property become a float4, and what’s a float4 anyway?
Those are built-in vector types in the language. Table 24.4 has the mapping.
The member names for the individual floats depend on their usage. For example, a
color has the properties r, g, b, and a.
HLSL is interesting in that it can perform multiplication and other operations on
whole structures. In that way, the number of instructions is reduced, but it can be hard
to understand when you first look at it. For example, listing 24.26 multiplies two
float4 values.
USING THE SHADER
With the shader compiled and the wrapper class in place, it’s time to try the shader in
your own application. As with any other element used in XAML, you must either
include an implicit namespace in your application settings or map a namespace in the
XAML file. In this case, because the shader is in the project with the XAML, you’ll use
an explicit map in the XAML. 
 Listing 24.28 shows the effect of using the shader with a red tint. It’ll look gray in
print, but you can tell there’s a tint over the whole image.
Result:
Code:
<UserControl x:Class="SilverlightApplication61.MainPage"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             xmlns:local="clr-namespace:SilverlightApplication61"
Table 24.4
Mapping from .NET types to HLSL types
Shader type
Description
.NET type
float
A single floating-point number
double, single
float2
A vector with two floating-point numbers
Point, Size, Vector
float3 
A vector with three floating-point numbers
(Unused in 2D shaders)
float4
A vector with four floating-point numbers
Color
Listing 24.28
Using the pixel shader effect in XAML

629
Summary
    mc:Ignorable="d"
    d:DesignHeight="300" d:DesignWidth="400">
    <Grid x:Name="LayoutRoot">
        <Grid Background="White" Width="180" Margin="25">
            <StackPanel x:Name="Elements" Margin="10">
                <TextBlock Text="Hello World" Margin="10" />
                <TextBox Text="This is a textbox" Margin="10" />
                <Button x:Name="Button" Content="Button"
                        Margin="10" />
            </StackPanel>
            <Grid.Effect>
                <local:ShaderEffect1 ColorFilter="Red" /> 
            </Grid.Effect>
        </Grid>
    </Grid>
</UserControl>
This is the same example used in previous sections, but instead of a drop-shadow, it
uses the pixel shader with a parameter of Red for the ColorFilter property. The end
result is an angry red form. As was the case in the other examples, the use of a pixel
shader has reverted the text to grayscale font smoothing.
 Pixel shaders are a great way to provide your own custom effects or to use effects
developed by others. Learning HLSL can be difficult, but the payoff is worth it: you
can use pixel shaders in Silverlight, in WPF, and, of course, in DirectX and XNA. Pixel
shaders, even the software-rendered ones in Silverlight, are extremely efficient as well.
When considering pixel-manipulation strategies in an application, the creation of a
pixel shader should be high on your list of options.  
24.5
Summary
Silverlight’s inherent graphical capabilities go far beyond cartoons and visual fireworks.
By shaping these elements into illustrations, graphics can provide a bridge to your users
to help them connect with difficult concepts. These valuable illustrations can be com-
posed of a series of shapes compiled from arcs, curves, and lines. These shapes can then
be filled with gradient colors or textured visuals such as images and videos.
 Effects augment both graphics and controls. The use of a subtle drop shadow or a
blur can help users focus their attention on a specific part of the screen. If those
effects aren’t sufficient, you also have the option to create your own effects in the form
of pixel shaders.
 Vector graphics and effects are definitely some of the strong points in Silverlight.
Previous technologies had no equivalents; you had to write everything from scratch or
use primitive drawing options. Silverlight also has rich support for images and media,
another of its strong points. You’ll learn more about that in appendices B and C of the
ebook. Before you get there, it’s important for you to understand the other type of
graphic you’ll run into in Silverlight: the bitmapped image.
ColorFilter 
property

630
Working with images
Images are used on web pages all across the internet. They’re used in the form of
application icons, corporate logos, and photos of you and your friends. It’s been
quite a while since I’ve seen even a regular forms-over-data application that didn’t
have images in the UI somewhere. Obviously, bitmap-based images have become a
mainstay of application design.
 Naturally, Silverlight includes mechanisms for displaying this content through
the Image element and the MultiScaleImage control. 
 In addition to displaying images, Silverlight includes the powerful ability to cre-
ate images from scratch or from other elements using the WriteableBitmap type.
You can even use the WriteableBitmap to provide support for formats not natively
supported in Silverlight (such as GIF).
 This chapter begins with the basics of imaging with the Image element. From
there, you’ll move on to creating images on the fly using the WriteableBitmap.
Once you have a handle on the WriteableBitmap, you’ll turn to Silverlight’s answer
This chapter covers
■
Working with images
■
Creating images on the fly
■
Deep Zoom
■
Stretching content

631
Basic imaging
to enormous gigapixel-level images or collections of images: Deep Zoom with the
MultiScaleImage control. Finally, I’ll wrap up the chapter with a discussion of the var-
ious ways of stretching content to fit the space allotted.
25.1
Basic imaging
The Image element enables you to display images from across the internet. In addi-
tion to loading images relative to your project, the Image element allows you to
retrieve images from another domain. Look at how listing 25.1 uses the Source prop-
erty  to get an image from the local web server.
Result:
XAML:
<StackPanel Height="200" Width="100">
  <Image Source="Assets/man.png" />
</StackPanel>
The Image in the markup retrieves an image from the local project. This image is ref-
erenced through the Source property, which is set with a Uri through XAML. If this
property needs to be set programmatically, you must use an ImageSource instead.
Because this abstract class can’t be used directly, you use a derivation known as
BitmapImage. This class name is a little misleading because only the types listed in
table 25.1 are supported.
The table shows the image formats supported by the BitmapImage class. Because this
is the type used by the Source property, these image formats also represent those sup-
ported by the Image element in general. 
 What are you to do if you want to load an image type that’s unsupported by Silver-
light, such as GIF or BMP? In the previous chapter, you saw how you can use the
MediaStreamSource API to provide a hook to use when a video or audio format is
unsupported. Luckily, Silverlight includes an equivalent for still images: the
WriteableBitmap.
Listing 25.1
An Image element that uses a picture from another domain
Table 25.1
Image formats supported by the Bitmap-Image class. These 
formats are inherently supported formats of the Image element.
Format
Extension(s)
Joint Photographic Experts Group
.jpg, .jpeg, .jpe, .jfif, .jfi, .jif
Portable Network Graphics
.png

632
CHAPTER 25
Working with images
25.2
Creating images at runtime
The WriteableBitmap (sometimes referred to as the Bitmap API) was introduced in
Silverlight 3. It provides the ability to generate new images based on existing images
or onscreen UI elements, or from scratch using pixel manipulation. 
WriteableBitmap is a class in the System.Windows.Media.Imaging namespace,
deriving from the common BitmapSource base class. Deriving from that class allows
you to use the WriteableBitmap in almost every place you could normally use any
other type of bitmap image class.
 The uses for this feature are numerous, and all over the map. I’ve used it to gener-
ate Windows 7–style window thumbnails in a large Silverlight business application for
a customer. I’ve seen others use it in games, for destructive 2D UI (think Lemmings
where a bomb takes a chunk out of the ground). Still others have built their own paint
programs using this feature.
 In this section, you’ll look at the three main ways to use the WriteableBitmap class:
creating editable bitmaps from existing images, creating bitmaps from portions of the
visual tree, and creating bitmaps from scratch.
 Before you do that, you’ll have the usual project setup to do. In this case, create a
new Silverlight project and modify the MainPage.xaml markup to look like listing 25.2.
Result (in designer):
XAML:
<UserControl x:Class="BitmapApi.MainPage"
  xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
  xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
  xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
  mc:Ignorable="d" d:DesignHeight="300" d:DesignWidth="500">
    <Grid x:Name="LayoutRoot" Background="White">
      <Grid.ColumnDefinitions>
        <ColumnDefinition Width="150" />
        <ColumnDefinition Width="*" />
      </Grid.ColumnDefinitions>
      <StackPanel x:Name="Elements"      
                  Grid.Column="0"
                  Margin="10">
Listing 25.2
MainPage.xaml for the WriteableBitmap examples
Tree root

633
Creating images at runtime
        <TextBlock Text="Hello World" Margin="3" />
        <TextBox Text="This is a textbox" Margin="3" />
        <Button x:Name="Capture"
                Content="Capture" Margin="3" />
        <Image Source="Assets/Pete3YearsOld.jpg"  
               X:Name="SourceImage"
               Stretch="Uniform" />
      </StackPanel>
      <Image x:Name="ResultBitmap"               
             Stretch="Uniform"
             Margin="10"
             Grid.Column="1" />
  </Grid>
</UserControl>
The markup includes a StackPanel that you’ll use for your visual tree rendering
example, including an image that you’ll use to test creating from existing images, and
a result bitmap that will display the writeable bitmap you create in the code-behind.
 Outside of the downloadable source, you likely don’t have a picture of me at three
years old hanging around (as in listing 25.2), so pick any old JPEG you have on your
machine and drag it into the Silverlight project as a resource, using it instead.
 Our first trial of the WriteableBitmap class is going to be to create a new image
from an old one.
25.2.1 Creating from existing images
If you’re creating a photo-manipulation program, you’ll want to create a Writeable-
Bitmap from an existing image. That new bitmap will enable you to access the pixels
to allow for drawing, erasing, recoloring, and pretty much anything else you can write
code for.
 There are some restrictions when creating images from existing images. If you
download the image from another server—in other words, a cross-domain call like we
Me at 3
Result
Figure 25.1
A WriteableBitmap 
(right) created from 
another bitmap (left)

634
CHAPTER 25
Working with images
discussed in chapter 19—you won’t be able to access the individual pixels of the
image. In this example, you’ll use an image that already exists in your project. The
resulting application will look like figure 25.1 once you click the Capture button.
 The example shows how to use one bitmap as a source to the writeable bitmap.
Once you have the image in a writeable bitmap, you can manipulate it all you’d like
(within the cross-domain restrictions I mentioned). Double-click the Capture button
to create an event handler, and then place this code in the handler:
BitmapSource source = SourceImage.Source as BitmapSource;
WriteableBitmap bmp = new WriteableBitmap(source);
ResultBitmap.Source = bmp;
You can also load the image from a URL. This code, used in place of the previous
example, shows how:
Uri uri = 
    new Uri("BitmapApi;component/Assets/Pete3YearsOld.jpg", 
    UriKind.Relative);
StreamResourceInfo res = Application.GetResourceStream(uri);
BitmapImage image = new BitmapImage();
image.SetSource(res.Stream);
WriteableBitmap bmp = new WriteableBitmap(image);
ResultBitmap.Source = bmp;
This example shows how to create a WriteableBitmap from an existing image that
hasn’t necessarily been loaded into an Image element onscreen.
 The convoluted loading scheme is required only because this file is a resource in
the Silverlight project. If it were a normal file on the server, you could’ve passed the
URI directly to the BitmapImage constructor.
NOTE
The image is loaded asynchronously; the data isn’t available until the
BitmapImage.ImageLoaded event has fired. Keep this in mind when working
with images from external servers.
Another way to use the WriteableBitmap class is to create a rendering of a portion of
the visual tree.
25.2.2 Creating from UI elements
The WriteableBitmap class can be used to take a snapshot of all or a portion of the
visual tree. This allows you to easily create thumbnails of large forms for a Windows 7
taskbar-like effect or capture still frames from videos playing in a MediaElement. Note
that cross-domain pixel-access checks are enforced, so if anything in the tree fails the
cross-domain check, everything will.
 As it turns out, creating a snapshot of a portion of the video tree is extremely sim-
ple. You pass the root element of the branch of the tree into the constructor of
WriteableBitmap, along with an optional render transform. Figure 25.2 is an example
of a direct 1:1 representation.

635
Creating images at runtime
To create the bitmap version of the UI as shown in figure 25.2, you only need a couple
of lines of code. Place these in the click event handler to substitute for the other code
shown so far:
WriteableBitmap bmp = new WriteableBitmap(Elements, null);
ResultBitmap.Source = bmp;
Elements is the name of the StackPanel containing the four elements. The fidelity of
the capture is close, but not perfect. For example, you lose ClearType rendering for
fonts, so most text will look a little different. If you pass in a render transform (to
rotate, skew, resize), it’ll definitely look different. 
 The final approach is to create an image from scratch. I’ll discuss direct pixel
access at the same time; it applies to all three approaches.
DIRECT PIXEL ACCESS 
The third approach to using the WriteableBitmap is to create an image from scratch.
This is useful when you want to create an image from code or allow the user to draw
on an empty canvas using the mouse. 
 The direct pixel access techniques shown here also work for any of the previous
approaches, once the base image is loaded. Keep in mind that cross-domain images
don’t allow direct pixel access, and you’ll get an exception if you try to do so.
 To create an image from scratch, you need only provide dimensions, like this:
WriteableBitmap bmp = new WriteableBitmap(640, 480);
Then you’re free to start working with the image. The pixels are manipulated using
the Pixels property, which returns an array of integers. Each 32-bit integer represents
one pixel in pARGB (premultiplied alpha, red, green, blue) format. This example iter-
ates through the array, setting completely random values for the pixels:
Random random = new Random();
for (int i = 0; i < bmp.Pixels.Length; i++)
    bmp.Pixels[i] = random.Next();
ResultBitmap.Source = bmp;
Figure 25.2
The elements to the 
left are live elements in 
the visual tree. On the 
right, you can see the 
bitmap representation 
of those elements, 
captured while the 
Capture button was 
clicked.

636
CHAPTER 25
Working with images
That’s interesting but not particularly helpful, because it doesn’t show how to set a
specific color. Setting a single pixel to a specific color is just as easy:
Color c = Colors.Orange;
bitmap.Pixels[i] = c.A << 24 | c.R << 16 | c.G << 8 | c.B;
The shifting combined with the bitwise OR operation packs the four values into their
correct position within the integer. To get an existing value, the code is a little more
verbose, but still amounts to the reverse of putting the pixel:
int pixel = bitmap.Pixels[i]
Color c = Color.FromArgb((byte)(pixel >> 24),
                         (byte)(pixel >> 16),
                         (byte)(pixel >> 8),
                         (byte)(pixel));
In this example, the variable c will contain the correct color code for the pixel at posi-
tion i. The bitshift operators and byte masking take care of getting the correct values
from the correct positions in the integer.
 One interesting use of all this is to create new images using an algorithm. One of
the most impressive and best-known algorithms is the Mandelbrot fractal. Next you’ll
create your own little Mandelbrot fractal generator. 
25.2.3 A Mandelbrot fractal generator
I love fractals. A number of the desktop wallpapers I created and offer through my per-
sonal site were generated using fractal explorer programs such as Ktaza (no longer
available). In this section, you’ll build a simple visualizer for the Mandelbrot set, a com-
mon fractal. The Silverlight application will be able to produce results like figure 25.3.
Figure 25.3
The 
WriteableBitmap
sample application 
modified to show a 
Mandelbrot fractal

637
Creating images at runtime
For efficiency, you’ll modify the same project you’ve been working with throughout
this section. Inside the button click handler, add the code from listing 25.3. This code
generates a Mandelbrot fractal, coloring it using the escape time algorithm. 
int width = 1024; int height = 768;
int[] colorTable = new int[256];
for (int i = 0; i < 256; i++)             
{
    Color c = Color.FromArgb(
        0xFF, (byte)(255 - i), (byte)(255 - i), (byte)(255));
    colorTable[i] = c.A << 24 | c.R << 16 | c.G << 8 | c.B;
}
WriteableBitmap bmp = new WriteableBitmap(width, height); 
for (int x = 0; x < width; x++)
{
    for (int y = 0; y < height; y++)
    {
        double zoom = 300;
        double x0 = 0; double y0 = 0;
        double cx = (x - width / 2) / zoom;
        double cy = (y - height / 2) / zoom;
        int iteration = 0;
        int maxIterations = 1000;
        while (x0 * x0 + y0 * y0 <= 4 && iteration < maxIterations)
        {
            double xtemp = x0 * x0 - y0 * y0 + cx;
            y0 = 2 * x0 * y0 + cy;
            x0 = xtemp;
            iteration++;
        }
        if (iteration == maxIterations)
        {
            bmp.Pixels[(y * width) + x] =
                       colorTable[colorTable.GetUpperBound(0)];
        }
        else
        {
            bmp.Pixels[(y * width) + x] =            
                       colorTable[iteration % colorTable.Length];
        }
    }
}
ResultBitmap.Source = bmp;                       
The example shows how to generate a simple Mandelbrot fractal with coloration based
on the escape time algorithm. The code to make this work in Silverlight is straightfor-
ward. First, you build a color table to be used by the escape time algorithm. The colors
simply fade from white to dark blue. You then create the WriteableBitmap instance.
 The majority of the remaining code is an implementation of the Mandelbrot frac-
tal algorithm. Should you want to modify the scale of the content, the zoom variable is
a good place to begin.
Listing 25.3
Mandelbrot fractal in WriteableBitmap
Color table
Escape time 
coloration
On-screen bitmap

638
CHAPTER 25
Working with images
 The final step is to set the source of the bitmap onscreen to be the Writeable-
Bitmap. This is consistent with the other examples.
 I remember in the ’80s I had a CBM-BASIC program that generated a Mandelbrot
set, and it ran all night, just to create a 320 x 200 image. When I run this Silverlight
example on my PC, the 1024 x 768 fractal generates and displays in subsecond time.
Impressive.
WriteableBitmap enables a number of important scenarios. First, you can use it to
duplicate an existing image to prepare it for editing. Second, you can take a snapshot
of a portion of the visual tree in order to create a thumbnail or to snap a frame of a
video. Third, you can generate images, or modify existing images, entirely from code.
The scenarios for WriteableBitmap reach across all types of applications from games,
to image manipulation, to forms-over-data business applications. Plus, just about any-
where you can use an Image, you can use a WriteableBitmap.
TIP
WriteableBitmap requires using a fair bit of effort to use for generating
shapes or lines. For those situations, you have to do the math to plot pixels
efficiently. The WriteableBitmapEx library on CodePlex at http://
writeablebitmapex.codeplex.com builds on the WriteableBitmap to add sup-
port for these and other functions.
The Image element will support images up to 4 gigapixels (four billion pixels) in size.
As you can imagine, using images this large can force your users to endure painful
wait times. In addition, with advancements in digital photography and photo-stitch-
ing, what are you supposed to do with images larger than 4 gigapixels? To address
these types of situations, Silverlight exposes a slick feature called Deep Zoom.  
25.3
Deep Zoom
Deep Zoom is a feature of Silverlight that enables users to explore groupings of high-res-
olution images. Traditionally, viewing high-resolution images over the internet has
been associated with painful wait times because high-resolution images are generally
larger in size. Silverlight’s Deep Zoom feature removes the long wait times. In addi-
tion, Deep Zoom natively allows users to drill into an image and see its most intricate
details. All this is delivered in a smooth viewing experience that runs with unprece-
dented performance. This kind of experience is made possible by the MultiScale-
Image control.
 The MultiScaleImage control, similar to the Image control, has the ability to effi-
ciently show incredibly high-resolution images. These images can be zoomed into, giv-
ing the user a close-up view of the content. Alternatively, the user can zoom away from
the image to get a bird’s-eye view of the image. Either way, these zooming features are
constrained to an area known as the viewport. This viewport can be zoomed into,
zoomed out of, and moved around the surface of an image, but this image isn’t an
image at all—it’s a collection of images typically created by Deep Zoom Composer, a
free tool from Microsoft.

639
Deep Zoom
25.3.1 Showing an image
Showing an image within a MultiScaleImage control is nearly identical to showing an
image within an Image control. As with the Image control, the only property you need
to set to display an image is Source. This property is a MultiScaleTileSource that
can be used to reference a file, but this file isn’t a typical image file. Instead, this file is
an XML file, known as the Deep Zoom image (DZI) file, that describes a multiscale image.
I’ll share more about this file type in a moment; for now, look at how a MultiScale-
Image is created in XAML:
<MultiScaleImage x:Name="myMultiScaleImage" 
  Source="images/dzc_output.xml" />
This code shows the XAML to load a relative multiscale image at design time. In the
event that you need to load a multiscale image at runtime, you use a DeepZoomImage-
TileSource instance. This type derives from the abstract base class MultiScaleTile-
Source, so it can be used at runtime, as shown here:
myMultiScaleImage.Source = new DeepZoomImageTileSource(
  new System.Uri("images/dzc_output.xml", UriKind.Relative));
This code shows how to load a multiscale image at runtime. If the referenced image
can’t be found, the MultiScaleImage object’s ImageOpenFailed event will be fired. If
the image is found, the ImageOpenSucceeded event will be triggered and the image
will be shown. Once this happens, you may consider giving your user the ability to
zoom in and out of the high-resolution image.
25.3.2 Zooming in and out
The MultiScaleImage control has the ability to show an extremely high-resolution
image. This control helps remove the traditional limitations associated with screen
real estate. This is accomplished by enabling your users to zoom in from a view as if
they were standing on top of a mountain.
 Zooming within a MultiScaleImage is handled by a method called ZoomAbout-
LogicalPoint. The ZoomAboutLogicalPoint method takes three parameters that
describe the zoom attempt. The first parameter determines how much to zoom by.
The second and third parameters specify from where in the image the zoom origi-
nates. These parameters and the ZoomAboutLogicalPoint method are shown next.
C#:
public MainPage()
{
  InitializeComponent();
  this.KeyDown += new KeyEventHandler(Page_KeyDown);        
  this.KeyUp += new KeyEventHandler(Page_KeyUp);            
  myMultiScaleImage.MouseLeftButtonDown +=            
Listing 25.4
Implementing zoom functionality
Input event

640
CHAPTER 25
Working with images
    new MouseButtonEventHandler(myMultiScaleImage_MouseLeftButtonDown);
}
private bool shouldZoom = true;
void Page_KeyDown(object sender, KeyEventArgs e)   
{ 
  if (e.Key == Key.Shift)
    shouldZoom = false;
}
void Page_KeyUp(object sender, KeyEventArgs e)            
{ 
  shouldZoom = true;
}
void myMultiScaleImage_MouseLeftButtonDown(object sender,
  MouseButtonEventArgs e)                                 
{
  Point point = e.GetPosition(myMultiScaleImage);
  point = myMultiScaleImage.ElementToLogicalPoint(point);
  if (shouldZoom == true)
    myMultiScaleImage.ZoomAboutLogicalPoint(1.5, point.X, point.Y);
  else
    myMultiScaleImage.ZoomAboutLogicalPoint(0.5, point.X, point.Y); 
}
Listing 25.4 looks like a lot of code. In short, this code enables the user to zoom in or
out of the MultiScaleImage defined earlier. To enable this functionality, you first lis-
ten for a keypress. If the keypress is made from the Shift key, the user is saying to zoom
away from the image. If the Shift key hasn’t been pressed, the zooming feature will
default to zooming in, so you also need to listen for a user releasing a key through the
KeyUp event. This event resets the zoom mode to the default after the Shift key has
been pressed. The real meat of this feature is demonstrated when the user clicks the
MultiScaleImage. This action forces a call to the ZoomAboutLogicalPoint method,
which zooms according to the three parameters passed to it.
 The first parameter passed to the ZoomAboutLogicalPoint method determines
how to zoom on the image. If this double value is less than 1, the method will zoom
away from the image. If the value is greater than 1, the method will zoom into the
image. Either way, you can play around with this value to also adjust the speed in
which the zoom is applied. To determine where the zoom begins, you must rely on the
second and third parameters.
 The second parameter represents the logical x coordinate to zoom from, and the
third parameter represents the logical y coordinate to zoom from. Both parameters
are double values that fall between 0 and 1. The fact that these values fall between 0
and 1 is what defines them as part of a logical coordinate system, but most items use a
standard Cartesian coordinate system. Fortunately, the MultiScaleImage class exposes
two methods that enable you to convert Point objects between the two coordinate sys-
tems. The methods are:
■
ElementToLogicalPoint
■
LogicalToElementPoint
Keypress

641
Deep Zoom
ElementToLogicalPoint converts a Cartesian Point to a logical Point. This is gener-
ally used to convert the position of the mouse cursor before zooming because the
ZoomAboutLogicalPoint method expects a logical point. Here’s an example, assum-
ing the user clicked the mouse at 125,200:
Point cartesianPoint = new Point(125, 200);   
Point logicalPoint = myMultiScaleImage.ElementToLogicalPoint(cartesianPoint);
myMultiScaleImage.ZoomAboutLogicalPoint(1.5, 
  logicalPoint.X, logicalPoint.Y);
LogicalToElementPoint converts a logical Point to a Cartesian Point. This allows you
to work with a point in a more familiar interface. Here’s an example of how to use this
method:
Point logicalPoint = new Point(0.25, 0.75);
Point cartesianPoint = 
myMultiScaleImage.LogicalToElementPoint(logicalPoint);
Together, these examples show how to convert between the two coordinate systems.
The logical coordinate system is necessary because it’s used for two important tasks.
The first task is zooming in and out of an image—which you just saw. The other major
task is selecting what part of a multiscale image to zoom in on. You’ll learn how to do
this in a moment. Regardless of your task, both require some knowledge of how to
manage the viewport. 
25.3.3 Managing the viewport
The viewport is a rectangular region used to view a specific area of an image. This
region enables you to zoom in and focus on the details of a specific part of an image,
so you may want to think of the viewport as a way to interact with an image three-
dimensionally. By default, this region is the size of the entire MultiScaleImage control,
but you can change the size of the viewport through the ViewportWidth property.
 The ViewportWidth property sets the size of a viewport in relation to the logical
coordinate space. Anytime you change the ViewportWidth property, it’ll be in relation
to the hosting MultiScaleImage. For instance, if you set the ViewportWidth property
to 1.0, the viewport will be the same size as the hosting MultiScaleImage control. If
you change the ViewportWidth property
to a double greater than 1.0, you’ll make
the viewport larger than the Multi-
ScaleImage. This approach would give
the user a sense of zooming away from
the image. Alternatively, you can focus
on a smaller portion of a multiscale
image by providing a value less than 1.0.
Figure 25.4 illustrates this zooming-
away effect.
Figure 25.4
A MultiScaleImage with a 
ViewportWidth of 0.33

642
CHAPTER 25
Working with images
 Figure 25.4 shows the effects of changing the ViewportWidth property to a double
less than 1.0. The figure on the left represents the original multiscale image. As you
can see, the Silverlight logo in this image is only a small portion of the area shown to
the user. By setting the ViewportWidth property to 0.33, the Silverlight logo becomes
the focus of the entire MultiScaleImage. In reality, the ViewportWidth is only part of
the story. The other part involves using the ViewportOrigin property.
 The ViewportOrigin specifies the position of the upper-left corner of the view-
port. This position is a logical Point relative to the upper-left corner of the Multi-
ScaleImage. Each of the coordinates within the Point will be between 0.0 and 1.0.
Note that you can still define this value at design time. To do this, you have to set the
ViewportOrigin property with the syntax shown here:
<MultiScaleImage x:Name="myMultiScaleImage" 
                 Source="images/dzc_output.xml"
                 ViewportOrigin=".33,.33" />
This line of markup shows how to set the ViewportOrigin property value at design
time. As you might expect, this value can also be set at runtime by creating an instance
of the Point class. This explanation hardly details the real value of the Viewport-
Origin property—that it enables you to navigate around the surface of an image once
you’re zoomed in. By handling a user action (see chapter 9), you can change the view-
port position as necessary. The following example shows how to change the position
of the viewport on a mouse click:
void myMultiScaleImage_MouseLeftButtonUp(object sender, 
  MouseButtonEventArgs e)
{
  Point newOrigin = e.GetPosition(myMultiScaleImage);
  myMultiScaleImage.ViewportOrigin = 
    myMultiScaleImage.ElementToLogicalPoint(newOrigin);
}
This example shows how to reposition the ViewportOrigin based on where a user
clicked. Once it’s clicked, the viewport will move to the new Point. This process
begins with a nice smooth animation called a spring animation. This animation will play
any time the viewport changes size or location—any time you zoom in or out of an
image or pan the surface. This animation can be turned off by changing the
UseSprings bool property to false, but you won’t usually want to do this.
 In general, it’s recommended that you leave the UseSprings property set to true
because the animation creates a rich viewing experience. In addition, it gives the
MultiScaleImage control more time to download any necessary data. Once the view-
port does change size or location, the MotionFinished event will be triggered, giving
you an opportunity to perform any UI updates that you may want to make to the display.
 The viewport is an important concept within the MultiScaleImage control. This
item gives you the power to scan the surface of a high-resolution image. In addition,
the viewport enables you to readily zoom in and out of an image. To enable this

643
Dealing with dead space
zooming functionality, you first load an image into the MultiScaleImage control. This
image is loaded through the Source property, and the Source should reference an
XML file, which can be created by a tool. This tool is used when you’re ready to deploy
a multiscale image. 
25.3.4 Deploying multiscale images
The MultiScaleImage control has built-in support for handling XML that details a
multiscale image. This type of file can be generated programmatically or by a tool
called Deep Zoom Composer. I won’t cover this tool in detail because of its simplistic
nature. Once you download and install the tool from the Microsoft Expression web-
site, you can quickly create XML files that can be used by the MultiScaleImage. These
files can be generated within the tool by going through a basic wizard. This wizard
goes through the following steps:
1
Import—Enables you to import your own images
2
Compose—Lets you lay out how the images should appear
3
Export—Determines where the result will be stored
These three steps will generate an XML file and a file/folder structure. These two items
must then be added to your web application so that the MultiScaleImage control can
access them. Once this has been done, you can use Deep Zoom on your own images.
 Deep Zoom is a powerful feature available within Silverlight. Because this technol-
ogy relies on basic images and an XML file, there are no server-side requirements. In
addition, the only client-side requirement is Silverlight itself. This is great news
because, as you play with Deep Zoom, you’ll see the rich experience it provides. This
experience truly makes viewing high-resolution images over the internet enjoyable.
 One of the misconceptions about Silverlight is that everything must be a vector
shape. Silverlight provides a number of ways to load and display bitmap images, as well
as powerful ways to manipulate them. You can load regular PNG and JPEG files from
the web or a local resource; you can create images on the fly, or from other visuals;
and you can quickly zoom through collections with millions or billions of pixels at
play. All of this Silverlight does natively and fluidly, proving both a simple developer
experience and an excellent end-user experience.
 In the examples shown so far in this chapter, you may have noticed some different
values for the Stretch property. This property is shared by video and image elements
alike and helps control how the content will fill (or not fill) the space provided.  
25.4
Dealing with dead space
Throughout this chapter you’ve seen a number of ways to deliver various kinds of
media. Often, media is intended to be a secondary part of an application instead of
the main attraction. For instance, a user’s profile picture is part of an application but
not as important as the profile information itself. As you can imagine, there’s the pos-
sibility that these profile pictures may be of different sizes. This can lead to dead space

644
CHAPTER 25
Working with images
or areas that don’t include content. Fortunately, there’s a way to gracefully deal with
these situations. Please look at figure 25.5.
 The Image, MediaElement, and Shape (discussed in chapter 24) classes expose a
property called Stretch. This property determines how the area devoted to an ele-
ment will be filled. This description will become clearer as you see the examples
available in this section. This property must be set to one of the four options available
in the System.Windows.Media.Stretch enumerator, which exposes the None,
Uniform, Fill, and UniformToFill options.
25.4.1 Filling the space
Most of the time, photos are represented as raster-based graphics. Raster-based graph-
ics often become pixelated and lose their detail when they’re enlarged. You can pre-
vent this from happening by using None for the Stretch value. This option commands
an element to maintain the original size of the requested content—this option doesn’t
make the content stretch at all. As you probably expected, you can set this property
value at design time, as shown here:
<Image x:Name="myImage" 
       Source="Assets/man.png" 
       Stretch="None" />
The XAML in this example loads an Image and prevents it from stretching. You can see
the result from this XAML in figure 25.5, which shows the results of the None option
when there’s plenty of space for a piece of content. Consider the scenario where the
content is larger than the hosting element. Look at Walker’s picture (the content) in
an Image element (the hosting element) smaller than the picture (see listing 25.5).
Figure 25.5
The boundary of an Image element in comparison to the actual size 
of the photo

645
Dealing with dead space
Result:
XAML:
<Image x:Name="myImage" Width="75" Height="75" 
       Source="Assets/man.png" 
       Stretch="None" />
Unfortunately for Walker, his legs got cut off! (One of my slightly twisted tech review-
ers suggested he should be named “Sitter” now. Thanks, Tom.) As the result in listing
25.5 shows, the original photo remains the same size, so the bottom and right edges of
the photo are cropped so that the image fits within the 75px-by-75px dimension of the
Image element. This illustration also erases any fears of an exception being thrown in
the case of an element being smaller than its content.
 At first glance, the None option may seem like the most obvious default option. It
may come as a surprise to learn that another option makes even more sense as the
default. When you begin to consider the fact that the Stretch option is applicable to
Image, MediaElement, and Shape elements, it makes much more sense to stretch items
by default: uniformly.
25.4.2 Uniform sizing
If you set the Stretch property to Uniform, the content of the element will symmetri-
cally expand or contract to occupy most of the available area. While the content
expands or contracts, the native aspect ratio will be preserved. This means that if you
revisit Walker’s picture, it’ll be stretched vertically, making him stand tall and proud
(see listing 25.6).
Result:
XAML:
<Image x:Name="myImage" Width="300" Height="200" 
       Source="Assets/man.png" 
       Stretch="Uniform" />
Listing 25.5
Use of the None option on an undersized Image element
Listing 25.6
A uniformly stretched Image with a photo smaller than the element

646
CHAPTER 25
Working with images
The light gray backdrop in listing 25.6 represents the area that could be filled by
an image. Because the Uniform option stretches content proportionally, it must
stop once either a vertical or horizontal boundary is met. But what happens if the
content is larger than the bounding element? Listing 25.7 shows how to maintain
aspect ratio.
Result:
XAML:
<Image x:Name="myImage" Width="75" Height="75" 
       Source="Assets/man.png" 
       Stretch="Uniform" />
As listing 25.7 illustrates, the content remains intact. Instead of cropping the image, as
was the case in listing 25.5, the content scales to a smaller size. As the content scales
down, the aspect ratio stays the same. Although maintaining the aspect has its bene-
fits, occasionally you might need to fill the entire area, no matter what. For these situ-
ations, you have the Fill option.
25.4.3 Fill the area
The Fill option allows you to expand or contract the content of an element to fully
occupy the space allocated to it. You’ll most likely use this option in backdrop scenar-
ios where you want an Image to serve as wallpaper. Listing 25.8 shows what the Fill
option does to Walker’s picture.
Result:
XAML:
<Image x:Name="myImage" Width="300" Height="200"
       Source="Assets/man.png" 
       Stretch="Fill" />
Walker looks a little bloated (it’s water weight, trust me) in listing 25.8 because,
although the Fill option will expand to ensure that every pixel allotted to an element
Listing 25.7
A uniformly stretched Image with a photo larger than the element
Listing 25.8
An Image using the Fill option to stretch an image

647
Summary
is used, the aspect ratio of the content won’t be preserved. Because of the oblong
dimensions of the photo, the photo is stretched horizontally—in turn, horizontally
stretching Walker. 
 Sometimes, you may need the flexibility to fill an element while maintaining the
aspect ratio. For these circumstances, you have the UniformToFill option.
25.4.4 UniformToFill
As the name implies, this option is a hybrid between the Uniform and Fill options.
The content within an element will maintain its aspect ratio while filling the entire
bounding area. If the content has a different aspect ratio than the housing element,
the overflowing content will be clipped. See listing 25.9 for a small sample using our
friend Walker.
Result:
XAML:
<Image x:Name="myImage" Width="300" Height="200"
       Source="Assets/man.png" 
       Stretch="UniformToFill" />
Listing 25.9 illustrates how a raster-based graphic can become pixelated when
inflated. It also shows how the aspect ratio is maintained as the picture is enlarged to
fill every allocated pixel. As you’ve probably noticed, Walker’s legs are removed from
this picture. This is because the bottom edge has been removed to ensure that the
image fits within the allocated boundaries.
 Stretching can help you address a wide variety of filling situations. Silverlight
allows you to easily address any type of stretching situation through the Stretch prop-
erty. This property can be used with the Image and MediaElement items discussed ear-
lier in this chapter. Interestingly, the Stretch property isn’t supported by the
MultiScaleImage control. But with those powerful deep-zooming capabilities, does it
make sense to stretch? I think not.  
25.5
Summary
In this chapter, you explored several ways of working with bitmap (also known as ras-
ter) images. Silverlight natively supports JPEG and PNG images in the Image element
but provides facilities for you to be able to construct any type of image you’d like using
direct pixel access with the WriteableBitmap.
Listing 25.9
An Image using the UniformToFill Stretch option

648
CHAPTER 25
Working with images
 The WriteableBitmap allows you to construct images from existing UI elements,
from existing images, or even from individually placed pixels. This supports countless
scenarios from screen thumbnails, to video stills, to games and paint programs.
 For truly large images, or collections of large images, Silverlight provides the
MultiScaleImage control, also known as Deep Zoom. Deep Zoom supports images in
the millions to billions of pixels, allowing for very fast enlargement of specific areas
while minimizing the amount of memory, processing power, and bandwidth used.
 All of the image types support various stretch options to allow them to conform to
the shape of the container they’re placed in. Silverlight smoothly resizes images, pre-
serving aspect ratio if you desire.
 Along with media (see appendix B of the ebook) and vector graphics, bitmap
images round out the graphical presentation capabilities of Silverlight, helping to put
the “rich” in rich internet application. But everything you’ve learned about so far has
been two dimensional. In the next chapter, you’ll look at an API introduced in Silver-
light 5 to enable rich visualizations and gaming: the 3D API.

649
Introduction to 3D
Some of you may remember the Commodore Amiga computer. I never owned one
(I had a Commodore 128 and then an IBM PS/1 286, after which I built every PC
I’ve owned), but my best friend had the cool Amiga 500,1 only slightly tarnished
with my drool. The thing that made the Amiga series so famous when first released
was this one demo called the Boing ball. The Boing ball was a 3D red-and-white ball
that bounced across the screen, with basic physics, shading, and a sound that made
it seem like the ball was full of cement and old cars or something (it’s actually a
sample of a foam bat hitting an aluminum garage door). Nevertheless, for 1985 this
was an absolutely amazing demo. Around that same time, the Apple Mac was a
black-and-white tiny-screened machine and PCs were using CGA neon four-color
palettes. It would take half a decade or more before PCs and Macs mostly caught up
This chapter covers
■
Using the Silverlight/XNA API and templates
■
Understanding vertices and primitives
■
Creating and rendering basic 3D geometry
1  You may be surprised to learn that the Amiga community is still quite alive and well, even to the point of
continually releasing new versions of the operating system. For example: http://bit.ly/Amiga2011.

650
CHAPTER 26
Introduction to 3D
to what the Amiga could do with graphics and sound, and only then with expensive
add-ons.
3D captivated the audiences back then because they had never seen it before on a
computer they could actually afford. It continues to captivate audiences today due to
increased levels of realism in 3D rendering and the maturity of the design tools. In
fact, most cartoons these days are drawn on computers, and although many are ani-
mated using Flash, a large percentage are animated using 3D software like Autodesk
Maya and NewTek’s LightWave.
 In this chapter, I’ll go over some of the basic concepts of Silverlight 3D, where the
classes are located, how it works, and what the system requirements are. Next, you’ll
use the built-in project templates to create a new Silverlight 3D application. Once you
have the project set up, you’ll start with rendering simple shapes so that you can better
understand the basic types and events in use. You’ll look at the most basic types,
including vertices and the triangle-based primitives. From there, you’ll move to 3D
shapes, specifically a sphere. As part of that, I’ll show you one approach to generating
3D geometry at runtime. By the end of this chapter, you’ll have a simple 3D sphere
rendering in Silverlight.
26.1
3D—a natural way of interacting with information
When I talk about 3D at conferences, I invariably get at least one evaluation back with
a comment stating that “3D isn’t useful for business applications.” When I hear that, I
feel like quoting the Emperor from Return of the Jedi: “Now you will pay the price for
your lack of vision!” Unfortunately, I haven’t yet figured out how to get lightning to
shoot from my fingertips.
3D isn’t just about games and Toy Story, Jimmy Neutron, or The Fairly Odd Parents any
more than pencil sketches are just about doing geometry homework. 3D design and ani-
mation have an important place in the business world because it’s often a natural way
of interacting with information on-screen. Here are two examples from my own expe-
rience as a developer. The first is for an insurance company application I worked on;
the second was shown to me in 2009 by a developer and a designer in the community.
The Glass Claims Insurance Application. Back in the .NET 1.1 timeframe, I was respon-
sible for designing the UI for a Windows Forms application for a large insurance com-
pany. The application was used by agents to take information about automobile glass
damage from their customers. It was used in the office for phone calls and in the
claims centers for in-person assessments. 
 The decision about whether or not to replace or repair a car’s window is a complex
one. If, for example, you have two cracks over a certain length, it’s cheaper to replace
the window. If you have more than one chip within a certain distance of another chip
or crack, it can also be cheaper to replace the window. The decision to repair or
replace comes down to real money on the part of the insurance company.
 The UI for the application needed a good way to place indicators of damage on a
model of the car. Their mainframe system required that they use cryptic codes to indi-
cate locations and types of damage, and even then the location was only approximate.

651
3D—a natural way of interacting with information
The customer really wanted 3D (they actually asked for it), so they could quickly zip
around the model of the car, drawing cracks and chips. But the technology available to
us at the time and, quite frankly, our lack of knowledge, kept us from being able to
deliver on that. Instead, we opted for a flattened 2D version they could draw on. It was
nice, but it lacked that extra bit that could have put this application over the top.
The WPF 3D Closet Configurator. Shortly after I joined Microsoft in fall 2009, I
attended the Professional Developers Conference (PDC). While there, I talked to a
developer from Europe and a local designer who had together created a cool sit-down
in-store closet configurator application in WPF.2 European homes tend to be smaller
than American homes, so storage space is taken seriously. Configuring a closet for the
maximum use of that space can be a somewhat lengthy process.
 The application they built was used in-store (like an upscale European version of a
big-box home store) and run by sales clerks with customers sitting next to them. The
clerk positioned 3D items on the screen: drawers, shelves, hangers, etc. to optimize the
use of space. While that was happening, the application built a list of all the pieces
needed. When complete, customers had 2D and 3D drawings of the final closet, a com-
plete bill of materials, and an exact price for everything they needed. This approach
was both more enjoyable and more efficient than looking in catalogs or typing codes
into a computer.
 It may not have had 300 text boxes on a battleship-gray forum, but there’s no
doubt in my mind that that was a business application, and a well-executed one at
that. There are many more examples of enhancing the experience using 3D for visual-
ization or input. Once you have the skills and knowledge, you’ll find many other
opportunities where 3D can make your application that much more usable or help it
stand out in the crowd.
 Now, to get back to the Amiga. The Amiga didn’t start it all, but it certainly popu-
larized 3D. It was also one of the first consumer machines used in the production of
3D graphics on television (such as Babylon 5) and film. So, in tribute to the little Amiga
my friend had, and to the Amiga 1000 that started it all,3 and to show off what Silver-
light is capable of, I decided to take inspiration from the Boing ball demo for the sam-
ple you’ll start in this chapter and complete in the next. In these two chapters, you’ll
build a simple animated bouncing ball demo, minus the physics simulation, to show-
case the 3D capabilities of Silverlight. 
 This chapter isn’t intended to be a full primer on XNA and 3D, but more a practi-
cal one on how to use those technologies inside Silverlight. If you want to learn more
about these technologies, most of the things you’ll learn about XNA 4 on the web
apply to the version that’s in Silverlight. Plus, in general, 3D concepts such as matrices
and vertices are universal.
2 You can see my video interview showing the application here: http://bit.ly/WPF3dCloset. 
3 Want to see some mid-1980s hardware demos that blew PCs and the Mac out of the water? See these two videos
on YouTube. First is the Boing ball that’s the inspiration for the 3D in this chapter: http://bit.ly/AmigaBoing.
Second is an iPhone-like shape/shadow real-time 3D demo: http://bit.ly/AmigaRT3D. 

652
CHAPTER 26
Introduction to 3D
26.2
The Silverlight/XNA 3D API
3D in Silverlight is based on a subset of the XNA Game Studio 4.0 3D core libraries,
which themselves are a .NET layer over the Windows-only DirectX technology. DirectX
is a C/C++ API for very low-level graphics programming, a driver specification, and also
a ton of helper functionality for creating graphics applications and games. It was
designed primarily to make games a reality on Windows but has since ended up just
about everywhere, including as the underlying technology for Windows Vista and Win-
dows 7/8 desktop rendering.
NOTE
XNA is not a high-level 3D engine with lighting and physics and what-
not, but rather the building blocks you or others can use to build a 3D render-
ing engine for specific application needs. A great example of a 3D engine with
all of that in place is the Babylon 3D Toolkit for Silverlight. This is freely avail-
able on CodePlex, so be sure to take a look at it there.
Silverlight supports what’s known as the XNA “Reach” profile. That means that it
works on Windows XP and above on Shader Model 2.0 or above DirectX 9–compatible
video card. The video card is a hard requirement; there’s no software fallback render-
ing. Not to worry, though, most PCs and laptops created in the past few years support
these levels. You’ll only run into problems if you try to repurpose that old Windows 3.1
machine.
26.2.1 Rendering pipeline
Silverlight supports Shader Model 2, not 3. This is important if you code your own
custom shaders or try to use shaders created by other people. The difference between
the two models has to do with what support they require on the video card as well
as differences in the shader programming language, number of available registers,
and more.
 Unlike 2D shaders, 3D shaders are code that run directly on the GPU, outside the
Silverlight sandbox. Because of that hardware-level access, they can potentially be
used as a way to gain access to your computer for malicious purposes. Windows XP sys-
tems are especially vulnerable to this because the old driver model is nowhere nearly
as protected as the newer model. Silverlight 5 addresses this security issue by requiring
either elevated trust or end-user confirmation when you want to use the 3D system.
 In addition, you must have the Silverlight EnableGPUAcceleration setting turned
on in order to use 3D rendering. Unlike WPF, Silverlight has no fallback to software
rendering when the hardware isn’t up to snuff.
 In a nutshell, the rendering architecture of 3D rendering in Silverlight looks like
figure 26.1.
 The rendering system takes vertices and primitives, which I’ll cover shortly, pro-
cesses them, then moves them to the pixel-processing step. Pixel processing takes tex-
tures (images applied to the surface of 3D geometry) and combines them with the
geometry to produce the final on-screen pixels.

653
The Silverlight/XNA 3D API
The XNA libraries are split across the Silverlight runtime, the Silverlight SDK, and the
Silverlight toolkit. The team split the assemblies this way to minimize the runtime
footprint of applications that don’t use 3D—the majority of Silverlight applications
out there. Conveniently, the 3D project templates take care of adding all the appropri-
ate references for you.
26.2.2 Project templates
The Silverlight toolkit comes with several 3D project templates. You can get pretty far
without using the templates, but once you try to do something like load content,
you’ll wish you started with them. It’s also difficult to add a content project to an exist-
ing solution, so it’s best to start with the full project template.
 The first step is to download and install the Silverlight 5 toolkit from http://
silverlight.codeplex.com. The Silverlight 5 version of the toolkit (I’m using the Sep-
tember 2011 build to code against, but a newer version should be out by the time you
read this) includes the Silverlight 3D Project templates as well as a number of helper
libraries.
 Next, you need to install XNA Studio 4 in order to use the 3D project templates
included with the toolkit. This free download is also linked to from the toolkit site.
Finally, if you plan to modify or compile any custom shaders in your project (the
default template, as of this writing, uses one named CustomEffect.slfx), you’ll need to
also install the latest DirectX SDK for Windows. It’s a big download, so budget some
time and bandwidth to get it.
 Once you have the toolkit and other bits installed, create a new Silverlight 3D
Application project. I creatively named mine Silverlight3DExample. Figure 26.2 shows
the correct project template selected in the New Project dialog.
 When the solution loads, you’ll see four different projects. The Silverlight project
and web project are ones you should be familiar with by now. The two content projects
are for loading assets like models, sounds, and images. They have a special relationship
Figure 26.1
The Silverlight 3D rendering pipeline. Source: MSDN Silverlight 3D Overview.

654
CHAPTER 26
Introduction to 3D
with the Silverlight application which (as of this writing) isn’t represented in the solu-
tion. If you crack open the Silverlight application’s project file, though, and search for
the word “content,” you’ll see how the two are linked.
 The Silverlight application includes a basic Scene class as well as a custom vertex
type and a cube object. I’ll talk about vertices later. The cube is some prebuild geome-
try. That’s no fun, though! Ignore it. Delete it. Do whatever you need to do to pretend
it doesn’t exist. You’ll implement your own geometry so you’ll need to delete it later
anyway.
 Open the project properties for the Silverlight 3D application and make it an out-
of-browser application. Don’t make it elevated permissions for now; I’ll get to that
shortly. You want it left as is so you can do a little sleuthing in the next section. 
26.3
Detecting capabilities with the GraphicsDeviceManager
Before you can use 3D, you should check to see if it’s available on the current system.
The user may have declined to permit it, the graphics card may not support it, or
something else may be wrong. Rather than simply show blank UI, it’s better to tell the
user what’s going on.
 The GraphicsDeviceManager will be the primary mechanism for detecting the capa-
bilities. But you’ll need to do a little work in XAML to make sure you have something
Figure 26.2
The New Project dialog showing the selected Silverlight 3D Application template

655
Detecting capabilities with the GraphicsDeviceManager
meaningful to show in either case. One thing I like to do for this and other similar
situations in Silverlight is to have the UI split into two different grids. The first grid is
shown when the feature can’t be used. The second grid is shown when the feature usage
checks out.
 Listing 26.1 shows an example of this using two grids: Overlay3DNotAvailable
and MainContent.
<UserControl x:Class="Silverlight3dApp.MainPage"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    mc:Ignorable="d"
    d:DesignHeight="300" d:DesignWidth="400">
  <Grid x:Name="LayoutRoot" Background="White">
    <Grid x:Name="Overlay3DNotAvailable"      
          Visibility="Collapsed"
          Background="Black">
      <TextBlock Text="3d Graphics are not available."
                 HorizontalAlignment="Center"
                 VerticalAlignment="Center"
                 Foreground="Orange"
                 TextWrapping="Wrap" />
    </Grid>
    <Grid x:Name="MainContent"                
          Visibility="Collapsed"
          Background="Black">
      <TextBlock Text="3d content will go here."
                 HorizontalAlignment="Center"
                 VerticalAlignment="Center"
                 Foreground="Orange"
                 TextWrapping="Wrap" />
    </Grid>
  </Grid>
</UserControl>
When you pasted in this code, you got rid of the “myDrawingSurface” from XAML.
That’s okay—you’ll replace it later. I’m not a fan of the “my” naming convention in
any case. But to be able to compile, you’ll need to comment out the offending lines
that reference it in the code-behind. I’ll address that shortly so don’t worry about it
for the moment.
 When the application first starts up, both grids are collapsed and therefore invisi-
ble. It will be up to your code to decide which grid should be displayed.
 Next you need to add a little code to make use of the two different parts of the UI.
For this you’ll use the GraphicsDeviceManager class. This is a singleton class that
exposes an instance of itself through the Current property. The instance exposes two
Listing 26.1
The XAML UI with information overlay
Overlay
3D goes here

656
CHAPTER 26
Introduction to 3D
properties and an event that are useful when checking for the availability of 3D graph-
ics. Table 26.1 lists them.
By using the GraphicsDeviceManager’s properties, you can quickly and easily tell if
you’ll be able to use 3D features in Silverlight. In addition, by ensuring you pay atten-
tion to changes in the render mode by using the RenderModeChanged event, you can
build a more robust application capable of reacting properly to system changes.
 Listing 26.2 shows how to use the GraphicsDeviceManager to enable the correct
portions of the UI and inform the user of any changes to the render capabilities.
public partial class MainPage : UserControl
{
  public MainPage()
  {
    InitializeComponent();
    Loaded += new RoutedEventHandler(MainPage_Loaded);
  }
  void MainPage_Loaded(object sender, RoutedEventArgs e)
  {
    GraphicsDeviceManager.Current.RenderModeChanged +=  
                        OnRenderModeChanged;
    if (GraphicsDeviceManager.Current.RenderMode == 
                                   RenderMode.Unavailable) 
      Disable3dUI(GraphicsDeviceManager.Current.RenderModeReason);
    else
      Enable3dUI();
  }
  void OnRenderModeChanged(object sender, RenderModeChangedEventArgs e)
  {
Table 26.1
GraphicsDeviceManager members used when checking for the availability of 3D graphics
Member
Description
RenderMode property
Gets the status of 3D rendering capabilities. In Silverlight, because 
there’s no software rendering, it’s either Unavailable or Hardware. 
RenderModeReason property
An enumeration of possible reasons for the RenderMode value. 
Using this, you can determine if the cause is a failure to set GPU 
acceleration, blocked by security, you have an incompatible card, or 
3D is temporarily unavailable for some other system reason, such as 
a Windows XP lock screen.
RenderModeChanged event
This event is raised whenever the RenderMode property changes. 
The passed-in event args include all the information you’d need about 
the current and previous render modes.
Listing 26.2
Checking for 3D availability using the GraphicsDeviceManager class
RenderModeChanged
Check 
RenderMode

657
Detecting capabilities with the GraphicsDeviceManager
    if (e.RenderMode == RenderMode.Unavailable)
      Disable3dUI(e.RenderModeReason);
    else
      Enable3dUI();
  }
  private void Disable3dUI(RenderModeReason reason)
  {
    string message = "3d Not Available. Reason: " + reason.ToString();
    Overlay3DNotAvailable.Visibility = Visibility.Visible; 
    MainContent.Visibility = Visibility.Collapsed;
    MessageBox.Show(message);
    Debug.WriteLine(message);
  }
  private void Enable3dUI()
  {
    Overlay3DNotAvailable.Visibility = Visibility.Collapsed;
    MainContent.Visibility = Visibility.Visible;  
  }
}
Now you can run the application. You should see a MessageBox informing you that 3D
isn’t available. You’ll also see the “3D is not available” overlay UI once you dismiss the
message box.
 Now, enable GPU acceleration. On a web page, you do so by using the object tag
parameter:
<param name="EnableGPUAcceleration" value="true" />
For this project, though, I’d like to simply make it an elevated trust out-of-browser
application. This isn’t a requirement, but for the reasons mentioned in the overview
of this chapter, it makes security easier when you go to run the application outside of
the development environment.
 If you haven’t already, open the project properties and select the option to enable
running out-of-browser, as covered in chapter 5. Next, click the out-of-browser settings
button, and check both Use GPU Acceleration and “Require elevated trust when run-
ning outside the browser.”
 Now, run the application again. You shouldn’t see the MessageBox this time
around but instead should see the placeholder for 3D content. If you see the place-
holder, you’re ready to proceed to the rest of the chapter. If you see a message about
not having 3D capabilities on your system, you may want to first update your graphics
driver from the vendor’s website.4 If you still see that message, you may be on a very
old or unsupported piece of hardware. There aren’t a lot of those out there, especially
4  All the cool kids know that you don’t get your graphics drivers from Windows Update if you’re using a discrete
graphics card. Instead, go to the nVidia or AMD site and download the correct drivers directly.
Error UI
3D UI

658
CHAPTER 26
Introduction to 3D
in developer hands, but it happens. In that case, I can recommend only that you beg,
borrow, and steal until you have a more modern machine with 3D capabilities.
 So far, you’ve used the RenderModeChanged event simply to enable or disable some
UI. In a real application, this is the place you’ll want to refresh your data. For exam-
ple, if the render mode changes from unavailable to available, you’ll have to rebuild
the objects you need to support 3D rendering in your application. Without 3D graph-
ics available, you wouldn’t want to bother loading all that data in memory.
 The GraphicsDeviceManager and GraphicsDevice together have a lot of addi-
tional features, which you’ll explore in many of the remaining examples in this chap-
ter. Before you explore the types that make up shapes to render, let’s wire up the
drawing surface to provide you with somewhere to render to. 
26.4
Using the DrawingSurface
The regular Silverlight graphics system is a retained mode system. That means that you
define the structures for rendering (like a rectangle or some text), and Silverlight
remembers it from frame to frame. Another type of rendering, often used in games and
in 3D,5 is called immediate mode rendering. In this type of rendering, you’re responsi-
ble for drawing the entire frame of graphics on-screen each time it’s rendered.
 Because of this different approach in rendering, Silverlight requires a rectangle on
the screen where the 3D content can be placed, rather than just loosely intermingling
it like any other UI element or requiring an actual new Windows-recognized operat-
ing system window like many other desktop technologies do. This rectangle, defined
by the DrawingSurface element, is the virtual window in your application that will be
owned by XNA/DirectX.
 Because the DrawingSurface is a FrameworkElement, you can use it in XAML just
like any other element, but much like the MediaElement, it’s a window into another
rendering system. Update the MainPage.xaml file MainContent grid so it looks like
the next listing. You can leave the original TextBlock if you wish, or comment it out as
done here.
<Grid x:Name="MainContent"
        Visibility="Collapsed"
        Background="Black">
    <!--<TextBlock Text="3d content will go here."
                HorizontalAlignment="Center"
                VerticalAlignment="Center"
                Foreground="Orange"
                TextWrapping="Wrap" />-->
  <DrawingSurface x:Name="MainDrawingSurface"      
                  Draw="MainDrawingSurface_Draw">
    <DrawingSurface.CompositionMode>
5 And good old GDI/GDI+ if you ever had the pain or pleasure of overriding WM_PAINT to do your drawing.
Listing 26.3
The DrawingSurface element on a page
DrawingSurface 
element

659
Project structure: the scene and objects
      <OffscreenCompositionMode PreferredMultiSampleCount="3"/> 
    </DrawingSurface.CompositionMode>
  </DrawingSurface>
</Grid>
Listing 26.3 shows how to put the drawing surface on a page in a Silverlight applica-
tion. I mentioned that the DrawingSurface is a FrameworkElement. Because of that, it
can participate in composition and properly work with z-ordering and other XAML
features. You can overlay XAML to partially obscure the DrawingSurface, for example.
This is something that business application designers will simply expect, but for game
designers, that’s the holy grail of 2D and 3D composition efficiency. 
 Antialiasing is the generic name for a number of algorithms that help remove the
staircase effect on lines. If we had a higher density of pixels on the screen than our
eyes could detect, this wouldn’t be necessary. The reality is, displays haven’t yet caught
up. If you want to support antialiasing for your own project, the PreferredMulti-
SampleCount property is what you need to use. I broke out the CompositionMode
property because this is something you can set only in XAML.6 The higher the num-
ber, the slower the rendering, so be careful of how much smoothness you ask for.
 In the markup, I wired up the Draw event exposed by the DrawingSurface. The
Draw event is raised whenever the drawing surface is invalidated—meaning whenever
it needs to be drawn. If you follow the usual approach of drawing items inside the
event handler and then calling InvalidateSurface, it’ll be called for each frame to
be rendered to screen.
TIP
If you’re looking for a place to put code to handle the screen resizing—
for example, to recalculate what you put in 3D space—the DrawingSurface
SizeChanged event is the recommended location.
If you run the application now (if you pasted the code rather than typing it by hand,
make sure you have the Draw event handler MainDrawingSurface_Draw:stubbed out),
you’ll get a blank 3D rendering space, most likely purple.7
 You now have an application that’s capable of rendering 3D content. But you don’t
yet have anything in place to actually render. You’d be forgiven for assuming it’d be a
simple matter to throw a few shapes out there and they’d easily render. 3D rendering
is much more complex than that. For that reason, you’ll need to add structure and a
fair bit of code to the application before you’ll see results. 
26.5
Project structure: the scene and objects
3D programming doesn’t start to make sense until you see an actual shape on-screen.
If there’s any one single chapter where I’d recommend you type in the code and
experiment a bit to see what happens, this would be that chapter.
6 This was true in the prerelease builds and is expected to remain true in the released product. Don’t just take
my word for it, though; try it out both in markup and in code.
7 As a reviewer from the Baltimore area pointed out, it’s a nice Ravens purple. Go Ravens!
Anti-aliasing

660
CHAPTER 26
Introduction to 3D
The problem is, 3D rendering systems show you absolutely nothing until you have all
the major pieces in place. If I added bits to the code as they were explained, you
wouldn’t see anything rendered on-screen until the last few sections in this chapter. I
don’t know about you, but when talking about something like 3D, I want to see pixels!
 In this section, you’ll structure the project to make it easier to plug additional
pieces in later. There will be a number of things, like the camera, projections, shaders,
and more, that will be included in here in the barest possible way simply to make sure
you can render on-screen.
 You can avoid these problems if you use a 3D toolkit like Babylon 3D. Although I’m
a big fan of that toolkit, I’d rather show you how Silverlight is working and let you
make toolkit decisions yourself with the underlying knowledge in place. 
 But in acknowledgement of the popularity and, quite frankly, necessity of toolkits,
I’ve structured this example application following patterns and APIs that are as close
to the Babylon approach without adding extra work. When you finish the example,
you’ll have a basic 3D application architecture that will help you understand 3D as well
as enable you to, relatively easily, port to a 3D toolkit later if you wish. Figure 26.3
shows the architecture.
 In this section, you’ll build the skeleton of the application architecture. There will
be a fair bit of code in place you don’t yet understand, but by the end of the next
chapter, all will be revealed. The code you create here will provide the minimum
amount of structure necessary to avoid a constant refactoring, as well as provide the
support objects required to render 3D content.
26.5.1 The scene
When rendering in 3D, you typically need some sort of master object that defines all the
parameters for what you want to render. It includes the angles through which the user
will see the content, a list of the content itself, and other things like lights and effects. 
 The object responsible for managing all of that information is typically called a
scene or stage, taking inspiration from movie and theater, respectively. Scene is gener-
ally the more common name, and more appropriate for having multiple instances, so
you’ll use that here.
 A 3D system could have multiple scenes. Consider for a moment the old 2D video
games where you had a “walking around in the wildness” mode, and then a special
Figure 26.3
A high-level look at the 
architecture of the 
sample application

661
Project structure: the scene and objects
“fighting the bad guy” mode. Pokemon and similar come to mind, but mostly because
my son has recently discovered the brain-melting pastime of playing it on my wife’s
ancient Gameboy.8 To make it easy to render, each of those could be set up as separate
scenes, with their own lighting, objects, camera, and everything else required. Each
scene should be entirely self-contained. The rendering system should simply ask it for
what needs to appear in a particular frame.
 You could even extend this idea to allow each scene to have a reference to a User-
Control that contains all the 2D Silverlight content you wish to overlay on the scene.
The scene itself could serve as the view model (chapter 33) for that overlay content, so
you get the best of both worlds.
 In the root of your Silverlight application, delete the stock Scene class, then create
a new class named Scene, with the code shown in listing 26.4.
using System;
using System.Collections.Generic;
using System.Windows.Controls;
using System.Windows.Graphics;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
namespace Silverlight3dApp
{
  public class Scene
  {
    public Color BackgroundColor { get; set; }
    public Camera Camera { get; private set; }
    public ContentManager Content { get; private set; }
    public List<SceneObject> Objects =
               new List<SceneObject>();            
    public GraphicsDevice GraphicsDevice       
    {
      get { return GraphicsDeviceManager.Current.GraphicsDevice; }
    }
    public Scene()
    {
      Content = new ContentManager(null, "Content");
      Camera = new Camera();
      Camera.SetFieldOfView(GraphicsDevice.Viewport.Width,
                            GraphicsDevice.Viewport.Height);
      LoadObjects();
    }
8  It was hidden in a box, high up on a shelf, but somehow he still found it. Pretty sure he can sense the presence
of ICs and LCD displays through some freaky geek telepathy.
Listing 26.4
The Scene class
Create list of 
Scene objects
Get the 
device to 
render on

662
CHAPTER 26
Introduction to 3D
    public void LoadObjects()               
    {
    }
    public void Draw()
    {
      GraphicsDevice.Clear(
               ClearOptions.Target | ClearOptions.DepthBuffer, 
               BackgroundColor, 1.0f, 0);
      foreach (SceneObject o in Objects)
      { 
        o.Draw(this);                            
      }
    }
  }
}
This code sets up the main class in your 3D system: the Scene class. The scene has a
background color to be used when nothing is renderable in a particular location, a list
of objects to be rendered, a camera to define how you see the scene, and the device
the scene is to render on. It also includes a reference to the ContentManager class pro-
vided by the Silverlight toolkit. You’ll use that later in the chapter when you work with
textures.
 The Draw method is the only interesting public method in the scene. This is what
will be called from the DrawingSurface for each and every frame to be rendered. 
 The compiler will tell you that it doesn’t see the SceneObject or Camera types
defined anywhere, so you can’t yet compile or run. You’ll add those shortly. But before
you do that, let’s update the MainPage code-behind to use the new Scene class.
 Listing 26.5 shows the MainPage updates that use the Scene class inside the Draw
event of the DrawingSurface.
private Scene _scene;
private void SetupScene()
{
    _scene = new Scene();
    _scene.BackgroundColor = new
        Microsoft.Xna.Framework.Color(0xaf, 0xcf, 0xff);   
}
private void MainDrawingSurface_Draw(object sender, DrawEventArgs e)
{
    if (_scene == null)
        SetupScene();
    if (_scene != null)
    {
        _scene.Draw();                             
Listing 26.5
Updating the MainPage code-behind to use the scene
You’ll create objects
here in the next 
sections
Render each
object
Color
Draw the scene

663
Project structure: the scene and objects
        e.InvalidateSurface();                    
    }
}
The listing sets up the scene in support of rendering in the Draw event. The majority
of the work is done inside the scene itself, so all this does is create the scene and set its
background color.
  It’s important to note that the XNA Color class isn’t the same as the Silverlight/
XAML Color class. Because of that, you’ll need to make sure you’re using the correct
one. In this case, I fully qualified the name, but you could use a using alias like this if
you wanted to:
using xnafx = Microsoft.Xna.Framework;
If you set up that alias, you could use xnafx.Color when referring to the Color class.
You could also remove the Silverlight namespaces from the using statements, but
because you’re in the code-behind for a page, that’s probably not a good strategy.
 The Draw event handler is called once for each frame to be rendered. Had I not
included the call to InvalidateSurface, the handler would be called once and only
once unless XNA detects a refresh is needed for some external reason. The
InvalidateSurface call tells XNA “Once you’ve completed processing this frame’s
data, go ahead and request the next one—I’ll probably have changes.” This is espe-
cially important for systems that animate. In fact, you could get away without this call
until you learn about animation later in this chapter. 
 Because not everyone who develops in Silverlight 3D is going to need maximum
frame rate rendering, making effective use of this method can save CPU and graphics
card cycles. To force a call to the Draw event from outside the event, for example, in
response to some mouse movement or a click on a Rotate button, call the Invalidate
method on the DrawingSurface directly.
 In this code, the first time the Draw event is called, you make a call to set up the
scene. This is done inside the Draw event handler because certain XNA object meth-
ods—specifically some of the ones on GraphicsDevice—are available only during that
time, on that thread. You won’t have to worry about them in our example, but if you
expand on it, you may need to.
 The Scene class included a list of SceneObject instances. That list represents all
the renderable geometry in the scene.
26.5.2 Renderable scene objects
Scenes typically have a number of geometry objects that must be rendered as part of
the scene. Consider a scene in your favorite movie: it probably had a number of
planes for the ground, sky, and so forth, plus maybe buildings or other structures, and
actors or other moving items. In our project structure, each of those things would be
represented as a SceneObject.
We want to 
draw it again

664
CHAPTER 26
Introduction to 3D
 You’ll implement specific SceneObjects later in the chapter. To start, listing 26.6
has the base class they’ll all use. Create a folder named Model and place this code in a
class named SceneObject in that folder. 
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework;
using Silverlight3dApp;
namespace Silverlight3DExample.Model
{
  public abstract class SceneObject
  {
    public GraphicsDevice Device { get; set; }
    public Effect Effect { get; set; }
    protected Matrix _worldMatrix = Matrix.Identity;
    public int VertexCount { get; protected set; }
    public abstract void LoadContent();        
    public abstract void Draw(Scene rootScene);     
    protected float _x;
    public float X
    {
      get { return _x; }
      set { _x = value; UpdateWorld(); }
    }
    private float _y;
    public float Y
    {
      get { return _y; }
      set { _y = value; UpdateWorld(); }
    }
    private float _z;
    public float Z
    {
      get { return _z; }
      set { _z = value; UpdateWorld(); }
    }
    public virtual void UpdateWorld()              
    {
      _worldMatrix = Matrix.CreateTranslation(X, Y, Z);
    }
  }
}
The X, Y, and Z coordinate values are primarily for use when you animate later. Their
purpose is to position the object in world space through the use of the world matrix.
I’ll cover all of these concepts when I discuss matrices.
Listing 26.6
The SceneObject class
Create geometry
Draw object
For movement 
and animation

665
Project structure: the scene and objects
 The Effect class encapsulates a lot of the rendering pipeline in XNA. You’ll learn
more about that when I cover effects and shaders later in the chapter.
 The SceneObject class is the base class from which you’ll derive all of the objects
you want to render. In the examples in this chapter, the class is optimized for simple
types that have only a single mesh of points, not multiple connected objects as you
might see on something complex like a helicopter with spinning rotors and a weapons
system. Similarly, something like a 3D bar graph would likely be made up of a number
of individual cubes as opposed to just a single set of vertices.
 The final item you need to place in the scene is a camera. This represents the view
the user will see.
26.5.3 The camera
The concept of a camera is a convenient way to render the scene. It defines, through
the use of some matrix math, the view the user will have when looking at the screen.
Your implementation will support only a single camera, but it’s common to allow mul-
tiple cameras to exist in a scene, cutting between them as you want to focus on differ-
ent items. This is similar to how it might be done on live TV.
 Listing 26.7 shows the basic implementation of the Camera class. Although the class
must be fully defined here to enable rendering to work, I’ll defer discussion on the
particulars of how it works until later in this chapter. 
using Microsoft.Xna.Framework;
using Silverlight3DExample.Model;
namespace Silverlight3DExample.Model
{
  public class Camera
  {
    public Matrix View { get; private set; }
    public Matrix Projection { get; private set; }
    public Camera()
    {
      X = 0; Y = 0; Z = 5;                          
      TargetX = 0; TargetY = 0; TargetZ = 0;     
    }
    public void SetFieldOfView(int viewportWidth, 
                               int viewportHeight)   
    {
       Projection = Matrix.CreatePerspectiveFieldOfView(
                MathHelper.ToRadians(45),
                (float)viewportWidth /
                (float)viewportHeight,
                1.0f, 100.0f);
    }
Listing 26.7
The basic Camera class
Location and aim
Updated projection
matrix

666
CHAPTER 26
Introduction to 3D
    private float _x;
    public float X
    {
      get { return _x; }
      set { _x = value; UpdateView(); }
    }
    private float _y;
    public float Y
    {
      get { return _y; }
      set { _y = value; UpdateView(); }
    }
    private float _z;
    public float Z
    {
      get { return _z; }
      set { _z = value; UpdateView(); }
    }
    private float _targetX;
    public float TargetX
    {
      get { return _targetX; }
      set { _targetX = value; UpdateView(); }
    }
    private float _targetY;
    public float TargetY
    {
      get { return _targetY; }
      set { _targetY = value; UpdateView(); }
    }
    private float _targetZ;
    public float TargetZ
    {
      get { return _targetZ; }
      set { _targetZ = value; UpdateView(); }
    }
    private void UpdateView()                         
    {
      View = Matrix.CreateLookAt(
              new Vector3(X,Y,Z), 
              new Vector3(TargetX, TargetY, TargetZ),
              Vector3.Up);
    }
  }
}
As I mentioned, the camera is just a convenience. What it’s really there for is as a help-
ful metaphor to enable you to compute the different matrices you need to use when
rendering. 
Updated 
view matrix

667
Vertices
 At this point, you finally have enough structure to the application to enable you to
compile and run it. Do so, and ensure there are no compile errors. You should see a
light blue window background where the purple one used to be. This is the back-
ground color of the Scene. If you want to test that, go ahead and change the code-
behind to assign a different color to the scene, and verify that’s what comes through.
 “She may not look like much, but she’s got it where it counts, kid.”
 It’s always a little scary to paste that much code in your application without a thor-
ough understanding of what it does. I’ll make it up to you over the rest of this chapter,
starting right now. The next step along the path to enlightenment is to learn about
the building blocks used when rendering 3D: vertices. 
26.6
Vertices
Have you ever worked through a dot-to-dot puzzle,
or played that “box” game on a piece of graph
paper? If you have, you may recognize that vertices
are much like the corners of the boxes, or in the
case of dot-to-dot, they’re the dots. In a 3D system, a
vertex holds its location in 3D space (x, y, z), as well
as color and potentially other information.
 The three vertices, shown in figure 26.4, are
named Top, Left, and Right just to make it easier to
refer to them in the upcoming example. But the 3D
system doesn’t know them that way; to it, they’re
simply a set of points in space. The order in which you specify them (clockwise or
counterclockwise) does have an impact, which you’ll learn about later.
 In the most basic case, using a simple vertex color shader, each vertex is defined by
a coordinate triad (X, Y, Z) and a color. The coordinates are represented using the
Vector3 structure. There are also Vector2 and Vector4 structures that are used in
other places of the framework.
 The Vector3 structure is a convenient structure used for holding three points of
data. In the case of the vertex, it holds X, Y, and Z. In the case of a color, it could be R,
G, and B. The use of these generic classes is prevalent in DirectX and is well supported
by the video card drivers. You’ll also run into the analogs of these types if you create
your own shaders.
 The structure also includes a ton of functionality for manipulating the three values
it contains. In case you were wondering why on earth these VectorN classes are so
prevalent in the framework, simply right-click one in the next listing and select Go to
Definition to see all the functions and operators it includes.
 In the rest of this section, you’ll use vertices to define a triangle and then render it
using Silverlight/XNA. The triangle will be wrapped up into a new SceneObject
named SimpleTriangle that you’ll add to the scene. This will be the first time you’ll
see any rendered pixels on-screen, so I’m sure you’re pretty excited!
Figure 26.4
A triangle showing its 
three vertices

668
CHAPTER 26
Introduction to 3D
26.6.1 Building a triangle using vertices
The simplest meaningful and visible shape you can render in 2D is a triangle. A trian-
gle is three vertices that may be used to define a surface. If you have only two vertices,
you end up with a line, which typically isn’t renderable. Only one vertex, and you get a
point. Points aren’t rendered except in the case of special particle systems and
advanced shaders that work on them.
 In listing 26.8, you’ll create a new SimpleTriangle class. This will define a triangle
using a hard-coded set of three vertices. Go ahead and create that class in the Model
folder and add the code from this listing.
using System;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework;
using Silverlight3dApp;
namespace Silverlight3DExample.Model
{
  public class SimpleTriangle : SceneObject
  {
    private VertexBuffer _buffer = null;
    public override void LoadContent()
    {
      const int z = 0;
      var leftVertex = new VertexPositionColor();        
      leftVertex.Position = new Vector3(-1, -1, z);
      leftVertex.Color = new Microsoft.Xna.Framework.Color(0xFF, 0, 0);
      var topVertex = new VertexPositionColor();
      topVertex.Position = new Vector3(0, 1, z);
      topVertex.Color = new Microsoft.Xna.Framework.Color(0, 0xFF, 0);
      var rightVertex = new VertexPositionColor();
      rightVertex.Position = new Vector3(1, -1, z);
      rightVertex.Color = new Microsoft.Xna.Framework.Color(0, 0, 0xFF);
      var vertices = new VertexPositionColor[] 
                        { leftVertex, topVertex, rightVertex };
      VertexCount = vertices.Length;
      _buffer = new VertexBuffer(
                Device,
                VertexPositionColor.VertexDeclaration,  
                VertexCount,
                BufferUsage.WriteOnly);
      _buffer.SetData<VertexPositionColor>(vertices, 0, VertexCount);
    }
Listing 26.8
Using vertices to create a simple triangle
Vertex defined
Vertex type

669
Vertices
    public override void Draw(Scene rootScene)
    {
      if (_buffer == null)
        LoadContent();
      _worldMatrix = Matrix.Identity;                 
      Device.RasterizerState = RasterizerState.CullNone;  
      Device.SetVertexBuffer(_buffer);
      ((BasicEffect)Effect).World = _worldMatrix;
      ((BasicEffect)Effect).View = rootScene.Camera.View;
      ((BasicEffect)Effect).Projection = rootScene.Camera.Projection;
      foreach (EffectPass pass in Effect.CurrentTechnique.Passes)
      {
        pass.Apply();
        Device.DrawPrimitives(PrimitiveType.TriangleList, 0, 1);
      }
    }
  }
}
The listing creates a 2D triangle in 3D space using vertices and stores it in the form of
a vertex buffer. A triangle has three corners and therefore three vertices. Each vertex
has a position in space defined using a Vector3. Because it’s 2D, it has no thickness—
no triangle does. If you were to have the camera oriented so that you were seeing the
shape edge on, you wouldn’t see a thing; the triangle is even thinner than paper Mario.
 Because the effect and its shaders that you’re using (the BasicEffect) support it,
each vertex also has a color. The left vertex is red, the top vertex is green, and the
right vertex is blue. There are other ways to define how to shade vertices, but you’re
using the simple VertexPositionColor class in this case. For clarity, I broke each ver-
tex out as a separate variable, but you could do all the work directly with array
elements.
 The VertexBuffer is the structure used by the rest of the system to process your
list of vertices. The LoadContent method uses the rendering device, which was help-
fully provided to you by the GraphicsDeviceManager via the Scene. Next, it needs the
type that corresponds to each vertex you’re using. 
 The VertexPositionColor type exposes the VertexDeclaration property, which
includes the type information. This property is the sole member of the IVertexType
XNA interface. This isn’t .NET type information—what it actually provides is the size
of each vertex in the buffer and a method for getting any extra data. This level of indi-
rection is needed to be able to support different types of shaders (a simple color
shader in our case) and vertex types, including custom ones.
 Finally, the code loads the vertices into the vertex buffer for use during the Draw
operation. All that’s left now is to load the triangle into the scene so it knows to
render it.
No movement
Render both
sides

670
CHAPTER 26
Introduction to 3D
26.6.2 Adding the triangle to the scene
You’ve defined the triangle object, but it’s just sitting out there, not attached to any
scene. To fix that, you’ll load the triangle (and its shader) from the LoadObjects
method of the Scene. Listing 26.9 has the code you’ll need to add to the Scene class.
public void LoadObjects()
{
  SimpleTriangle o = new SimpleTriangle();
  o.Device = GraphicsDevice;
  BasicEffect effect = new BasicEffect(o.Device);   
  effect.AmbientLightColor = new Vector3(1.0f, 1.0f, 1.0f);
  effect.VertexColorEnabled = true;
  o.Effect = effect;
  Objects.Add(o);
}
The code does two important things. The first is that it creates an instance of the
SimpleTriangle class and adds it to the list of objects to be rendered in the scene.
The second is it sets up a BasicEffect, which supplies the required pixel and vertex
shaders vertex.
 The BasicEffect, which I’ll cover later in the chapter, is an effect that comes with
XNA. It reads the color information from the vertices and presents the information to
XNA so that you don’t have to worry about writing pixel and vertex shaders for simple
rendering scenarios like this one. Most game engine and 3D toolkit implementations
come with their own additional shaders.
 Run the application. When it pops up, it should look like figure 26.5. It’s the
BasicEffect and the vertex colors you supplied that give each vertex its own color.
The shader is what handles the color blending between them.
Listing 26.9
Loading the triangle and its shader
XNA effect
Figure 26.5
The rendered triangle in 
all of its converted-to-grayscale-
during-book-production glory. When 
you see this in color on your PC, don’t 
be surprised if you suddenly develop a 
craving for Pink Floyd.

671
Primitives
In listing 26.8, in the Draw method is this line of code:
Device.DrawPrimitives(PrimitiveType.TriangleList, 0, 1);
This line is the critical part of the Draw method—it’s the only way that the graphics
device knows how to render the vertices. The call passed the points in to the
DrawPrimitives method, telling it to treat the points as a TriangleList starting at
the first (zero) item in the buffer and continuing for one triangle (three vertices).
What exactly is a triangle list, and what’s a primitive anyway? I’ll answer that question
in the next section.
26.7
Primitives
A vertex defines a point in 3D space. Once you connect those vertices to each other,
you get shapes.  A primitive is a shape that the rendering system understands, is opti-
mized for, and that’s commonly used to create more complex shapes. In a DirectX-
based 3D system, the two most common primitives are the triangle and the line. I’ll
concentrate on triangles in this chapter, because they’re the most useful.
 In this section, you’ll first take a brief look at the TriangleList primitive. You used
this primitive when creating the single triangle you rendered earlier, although it’s typ-
ically used to render multiple triangles. After that, you’ll learn how to use the
TriangleList primitive and apply it to the specific case of sphere tessellation. Finally,
you’ll render a sphere using the triangle strip.
Extra credit
Here’s some fun extra credit. If you take the triangle example and temporarily add
the following code to the block of code in the Draw event handler in the code-behind,
right before the call to _scene.Draw() but inside the if block, you’ll get a neat “flying
in” effect:
float cameraZ = _scene.Camera.Z - 0.1f;
if (cameraZ > 10)
    cameraZ = 0;
if (cameraZ < 0)
    cameraZ = 10;
_scene.Camera.Z = cameraZ;
The basics of animation, which I’ll cover later, involve manipulating one or more ma-
trices either on a per-frame basis, or more commonly, based on the current time. In
this case, by manipulating the camera’s Z position, you’re modifying the View matrix
Make sure you remove this code once you’ve finished ogling the cool effect. 

672
CHAPTER 26
Introduction to 3D
26.7.1 The TriangleList primitive
Any shape you see in a DirectX application
(and many other 3D rendering systems) ulti-
mately resolves down to a bunch of con-
nected triangles. Take the sphere in figure
26.6, for example.
 This sphere is defined by a large number
of connected triangles. Although the shaders
in use make it look nice and smooth on the
surface, you can see some of the hard angles
when you look at the edges against the back-
ground. In general, the more triangles you
have in your shape, the closer to the desired
shape it’ll look. But the more triangles you
have, the more memory it takes, and the lon-
ger it’ll take the graphics card to render and
shade it. That’s why older video games often
have distinct triangles in their models and try
to stick to very flat or blocky surfaces but newer ones targeting faster video cards have
far more detail.
 Most shapes you could want can be represented by a set of connected triangles.
The TriangleList is the easiest way to represent all of those individual triangles. In a
triangle list, each and every triangle you want to use is defined by a set of three verti-
ces. So, for a shape made up of 100 triangles, you’ll have 300 vertex entries. This is
true even in the very common case of a connected strip of triangles where each trian-
gle shares two points with the previous triangle in the strip.
 You can see an example of a TriangleList with one triangle by looking at the
code that rendered the SimpleTriangle. The call to DrawPrimitives tells the render-
ing system that for this array of vertices, treat it as individual triangles.
Device.DrawPrimitives(PrimitiveType.TriangleList, 0, 1);
In this case, it says to start at vertex 0 and read for 1 triangle. Silverlight, because the
TriangleList primitive is specified, will expect to see 3 vertices defined in the list. If
you don’t have at least 3 in there, you’ll get a runtime error.
 So, the TriangleList (and the other primitives) aren’t real types in the .NET
sense. They’re a specification that tells the rendering system how to treat an otherwise
arbitrary array of vertices.
 The regular triangle list (not the indexed version you’ll use in the next chapter)
isn’t necessarily the most efficient approach to specifying shapes, because it repeats a
lot of data. When working with connected triangles to form a large or complex sur-
face, you may want to consider the TriangleStrip instead.
Figure 26.6
A sphere reduced to a series 
of connected triangles. These triangles are 
usually referred to as faces. The more faces 
you have, and the smaller they are, the 
higher-fidelity the rendering. (Rendered in 
McNeel Rhino)

673
Primitives
26.7.2 The TriangleStrip primitive
You can always use vertices to specify
shapes to render. In fact, video cards
used to only deal with vertices and
shaders, leaving the rest of the process-
ing to the CPU. As their hardware got
better and their drivers much more so,
they started to be optimized for more
of the DirectX features, including
things to optimize use and numbers of
vertices. 
 Consider for a moment the two
examples shown in figure 26.7. The
top example has four triangles, which I
want to render as a complete surface, like the bottom example. I spaced them out sim-
ply to show how I’m sending the data across.
 In the top example, I specified the shape to render as four distinct triangles, each
with three points. Despite many of the vertices being the same point in space, those
four triangles give me a total of 12 vertices to pass along to the video card. In the bot-
tom example, the triangles have been optimized into a strip, which uses fewer points. 
 A triangle strip is defined by creating the three vertices for the first triangle, then
providing the additional single point, which makes the next triangle, all the way
through to the end of the strip. A triangle strip has n + 2 vertices, where n is the num-
ber of triangles. A triangle list has n * 3 vertices. That’s quite a difference in the
amount of data being processed.
 If you’ve ever wondered why some 3D games perform really well and some per-
form much more slowly, it’s scenarios like this one that start to give you some insight.
Each byte that you push to the video card takes time and space on the bus. When
you’re trying to get 30 or 60 or even 100 frames per second,9 each and every byte of
data, and each and every bit of processing counts.
 I’ll continue the exploration of triangles in just a moment. In preparation for that,
create a new class named Sphere in the Model folder. The code for that class is in
listing 26.10.
using System;
using System.Collections.Generic;
using System.Net;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework;
using Silverlight3dApp;
9  Right at this very second, someone is thinking, “I wonder if I can port Crysis and get 100 fps in Silverlight?”
Listing 26.10
The Sphere class structure
Figure 26.7
How I specify the vertices vs. how I 
want the vertices to be used. When using a triangle 
list, the triangles share common points in space but 
are completely duplicated entries.

674
CHAPTER 26
Introduction to 3D
namespace Silverlight3DExample.Model
{
  public class Sphere : SceneObject
  {
    private VertexBuffer _buffer = null;
    private float _radius = 5;
    public float Radius
    {
      get { return _radius; }
      set { _radius = value; InvalidateBuffer(); }
    }
    private void InvalidateBuffer()
    {
      _buffer = null;
    }
    public override void LoadContent()   
    {
    }
    public override void Draw(Scene rootScene)   
    {
    }
  }
}
The listing contains the class definition for Sphere. It’s almost identical to the Simple-
Triangle class you created earlier, with the exception of the new Radius property and
InvalidateBuffer method.
 The Radius property defines the size of the sphere around the central point.
When the value for the radius changes, you need to recalculate the entire vertex buf-
fer, because you’re changing the geometry of the shape. The InvalidateBuffer
method sets the buffer to null, which serves as a flag to rebuild it.
26.7.3 Tessellating a sphere
The sphere is defined with a radius, but you’ll need to convert it to triangles to render.
When you model in something other than triangles, and then convert to triangles (or
other shapes) for use with a 3D system, the process (and end result) is called tessella-
tion. A tessellation is a pattern of planes, triangles in DirectX, with no overlaps and no
gaps. There are well-known algorithms for performing tessellation on various shapes,
many taking quite different approaches.
 In this example, I used a very basic algorithm10 that results in uneven triangle sizes
across the shape, much like the Rhino 3D sphere I showed earlier. It’s not a pretty one,
10 The sphere tessellation algorithm I used can be found on this site: http://bit.ly/SphereTess. That page has a
great tutorial too. It’s in C, and doesn’t use XNA, but the algorithm information still applies.
Sphere calculation
Draw sphere

675
Primitives
and it even leaves a few artifacts, including a big seam down one side, but it’s under-
standable and, most importantly, it’s set up to use triangle strips. Update the Sphere
class’s LoadContent method using the code in listing 26.11.
public override void LoadContent()
{
  const int bandPower = 5;
  int bandPoints = (int)Math.Pow(2, bandPower);
  int bandMask = bandPoints - 2;
  int sectionsInBand = (bandPoints / 2) - 1;
  int totalPoints = sectionsInBand * bandPoints;
  double sectionArc = 6.28 / (double)sectionsInBand;
  float xAngle;
  float yAngle;
  var vertices = new List<VertexPositionColor>();
  for (int i = 0; i < totalPoints; i++)         
  {
    xAngle = (float)(i & 1) + (i >> bandPower);
    yAngle = (float)((i & bandMask) >> 1) + 
               ((i >> bandPower) * (sectionsInBand));
    xAngle *= (float)sectionArc / 2.0f;
    yAngle *= (float)sectionArc * -1;
    var vertex = new VertexPositionColor();
    vertex.Position = new Vector3(                   
      (float)(_radius * Math.Sin(xAngle) * Math.Sin(yAngle)),
      (float)(_radius * Math.Cos(xAngle)),
      (float)(_radius * Math.Sin(xAngle) * Math.Cos(yAngle)));
    vertex.Color = new Microsoft.Xna.Framework.Color(  
                      i % 0xFF, i % 0xFF, i % 0xFF);
    vertices.Add(vertex);
  }
  VertexCount = vertices.Count;
  _buffer = new VertexBuffer(
              Device,
              VertexPositionColor.VertexDeclaration,
              VertexCount,
              BufferUsage.WriteOnly);
  _buffer.SetData<VertexPositionColor>(
         vertices.ToArray(), 0, VertexCount);
}
Listing 26.11
The Sphere class tessellation code
Create points
Calculate 
next vertex
Increment color

676
CHAPTER 26
Introduction to 3D
The example in listing 26.11 is pretty much a direct port of the algorithm linked to in
the footnote. As the author put excellent information on his site, I’ll direct you there
for details. In essence, the code calculates the triangles for a band (row) across the
sphere, then flips down to the next row using a zero-sized triangle to reorient the
points. It does this until it reaches the end of the sphere.
 After the first triangle is created, the code needs only add one additional point to
make the next triangle, and then one more point to create another triangle, and so
on. This approach is practical in use, quick and easy to process, and frugal with mem-
ory. Whenever possible, you’ll want to consider using triangle strips (or indexed verti-
ces which we’ll cover later) when generating your own shapes.
26.7.4 Rendering the sphere with primitives
Once the sphere is fully tessellated, you can render it. Listing 26.12 shows how, with a
bit of animation thrown in for fun. 
public override void Draw(Scene rootScene)
{
  if (_buffer == null)
    LoadContent();                         
  Device.SetVertexBuffer(_buffer);
  ((BasicEffect)Effect).World = _worldMatrix;
  ((BasicEffect)Effect).View = rootScene.Camera.View;
  ((BasicEffect)Effect).Projection = rootScene.Camera.Projection;
  int triangleCount = VertexCount - 2;
  foreach (EffectPass pass in Effect.CurrentTechnique.Passes)
  {
    pass.Apply();
    Device.DrawPrimitives(
        PrimitiveType.TriangleStrip, 0, triangleCount); 
  }
}
The code is similar to the SimpleTriangle drawing code, with one key change: the
primitive type used in DrawPrimitives is a TriangleStrip rather than TriangleList.
This is a subtle but important change. If you want to see what the points look like
when rendered as a TriangleList instead of a TriangleStrip, change the line so it
looks like this:
Device.DrawPrimitives(PrimitiveType.TriangleList, 0, VertexCount/3);
The end result is interesting and pretty in its own way, but it definitely isn’t the result
you’re looking for. What it does let you see is the relative size of the triangles on the
equator compared to those at the poles. There are other types of tessellations that use
a more uniform subdivision approach resulting in an equal density of points across
Listing 26.12
The Sphere class drawing code
Tessellate 
the sphere
Draw as 
triangle strip

677
Primitives
the entire sphere. Some of those present different problems when it comes to textur-
ing, but they result in a much cleaner mesh with the number of points.
 The final task is to add the sphere to the scene to prepare it for rendering. At the
same time, you’ll eliminate the cool multicolor triangle you’d been working with ear-
lier. Listing 26.13 shows the updated Scene.LoadObjects. 
private void LoadObjects()
{
  //SimpleTriangle o = new SimpleTriangle();
  //o.Device = GraphicsDeviceManager.Current.GraphicsDevice;
  Sphere o = new Sphere();
  o.Radius = 1f;
  o.Device = GraphicsDeviceManager.Current.GraphicsDevice;
  ...
}
The code works just as it did with the triangle. The only addition is setting the Radius
property of the Sphere. The later code in the method sets up the BasicEffect and
adds the object to the scene.
 Go ahead and run the application. You should end up with grayscale sphere cen-
tered on the screen, as shown in figure 26.8.
 Vertices are obviously very important, but the real workhorse of rendering is the
triangle. Typically, when you hear a game designer brag that their engine is rendering
X polygons a second, they’re talking about how many triangles it’s able to process and
send to the video card for processing.
Listing 26.13
Updates to the SetupScene method in MainPage.xaml.cs
Figure 26.8
Our first actual 3D object! If 
the triangle reminded me of 
Pink Floyd, this one reminds 
me more of the old Electronic 
Arts C64 games loader 
screen…either that or the 
Aperture Science 1978 logo.

678
CHAPTER 26
Introduction to 3D
When working with triangles, you want to be efficient with how many vertices you
define. The straight TriangleList is an easy-to-use class, and for low numbers of tri-
angles, perfectly acceptable. When you get into the higher numbers of triangles that
complex shapes require, you’ll want to use the TriangleStrip type instead or con-
sider the approaches you’ll learn in the next chapter. 
26.8
Summary
When you think of 3D, the first thing that comes to mind is usually entertainment:
video games, movies, and so forth. 3D in Silverlight is definitely useful in that space
but can also be used to enhance the experience of an otherwise 2D application. If you
want to add that extra bit of visualization, or that 3D graph you can manipulate in real
time, or even that 3D car model like I discussed in the introduction, you can do that
now with Silverlight and XNA.
XNA is a DirectX technology used on Windows, the Xbox, the Windows Phone, and
now in Silverlight. It has its roots in the old Managed DirectX implementations that
attempted to provide a friendly wrapper to the complex DirectX C++ APIs. With XNA 4,
the version ported to Silverlight, XNA has met that goal. The project templates make it
easy to get started with 3D, a complex topic no matter how friendly the API.
 This chapter covered the groundwork for creating a 3D application. Vertices and
triangles form the basis for almost everything you’ll render in 3D. How you use those
elements can have a profound impact on the size of your application and its perfor-
mance. The TriangleList is appropriate in some circumstances but uses n * 3 verti-
ces to define n triangles. The more efficient TriangleStrip uses n + 2 vertices, a
significant savings. In the next chapter, you’ll also look at using indexed triangle lists,
which use a very small number of vertices (n + 2) but add an index to make them read-
able without having to worry about things like winding order and whatnot during ver-
tex creation.
 The next chapter also continues our exploration into 3D by adding proper lighting
as well as animation, texturing and working with content, and even including some
additional objects in the scene.

679
3D lighting, texturing,
and animation
In the previous chapter, you modeled a sphere and rendered it in 3D. You could tell
it was 3D due to the curvature of the bands, but it wasn’t nicely shaded, and it defi-
nitely wasn’t lit. A key part of what makes a rendering convincing as 3D is the lighting.
 In DirectX-based 3D systems, lighting is handled by various shaders. These shad-
ers, which run directly on the video card, are small, high-performance algorithms
that anyone can write. In XNA, a DirectX-based system, the shaders are encapsu-
lated in a class derived from the Effect class. Throughout this chapter (as you did
in chapter 26), you’ll use the BasicEffect class. This class’s name is a bit mislead-
ing because it can do so very much for you.
 As part of the lighting effect discussion, I’ll also show you another way to tessel-
late spheres. This version works better for lit and textured shapes, and it also uses a
new way of representing the shapes: an indexed vertex list.
This chapter covers
■
Effects, lighting, and normal vectors
■
Texturing objects
■
Coordinate spaces and matrices
■
Keyframe animation

680
CHAPTER 27
3D lighting, texturing, and animation
One of the things the shaders in the BasicEffect class support is texturing. Textures
provide a way to add color and detail to a shape without using additional geometry.
After I cover lighting, and the normal vertices that make lighting possible, I’ll move
on to using textures on the objects.
 After the sphere and background have been properly textured, it’s time for anima-
tion. Because you can’t animate something without understanding exactly what X, Y,
and Z represent, I’ll discuss the coordinate spaces and the matrices that translate
between them. Finally, you’ll implement a basic but sufficiently featured keyframe ani-
mation system that you’ll use to bounce the sphere around the screen.
 By the end of this chapter, you’ll have your own cool version of the Amiga Boing
ball demo. This one will be a little different, but it’ll also be implemented entirely
using Silverlight and XNA, with not a drop of assembly to be found. Figure 27.1 shows
the end result across three frames.
27.1
Lighting and normal vectors
3D systems require pixel shaders and vertex shaders to calculate colors. Without even
the most basic shaders, you wouldn’t have any color to any objects at all. Shaders are
also responsible for things like reflections, lighting, and texturing. Pixel shaders oper-
ate, as the name implies, on the resulting pixels in 2D space. Vertex shaders operate
on the vertices in 3D space and calculate color, texture coordinates, and so forth.
 The shader language HLSL, which you learned about in chapter 24, is the same
shader language used when creating custom shaders for 3D. There are many great
tutorials on the web with information about HLSL, so I won’t go into it here.
 Effects are a convenient way to wrap up shaders, lighting, texturing, and many
other processing features. There are third-party effects, and many toolkit/engine
developers create their own as well. XNA includes a few stock effects—you’ve been
using the BasicEffect in this example from the previous chapter.
 In this section, you’ll continue with the example from the previous chapter and
explore effects to add lighting to the sphere. Because the shader requires the use of
normal vectors (“normals”), you’ll examine them and see how to implement them in
your own program. In support of both lighting and normals, I’ll show you another
algorithm for drawing the triangles that make up the shape: indexed primitives.
Figure 27.1
Three frames of our version of the Amiga Boing ball demo. This is what you’ll have created 
by the end of the chapter.

681
Lighting and normal vectors
27.1.1 Lighting the scene
Humans can’t see without light. If you’ve ever taken one of those underground cavern
tours, you’ll appreciate just how blind we really are in true dark situations. Our eyes
use the light reflected off objects to get both color and shape information to our
brain. 3D rendering systems use lighting for the same purpose: to provide color and
shape information.
 So far, you’ve been using straight vertex coloring. This is a color that’s calculated
on a per-vertex level. You didn’t set it to anything that makes sense in a 3D world but
simply chose values that would provide depth to the shape.
 At the same time, you set up a white ambient light but didn’t use it. This is just a
constant value that’s applied to all shapes in the scene. Because there’s only a constant
shading, there’s no sense of depth to any objects.
 To see the effect that ambient lighting has on the scene, open the Scene class and
temporarily change the effect’s AmbientLightColor property in the LoadObjects
method and enable lighting. If you choose red, as shown here, the sphere will have a
red color cast to it.
effect.AmbientLightColor = new Vector3(1.0f, 0.0f, 0.0f);
effect.LightingEnabled = true;
effect.VertexColorEnabled = false;
Now go ahead and disable vertex coloring by setting the VertexColorEnabled prop-
erty to false in that same method. You’ll see that the sphere no longer has any depth.
It’s just a solid red circle (minus that little seam caused by my choice of tessellation
algorithms). Let’s try with some lights. Listing 27.1 has a new method to add to the
Scene class.
public class Scene
{
  ...
    private void SetupLights(BasicEffect effect)
    {
      effect.EnableDefaultLighting();          
      effect.VertexColorEnabled = false;
    }
}
The code uses one of the nice features of the BasicEffect class: standard three-point
lighting. If you’ve ever had your photo taken in a studio, you’ve likely noticed the
three lights used by the photographer: the key light, the fill light, and the back light.
 Now, go into the LoadObjects method of the Scene class and change the code that
deals with effects so it has only these two lines:
BasicEffect effect = new BasicEffect(o.Device);
SetupLights(effect);
Listing 27.1
The new SetupLights method of the Scene class
3-point light

682
CHAPTER 27
3D lighting, texturing, and animation
Make sure you’ve removed the references to vertex coloring and other the other
"effect." lines. Now go ahead and run the program. You might think you’ll get lights,
but instead you’ll end up with a solid black disc where you previously had solid red.
 Despite the lighting being in place, the sphere still has no shading. That’s because
when it was created, you used the VertexPositionColor vertex type. That type
includes color information that enabled you to see the sphere without any lighting.
But it didn’t include the normal vector or texture coordinates required by the lighting
and texturing parts of the BasicEffect. The vertex color system is meant to be a
quick way for you to control shading from within the geometry itself, rather than
through lighting in a scene. It’s time to switch to something more usable.
27.1.2 Sphere normal vectors
In a 3D system, each vertex has something called a normal. The normal is a unit vector
(a vector of length 1) that points away perpendicular from the vertex. If you imagine
your desk as a vertex and then stand a ruler on end on top of it, that ruler would be
the representation of the normal for that desk.
 Normal vectors (usually just
called “normals” but Microsoft Word
autocorrects it to “normal” every
time I type it) are important because
lighting systems and shaders require
them to be able to tell how to shade
the object. Figure 27.2 shows what
the normal vectors on a curved sur-
face might look like.
 These normal vectors are typi-
cally calculated when the geometry
is created. If you import a mesh file from a 3D program, it almost certainly will have
the normal vectors included. In this case, because you created the sphere from code,
you need to have that calculation included as part of the build process. 
 Create a brand-new class named TexturedSphere and copy all of the existing
Sphere code into it. When copying, make sure you change the class name to
TexturedSphere. Once completed, use the code in listing 27.2 to update the Load-
Content method of the TexturedSphere class to a new tessellation algorithm that sup-
ports normal vectors and texturing. 
protected IndexBuffer _indexBuffer;
protected int _triangleCount = 0;
public Texture2D Texture { get; set; }
public override void LoadContent()
{
Listing 27.2
LoadContent method of the TexturedSphere class
Figure 27.2
A curved surface showing the normal 
vectors (source: Wikimedia commons, public domain)

683
Lighting and normal vectors
  int stacks = 24;                          
  int slices = 24;                                  
  VertexCount = (stacks + 1) * (slices + 1);
  var vertices = new VertexPositionNormalTexture[VertexCount]; 
  float phi, theta;
  float dphi = MathHelper.Pi / stacks;
  float dtheta = MathHelper.TwoPi / slices;
  float x, y, z, sc;
  int index = 0;
  for (int stack = 0; stack <= stacks; stack++)
  {
    phi = MathHelper.PiOver2 - stack * dphi;
    y = Radius * (float)Math.Sin(phi);
    sc = -Radius * (float)Math.Cos(phi);
    for (int slice = 0; slice <= slices; slice++)
    {
      theta = slice * dtheta;
      x = sc * (float)Math.Sin(theta);
      z = sc * (float)Math.Cos(theta);
      float u = (float)slice / (float)slices;
      float v = (float)stack / (float)stacks;
      vertices[index++] = new VertexPositionNormalTexture(
                new Vector3(x, y, z),
                Vector3.Normalize(new Vector3(x, y, z)),
                new Vector2(u, v));
    }
  }
  var indices = new ushort[slices * stacks * 6];   
  index = 0; int k = slices + 1;
  for (int stack = 0; stack < stacks; stack++)
  {
    for (int slice = 0; slice < slices; slice++)    
    {
      indices[index++] = (ushort)((stack + 0) * k + slice);
      indices[index++] = (ushort)((stack + 1) * k + slice);
      indices[index++] = (ushort)((stack + 0) * k + slice + 1);
      indices[index++] = (ushort)((stack + 0) * k + slice + 1);
      indices[index++] = (ushort)((stack + 1) * k + slice);
      indices[index++] = (ushort)((stack + 1) * k + slice + 1);
    }
  }
  _triangleCount = stacks * slices * 2;         
  _buffer = new VertexBuffer(
Latitudinal stacks, 
longitudinal slices
New vertex 
type
Index array
Indices calculation
Triangle count

684
CHAPTER 27
3D lighting, texturing, and animation
                Device,
                VertexPositionNormalTexture.VertexDeclaration,
                VertexCount,
                BufferUsage.WriteOnly);
  _buffer.SetData<VertexPositionNormalTexture>(vertices, 0, VertexCount);
  _indexBuffer = new IndexBuffer(                 
                Device,
                IndexElementSize.SixteenBits,
                index,
                BufferUsage.WriteOnly);
  _indexBuffer.SetData<ushort>(indices, 0, index);
}
This version uses an entirely new algorithm that supports setting the normal vectors
and texture coordinates. It’s also noteworthy in that it uses indexed vertices. Rather
than use the interesting yet somewhat strange algorithm the first listing used to gener-
ate a complete and seamless triangle strip, listing 27.2 has the additional flexibility of
being able to generate the sphere using a series of slices. 
 Each stack represents a horizontal (latitudinal) division of the sphere. Each slice
represents a single vertical slice within that horizontal division. Each slice on a stack is
made up of two triangles that form a quadrilateral.
 Once the vertices are created, the algorithm takes a second pass to generate all the
indices. It’s the use of indices that give you the freedom.
27.1.3 Indexed vertices
Indexed vertices are another way to avoid duplicating vertex entries. It works by defin-
ing each vertex only once in an array and keeping a separate array of indices into that
array so you can refer to the same vertex in multiple triangles. This is a common and
popular approach that uses a bit more data than a TriangleStrip but still far less
than a nonindexed TriangleList. 
 Indexed vertices define
a vertex only once and then
use an external index to
build the triangles. That
means the vertex count for
n triangles will be n + 2, just
as it was with the Triangle-
Strip in the previous chap-
ter. But the external index
will have n * 3 16-bit values
stored in it as well. Figure
27.3 shows what the vertex
buffer and index buffer for
a 
four-triangle 
primitive
might look like.
Index buffer
Figure 27.3
The relationship between the triangles, the vertex 
buffer, and the index buffer. Although the concept is the same, 
this doesn’t necessarily represent the exact algorithm or winding 
order you used to generate the sphere.

685
Lighting and normal vectors
Despite the extra data, the indexed TriangleList is an extremely popular approach.
The reason is, unlike with the TriangleStrip, you have complete control over the
winding order (the order in which points on a triangle are defined: clockwise or coun-
terclockwise), and the indices are often easier to visualize and generate. Video card
drivers and GPUs are also well optimized for this approach, so the code should be fast.
 To try out this new sphere, you’ll need to make a few changes to the LoadObjects
method of the scene. Listing 27.3 shows the complete method with the BasicEffect
and the new TexturedSphere.
public void LoadObjects()
{
  TexturedSphere o = new TexturedSphere();     
  o.Radius = 1f;
  o.Device = GraphicsDeviceManager.Current.GraphicsDevice;
  BasicEffect effect = new BasicEffect(o.Device);
  SetupLights(effect);
  o.Effect = effect;
  Objects.Add(o);
}
If you run the example now, you’ll see a cool slinky-looking sphere. It’s not solid by a
long shot. Surely something is wrong? Yes, it is. You still have the old TriangleStrip
code in the Draw method of the TexturedSphere class so the vertices are being inter-
preted differently than you want, and the indices are being ignored. Listing 27.4
shows the updates required to move to the new indexed primitive approach.
public override void Draw(Scene rootScene)
{
  if (_buffer == null)
    LoadContent();
  Device.SetVertexBuffer(_buffer);      
  Device.Indices = _indexBuffer;           
  ((BasicEffect)Effect).World = _worldMatrix;
  ((BasicEffect)Effect).View = rootScene.Camera.View;
  ((BasicEffect)Effect).Projection = rootScene.Camera.Projection;
  ((BasicEffect)Effect).Texture = Texture;
  foreach (EffectPass pass in Effect.CurrentTechnique.Passes)
  {
    pass.Apply();
Listing 27.3
Updated LoadObjects method with the new Sphere class
Listing 27.4
Updated Draw method with the new indexed rendering approach
The new 
sphere
Vertex buffer
Index buffer

686
CHAPTER 27
3D lighting, texturing, and animation
    Device.DrawIndexedPrimitives(         
              PrimitiveType.TriangleList, 0, 0,  
              VertexCount, 0, _triangleCount);
  }
}
The Draw method now sets the index buffer in addition to the vertex buffer. Also, the
call to DrawPrimitives has been changed to DrawIndexedPrimitives, so the device
knows to use your index buffer as well as the vertex buffer.
 Build and run the application now. Wow! That’s more like it! With the addition of
lighting, supported by the normals on the sphere, you have something that looks
much more like what you’d expect out of a 3D system. Figure 27.4 shows you how it
should look.
 Normal vectors are a key part of a 3D model. Without them, lighting systems have
no idea how to shade the shape you’re rendering. In most applications, you’ll simply
load the 3D model from a file, enabling you to skip all that pesky normal calculation—
the modeling tool will have included it in the data. But you need to understand nor-
mals and how they work so you can make sense of things when you find something
wrong with your model. In fact, there’s a little something wrong with this model, as
you’ll see in the next section.
 You’ve also looked at the indexed primitives approach to defining objects. This
takes the best part of the triangle strip—vertices are defined only once—and com-
bines it with an external index to make it easier to create models without having to do
crazy triangle flipping to ensure the shape remains one continuous triangle strip.
Indexed 
primitives 
drawn
Figure 27.4
The new 
3D sphere, looking very 
much like a lonely 
planet. Put a star field 
behind it and call it a 
wrap—except the 
sphere is actually inside-
out, as you’ll see later.

687
Applying a texture
Now that you have something that looks more like a real 3D bouncy ball, you’re that
much closer to meeting your goal of replicating the Amiga Boing ball in Silverlight.
The next step is to apply that classic red-and-white checkerboard pattern. 
27.2
Applying a texture
A texture is a graphic that’s applied to 3D geometry much like you’d paper over a wall
in your house. If you tacked some interesting shapes to the wall, like a cat or that ugly
tchotchke you’ve wanted to get rid of, and then papered over them and the wall, hug-
ging all the nooks and crannies of those shapes to have them fully realized in wallpa-
per, you begin to see what a texture can do.
 In the earliest days of 3D, textures weren’t available. Shapes were all shaded using
simple geometry color. Later, bitmap images were used to cover the surfaces as it was
often easier to represent texture outside the 3D system. For a real flashback example
that uses a bit of both, search YouTube for “dire straits money for nothing music video.”
The 3D modeling is extremely crude and most of the geometry is flat shaded, using just
geometry colors. But the walls in the room in the opening scene are textured.
 Now, flash-forward a few years to some of the earliest 3D games: the 1992 game Cas-
tle Wolfenstein 3D and the trend-setting 1993 game Doom.1 In those games, the envi-
ronment relied almost entirely on textures. Game designers discovered that they
could have really crude geometry and simply provide (relatively) elaborate textures to
supply the missing detail. Doom had some basic lighting, but Wolfenstein was pretty
much just wall textures on a maze-like grid pattern. This made the graphics much eas-
ier for those old VESA Local Bus video cards to render.
 Textures are still important to 3D rendering. They’re no longer the only item in
the toolkit, and they’re often combined with other lighting and additional texture sys-
tems, but you can still get very far with them.
 In this section I’ll first cover the ContentManager and the content pipeline that
supports it. You can’t effectively load textures in your application without it. From
there, you’ll apply a texture to the sphere created in the previous section. The final
task will be to create a new type of SceneObject: the TexturedPlane. You’ll load a tex-
ture on to that and render it as the background to the 3D scene. At the end of this sec-
tion, you’ll have everything you need for the Amiga Boing ball, except for animation.
27.2.1 The ContentManager
The Silverlight toolkit includes a version of the XNA ContentManager class. When
combined with the content libraries in the default 3D project, it becomes a powerful
and easy way to load data into your 3D application.
 One of the challenges of working with models and textures is getting them into the
right format for the XNA system to use. You can’t simply load a bitmap and use it to
1 Doom was so groundbreaking, that for years, first-person shooters were referred to as “Doom Clones.” The
phrase “FPS” or “First Person Shooter” didn’t enter the lexicon until later.

688
CHAPTER 27
3D lighting, texturing, and animation
texture an object, for example. Instead, that bitmap needs to be formatted in a
specific way. In addition, it needs to be sized using a power of 2 size, like 256 or 1024
pixels. The sizing you can handle yourself in whatever drawing program you use. The
conversion is a bit more troublesome.
 The extensions for Visual Studio and the content project type handle the data con-
versions for you. If you open up the bin/debug folder for your application, after
you’ve added resources you’ll see the data formats that XNA uses.
 Once the data is converted, you need to be able to use it in your application. The
ContentManager makes this simple. Once you’ve created an instance of the class (your
Scene has an instance already set up, just like the default template), you can simply
call Content.Load and give it the name of the resource you want. This name is what
you saw in the file properties, and it’s typically the filename minus the extension.
 For the texturing tasks in this section, you’ll need two resources. First, create a Tex-
tures folder in the Silverlight3DAppContent project. Inside that folder, add the Plane-
Texture and SphereTextureSmall files from the downloadable source code for this
book. If you don’t have access to that source code, the PlaneTexture is a small 128 x
128 square with a gray background and purple border. The SphereTextureSmall is a
larger file with alternative red and white squares in a 6 x 6 grid. You’ll see an image of
that when you work with texturing the sphere. 
 The sphere texture isn’t sized as a power of 2, so you’ll need to ensure it gets cor-
rectly converted. To do that, click on the SphereTextureSmall.bmp file in the project.
In the properties window, open the Content Processor group. Inside that, change the
Resize to Power of Two property to true. If you forget to do that, you’ll see an error
when you try to use the texture later.
 While there, change the Color Key Enabled property to false. This ensures that you
don’t accidentally get transparency in your background. Do the same with the Plane-
Texture.bmp resource.
 Once the textures are loaded into the content pipeline, you can use them in the
application. We’ll start by texturing the sphere.
27.2.2 Texturing the sphere
The famous Amiga Boing ball demo used a red-and-white checkerboard pattern
applied to the sphere. It was six rows high by some number of rows across. The Amiga
version was almost certainly generated procedurally, but you’ll do yours the new-
fangled way: in Photoshop. Figure 27.5 shows the texture being edited. 
 The texture is a regular bitmap with approximately equal sides. To make the best
use of video card memory and processing, you need the texture to be square (equal
sides) and sized in a power of 2—for example, 128 pixels x 128 pixels, or 512 pixels x
512 pixels. You did none of those things for this demo, because you let the content
processor resize it for you. In a real application, where you want better control, you’ll
need to do that sizing yourself.

689
Applying a texture
When the sphere was generated, you created texture coordinates for each vertex
using these lines of code: 
float u = (float)slice / (float)slices;
float v = (float)stack / (float)stacks;
vertices[index++] = new VertexPositionNormalTexture(
                       new Vector3(x, y, z),
                       Vector3.Normalize(new Vector3(x, y, z)),
                       new Vector2(u, v));
Texture coordinates are specified as a pair (u,v), often referred to simply as “UV.” UV
coordinates represent positions on a rectangular bitmap. U is the X position across
the bitmap and V is the Y position. These coordinates are normalized on a 0..1 scale,
so 0,0 is the top left and 1,1 is the bottom right.
 When the model is created, each vertex is assigned a position on that UV map. In
the case of your sphere, this is similar to the process that mapmakers use when unroll-
ing the globe to create a flat map. If you’ve ever used a Mercator projection map, you
can see that it distorts the geography near the poles. You’ll run into the same thing in
reverse so that the texture will be pinched at the poles and closest to its natural aspect
ratio at the equator. That’s fine, though, as it’s expected. You could design your own
texturing algorithm that uses something more like a Goode Homolosine2 approach or
something else that reduces distortion if you’d like.
2 That made me sound really smart, I know. In truth, I recently read all the names in this great xkcd comic:
http://xkcd.com/977/. 
Figure 27.5
The Boing ball checkerboard pattern replicated using my mad Photoshop skills

690
CHAPTER 27
3D lighting, texturing, and animation
 Using the content manager discussed earlier, you’ll texture the sphere with the bit-
map. Ensure that you have the sphere texture loaded into the content project. Next,
in the Draw method, update the LoadContent line to also load the texture and enable
the texture on the effect.
public override void Draw(Scene rootScene)
{
  if (_buffer == null)
  {
    LoadContent(); 
    LoadTexture(rootScene);                
  }
  ...
 ((BasicEffect)Effect).Texture = Texture;   
 ((BasicEffect)Effect).TextureEnabled = true;
  ...
}
The LoadTexture method this code relies on is a single line of code. Go ahead and
create that method as shown here:
private void LoadTexture(Scene rootScene)
{
  Texture = rootScene.Content.Load<Texture2D>(
                             "Textures/SphereTextureSmall");
}
Listing 27.5 and this method together load the texture using the content manager
and apply the texture to the effect you’re using. Note also that you have to explicitly
enable the use of textures using the TextureEnabled property.
 When you run the application, you’ll now see a nicely textured ball. But it looks a
little strange—it looks inside out. Why is that? That’s because the winding order used
by the sphere generation function doesn’t fit the default winding order used in XNA.
To fix that, in the Draw method, before you work with the effect but after setting the
index buffer, add this line of code:
Device.RasterizerState = RasterizerState.CullClockwise;
This line tells the rasterizer which triangles to remove from the scene when render-
ing. You could also have set it to CullNone, but that doesn’t give perfect results. By
default, XNA is using CullCounterClockwise, but the sphere generation algorithm
used the opposite. Now go ahead and run the application again. This time the sphere
in figure 27.6 looks exactly as you expect it to.
Listing 27.5
Loading the sphere texture inside the Draw method
LoadTexture
Apply texture

691
Applying a texture
It’s a lot of fun to see the ball rendered on screen, in 3D, with an interesting (if not
entirely Amiga-accurate) texture. Next, you need a background for it to bounce in
front of.
27.2.3 Adding and texturing a background
A plane is a surface with no depth but with width and height. It doesn’t have to be, but
it’s easily made up using two triangles to form a square. When texturing, though, hav-
ing just the corners as vertices limits what you can do with tiling the texture. Instead,
you’d have to create a huge texture large enough to cover the entire plane.
 If you make the plane from many smaller squares, you can give them each the
same UV coordinates to enable tiling the texture. This saves texture memory at the
expense of vertices.
 That’s a lot of work, though. What you need is a shader that can support tiling the
texture. Remember how I said the UV coordinates are always in the range of 0..1?
Well, I lied, a little. If you use a number great than 1, the texture will repeat when
using the BasicEffect. With that in mind, it’s a simple matter to create a plane with
two triangles and the correct texture coordinates.
 In the Model folder, create a new class named TexturedPlane. The code for the new
class, which relies on one of the textures you loaded earlier, is shown in listing 27.6.
using System;
using Silverlight3DExample.Model;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework;
Listing 27.6
The Plane class
Figure 27.6
The Boing ball is 
starting to look more 
like the Amiga version. 
Love that texture!

692
CHAPTER 27
3D lighting, texturing, and animation
using Silverlight3DApp;
namespace Silverlight3DExample.Model
{
  public class TexturedPlane : SceneObject
  {
    private VertexBuffer _buffer = null;
    protected IndexBuffer _indexBuffer;
    protected int _triangleCount = 0;
    public Texture2D Texture { get; set; }
    private int _rows = 1;
    public int Rows                             
    {
      get { return _rows; }
      set { _rows = value; InvalidateBuffer(); }
    }
    private int _columns = 1;
    public int Columns                       
    {
      get { return _columns; }
      set { _columns = value; InvalidateBuffer(); }
    }
    private float _width = 1;
    public float Width
    {
      get { return _width; }
      set { _width = value; InvalidateBuffer(); }
    }
    private float _height = 1;
    public float Height
    {
      get { return _height; }
      set { _height = value; InvalidateBuffer(); }
    }
    private void InvalidateBuffer()
    {
      _buffer = null;
      _indexBuffer = null;
    }
    private void LoadTexture(Scene rootScene)
    {
      Texture = rootScene.Content.Load<Texture2D>(
                  "Textures/PlaneTexture");
    }
                   
  }
}
Rows to tile
Columns to tile
Draw method copied 
from TexturedSphere

693
Applying a texture
You copy the Draw method from the TexturedSphere class; it’s exactly the same in the
TexturedPlane class, including the clockwise culling. You could also break that out
into a TexturedObject base class and inherit both from that class, but you didn’t do
that here.
 The previous listing didn’t include the code to actually create the plane. Listing
27.7 breaks that out, along with a helper function used to create vertices with their
normal vectors and UV coordinates.
private VertexPositionNormalTexture BuildVertex(
            float x, float y, float u, float v)
{
  return new VertexPositionNormalTexture(
     new Vector3(x, y, 0), Vector3.Normalize(new Vector3(x, y, 0)),
     new Vector2(u, v));
}
public override void LoadContent()
{
  _triangleCount = 2;
  VertexCount = 4;
  var topLeftVertex = BuildVertex(0, Height, 0, 0);            
  var bottomLeftVertex = BuildVertex(0, 0, 0, Rows);            
  var bottomRightVertex = BuildVertex(Width, 0, Columns, Rows); 
  var topRightVertex = BuildVertex(Width, Height, Columns, 0); 
  var indices = new ushort[6];
  var vertices = new VertexPositionNormalTexture[]
     { topLeftVertex, bottomLeftVertex, 
       bottomRightVertex, topRightVertex };
  indices[0] = 0; indices[1] = 1; indices[2] = 3;    
  indices[3] = 1; indices[4] = 2; indices[5] = 3;       
  _buffer = new VertexBuffer(
             Device,
             VertexPositionNormalTexture.VertexDeclaration,
             VertexCount,
             BufferUsage.WriteOnly);
  _buffer.SetData<VertexPositionNormalTexture>(vertices, 0, VertexCount);
  _indexBuffer = new IndexBuffer(
        Device,IndexElementSize.SixteenBits, 6, BufferUsage.WriteOnly);
  _indexBuffer.SetData<ushort>(indices, 0, 6);
}
The listing creates two triangles, using six index entries and four vertices. The general
approach is the same as with the TexturedSphere, but a plane is generally easier to
understand. Also, you named the individual vertices to make the code easier to follow.
Listing 27.7
The LoadContent method of the TexturedPlane
Four vertices
Triangle 1
Triangle 2

694
CHAPTER 27
3D lighting, texturing, and animation
 Finally, you need to load the TexturedPlane from the LoadObjects method of the
Scene. This necessitates a few changes to the scene, included in listing 27.8.
private TexturedSphere _sphere = new TexturedSphere();
private TexturedPlane _plane = new TexturedPlane();
public void LoadObjects()
{
  BasicEffect sphereEffect = new BasicEffect(GraphicsDevice);
  SetupLights(sphereEffect);
  _sphere.Radius = 0.65f;
  _sphere.Effect = sphereEffect;
  Objects.Add(_sphere);
  BasicEffect planeEffect = new BasicEffect(GraphicsDevice); 
  SetupLights(planeEffect);
  _plane.Width = 4;        
  _plane.Height = 4;                                   
  _plane.Rows = 12;         
  _plane.Columns = 12;                                  
  _plane.X = -2; 
  _plane.Y = -2;
  _plane.Effect = planeEffect;
  Objects.Add(_plane);
    foreach (SceneObject o in Objects)
        o.Device = GraphicsDeviceManager.Current.GraphicsDevice;
}
This code modifies the LoadObjects method to make the two objects class-level vari-
ables. This will be important for the animation you’ll do later in this chapter. In addi-
tion, each object has been given its own BasicEffect instance. That’s required to
support the different textures without dancing around to reuse the same effect.
 Run the application and you should see a nicely shaded background like figure
27.7. This is the same type of colored background that the Amiga demo used, except
yours is shaded a little more nicely.
 In this section, you rendered a sphere using nothing but triangles. You then tex-
tured it with a bitmap. Once the sphere was in place and looking like the good old
Amiga ball, you added in a background. The background was implemented as a plane
with a tiled texture, replicating the Amiga Boing ball demo background. The loading
of the textures was handled through the ContentManager Silverlight SDK class.
 When placing the plane, you set X and Y coordinates. Similarly, when building the
triangles for the plane, you used sets of X and Y coordinates in a different coordinate
space. If you’re used to the Silverlight “top left is 0,0” coordinate system, some of
those numbers may have looked a little confusing.
 The Amiga demo also included a ground plane, but I have left that off here. When
creating a ground plane, you’ll want to reuse the plane class but do a rotate transform
to get the plane oriented horizontally. To do that, you’ll need to use a matrix. 
Listing 27.8
Updated LoadObjects method of the Scene
4 x 4 Plane
12 x 12 grid

695
Coordinate spaces and matrices
27.3
Coordinate spaces and matrices
3D systems, by necessity, work with a number of different coordinate spaces. For exam-
ple, when you define a 3D shape, as you’ve done here with a triangle and sphere, you
specify its points relative to its own model space. The points used here are local coor-
dinates. The scene then imposes the idea of world space.
 Four different coordinate spaces, plus one scoping of an existing space, are used in
a 3D system:
■
Model space (also called local space) is where the points are all defined relative
to the model. This is what you get when you import or generate geometry.
■
World space is the coordinate system used by the entire scene. In it, objects are
placed in different locations, despite having their points defined relative to
their own space. World space is important for positioning and interaction
between objects, but also for things like lighting.
■
View space is the space from the camera’s point of view (called the view frustum).
This is, like the other two, a representation in 3D space, but it’s relative to the
camera and therefore relative to their final positions on screen.
■
Projection space sets up perspective and also helps define how close things need
to be to be visible. Many games will slowly fade objects to a background or fog
color as they get further away, eventually eliminating those that are too far
(defined by a clipping plane), helping to reduce the number of vertices in play
for any particular frame.
■
Clip space is what you actually see on your screen. It’s not a separate coordinate
space, but instead is the part of projection space that can be seen between the
near and far clipping frames.
Figure 27.7
The Boing ball demo 
gets a background.

696
CHAPTER 27
3D lighting, texturing, and animation
In each of those coordinate spaces, 0,0,0 is typically
the center of the screen, with negative X to the left,
positive X to the right, negative Y to the bottom,
and positive Y at the top. Positive Z space comes out
of the screen and toward you, the viewer. Negative
Z space goes into the screen. Together, this is called
a right-hand coordinate system. If you imaging the
plane shown is your display and you’re sitting at +Z,
figure 27.8 shows this better than words.
 With all these different spaces, it becomes neces-
sary to translate between them. The scene needs the
object’s points represented in world space, the cam-
era needs them in view space, and so forth. To do
this translation, you use something called a matrix.
 In this section, you’ll look at the Matrix class and see how the three types of matri-
ces can be used to translate among the various types of coordinate spaces as well as
perform operations such as rotation and movement.
27.3.1 The three coordinate space conversion matrices
XNA, like most other 3D systems, uses three primary matrices: World, View, and Pro-
jection. These are used for translating between the different coordinate spaces I just
covered:
■
The World matrix controls where objects are drawn in the scene. It’s the responsi-
bility of this matrix to transform between the local object coordinates (in model
space) to the scene coordinates in world space. Multiply the coordinates in
model space by the world matrix to get coordinates in world space.
■
The View matrix defines the position of the camera and how everything appears
to it. This matrix is responsible for transforming the world coordinates into
camera-oriented coordinates. Multiply coordinates in world space by this
matrix to get them in view space.
■
The Projection matrix is what transforms 3D coordinates into something usable in
a 2D screen coordinate system. This matrix helps decide if there is no perspec-
tive (orthogonal projection), normal perspective, or crazy perspective with
elongated objects. Multiply view space coordinates by this matrix to get them in
projection space. It’s all pixels in the end.
There also exists a fourth type of matrix, but it’s simply a combination of the three oth-
ers, used to help reduce the number of matrix multiplication steps required to get from
model space all the way to projection space. This is called the World-View-Projection
matrix (WVP). The WVP is often used by shaders—code that must be as efficient as
possible due to the number of times they run during any given frame.
 Each type of matrix is simply an instance of the Matrix class. 
Figure 27.8
XNA is a right-hand 
coordinate system as shown on a 
super-thin flat panel display. Mmm, 
dat bezel. 

697
Coordinate spaces and matrices
27.3.2 The Matrix class
A matrix is a mathematical concept that enables a number of special types of addition,
multiplication, and other operations. You first ran across the matrix in chapter 7 on
transforming. In that case, the matrix was a 3 x 3 matrix for transforming in 2D space.
In XNA, the matrix is a 4 x 4 matrix for transforming in 3D space. Silverlight also sup-
ports a native 4 x 4 matrix used by the Matrix3DProjection, but it’s not the same as
what you’ll use here.
 The topic of matrices in 3D can quickly get to be a complicated subject, so if you
want to dive more deeply into them, I encourage you to pick up a book on math con-
cepts for 3D graphics.
 That said, you can get pretty far in XNA without worrying about how exactly the
matrix operations are implemented and how they work. This is possible because the
XNA version of the Matrix type exposes a number of helpful methods and operators
that make matrix math accessible for us mortals. Table 27.1 shows a sampling of these
members.
You can see that the Matrix class has a number of helper methods that make its use
easy. You could define each of these manually using just the matrix values, but that’s
simply not approachable for most of us.
 The Matrix class has many other methods, including ones to help with shadows and
reflections. Be sure to look it up in the object browser or the online documentation.
 If you need to manipulate a point (or vertex), you almost always want to use a matrix.
Matrices are used for transforming points from one coordinate system to another, but
Table 27.1
The methods and properties on the Matrix class
Member
Description
M11 to M44
These represent the row and column data for the matrix.
Operators
The Matrix class overloads all the common mathematical operators 
to enable matrix math.
CreateFromAxisAngle
Creates a matrix that rotates around a vector at a specified angle.
CreateFromYawPitchRoll
Creates a matrix from the provided yaw, pitch, and roll values.
CreateLookAt
Creates a view matrix for use with a camera.
CreateOrthographic
Creates a projection matrix with no perspective.
CreatePerspective
Creates a perspective projection matrix.
CreateRotationX/Y/Z
Creates a rotation matrix around the specified axis at the specified 
angle.
CreateScale
Creates a matrix that can be used to scale an object.
CreateTranslation
Creates a matrix that can be used to move an object.
CreateWorld
Creates a world matrix with specified reference vectors.

698
CHAPTER 27
3D lighting, texturing, and animation
they’re also generally useful for moving points around within a coordinate system to
support moving objects discretely, or as you’ll see next, animating them. 
27.4
Keyframe animation
Silverlight has excellent support for keyframe animation in 2D. You learned all about
the animation types and the related easing functions in chapter 13. But in the 3D
world, animation is entirely left up to the implementer and therefore is typically
found as a part of 3D toolkits and engines rather than in the core itself.
 If you want to create your own animation system, you’ll need to manipulate the
various matrices you learned about in the previous section. One area where the
Matrix class shines is scaling, rotating, and translating (SRT) your objects. Scaling is
the operation of resizing. Rotating enables orientation and spinning, and translating
moves the object from one place to another.
 Ultimately, all of these SRT acts are about moving points around the system, and
that’s where matrices excel. You’ve seen how simple it is to add spin to the sphere.
Let’s take it a bit further and add movement, and formalize the whole thing into a reg-
ular keyframe animation system. 
 In this section, you’ll implement a basic keyframe animation system for your sam-
ple application. The goal is to enable the sphere to spin and also bounce across the
screen. That means you’ll animate rotation as well as translation on the X and Y axes.
Because you could use a little more room, you’ll also translate on the Z axis to move
the sphere further away from the camera. The bounce itself won’t be fancy, but it’ll do
its duty of showing how to animate in 3D.
27.4.1 The KeyFrame and KeyframeAnimation classes
I built this animation system around keyframes. As you learned in chapter 13, a key-
frame represents a value at a point in time. It’s up to the animation system to figure
out how to get there from the current value.
 Listing 27.9 shows the KeyFrame class. The class includes the time (offset), the
value at that time, and then an easing function to figure out how to get there. Create
this class in the Model folder.
using System;
namespace Silverlight3DExample.Model
{
  public enum EasingType
  {
    Linear,
    SmoothStep
  }
  public class KeyFrame
  {
Listing 27.9
The KeyFrame class

699
Keyframe animation
    public float Value { get; set; }
    public int Offset { get; set; }
    public EasingType EaseIn { get; set; }        
    public KeyFrame() { }
    public KeyFrame(int offset, float value, EasingType easeIn)
    {
      Value = value;
      Offset = offset;
      EaseIn = easeIn;
    }
  }
}
The MathUtility static XNA class includes basic functions that can be used for easing.
Rather than implement your own easing functions, here you simply use two of the
MathUtility functions: Lerp (Linear Interpolation) and SmoothStep.
 The KeyFrame class is a structure to hold data; it doesn’t have any actual functional-
ity. Everything that handles the animation is included in the KeyFrameAnimation class,
the start of which is shown in listing 27.10.
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Microsoft.Xna.Framework;
namespace Silverlight3DExample.Model
{
  public class KeyFrameAnimation
  {
    private List<KeyFrame> _keyFrames = new List<KeyFrame>();
    public bool Completed { get; set; }
    public bool Repeat { get; set; }
    public bool AutoReverse { get; set; }
    public KeyFrameAnimation(bool repeat, bool autoReverse)
    {
      Repeat = repeat;
      AutoReverse = autoReverse;
    }
    public void AddKeyFrame(KeyFrame keyFrame)
    {
    }
    public float GetFrameValue(int offset)
    {
    }
Listing 27.10
The KeyFrameAnimation class structure
Easing function

700
CHAPTER 27
3D lighting, texturing, and animation
    public void Reset()
    {
      Completed = false;
      _currentKeyFrame = 0;
      _nextKeyFrame = 0;
      _movingForward = true;
    }
  }
}
The listing shows the outline of the KeyFrameAnimation class and a couple of its sim-
pler methods. The functions of the members are described in table 27.2.
I mentioned that the keyframes are sorted. Sorting the keyframes by their offset is an
important part of making the keyframe animation work correctly. Without this sort-
ing, it’d be more difficult to assess progress during the animation stage. Listing 27.11
shows the AddKeyFrame function, complete with sorting on insert.
public void AddKeyFrame(KeyFrame keyFrame)
{
  var nextFrame = _keyFrames                   
        .Where(f => f.Offset > keyFrame.Offset) 
        .FirstOrDefault();                       
  if (nextFrame != null)
    _keyFrames.Insert(_keyFrames.IndexOf(nextFrame), keyFrame);
  else
    _keyFrames.Add(keyFrame);
}
The function in the listing sorts the keyframes as they’re added, making the collection
much easier to work with when calculating the current value.
Table 27.2
The KeyFrameAnimation class members
Member
Description
_keyFrames
A sorted list of keyframes.
Completed
True when the animation has completed and it isn’t set to repeat.
Repeat
If true, the animation will repeat over and over.
AutoReverse
If true, when the animation reaches the last keyframe it’ll then reverse itself. 
If Repeat isn’t true, this will be done only once. If Repeat is true, this will 
continue forever.
AddKeyFrame
Inserts a keyframe into the collection at the appropriate position.
GetFrameValue
Returns the value for the specified time/frame offset.
Reset
Resets the animation to its default state.
Listing 27.11
Adding keyframes
Sort position

701
Keyframe animation
 The current value calculation is necessarily the most complex function in the class.
It takes in the render frame and, from there, decides which keyframe you’re in, the
direction you need to move, and more. 
private int _currentKeyFrame = 0;
private int _nextKeyFrame = 0;
private int _normalizedOffset = 0;
private int _lastOffset = 0;
private bool _movingForward = true;
public float GetFrameValue(int offset)
{
  Debug.Assert(_keyFrames.Count >= 2);           
  if (_movingForward)
  {
    _normalizedOffset += (offset - _lastOffset);
    if (_normalizedOffset >= _keyFrames[_nextKeyFrame].Offset)
    {
      _currentKeyFrame = _nextKeyFrame;               
      _nextKeyFrame += 1;                              
    }
    if (_nextKeyFrame > _keyFrames.Count - 1)         
    {
      if (AutoReverse)
      {
        _currentKeyFrame = _keyFrames.Count - 1;
        _nextKeyFrame = _keyFrames.Count - 2;
        _movingForward = false;
      }
      else if (Repeat)
      {
        _currentKeyFrame = 0;
        _nextKeyFrame = 1;
      }
      else
      {
        Completed = true;
        return _keyFrames[_keyFrames.Count - 1].Value;
      }
    }
  }
  else
  {
    _normalizedOffset -= (offset - _lastOffset);
    if (_normalizedOffset <= _keyFrames[_nextKeyFrame].Offset)
    {
      _currentKeyFrame = _nextKeyFrame;               
      _nextKeyFrame -= 1;                              
Listing 27.12
Calculating the current value
Needs 2+ keyframes 
to work
Move forward 
one keyframe
At end?
Move backward 
one keyframe

702
CHAPTER 27
3D lighting, texturing, and animation
    }
    if (_nextKeyFrame < 0)                         
    {
      if (AutoReverse && Repeat)
      {
        _currentKeyFrame = 0;
        _nextKeyFrame = 1;
        _movingForward = true;
      }
      else
      {
        Completed = true;
        return _keyFrames[0].Value;
      }
    }
  }
  _lastOffset = offset;
  float value;
  if (_normalizedOffset == _keyFrames[_currentKeyFrame].Offset)
    value = _keyFrames[_currentKeyFrame].Value;
  else
  {
    float progress;
    progress = (_normalizedOffset - 
                _keyFrames[_currentKeyFrame].Offset) /
            (float)(_keyFrames[_nextKeyFrame].Offset -
                    _keyFrames[_currentKeyFrame].Offset);
    if (_keyFrames[_nextKeyFrame].EaseIn == EasingType.Linear)
      value = MathHelper.Lerp(                             
                  _keyFrames[_currentKeyFrame].Value,      
                  _keyFrames[_nextKeyFrame].Value,    
                  progress);                              
    else
      value = MathHelper.SmoothStep(                      
                  _keyFrames[_currentKeyFrame].Value,        
                  _keyFrames[_nextKeyFrame].Value,          
                  progress);                             
  }
  return value;
}
The first thing the function in listing 27.12 does is check to make sure you have at
least two keyframes. To keep the code simple, I made the assumption that you’ll always
have two. You could modify the function to always return the same value in the case
where there’s only one keyframe.
 Once verified that there are at least two keyframes, the code next checks to see if
the animation is progressing forward (lowest to highest) or backward (highest to
At beginning?
At keyframe
offset
Linear 
interpolation
Cubic 
interpolation

703
Keyframe animation
lowest) through the keyframes. In either case, it checks to see if you’ve moved beyond
the bounds of the collection. If so, and you’re set up to autoreverse, it reverses direc-
tion. If not, it ends the animation by setting the Completed flag and returning the final
keyframe value.
 After all the code to decide which keyframe you’re dealing with has executed, the
function then moves on to calculate the value to return. Unless you’re exactly on the
offset for a keyframe, the value to return will be interpolated between the value of the
last keyframe and the current keyframe. The position between the two is converted to
a ratio between 0 and 1, with 0.5 being exactly halfway through and 0.75 being three-
fourths of the way over to the next keyframe. This works the same way regardless of
the direction you’re moving.
 Once the progress has been calculated, that progress number is provided to the
appropriate interpolation function to give you the value for that frame of animation. 
 The returned value needs to be provided to a property of a SceneObject in order
to animate it. I’ll look at that next.
27.4.2 Using animation
The value calculation is only half of the animation. The other half is the actual value
you want to animate. Because you’re working in a 3D system, chances are that the
value is going to end up manipulating a matrix.
 The SceneObject already supports X,Y,Z positioning in world space. But it doesn’t
currently support the other thing you want to animate: rotation. Listing 27.13 has the
updated code for SceneObject to support rotation.
public abstract class SceneObject
{
   ...
  private float _xRotationDegrees;
  public float XRotationDegrees
  {
    get { return _xRotationDegrees; }
    set { _xRotationDegrees = value; UpdateWorld(); }
  }
  private float _yRotationDegrees;
  public float YRotationDegrees
  {
    get { return _yRotationDegrees; }
    set { _yRotationDegrees = value; UpdateWorld(); }
  }
  private float _zRotationDegrees;
  public float ZRotationDegrees
  {
    get { return _zRotationDegrees; }
Listing 27.13
Updates to SceneObject with rotation angle settings

704
CHAPTER 27
3D lighting, texturing, and animation
    set { _zRotationDegrees = value; UpdateWorld(); }
  }
  public virtual void UpdateWorld()
  {
    float xrad = MathHelper.ToRadians(_xRotationDegrees);  
    float yrad = MathHelper.ToRadians(_yRotationDegrees); 
    float zrad = MathHelper.ToRadians(_zRotationDegrees); 
    _worldMatrix =                                        
        Matrix.CreateFromYawPitchRoll(yrad, xrad, zrad) *  
        Matrix.CreateTranslation(X, Y, Z);                
  }
}
The X, Y, and Z rotation properties are straightforward. Just as the positioning proper-
ties did, they call UpdateWorld whenever the value changes.
 The UpdateWorld function in listing 27.13 has been augmented to first convert the
rotation degrees to radians, which is what the matrix functions use. Next, it multiplies
the rotation matrix and the translation matrix together to produce both movement
and rotation. Rather than use three separate rotation matrices, you use the single
CreateFromYawPitchRoll function to generate a matrix for all three axes at once.
 The final step in animating the sphere is to create the keyframes and update the
SceneObject properties during each render frame. Listing 27.14 has the new SetupA-
nimation method in the Scene class.
private KeyFrameAnimation _xAnim;    
private KeyFrameAnimation _yAnim;    
private KeyFrameAnimation _rotAnim;  
private void SetupAnimation()
{
  _xAnim = new KeyFrameAnimation(true, true);      
  _xAnim.AddKeyFrame(new KeyFrame(0, -2, EasingType.SmoothStep));
  _xAnim.AddKeyFrame(new KeyFrame(50, -1, EasingType.SmoothStep));
  _xAnim.AddKeyFrame(new KeyFrame(100, -0, EasingType.SmoothStep));
  _xAnim.AddKeyFrame(new KeyFrame(200, 1, EasingType.SmoothStep));
  _xAnim.AddKeyFrame(new KeyFrame(300, 2, EasingType.SmoothStep));
  _yAnim = new KeyFrameAnimation(true, true);             
  _yAnim.AddKeyFrame(new KeyFrame(0, 1.5f, EasingType.Linear));
  _yAnim.AddKeyFrame(new KeyFrame(25, 1.4f, EasingType.Linear));
  _yAnim.AddKeyFrame(new KeyFrame(50, 1.0f, EasingType.Linear));
  _yAnim.AddKeyFrame(new KeyFrame(75, 0, EasingType.Linear));
  _yAnim.AddKeyFrame(new KeyFrame(100, -2, EasingType.Linear));
  _rotAnim = new KeyFrameAnimation(true, true);              
  _rotAnim.AddKeyFrame(new KeyFrame(0, 0, EasingType.Linear));
  _rotAnim.AddKeyFrame(new KeyFrame(300, 359, EasingType.Linear));
}
Listing 27.14
Building the keyframes in the Scene
Calculate 
radians
Update World
matrix
Horizontal
Vertical
Rotation

705
Keyframe animation
The function sets up three animations. The first animation, _xAnim, moves the ball
from left to right. It’s set to autoreverse and to repeat, so it’ll continue moving left to
right forever. The second animation, _yAnim, is responsible for moving the ball up
and down. This animation also autoreverses and loops. Its total duration is 100, so it’ll
play three times when moving across the screen. The final animation, _rotAnim,
rotates the sphere one full turn over its traversal of the screen. When it reaches the
opposite side, the autoreverse setting will cause it to reverse the direction of the ani-
mation. This is all consistent with how the Amiga demo works.
 The keyframes themselves are pretty crude. You could add additional keyframes to
make a smoother bounce animation.
 This function needs to be called from somewhere, so add a call to the new Setup-
Animation method as the very last line of LoadObjects. 
 Once you have that in place, you’re ready to perform the animation. Listing 27.15
shows the updated Scene.Draw method as well as the AnimateSphere function, which
is called for every render frame.
private int frameNumber = 0;
private void AnimateSphere()
{
  _sphere.X = _xAnim.GetFrameValue(frameNumber);  
  _sphere.Y = _yAnim.GetFrameValue(frameNumber);  
  _sphere.YRotationDegrees =                       
              _rotAnim.GetFrameValue(frameNumber);
}
public void Draw()
{
  GraphicsDevice.Clear(ClearOptions.Target | ClearOptions.DepthBuffer, 
        BackgroundColor, 1.0f, 0);
  foreach (SceneObject o in Objects)
  {
    AnimateSphere(); 
    o.Draw(this);
    frameNumber++;                        
  }
}
The Draw method in the listing has been modified to call the animation function and
also increment the frameNumber counter. The frame number counter is for render
frames, not keyframes. Unfortunately the term “frame” is a bit overloaded here. Note
also that you don’t do any bounds checking on the frame number, so if it runs long
enough to get to int.MaxValue, it’ll eventually fail. Granted, that’ll take a bit over a
year of continuous running at 60 frames per second. Simply causing it to wrap back
Listing 27.15
Updated Draw method and new AnimateSphere in the Scene
Animate values
Frame counter

706
CHAPTER 27
3D lighting, texturing, and animation
around to zero won’t fix the issue—the KeyFrameAnimation class won’t work correctly
at that point. For a demo, though, this is robust enough.
 Run the application. You should see a relatively crude animation of a ball bounc-
ing across the screen—a couple of stills are shown in figure 27.9. You’ve just imple-
mented your own keyframe animation system! Go ahead, pat yourself on the back.
You deserve it.
 As is the case in Silverlight 2d, the difference between simple animation and good-
looking animation in 3D is a significant amount of framework code. For that reason, if
you intend to do animation, I recommend that you use something like Babylon. It has
built-in support for keyframe and other types of animation models, including nice eas-
ing functions.
 Some things you may want to do if you continue creating your own animation sys-
tem is to support additional easing functions and enable easing both in and out of a
keyframe; you can’t get a realistic bounce with the current approach unless you use a
ton of frames.
 The other thing you’ll want to do is switch the whole system over to use time-based
animation rather than frame number based. This requires you to keep track of “game
time” across the system, but it’ll provide a great frame rate–independent approach for
rendering and animation. 
 Caveats aside, this is a pretty decent animation system that you can build on. Once
you understand the workings of a keyframe-based system, you’ll be able to augment
this one to build your own or more easily use other animation systems, including
those ported from the desktop and Windows Phone. 
27.5
Summary
Nothing brings a 3D model to life like a good shader. In XNA, the shaders are encapsu-
lated by effects. In the examples in this chapter, you used the flexible and probably
Figure 27.9
Two still frames from the animated Amiga Boing ball demo, recreated in Silverlight 5. Notice 
the perspective applied to the ball, as well as the shading.

707
Summary
misnamed BasicShader. It provided not only light but also the ability to texture your
creation with graphics drawn outside Silverlight.
 Texturing your objects is a good way to get additional detail without investing in
additional geometry. The background of the whole scene is just two triangles, but the
tiled texture makes it look like it’s more complex than just four vertices in 3D space.
 As important as lighting is, animation is what makes your work noticeable.
Whether you design games or 3D data visualization, having the ability to animate val-
ues—either using keyframes or using mouse gestures from the user that directly
manipulate matrices—is a great way to take the UI to the next level.
 These two chapters have introduced you to using 3D in Silverlight. 3D is a huge
topic, worthy of its own book. There are many more topics of interest, including
bump mapping, loading meshes and complex geometry, other lighting, and shading
models… not to mention the awesome 3D engines/toolkits that offer even more capa-
bilities and more robust animation systems.
 It was exciting to explore Silverlight 3D with you. Incidentally, this was the very last
chapter I wrote when completing this book, and I had a ton of fun doing it. I can’t wait
to see what you build with it. Another area of Silverlight that’s both fascinating and
extremely useful is Media. Over the next two chapters, you’ll explore different ways to
use media, both runtime generated and loaded from files, in your applications.

 
 
 
 
 

Part 5
Making the most
of the platform
With traditional web development technologies, complex applications
often hit roadblocks when it comes to integrating with the local system. They
have difficulty accessing local resources, working with windows, and even doing
things as simple as printing a report with proper page breaks. Silverlight has
evolved to the point where developers and designers are able to create these
truly complex and rich applications, often in a business context.
 In the next five chapters, you’ll explore the ways Silverlight integrates with
the local operating system to provide a better experience. First, you’ll see the
most basic form of integration: creating windows. Silverlight has window and
pop-up/dialog solutions that range from simple on-page simulated windows all
the way to full-fledged operating system windows on both Windows and Mac.
 Next, you’ll look at ways to integrate navigation into your applications, both
integrating with the browser history and maintaining your own separate history.
You’ll use some of the great built-in templates to help you structure the applica-
tions in a navigation-friendly way.
 Then, because one of the most common points of integration is working with
local files, you’ll examine the various ways that Silverlight can work with files
both in partial trust and elevated trust applications.
 Many applications, especially business applications, need to send documents
and reports to local and remote printers. Silverlight has built-in support for both
bitmap printing and PostScript vector printing, both of which you’ll explore in
depth while building a simple reporting framework. 

 Finally, you’ll dive into platform integration: working with COM objects and Win-
dows APIs. As a part of that, you’ll explore speech synthesis and device integration.
You’ll integrate with the Windows 7/8 taskbar and even use a little Win32 API magic
to expand your printing capabilities.

711
Pop-ups, windows, and
full-screen applications
There comes a time when just about any nontrivial application needs to make a
request of the user that can’t be entirely contained on the current screen. In Win-
dows Forms and previous technologies like Visual Basic 3+, the programmer would
create a form that would be shown at runtime. The form would have a few fields
and some sort of confirmation button. This was extremely easy to do because,
quite frankly, it was the primary method of application navigation and structure at
the time.
 When browser applications first started becoming more common, we switched
to moving users to secondary pages in more of a wizard-type format. This approach
was cumbersome and involved any number of page loads during the process. Even-
tually, web developers came around to what client developers knew all along:
This chapter covers
■
Working with Popup and ChildWindow elements
■
Creating native OS windows
■
Customizing window chrome
■
Taking your application full-screen

712
CHAPTER 28
Pop-ups, windows, and full-screen applications
popping up a window makes perfect sense in a keyboard- and mouse-oriented envi-
ronment. Libraries like jQuery made it easier for those developers to simulate win-
dows by overlaying content on the page, eliminating the page loads and other
transitions.
 When Silverlight came out, it was first a web technology. Although you could cer-
tainly argue that it was a desktop technology in web clothing, it took inspiration from
browser applications and the approaches used there.
 Silverlight’s first approaches to displaying the pop-up window and dialog involved
using the Popup element and later the ChildWindow control that built on it. These pro-
vided a great way to have a 100 percent XAML way of defining what looked much like
a window in your application. But because these were similar in approach to the web-
based windows HTML/JS programmers had been using, they suffered from the same
limitations.
 In Silverlight 5, Microsoft enabled support for creating your own native OS win-
dows. Unlike the previous approaches (which are still valid and useful in many sce-
narios), these were real windows with (in Windows) a real hWnd. That meant they
could jump outside of the Silverlight drawing surface’s bounds, even on to separate
windows.
 But native OS windows lacked one thing that made the ChildWindow approach so
good: they didn’t enable customization of the window chrome. The Silverlight team
added in that support as well, so your native OS windows could look almost as good as
your ChildWindow-based simulated windows. 
 Windows are great and useful. But what about those times when you want a more
kiosk-type look for your application? What if you wanted the local deli to have its self-
service sandwich ordering system written in Silverlight? Certainly you wouldn’t want a
lot of OS cruft appearing on the screen with your application. For those scenarios and
others, the Silverlight team included support for full-screen windows. 
 This chapter explores windows of all types and full-screen applications. I’ll start
with how to use the most basic of windowing elements: the popup element. As popup is
rarely used directly for windowing purposes, I’ll then move right into using the
ChildWindow control for creating real dialog-like interactions in your applications.
From there, I’ll move on to the exciting new support for creating native OS windows
and show you how to customize them with your own chrome. I particularly like how
the team included easy-to-use support for resizing and moving from your custom
chrome windows. The chapter wraps up with a look at how to take your application
into full-screen mode.
28.1
Showing pop-ups and child windows
There are certain times when you need to grab the user’s attention and display some-
thing that overlays other page content. Maybe you need to display details about a crit-

713
Showing pop-ups and child windows
ical error. You could do this with the message box, but that’s often limited to simply
displaying static text. For more intricate dialogs, you may want to consider the other
two alternatives available in Silverlight.
 In this section, you’ll learn about the two types of XAML-based visual prompts avail-
able in Silverlight. I’ll briefly cover the Popup control, followed by the ChildWindow
control—a control that provides the capability to display in-Silverlight dialogs. The
ChildWindow control is the more user-friendly, and it’s more likely to be used directly
in your applications, so I’ll spend the majority of the section on it.
28.1.1 The Popup control
In Silverlight 2, if you wanted to create a dialog-like experience, you likely used the
Popup control from the System.Windows.Controls.Primitives namespace. The Popup
control provided a way to guarantee that your content would show up at the top of the
z-order, regardless of which control created it. But it wasn’t really a dialog substitute.
 The Popup control has no visuals of its own. Typically, you’ll enclose a UserControl
or a number of elements within the Popup to give it the behavior you want. Because
sizing and positioning can be tricky otherwise, you should apply a fixed size to the
content in the Popup and then perform any centering or other position calculations.
 Assuming that the XAML namespace xmlns:primitives points to System
.Windows.Controls.Primitives, the syntax for the Popup element is simple:
<primitives:Popup x:Name="MyPopup"> content </primitives:Popup>
To display the pop-up in the example, you’d then use the IsOpen property:
MyPopup.IsOpen = true;
In Silverlight 3 and 4, the use of the Popup control is more for floating nondialog
items to the top of the stack but not for simulating dialog boxes, so I won’t spend
much time on it. The Popup control is used by Silverlight to support other elements
such as tooltips, the drop-down in the ComboBox, and, of course, the ChildWindow con-
trol introduced with Silverlight 3.
28.1.2 Displaying a dialog box with the ChildWindow control
Silverlight 3 introduced a new class, ChildWindow, which provides a window-like expe-
rience over the base Popup control. Where the Popup control is an infrastructure class
that provided only z-order management, the ChildWindow adds window overlays, dia-
log results, OK/Cancel buttons, and window title functionality.
 Unlike Popup, ChildWindow is considered a first-class top-level element, like Page
and UserControl, and has a template in the project items template list, as shown in
figure 28.1.
 That said, ChildWindow isn’t located in the core Silverlight runtime; it’s located in
the System.Windows.Controls assembly in the SDK. The primary reason for keeping

714
CHAPTER 28
Pop-ups, windows, and full-screen applications
it out of the runtime is that it’s not an essential or enabling technology; you could live
with Popup if you absolutely needed to.
 After you create a new ChildWindow, you’re presented with its default template. 
Result:
XAML:
<controls:ChildWindow x:Class="WindowExample.ChildWindow1"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:controls="clr-namespace:System.Windows.Controls;
    ➥ assembly=System.Windows.Controls"
    Width="400" Height="300" Title="ChildWindow1">
Listing 28.1
The default ChildWindow template
Figure 28.1
The Silverlight ChildWindow is a first-class element like UserControl and Page.

715
Showing pop-ups and child windows
  <Grid x:Name="LayoutRoot" Margin="2">
    <Grid.RowDefinitions>
      <RowDefinition />
      <RowDefinition Height="Auto" />
    </Grid.RowDefinitions>
                                             
    <Button x:Name="CancelButton" Content="Cancel"
      Click="CancelButton_Click"
      Width="75" Height="23" HorizontalAlignment="Right"
      Margin="0,12,0,0" Grid.Row="1" />
    <Button x:Name="OKButton" Content="OK"
      Click="OKButton_Click" Margin="0,12,79,0" Grid.Row="1"
      Width="75" Height="23" HorizontalAlignment="Right" />
  </Grid>
</controls:ChildWindow>
Listing 28.1 shows the default look and feel of the ChildWindow control. Before you
get into how to customize that, I’ll cover the mechanics of showing and hiding the
window.
SHOWING AND HIDING THE CHILDWINDOW
A ChildWindow is typically displayed from code rather than included as an inline ele-
ment in XAML. To facilitate this, the control has several members that handle show-
ing, closing, reporting results, and allowing cancellation. Table 28.1 lists those
members and their related functions. 
Table 28.1
Properties, methods, and events related to showing and closing/hiding the ChildWindow
Member
Description
DialogResult property 
A nullable Boolean that indicates whether the dialog was accepted or 
canceled. This is typically set to true in the handler for an OK button 
and false in the handler for a Cancel button.
Show method 
Displays the child window and immediately returns. Whereas the behavior 
of a ChildWindow is logically modal, from a programmatic standpoint, 
Show is a nonblocking and therefore nonmodal method.
Close method 
Closes the window. Typically, this is called from a button on the child win-
dow itself.
Closing event 
Raised when the child window is closing. The handler for this event has 
the opportunity to cancel the close operation and force the window to 
stay open.
Closed event 
Raised after the child window has been closed. Note that due to anima-
tions, the window may still be visible on the screen for a moment longer, 
but it’s in the process of closing for good. Use this event to inspect the 
DialogResult property.
Window content 
goes here

716
CHAPTER 28
Pop-ups, windows, and full-screen applications
The typical way to use a ChildWindow is to call the Open method from code and to take
some action based on the dialog result available during the Closed event. Listing 28.2
shows this process in more detail.
C#:
void MainPage_Loaded(object sender, RoutedEventArgs e)
{
  ChildWindow dialog = new MyDialog();
  dialog.Closed += (s, ea) =>
    {
      if (dialog.DialogResult == true)          
      { ... }
      else if (dialog.DialogResult == false)       
      { ... }
      else 
      { ... }
    };
  dialog.Show();
}
The example shows how to display a ChildWindow and handle the three possible
DialogResult values set when the user closes the window. Note that this example also
uses a lambda expression to create the event handler. This is a shortcut to create a
delegate inline in your code rather than create a separate event handler function. In
this example, s is the variable that contains the sender and ea is the variable that con-
tains the event arguments. The code to display the window could’ve also been written
like this:
ChildWindow dialog = new MyDialog();
dialog.Closed += new EventHandler(dialog_Closed);
dialog.Show();
In that instance, you’d need to create a separate function named dialog_Closed that
had the event handler logic in it. Either way is valid.
 Note also that you do a true/false/else check on the DialogResult value. This is
because the DialogResult is a nullable Boolean type, and it’s not usually sufficient to
check for true or false. Nullable Booleans also don’t allow you to write code like this:
if (dialog.DialogResult)     { ... }
You’ll get a compile-time error unless you cast the value to a regular bool. For that
reason, you check explicitly against true, false, and the null (default) value.
 Closing the window is just as easy as opening it, although you’ll typically do it from
code on the ChildWindow itself. To close, simply call the Close function. If you want to
perform any checking on the selections made in the window, be sure to wire up the
Closed event as shown in listing 28.2.
Listing 28.2
Displaying a ChildWindow and capturing the DialogResult
User clicked OK
User clicked Cancel

717
Creating native windows
 When you ran the code in listing 28.1, you probably noticed that the content behind
the window was overlaid with a gray rectangle. The color and opacity of the overlay are
a couple of the knobs you can tweak to customize the way the ChildWindow looks. 
CUSTOMIZING THE CHILDWINDOW
Like almost everything else in Silverlight, you can do basic customization of a Child-
Window to change things such as background and overlay colors without messing
around with the control template. Some of those properties specific to ChildWindow
are listed in table 28.2.
The ChildWindow provides the capability to create any in-application modal-style dia-
log that you need. Sometimes, though, what you really need is a free-floating window
that doesn’t block the rest of the UI. For those cases, you have native operating system
windows.  
28.2
Creating native windows
In versions of Silverlight before 5, you didn’t have the ability to create new native OS
windows. If you wanted to pop up content over your other application, you had to use
the popup element or the derived ChildWindow control, both of which I just discussed.
Those work well in a number of situations but don’t act as true OS windows. Specifi-
cally, they can’t escape the bounds of your main application because they are normal
XAML elements with some z-order trickery.
 In one application I worked on in Silverlight 3, I could’ve used real windows. The
customer was porting from an existing Windows Forms application that already had
the ability to open new windows and place them anywhere on any monitor. The lack
of support for native windows cramped the workflow in the new UI and effectively
killed any idea of supporting multiple monitors from a single application.
 Silverlight 5 added support for true OS windows. They’re managed and created by
the OS as native windows with Silverlight content inside them. Operating system
Table 28.2
Properties of the ChildWindow control
Property
Description
HasCloseButton 
Set this value to determine whether the close button, typically at the upper right, 
is visible or collapsed. If you set HasCloseButton to false, make sure you 
provide another way to close the window.
OverlayBrush 
When the ChildWindow is displayed, it includes an overlay that covers all other 
content in the current Silverlight application. This gives the illusion of a modal 
dialog. Use OverlayBrush to set the brush to be used for that overlay.
OverlayOpacity 
Sets the opacity of the overlay. A higher opacity means less background content 
shines through.
Title 
Displays content in the window title bar. Although typically text, this can be any 
element.

718
CHAPTER 28
Pop-ups, windows, and full-screen applications
windows are supported on both the Mac and PC in elevated trust out-of-browser appli-
cations. They aren’t supported in-browser, regardless of trust level.
 In this section, you’ll learn how to create a native window. I’ll cover how to set the
usual properties such as width and height, as well as title and more. From there, you’ll
learn how to work with the collection of open windows.
 After the basics of window creation are covered, you’ll learn how to create com-
pletely custom window chrome to give the window the look you want. The section will
wrap up with code for a window with custom chrome and functioning resizing, mov-
ing, minimizing, restoring, maximizing, and closing functionality. You’ll be surprised
at how short that listing is due to all the built-in support in Silverlight.
28.2.1 Creating a normal window
Application-created windows in Silverlight use the same base Window class you use
when working with the main application window in out-of-browser mode. The created
windows become a child of the main out-of-browser window and close when it closes.
But they’re not modal and they don’t activate or minimize/maximize in sync with the
main window. In that way, they are children but with rather laissez-faire1 parents.
 Operating system windows are supported only in trusted out-of-browser applica-
tions. Trying to create them from a normal out-of-browser or an in-browser applica-
tion will result in an exception when instantiating the Window class.
 Windows are created completely from code. You can’t create them in XAML like
you can a ChildWindow element. To create a window, create a variable of type Window,
then assign it some content, set the dimensions and a few other properties, and call
the Show method to display the window. Listing 28.3 shows the whole process assum-
ing you have a button on the page named OpenWindow.
private void OpenWindow_Click(object sender, RoutedEventArgs e)
{
  Window child = new Window();
  child.Width = 500;
  child.Height = 300;
  child.Title = "This is a Child Window";
  child.WindowState = WindowState.Normal;
  child.Content = null;  
  child.Show();
}
Run the code and click the Open Window button on the main form. (Remember, the
application must be a trusted out-of-browser application or you’ll get an exception.)
The result you’ll see is an empty pop-up window. You are free to move that window
1 I’ve had eight years of French language schooling, and taught programming in France twice. About all I
remember is “laissez-faire” and a few colorful phrases.
Listing 28.3
Displaying a window from code
No content

719
Creating native windows
around the screen, even onto your secondary screens if you have more than one dis-
play on your machine. Close the window as you would any other OS window.
CONTENT
Of all the properties available on the Window class, the most useful for child windows is
the Content property. In the previous example, I set it to null just to expedite showing
the window, but you’d never display an empty window in a real application. 
 This property is where you provide everything that sits inside the window client
area (the area within the OS window chrome when using the default window style). In
most cases, you’ll create a UserControl with the window content and assign an
instance of it in code, like this:
child.Content = new MyChildWindowContentUserControl();
If you follow that pattern, your application will end up with a number of UserControl
instances in the project, each corresponding to a child window. You’ll be able to
design your window layout but as a UserControl. To make it easier to create windows
based on those user controls, you may want to add a few properties like Title,
WindowWidth, and WindowHeight to a new WindowUserControl base class from which
you derive all your window user controls.
 In addition to Content, there are a number of other properties you can set in the
window, most of them shown in the previous listing. Of them, WindowState demands a
little more explanation.
WINDOW STATE
In most operating systems, windows can have a state that’s independent of its defined
size. For example, you can size the window to take up the full screen, but the borders
(on Windows) will still be visible. If you instead set the window’s state to Maximized,
it’ll take up the entire screen (minus any static elements like the task bar) and won’t
display any borders.
Why windows won’t work directly in XAML
If you’re familiar with the WPF way of creating windows, you may find the Silverlight
approach a little strange. Rather than have the Window class be a designable content
control with a template and code-behind, the team decided to make it a type that de-
rives directly from FrameworkElement. 
This decision no doubt avoids some issues the team ran into in the implementation,
especially when it came to ownership of the window and its content and reuse of the
base Window class, but it also eliminates the possibility of using the window directly
in markup. The window would need to derive from UIElement for that to work, and
from ContentControl for it to be designable with content like a UserControl.
The initial beta of Silverlight 5 lacked a Show method for the Window class. Strangely,
you had to use the Visibility property just as you did with the ChildWindow class.
I was happy to see a proper method introduced in time for the RC (Release Candidate).

720
CHAPTER 28
Pop-ups, windows, and full-screen applications
 You can set the window state at any time, although you’ll typically set it when the
window is first opened and then let the user change it from there. The three possible
states for windows are shown in table 28.3.
When WindowState is Normal, you can also set the Left and Top properties to position
the window and Width and Height to set its size. Those properties have no immediate
effect when WindowState is Minimimized or Maximized, but they do come into play if
the user restores the window manually using the restore button.
 Regardless of the WindowState you selected, the window will behave as the operat-
ing system dictates. That means, for example, on Windows 7 you’ll see a preview
thumbnail of your child window when you hover over your application in the task bar.
 Once you have a number of child windows open, it can be a chore to track them
and their lifetime. For that reason, Silverlight provides a basic tracking list.
THE WINDOW LIST
Look at the code in listing 28.3. One strange thing here is that the Window variable
“child” goes out of scope at the end of the method, but the window remains open and
active. What’s holding a reference to it to allow that to happen?
 Silverlight is tracking each open window in the Application.Current.Windows
collection. This is a WindowCollection, which is a lightweight sealed collection to
which you can’t manually add or remove windows. It’s simply a tracking mechanism.
Note that it isn’t an observable collection, so to bind to it you’ll need to manually
refresh your targets.
 The window list includes any open child windows as well as the main out-of-
browser application window. Figure 28.2 shows an example application that lists all
the open windows.
 The first item in the list is always the main out-of-browser window. Any other win-
dows are ones opened using the Window class discussed in this section. 
 One odd thing you’ll notice is the Left position of several of the windows. On my
rig, I have two 30” displays side by side. The main display is in front of me and the sec-
ondary to the left. Silverlight has no built-in knowledge of multiple-display configura-
tions. Therefore, to position windows on other screens you need to use the
appropriate coordinates as though it were one giant screen with 0,0 at the top left of
the main display. You may be able to get the screen configuration using native Win32
Table 28.3
Possible values for WindowState
State
Description
Normal
Shows the window in the normal state taking up a portion of the screen as 
based on the Left and Top position and Width and Height values.
Minimized
Minimize the window according to OS rules.
Maximized
Maximize the window to take up the entire screen.

721
Creating native windows
API calls such as EnumDisplayDevices and PInvoke (covered in chapter 32) only on
Windows, but unfortunately it isn’t something you can use cross-platform.
 Listing 28.4 shows the XAML UI you’ll use for the window list example shown in fig-
ure 28.2. In this example, you’ll update a ListBox with the titles of windows as they’re
opened.
<UserControl x:Class="WindowExample.MainPage"
  xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
  xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
  xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
  mc:Ignorable="d"
  d:DesignHeight="300" d:DesignWidth="400">
  <Grid x:Name="LayoutRoot" Background="White">
    <Grid>
      <Grid.RowDefinitions>
        <RowDefinition Height="Auto" />
        <RowDefinition Height="*" />
      </Grid.RowDefinitions>
      <Button x:Name="OpenWindow" Click="OpenWindow_Click"
              Grid.Row="0" Content="Open Window"
              HorizontalAlignment="Center" VerticalAlignment="Top"
              Width="125" Height="30" Margin="10" />
      <ListBox x:Name="WindowList" Grid.Row="1" Margin="10">  
        <ListBox.ItemTemplate>
          <DataTemplate>
            <Grid>
              <Grid.ColumnDefinitions>
                <ColumnDefinition Width="200" />
                <ColumnDefinition Width="75" />
                <ColumnDefinition Width="75" />
              </Grid.ColumnDefinitions>
          
              <TextBlock Grid.Column="0" Text="{Binding Title}" />
Listing 28.4
The XAML for the WindowList example
Figure 28.2
An application showing 
four child windows plus the main 
window. Note the negative left 
positions of the windows caused by 
moving them to the secondary display 
to the left of my main display.
WindowList 
ListBox

722
CHAPTER 28
Pop-ups, windows, and full-screen applications
              <TextBlock Grid.Column="1" Text="{Binding Left}" />
              <TextBlock Grid.Column="2" Text="{Binding Top}" />
            </Grid>
          </DataTemplate>
        </ListBox.ItemTemplate>
      </ListBox>
    </Grid>
  </Grid>
</UserControl>
The XAML in the listing creates a UserControl with a ListBox for the list of windows,
as well as the button you’ve been using all along. The code-behind will be slightly dif-
ferent because you’ll need to set the window title so it includes a window number for
differentiation. The code will also need to make sure the ListBox stays updated, as
shown next.
private int _windowNumber = 0;
private void OpenWindow_Click(object sender, RoutedEventArgs e)
{
    Window child = new Window();
    child.Width = 500;
    child.Height = 300;
    child.Title = "Child Window " + _windowNumber;
    child.WindowState = WindowState.Normal;
    child.Content = null;
    child.Show();
    _windowNumber++;
    WindowList.ItemsSource = null;                        
    WindowList.ItemsSource = Application.Current.Windows;
}
Listing 28.5 looks similar to listing 28.3, except you’re adding a _windowNumber variable
to keep track of the current window number. Using the count from the Windows collec-
tion wouldn’t suffice—as that doesn’t account for windows that have been closed.
 Note the ItemsSource set over two lines. You set it to null and then to the Windows
property to force binding to refresh. You can also refresh other ways using the Binding-
Expression and Binding objects, but simply setting to null first is an easy way to do it.
Note that this is only necessary because the Windows collection isn’t observable. For that
reason, this ListBox doesn’t automatically update when windows are closed.
 Creating a standard-looking window is a great feature of Silverlight. If you want to
integrate well with the OS look, that’s the way to go. But one of the real benefits of
using Silverlight is being able to create your own look. After all, you can customize the
window chrome on a regular out-of-browser application window, and you’d expect to
Listing 28.5
MainPage code-behind for the window list example
Refresh binding

723
Creating native windows
be able to make the new pop-up windows match. As you’d expect, Silverlight has you
covered and then some. Custom window chrome is both easy to create and flexible in
how it can be used.
28.2.2 Customizing window chrome
The chrome of a window is all of the nonclient area. Run the previous example again,
and you’ll see borders, title bar, buttons, and more. Everything outside of that white
rectangle in the middle (the client area) is the window chrome. Typically, the OS has
complete control of that area and is responsible for drawing everything in the chrome. 
 Sometimes, the OS chrome clashes with the look you’re aiming for in your applica-
tion. Your cool charcoal gray and black application with custom fonts looks strange
when it’s wrapped by a border of blue glass from Windows Aero.
 If you eschew that wonderful support provided by the OS, you suddenly have to
recreate it all yourself. It’s all or nothing: the OS gets to do things its way, or you have
to do it all.
 Listing 28.6 is the same example you’ve been working on, but it adds a red-filled
Grid for the content and sets the WindowStyle to WindowStyle.None to stop the OS
from painting the chrome. The result is a red rectangle on your screen, with no way to
move it, resize it, close it, or otherwise interact.
private int _windowNumber = 0;
private void OpenWindow_Click(object sender, RoutedEventArgs e)
{
  Window child = new Window();
  Grid content = new Grid();                
  content.Background = new SolidColorBrush(Colors.Red);
  child.Width = 500;
  child.Height = 300;
  child.Title = "Child Window " + _windowNumber;
  child.WindowState = WindowState.Normal;
  child.WindowStyle = WindowStyle.None;        
  child.Content = content;
  child.Show();
  _windowNumber++;
  WindowList.ItemsSource = null;
  WindowList.ItemsSource = Application.Current.Windows;
}
Close the main window (or stop debugging) to close the errant child window. Before
you see how to remedy this situation, it’s a good time to look at the WindowStyle enum.
Listing 28.6
A window with WindowStyle set to None
Grid content
WindowStyle None

724
CHAPTER 28
Pop-ups, windows, and full-screen applications
WINDOWSTYLE
As you saw in listing 28.6, the WindowStyle property can have a profound effect on
how the window appears. There are three possible values for WindowStyle, but only
two of them are valid for windows you create. Table 28.4 shows all three.
For the remainder of this section, you’ll be
working with a window with its Window-
Style set to None so that you may provide
custom window chrome.
 To create your own window chrome,
you first need to understand the parts the
OS typically provides so that you can repli-
cate them. Figure 28.3 shows the parts of a
window.
 The parts of the window have the fol-
lowing typical functions:
■
Title bar—This is where you typically
drag to move the window. The title
bar also contains the minimize, max-
imize, and close buttons.
■
Left edge, right edge—The left and right edges can be dragged horizontally to
increase or decrease the width of the window.
■
Bottom edge—The bottom edge can be dragged vertically to increase or decrease
the height of the window.
■
Bottom-left corner, bottom-right corner—The bottom-left and bottom-right corners
enable resizing the window both horizontally and vertically at the same time
I say “typical functions” because you don’t have to implement everything this way. If
you don’t want your window to allow resizing, you could support only movement. If
you don’t want to allow minimize or maximize, you can leave those buttons off the
window. In many cases, custom implementations allow dragging a window to move it
from anywhere inside the client area, not just the title bar. 
Table 28.4
The three possible values for WindowStyle
Style
Description
SingleBorderWindow
A normal border window. The OS dictates how the chrome is 
painted.
None
Don’t paint any OS chrome. This is the setting to use for cus-
tom chrome.
BorderlessRoundCornersWindow
You can’t use this from your own windows; it’s reserved for 
use only by the main window. Because the Window class is 
the same class used for the main window, this value exists 
but will throw an exception if used on created windows.
Figure 28.3
The key parts of a typical window 
that allows resizing

725
Creating native windows
 Outside of that, I don’t recommend changing known patterns. For example, I
wouldn’t use the bottom-right corner for moving the window. With that in mind, let’s
implement a little functionality.
MOVING THE WINDOW
One of the easiest interactions is moving the window. Why is it so easy? Because Silver-
light provides the DragMove method, which requires nothing more than a single
method call to enable users to move the window as much as they want. 
private int _windowNumber = 0;
private void OpenWindow_Click(object sender, RoutedEventArgs e)
{
  Window child = new Window();
  Grid content = new Grid();
  content.Background = new SolidColorBrush(Colors.Red);
  content.MouseLeftButtonDown += (s,ea) =>
    {
      child.DragMove();                    
    };
  child.Width = 500;
  child.Height = 300;
  child.Title = "Child Window " + _windowNumber;
  child.WindowState = WindowState.Normal;
  child.WindowStyle = WindowStyle.None;
  child.Content = content;
  child.Show();
  _windowNumber++;
  WindowList.ItemsSource = null;
  WindowList.ItemsSource = Application.Current.Windows;
}
Listing 28.7 shows how to use DragMove inside your own window. Note that you’re wir-
ing up the MouseLeftButtonDown event on the content grid, not the window itself.
Why? Because the window has no chrome, and a Grid will naturally stretch to fill its
parent, the mouse event will go to the grid. In addition to this, there’s the practical
matter that you’ll normally wire this event up on a title bar, which is going to be a grid
or some other element. In any case, MouseLeftButtonDown is the event you want to
use, because that starts a logical drag operation.
 Run the application and click and drag on the red rectangle. You’ll see you can
drag the window all over the screen.
RESIZING THE WINDOW
There are more places on the window with which the user interacts, so resizing a window
is slightly more complex than moving it. For that reason, you want to create something
Listing 28.7
Using DragMove to move the window
DragMove

726
CHAPTER 28
Pop-ups, windows, and full-screen applications
with a little more structure. Listing 28.8 shows the implementation of a grid with discrete
elements for the title bar and the different drag points shown in figure 28.3.
private Grid BuildChromeElement(                  
      int row, int column, Color background,         
      Cursor cursor)                                    
{
  Grid element = new Grid();
  element.SetValue(Grid.RowProperty, row);
  element.SetValue(Grid.ColumnProperty, column);
  element.Background = new SolidColorBrush(background);
  element.Cursor = cursor;
            
  return element;
}
private Grid BuildChrome(UIElement content, Window window)
{
  Grid chrome = new Grid();                             
  ColumnDefinition leftColumn = new ColumnDefinition();
  leftColumn.Width = new GridLength(10);
  ColumnDefinition middleColumn = new ColumnDefinition();
  middleColumn.Width = new GridLength(1, GridUnitType.Star);
  ColumnDefinition rightColumn = new ColumnDefinition();
  rightColumn.Width = new GridLength(10);
  chrome.ColumnDefinitions.Add(leftColumn);
  chrome.ColumnDefinitions.Add(middleColumn);
  chrome.ColumnDefinitions.Add(rightColumn);
  RowDefinition topRow = new RowDefinition();
  topRow.Height = new GridLength(40);
  RowDefinition middleRow = new RowDefinition();
  middleRow.Height = new GridLength(1, GridUnitType.Star);
  RowDefinition bottomRow = new RowDefinition();
  bottomRow.Height = new GridLength(10);
  chrome.RowDefinitions.Add(topRow);
  chrome.RowDefinitions.Add(middleRow);
  chrome.RowDefinitions.Add(bottomRow);
  var titleBar = BuildChromeElement(0, 0, Colors.Purple, 
                                          Cursors.Arrow);
  titleBar.SetValue(Grid.ColumnSpanProperty, 3);
  titleBar.MouseLeftButtonDown += (s, ea) => 
      window.DragMove();                               
  var leftResize = BuildChromeElement(1, 0, Colors.Orange, Cursors.SizeWE);
  leftResize.MouseLeftButtonDown += (s, ea) => 
        window.DragResize(WindowResizeEdge.Left);
  var rightResize = BuildChromeElement(1, 2, Colors.Blue, Cursors.SizeWE);
Listing 28.8
Implementing resize in the window using a grid layout
Build element
Chrome grid
Title bar
Buttons go here

727
Creating native windows
  rightResize.MouseLeftButtonDown += (s, ea) => 
        window.DragResize(WindowResizeEdge.Right);
  var bottomResize = BuildChromeElement(2, 1, Colors.Black,
                                              Cursors.SizeNS);
  bottomResize.MouseLeftButtonDown += (s, ea) => 
        window.DragResize(WindowResizeEdge.Bottom);
  var bottomRightCorner = BuildChromeElement(2, 2, Colors.Yellow,
                                                   Cursors.SizeNWSE);
  bottomRightCorner.MouseLeftButtonDown += (s, ea) => 
        window.DragResize(WindowResizeEdge.BottomRight);
  var bottomLeftCorner = BuildChromeElement(2, 0, Colors.White,
                                                  Cursors.SizeNESW);
  bottomLeftCorner.MouseLeftButtonDown += (s, ea) => 
        window.DragResize(WindowResizeEdge.BottomLeft);
  content.SetValue(Grid.RowProperty, 1);                   
  content.SetValue(Grid.ColumnProperty, 1);
  chrome.Children.Add(leftResize);
  chrome.Children.Add(rightResize);
  chrome.Children.Add(titleBar);
  chrome.Children.Add(bottomLeftCorner);
  chrome.Children.Add(bottomRightCorner);
  chrome.Children.Add(bottomResize);
  chrome.Children.Add(content);
  return chrome;
}
This listing includes two helper functions that build the window chrome. The first,
BuildChromeElement, wraps common operations for defining each bit of chrome. It
sets the grid row and column, the background color, and the cursor.
 The second function, BuildChrome, is responsible for building the grid of window
chrome. The chrome is positioned in a 3 x 3 grid with the center being the content
area. Into each of those outer grid cells (except the top left and top right), you place a
chrome element. (To make it easy to see in the sample, I colored each differently.) 
 Each chrome element is responsible for handling the MouseLeftButtonDown event
and calling DragMove or DragResize as appropriate.
 In this example, you can move the window only through the title bar. This is consis-
tent with regular Windows behavior, but it isn’t a hard requirement. There are a cou-
ple of other possible resize points as well, specifically the top bar and top left and top
right. I left them out simply for space concerns here.
DragResize is new to this example. The DragResize method works much like the
DragMove method in that you only need to call it from the MouseLeftButtonDown
event. Once called, the system takes over and handles window resizing for as long as
the mouse is down. Silverlight knows which way to resize based on the WindowRe-
sizeEdge you pass to DragResize. The values for that enum are self-explanatory.
Place content

728
CHAPTER 28
Pop-ups, windows, and full-screen applications
 The bulk of the logic was in the two helper methods. Once those are in place, you
only need to make a couple tweaks to the main window creation method.
private int _windowNumber = 0;
private void OpenWindow_Click(object sender, RoutedEventArgs e)
{
    Window child = new Window();
    Grid content = new Grid();
    content.Background = new SolidColorBrush(Colors.Red);
    TextBlock text = new TextBlock();                     
    text.Text = "Hello World!";
    text.FontSize = 30;
    text.HorizontalAlignment = HorizontalAlignment.Center;
    text.VerticalAlignment = VerticalAlignment.Center;
    content.Children.Add(text);
    child.Width = 500;
    child.Height = 300;
    child.Title = "Child Window " + _windowNumber;
    child.WindowState = WindowState.Normal;
    child.WindowStyle = WindowStyle.None;
    child.Content = BuildChrome(content, child);     
    child.Show();
    _windowNumber++;
    WindowList.ItemsSource = null;
    WindowList.ItemsSource = Application.Current.Windows;
}
The OpenWindow_Click event handler in listing 28.9 creates the window as before, but
it adds more content in the form of a TextBlock and assigns the actual window
Content property the result of the BuildChrome method. In this way, as far as Silver-
light is concerned, the chrome is the content because the window is simply a rectangu-
lar space on the screen. This is important to know because you no longer receive any
automatic sizing of the window client area and can have content overlap the chrome if
you aren’t careful. On the positive side, that means anything you can do in Silverlight
is fair game for being in the window chrome, as long as it fits inside the rectangle.
Listing 28.9
Rolling the chrome into the window
Shaped windows?
In Silverlight, your window is required to be rectangular and opaque. For those reasons,
you can’t have windows with arbitrary shapes like circles and stars, nor can you have
content that extends beyond the rectangle defined by the window size and position.
TextBlock 
content
Chrome is window 
content

729
Creating native windows
So far, we have created a window with custom chrome. The chrome allows resizing and
moving the window. It even leaves a place where you can include actual window content
(lest that be lost in all this). One thing you can’t do, though, is close the window.
CLOSING, MINIMIZING, AND MAXIMIZING
Look at the upper-right corner of most application windows. You’ll almost certainly
see buttons for minimizing and maximizing (or restoring if already maximized) as
well as a button to close. These aren’t required parts of a window. In fact, if you’re cre-
ating a window that can’t be resized, there’s little reason to include minimize and
maximize buttons. If you want to ensure the user selects an option on the screen, you
may also want to omit the close button.
 That said, most windows will have some or all of these buttons. When you imple-
ment the functionality in your application, you’ll use the WindowState property to
handle the minimized/maximized/restored state and the window’s Close function to
handle closing the window. Listing 28.10 shows how. Place this code in the marked
location in listing 28.8.
Button closeButton = new Button();                    
closeButton.Content = "X";
closeButton.Click += (s, ea) =>
    window.Close();
Button minimizeButton = new Button();                     
minimizeButton.Content = "_";
minimizeButton.Click += (s, ea) =>
    window.WindowState = WindowState.Minimized;
Button maximizeRestoreButton = new Button();           
maximizeRestoreButton.Content = "[]";
maximizeRestoreButton.Click += (s, ea) =>
    window.WindowState = window.WindowState == WindowState.Maximized ?
        WindowState.Normal : WindowState.Maximized;
StackPanel buttonsPanel = new StackPanel(); 
buttonsPanel.Orientation = Orientation.Horizontal;
buttonsPanel.HorizontalAlignment = HorizontalAlignment.Right;
buttonsPanel.VerticalAlignment = VerticalAlignment.Center;
buttonsPanel.Children.Add(minimizeButton);
buttonsPanel.Children.Add(maximizeRestoreButton);
buttonsPanel.Children.Add(closeButton);
titleBar.Children.Add(buttonsPanel);
Listing 28.10 defines three buttons and a stack panel to hold them. The panel is
hosted in the title bar of the window, aligned to the right edge. My graphics could use
a little work (I recommend using images or shapes), but the idea is the same: define
the buttons and wire them up to the appropriate methods on the Window instance.
Listing 28.10
Code to implement window state and closing
Close
Minimize
Maximize 
or restore

730
CHAPTER 28
Pop-ups, windows, and full-screen applications
 The only tricky bit of code here is for the maximizeRestoreButton. That button
needs to maximize when the WindowState is Normal or Minimized and restore when
it is Maximized. You do this with a single statement in order to keep the code lean
and simple.
 The support for programmer-created native OS windows is a great addition to
Silverlight. Your applications can now span windows and even screens. You can create
as many windows as your machine’s resources support and keep track of them using
the window list on the Application object.
 You also have a great deal of flexibility when it comes to how the window looks and
works. If you don’t like the native OS look, you have a rectangle within which you can
design any UI you want. Silverlight even includes a number of properties and func-
tions that make duplicating the normal window chrome functionality a snap.2
 Although you can size a window to take up most of the screen, or maximize it to do
so even more efficiently, neither option makes kiosk-like entire-screen apps look quite
right; you still have static elements like the task bar. To get past this, you’ll need to
turn to Silverlight’s true full-screen support. 
28.3
Running in full screen
Most browsers support the ability to run in the full-screen mode, typically by pressing
F11 or selecting the Full Screen option from the Tools menu equivalent. Though this
mode is nice, the amount of real estate given over to the application isn’t consistent
between browser versions. For example, the older versions of Internet Explorer kept
the status bar and some other elements on the screen. Internet Explorer 8+ and
Google Chrome both allow the browser to take over the entire screen, without any
additional, ahem, chrome visible. Firefox (as of this writing) shows a small gray bar at
the top used as a hotspot for the toolbar. All of these also require the user to navigate
a browser-specific menu or press a browser-specific (but currently identical) hotkey.
The other problem is that there’s no way to use this when running in the out-of-
browser mode.
 Silverlight also supports its own full-screen mode, available both in and out of the
browser. The experience is the same across browsers and the mode may be invoked via
a button you provide in the Silverlight application. This allows you to keep the user’s
focus inside the application (no “Best viewed in full-screen mode, accessed by F11”
prompts) and enable the functionality in a way that’s consistent with your applica-
tion’s experience.
 In a sandboxed application in the browser or a nonelevated application out of the
browser, Silverlight’s full-screen support limits the types of keyboard entry just to those
typically used in media players and games (arrow keys, page navigation keys, and so
on). The reason for this is to prevent someone taking over the entire screen and
spoofing an OS login experience, thereby capturing the user’s password and perhaps
2 Alert! Windows 7/8 geek reference pun.

731
Running in full screen
sending it off to some scary site to be used to gain access to your private information,
like your tax returns for the past five years and that passwords.txt file you thought no
one would notice.
 There are some significant differences between the capabilities enabled by full
screen in the partial-trust mode and full screen in the elevated-trust mode. Let’s tackle
them separately.
28.3.1 Normal full-screen mode
In keeping with the promise of delivering rich interactive experiences, Silverlight goes
far beyond the standard web capabilities by providing a full-screen mode. This mode
enables a user to enjoy immersive visual experiences and interactive media outside the
bounds of the web browser. This full-screen experience comes with some limitations
that you’ll see in a bit. Because of these limitations, the full-screen mode is generally
used strictly with media. This section shows you the differences between the full-
screen and the normal screen modes. Then, you’ll learn how to programmatically tog-
gle between the screen modes.
 If a Silverlight application is put in the full-screen mode, the user will be greeted
with a brief overlay message that looks like figure 28.4.
 Note that full-screen mode doesn’t support the OpenFileDialog and SaveFile-
Dialog classes (covered in chapter 30), nor does it support multitouch input (covered
in chapter 9). But full-screen mode is supported whether running in-browser or out. 
 Figure 28.4 shows the prompt shown to users when they enter the full-screen
mode. This message will overlay the Silverlight content for approximately 3.5 seconds.
After that time, the prompt will gracefully fade out of view. This prompt can’t be cus-
tomized, and in the normal partial trust mode, it can’t be turned off because this
prompt is designed to prevent spoofing.
Spoofing is a security attack used by malicious developers who try to deceptively
mask their application as another or as Windows itself. The purpose of this malicious
attempt is to collect otherwise sensitive information such as bank account numbers
and passwords.
 Because of the severity of this type of attack, Silverlight imposes two safeguards
when running in the partial trust mode. The first safeguard limits user input to the
arrow, Tab, Enter, Home, page up, page down, and space keys, as well as mouse events.
Additional information entered through the keyboard won’t be passed to the Silver-
light application. The second safeguard ensures that the full-screen mode can only be
entered through a user-initiated event such as a button click. Once this happens, you
can switch the Silverlight plug-in into the full-screen mode through the host.
Figure 28.4
The prompt 
displayed to users when they 
enter the full-screen mode

732
CHAPTER 28
Pop-ups, windows, and full-screen applications
TOGGLING BETWEEN SCREEN MODES
The SilverlightHost class gives you access to the information associated with a plug-
in instance. The switch to the full-screen mode is made using the Content property,
which exposes a bool property of its own called IsFullScreen. As you might expect,
this property can be used to toggle between the full-screen and the embedded modes,
as shown in listing 28.11.
private void GoFullScreen_Click(object sender, RoutedEventArgs e)
{
  Application.Current.Host.Content.IsFullScreen = true;
}
The example shows how to switch a plug-in into the full-screen mode. As you’ve prob-
ably guessed, you can set the IsFullScreen property to false to go back to the nor-
mal mode. Regardless of which direction you’re going, a change in the screen mode
will cause the FullScreenChanged event to be triggered. This event is useful for resiz-
ing the content so that it scales to an appropriate size based on the screen mode.
 If you want to avoid the onscreen message, keyboard restrictions, and the require-
ment for user initiation, you’ll need to run in the elevated trust mode. 
28.3.2 Elevated trust full-screen mode
Out-of-browser applications can go full screen whether they’re running in the normal
partial trust mode or in the elevated trust mode. The mechanisms for going full
screen and detecting the mode are the same. But the elevated trust mode (both in-
browser and out) provides some real benefits to applications that require it.
 First of all, elevated-trust applications allow you to enter the full-screen mode from
any branch of code and not just something that’s user-initiated. For example, you can
go full screen from the Loaded event of the main page, as shown in listing 28.12.
private void MainPage_Loaded(object sender, RoutedEventArgs e)
{
  if (Application.Current.HasElevatedPermissions)
  {
      Application.Current.Host.Content.IsFullScreen = true;
  }
}
Elevated trust also eliminates the “Press Esc to exit full-screen mode” prompt that’s
displayed when the full-screen mode is first entered, giving you a more professional
look. At the same time, it eliminates the use of the Esc key for this purpose altogether.
You’ll need to provide the user with another way to exit the full-screen mode either by
capturing the Esc key and/or providing a button to drop out of full screen.
 The keyboard restrictions on the partial-trust full-screen mode make it suitable for
only a small class of applications. The full-screen mode in the elevated trust also
Listing 28.11
Entering full-screen mode
Listing 28.12
Entering full-screen mode from the loaded event

733
Summary
provides access to all the keys you get in the normal out-of-browser mode. This is a
huge boon that makes the mode acceptable for kiosks, full-screen games, interactive
media players with chat, and many other application types. 
 The full-screen mode works whether running in or out of the browser, in partial
trust or elevated trust. Once in the full-screen mode, you can simulate an entire desk-
top, provide your own window management, and so forth. It effectively gives you a
work space that’s larger than what you’d traditionally consider a window. 
28.4
Summary
Any real UI platform needs to have a way to inject interstitial information or requests
into a larger navigation scheme. On operating systems like Windows and Mac OS X,
this typically comes in the form of pop-up windows.
 In the first half of this chapter, you learned about all the various approaches for
displaying pop-up windows from your applications. The first approaches, the pop-up
and child window, were XAML elements that couldn’t escape the bounds of the Silver-
light plug-in. But they’re great for simulating modal dialogs and for having complete
control over the look and feel of the pop-up.
 The second type of pop-up window is the native OS window. This is just a long-
winded way of saying “window” whereas the other approaches were simulated windows
consisting only of shapes. These real windows give you the power to escape the
bounds of the Silverlight plug-in. You can drag the windows around the screen or on
to other displays if you have them. 
 One issue with windows is that the chrome may not fit the style of your application.
This wasn’t a problem with the ChildWindow approach because that’s just XAML.
When you’re working with real windows though, you need to do a little more coding
to provide the expected window manipulation functionality. The Silverlight team pro-
vided helper methods to make that easy for you. When combined with your own
XAML, you can design a window that looks exactly like the rest of your application.
 The final topic covered in this chapter is the use of full-screen in your applica-
tions. This works like maximizing your windows but goes a step further to take over
the entire screen, including the areas normally reserved for OS gadgetry like task
bars. Of course, when in full-screen mode, you can still use the other pop-up features
discussed so far, although you’ll find that the ChildWindow approach is the most flexi-
ble in that scenario.
 Windows and pop-ups provide one approach to navigation in a Silverlight applica-
tion, but they’re really better used in the context of a larger overall navigation
scheme. To wrap up everything, you need to know about structuring the navigation in
your application; you’ll dive into the navigation framework built into Silverlight in the
next chapter.

734
Navigation
When you first created a Silverlight 2 application, you ended up with a project that
contained a single white main page, probably sized at 300 x 400, depending on the
template you used. There was no guidance for structuring your application or how
to move from page to page. Unlike HTML pages, WPF, or Windows Forms, the navi-
gation structure wasn’t something intuitive, building on a decade or more of knowl-
edge and established patterns. Instead, most new Silverlight developers were left
staring at that blank page, wondering what to do next.
 Silverlight 3 introduced not only a complete navigation framework but also an
application template built on this framework. The navigation framework takes a mod-
ern browser-oriented approach to navigation, supporting concepts such as journal
histories, back-and-forward navigation, and uniquely addressable pages. This frame-
work addressed the needs of both application structure and end-user navigation.
 This chapter dives deep into Silverlight navigation. I’ll look to history to show
you how navigation is handled in the browser and how hashtags or URI fragments
work. From there, you’ll start building an application using the navigation
This chapter covers
■
Browser navigation
■
The Navigation Application template
■
Navigation with out-of-browser applications

735
Browser navigation background
template. The navigation template will then be used to explore navigation to individ-
ual pages and customization of navigation.
 Before diving into Silverlight navigation, let’s look at a well-established navigation
paradigm as used by the web browser.
29.1
Browser navigation background
The introduction of GUI web browsers hailed a new approach to navigation. Prior to
Mosaic, the typical modes for navigation were either keyboard commands or drop-
down menus. Most applications had multiple windows and were wizard- or dialog-
driven. Browsers introduced two key things:
■
Navigation to previously visited pages using Back and Forward buttons, with
retained history on both
■
Navigation to new pages using hyperlinks
This may seem pretty unexciting now, but it wasn’t a mainstream approach at the
time. Applications didn’t contain a single frame that was swapped in and out with dif-
ferent bits of content.
 With the ubiquity of web browsers came new demands for how applications
worked. It was expected that your applications, especially if hosted in a browser, would
use the tried and true forward/backward and link navigation approach. This
approach became more complex with the introduction of Ajax-style applications, but
it was still an expectation. The complexity arose from the lack of standards for work-
ing with the browser journal, the structure in the browser that keeps track of your nav-
igation history, when the hosted page itself never changed.
 Silverlight is affected by this. When run, a Silverlight application doesn’t change
the URL or load a different hosting page. It all happens on a single HTML page when
running in the browser.
 Eventually, both browser makers and the application framework developers were
able to work together to provide a hashtag (the # symbol)-based approach for inter-
acting with the browser journal. The rest is, well, history.1
 In this section, I’ll briefly cover how the browser journal works and how it interacts
with anchor tags on a typical web page. With that grounding, you’ll then explore Sil-
verlight navigation in the subsequent sections.
29.1.1 Browser journals
The browser journal keeps track of your navigation history for a session. It’s what allows
you to click the Back button to open the previous page and then click the Forward
button to return to where you were.
 Browsers each implement their history journal and its API in subtly different ways.
For example, Internet Explorer 7 required the use of an HTML iframe in order to gen-
erate an actual history entry when you navigate to a hashtag. Other browsers didn’t
1 You didn’t think I’d get past this section without cracking that joke, did you?

736
CHAPTER 29
Navigation
update their JavaScript API objects, such as location.hash, to reflect changes to the
hashtag. Some other browsers were just plain buggy and didn’t consistently keep the
correct state. There were other smaller differences in addition to gross API differences.
NOTE
Ever wonder why you need that iframe in the HTML page in a Silverlight
project? It’s there for navigation support in older browsers, including IE7. IE7
wouldn’t generate a history entry when you navigated to a hashtag unless you
also navigated a frame at the same time. Some pretty clever scripting avoids a
server round-trip in there, all happily wrapped inside the navigation API. IE8
and above don’t require this hack. You’re not actually still using IE6 or 7, are
you? Use IE9 or preferably IE10 (when available) if you’re going to use IE at all.
Around 2007–2008, Ajax libraries started to include functionality to wrap all this jour-
nal ugliness. Happily, Silverlight was able to build on this body of work to provide the
same functionality.
 The entire navigation structure for rich, client-side browser applications is built
around hashtags.
29.1.2 Anchor hashtags
Hashtags, more properly known as fragments when part of a larger URI, were originally
designed to enable navigation within the same page without requiring a round-trip to
the server. They were for top-level tables of contents on really long pages. Here’s an
example in HTML:
<html>
<body>
<ul>
<li><a href="#first">First</a></li>
<li><a href="#second">Second</a></li>
</ul>
<p><a style="height:600px" name="first"/>
This is the first content paragraph</p>
<p><a style="height:600px" name="second"/>
This is the second content paragraph. Put me below the fold.</p>
</body>
</html>
If you paste this into a file with an .html extension and view it in your browser, you’ll
see how clicking the links at the top brings the bottom content into view and updates
the address at the top of the browser. If the content is already in view, you won’t see
any on-page changes, but you’ll
still see the hashtag change in the
URL. Figure 29.1 illustrates this.
Figure 29.1
I just clicked the First link
at the top of the page. The browser
scrolled to bring the content into
view and updated the URL with
the hashtag #first.

737
Browser navigation background
You can achieve a similar effect using JavaScript. Rather than having to click a link,
you can use this one line of JavaScript code:
window.location.hash = "#first";
As you learned in chapter 4, Silverlight can manipulate the browser DOM for any page
it’s on. Silverlight uses this and the plug-in model to handle the journal manipulation
for you, saving you the aggravation of coming up with a cross-platform, cross-browser,
custom solution or handcrafting JavaScript.
 The hashtag approach provides a way to uniquely address content. It’s common to
see, for example, blog engines using this to uniquely address comments on a page. In
Ajax applications and in-browser RIAs, you can use it the same way: to uniquely iden-
tify content that’s on the same browser page but nested within your application.
 Assuming you’re already on the browser page specified in the URL, all of this is
done without a page refresh, which is the key to making it work with your applications.
29.1.3 Back and forth
Browsers have a long history2 with their current navigation paradigm. When running
an application in the browser, and increasingly when running desktop applications,
users have come to expect that the approach of Back buttons, Forward buttons, and
hyperlinks will be, if not the primary navigation mechanism, at least one form that’s
available to them. It has even reached a level mainstream enough to be incorporated
into the Windows shell, as shown in figure 29.2.
 The Back and Forward buttons have their own settled UI convention (left and
right arrows). As expected, Back navigates the browser history backward, toward the
first page in the navigation chain, and Forward navigates forward as far as you’ve gone
in this chain. Forward only works if you’ve already used the Back button. When you
click another hyperlink, the forward chain is rebuilt starting at the current point.
 With this background in browser navigation, journals, and hashtags, you can now
look at the Silverlight implementation and make more sense of the design choices
made, as well as the knobs provided for tweaking the approach. The easiest and most
obvious way to explore the navigation framework is to start with the Silverlight Naviga-
tion Application template. 
2 I did it again! I kill me.
Figure 29.2
The Back and 
Forward buttons have even 
made it into the Windows shell, 
in the file explorer windows.

738
CHAPTER 29
Navigation
29.2
The Navigation Application template
When creating a new Silverlight project, you can choose from several stock templates.
For most of the projects in this book, you’ve used the generic Silverlight Application
template. That template is great if you want a blank slate to start with.
 The Silverlight Navigation Application template is another good one. This tem-
plate provides the fundamental structure and plumbing required to allow your appli-
cation to work using a familiar web page navigation model. In addition, the template
provides for easy theming of your application.
 The Silverlight Navigation Application template isn’t required when you want to
incorporate navigation in your application. But you’ll find the template provides a
good starting point.
 In this section, you’ll create a new navigation project and use it to explore the Nav-
igation Application template, including modifying the navigation to include an addi-
tional page and the link to that page. I’ll wrap up this section with an example showing
you how to use the free online themes to customize the UI of the navigation application.
29.2.1 Creating a navigation application
As the name suggests, the Silverlight Navigation Application template structures the
application around the navigation API first introduced with Silverlight 3. This API
Figure 29.3
Picking the Navigation Application template in Visual Studio 2010

739
The Navigation Application template
makes it easy to move between pages. The template provides a best-practices structure
for using the capabilities provided, as well as a good starting point for your own
applications.
 The first step is to create the new project using the navigation template. Figure
29.3 shows the correct template selected in the Visual Studio 2010 New Project dialog.
I named the application NavigationExample.
 After the project has been created, you end up with a structure that includes an
Assets folder with application styles (see chapter 14 for more on styling) and a Views
folder that includes two pages and an error window dialog. You’ll also see the usual
MainPage.xaml and App.xaml files in the project root.
 When you run the unmodified application, using the default application style,
you’ll end up with something that looks like figure 29.4.
 The application template includes all the wiring required to synchronize the menu
(the Home button at the upper right in figure 29.4) with the page in view and syn-
chronizes both with the hashtag in the URL. If you click the About navigation button,
you’ll see that the URL changes. Even better, you can use the browser’s Back button to
get back to the home page of the application.
 Although this is a great structure, an application with only home and about pages
would probably not be particularly engaging. To grow beyond this, you need to add a
new page and modify the navigation menu.
Figure 29.4
The Navigation Application default project. Note how the URL corresponds to the 
current page visible in the application, and how the navigation menu on the right is synchronized 
with the two.

740
CHAPTER 29
Navigation
29.2.2 Adding a new page
Much like regular web pages, the functionality and content for a navigation application
are in the pages. Adding a new page to a navigation application involves three steps:
1
Add the new view to the Views folder.
2
Add a link to the top menu.
3
Add functionality to the page.
The first step is as simple as dropping a new file into a folder. The second step involves
modification to MainPage.xaml, and the third step is what you’d normally do in any
application, so we’ll skip it here.
ADDING THE NEW VIEW
Views are instances of the Silverlight Navigation Page class defined in the System.
Windows.Controls.Navigation namespace. The Silverlight tools include a template
for a blank page deriving from the navigation:Page class, a class that’s essentially a
UserControl that has been beefed up to support navigation.
 Right-click the Views folder and select Add New Item. In the Add New Item dialog,
select the Silverlight Page template and name the file CustomerDetail.xaml, as
shown in figure 29.5.
 After you’ve added the new page, you need to provide a way for the end user to
find it. In a regular desktop application, this may be a menu or toolbar. For this navi-
gation application, you’ll use a HyperlinkButton.
Figure 29.5
The Add New Item dialog with the Silverlight Page template selected. This is the template 
to be used for views in a Silverlight navigation application. I may have more templates than you; I’ve 
installed some add-ins.

741
The Navigation Application template
ADDING THE LINK TO THE TOP MENU
In this template, navigation to individual pages is accomplished by HyperlinkButton
instances on MainPage.xaml. The pages themselves are loaded in the navigation:
Frame element named ContentFrame.
 On MainPage.xaml is a Border named LinksBorder. This is the navigation menu
that appears at the upper right. The default XAML for this area is shown in listing 29.1.
Result:
XAML:
<Border x:Name="LinksBorder" 
        Style="{StaticResource LinksBorderStyle}">
  <StackPanel x:Name="LinksStackPanel" 
              Style="{StaticResource LinksStackPanelStyle}">
    <HyperlinkButton x:Name="HomeLink"                   
                     Style="{StaticResource LinkStyle}" 
                     NavigateUri="/Home" 
                     TargetName="ContentFrame"
                     Content="home"/>
                                                       
   <Rectangle Style="{StaticResource DividerStyle}"/>
   <HyperlinkButton x:Name="AboutLink" 
                    Style="{StaticResource LinkStyle}" 
                    NavigateUri="/About" 
                    TargetName="ContentFrame"
                    Content="about"/>
  </StackPanel>
</Border>
This Border contains the top menu navigation structure for the application. It’s a sim-
ple StackPanel of elements: HyperlinkButton instances separated by vertical lines
(narrow rectangles). 
 Note that I removed the x:Name from the divider rectangle, because it’s not needed.
The names in the HyperlinkButton instances also aren’t needed, but I gave them
meaningful names to help with the discussion here, and in case you decide to do some-
thing with them in code. In your own project, you can remove the names if you’d like.
 To add your own page to the navigation structure, you need to follow this pattern
and add a divider rectangle (optional, but recommended) and a HyperlinkButton
pointing to your page. Place this markup in the XAML in the spot indicated in the pre-
vious listing:
<Rectangle Style="{StaticResource DividerStyle}" />
<HyperlinkButton x:Name="CustomerDetailLink" 
                 Style="{StaticResource LinkStyle}"
                 NavigateUri="/CustomerDetail"
                 TargetName="ContentFrame"
                 Content="customer" />
Listing 29.1
LinksBorder showing navigation menu
Page link
Your link 
goes here

742
CHAPTER 29
Navigation
When copying and pasting from the other links, I left the divider alone but changed a
couple of properties of the HyperlinkButton. The first is the x:Name property, which
is optional because it’s not used in any code, binding, or animation in the default tem-
plate. The second is the Content. This is what will be displayed on the menu bar. You
could easily use images rather than text if you’d like. You’re also free to change the
LinkStyle resource to modify the appearance. The final property is the NavigateUri.
That needed to be changed to point to the newly added page.
 You may have noticed that the URI for the page is set to /CustomerDetail, when the
actual page is stored in /Views/CustomerDetail.xaml. This is handled by the URI mapper,
which I’ll cover later in this chapter.
 Although it isn’t unique to the navigation API, one other nice feature of the naviga-
tion application is its ability to be easily styled or themed.
29.2.3 Changing the application theme
When the Silverlight team created the navigation template, they enlisted the help of
an in-house designer to both ensure that the template could be themed and to create
themes for use with it. Long after the release, the design team has continued to put
out new themes, each more impressive than the last.
 The templates are available in Visual Studio through the extension manager. You
can also get the full set of templates by visiting http://bit.ly/sltemplates and clicking
the big download link at the top. Be sure to grab the VisualStudio2010 zip file, which
contains the .vsix (Visual Studio Install Package) files for the themes. This will install
a number of new project templates, one for each theme you install. You can also
install the templates directly from the Add New Project dialog by selecting to view
online templates.
 Because you’ve already started your project, you’ll need to steal some theme files
from another project. In another instance of Visual Studio, create a new Silverlight
Navigation Application–Cosmopolitan Theme (or a different theme if you prefer)
application. Save that. Then, find the folder where you stored that project, open it in
Explorer, and drag all the contents except the SDKStyles.xaml and ToolkitStyles.xaml files
from the Assets folder in the temp project into the Assets folder of your chapter proj-
ect. Be sure to overwrite (or first rename) the old Styles.xaml file so you pick up the
new one.
NOTE
Make sure each of the theme XAML styles is compiled with a build
action of Page and a custom tool of MSBuild:Compile. You’ll find both set-
tings in the property panel for the file. The build action provides compile-
time errors. The custom tool tells Visual Studio what to do with the file and
how to include it in the assembly.
If you include SDKStyles.xaml or ToolkitStyles.xaml, you’ll get compile errors unless
you also have the required SDK and Toolkit assembles (respectively) referenced in the
application. 

743
The Navigation Application template
 Finally, open App.xaml in the project you’ve been working in, and merge in the
new resource dictionaries:
<Application.Resources>
  <ResourceDictionary>
    <ResourceDictionary.MergedDictionaries>
      <ResourceDictionary Source="Assets/Styles.xaml" />
      <ResourceDictionary Source="Assets/CoreStyles.xaml" />
    </ResourceDictionary.MergedDictionaries>
  </ResourceDictionary>
</Application.Resources>
After you have all the SDK and toolkit assemblies referenced, rebuild your application
and run. I picked the Cosmopolitan theme, so my application looks like figure 29.6. I
didn’t change a single line of page XAML, just the applied styles. Note how the sizes,
colors, fonts used, and locations of the elements have all changed—pretty awesome. 
 Most of the rest of what you’ll do inside the pages is straight Silverlight code and
design. You’ll write code either in the code-behind or using something like the MVVM
pattern described in chapter 33. 
 Why did I have you jump through those hoops? During the Silverlight develop-
ment cycle, the themes were only available as loose XAML files, without any templates.
You had to copy those files over manually. Later, even though templates became avail-
able, other people posted similar resource dictionaries on CodePlex and other sites;
Figure 29.6
The Silverlight navigation application with a new style. The Cosmopolitan style is 
similar to the Metro theme used by Windows Phone, Xbox, and Windows 8, but most closely 
resembles the early Metro work pioneered in the Zune client.

744
CHAPTER 29
Navigation
you had to use this approach to get them. It’s useful to know should you want to use
someone else’s loose XAML theme files.
 As we continue to explore the navigation framework, you’ll use this application in
the examples. Now that you’ve seen how straightforward it is to create a Silverlight
navigation-enabled application using the template, it’s time to dig into the classes and
methods that make the template possible.  
29.3
Navigating to pages
In the previous section, you saw what it takes to add a new page into the navigation
structure. In a nutshell, all you need to do is add the page to the Views folder and
then to the navigation links on the top.
 Pages are the most frequently used part of the navigation framework. They’re the
primarily location for your content. In addition to pages, there are several other
important parts. The NavigationService class provides the underlying property and
event information required to make navigation work. Then you have the Frame ele-
ment, which loads pages using URIs and supports features such as URI mapping. Both
the pages and frames also support forms of caching to minimize the reload time for
any given information. Also, much like HTML, frames can be nested and have multi-
ple levels of navigation, or even navigation to pages in other assemblies.
 All of these classes collectively fall under the Navigation framework, and all of
them are involved in navigating to pages in your Silverlight application.
 In this section, you’ll dig deeper into what makes navigation possible, looking at
the core Page class and its properties. From there, you’ll learn how the Frame class and
URI mapping work to load those pages, and how to pass and receive parameters
between page instances. The section wraps up with a look at caching pages for reuse
and navigating to pages contained in other assemblies.
29.3.1 The Page class
The Page class, in the System.Windows.Controls namespace, provides the behavior
expected of content to be loaded into a navigation Frame. The Page itself is analogous
to an HTML page or to a regular Silverlight UserControl, but with the addition of nav-
igation events, members, and a navigation service. The page also provides caching
capabilities in concert with the Frame class; I’ll cover that and other features later in
this chapter.
 In addition to the standard Title property, which provides a unique friendly title
to the page, and some navigation objects that I’ll discuss shortly, the Page class
includes several virtual functions used to provide information about the current navi-
gation state. 
NAVIGATION VIRTUAL FUNCTIONS
The Page class includes four navigation-related virtual functions. Override these when
you want to perform an action on a specific navigation step. Table 29.1 lists the
functions of each.

745
Navigating to pages
These four events were implemented as virtual functions to eliminate the require-
ment of hooking up event handlers, potentially keeping pages around longer than
intended. 
 You’ll use the OnFragmentNavigation when you want to respond to subnavigation
within the current page. This is a powerful but seldom-used capability similar in intent
to hashtag or fragment navigation on HTML pages.
 A good place for page cleanup code, or persisting to a backup cache, is the
OnNavigatedFrom method. This is fired when the page is no longer the active page, so
it’s too late to use to prompt the user for saving. Use the OnNavigatingFrom method
when you need to prompt the user.
 The OnNavigatingFrom method provides a facility for informing the user that the
page is about to be navigated away from. The method signature allows for canceling
the navigation, typically in response to a prompt to the user.
 The OnNavigatedTo method is the one most commonly used in navigation pages.
This is typically used for any data loading or data-cache retrieval, as well as any page
setup. Because pages can themselves be cached, this is the place to check the state of
that page cache and perform any operations necessary to make the page available to
the user.
 The source of the event information is the NavigationService class, which also
has several other useful properties and methods. 
Table 29.1
Page navigation members
Navigation event
Description
OnFragmentNavigation
Called when a fragment inside the Silverlight application is navi-
gated to—for example, /Views/CustomerDetail.xaml#Item1234. 
This is different from the top-level hash or fragment used to support 
Silverlight navigation.
Equivalent to the FragmentNavigation event on the 
NavigationService class.
OnNavigatedFrom 
Called when this page is no longer the active page in the frame. Use 
this for any final cleanup code.
Equivalent to the Navigated event of the NavigationService
class.
OnNavigatingFrom 
Called just before this page is swapped out for another. The event 
args allow for canceling the navigation. You can use this to prompt 
the user to save data, for example.
Equivalent to the Navigating event of the NavigationService
class.
OnNavigatedTo 
Called when the page becomes the active page in the frame. In 
most cases, you’ll use this where you’d use the Loaded event in 
non-navigation scenarios.

746
CHAPTER 29
Navigation
29.3.2 The NavigationService class
The navigation Page class exposes a NavigationService class with a property of the
same name. This service is useful as a means to hook into the navigation system for
the hosting frame from within page code.
 The NavigationService class provides five methods used for navigating away from
this page, reloading the current page, and stopping asynchronous navigation actions.
Table 29.2 provides detail on each function. 
GoBack and GoForward use the currently active journal to move backward and for-
ward through the journal history. These methods are provided both here and at the
Frame level to allow you to create your own navigation UI, typically for use when run-
ning out-of-browser applications where there’s no browser UI. You can certainly use
these in-browser, though—something that may be useful for full-screen applications
in particular.
 The Navigate method takes a URI and starts the process of loading the new con-
tent and replacing the current content. I’ll cover the Navigate method in more detail
when I discuss the Frame class.
 In all cases, when using these navigation functions, the events listed in table 29.1
will be fired at their appropriate times.
 In addition to the navigation functions, two other methods are available. The first,
Refresh, is similar in functionality to the browser’s Refresh button. Typically this is
used only when you have custom content loaders and are performing some sort of
authentication step that must happen before the content appears. This method
reloads the page but doesn’t force it to be regenerated: if the page is cached, it’ll be
read from the cache. The second, StopLoading, is similar to the browser’s Stop or
Cancel button. It stops an asynchronous or long-running page-load process. Given the
structure of most navigation applications, with local compiled pages, StopLoading is
rarely used.
Table 29.2
The NavigationService class functions
Member
Description
GoBack 
Navigates to the previous entry in the history. Throws an exception if no previous 
entry exists in the history.
GoForward 
Navigates to the next entry in the history. Throws an exception if no next entry 
exists in the history.
Navigate 
Navigates to an arbitrary URI.
Refresh 
Reloads the current page. Note that this is useful only when you provide a custom 
INavigationContentLoader for the Frame’s ContentLoader property.
StopLoading 
Cancels any asynchronous navigation actions that haven’t yet been processed.

747
Navigating to pages
 Related to those functions are four properties that provide information on the nav-
igation history as well as the current and planned page. 
These properties are typically used in concert with functions from table 29.2 For
example, you’ll check the CanGoBack property before calling the GoBack function.
Listing 29.2 shows several of these in use in a hypothetical page.
XAML:
<Grid x:Name="LayoutRoot">
  <StackPanel Orientation="Horizontal" Height="30">
    <Button x:Name="NavigateBack"
            Click="NavigateBack_Click"
            Content="Back"
            Width="100" />
    <Button x:Name="NavigateForward"
            Click="NavigateForward_Click"
            Content="Forward"
            Width="100" />
  </StackPanel>      
</Grid>
C# code-behind:
private void NavigateBack_Click(object sender, RoutedEventArgs e)
{
  if (NavigationService.CanGoBack)           
    NavigationService.GoBack();               
}
private void NavigateForward_Click(object sender, RoutedEventArgs e)
{
  if (NavigationService.CanGoForward)        
    NavigationService.GoForward();          
}
Note that, as shown in the listing, you should always check the CanGoForward or
CanGoBack functions as appropriate. Failure to do that risks a runtime exception when
the user is at the top or bottom of the navigation history stack.
Table 29.3
The NavigationService class properties
Member
Description
CanGoBack
Returns true if there’s at least one previous entry in the history.
CanGoForward
Returns true if there’s at least one next entry in the history.
CurrentSource
Returns the URI of the currently displayed page. This value changes when naviga-
tion has completed.
Source
Gets or sets the page to be displayed. If set, when navigation completes, Source
and CurrentSource will be the same. In the interim, they may be different.
Listing 29.2
Using the NavigationService class to navigate forward or backward
Navigate 
backward
Navigate 
forward

748
CHAPTER 29
Navigation
 These functions and properties are useful for those odd times when you need to
perform navigation directly from the page. The more typical approach, shown in sec-
tion 29.4, is to call them from the UI that hosts the navigation Frame control.
 The final bit of functionality provided by the NavigationService class is surfaced
through a set of five events that provide information about the current state of naviga-
tion. Table 29.4 shows the events exposed by this class. 
Several of the events on the NavigationService class are equivalent to the virtual func-
tions exposed by the page class, discussed earlier. Two of them, the NavigationFailed
and NavigationStopped events, have no equivalent and so bear more investigation.
 The NavigationService class provides much of the core functionality of the navi-
gation system in Silverlight. Although accessing it from within a page is a fine way to use
those capabilities, it’s more common to access the equivalent properties and methods
directly exposed by the Frame class to navigate using URIs or the history journal.  
29.3.3 Frames and URIs
In Silverlight, Pages are loaded into Frames and are uniquely addressable via URIs.
These two types—the Frame and the URI—are conceptually similar to their HTML
counterparts in that the frame is both a container and a bit of a walled garden, used to
host content.
 The Frame class is a ContentControl, so it can have only one item as its content. In
most cases, that’s another XAML page, but that’s controllable using the Content-
Loader property of the Frame class.
 The Frame class exposes many of the same properties and methods that the
NavigationService exposes. One benefit at the Frame level is that most of these are
exposed as dependency properties and can therefore be used to control the
IsEnabled state of navigation controls via binding.
 You can load content into a frame in a few different ways: using the GoBack and
GoForward methods seen in the previous section, or via URI using the Navigate
Table 29.4
The NavigationService class events
Member
Description
FragmentNavigation
Raised when the system navigates to a hashtag (fragment) on the current 
page. Equivalent to the Page.OnFragmentNavigation method.
Navigated
Raised when the system has navigated away from the page. Equivalent to 
the Page.OnNavigatedFrom method.
Navigating
Raised when the system is planning to navigate away from the page. This is 
a cancellable event. Equivalent to the Page.OnNavigatingFrom method.
NavigationFailed
Raised when the frame is unable to navigate to the requested page. 
Provides the exception information.
NavigationStopped
Raised when navigation has been stopped.

749
Navigating to pages
method, which I’ll cover here. Frames also support URI mapping to change ugly URLs
into more user-friendly versions. This mapping also helps better support page
parameters.
LOADING CONTENT WITH THE NAVIGATE METHOD
Silverlight navigation applications load content pages into frames. In our walkthrough
of the Navigation Application template in section 29.2, you saw that the Hyperlink-
Button in the MainPage.xaml file invokes navigation for you. Although using a
HyperlinkButton is an easy way to get content into a frame, it’s not the only way. For
example
ContentFrame.Navigate(new Uri("/CustomerDetail", UriKind.Relative));
If the page /CustomerDetail maps to a valid page via the in-force URI mapping, this
example will navigate to that page. You could put this type of code in a button or any
sort of other handler in the application. The ability to navigate using code means
you’re not stuck with using HyperlinkControls for your application navigation: you
can use traditional menus, ListBoxes, Buttons, or pretty much anything you’d like.
 When working with navigation pages, you typically don’t navigate to pages using a
full filename such as CustomerDetail.xaml. Instead, you map friendly URIs to these
absolute URIs. This is done through a property on the Frame class.
URI MAPPING
The Frame class exposes a property named UriMapper of type UriMapperBase. This
class is responsible for translating real application URIs into something more user-
friendly. The default implementation is a class containing a collection of UriMapping
objects. Table 29.5 shows the members of the UriMapper class.
The UriMapper property of the Frame class is read/write. Should you desire, you can
create your own UriMapper implementation, using your own scheme for mapping
URIs. To do so, inherit from UriMapperBase and provide the required functionality in
the MapUri function.
 In the example at the beginning of this chapter, you saw how the mapper automat-
ically translated /CustomerDetail into /Views/CustomerDetail.xaml. The default
Table 29.5
The members of the UriMapper class
Member
Description
UriMappings
Collection of UriMapping objects representing a single pair of URIs to be 
mapped. Each UriMapping object contains a Uri property and a MappedUri
property as well as a MapUri function.
MapUri
Inherited from UriMapperBase and overridden in the default UriMapper class. 
The function accepts a regular URI and returns the URI that it maps to. In the 
default UriMapper implementation, it calls the MapUri function of the 
UriMapping that matches the input URI.

750
CHAPTER 29
Navigation
UriMapper class exposes the UriMappings collection. Here’s the full XAML for the
mapping:
<navigation:Frame.UriMapper>
  <uriMapper:UriMapper>
    <uriMapper:UriMapping Uri="" 
                          MappedUri="/Views/Home.xaml"/>
    <uriMapper:UriMapping Uri="/{pageName}"
                          MappedUri="/Views/{pageName}.xaml"/>
  </uriMapper:UriMapper>
</navigation:Frame.UriMapper>
Given this mapping, and assuming an application URI of http://myapp.com/
app.aspx, when the user visits http://myapp.com/app.aspx#/CustomerDetail, the
second mapping will come into play and map to http://myapp.com/app.aspx#/
Views/CustomerDetail.xaml. Also note the hashtag in both cases; the mapping only
comes into play with that fragment.
 This mapping XAML fragment sits inside the navigation:Frame element and pro-
vides the two mappings required for the URLs you’d normally use: no page and a spe-
cific page. Maps are read top-down and complete when the first match is hit. If you
want to pass parameters to your page, you can get more complex and include support
for query string values.
PASSING AND RECEIVING PAGE PARAMETERS
A common pattern in web applications is to pass parameters to a page using the query
string. The query string is the set of delimited name/value pairs after the question
mark in a URL—for example:
http://myapp.com/app.aspx?customer=1234
In this case, the query string would produce two name/value pairs: customer with a
value of 27 and invoice with a value of 2506. 
 That works well for passing parameters to an actual HTML page, but how does it fit
in with the hashtag approach used with Silverlight navigation? How do you pass
parameters to internal Silverlight pages? In a Silverlight application, much as we’ve
gotten used to elsewhere on the web, you may want something a little friendlier:
http://myapp.com/app.aspx#/CustomerDetail/1234
In this case, when you have mapping set up, Silverlight will load the CustomerDetail
page and pass in a parameter of 1234. How is that parameter passed in? It’s entirely up
to you and how you do the mapping. For example, let’s say you want 1234 to map to a
CustomerID query string variable. You provide a map that looks like this:
<uriMapper:UriMapping Uri="/CustomerDetail/{CustomerID}"
        MappedUri="/Views/CustomerDetail.xaml?CustomerID={CustomerID}" />
That map needs to appear near the top, preferably after the Home mapping, in order
to be hit. Remember, the maps are evaluated top-down, and the first match is the only
one that will be executed.

751
Navigating to pages
 Retrieving the parameter from within the Page is super simple. The Navigation-
Context object on the property of the same name in the Page class includes a Query-
String property that may be used to retrieve the parameters passed into the page. It’s
an IDictionary of strings, so no parsing is required; use the name/value pairs as
they’re provided:
protected override void OnNavigatedTo(NavigationEventArgs e)
{
  if (NavigationContext.QueryString.ContainsKey("CustomerID"))
  {
    string id = NavigationContext.QueryString["CustomerID"];
    if (!string.IsNullOrWhiteSpace(id))
        LoadCustomerDetails(id);
  }
}
This example shows how easy it is to grab the ID from the query string passed into the
page. Although I left them out for brevity here, you’ll want to have all your query
string key names in constants or an enum (using enum.ToString).
 This approach enables you to provide meaningful deep links into data-oriented
Silverlight applications, pulling up the appropriate records or other state. Back when
I worked primarily with Windows Forms in the .NET 1 and 1.1 days, this was a feature
many customers asked for: “How can I email a link to a specific page in the applica-
tion?” We had all sorts of strange solutions involving custom URI schemes and more.
I’m glad to see it’s much simpler now.
 When you have a data-oriented application, that typically means individual pages
cause some sort of database transaction and web service call to run when you load
them. The query string parameter may contain a record ID used to load some data.
When the user is bouncing back and forth between pages in the application, you don’t
necessarily want to take a service or database hit on each page; that’s where caching
comes into play. 
29.3.4 Caching pages
There are all sorts of ways to cache information in a Silverlight application: you can
cache data at the service level on a web server or using a server-side caching product.
You can cache locally on the client using cookies and isolated storage. With elevated
trust applications, you can even cache to files in the My Documents folder. Of course,
because Silverlight applications are stateful, you could cache everything you need in
memory on the Silverlight client. The Page cache is a specialized form of this in-
memory approach.
PAGE CACHE SETTINGS
Normally, when you navigate to a page using the navigation framework, you’ll get a
new instance of that page. This includes times when you click the Back button to get
to that page. In order for Silverlight to cache that page, you need to enable caching at

752
CHAPTER 29
Navigation
the page level using the NavigationCacheMode property. Table 29.6 shows the three
possible values for page caching.
The cache mode is specific to the URI in use. When using parameters, each unique
URI, including the query string and hash, results in a new cached page if caching is
turned on. Given the way parameters usually affect the data on the page, this is a desir-
able effect. If you want to avoid this, you can cancel the navigation using code in the
Navigating event or by overriding the OnNavigatingFrom function on the Page. 
 Typically, you’ll set the page’s cache mode in the constructor. Cached pages will
still receive the navigation events, so you may do any page-loading work inside the
OnNavigatedTo override.
 The page cache is handled at the Frame level, so it makes sense for that to be the
location of the cache settings.
FRAME CACHE SETTINGS
The Frame instance is responsible for any caching of pages it loads. It uses a simple in-
memory structure keyed by the URI of the page to be cached. By default, the size of
this cache is set to 10 pages, but you can change that by setting the Frame.CacheSize
property in either markup or code. Recall that this limit doesn’t include pages that
require cache, only pages that enable it.
 Logically, the cache is a queue: new pages are added to one end, and old pages fall
off the other. The cache itself is opaque; you don’t have direct access to it and can’t
manually manipulate the pages contained within. If you need that level of cache con-
trol, you can consider creating your own custom INavigationContentLoader and
bypassing the built-in cache.
 Caching is a powerful way to improve the performance of your application. Using
the built-in page cache takes the guesswork out of dealing with individual page
instances in a navigation application.
 So far, you’ve seen a number of pages being loaded (and cached) using straightfor-
ward URIs. Those pages all existed in the currently executing assembly. It’s rare for an
application of any complexity to have all of its user interface contained within the
main assembly. 
 For the last topic of this section, I’ll cover how to navigate to pages contained in
other assemblies.
Table 29.6
The values for NavigationCacheMode for a Page
Value
Description
Disabled
The default value. The page is never cached.
Required
The page is cached, and the cached version is used for every request. Pages marked as 
required don’t count against the Frame’s cache limit and won’t be discarded.
Enabled
The page is cached but is discarded when the Frame’s cache limit is reached.

753
Navigating to pages
29.3.5 Navigating to pages in other assemblies
Nontrivial applications almost always contain multiple assemblies. In many cases,
those assemblies may contain UI pages that must be integrated with the rest of the
application. The Silverlight navigation framework supports navigating to pages
included in other assemblies.
 There are multiple ways to get the assembly down to the local machine. First, it can
be packaged in the same XAP file with the initial application download. This doesn’t
help download time, but it does help keep the application modular. The assembly can
be a shared assembly sitting on the server, resolved by the Silverlight assembly caching
resolver. It can be an assembly dynamically downloaded using the Managed Extensibil-
ity Framework (MEF) or via an HttpWebRequest (as seen in chapter 19).
URI SYNTAX
Regardless of the download mechanism, the navigation approach remains the same
when you have the assembly available to Silverlight. Silverlight uses a specialized form
of URI to reference the page. You may have seen this when loading resource files. For
example, to get to CustomerList.xaml in a Views folder in the assembly Customer-
Module, the URI looks like this:
/CustomerModule;component/Views/CustomerList.xaml
That says to load the CustomerModule component and look in the Views folder for a
file named CustomerList.xaml. You could use this syntax as is, but it’s much nicer to
integrate it with the URI mapper. First, let’s modify the project to include a new assem-
bly with the CustomerList page so you can try this out.
ADDING THE ASSEMBLY
To the existing solution, add a new Silverlight Class Library project named Customer-
Module. In that project, create a new Views folder. In the Views folder, add a new
Silverlight page named CustomerList.xaml. Feel free to remove the default Class1.cs
class that came along for the ride.
 The XAML for the CustomerList file is short:
<Grid x:Name="LayoutRoot">
    <TextBlock Text="Customer List Page from Assembly" />
</Grid>
The next step is to reference this assembly from the main Silverlight application. First,
build the solution. Then, right-click the Silverlight app and choose Add Reference.
From the Projects tab, select the newly added CustomerModule assembly.
 At this point, you have everything needed for a page in a separate assembly,
included in the main XAP file. The next step is to build the URI mapping rule.
MAPPING THE URI
Unless you have a specific pattern to the URIs in your external assemblies, you’ll need
to create individual mapping rules for them. This alone can be a good reason to
group pages by a common name prefix (such as Customer) and partition them into
assemblies based on those names.

754
CHAPTER 29
Navigation
 In this case, you’ll add a specific URI mapping as the first rule in the URI mapper in
MainPage.xaml. The rule looks like this:
<uriMapper:UriMapping Uri="/CustomerList"
        MappedUri="/CustomerModule;component/Views/CustomerList.xaml" />
When the mapping is in place, all you have to do is add some navigation controls on
the page.
ADDING THE NAVIGATION MENU ITEM
Still in MainPage.xaml, locate the LinksBorder where you previously added the Cus-
tomer menu item. Right under the CustomerDetailLink, add the following XAML:
<Rectangle Style="{StaticResource DividerStyle}" />
<HyperlinkButton x:Name="CustomerListLink"
                 Style="{StaticResource LinkStyle}"
                 NavigateUri="/CustomerList"
                 TargetName="ContentFrame"
                 Content="customer list" />
When you run the application and click the Customer List menu option, you’ll see
something like figure 29.7. With the mapped URI, the fact that the page isn’t in the
main assembly is completely transparent to the user. Not only is this generally a good
practice, but it’ll make any further refactoring easier, because you can keep the URIs
the same regardless of which assembly the pages live in.
 Navigation in Silverlight is based primarily around Pages, Frames, and URIs. Individ-
ual pages have unique URIs and are loaded by those URIs into frames in the application.
Frames provide a location to host pages, as well as a common interface to the navigation
Figure 29.7
The navigation application with a customer list page loaded from an external assembly

755
Navigation out of the browser
facilities offered by the NavigationService class and services such as the URI mapper.
Both frames and pages participate in caching to help improve application perfor-
mance. Pages can be loaded from resources inside the executing assembly, or from
external assemblies resolved at compile time or runtime.
 So far, everything you’ve done has been for in-browser applications, where you
have the browser’s navigation UI and history journal to rely on. Out-of-browser appli-
cations obviously can’t take advantage of these things. Luckily, the Silverlight naviga-
tion framework has taken this scenario into consideration and provided everything
you need to have proper out-of-browser navigation. 
29.4
Navigation out of the browser
Out-of-browser applications don’t have the benefit of the browser-based navigation UI.
From a user experience standpoint, this is excellent, because you’ll want to provide
your own in-theme navigation controls anyway. Consider the Microsoft Zune software
client: it uses familiar navigation metaphors but looks different from a web browser.
 The Zune client uses some of the traditional controls and navigation concepts (pri-
marily links and the Back button) but provides a custom look and feel. The Zune
client also eschews the use, in this case, of a Forward button.
Figure 29.8
The Zune software client. Note the small arrow Back button at the upper left. Also 
note the two-level navigation using links such as Quickplay, Collection, Marketplace, and Social. 
(I get my Doctor Who fix using Zune. It’s cheaper than cable.)

756
CHAPTER 29
Navigation
A UI along the lines of the Zune client is well within the capabilities of a Silverlight
out-of-browser application with custom chrome and navigation. In this section, you’ll
see what it takes to create custom navigation controls, hook up to an appropriate jour-
nal, and support navigation out of the browser.
29.4.1 Providing custom navigation controls
In the previous sections, you’ve seen how the Frame class provides various properties,
methods, and events you can use to control and respond navigation. You’ve also cre-
ated a shell of a navigation application that integrated with the browser to provide
standard URI and back and forward navigation. 
 The next step is to take this application out-of-browser and provide your own cus-
tom navigation UI.
CREATING THE NAVIGATION CONTROLS
The application needs, at a minimum, a Back button and a Forward button. For this,
you’ll use the metro theme (Windows Phone and Zune) icons from http://metro
.windowswiki.info/. From that set, drag both the back.png and next.png black icons
into the project’s Assets folder. When they’re in place, modify MainPage.xaml to add
the XAML in listing 29.3 right before the closing Grid tag at the bottom of the file.
<Grid x:Name="OutOfBrowserNavigationControls"
      VerticalAlignment="Top" HorizontalAlignment="Left"
      Margin="15">
  <Grid.Resources>
    <Style TargetType="Button">
      <Setter Property="Cursor" Value="Hand" />
      <Setter Property="Margin" Value="2" />
      <Setter Property="Opacity" Value="0.5" />
      <Setter Property="VerticalAlignment" Value="Top" />
      <Setter Property="Template">
        <Setter.Value>
          <ControlTemplate>                            
            <Grid>
              <VisualStateManager.VisualStateGroups>
                <VisualStateGroup x:Name="CommonStates">
                  <VisualState x:Name="Normal" />
                  <VisualState x:Name="Disabled">
                    <Storyboard>
                      <DoubleAnimation Duration="0"
                        Storyboard.TargetName="Content"
                        Storyboard.TargetProperty="Opacity"
                        To=".2" />
                    </Storyboard>
                  </VisualState>
                </VisualStateGroup>
              </VisualStateManager.VisualStateGroups>
              <ContentPresenter x:Name="Content" />
            </Grid>
          </ControlTemplate>
        </Setter.Value>
Listing 29.3
The Back and Forward buttons on MainPage.xaml
Button 
template

757
Navigation out of the browser
      </Setter>
    </Style>
  </Grid.Resources>
  <StackPanel Orientation="Horizontal">
    <Button x:Name="BackButton"                         
            Click="BackButton_Click"
            Width="40" Height="40">
      <Image Source="Assets/back.png" />
    </Button>
    <Button x:Name="ForwardButton"                        
            Click="ForwardButton_Click"
            Width="25"
            Height="30">
      <Image Source="Assets/next.png" />
    </Button>
  </StackPanel>
</Grid>
The XAML in the listing
adds two buttons: Back and
Forward. The style resource
creates a button that has no
real appearance other than
its content. When you run
the application, the 
UI
displays the two new but-
tons at the upper left on
the main page, as shown in
figure 29.9.
 The new UI looks pretty good. With the buttons in place, you’ll need to wire them
up to the content frame to make navigation happen.
WIRING UP THE BUTTONS
In the button-click event handlers for the two new navigation buttons, you’ll place
code similar to what you wrote in listing 29.2. This time, though, you’ll use the Frame
class directly rather than the NavigationService class. Listing 29.4 shows the code-
behind for the MainPage.xaml page.
private void BackButton_Click(object sender, RoutedEventArgs e)
{
  if (ContentFrame.CanGoBack)
    ContentFrame.GoBack();
}
private void ForwardButton_Click(object sender, RoutedEventArgs e)
{
  if (ContentFrame.CanGoForward)
    ContentFrame.GoForward();
}
Listing 29.4
Navigation code in MainPage.xaml.cs
Navigation
button
Navigation
button
Figure 29.9
The new navigation buttons appear at the upper left 
in the UI.

758
CHAPTER 29
Navigation
With this code in place, you can use either the browser buttons or the custom naviga-
tion buttons to move backward and forward through the journal. There’s currently no
visual cue indicating whether either navigation option is available. You can do this
using binding, because the CanGoBack and CanGoForward properties of the Frame class
are implemented as dependency properties. As you learned in chapter 16, you can use
element binding to get to the properties on ContentFrame, as shown here:
<Button x:Name="BackButton"
        IsEnabled="{Binding CanGoBack, ElementName=ContentFrame}"
...
</Button>
<Button x:Name="ForwardButton"
        IsEnabled="{Binding CanGoForward, ElementName=ContentFrame}"
...
</Button>
With that in place, you’ll see the Forward and Back buttons ghost out when the func-
tion isn’t available. Note how the buttons are in sync with the browser navigation but-
tons. Now, let’s try it without the browser.
OUT-OF-BROWSER 
The next step is to turn the application into an out-of-browser application. Chapter 5
covered out-of-browser applications in detail; if you haven’t yet read that chapter, you
may wish to take a brief detour over there now.
 Right-click the main application project, select Properties, and select the Enable
Running Application Out of the Browser check box on the Silverlight tab. Next, on
the Debug tab, select Out-of-Browser Application as the start action. Finally, set the
NavigationExample project as the startup project by right-clicking the project and
selecting Set as Start-up Project.
 With those steps complete, run the application. The result will look something like
figure 29.10.
Figure 29.10
The navigation 
application running 
out of browser, with 
custom navigation 
controls

759
Summary
One other important option relates to custom navigation: controlling who owns the
journal.
CONTROLLING THE JOURNAL
The Frame class includes a property named JournalOwnership. This property lets you
decide who should own the history journal. In a top-level navigation frame in an in-
browser application, the default is to let the browser own the journal. In an out-of-
browser application, the default is to let the frame own the journal. Table 29.7 shows
the three possible values of the JournalOwnership property.
 Given the defaults, leaving journal ownership at the default value will be sufficient
for most cases, including your out-of-browser application. For out-of-browser applica-
tions, it wouldn’t hurt to set the journal ownership to OwnsJournal, but other than a
short decision tree, you’re not really saving any code.
 There was a time when a series of dialogs could be considered the main UI for a
number of applications. Not anymore. Pages are the main way you present content to
users. But dialogs still have their place for presenting important information to the
user, such as error messages or details, or for gathering discrete bits of information
such as filenames.
In addition to the page-navigation approach you’ve seen so far, Silverlight has support
for two discrete types of dialogs: in-application floating windows with simulated
modality and system dialogs.  
29.5
Summary
In the old days, we had chisels and stone, manual typewriters, and the MDI and dialog
application navigation styles. At some point in the late 1990s, developers started tak-
ing cues from web browsers and decided that their navigation approach—using Back
and Forward buttons and uniquely addressable pages—made sense for many applica-
tions. It certainly made more sense than MDI in nondocument applications.
 Silverlight builds on this history and application navigation trends to nicely sup-
port the back/forward and URI navigation paradigm. Silverlight pages can be
uniquely addressed via URIs (including parameters for deep links directly into specific
bits of data) using hashtags as pioneered by Ajax. The navigation API even includes
support for caching and for customizing the navigation UI.
Table 29.7
Values for the JournalOwnership property of the Frame class
Value
Description
Automatic
If the frame control is a top-level frame and is running in-browser, the 
browser’s journal is used. Otherwise, the frame maintains its own journal.
OwnsJournal
The frame maintains its own journal.
UsesParentJournal
Uses the browser’s journal. This may only be used with a top-level (not 
nested) frame.

760
CHAPTER 29
Navigation
 Setting up a project to use the navigation API can be tricky, so the Silverlight tools
include a Navigation Application template that includes all the plumbing necessary to
get you well on your way to building the application. The template even includes
excellent support for skinning and theming. 
 The Silverlight navigation framework provides essential structure to your applica-
tions, independent of the implementation code within your app—just about any
application can use the navigation framework. In the next chapter, you’ll learn how to
enable Silverlight to work with local files.

761
Working with files
and directories
If you’re at your desktop, stop reading for a moment and look at the applications
you have open. Of them, how many require file operations? As I write this, I have a
number of applications open on my desktop that require file operations: Microsoft
Visual Studio, Word, Excel, and Windows Explorer; Adobe Illustrator; Zune, which
loads the music from the drive; Rhino 3D, for files, templates, temporary storage,
and more; Internet Explorer and Google Chrome, which need temporary storage
as well as the ability to save downloaded files; my webcam viewer,1 because it can
save snapshots; and Lync, which stores an archive of conversations if you leave that
option on. I can’t find a single open application on my machine that doesn’t
This chapter covers
■
File dialogs
■
Directories
■
Files
■
Isolated storage
1 I have a webcam on top of my PC pointed out and away and always on, because I can’t see over my two 30”
LCDs without it. Yeah, I know, first-world problem.

762
CHAPTER 30
Working with files and directories
require file input-output (I/O) of some sort. File I/O is so important that it feels
almost silly to say so.
 Since version 2, Silverlight has offered the ability to load data from local files, but it
was restricted to isolated storage and to streams loaded via the OpenFileDialog. Start-
ing with Silverlight 4 and the elevated trust mode it introduced, you gained the ability
to open any file in the My Documents folder (and the equivalent folder on the Mac)
without injecting additional UI in the process. This was further expanded in Silver-
light 5 to support opening most files from the user’s machine when running in ele-
vated trust mode.
 In this chapter you’ll first explore the secure way of loading and saving files: Open-
FileDialog and SaveFileDialog. These two dialogs have been around since the early
days of Silverlight, providing an abstraction layer that enables you to open and save
files without having any actual knowledge of the user’s filesystem.
 The dialog approach falls far short when doing any type of application with serious
file requirements. For those cases, if you’re willing to require elevated trust mode, you
have access to the Directory and File classes. Both of those are important to file-cen-
tric applications, so you’ll look at them in detail.
 Finally, on the opposite end of the spectrum is isolated storage. Isolated storage
has also been around since the early days of Silverlight. It was included as an answer to
those applications that needed a filesystem they could programmatically interact with,
without user intervention. Elevated trust mode has gained popularity over the past
couple revisions of Silverlight, so this approach has somewhat declined in usage.
 My coverage of file I/O in Silverlight will start where Silverlight did: the open and
save dialogs.
30.1
Using the file open and save dialogs
Silverlight includes two specialized dialog classes, which work cross-platform and sup-
port opening and saving files. These dialog classes are named, respectively, OpenFile-
Dialog and SaveFileDialog.
 The OpenFileDialog class enables you to ask users for one or more files from their
filesystem. From there, you can load the data from the selected files into memory, giv-
ing you the flexibility to do any number of things. For instance, you can send the con-
tents of a file to a server or load the contents into your Silverlight application. The
SaveFileDialog performs a similar function but provides a mechanism to save a sin-
gle file to the filesystem. In both cases, the application code knows nothing about the
actual location of the file.
 Normally, the dialog must be user initiated—that is, the call to open a dialog must
come from a user-initiated event: a button click, for example. Except when running
in elevated trust mode, a call to the dialog without user initiation will result in an
exception.

763
Using the file open and save dialogs
 In this section, you’ll learn the three steps involved in interacting with an Open-
FileDialog. The first step involves launching and configuring an instance of the
OpenFileDialog class. Next, you must wait for and retrieve the results of a user’s inter-
action with an OpenFileDialog. Finally, you’ll parse the results if a user has selected at
least one file.
30.1.1 Working with the OpenFileDialog
The OpenFileDialog provides a safe way to interact with files on the user’s OS. Unlike
the code approaches you’ll see later in this chapter, the use of the OpenFileDialog
doesn’t require elevated permissions.
 The dialog takes on the default appearance for the Open File dialog for the oper-
ating system and operating system theme in use. This confirms that the user is familiar
with the dialog and helps ensure their trust. Because this is an operating system dialog
running from a sandboxed environment, you can’t customize the look. The dialog has
only a few properties with which you’ll interact; table 30.1 lists them.
You display the dialog through a call to the OpenDialog function. This function option-
ally takes a reference to a parent window (important in out-of-browser applications
using OS native windows) and returns a nullable bool value indicating whether the user
has selected a file or canceled. It’s a tristate nullable value only for compatibility with
the desktop version. Figure 30.1 shows the dialog as it appears on Windows 7.
Table 30.1
Properties for the OpenFileDialog class
Property
Description
Filter
The string specifying which file types to show in the dia-
log. You may provide any number of filter specifications 
separated by the pipe character as in this example: 
description|*.ext|description|*.ext.
FilterIndex
The filter you wish to be the default. This is a one-
based index into the filters specified by the Filter
property.
InitialDirectory
A string specifying the directory to be opened upon 
startup.
Multiselect
Set to true if you want to support multiple file selec-
tion; false is the default.
File
When in single selection mode, exposes a FileInfo
object with information about the selected file.
Files
Primary for use in multiselection mode, it exposes a 
collection of FileInfo objects.

764
CHAPTER 30
Working with files and directories
In this example, I set a starting directory through the InitialDirectory property and
a set of valid extensions through the Filter property, and defaulted to the second fil-
ter in the list, Microsoft Word, through the FilterIndex property. Note that the code
in the listing runs inside a button click handler on a page.
private void OpenFile_Click(object sender, RoutedEventArgs e)
{
  var dialog = new OpenFileDialog();
  dialog.Filter = "Text files (*.txt)|*.txt|" +
                  "Microsoft Word (*.docx,*.doc)|*.docx;*.doc|"+
                  "XML files (*.xml)|*.xml|" +
                  "XAML files (*.xaml)|*.xaml";
  dialog.FilterIndex = 2;
  dialog.Multiselect = false;
  dialog.InitialDirectory = 
    @"D:\Documents\Docs\Publications\Silverlight 5 in Action\Manuscript";
            
  dialog.ShowDialog();                  
}
Listing 30.1 shows the OpenFileDialog with a few options to customize its presenta-
tion to the user. You’re not using the return value from ShowDialog in this code; that
will come shortly. 
Listing 30.1
Showing the OpenFileDialog with options
Figure 30.1
The OpenFileDialog showing the specified filter and start location in use
Show dialog

765
Using the file open and save dialogs
 The first option is the filter. You allow the user to select from four different types of
files, one of which, the Microsoft Word filter, has two possible extensions. The filter
format itself is the standard file dialog filter format you’re used to from Windows, but
it also works on the Mac. The format is a description followed by the pipe character,
followed by one or more filter patterns. The filter specifications must include the wild-
card (*) character. If more than one filter pattern is used, separate them with a semi-
colon. If more than one filter (description plus pattern) is used, separate them with a
pipe. Don’t put any spaces before or after the pipes or the patterns may not work cor-
rectly. Including the pattern in parentheses as part of the description is recommended
but not required.
 Next, you set the FilterIndex. This property is a one-based array index into the
filter string provided through the Filter property. Note this is one based—that is, the
first item in the list is the value 1. Setting this value makes the Microsoft Word filter in
the list the default filter. Users are free to select the others if they so desire.
 You then set the Multiselect property to false. By default it’s false, so this is
illustrative only. If you wanted to enable selection of more than one file, you’d set it to
true. Note that value of the MultiSelect property also affects which property you’ll
use to get the selected file information, as you’ll see shortly.
 The last step before you show the dialog is to set the InitialDirectory property.
This property lets you have the dialog open in a specific directory on the end user’s
machine. Setting this property is optional; for most applications, it should be left at
the default value, which is the last location used.
 In this example, you didn’t do anything with the results of the ShowDialog call.
Typically, you’ll want to check the return value and if the user did actually select a file,
use the File property (if single select) or Files collection (if multiselect) to get to the
FileInfo object you’re interested in. 
private void OpenFile_Click(object sender, RoutedEventArgs e)
{
  var dialog = new OpenFileDialog();
  dialog.Filter = "Text files (*.txt)|*.txt|" +
                  "Microsoft Word (*.docx, *.doc)|*.docx;*.doc|" +
                  "XML files (*.xml)|*.xml|" +
                  "XAML files (*.xaml)|*.xaml";
  dialog.FilterIndex = 2;
  dialog.Multiselect = false;
  dialog.InitialDirectory = 
    @"D:\Documents\Docs\Publications\Silverlight 5 in Action\Manuscript";
            
  bool? fileSelected = dialog.ShowDialog();    
  if (fileSelected == true)
  {
    var fileInfo = dialog.File;
Listing 30.2
Getting the file information from OpenFileDialog and opening the file
File selected?

766
CHAPTER 30
Working with files and directories
    using (StreamReader reader = fileInfo.OpenText())
    {
      string contents = reader.ReadToEnd();
      FileContents.Text = contents;
    }
  }
  else
  {
    MessageBox.Show("No file selected.");
  }
}
Listing 30.2 expands on listing 30.1 to add in code to deal with the result from Show-
Dialog, as well as read the contents of the text file. As mentioned, the ShowDialog call
returns a nullable Boolean value. Although this is only for compatibility with the desk-
top version, it requires you to do an explicit check against true or false rather than
just if (fileSelected) as you might normally do. Ugly, I know.
 Once you’ve confirmed the user selected a file instead of canceling the dialog, you
can get the FileInfo object. The FileInfo object contains the methods you need to
safely open that file for reading. In this case, you use OpenText to get a StreamReader.
Once you have the reader, it’s business as usual to read out the file contents. 
 Note that at no point in this process do you get an actual File object. The Open-
FileDialog was designed to be safe and secure, and therefore won’t provide you with
information that could potentially compromise the security of the user’s workstation
unless you’re already running in elevated trust mode. That information includes file
path information. Table 30.2 provides a bit more information on what this class sur-
faces for you.
Table 30.2
Properties and methods of the FileInfo object
Member
Description
Directory
Property that holds the DirectoryInfo object for the file. Only available to ele-
vated trust applications. Calling this from normal trust applications will throw an 
exception.
DirectoryName
Property that returns a string with the full path of the file. Only available to elevated 
trust applications. Calling this from normal trust applications will throw an excep-
tion.
Exists
Boolean property that returns true if the file exists. Returns false if the file 
doesn’t exist or if the file is a directory.
Length
Property containing the size in bytes of the represented file.
Name
Property that contains the string name of the file, without path information.
AppendText
Trusted applications only. Creates a StreamWriter for appending text to the file.
CopyTo
Trusted applications only. Copies the file to the specified path.
Create
Trusted applications only. Creates a file and returns an open FileStream.
Open file for 
text reading

767
Using the file open and save dialogs
You’ll note that when running in normal partial trust mode, most of the FileInfo
properties are unavailable. In fact, all you can tell is the filename (without the path),
its size, and whether it exists. When it comes to working with the file, you can only call
the OpenRead and OpenText methods. But because this is the result of the OpenFile-
Dialog, not being able to write to the file makes sense in most cases. When you want
to write to files in partial trust mode, you need to use the counterpart to the Open-
FileDialog: the SaveFileDialog. 
30.1.2 Saving files with the SaveFileDialog
If you find yourself working with files in Silverlight, opening them using the Open-
FileDialog or another means, there comes a time when they must be saved. In partial
trust applications, the only option you have for saving to the user’s filesystem is the
SaveFileDialog. 
 The SaveFileDialog does for writing files what OpenFileDialog does for reading.
It provides a safe and secure way to request write access to a file from the user. The
SaveFileDialog is quite a bit simpler than the OpenFileDialog given that it supports
working with only a single file, and it doesn’t return any FileInfo objects for you to
manipulate. Like the OpenFileDialog, it’s displayed using the ShowDialog method.
Table 30.3 shows the other properties and methods exposed by this class.
CreateText
Trusted applications only. Creates a file and returns an open StreamWriter.
Delete
Trusted applications only. Deletes the file.
MoveTo
Trusted applications only. Moves the file to a new location and, optionally, assigns a 
new filename.
Open
Trusted applications only. Opens the file in the specified mode and optionally speci-
fies flags for access type and sharing mode.
OpenRead
Opens the file for reading and returns the FileStream object.
OpenText
Opens the file for reading and returns the StreamReader object.
OpenWrite
Trusted applications only. Opens the file for writing and returns the FileStream
object.
Table 30.3
Properties and methods for the SaveFileDialog class
Member
Description
DefaultExt
Property that specifies the default filename extension that’s tacked on to the 
end of the filename if the user leaves off the extension; for example, txt.
DefaultFileName
Property that sets the filename that will be displayed by default in the dialog. 
Table 30.2
Properties and methods of the FileInfo object (continued)
Member
Description

768
CHAPTER 30
Working with files and directories
You can see that the only way to work with the file is through the OpenFile method.
Unlike the OpenFileDialog, there’s no provision to get additional path information
or to open the file in different modes. There’s also no provision to specify the default
directory. In partial trust applications, saving files is considered inherently more dan-
gerous than opening files, so these properties have been left out.
 Like the OpenFileDialog, the SaveFileDialog has an OS–specific theme; it’s the
actual OS dialog that’s being shown. Also like the other dialog, the SaveFileDialog
can’t be customized. Figure 30.2 shows how it looks.
Filter
The string specifying which file types to show in the dialog. You may provide 
any number of filter specifications separated by the pipe character as in this 
example: description|*.ext|description|*.ext.
FilterIndex
The filter you wish to be the default. This is a one-based index into the filters 
specified by the Filter property.
SafeFileName
String containing the filename picked by the user. This doesn’t contain any 
path information.
OpenFile
Method that opens the file for reading and writing, returning a Stream object.
Table 30.3
Properties and methods for the SaveFileDialog class (continued)
Member
Description
Figure 30.2
Saving a file to my desktop using the SaveFileDialog. The filename was prefilled based 
on properties set on the object. Yes, my desktop is cluttered. I switch browsers a lot and don’t use 
anything to synchronize favorites between them. Anything except my desktop, that is!

769
Using the file open and save dialogs
 The code to use the dialog is similar to what you saw for the OpenFileDialog. Listing
30.3 shows how to use the SaveFileDialog and write to the file selected by the user.
private void SaveFile_Click(object sender, RoutedEventArgs e)
{
  var dialog = new SaveFileDialog();
  dialog.Filter = "All files (*.*)|*.*|" + 
                  "Text files (*.txt)|*.txt|" +
                  "XML files (*.xml)|*.xml|" +
                  "XAML files (*.xaml)|*.xaml";
  dialog.FilterIndex = 2;
  dialog.DefaultExt = "txt";
  dialog.DefaultFileName = "SilverlightInAction.txt";
  bool? fileSelected = dialog.ShowDialog();
  if (fileSelected == true)
  {
    using (Stream stream = dialog.OpenFile())     
    {
      string contents = "Hello world from Silverlight!";
      using (var writer = new StreamWriter(stream))
      {
        writer.Write(contents);
        writer.Flush();
        writer.Close();                        
      }
    }
    MessageBox.Show("File saved to " + dialog.SafeFileName);
  }
  else
  {
    MessageBox.Show("No file selected.");
  }
}
The example shows how to prompt the user for a file, then open it and write the con-
tents of a string to the file. The file opens in binary mode so you aren’t limited to text
contents.
 After calling OpenFile, you’re responsible for closing the stream. If you use a
StreamWriter, as shown in this listing, closing it will automatically close the underly-
ing stream.
 The SaveFileDialog is great for Save As–type functionality in your applications.
It’s safe for users to use because the application knows nothing about the actual loca-
tion of the file. For the same reasons, it’s not great for resaving previously saved data. 
 Similarly, the OpenFileDialog is good when you need user intervention but not
great when you know the file you want to open in advance. In those cases, you’ll want
Listing 30.3
Writing a file using the SaveFileDialog
Get open 
file stream
Close stream
and writer

770
CHAPTER 30
Working with files and directories
to use elevated permissions and start working directly with the underlying filesystem,
starting with directories.  
30.2
Working with directories
Folders (or directories to those of us who did our first serious development using 8.3
character filenames on 5¼" floppies) are the way in which the filesystem is organized.
Directories provide a way to group files and other directories, as well as a structure by
which the filesystem tree may be navigated.
 For those reasons, when working with files in Silverlight, it often makes sense to
start with directories. Silverlight provides the Directory class, which has a number of
static methods that may be used to manipulate directories, list their contents, and
more. Table 30.4 shows the functions of the Directory class.
All of the methods of the Directory class require elevated permissions to work. This
makes sense, because you’re delving deeper into the filesystem than a user might con-
sider reasonable for a web-based technology. The user is no longer in control, so ele-
vated permissions are needed.
Table 30.4
The functions of the Directory class. All functions require elevation.
Function
Description
CreateDirectory
Creates all directories and subdirectories passed to the path parameter.
Delete
Deletes an empty directory. An overload takes a bool parameter, which 
will recursively delete all folders and files in the path.
EnumerateDirectories
Returns an IEnumerable of directories in the path. Overloads include 
optional meeting search criteria and flags for controlling how it’s used.
EnumerateFiles
Does the same for Files as EnumerateDirectories does for 
directories.
EnumerateFileSystem-
Entries
Returns everything in the specified filesystem path. This is logically a 
combination of EnumerateDirectories and EnumerateFiles.
Exists
Returns true if the specified path refers to a valid existing directory.
GetCreationTime
Returns a System.DateTime (in local time), which represents the 
date/time the specified directory was created.
GetCurrentDirectory
Returns a string with the full path of the current working directory.
GetDirectoryRoot
Returns the root/volume information for the specified directory.
GetLastAccessTime
Returns a System.DateTime (in local time), which represents the 
date/time the specified directory was last accessed.
GetLastWriteTime
Returns a System.DateTime (in local time), which represents the 
date/time the specified directory was last written to.
Move
Moves a file and its contents to a new location. The destination directory 
must not already exist.

771
Working with directories
Throughout the rest of this section you’ll explore the features of the Directory class.
You’ll first explore some of the utility methods of the class to pull out metadata such
as the date and time the directory was created. Then, you’ll dive into some of the
methods that provide access to the contents of the directories: files and subdirecto-
ries. Finally, you’ll look at the special folders supported on both Windows and Mac
that allow you to work with files in locations the OS knows but that may be different on
each user’s machine, like the Documents or Videos folders.
 To do that, you’ll work with a small Silverlight application with buttons for most of
the functions, a ListBox to display enumeration results, and a TextBlock to display
single value results. When run, it will look like figure 30.3.
 The test application is an elevated permissions application, running in-browser as
first enabled by Silverlight 5. Without elevated permissions, you wouldn’t be able to
test any of this functionality. The XAML to create the UI shown in figure 30.3 is
included in listing 30.4.
<UserControl x:Class="FileExample.MainPage"
  xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
  xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
  xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
  mc:Ignorable="d"
  d:DesignHeight="400" d:DesignWidth="500">
  <UserControl.Resources>
Listing 30.4
The test application UI XAML
Figure 30.3
The Directory 
test application UI showing 
the results of the Enum All 
button. This is an elevated 
permissions application, 
running in-browser.

772
CHAPTER 30
Working with files and directories
    <Style TargetType="Button">
      <Setter Property="Margin" Value="4" />
      <Setter Property="Width" Value="140" />
      <Setter Property="Height" Value="25" />
    </Style>
  </UserControl.Resources>
    
  <Grid x:Name="LayoutRoot" Background="White">
    <Grid.ColumnDefinitions>
      <ColumnDefinition Width="*" />
      <ColumnDefinition Width="Auto" />
    </Grid.ColumnDefinitions>
        
    <ListBox x:Name="ResultsList" Grid.Column="0" Margin="10" />  
    <StackPanel Grid.Column="1" Margin="10">
      <TextBlock Text="Path" Margin="0 0 0 0" Width="200" />
      <TextBox x:Name="PathEntry" Text="C:\Program Files"
               Margin="4 2 4 4" />
      <TextBlock x:Name="SingleResult" Text="(result)"    
                 Margin="4" Width="200" />
      <Button x:Name="CreateDirectory" Content="Create"
              Click="CreateDirectory_Click" />
      <Button x:Name="EnumerateDirectories" Content="Enum Dirs"
              Click="EnumerateDirectories_Click" />
      <Button x:Name="EnumerateFiles" Content="Enum Files"
              Click="EnumerateFiles_Click" />
      <Button x:Name="EnumerateAll" Content="Enum All"
              Click="EnumerateAll_Click" />
      <Button x:Name="GetDirectoryRoot" Content="Get Dir Root"
              Click="GetDirectoryRoot_Click" />
      <Button x:Name="GetCreationTime" Content="Get Create Time"
              Click="GetCreationTime_Click" />
      <Button x:Name="GetLastAccessTime" Content="Get Last Access Time"
              Click="GetLastAccessTime_Click" />
      <Button x:Name="GetLastWriteTime" Content="Get Last Write Time"
              Click="GetLastWriteTime_Click" />
      <Button x:Name="CheckForExists" Content="Exists?"
              Click="CheckForExists_Click" />
      </StackPanel>
  </Grid>
</UserControl>
When creating this example, you’ll find that the easiest way to get the event handlers
in place and wired up is to name the control and then double-click it on the design
surface. In the case of a button, doing so will create a Click event handler and wire up
the Click event in XAML.
 Now, on to writing code to demonstrate each of these features, starting with infor-
mation about the directories.
30.2.1 Getting directory timestamps
Directory entries on disk store information about the directory itself. The information
or metadata includes the date and time it was created, the date and time it was last
accessed by a user, and the last time it was written to. Each of these can be useful when
Enum 
results
Single
results

773
Working with directories
you’re creating your own directory browser in Silverlight. The Directory class surfaces
all three bits of metadata as standard .NET DateTime values, in local machine time.
 Listing 30.5 shows how to get all three timestamps from a directory and surface the
information on the UI created earlier.
private void GetCreationTime_Click(object sender, RoutedEventArgs e)
{
  string path = PathEntry.Text.Trim();
  if (PathExists(path))
  {
    DateTime result = Directory.GetCreationTime(path);  
    ResultsList.ItemsSource = null;
    SingleResult.Text = result.ToString();
  }
}
private void GetLastAccessTime_Click(object sender, RoutedEventArgs e)
{
  string path = PathEntry.Text.Trim();
  if (PathExists(path))
  {
    DateTime result = Directory.GetLastAccessTime(path);  
    ResultsList.ItemsSource = null;
    SingleResult.Text = result.ToString();
  }
}
private void GetLastWriteTime_Click(object sender, RoutedEventArgs e)
{
  string path = PathEntry.Text.Trim();
  if (PathExists(path))
  {
    DateTime result = Directory.GetLastWriteTime(path);   
    ResultsList.ItemsSource = null;
    SingleResult.Text = result.ToString();
  }            
}
The code for the three event handlers is identical except for the call to the appropri-
ate Directory function. In each case, you first clean up the path entered in the Text-
Box on the page. Then, you check to see if the path exists (more on that in a
moment). If the path exists, you call the function to get the metadata, and then store
the results in a DateTime variable, which is displayed in a TextBlock on the page. At
the same time, you clear out the ListBox so its display isn’t confused with the results
of the button click.
Listing 30.5
Getting the timestamps for a directory
Creation
Last access
Last write

774
CHAPTER 30
Working with files and directories
30.2.2 Checking for directory existence
Notice that each event handler in listing 30.5 makes a call to PathExists to see if the
specified directory exists. To make your code more robust, it’s a good practice to
check for the existence of a directory before doing anything with it. In this way, you
can differentiate a “doesn’t exist” result from another potential error. That’s a prac-
tice you’ll follow in this example. The PathExists function is a wrapper around the
Directory.Exists function, as shown in listing 30.6.
private bool PathExists(string path)
{
  if (Directory.Exists(path))              
  {
    return true;
  }
  else
  {
    MessageBox.Show("Path doesn't exist");
    return false;
  }
}
PathExists is a helper function I wrote so as not to duplicate the MessageBox code in
each function. Avoiding unnecessary duplication is a good coding practice in general,
but even more so when your listings need to fit in the pages of a book.
 This code first makes a call to Directory.Exists. The Exists function will return
true if the provided path points to a valid directory on disk. If the path exists, it simply
returns true. If the path doesn’t exist, the function displays a message and returns
false.
 In this way, you get the Exists functionality as well as handling to display a
MessageBox all wrapped up into one function.
 Another piece of information you can get about the directory is the drive root on
which it exists.
30.2.3 Getting the directory root
Each directory in Windows and most other OSs has what’s known as a “root.” In the
case of physical drives, the root is typically a drive letter like c:\. In the case of network
shares, the root is the share name. For example, on my home network I have a server
named Moria.2 If I request the root name for the directory:
\\Moria\Media\Images\Personal Photos\2011\2011-05-11
Listing 30.6
Telling whether a directory exists
2 The server is dark, dusty, and loaded full of ancient files. Oh, and orcs.
Call to 
Directory.Exists

775
Working with directories
the call to GetDirectoryRoot returns the share name: \\Moria\Media. If I pass in this
directory name:
D:\Source\Hardware\Roland JP-8080
the result from GetDirectoryRoot will simply be D:\. The OS defines what the root of
any given drive is. The general rule is, for mapped drives and physical drives the root
is the drive letter. For network shares, the root is the share name. Listing 30.7 shows
how to get the directory root for the path entered on the page.
private void GetDirectoryRoot_Click(object sender, RoutedEventArgs e)
{
  string path = PathEntry.Text.Trim();
  if (PathExists(path))
  {
    string result = Directory.GetDirectoryRoot(path);
    ResultsList.ItemsSource = null;
    SingleResult.Text = result;
  }
}
As before, you trim the entry and check to see if the path exists. With that ceremony
out of the way, you simply call Directory.GetDirectory root and display the results in
the TextBlock on the page.
GetDirectoryRoot is useful especially when you need to navigate up to the root of
a directory programmatically. Once at the root, you may be interested in creating
other directories or even removing ones already present.
30.2.4 Creating and deleting directories
Part of saving files in a full-featured application may involve creating directories. You
may need to save them as part of storing standard reports in date-specific folders, for
example. If you can create directories, you should also be able to remove them. It’d be
strange for an application to provide users with the ability to create one and then tell
them they can’t remove it when they made a mistake.
 The Directory class provides both a CreateDirectory method and a Delete
method. The CreateDirectory method will create every nonexisting directory in the
provided path. So, if you provide it with d:\Foo\Bar\Baz as the folder name, and nei-
ther Bar nor Baz exists, they’ll both be created following that structure.
 On the other hand, Delete will delete only the bottommost (or leaf-most) direc-
tory provided in the path. If you provide it with the same d:\Foo\Bar\Baz path, it’ll
delete only Baz. First, let’s look at how to create a string of directories.
CREATING DIRECTORIES
In the sample application, you’ve provided a button to enable creating directories.
You’ll want to change the entry to something other than c:\Program Files in order to
Listing 30.7
Getting the directory root

776
CHAPTER 30
Working with files and directories
test this out. Listing 30.8 shows how to create the directory specified in the TextBox on
the page.
private void CreateDirectory_Click(object sender, RoutedEventArgs e)
{
  string path = PathEntry.Text.Trim();
  if (Directory.Exists(path))
  {
    MessageBox.Show("The directory \"" + path + "\" already exists.");
  }
  else
  {
    var dirInfo = Directory.CreateDirectory(path);  
    ResultsList.ItemsSource = null;
    SingleResult.Text = "Created " + dirInfo.Name;
  }
}
When creating the directory, you first check to see whether the directory exists. But
it’s not quite the same flow as it was in the previous examples. In this case, if the direc-
tory exists, you want to display an error. The code only proceeds in the case that the
directory doesn’t already exist. Because of the way the CreateDirectory method
works, you don’t need to check each directory in the path; as I mentioned, it’ll create
them all for you as needed.
DELETING DIRECTORIES
I hesitated to provide a “delete” example in the code, but figured I would anyway.
Please don’t write to me if you happen to delete some critical directory on your
machine when trying this example. Seriously, make sure you know what you’re delet-
ing and you’re cool with it before you run it. I didn’t wire the function up to an event
handler; instead I opted to leave it in the code orphaned so your curious click-happy
three-year-old child can’t accidentally toast your drive.3 On the up side, the code can’t
do any more than you can, so if you have Windows Vista, 7, or 8 and have the elevation
prompts on and aren’t running as local admin,4 you’ll be good.
 Listing 30.9 shows how to recursively delete everything below and including the
Bar directory under d:\Foo.
private void DeleteDirectory()
{
  string path = @"D:\Foo\Bar";
Listing 30.8
Creating a directory
3 I have a three-year-old, and I can totally see this happening, complete with Hitchcock Psycho shower-scene hor-
ror music and slow-motion scream.
4 All six of you.
Listing 30.9
Deleting a directory and its contents
CreateDirectory

777
Working with directories
  if (MessageBox.Show(
    "Really delete the directory \"" + path + 
      "\" and all the items below it?",
    "Delete Confirmation",
    MessageBoxButton.OKCancel) == MessageBoxResult.OK)
  {
    if (PathExists(path))
    {
      Directory.Delete(path, true);        
    }
  }
}
The Directory.Delete function has two overloads. The first takes a path and will only
delete an empty directory. The second, used here, takes a Boolean value that indicates
whether or not to recursively delete all files and folders. In this case, because you
passed in true, any contents of Bar, including other directories and their contents,
will be deleted. Had you passed in false, the delete would fail if Bar had any contents.
 Rather than just drop a nuke on part of the filesystem by passing in true as used
here, you may want to check to see whether the directory is, in fact, empty. There are
several functions that can help.
30.2.5 Listing directory contents
One of the most useful functions provided by the Directory class is enumerating con-
tents. This is essential for any file browser-type functionality you’ll have in your appli-
cation, including creating your own version of a Save dialog.
 Directory contents enumeration is broken down into three parts. The first
method, EnumerateDirectories, will only list the directories below the specified
path. Similarly, EnumerateFiles will only list the nondirectory files in the same path.
If you want the combination of the two, you’ll need to use the EnumerateFileSystem-
Entries function.
 In all cases, these functions return IEnumerable<string>. This is typically suffi-
cient for a simple ListBox of files or directories. But if you want additional details for
the items, such as create dates, you’ll need to roll through the enumerable and use
the appropriate functions to get that information for each item.
 Listing 30.10 shows how to use the three different enumeration functions to popu-
late the ListBox in the sample application.
private void EnumerateDirectories_Click(object sender, RoutedEventArgs e)
{
  string path = PathEntry.Text.Trim();
  if (PathExists(path))
  {
    var files = Directory.EnumerateDirectories(path);    
Listing 30.10
Enumerating directories and files
Delete recursively
Directories

778
CHAPTER 30
Working with files and directories
    ResultsList.ItemsSource = files;
  }
}
private void EnumerateFiles_Click(object sender, RoutedEventArgs e)
{
  string path = PathEntry.Text.Trim();
  if (PathExists(path))
  {
    var files = Directory.EnumerateFiles(path);       
    ResultsList.ItemsSource = files;
  }
}
private void EnumerateAll_Click(object sender, RoutedEventArgs e)
{
  string path = PathEntry.Text.Trim();
  if (PathExists(path))
  {
    var files = Directory.EnumerateFileSystemEntries(path);  
    ResultsList.ItemsSource = files;
  }
}
The results of the function calls are shown in the ListBox on the page. If you refer
back to figure 30.3, you’ll see the results of enumerating both files and directories.
 Note that I could have shortened the listing slightly by setting the ItemsSource to
the results of the enumeration functions directly rather than through an intermediary
variable.
 So far, all of the examples have had a user-supplied path. In some cases, you’ll want
to access a known system directory such as My Documents. Those are collectively
known as special folders.
30.2.6 Accessing special folders
Special folders are the folders reserved for OS–specific functionality. These are the
known folders that, on Windows, typically have a different icon in Windows Explorer,
such as Desktop, Program Files, My Videos, and others. When saving files, you’ll find
that it often makes sense to set the initial directory to one of these known folders.
 The paths to the special folders are accessed using Environment.GetFolderPath
and passing it a value in the Environment.SpecialFolder enumeration. Environment
.GetFolderPath returns the full path associated with the supplied SpecialFolder
value. An example of enumerating all of the files in the My Music folder looks like this:
var music = Directory.EnumerateFiles(
  Environment.GetFolderPath(Environment.SpecialFolder.MyMusic));
The result is an IEnumerable<string> containing all of the files in the D:\Docu-
ments\Docs\Music folder on my machine, or likely the C:\Users\YourName\Music
Files
All

779
Working with directories
folder on your machine. I changed the location on mine because I didn’t want to fill
up my SSD (Solid State Drive) with music files and other data. What’s great is no other
program needs to know that I made that change, as long as it uses the GetFolderPath
function.
 The full list of special folders currently supported in elevated trust Silverlight
applications is shown in table 30.5. The enumeration itself has quite a few other val-
ues, but those are for compatibility with the full framework. Using them in Silverlight
will throw an exception. 
Silverlight provides a rich set of functions for working with directories—far more than
you might expect from a web application technology. You can create and delete direc-
tories, check to see whether they exist, get metadata about them, and list their contents. 
 Most applications don’t stop with directory manipulation, though. Working with
directories is typically the first step to getting to the real data: files.
Table 30.5
 The values of SpecialFolder currently supported in Silverlight
Enum value
Description
MyComputer
The My Computer folder
Note: The MyComputer constant always contains the empty string ("") 
because no path is defined for the My Computer folder.
Example: ""
MyMusic
The My Music folder.
Example: C:\Users\Pete.Brown\Music
MyPictures
The My Pictures folder.
Example: C:\Users\Pete.Brown\Pictures
MyVideos
The My Videos folder.
Example: C:\Users\Pete.Brown\Videos
Personal
The directory that serves as a common repository for documents.
This is the same as MyDocuments.
MyDocuments
The My Documents folder.
Example: C:\Users\Pete.Brown\Documents
The Path utility class
Silverlight also includes the System.IO.Path utility class. This is a helpful class that
includes static methods for manipulating paths. It doesn’t do anything directly with
the underlying filesystem but rather provides a way to manipulate path strings as well
as a couple of other helpful features.
The Path class provides a safe way to combine a directory name and a filename, with-
out your having to check for things like trailing slashes. It’ll also provide you with the
component parts of a given path should you need to parse them from a string. The

780
CHAPTER 30
Working with files and directories
30.3
Working with individual files
Most of the applications you work with day in and day out work with data, and if that
data doesn’t reside in a database it typically resides in a file. Most applications work
with local files if they aren’t working with a service of some kind. Not only do you have
the obvious uses for documents like the program I’m using to type this chapter, but
file I/O is needed for things like temporary storage, configuration files, local cache,
data sharing, and much more.
 When working with files, you use three primary operations: creating, writing, and
reading. Beyond that you can also delete and copy or move files, as well as get meta-
data on the files, just as you did earlier with directories.
 In this section you’ll build a small sample application that shows how to create
files, write to files, read from files, and get file metadata. I’ll also talk about some of
the utility functions available but not commonly used.
 First, as was the case with the directory example, you need to create an elevated
trust Silverlight project with some UI, an example of which you can see in figure 30.4.
(continued)
Path object will even tell you the right separator character to use for the OS Silverlight
is running on.
Path is also the object to use if you want to know the directory or a filename for tem-
porary files.
If you find yourself doing manual path manipulation, concatenation, or parsing, look
to see if the Path class has equivalent functionality, and use that. You’ll avoid bugs
and have cross-platform support. 
Figure 30.4
The demo application that will illustrate the different types of file manipulation

781
Working with individual files
The application has two TextBox controls on the left: one for the contents to be writ-
ten to a file, another for the contents to be read from a file. On the right, there’s a
TextBox for entering a filename, several TextBlock elements for showing file meta-
data, and a bunch of buttons to use to test the functions.
<UserControl x:Class="FileExample.MainPage"
  xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
  xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
  xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
  mc:Ignorable="d" d:DesignHeight="400" d:DesignWidth="500">
  <UserControl.Resources>
    <Style TargetType="Button">
      <Setter Property="Margin" Value="4" />
      <Setter Property="Width" Value="140" />
      <Setter Property="Height" Value="25" />
    </Style>
    <Style TargetType="TextBlock">
      <Setter Property="Margin" Value="0 4 10 0" />
    </Style>
    </UserControl.Resources>
    <Grid x:Name="LayoutRoot" Background="White">
      <Grid.ColumnDefinitions>
        <ColumnDefinition Width="*" />
        <ColumnDefinition Width="Auto" />
      </Grid.ColumnDefinitions>
        
      <Grid Grid.Column="0" Margin="10">
        <Grid.RowDefinitions>
          <RowDefinition Height="Auto" />
          <RowDefinition Height="*" />
          <RowDefinition Height="Auto" />
          <RowDefinition Height="*" />
        </Grid.RowDefinitions>
        <TextBlock Text="Entry" Grid.Row="0" />   
        <TextBox x:Name="ContentsEntry"             
                 TextWrapping="Wrap" Grid.Row="1" />
        <TextBlock Text="Contents" Grid.Row="2" />
        <TextBox x:Name="ExistingContents"      
                 Grid.Row="3" TextWrapping="Wrap" />
      </Grid>
      <StackPanel Grid.Column="1" Margin="10">
        <TextBlock Text="File Name" Margin="0 0 0 0" Width="200" />
        <TextBox x:Name="FileNameEntry" Margin="4 2 4 4" />
        <Grid>
          <Grid.ColumnDefinitions>
            <ColumnDefinition Width="Auto" />
            <ColumnDefinition Width="*" />
          </Grid.ColumnDefinitions>
Listing 30.11
XAML UI for the file example
New contents
Existing contents

782
CHAPTER 30
Working with files and directories
          <Grid.RowDefinitions>
            <RowDefinition Height="Auto" />
            <RowDefinition Height="Auto" />
            <RowDefinition Height="Auto" />
            <RowDefinition Height="Auto" />
          </Grid.RowDefinitions>
          <TextBlock Grid.Row="0" Grid.Column="0" Text="Attributes" />
          <TextBlock x:Name="FileAttributesDisplay"
                     Grid.Row="0" Grid.Column="1" TextWrapping="Wrap" />
          <TextBlock Grid.Row="1" Grid.Column="0" Text="Created" />
          <TextBlock x:Name="FileCreateDate" 
                     Grid.Row="1" Grid.Column="1" />
          <TextBlock Grid.Row="2" Grid.Column="0" Text="Last Access" />
          <TextBlock x:Name="FileLastAccessDate"
                     Grid.Row="2" Grid.Column="1" />
          <TextBlock Grid.Row="3" Grid.Column="0" Text="Last Write" />
          <TextBlock x:Name="FileLastWriteDate"
                     Grid.Row="3" Grid.Column="1" />
        </Grid>
        <Button x:Name="CreateFile" Content="Create"        
                Click="CreateFile_Click" />
        <Button x:Name="AppendToFile" Content="Append"
                Click="AppendToFile_Click" />
        <Button x:Name="ReadFromFile" Content="Read from File"
                Click="ReadFromFile_Click" />
        <Button x:Name="GetFileMetadata" Content="Get Metadata"
                Click="GetFileMetadata_Click" />
        <Button x:Name="CheckForExists" Content="Exists?" />
    </StackPanel>
  </Grid>
</UserControl>
Listing 30.11 shows the XAML that creates a two-column layout, the first column of
which has the two contents boxes; the second has the filename input box, the meta-
data display, and the buttons.
 Listing 30.12 shows the code-behind, with an example of how I used the
Environment.SpecialFolders 
enum 
from 
the 
previous 
section, 
plus 
the
System.IO.Path class, to provide the default filename.
using System;
using System.Windows;
using System.Windows.Controls;
using System.IO;
namespace FileExample
{
  public partial class MainPage : UserControl
  {
    public MainPage()
    {
Listing 30.12
Code-behind for the file example

783
Working with individual files
      InitializeComponent();
      Loaded += new RoutedEventHandler(MainPage_Loaded);
    }
    void MainPage_Loaded(object sender, RoutedEventArgs e)
    {
      if (!Application.Current.HasElevatedPermissions)  
      {
         LayoutRoot.Visibility = Visibility.Collapsed;
         MessageBox.Show("This demo requires elevated permissions");
      }
      else
      {
         ContentsEntry.Text = 
             "I have no idea to this day what those two " +
             "Italian ladies were singing about. Truth " +
             "is, I don't want to know. Some things are " +
                         ...
             "moments, every last man in Shawshank felt " +
             "free.";            
        
         FileNameEntry.Text = System.IO.Path.Combine(  
           Environment.GetFolderPath(
             Environment.SpecialFolder.MyDocuments),   
             "Foo.txt");
      }
    }
  }
}
In the MainPage_Loaded event handler for this page, you first check to see if the appli-
cation is running with elevated permissions. If it isn’t, you collapse the UI and display
a message. I had similar code in the directory example application, but I didn’t
include it in the book listings; it’s in the downloadable code at www.manning.com/
Silverlight5inAction.
 If the check passes, you then add the default text to the contents box—this is just
to avoid having to type new text in each example. Then you set the default filename.
Notice how you use Environment.GetFolderPath and Environment.SpecialFolder
as described in the previous section, and then combine the results of that call with the
filename Foo.txt using the Path.Combine utility method. 
 In the rest of this section you’ll explore the other major functions provided by the
File class. First, you’ll create a file on disk. Next, you’ll open the file and write addi-
tional content to it. Then, in order to see what you’ve already written, you’ll imple-
ment read functionality to pull back the contents. The metadata about your file can
also be interesting, so you’ll take a look at that as well. The section will wrap up with a
brief look at the utility functions provided by the File class.
 The File class has a large number of methods, but once you understand the basic
functionality of a single method within a particular functional grouping, you can eas-
ily figure out the remaining functions. For that reason, the code examples won’t cover
Check 
permissions
Path.Combine
Special folder

784
CHAPTER 30
Working with files and directories
every function but will instead focus on demonstrating the capabilities within each
group, starting with creating a new file.
30.3.1 Creating a file
One of the most basic file manipulation functions is the creation of a file. Typically,
the application will enable some sort of entry, or will have variables that must be saved
to disk. Then, it’ll either use a calculated filename or prompt users for the location
and filename they wish to use. The contents of the variable or entry field will then be
written to the newly created file.
 In general, it’s not a great practice to keep the file open and locked by the applica-
tion. If you want to follow the approach used by Microsoft Office applications, you keep
open a temporary file to which you regularly write the data. When the user decides to
save, you open the main file, update it, and close it. This keeps the opportunity for cor-
rupted or locked files to a minimum and therefore keeps your users happy.5
 Although several other methods will automatically create files, there are two dedi-
cated file creation methods in the File class. Those methods are listed in table 30.6.
The two functions are similar, but CreateText saves you a step in that it returns a
StreamWriter for you. In the example, you’ll use the more basic Create method and
create the StreamWriter manually.
private void CreateFile_Click(object sender, RoutedEventArgs e)
{
  string fileName = FileNameEntry.Text.Trim();
  string newContents = ContentsEntry.Text.Trim();
  if (!File.Exists(fileName))                       
  {
    using (var fileStream = File.Create(fileName))  
    {
      using (var writer = new StreamWriter(fileStream))
      {
5 I can think of few things as annoying as a lock that prevents you from copying, moving, or deleting the
file or folder it resides in. This used to happen all the time on network shares. I’m pretty sure it’s the origin
of IT Rage.
Table 30.6
The file creation functions of the File class. All functions require elevation.
Function
Description
Create
Creates or overwrites the file specified by the path parameter and 
returns a FileStream
CreateText
Creates or overwrites the file specified by the path parameter and 
returns a StreamWriter
Listing 30.13
Creating a file
File exists?
Create

785
Working with individual files
        writer.Write(newContents);
        writer.Flush();
        writer.Close();
      }
    }
    MessageBox.Show("File created");
  }
  else
  {
    MessageBox.Show("File already exists");
  }
}
Listing 30.13 takes the text from the ContentsEntry TextBox and writes it to the file
specified by the FileNameEntry TextBox. You use a StreamWriter to write text out to
the file. Once it’s written, you display a message to the user. You also flush and close
the StreamWriter, in addition to enclosing it and the FileStream in using state-
ments.
 The File.Create method will overwrite an existing file, so you put in a check
using the File.Exists method. If the file exists, you don’t allow overwriting it. A bet-
ter choice is to provide a prompt asking users if they wish to overwrite it. In either
case, you’ll use the Exists method to help make that determination.
 The Create methods are appropriate for the first time you save to a file, but they
aren’t appropriate for subsequent writes, even when you intend to resave the entire
contents of the file. For subsequent writes, you’ll want to use one of the file writing
functions.
30.3.2 Writing to a file
The majority of I/O for applications comes in the form of reading data (files, data-
base, and so forth). At some point, though, someone has to write that data to disk. 
 There are two main approaches to writing data to files:
■
Overwriting and/or creating the file and writing to it
■
Appending to an existing file
In the previous section, I covered part of the first option. That’s often the most appro-
priate approach for files that will fit in memory as a whole and that can be overwritten
each time—for example, a document you alone are working on. The second
approach is more appropriate for files to which new data is always added at the end—
for example, a log file. You also wouldn’t want to waste time opening a file stream to a
log file and then seeking all the way to the end just to write an entry; that would be
extremely wasteful of I/O.
 In this section, you’ll look at the appending approach. The overwriting approach
is straightforward and similar to the create functions covered in the last section. For
completeness, table 30.7 lists all of the functions that cover both scenarios, as well as
the generic Open function that may be used for both reading and writing.

786
CHAPTER 30
Working with files and directories
One subtle difference between the write functions covered here and the create func-
tions from the previous section is how the file create date is handled. Although ulti-
mately the OS decides how to set the file creation date, using the create methods will
typically reset it to the current date/time whereas the write methods, when used on an
existing file, will preserve the original file creation date. This is an important piece of
metadata to respect because it can be used by archival programs. There are other bits
of metadata that are also affected in the same way, as you’ll see shortly.
 Listing 30.14 shows how to append text to an existing file using the AppendAllText
method.
private void AppendToFile_Click(object sender, RoutedEventArgs e)
{
  string fileName = FileNameEntry.Text.Trim();
  string newContents = ContentsEntry.Text.Trim();
  if (File.Exists(fileName))
  {
    File.AppendAllText(fileName,              
        Environment.NewLine + "New entry from " + 
        DateTime.Now.ToString() + Environment.NewLine);
    File.AppendAllText(fileName, "====================" +
        Environment.NewLine);
    File.AppendAllText(fileName, newContents);
Table 30.7
The writing and file Open functions of the File class. All functions require elevation.
Function
Description
AppendAllLines
Appends to an existing file lines of text contained in an 
IEnumerable<string>, then closes the file. Each item becomes a sepa-
rate line. If the file doesn’t exist, this will throw a FileNotFound exception.
AppendAllText
Appends to a specified file the text contained in a string, then closes the file. 
If the file doesn’t exist, the file will be created.
AppendText
Opens an existing file and returns a StreamWriter, which may be used to 
write to it.
Open
Opens a file, specified by the path, using the FileMode, FileAccess, and 
FileShare properties optionally supplied by the caller. This is a general pur-
pose file opening method, which returns a FileStream.
OpenWrite
Opens an existing file for writing and returns a FileStream. The file must 
exist or the method will throw a FileNotFound exception.
WriteAllBytes
Creates a new or overwrites an existing file and writes the contents of a byte 
array to the file.
WriteAllLines
Creates a new file or overwrites an existing file and writes text contained in an 
IEnumerable<string> to the file. Each item becomes a separate line.
WriteAllText
Creates a new file or overwrites an existing file and writes the text contained 
in a string variable to the file.
Listing 30.14
Appending text to an existing file
AppendAllText

787
Working with individual files
    MessageBox.Show("File appended");
  }
  else
  {
    MessageBox.Show("File does not exist");
  }
}
The example shows how to append a few entries to an existing file, using a logfile-type
approach. You first check to see whether the file exists. If it exists, you write out a New
Entry marker, which includes the current date and time; next, a separator; and finally,
the contents from the ContentsEntry TextBox. You used Environment.NewLine to
separate the lines and guarantee that, regardless of platform, you had the right new-
line selected.
 The File class supports a large number of file writing operations, each made to
support slightly different scenarios. In truth, they boil down to overwriting or append-
ing. Beyond that, it’s all just sugar to make it easier for you to accomplish that task.
 Next, you’ll pull the file contents back into the application so you can view it with-
out cracking open Notepad.
30.3.3 Reading from a file
So far, you’ve written a bunch of data but haven’t yet brought it back into the applica-
tion to see what a spectacular job your code has done. This is in contrast to most appli-
cations, which spend almost all of their I/O cycles reading data versus writing it.
 Files are written in either text or binary mode. Although you can certainly open a
text file using binary functions (that’s what the OS does), it’s much easier to use text-
optimized functions, which work well with strings or collections of strings. That’s what
you’ll do here because you’ve been working with text in the previous examples. Keep
in mind that Silverlight isn’t limited to writing text files—if you want to store binary
data like an image or a media file, you’re able to do that.
 Table 30.8 lists the functions available for reading data from an existing file. In all
cases, the file must exist or the method will throw a FileNotFoundException.
Table 30.8
The Read functions of the File class. All functions require elevation. 
Function
Description
OpenRead
Opens an existing file for reading and returns a FileStream object.
OpenText
Opens an existing UTF-8 text file for reading. 
ReadAllBytes
Opens an existing binary file, reads the contents into a byte array, then 
closes the file. The byte array is returned by the function.
ReadAllText
Opens an existing UTF-8 text file for reading, reads the contents into a 
string, and closes the file. The string is returned by the function. 
ReadLines
Opens an existing UTF-8 text file for reading, reads each line into an 
entry in an IEnumerable<string>, and closes the file. The 
IEnumerable is returned by the function.

788
CHAPTER 30
Working with files and directories
First, you’ll look at how to read from a text file using the simplest possible method:
ReadAllText.
private void ReadFromFile_Click(object sender, RoutedEventArgs e)
{
  string fileName = FileNameEntry.Text.Trim();
  if (File.Exists(fileName))
  {
    string oldContents = File.ReadAllText(fileName);  
    ExistingContents.Text = oldContents;
  }
  else
  {
    MessageBox.Show("File does not exist");
  }
}
Listing 30.15 shows how to read the contents of a text file. You can see that the code is
simple, as it should be. Functions like ReadAllText make it easy to pull the data from
the file without having to deal with streams or a bunch of other stuff. If all you want to
do is read all the text from the file into a string, this is the recommended approach.
 If you want to do more, you’ll need to use one of the other functions. Though not
super complicated, reading from a text file using the more basic OpenRead does take
additional steps.
private void ReadFromFile_Click(object sender, RoutedEventArgs e)
{
  string fileName = FileNameEntry.Text.Trim();
  if (File.Exists(fileName))
  {
    using (var stream = File.OpenRead(fileName))
    {
      using (var reader = new StreamReader(stream))
      {
        string oldContents = reader.ReadToEnd();
        ExistingContents.Text = oldContents;
        reader.Close();
      }
    }
  }
  else
  {
    MessageBox.Show("File does not exist");
  }
}
Listing 30.15
Reading from a text file using ReadAllText
Listing 30.16
Reading from a text file using OpenRead and a stream
ReadAllText

789
Working with individual files
Listing 30.16 performs exactly the same function as listing 30.15 but uses a more
explicit approach. When might you use code like this? In this version, you have access
to the stream, so if you need to seek or perform other stream operations, you’ll need
to use OpenRead or one of the similar functions.
 The Open functions can be loosely grouped into text and binary functions. Within
those, they differ in how much access you trade for convenience. At the top of the sim-
plicity curve, you have ReadAllText and ReadAllBytes. In general, if you can use
those functions, you should, because doing so will mean less code for you to test and
fewer opportunities for you to leave a file open accidentally.
 Earlier I mentioned that file creation sets important metadata. Let’s look at that next.
30.3.4 Getting and setting file metadata
Files, like directories, have metadata stored in the filesystem. This metadata includes
the date and time the file was created, as well as dates for the last write and last access.
Files also have an important bit of data known as attributes—flags set on files in the
filesystem. The functions for retrieving file metadata are listed in table 30.9.
Of the functions listed in table 30.9, all report on the file except for SetAttributes.
The SetAttributes functions let you set one of the flags on a file to, for example,
mark it as a hidden file or a temporary file. There are a large number of possible flags.
 Listing 30.17 shows how to retrieve the metadata, including the file timestamps as
well as the attributes the file is flagged with.
private void GetFileMetadata_Click(object sender, RoutedEventArgs e)
{
  string fileName = FileNameEntry.Text.Trim();
  if (File.Exists(fileName))
  {
    FileCreateDate.Text =                            
        File.GetCreationTime(fileName).ToString(); 
    FileLastAccessDate.Text =                        
Table 30.9
The metadata functions of the File class. All functions require elevation.
Function
Description
GetAttributes
Returns a flags enum with the file attributes, such as Read Only, Hidden, 
System, and more
GetCreationTime
Returns a DateTime with the creation timestamp in local time
GetLastAccessTime
Returns a DateTime with the last access timestamp in local time
GetLastWriteTime
Returns a DateTime with the creation timestamp in local time
SetAttributes
Enables an application to set the attributes for the specified file
Listing 30.17
Getting file metadata
Timestamps

790
CHAPTER 30
Working with files and directories
        File.GetLastAccessTime(fileName).ToString(); 
    FileLastWriteDate.Text =                         
        File.GetLastWriteTime(fileName).ToString();  
    FileAttributesDisplay.Text = string.Empty;   
                
    FileAttributes attributes = File.GetAttributes(fileName);
    if (attributes.HasFlag(FileAttributes.ReadOnly))
      FileAttributesDisplay.Text += "Read Only" + 
      Environment.NewLine;
    if (attributes.HasFlag(FileAttributes.System))
      FileAttributesDisplay.Text += "System" + 
      Environment.NewLine;
    if (attributes.HasFlag(FileAttributes.Archive))
      FileAttributesDisplay.Text += "Archive" + 
      Environment.NewLine;
        ...
  }
  else
  {
    MessageBox.Show("File does not exist");
  }
}
The code first gets the timestamp attributes—create, last access, and last write—and
then displays them on the screen. Next, it gets the FileAttributes flags enum using
the File.GetAttributes function. The enumeration includes all the possible attri-
butes, a few of which are included in this listing. The downloadable source has the
full set.
 You could combine all the HasFlag blocks and replace them with a single foreach
loop if you don’t care about the specific formatting of the attribute names or don’t need
to translate any attribute names to something more reader friendly. For example:
foreach (var flag in Enum.GetValues(typeof(FileAttributes)))
{
  if (attributes.HasFlag((FileAttributes)flag))
    FileAttributesDisplay.Text += flag.ToString() +
      Environment.NewLine;
}
Most applications won’t need to directly access the file metadata, unless they’re build-
ing a file explorer or a replacement for a file open/save dialog. Similarly, advanced
file management apps will need a number of file utility functions, but most typical
applications won’t. Nevertheless, for the apps that need them, they’re essential.
30.3.5 File utility functions
The File class contains four utility functions unrelated to reading or writing files.
These are pure file management functions. In every listing you’ve already used one
Timestamps
Attributes

791
Storing data in isolated storage 
of them: File.Exists. In addition to that, there are functions to copy, move, and
delete files.
Except for the Exists function, it’s rare to use these in a typical application. In addi-
tion, they are very straightforward to use.
 The File class contains a wealth of functions that run the gamut from creating
files, overwriting file contents, appending data, reading both text and binary data, and
pulling back metadata, as well as utility functions like copy and delete. For an applica-
tion that can be run in the required elevated trust mode (either in-browser or out),
these functions enable you to accomplish just about any file operation a traditional
desktop application could.
 Sometimes, though, you can’t run in elevated trust mode, or you can and you sim-
ply don’t want to have to worry about where you put the data files. In those cases, you
can turn to isolated storage—the only filesystem integration option available with the
first versions of Silverlight.
30.4
Storing data in isolated storage 
Even in the out-of-browser mode, Silverlight is technically a web-delivered browser-
based plug-in, so by default, it has the lowest of security privileges to ensure a safe
browsing experience for your users. This safety restriction introduces a number of
development challenges, such as working with data across browser sessions. Although
working with data across browser sessions may not be a problem if the data is stored
on a web server, it can be a problem if the data needs to be stored locally.
Isolated storage is a mechanism that allows you to preserve data across browser ses-
sions on a user’s machine. This storage area is tied to an individual user and helps you
overcome the 4 KB limitation of a cookie without taking on the burden of full filesys-
tem integration. Unlike a cookie, isolated storage lies outside of the browser cache—if
a user clears the browser history, the items within isolated storage will remain in place.
To access this storage area, you use the System.IO.IsolatedStorage namespace.
 The System.IO.IsolatedStorage namespace provides the functionality to work
with a user’s isolated storage area. This area can be accessed through the Isolated-
StorageFile class, which exposes two statically visible methods that retrieve an
Table 30.10
The utility functions of the File class. All functions require elevation.
Function
Description
Copy
Copies the specified file to the specified destination. Takes an optional bool to decide 
whether destination files are overwritten.
Delete
Deletes the specified file.
Exists
Returns true if the specified file exists.
Move
Moves the specified file to a new path and, optionally, a new filename.

792
CHAPTER 30
Working with files and directories
IsolatedStorageFile. These methods are GetUserStoreForApplication and Get-
UserStoreForSite. The GetUserStoreForApplication can be used to retrieve a
user’s isolated storage for a specific Silverlight application, defined by the full URL to
the XAP. The GetUserStoreForSite method gets a user’s isolated storage for an entire
domain. As you may have guessed, this method gives you the ability to share informa-
tion across multiple Silverlight applications. Here’s an example of retrieving an
IsolatedStorageFile:
IsolatedStorageFile isoFile = 
  IsolatedStorageFile.GetUserStoreForApplication();
This code gives you access to a user’s isolated storage area. Once you’ve retrieved an
IsolatedStorageFile, you can use it to manage a safe virtual filesystem, which gives
you the ability to read and write files and directories.
30.4.1 IsolatedStorageFile: the virtual filesystem
The IsolatedStorageFile class represents a virtual filesystem that a Silverlight appli-
cation can manage. Note the word virtual; outside of the elevated trust mode and all it
enables with the File and Directory classes seen so far in this chapter, you can’t
directly access the user’s local filesystem due to security constraints. As the previous
example showed, you can still access data related to the requesting Silverlight applica-
tion, but in reality, the term filesystem is a probably a stretch.
 The IsolatedStorageFile object represents a specific partition within the iso-
lated storage area. This partition is tied to both the user and the application. It’s easi-
est to think of this partition as a specific folder or directory. And like a regular
directory, the isolated storage area enables you to perform several operations, includ-
ing the ability to list the contents of a directory. This directory can have other files or
directories added to or removed from it, so you should probably keep track of the iso-
lated storage usage statistics to ensure you don’t run out of space. Fortunately, the
IsolatedStorageFile allows you to check these statistics and request more space if
you need it.
LISTING THE CONTENTS OF THE VIRTUAL FILESYSTEM
The IsolatedStorageFile class provides two methods that
enable you to retrieve the items within a storage area. The
first, GetDirectoryNames, enables you to retrieve the
names of the directories that match a certain pattern; the
GetFileNames method allows you to search for files that
match a particular filter. Figure 30.5 shows an example iso-
lated storage structure with files and directories.
 The depicted isolated storage area contains a number of
common filesystem items. For instance, there are three text
files, one XML file, and one subdirectory. With this hierarchical structure in mind,
let’s turn our focus to mastering the filtering string syntax used for searching the iso-
lated storage area.
Figure 30.5
An 
illustration of a potential 
isolated storage area

793
Storing data in isolated storage 
 The first and most verbose approach involves searching for a specifically named
item. This approach works with both the GetDirectoryNames and GetFileNames
methods. To perform the search, you provide the exact path to the file or directory. If
the filename or directory is found, a string array with one element will be returned.
Otherwise, an empty result set will be returned. Both approaches are shown here:
string[] directory1 = isoFile.GetDirectoryNames("Directory1");
string[] noDirFound = isoFile.GetDirectoryNames("Directory2");
string[] testfile1 = isoFile.GetFileNames("testfile1.txt");
string[] noFileFound = isoFile.GetFileNames("testfile2.txt");
string[] nestedFile = isoFile.GetFileNames("Directory1/file1.txt");
Similarly, wildcard characters may be used to pattern-match filenames. Following nor-
mal Windows operating system rules, the * character matches any number of charac-
ters, and the ? character matches any single character:
string[] results1 = isoFile.GetFileNames("*");                
string[] results2 = isoFile.GetFileNames("Directory1/*");
string[] results3 = isoFile.GetFileNames("textfile*");
string[] results4 = isoFile.GetFileNames("*.txt");
The * and ? wildcard characters are applicable within the GetDirectoryNames
method as well. Once you have the file you’re looking for, you can open it and work
on it just like you would any other file, including deleting it.
REMOVING ITEMS FROM ISOLATED STORAGE
The IsolatedStorageFile class exposes two utility methods that enable you to
remove items from the storage area. The first method, DeleteDirectory, is used to
remove a directory from the isolated storage area. The second method, DeleteFile,
similarly allows you to remove a file. The usage of the DeleteFile method is illus-
trated here:
soFile.DeleteFile("testfile1.txt");
isoFile.DeleteFile("Directory1/file1.txt");
As this example shows, you must explicitly provide the absolute path to the file you
want to delete. If you provide an invalid path, an IsolatedStorageException will be
thrown. This same exception will be thrown if you attempt to remove a directory that
isn’t empty. Other than that, the syntax is the same when using the DeleteDirectory
method. But before you can delete a directory, it needs to be created.
CREATING DIRECTORIES WITHIN ISOLATED STORAGE
The IsolatedStorageFile class exposes a method called CreateDirectory that
enables you to create a directory within the isolated storage space. There isn’t any-
thing too shocking about the syntax associated with this method—to create a direc-
tory, you state the name of the folder:
isoFile.CreateDirectory("Directory1");

794
CHAPTER 30
Working with files and directories
In addition to creating directories at the root of the isolated storage area, the Create-
Directory method enables you to create subdirectories. To do this, you use a URL-
style syntax that uses forward slashes as separators: 
isoFile.CreateDirectory("Directory1/SubDirectory1");
isoFile.CreateDirectory("Directory1/Sub2/Leaf");
The first line of code is simple; it creates a subdirectory under an existing directory.
The second line of code shows an additional feature. If you provide an absolute path
to a subdirectory further down the line, all missing directories along the way will auto-
matically be added. Once a directory exists, you can add files to it. I’ll discuss adding
files later in this section. But first, let’s make sure there’s space for a new file.
CHECKING THE AVAILABLE SPACE
The IsolatedStorageFile class exposes two read-only properties that inform you of
an isolated storage area’s memory situation. The first property, Quota, holds the total
number of bytes allocated to the storage area. The other property, Available-
FreeSpace, represents the number of bytes remaining in the storage area. 
 By default, the Quota property value is set to 1MB by default or, as reported by the
Quota property, 1,048,576 bytes. But you have the option to ask the user for more
space should your application need it.
REQUESTING MORE SPACE
The IsolatedStorageFile class enables the application to ask the user for more stor-
age space. This request can be made by calling the IncreaseQuotaTo method, which
accepts a long parameter that represents the new quota size you want. This size signals
the total number of bytes you want to allocate to the isolated storage area; it doesn’t rep-
resent the number of bytes by which you want to increase the storage. For example: 
IsolatedStorageFile isoFile = 
  IsolatedStorageFile.GetUserStoreForApplication();
long newQuotaSize = isoFile.Quota * 2;
bool requestAccepted = isoFile.IncreaseQuotaTo(newQuotaSize);
This example shows how to request more space for an application from a user. You
also have the option of asking for more storage for a domain if you retrieve the
IsolatedStorageFile through the GetUserStoreForSite method. Either way, the
IncreaseQuotaTo method can only be called from a user-initiated event such as a but-
ton click. Once this request is made, the dialog box shown in figure 30.6 will be dis-
played to the user.
Figure 30.6
The quota increase confirmation 
dialog box

795
Storing data in isolated storage 
This dialog box displays the name of the website requesting the new quota. In addi-
tion, it shows how much space is currently being used and the quota size being
requested. The user’s accept or deny decision will be returned from the Increase-
QuotaTo method in the form of a bool.
 The IsolatedStorageFile represents a virtual filesystem giving you the flexibility
to create, navigate, and remove items from within it. To make sure that you have space
to create items, you may need to check the AvailableFreeSpace property, which rep-
resents the number of bytes available within the allocated storage Quota. If you need
more space, you can request it using the IncreaseQuotaTo method. Requesting more
space can come in handy as you read and write files. 
30.4.2 Reading and writing files: the isolated storage way
Files stored within the isolated storage area can be created and retrieved through a
file stream. This file I/O task is like any other in the .NET Framework, but because
you’re working within a special area that provides additional security features, you
must use a specific type of file stream. This particular type of file stream is appropri-
ately named IsolatedStorageFileStream.
 The IsolatedStorageFileStream object provides in-memory access to a file
stored within the isolated storage area. With an instance of this class, you can create,
update, and read a file from the isolated storage area. Because a file must exist before
you can read it, it makes sense to first discuss how to create and update files within iso-
lated storage.
ISOLATED FILE CREATION
Creating a file within a user’s isolated storage area is a simple process. This process
hinges on the System.IO.StreamWriter object. Just as you did with regular filesystem
files, you can use a StreamWriter to write content into a file stored within isolated
storage. 
using (IsolatedStorageFile isoFile =
  IsolatedStorageFile.GetUserStoreForApplication())
{                
  using (IsolatedStorageFileStream stream = 
         new IsolatedStorageFileStream(
             "file1.txt", FileMode.Create, isoFile))
  {
    using (StreamWriter writer = new StreamWriter(stream))  
    {   
      writer.Write("Hello, from the isolated storage area!");
      writer.Flush();
      writer.Close();
    }
  }
}
Listing 30.18
Creating a text file within a user’s isolated storage area
Create file

796
CHAPTER 30
Working with files and directories
Listing 30.18 shows how easily you can write a text file into the isolated storage area.
The first step is to retrieve a user’s isolated storage area. Next, you create an
IsolatedStorageFileStream that represents a file within isolated storage. The con-
tents of this file are created using a StreamWriter. This StreamWriter gives you the
flexibility to write either binary data or plain text. This is important to recognize
because the contents of an isolated storage area aren’t encrypted automatically.
Because of this, you may want to manually encrypt your data when writing it to a file.
 You may have noticed the use of the FileMode enumeration. This value determines
how the file will be opened. In all, there are six different ways to open a file encom-
passing the operations from Create to Append to Open, just as you had with the File
operations in the regular filesystem.
READING AN ISOLATED FILE
The process of reading a file from a user’s isolated storage area is similar to writing to
a file. Instead of taking advantage of a StreamWriter, you use a StreamReader. The
process of using a StreamReader to read a file is shown in listing 30.19.
using (IsolatedStorageFile isoFile =
  IsolatedStorageFile.GetUserStoreForApplication())
{
  using (IsolatedStorageFileStream stream = 
    new IsolatedStorageFileStream("file1.txt", FileMode.Open, isoFile))   
  {
    using (StreamReader writer = new StreamReader(stream))
    { 
      myTextBlock.Text = writer.ReadToEnd();
      writer.Flush();
      writer.Close();
    }
  }
}
As the listing shows, reading a file is almost identical to creating a file. The first step
involves retrieving the user’s isolated storage area. Then, you create an Isolated-
StorageFileStream object—this time using the FileMode.Open option. Once the file
is opened, you can read through it using a StreamReader.
 Both the StreamReader and StreamWriter classes provide a lot of features for
working with character-based and binary input and output in isolated storage, just as
they did for the traditional filesystem. Given the similarities in file operations, if you
understand one filesystem you’ll be quickly comfortable with the other.
 Isolated storage is a great way to store temporary or noncritical data on the end
user’s local machine. It’s flexible in that it works in all modes of Silverlight operation
(in-browser, out-of-browser, elevated out-of-browser) and works as a virtual filesystem.  
Listing 30.19
Reading a file from the user’s isolated storage area

797
Summary
30.5
Summary
File manipulation, especially opening and saving files, is an incredibly important fea-
ture of most applications you use. In the early releases of Silverlight you were
restricted to file dialogs and isolated storage. Both were useful and continue to be
used by many applications, especially those that run in partial trust mode. But as appli-
cations become more complex, you have to have richer file access options.
 When writing a chapter, the last two sections I write are the introduction and the
summary, in that order. As I type this summary, Microsoft Word is busy saving snap-
shots of my progress to a temporary file. If I didn’t have a nervous Ctrl-S twitch, that
might be the only saving of my work that happens in an hour or so, and it happens
without user intervention. 
 With elevated trust mode and the Directory and File classes, Silverlight now sup-
ports the same type of UI-less file manipulation. If you want to save a file in the back-
ground, you can. If you want to keep saving a file using a normal File > Save menu,
without displaying a dialog each time, you can. If you want to wipe out swathes of the
user’s machine because they happen to be running as a local admin, yes, you can do
that too, but we won’t talk about that.
 Regardless of the trust level you can support with your application, Silverlight has
an approach to storing information on the local machine in a way that’s consistent
with the security model and the expectations of the user.
 In the next chapter you’ll bring your files out of the computer and into the physi-
cal world, by printing information on paper—another essential feature that few apps
can do without.

798
Printing
The support for binding and validation, WCF RIA Services, and out-of-browser
trusted applications are all major factors in making Silverlight useful for business
application development. But most business, even today, run on a serious amount
of paper. In those places, a development platform simply can’t be used unless it has
good support for printing. 
 Many business applications need to print paper forms and reports as a standard
part of their process. Large-scale applications typically farm out that functionality
to a server somewhere with centralized print systems. I’ve seen systems like this that
require a whole dedicated print room, with printing, paper folding, and envelope
stuffing machines all combined. Most other applications, especially those used in
smaller businesses, departmental applications, and consumer applications, use
printers directly mapped and available on the client workstation. For those applica-
tions, platform support for printing is essential.
This chapter covers
■
Understanding the printing API
■
Printing onscreen content
■
Scaling content for print
■
Getting data from a service for a report
■
Creating headers, footers, and more

799
How Silverlight printing works
 Printing support opens up other nonbusiness scenarios as well. Now you can make
that coloring-book creator or papercraft application you’ve had in your “cool app
ideas” folder. I joke about printing being a holdover from the dark ages,1 but I used to
print directions before I had a GPS receiver, and flight information before it was syn-
chronized to my phone via Microsoft Exchange. There are still many interesting and
legitimate uses of printing inside and outside of business.
 In our tour of printing, you’ll take a look under the hood to understand how print-
ing works in Silverlight, then handle the use case of printing onscreen content. From
there, you’ll explore considerations that come into play when building multipage doc-
uments. Wrapping up, I’ll show you an example of a simple report writer with head-
ers, footers, and items rows.
31.1
How Silverlight printing works
When designing the printing system, the Silverlight team wanted something that
would work with all current onscreen visuals while not adding a large feature payload
to the overall runtime. Team members also wanted something that would work cross-
platform and be available in all modes of operation: in-browser, out-of-browser trusted
applications, and out-of-browser sandboxed applications.
 There are two modes of printing: PostScript vector printing and bitmap printing.
The former is new to Silverlight whereas the latter was available starting with Silver-
light 4. Which mode is used depends on the contents you’re printing and the capabil-
ities of your printer and printer driver. For those reasons, the printing process
resembles the overall screen layout process (see chapter 7), with additional printing-
specific steps tagged on. Figure 31.1 shows the printing process at a high level.
1 Don’t get me started on faxing. Really don’t get me started on people who send an email requesting you fax
them something. And absolutely positively don’t get me started on people who email you a document, tell you
to print it, sign it, and fax it back to them. Hand me my parchment and feather pen.
No
Print
BeginPrint
Event
EndPrint
Event
PrintPage
Event
Set
PageVisual
Layout
Rasterize
Send to 
Printer 
Driver
More 
Pages?
Yes
Visual Tree
Convert to
PostScript
Figure 31.1
The printing process at a high level. User code may be run inside the 
BeginPrint, PrintPage, and EndPrint events.

800
CHAPTER 31
Printing
The printing process starts by creating a PrintDocument object and calling its Print
method. The PrintDocument then raises the BeginPrint event if there are any listen-
ers. Your own startup code can run inside that event handler. Then, for each page to
be printed, the PrintDocument raises the PrintPage event. Inside the handler for that
event, you’ll set the page visual and tell Silverlight if there are any more pages. The
printing system then lays out the content and, if necessary, rasterizes it into a bitmap
at the print resolution (typically 600dpi, but it varies) to send to the printer driver. If
the content doesn’t require rasterization, and a PostScript-compatible printer driver
was selected, it converts to PostScript vectors and sends that to the driver. Note that
the two aren’t mutually exclusive—bitmaps can be included in the PostScript stream.
 Note that in all cases, if your printer doesn’t support PostScript, you’ll get an
uncompressed bitmap sent to the printer. At higher resolutions, such as 600dpi or
1200dpi, that means you’ll get a lot of bits sent across the wire, and the pages will take
a fairly long time to print, or in the case of printers with little memory, simply not
print at all. The good news is that most printers have PostScript drivers available. The
bad news is, they’re almost never installed by default except for the drivers that come
with big office workhorse printers.
Once that page is sent to the printer driver, Silverlight raises the PrintPage event if
you’ve indicated that there are more pages, or raises the EndPrint event if not. Dur-
ing this process, the primary object you’re interacting with, the object raising the
three mentioned events, is the PrintDocument class.
 In the remainder of this section, I’ll start with the PrintDocument class, covering its
properties, methods, and events. In detail, I’ll cover the PrintPage event and the
actions you take within it. After that, I’ll take a deeper look at the rasterization step
and how that affects the process
Why PostScript?
The Silverlight team picked PostScript for a few reasons. The first is that it’s supported
cross-platform, having excellent support on the Mac and good support even on older
versions of Windows like XP and Vista. The team considered going the XPS route (pi-
oneered with WPF), but that’s a huge chunk of code that would’ve bloated the Silverlight
runtime beyond an acceptable size, especially if they had to add additional ports to
XP and Mac (those don’t currently support XPS). The team also considered going the
GDI route like Windows Forms, but that’s considered a legacy technology and has no
cross-platform support.
In the end, PostScript is a natural fit for vector printing and requires only one imple-
mentation, rather than the multiple approaches that would’ve been required for inter-
facing with various other printer data schemes.
Remember, PostScript isn’t required for printing (printing still works in bitmap mode);
you’ll just have a better printing experience if you have support for it.
It’s worth noting that Adobe Flash and Flex took a similar route, sending PostScript
when it can and bitmaps when it can’t.

801
How Silverlight printing works
31.1.1 The PrintDocument class
The heart of printing in Silverlight is the PrintDocument class, located in the System
.Windows.Printing namespace. The PrintDocument class includes the single Print
method required to kick off the process, a helper property to provide access to the
page count, and three important events raised at different points in the process. Table
31.1 describes each of these members.
In the remainder of this section, I’ll look at these properties, methods, and events in
more detail, starting with the Print method.
PRINT METHOD
The first step after instantiating the PrintDocument class is to call the Print (or
PrintBitmap) method. The Print method takes in a parameter specifying the name
of your document. This document name is what shows up in the OS print spooler. The
name should be descriptive, containing the title of your report or document. If your
application plans to print many of these, you may want to add an identifier such as the
patient’s name in the case of a medical report, or perhaps some criteria used to gener-
ate the report. Listing 31.1 shows how to use the Print method.
XAML:
<Grid x:Name="LayoutRoot" Background="White">
  <Button x:Name="Print" Content="Print" 
          Width="100" Height="30" 
          Click="Print_Click"/>           
</Grid>
Table 31.1
PrintDocument members
Member
Description
Print method 
Displays the Printer dialog and, if accepted, raises the 
BeginPrint event followed by the PrintPage event to begin the 
printing process. There’s an overloaded version of this method that 
accepts a PrinterFallbackSettings instance.
PrintBitmap method
Just like the Print method, but prints as a bitmap. If the printer 
and driver support PostScript, a compressed bitmap is sent; other-
wise an uncompressed bitmap is sent.
PrintedPageCount property 
A dependency property containing the total number of pages printed.
BeginPrint and EndPrint
events
Events fired at the beginning and ending of the print job, respectively.
PrintPage event
The most important event. This is the event that enables you to build 
and print a single page.
Listing 31.1
Using the Print method and specifying a document name
TextBlock 
will go here

802
CHAPTER 31
Printing
C#:
private PrintDocument _document;
public MainPage()
{
  InitializeComponent();
  Loaded += new RoutedEventHandler(MainPage_Loaded);
}
void MainPage_Loaded(object sender, RoutedEventArgs e)
{
  _document = new PrintDocument();                  
}
private void Print_Click(object sender, RoutedEventArgs e)
{
  PrintForm("Brown, Pete");
}
private void PrintForm(string patientName)
{
                                                      
  _document.Print("Admittance form for " + patientName);
}
The example doesn’t do anything meaningful yet—it doesn’t print anything. You’ll
use this as the base for the rest of the examples centered around PrintDocument. Spe-
cifically, the placeholders for the TextBlock and the event wire-up will be filled out in
later examples.
 As written, the code is fairly simple. It sets up the required PrintDocument class
instance and calls the Print method. The Print method is asynchronous: it immedi-
ately returns once you call it. But it raises all of its events back on the calling thread, so
the UI thread can still be blocked.
 Note that in untrusted applications, the Print method must be called from a user-
initiated event, such as a button click event. Trusted out-of-browser applications (see
chapter 5) eliminate this restriction. Once you wire up the PrintPage event (coming
up shortly), you’ll see that the print spool entry document name will contain the value
passed into the Print method. Figure 31.2 shows the Windows 7 print spooler with a
Silverlight print document spooled.
Create 
PrintDocument
Event wire-up 
will go here
Figure 31.2
The Windows 7 print spooler showing the Silverlight document titled “Admittance form 
for Brown, Pete,” created in listing 31.1.

803
How Silverlight printing works
The PrintDocument supports multipage printing. While printing, you’ll find it useful
to get the current number of pages that have been printed, in order to report the
print status to your user. The PrintedPageCount property provides you with this
information. 
PRINTEDPAGECOUNT PROPERTY
The PrintedPageCount property contains the number of pages sent to the print
driver. This doesn’t necessarily correspond to the number of pages physically printed,
because printers are typically much slower than the PC they’re attached to. But it’s use-
ful as a general way of reporting status to the user. 
PrintedPageCount is a read-only dependency property, so you can bind to that in
XAML. Continuing from the example in listing 31.1, you can modify the code and
XAML as shown in listing 31.2 to support this. Add the TextBlock in the XAML to the
spot reserved with the comment.
XAML:
<TextBlock x:Name="PrintStatus"
           HorizontalAlignment="Center"
           VerticalAlignment="Bottom"
           Text="{Binding PrintedPageCount}"       
           FontSize="40" />
C#:
void MainPage_Loaded(object sender, RoutedEventArgs e)
{
  _document = new PrintDocument();
  PrintStatus.DataContext = _document;              
}
Now when you print a multipage document, the status text will display the number of
pages that have been printed so far. This is similar to what you see when you print a
document in Microsoft Word, where a status dialog appears with a number showing
the progress.
TIP
The PrintedPageCount property is incremented after the PrintPage
event returns. Any check you do after setting the PageVisual will need to take
into account that the PrintedPageCount hasn’t yet been incremented.
In addition to the PrintedPageCount property, two other events can be used for status
reporting, as well as for startup and shutdown code: BeginPrint and EndPrint.
THE BEGINPRINT AND ENDPRINT EVENTS
The BeginPrint and EndPrint events are raised at the beginning and end of the print
job, respectively. Specifically, BeginPrint is raised before the first call to the Print-
Page event but after the printer dialog is shown, and EndPrint is raised after the last
call to EndPrint completes or if the user cancels printing in-progress.
Listing 31.2
Showing the number of pages printed
Binding statement
TextBlock 
DataContext

804
CHAPTER 31
Printing
 If the user cancels printing from the printer selection dialog, neither BeginPrint
nor EndPrint will be raised. Similarly, if Silverlight can’t print due to issues with paper
format or memory allocation, BeginPrint may not be called.
 Continuing our example, the following code shows how to wire up the two events.
You won’t do anything with BeginPrint in this example, but you’ll show a message
box when completed using the EndPrint event handler. The event handlers should be
inserted into the listing 31.1 code, in the PrintForm method, where the event wire-up
comment is located:
_document.BeginPrint += (s, e) =>
    {
    };
_document.EndPrint += (s, e) => 
  {
    MessageBox.Show("Print job completed.");
  };
The BeginPrint and EndPrint methods may be used for status reporting or for doing
document buildup and teardown. Unlike the PrintPage event, their event arguments
don’t contain any actionable information. It’s not essential to wire them up, but you’ll
find that a complete printing solution typically requires one or both of them. 
 One event that’s not optional is the PrintPage event.  
31.1.2 The PrintPage Event
The PrintPage event is the heart of the user-code side of the printing system in Silver-
light. This is where you’ll obtain key layout information from the system and use it to
create or otherwise lay out the visuals you use to represent the page. It’s also the event
where the assignment of the printer page root visual occurs, and the event where the
decision is made as to how many pages the print document will contain.
 For each page that will be printed, the PrintDocument class raises the PrintPage
event. The PrintPage event passes in an instance of the PrintPageEventArgs class,
specific to that page. Table 31.2 shows the properties of the class.
Table 31.2
PrintPageEventArgs members
Member
Description
PageMargins property 
Gets the margins of the page as set by the printer driver 
settings. Represented at 96dpi.
PrintableArea property 
The size (width and height) of the printable area inside the 
margins of the page. This is represented at 96dpi.
HasMorePages property 
Set to true if there are additional pages after this one.
PageVisual property 
Set this to the root element (typically a panel) that makes 
up the page content.

805
How Silverlight printing works
I’ll cover each of the properties next, starting with the properties that report the size
of the area you can use for content: PageMargins and PrintableArea.
PAGEMARGINS AND PRINTABLEAREA PROPERTIES
The PageMargins property is a standard Thickness property like those used for mar-
gins throughout the rest of Silverlight. It reports the size of the margins set in the
printer configuration dialogs in your system.
 The PrintableArea property is a Size property that indicates the width and height
of the area within the margins. This is the area in which you can lay out your content.
 It’s important to note that the PageMargins and PrintableArea measurements are
all provided at 96dpi, consistent with screen layout . My printer handles resolutions up
to 1200dpi (normally set to 600dpi). Despite that, the printable page area comes
through at 784 x 1024 and the margins come through at 16,16,16,16. Add 32 (right
and left margin) to 784 and divide by 96, and you get 8 1/2 inches. Do the same for
the height and you get 11 inches. 8 1/2 x 11 inches is, in the United States, the size of
a standard sheet of letter-sized paper. The print quality itself is better than that but still
not as good as what you may be used to.
NOTE
Silverlight when printing in raster mode is currently limited to printing
documents sized at A3 or smaller. Large-format pages may work in certain sit-
uations but aren’t supported. For reasons why, see the section on rasterization.
Similarly, if you print using the Microsoft XPS Document print driver (a great test
driver), you’ll see that it has no enforced margins and therefore provides a size of 816
x 1056.
 If the content you have won’t fit on a single page, Silverlight will clip it to the
dimensions specified in PrintableArea. In those cases, you may want to handle man-
ually clipping and saving the remaining elements for the next page. To indicate addi-
tional pages, use the HasMorePages property.
HASMOREPAGES PROPERTY
Printed documents may consist of more than one page. But without precalculating all
the page content (not a bad idea but not required), you won’t know the number of
pages until you’re done printing. Similarly, you don’t necessarily know if a page is the
last page until you try to fit all the content into the printable area and see what fits.
 For those reasons, the PrintPage event includes the Boolean HasMorePages prop-
erty. Simply assign true to this property to indicate that the current page isn’t the last
page to be printed. This will cause Silverlight to raise another PrintPage event upon
the completion of the current one. When you have no more pages to print, set Has-
MorePages to false (the default value) to end printing. The following code expands
on listing 31.1 to do a simple check against a hard-coded number of pages. You use -1
because the PrintedPageCount is incremented after the PrintPage event returns:
int numberOfPages = 5;
_document.PrintPage += (s, e) =>
  {

806
CHAPTER 31
Printing
    Debug.WriteLine("Printing page");
    e.PageVisual = LayoutRoot;
    e.HasMorePages = 
        _document.PrintedPageCount < numberOfPages - 1;
  };
Note also that you’re effectively doing a print-screen in this example by passing the
LayoutRoot in as the PageVisual to be printed. I’ll discuss PageVisual in detail in a
moment.
 You can also allow the user to cancel printing by setting HasMorePages to false
when the user clicks a cancel button. Doing so will terminate printing after the cur-
rent page. To do that, you’ll need to set a flag in your class and have your code in the
print method check for this flag. Additionally, if you know the user has clicked cancel
before you set the PageVisual, you can both skip setting the PageVisual and set Has-
MorePages to false to avoid printing the current page and any subsequent pages.
PAGEVISUAL PROPERTY
The PageVisual property is the property you use to assign the root element of your
page. Think of your root element like LayoutRoot on a typical Silverlight page. This
will usually be a panel of some sort, but any UIElement will work.
 Before assigning the element to the PageVisual property, you need to ensure that
it has all of its children in place. When PageVisual is set, it’s then measured and laid
out. Because it’s not part of the proper Silverlight visual tree, adding elements to the
visual doesn’t cause an automatic measure and layout pass (see chapter 7 for more
information on measuring and layout). You can either manually force a measure and
layout, or simply populate the visual completely prior to assigning it to the Page-
Visual property.
 Figure 31.3 shows the result of adding child elements after assigning the PageVisual.
 When assigning the PageVisual, keep in mind that any content outside the rectan-
gle defined by the PrintableArea will be clipped. If you need to fit more content on
the page, you can apply a scale transform to shrink the content down by a ratio that
will fit it all on the page.
 I’ll discuss setting the PageVisual when I look at some specific printing use cases
in sections 31.2 and 31.3.
 Once the PageVisual is set and the PrintPage event returns, Silverlight prepares
the page for printing by first calling Measure and Arrange (the layout pass described
in chapter 7 and rasterizing it to a single bitmap representing the page. 
Figure 31.3
The result of assigning the page visual prior to adding child 
elements to a part of the visual. Layout doesn’t happen automatically, so 
all the elements are stacked on top of each other.

807
How Silverlight printing works
31.1.3 Converting to PostScript
By default, if you have a PostScript-compatible printer and driver, Silverlight will attempt
to convert the visuals to PostScript format. PostScript is a printer format pioneered by
Adobe that enjoys broad cross-platform support and is especially popular on the Mac.
 The benefits of PostScript for printers are similar to those for XAML in Silverlight:
you can send vectors that will scale as high as the destination DPI, regardless of the
source DPI, and the payload for a page is typically much smaller than a bitmap version
of that page. Of course, PostScript requires more processing by the driver or the
printer itself in the case of PostScript-capable printers.
 The conversion process is straightforward. Silverlight takes the visual tree and
translates it to its PostScript equivalent. The languages are different, but the concepts
are the same. There’s no dependency on PostScript-compatible fonts, so you don’t
need to use special PostScript fonts or anything.
 Not everything can be converted to vector format. In those instances, Silverlight
will rasterize the elements to a bitmap format.
31.1.4 Rasterization
In chapter 7, we discussed the rendering process for onscreen elements. One step of
that process was the rasterization of vector and text elements, and the included blit-
ting of raster (bitmap) elements. Bitmap-mode printing follows the same general pro-
cess, down to the rasterization step.
 When you print a tree of elements by assigning it as the page visual and choose to
print in bitmap mode, or Silverlight determines they must be printed as a bitmap,
those elements are all rasterized into a page-sized bitmap (or larger if you overrun the
size of the page), clipped to the page dimensions, and sent to the printer. Table 31.3
shows the cases when rasterization is performed.
*There’s a way around this, which I’ll cover later in this chapter.
If you’re familiar with how printing normally works when using printer languages
such as PCL or PostScript, you may find the rasterization approach a little odd. In
typical document printing, the print driver sends a list of commands to the printer;
Table 31.3
Print format matrix
Content type
PostScript-compatible printer
Vector content with opacity of 1.0
PostScript vectors
Vector content with opacity less than 1.0
Compressed bitmap*
Vector content with basic render transforms 
(rotate, scale, skew, etc.)
PostScript vectors
Vector content with perspective transform
Compressed bitmap*
PNG or other image with other vector content
Compressed bitmap inside PostScript with 
other vectors

808
CHAPTER 31
Printing
those commands contain information such as drawing commands, raster images, font
and style specifications, and text commands. The end result is a smaller payload, and
the printer is free to optimize the printing for its own capabilities and resolution.
 The bitmap-based approach in Silverlight is flexible and functional across plat-
forms, and supports anything Silverlight can render onscreen. But it’s fairly time- and
memory-intensive. A Microsoft Word document with text and images prints fairly
quickly on my HP LaserJet 1320, taking just a few seconds between my hitting the Print
button and seeing output on the printer. A similar document printed through Silver-
light takes considerably longer on a non-PostScript printer because it’s treated as one
(approximately) 8 1/2 x 11 inch bitmap.
 For those reasons, I don’t consider the printing API in Silverlight to be a good
choice for large reporting solutions unless you have a PostScript-compatible printer.
You’ll be waiting quite a long time for a 50-page report to come off a non-PostScript
printer. The actual speed is as much a function of the printer hardware as anything, so
your own mileage may vary.
31.1.5 Forcing bitmap printing
Although there may be some disadvantages to bitmap-based printing, specifically
speed and memory usage, there are times when you know you’re going to want to
print bitmap format up front. Rather than have Silverlight analyze the content and
make a decision as to whether PostScript vectors or PostScript (and non-PostScript)
bitmap rasterization is appropriate, you can tell Silverlight to use bitmap printing.
 The only change you need to make to your code to support this is to change the
PrintDocument.Print call to PrintDocument.PrintBitmap. Once you do that, Silver-
light will skip the decision process and proceed right to rasterization.
 When run on a PostScript compatible printer, the pipeline will still send the bit-
map as a compressed bitmap wrapped in a PostScript message to the printer, so you’ll
see speed improvements over Silverlight 4 printing. Listing 31.3 shows how to use the
Document.PrintBitmap method to send a rasterized version of the content to the
printer.
private void PrintBitmap_Click(object sender, RoutedEventArgs e)
{
  PrintDocument doc = new PrintDocument();
  doc.PrintPage += (s, ea) =>
  {
    StackPanel printPanel = new StackPanel();
    Random rnd = new Random();
    for (int i = 0; i < 30; i++)
    {
      TextBlock row = new TextBlock();
      row.Opacity = (rnd.Next(3, 10)) / 10.0;       
      row.Text = "This is row " + i + ". Opacity is " + row.Opacity;
Listing 31.3
Forcing bitmap printing using the PrintBitmap method
Opacity

809
How Silverlight printing works
      printPanel.Children.Add(row);
    }
    ea.PageVisual = printPanel;
    ea.HasMorePages = false;
  };
  doc.PrintBitmap("Silverlight Bitmap Print");
}
Note that the example in listing 31.3 shows a page with rows of varying opacity. As you
learned earlier, opacity other than 1.0 will force you to use bitmap-based printing.
Because you know ahead of time that you’re going to be varying opacity, it makes
sense to force bitmap printing in this context.
 But what happens when you want to print that content but would rather Silverlight
just send vectors to the printer anyway? In those cases, you can force Silverlight to
print in vector mode, at the expense of the opacity and some transforms.
31.1.6 Forcing vector printing
As shown in the previous sections, there are scenarios where the printer supports Post-
Script but the content is such that it requires rasterization to a bitmap. It may be that
you don’t want rasterization but would rather the printer receive PostScript vectors. 
 Luckily, the Silverlight team has provided a way for you to set fallback options to tell
the printing system how you’d like the elements converted. This is provided through the
PrinterFallbackSettings class and an overload of the Document.Print method.
 The PrinterFallbackSettings class has two properties of interest: ForceVector
and OpacityThreshold. The first property is required, and the second is optional. In
addition, OpacityThreshold has no effect unless ForceVector is set to true.
ForceVector, when set to true, tells Silverlight that you want to print vectors, with-
out any rasterization of the page. Any opacity or unsupported transforms will be lost.
Perspective transforms will simply be ignored. In the case of opacity, the Opacity-
Threshold setting controls how it’s treated.
OpacityThreshold sets the cutoff for treating opacity as 1.0. For example, if opac-
ity is set to 0.5, anything over that will automatically be treated as 1.0 and show at full
opacity; anything under it will be converted to 0.0 and not displayed in the output.
 Listing 31.4 shows how to use the PrinterFallbackSettings class to force vector
printing on a PostScript-compatible driver/printer combination and set the Opacity-
Threshold. Keep in mind that if you don’t have a PostScript-compatible printer, Silver-
light will fall back to bitmap mode and the OpacityThreshold will have no effect.
private void PrintVectorForced_Click(object sender, RoutedEventArgs e)
{
  PrintDocument doc = new PrintDocument();
  doc.PrintPage += (s, ea) =>
  {
Listing 31.4
Ensuring vector printing with PrinterFallbackSettings

810
CHAPTER 31
Printing
    StackPanel printPanel = new StackPanel();
    Random rnd = new Random();
    for (int i = 0; i < 30; i++)
    {
      TextBlock row = new TextBlock();
      row.Opacity = (rnd.Next(3, 10)) / 10.0;       
      row.Text = "This is row " + i + ". Opacity is " + row.Opacity;
      printPanel.Children.Add(row);
    }
    ea.PageVisual = printPanel;
    ea.HasMorePages = false;
  };
  PrinterFallbackSettings settings = new PrinterFallbackSettings(); 
  settings.ForceVector = true;
  settings.OpacityThreshold = 0.5;               
  doc.Print("Silverlight Forced Vector Print", settings);
}
If you run the example in listing 31.4 with a PostScript-compatible printer, you
shouldn’t see any lines with an opacity lower than 0.5, and all above that should be
completely black.
 We’ll now turn to a few common printing use cases and walk through how to
implement them using the Silverlight printing system, starting with printing content
as it appears onscreen. 
31.2
Printing onscreen information 
If a user wants to print the entire web page, she can do so using the browser’s Print
button. This will also print the contents of any Silverlight control but only what’s visi-
ble onscreen. If you have content in a ListBox, for example, and want to have it
expand to show its entire contents, you won’t be able to do that. If your Silverlight
application extends below the fold on the browser (if it’s taller than the visible portion
of the browser page), you’re also out of luck.
 Additionally, if you want to print only the contents of your Silverlight page and not
the surrounding web page, that’s not something most browsers will support. For that
scenario, you’ll want to use the printing API.
 In this section you’ll explore three ways of printing onscreen content: printing it as
is, providing a new root so it can perform layout specific to the printer page, and a
combination of providing a new root and using a ScaleTransform to ensure the con-
tent fits on the printed page.
31.2.1 Printing the content as is
The easiest way to print content is to simply hand off the root of your UI and print it as
is. This approach works for things that fit onscreen or to provide the equivalent of a
Opacity
OpacityThreshold

811
Printing onscreen information 
print-screen function for your application. Figure 31.4 shows an example application
with a fixed height and width. You’ll want to perform the equivalent of a print-screen
on this application.
 The screen shot shows the results of listing 31.3. Note that the application doesn’t
automatically scale to the size of the page, because it has a hard-coded height and
width. Note also that not all the content fits onscreen due to the hard-coded size.
 Listing 31.5 shows the markup for a little application that lists several images from
my website. You’ll use this application markup throughout the rest of the examples in
this section.
<UserControl x:Class="SilverlightPrintTest.MainPage"
  xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
  Height="400" Width="500">                           
  <Grid x:Name="LayoutRoot" Background="White" Margin="5">  
    <Grid.RowDefinitions>
      <RowDefinition Height="Auto" />
      <RowDefinition Height="*" />
      <RowDefinition Height="Auto" />
    </Grid.RowDefinitions>
    <TextBlock Text="Images from Pete's Site"
               FontSize="30"
               TextAlignment="Center" />
    <ScrollViewer Grid.Row="1">                   
      <StackPanel>
        <Image 
          Source="http://10rem.net/media/507/
          ➥ pete-brown-silverlight-in-action.png" 
           Stretch="None"/>
        <Image 
Listing 31.5
UI XAML for the content printing example
Figure 31.4
The example application from 
listing 31.3. The application has 
a fixed height and width.
Hard-coded 
application size
 Root visual
ScrollViewer 
with images

812
CHAPTER 31
Printing
           Source="http://10rem.net/media/33418/wpfdisciples.png"
           Stretch="None" />
        <Image
           Source="http://10rem.net/media/17094/commodorelogo_100x100.png"
           Stretch="None" />
      </StackPanel>
    </ScrollViewer>
    <Button x:Name="Print" Content="Print"
            Grid.Row="2"
            Width="100" Height="30" 
            Click="Print_Click"/>
  </Grid>
</UserControl>
If you use the browser to print that same content, all you’ll see is what’s visible on the
browser page. To get the same effect from Silverlight, you’ll assign the UserControl or
LayoutRoot to PageVisual in the printing code. Listing 31.6 shows how to do that in
the code-behind, using the XAML from listing 31.5.
public partial class MainPage : UserControl
{
  public MainPage()
  {
    InitializeComponent();
  }
  private PrintDocument _document = new PrintDocument();
  private void Print_Click(object sender, RoutedEventArgs e)
  {
    _document.PrintPage += (s, ea) =>
      {
        Debug.WriteLine("Printing page");
        ea.PageVisual = this;               
        ea.HasMorePages = false;
      };
    _document.Print("Silverlight screen print");
  }
}
When you hit the Print button, the result is exactly what you see onscreen but on a
printed page. Note that you could also assign the LayoutRoot as the element you
wanted to print. Because the LayoutRoot already belongs to another visual tree, it
won’t be resized or anything when assigned to the PageVisual. One way around this is
to reroot the root element. 
31.2.2 Reparenting the elements to fit
One way around the issue with fixed-size content is to take the LayoutRoot (or
another element) and reparent (or reroot) it in a printer-specific root element. That new
root element is sized to fit the printer page. Listing 31.7 shows how to reroot the ele-
ment using the BeginPrint and EndPrint events for setup and repair.
Listing 31.6
Printing the entire UserControl and retaining visual size
Print entire 
user control

813
Printing onscreen information 
public partial class MainPage : UserControl
{
  public MainPage()
  {
    InitializeComponent();
  }
  private PrintDocument _document = new PrintDocument();
  private void Print_Click(object sender, RoutedEventArgs e)
  {
    Grid printRoot = new Grid();               
    _document.BeginPrint += (s, ea) =>
      {
        this.Content = null;                                        
        printRoot.Children.Add(LayoutRoot); 
      };
    _document.EndPrint += (s, ea) =>
      {
        printRoot.Children.Remove(LayoutRoot);
        this.Content = LayoutRoot;                                  
        MessageBox.Show("Print job complete.");
      };
    _document.PrintPage += (s, ea) =>
      {
        printRoot.Height = ea.PrintableArea.Height;   
        printRoot.Width = ea.PrintableArea.Width;     
        ea.PageVisual = printRoot;             
        ea.HasMorePages = false;
      };
    _document.Print("Silverlight screen print");
  }
}
The process is picky but relatively straightforward. Before you can move an element to
be a child of another element, you must first remove it from its current parent. In
BeginPrint, you remove LayoutRoot from the page (its current parent) and add it to
the children of the new printer root. In EndPrint, you reverse the process. When
printing, you simply size the new printer root to the dimensions provided by the print-
ing system and assign to the PageVisual the new printer root element as opposed to
the user control itself.
 This whole swapping process exists only to allow you to provide layout dimensions
that differ from the onscreen dimensions. If you could resize the elements onscreen,
that would also work but may be jarring to the user watching the process. 
 Depending on the complexity of what you’re trying to do, this could be tricky.
There may be unintended consequences associated with additional layout passes for
controls you’re using, for example, or you may have binding information or resources
that are no longer accessible once reparented. It’s not an approach I recommend
Listing 31.7
Reparenting an element into a printer-specific root
New printer-
specific root
Size print root 
to printer page
Print it

814
CHAPTER 31
Printing
without first testing for your specific scenario. That being said, it gets around the issue
with having fixed-size page content and wanting to print the content in full.
 Another option is to scale the content to fit. Similar to this approach, you’ll need to
make a decision whether to do it live onscreen or scale using an offscreen visual tree.
31.2.3 Scaling content to fit 
Scaling the content to fit on a single page is another way to print onscreen elements.
As was the case with the previous approaches, you can scale the content onscreen, in
the live visual tree, or you can reroot and scale the print-specific visual tree.
 In most cases, it’d be pretty jarring to scale the onscreen content, so for this exam-
ple, you’ll use the print-specific visual tree.
 In this example, I duplicated the content inside the ScrollViewer five times, in
order to provide sufficient content to illustrate the example. Simply copy and paste
the three Image elements in the XAML so they each appear five times.
 Next, modify the code from listing 31.7 so it does an automatic scale using a Scale-
Transform. Listing 31.8 shows the changed code in the two affected event handlers.
_document.EndPrint += (s, ea) =>
  {
    LayoutRoot.RenderTransform = null;        
    printRoot.Children.Remove(LayoutRoot);
    this.Content = LayoutRoot;
    MessageBox.Show("Print job complete.");
  };
_document.PrintPage += (s, ea) =>
  {
    printRoot.Measure(                            
            new Size(double.PositiveInfinity, 
                     double.PositiveInfinity));
        printRoot.Width = printRoot.DesiredSize.Width;
        printRoot.Height = printRoot.DesiredSize.Height;
    ScaleTransform transform = new ScaleTransform();
    if (printRoot.Height > printRoot.Width)
    {
      transform.ScaleX = transform.ScaleY =            
             ea.PrintableArea.Height / printRoot.Height;
    }
    else
    {
      transform.ScaleX = transform.ScaleY =             
             ea.PrintableArea.Width / printRoot.Width;
    }
    LayoutRoot.RenderTransform = transform;                  
    ea.PageVisual = printRoot;
    ea.HasMorePages = false;
  };
Listing 31.8
Transforming the content to fit on the printed page
Clear out render 
transform
Measure for max 
desired size
Calculate 
scaling factor
Calculate 
scaling factor

815
Printing onscreen information 
If you look closely, you can see that in
this listing you did something strange:
you assigned the render transform to
LayoutRoot instead of printRoot. It
turns out that the print clipping is
applied directly to the PageVisual you
supply. If you also have a transform
attached to that visual, it’ll transform the
clipping rectangle as well. The effect is
having something that’s sized to fit the
page but is clipped in exactly the same
spot it would be if it were at 100 percent
scale—not what you want.
 There are a couple of ways you could
solve this. You could put yet another
visual between the PageVisual and the
LayoutRoot, or if it suits you, attach the
transform to the element one level
below the PageVisual: the LayoutRoot
in this case. 
 Figure 31.5 shows what happens
when you put the transform on the same
level as the clip (left image) or one level
down, as shown on the right-side image.
 If you apply a transform to resize
content and you attach it to an onscreen
visual, make sure you remove it when
complete. If the content already has a
transform applied to it, you’ll need to
either create a transform group, or—my
recommendation—inject 
a 
second
visual between your element and the
PageVisual.
 Printing the onscreen content is cer-
tainly useful, and is often a desirable fea-
ture in applications. More common is
printing information specifically created
for the printer. Such content often spans
more than one page, so you’ll look at
printing purpose-built trees and sup-
porting multipage documents in the
next section.  
  
Figure 31.5
The content on the left had the 
transform applied directly to the PageVisual. It 
was clipped prior to transforming. The content on 
the right had the transform applied one level 
below the PageVisual, at the LayoutRoot. 
The LayoutRoot was transformed, and the 
PageVisual was clipped, providing the result 
we were looking for.

816
CHAPTER 31
Printing
31.3
Multipage printing dedicated trees
Multipage printing comes in many flavors. You could be printing documents or let-
ters, perhaps with mail-merge fields. You may be printing a long tabular report, or you
may have to print a complex multipage form. All three have two things in common:
they may span more than one page and they contain information formatted specifi-
cally for the printer.
 Before we continue, let me reiterate: Silverlight printing isn’t optimized for large
multipage documents. In the case of raster (bitmap) printing, which will be the major-
ity of scenarios, each page is a large bitmap and takes some time to print—how much
depends on the printer and driver. With a PostScript-compatible printer and appropri-
ate installed driver, the story is better. If your application needs to do a lot of printing,
consider sending it through a server printer or another approach, such as using COM
automation to generate a report using Microsoft Word or Excel. In any case, be sure to
test with your specific user’s machine configuration before making too many plans.
 With that out of the way, I’ll show you how and let you figure out whether it works
in your situation. In the remainder of this section, you’re going to build a simple report
with a page header and footer and a number of lines in-between. This isn’t a full report
writer, although I do have something akin to that on http://silverlightreporting
.codeplex.com. You’ll start with building a little infrastructure, then print pages with
only the line items. From there, you’ll add simple headers and footers to each page.
First, let’s set up your report data.
31.3.1 Prerequisites
For this example, you’ll use the same AdventureWorks database and entity model
used in other chapters. Please refer to appendix A for instructions on setting up the
database, connection, and entity model in your web project.
Whatever happened to the paperless office?
I often lament the fact that the paperless office promised in the 1990s never really
came to fruition. We make baby steps every year, but paper printouts are still essential
to the world of business. Most important forms are still passed around in paper format.
Many computer systems are linked only by a manual paper and human data entry pro-
cess sitting between them.
I heard a story on NPR about a school system that’s going to save millions of dollars
in printer toner by changing the default email font to one that uses less toner—yes,
employees print email that much! Oddly enough, no one suggested “please don’t print
email” as a potential cost-saving measure.
It’s great to support printing in your application, and essential in many cases, but con-
sider other ways to service the use case when possible. For example, do they need
to print that appointment information your application is storing, or would it be equally
or perhaps more useful to provide them with an iCal file that they can import into their
own scheduling software and synchronize with their phone?   

817
Multipage printing dedicated trees
Once you have the database connection information and model set up, you can turn
your attention to creating a WCF service to surface the data to the Silverlight client.
CREATING THE SERVICE
Continuing in the web project, it’s time to create the service. The first step is to create
a folder named Services and into it add a new Silverlight-enabled WCF service. Figure
31.6 shows the Add New Item dialog with the correct template selected and named.
 For this demo, you’re interested in read-only data, so you’re going to create a basic
service method that returns data from the Adventure Works entity model. You won’t
support create, update, or delete options. If you’re interested in options for that func-
tionality, read the downloadable appendices covering WCF RIA services.
 You’ll implement the service methods soon. Before you can do that, you need to
create the EmployeeReportItem class.
CREATING THE EMPLOYEEREPORTITEM CLASS
The EmployeeReportItem class represents a single row of data for your report. You
could simply send down the complete entities from the model, but that’d be wasteful
and perhaps even confusing. Instead, you’ll create a denormalized entity that contains
properties from both the Employee and the Contact classes.
 In the Services folder of the web project, create a new class named Employee-
ReportItem. Listing 31.9 shows the implementation of this class. 
public class EmployeeReportItem
{
    public int EmployeeID { get; set; }
    public string FirstName { get; set; }
Listing 31.9
The EmployeeReportItem class
Figure 31.6
Adding a Silverlight-enabled WCF service to the web project

818
CHAPTER 31
Printing
    public string LastName { get; set; }
    public string Title { get; set; }
    public string EmailAddress { get; set; }
    public string Phone { get; set; }
    public DateTime HireDate { get; set; }
}
Note that because you’re using .NET 4 on the server, you don’t need to include Data-
Contract and DataMember attributes in the class. WCF will serialize all public members
by default.
 Once the EmployeeReportItem class is in place, you can use it from your service.
ADDING THE SERVICE IMPLEMENTATION
The last step on the server-side of the project is to add the implementation of the
GetEmployeeReportData method of the service. This implementation will join the two
entities and pull out fields from them to create EmployeeReportItem instances. Those
instances will then be returned to the caller, your Silverlight client in this case. Listing
31.10 lists the code required in the service.
[OperationContract]
public List<EmployeeReportItem> GetEmployeeReportData()
{
  using (AdventureWorksEntities context =
      new AdventureWorksEntities())   {
    var items =
      (from emp in context.Employees
         select new EmployeeReportItem()              
         {
           EmployeeID = emp.EmployeeID,
           FirstName = emp.Contact.FirstName,
           LastName = emp.Contact.LastName,
           Title = emp.Title,
           EmailAddress = emp.Contact.EmailAddress,
           Phone = emp.Contact.Phone,
           HireDate = emp.HireDate
         }).Take (100)                                   
           .ToList ();  
    return items;
  }  
}
The service in listing 31.10 pulls information from the AdventureWorks2 database,
using LINQ to both limit the number of items returned to a reasonable number (100)
and merge the entities to create a single EmployeeReportItem for each row of data.
Listing 31.10
The GetEmployees method of the AdventureWorksService class
2  Did I mention I work at Microsoft? Hey, at least I don’t have any Contoso apps in here.
Shape into 
EmployeeReportItem
Limit return
count

819
Multipage printing dedicated trees
ADDING A REFERENCE TO THE SERVICE
The final required step before you get into the report itself is to add a reference to the
WCF service. First build the solution and ensure that there are no errors. Then, right-
click the Silverlight project and choose Add Service Reference. Be sure you set the
web project to run on a static port before doing this.
 In the dialog, click Discover to find the services in your solution. If successful,
you’ll see something like figure 31.7.
 In the namespace area, enter the name Services. On the Silverlight client, that
will be the namespace (under your root namespace) into which the service client
proxy and the EmployeeReportItem class will be generated.
TEST THE SERVICE
Before I move into printing, let’s add one last step: testing. This is optional, but I rec-
ommend doing it to ensure that all the other parts are working correctly.
 In the code-behind for the main page of your project, add the code shown in listing
31.11. Be sure to right-click AdventureWorksServiceClient and choose Resolve (or
press Alt-Shift-F10) to automatically add the correct using statement to the code file.
public MainPage()
{
  InitializeComponent();
  Loaded += new RoutedEventHandler(MainPage_Loaded);
}
void MainPage_Loaded(object sender, RoutedEventArgs e)
Listing 31.11
Code to test the service reference from Silverlight
Figure 31.7
Adding a 
service reference from 
our Silverlight project 
to the WCF service in 
the web project

820
CHAPTER 31
Printing
{
  var client = new AdventureWorksServiceClient();
  client.GetEmployeeReportDataCompleted += (s, ea) =>
    {
      if (ea.Result != null)
      {
        int i = 0;
        foreach (EmployeeReportItem item in ea.Result)
        {
          Debug.WriteLine(item.LastName + ", " + item.FirstName + 
                          " " + i++);
        }
      }
    };
  client.GetEmployeeReportDataAsync();
}
When you run the project, take a look at your output window and see whether it dis-
plays 100 names. If it does, you’re good. If not, debug any error you receive and try
again. Once it’s working, you’re ready to build the report, starting with the line items.
Be sure to remove the test code from the project. 
31.3.2 Printing line items
For the report, you’re going to build a custom print-optimized visual tree using a com-
bination of code and data templates. 
NOTE
This report is optimized for learning the concepts and fitting into a
book. It’s not meant to be a reusable report class but rather a starter to pro-
vide insight into how you might create your own reports in Silverlight. The
version on the Silverlight Reporting CodePlex site is more robust but still not
exactly “enterprise ready.”
In this and the following sections, you’ll first get the data from the WCF service into
the report class. Then you’ll print a single-page version of the report using only the
line items and a data template. The next step is modifying the report to support page
breaks. From there, you’ll add a header and footer before wrapping up.
CREATING THE EMPLOYEEREPORT CLASS AND LOADING DATA
The first step is to create, in the Silverlight project, a class named EmployeeReport.
Into that class, you’ll add code to call the service and load the data. The code to load
the data will be similar to the test code in listing 31.11. Listing 31.12 shows the class
with a LoadData method and the shell of the Print method.
public class EmployeeReport : FrameworkElement 
{
  public EmployeeReport() { } 
  public event EventHandler DataLoaded;
  private IEnumerable<EmployeeReportItem> _items;     
Listing 31.12
The EmployeeReport class
Contains line 
items for report

821
Multipage printing dedicated trees
  public void LoadData ()
  {
    var client = new AdventureWorksServiceClient();
    client.GetEmployeeReportDataCompleted += (s, e) =>
    {
      _items = e.Result;
      if (DataLoaded != null)  
        DataLoaded(this, EventArgs.Empty);
    };
    client.GetEmployeeReportDataAsync();
  }
  private void InternalPrintReport()          
  {
  }
  public void Print()
  {
  }
}
You derive from FrameworkElement for two reasons: 
■
You need to derive from some DependencyObject-derived class in order to sup-
port the dependency properties that’ll be used for the templates.
■
You want the element to be on-page and accessible in XAML. 
For more on FrameworkElement, see chapter 7.
 Listing 31.12 forms the shell of your new report class. Because you’ll use it in
XAML, in addition to deriving from FrameworkElement, you needed to include a
default constructor. It’s an empty constructor, but its presence means that it can be
instantiated in XAML. Additionally, because you need to support a user-initiated print
process, you raise a DataLoaded event when the data is loaded. The UI can then cap-
ture that and allow the user to click a button to perform the printing.
 Now that the class has been created, you’ll add support for the first template: the
item template. 
ADDING THE ITEMTEMPLATE
The next step is to add a dependency property for the item template used to format
items on the report. The DependencyProperty will hold a DataTemplate containing
visuals and binding statements for the items rows. Listing 31.13 shows the code you’ll
need to add to the EmployeeReport class.
public DataTemplate ItemTemplate
{
  get { return (DataTemplate)GetValue(ItemTemplateProperty); }
  set { SetValue(ItemTemplateProperty, value); }
}
public static readonly DependencyProperty ItemTemplateProperty =
  DependencyProperty.Register("ItemTemplate", 
  typeof(DataTemplate), typeof(EmployeeReport), 
  new PropertyMetadata(null));
Listing 31.13
The ItemTemplate on the EmployeeReport class
Handles actual 
report printing

822
CHAPTER 31
Printing
You’ll have a few more dependency properties to add before you’re through. Before
you do that, let’s crack open the MainPage XAML, add a reference to the Employee-
Report type, and flesh out the data template for the item rows.
 Listing 31.14 shows the MainPage XAML file with a reference to the local
namespace as well as an instance of the report with an appropriate yet simple data
template. You’ll also add a Print button (with a click handler in the code-behind) to
provide a way to print the report.
<local:EmployeeReport x:Name="Report">
  <local:EmployeeReport.ItemTemplate>
    <DataTemplate>
      <Grid>
        <Grid.ColumnDefinitions>
          <ColumnDefinition Width="40" />
          <ColumnDefinition Width="180" />
          <ColumnDefinition Width="180" />
          <ColumnDefinition Width="210" />
          <ColumnDefinition Width="100" />
          <ColumnDefinition Width="70" />
        </Grid.ColumnDefinitions>
        <TextBlock Grid.Column="0"
                   Text="{Binding EmployeeID}" />
                        
        <StackPanel Grid.Column="1" Orientation="Horizontal">
          <TextBlock Text="{Binding LastName}" />
          <TextBlock Text=", " />
          <TextBlock Text="{Binding FirstName}" />
        </StackPanel>
        <TextBlock Grid.Column="2"
                   Text="{Binding Title}" />
        <TextBlock Grid.Column="3"
                   Text="{Binding EmailAddress}" />
        <TextBlock Grid.Column="4"
                   Text="{Binding Phone}" />
        <TextBlock Grid.Column="5"
              Text="{Binding HireDate, StringFormat='{}{0:d}'}" />
      </Grid>
    </DataTemplate>
  </local:EmployeeReport.ItemTemplate>
</local:EmployeeReport>
The local namespace is mapped to the project the code and markup reside within.
The ItemTemplate contains a DataTemplate that has a grid column for each column
displayed on the report. Each column contains one or more fields bound to the prop-
erties of the EmployeeReportItem class. The EmployeeReport element itself resides in
the LayoutRoot grid, left out of listing 31.14 for space considerations. Also in the
LayoutRoot grid, after the report add this button:
<Button x:Name="Print" Content="Print" Width="100" Height="30"
        IsEnabled="False"
        Click="Print_Click"/>
Listing 31.14
MainPage markup subset for report and template

823
Multipage printing dedicated trees
Note that the button isn’t enabled by default. You’ll enable it once the data is loaded
from the service. The code to run the report can’t be included in the service return
event handler, because (in normal trust applications) it must be run from a user-initi-
ated event. 
 Listing 31.15 shows the code-behind with the code to load the report data and han-
dle the print report button click.
public MainPage()
{
  InitializeComponent();
  Loaded += new RoutedEventHandler(MainPage_Loaded);
}
void MainPage_Loaded(object sender, RoutedEventArgs e)
{
  Report.DataLoaded += (s,ea) =>
    { 
      Print.IsEnabled = true;                     
    };
  Report.LoadData();                               
}
private void Print_Click(object sender, RoutedEventArgs e)
{
  Report.Print();
}
With the item template in place, and your print button wired up, you’ll turn back to
the PrintDocument class and the PrintPage event.
THE PRINT METHOD
The EmployeeReport class currently has a Print method that does nothing. You’ll
flesh that out to include the usual trifecta of print event handlers, as shown in listing
31.16.
public void Print()
{
  PrintDocument doc = new PrintDocument();
  IEnumerator<EmployeeReportItem> itemsEnumerator = 
    _items.GetEnumerator();                      
  doc.BeginPrint += (s, e) =>
    {
      itemsEnumerator.Reset();                       
    };
  doc.EndPrint += (s, e) =>
    {
      MessageBox.Show("Report complete.");
Listing 31.15
Code-behind for MainPage 
Listing 31.16
The three printing event handlers, wired and ready to go
Enable button
when loaded
Load data
Enumerator 
explained shortly
Enumerator 
explained shortly

824
CHAPTER 31
Printing
    };
  doc.PrintPage += (s, e) =>                           
    {
    };
  doc.Print("Employee Report");
}
From this point forward, the majority of the code will go into the PrintPage method.
For space considerations, I won’t show the other event handlers or the InternalPrint-
Report function itself.
ENUMERATING ROWS
When I was in college, they made me learn COBOL. Not just any old COBOL, but
COBOL on an unforgiving editor on a VAX/VMS computer. If you’ve never written in
COBOL, give it a try—it’ll make you appreciate how little typing you need to get things
done in C#. Perhaps my interest in curly-brace languages like C# is the result of the
trauma I sustained in that class.
 But I digress. One thing that the COBOL class did teach was how to build reports
from code. That’s one skill that I’ve been able to use in most technologies since. Up
until now, I hadn’t been able to use that in Silverlight. Luckily, that’s about to change.
 Normally when you process a bunch of rows of data, you’d use a LINQ statement or
a for each loop. Neither approach will work particularly well here, because you need
to keep a pointer to your position in the data while allowing Silverlight to raise separate
events for each page. Though you could use a simple for next loop and an index that
you keep track of externally, this is the type of scenario just built for IEnumerator<T>. 
 In listing 31.16, you can see the enumerator declared inside the Print method.
This will be used to keep track of your current position in the report data. In the
BeginPrint event handler, you reset the enumerator. Doing so allows Print to be
called multiple times on the same data, without running into an enumerator problem.
 The enumerator approach is similar to what you might use in COBOL or in record-
set/rowset processing in another language, where there’s the concept of a “current”
record as opposed to an external loop index.
 In listing 31.17, you first create a StackPanel that’ll be used to hold the rows of
data. You then move through each row of data, instantiate the template, and add the
resulting element to the panel. Finally, the panel is set as the page visual, ready for Sil-
verlight to print.
doc.PrintPage += (s, e) =>
{
  StackPanel itemsPanel = new StackPanel();                      
  while (itemsEnumerator.MoveNext())
  {
    FrameworkElement row =                               
Listing 31.17
Enumerating and printing each row of data
PrintPage 
event handler
Create from
template

825
Multipage printing dedicated trees
      ItemTemplate.LoadContent() as FrameworkElement;
    row.DataContext = itemsEnumerator.Current;                   
    row.Measure(e.PrintableArea);                                
    itemsPanel.Children.Add(row);        
  }
  e.PageVisual = itemsPanel;
  e.HasMorePages = false;
};
The code in listing 31.17 includes the majority of the important logic required to
print a report. It first creates a StackPanel used to hold the content. It then loops
through the line items, creating a template-based element to be the row’s contents,
then setting the data context of that element to be the row data itself. It then mea-
sures the element, providing it the bounds of the page, and, finally, adds it to the stack
panel. Once all elements have been created, the page visual is set to the stack panel
and the HasMorePages flag is set to false.
 In setting HasMorePages to false and not dealing with page breaks, the code in
listing 31.15 blindly prints, ignoring the end of the page. If this were old traditional
printing, green-bar fan-fold paper would be flying off the printer faster than you
could catch it, with printing on the seams and everywhere else. Silverlight will clip
this, so the result will be only a single page that doesn’t overrun its boundaries. Figure
31.8 shows the top of the report page for reference, as it appears when using the XPS
document print driver. 
 A short single page is nice, but losing data off the bottom isn’t. What you really
want is to support multiple pages and wrap contents on to those subsequent pages. 
31.3.3 Adding multipage support
To support multiple pages, you need to keep track of the size of the report at every
row. You could precalculate the number of rows that will fit, but then you’d lose the
flexibility to have dynamically sized rows that change height based on their content.
Add to panel
Figure 31.8
The top portion of the report, shown in the XPS viewer

826
CHAPTER 31
Printing
Listing 31.18 shows what you can do to keep track of the page size and ensure the con-
tent will fit on the page. Note the addition of the !full check in the while loop.
doc.BeginPrint += (s, e) =>
{
    itemsEnumerator.Reset();
    itemsEnumerator.MoveNext();                     
};
doc.PrintPage += (s, e) =>
{
    StackPanel itemsPanel = new StackPanel();
    double itemsAreaHeight = e.PrintableArea.Height;
    double itemsHeight = 0.0;
    bool full = false;
    bool moreItems = true;
    while (moreItems && !full)
    {
        FrameworkElement row = 
            ItemTemplate.LoadContent() as FrameworkElement;
        row.DataContext = itemsEnumerator.Current;
        row.Measure(e.PrintableArea);
        itemsHeight += row.DesiredSize.Height;
        if (itemsHeight > itemsAreaHeight)
        {
            full = true;                         
        }
        else
        {
            itemsPanel.Children.Add(row);        
            moreItems = itemsEnumerator.MoveNext();
        }
    }
    e.PageVisual = itemsPanel;
    e.HasMorePages = moreItems;                       
};
doc.Print("Employee Report");
}
The approach used in listing 31.18 to move things to the next page is a little hokey.
For one thing, that MoveNext in BeginPrint assumes the report will always have at
least one row of data. For another, there’s a wasted measure call when you reach the
point of moving to a new page.
 To do multipage support correctly, you need to precalculate your pages. This is the
approach I took in the version I put up on CodePlex. But for the simple example
here, I decided to reserve a bit of buffer space at the bottom of the page, equal to the
size of one row. Of course, this assumes fixed-height rows, so if any vary wildly, the pag-
ing here won’t work correctly. To truly support dynamically sized rows, you’ll need to
Listing 31.18
Breaking when the page is full
Move to 
valid item
Row doesn’t fit
Row fits; add it
More items means
more pages

827
Multipage printing dedicated trees
measure and then move the item to the next page if it doesn’t fit—something much
easier to do in a precalculation routine.
 Whatever approach you use, once you have some measuring infrastructure in
place, it becomes fairly easy to add a header and footer.
31.3.4 Adding a header and footer
The approach you’ll use to add a header and footer is similar to the items approach.
The header and footer will each have an associated DataTemplate property that’ll be
populated in XAML with the appropriate content. Listing 31.19 shows the property
declarations in the EmployeeReport class.
public DataTemplate PageHeaderTemplate       
{
    get { return (DataTemplate)GetValue(PageHeaderTemplateProperty); }
    set { SetValue(PageHeaderTemplateProperty, value); }
}
public static readonly DependencyProperty PageHeaderTemplateProperty =
    DependencyProperty.Register("PageHeaderTemplate", 
    typeof(DataTemplate), typeof(EmployeeReport), 
    new PropertyMetadata(null));
public DataTemplate PageFooterTemplate       
{
    get { return (DataTemplate)GetValue(PageFooterTemplateProperty); }
    set { SetValue(PageFooterTemplateProperty, value); }
}
public static readonly DependencyProperty PageFooterTemplateProperty =
    DependencyProperty.Register("PageFooterTemplate", 
    typeof(DataTemplate), typeof(EmployeeReport), 
    new PropertyMetadata(null));
public int PageNumber                    
{
    get { return (int)GetValue(PageNumberProperty); }
    private set { SetValue(PageNumberProperty, value); }
}
public static readonly DependencyProperty PageNumberProperty =
    DependencyProperty.Register("PageNumber",
    typeof(int), typeof(EmployeeReport),
    new PropertyMetadata(0));
Note that you’re adding a third dependency property to hold the page number. You’ll
use that inside the templates to show the current page number via a binding state-
ment. The two other dependency property declarations are pretty straightforward.
Listing 31.19
Dependency properties for templates
Page header
Page footer
Read-only page 
number

828
CHAPTER 31
Printing
You’ll have one data template for the page header and another for the page footer.
The XAML data templates for listing 31.19 are shown in listing 31.20. 
<local:EmployeeReport.PageHeaderTemplate>        
  <DataTemplate>
    <Grid Margin="1 1 1 10">
      <Rectangle Stroke="Black"/>
      <TextBlock Text="Adventure Works Employee Report"
                 FontSize="25" Margin="10"
                 HorizontalAlignment="Left"
                 VerticalAlignment="Center" />
    </Grid>
  </DataTemplate>
</local:EmployeeReport.PageHeaderTemplate>
<local:EmployeeReport.PageFooterTemplate>        
  <DataTemplate>
    <Grid Margin="1 10 1 1">
      <Rectangle Stroke="Black" />
        <TextBlock 
           Text="{Binding PageNumber,StringFormat='Page {0}'}"
           Margin="10" HorizontalAlignment="Right" 
           VerticalAlignment="Center" />
    </Grid>
  </DataTemplate>
</local:EmployeeReport.PageFooterTemplate>
To support the page numbering used in listing 31.20, you have to add another reset
line to the BeginPrint event. This line resets PageNumber to 0, assuming you may
print the report more than once. Here’s the additional line of code, shown in context:
doc.BeginPrint += (s, e) =>
{
    itemsEnumerator.Reset();
    itemsEnumerator.MoveNext();
    PageNumber = 0;         
};
You could leave out the PageNumber reset, and the worst that would happen would be
that your page numbers would continue to increment from report to report during
the same Silverlight session.
 That brings us to the real core of the multipage support: the PrintPage changes.
PrintPage gains a significant number of lines of code because you now need to build
a grid to contain the header, footer, and content rows. The StackPanel is still there, in
the central cell in the grid, but it’s now positioned between two other grid rows. List-
ing 31.21 shows the method, with the exception of the code right above and inside the
while loop, which remains untouched.
Listing 31.20
Header and footer data templates in MainPage XAML
Header
Footer

829
Multipage printing dedicated trees
doc.PrintPage += (s, e) =>
{
  PageNumber++;                                   
  Grid rootGrid = new Grid();                              
  RowDefinition headerRow = new RowDefinition();           
  headerRow.Height = GridLength.Auto;
  RowDefinition itemsRow = new RowDefinition();             
  itemsRow.Height = new GridLength(1, GridUnitType.Star);
  RowDefinition footerRow = new RowDefinition();            
  footerRow.Height = GridLength.Auto;
  rootGrid.RowDefinitions.Add(headerRow);
  rootGrid.RowDefinitions.Add(itemsRow);
  rootGrid.RowDefinitions.Add(footerRow);
  FrameworkElement header =                       
    PageHeaderTemplate.LoadContent() as FrameworkElement;
  header.DataContext = this;
  header.Measure(e.PrintableArea);
  Grid.SetRow(header, 0);
  StackPanel itemsPanel = new StackPanel();
  Grid.SetRow(itemsPanel, 1);
  FrameworkElement footer =                       
    PageFooterTemplate.LoadContent() as FrameworkElement;
  footer.DataContext = this;
  footer.Measure(e.PrintableArea);
  Grid.SetRow(footer, 2);
  rootGrid.Children.Add(header);                    
  rootGrid.Children.Add(itemsPanel);               
  rootGrid.Children.Add(footer);                    
  double itemsAreaHeight = e.PrintableArea.Height -          
      header.DesiredSize.Height - footer.DesiredSize.Height;
    ... existing code: itemsHeight, full, moreItems, while loop ...
  e.PageVisual = rootGrid;                                   
  e.HasMorePages = moreItems;
};
The additions in listing 31.21 are long but easily understood. You first increment the
page number so you can use that in the bound header and footer. You then create a
root element, this time a grid. Three rows are added to the grid: the header row, the
items row, and the footer row. The header and footer rows are autosized; the middle
items row is set to take up the remaining available space. You then create the elements
from the header and footer templates and add them to the appropriate rows in the
grid along with the StackPanel used to hold items. Their data contexts are set to the
Listing 31.21
Updated PrintPage code for header and footer
Create header
Create footer

830
CHAPTER 31
Printing
report object, so they can pick up the PageNumber property. The final new step before
the loop is to modify the way the itemsAreaHeight is calculated, so it takes into
account the size of the header and footer. Finally, rather than assign the items panel
to the PageVisual, you assign the entire grid, header, items, footer, and all. Figure
31.9 shows the header and footer at the page break between page 1 and page 2.
 It’s relatively easy to get the page number, as you see in the example code. It’s
more difficult to get a total page count. One common request for reports is the ability
to show the page number as “Page x of y” where x is the current page and y is the total
count of pages. Should you desire to do this, you’ll need to precalculate the pages
prior to printing—the approach I took in the version posted to CodePlex.
 Supporting multipage printing with headers and footers is easily done, given the
flexibility of data templates and the “no assumptions” low-level nature of the Silver-
light printing API. Though the performance of the printing system isn’t quite up to
par for huge multipage reports, the API does nothing to prevent you from creating
those types of print jobs if they’re appropriate to your project. 
 Combining the print API with binding and templates offers a good reuse story and
allows you to spend more time in XAML using design tools and less time in code. You
could even extend the template model to include a report footer for totals or modify
it further to support nested groups. The sky’s the limit.  
31.4
Summary
In order for Silverlight to be taken seriously in the business world, it had to support a
flexible printing API. Though you can sometimes punt and skip on printing support
in consumer applications, the business world is less forgiving.
 With Silverlight 4, the product team delivered a very flexible printing API. Silver-
light 5 expanded on that to provide true PostScript vector printing support. 
 The printing API in Silverlight can be used for anything from printing simple
onscreen content to complex multipage reports with headers, footers, grouping, and
more. In this chapter you learned how the printing system functions and saw how to
Figure 31.9
The footer from page 1 and the header from page 2. Note the page number on the first page.

831
Summary
send vector and bitmap content to the printer and how to print content as it appears
onscreen. You then explored a few ways to handle scaling that content so it better fit the
printer. You also looked at content that was purpose-built specifically for the printer,
whether a simple single-page list or a multipage report including headers and footers.
 The information in this chapter can serve as a foundation on which you can build
your own printing and reporting systems in your applications. But should you want to
take the knowledge and simply apply it to someone else’s code, I have created a simple
report writer project on CodePlex at http://silverlightreporting.codeplex.com. I plan
to use that as a test bed for new ideas and provide something real that you can build
on to meet your own requirements. Take a look at it, if only to see some of the other
techniques described in this chapter, such as precalculating pages.
 In the next chapter, you’ll dive further into integrating with the operating system
by looking at COM, the native extensions, and Silverlight support for p-invoke.

832
COM, Native Extensions,
and p-invoke
Since the early versions, Silverlight has occupied an interesting space straddling
both the web and desktop worlds. Silverlight 3 introduced out-of-browser mode.
Silverlight 4 introduced elevated trust and COM automation support. Silverlight 5
capped it all off with support for p-invoke which is used to call native Win32 API-
style functions. Pretty amazing for something that started off as a web technology!
 In reality, most people developing new Silverlight applications are delivering
desktop applications for Windows and use Silverlight for a number of reasons men-
tioned throughout this book. Those people have asked for more and deeper OS
integration in the form of access to COM objects and Win32 API calls. Those same
people and others have also implicitly requested these features when they asked for
things the Silverlight team wouldn’t have time to deliver but that can be accessed
through these mechanisms.
This chapter covers
■
COM automation
■
Native Extensions for Silverlight
■
P-invoke

833
COM automation
COM automation is good for accessing anything that surfaces an automation inter-
face. The original intent was to enable integration with Microsoft Office, but industri-
ous developers have discovered lots of other automation-capable interfaces in
Windows.
 One of those developers went so far as to create a complete set of COM automation
servers in C++, and then write Silverlight wrappers for them. This amazing body of
work, collectively known as the Native Extensions for Silverlight, makes it possible to
integrate with Windows in ways previously reserved only for deep Windows desktop
technologies like WPF.
 No talk of integration would be complete without looking at the base operating
system API itself. In Windows, this is the Win32 API—something .NET applications have
been able to access via Platform Invocation Services (p-invoke) since .NET 1.0. With
the introduction of version 5, this is now on the table for your Silverlight applications
as well.
 In this chapter, I’ll show you various ways Silverlight can integrate with the OS and
installed applications. You’ll first explore COM automation and see how it can be used
for things like speech synthesis, GPS location services, and even automating Microsoft
Excel. Then, you’ll learn about the Native Extensions for Silverlight, a rich set of COM
automation servers and wrapper classes that provide access to core Windows 7 and 8
services, most of which are unavailable to Silverlight in any other form. This chapter
wraps up with a look at p-invoke and how it can be used to make traditional Win32
API–style function calls.
32.1
COM automation
One of the more interesting capabilities in the System.Windows.Interop namespace
is the ability to use COM automation to integrate with native code and applications on
the desktop. The primary intent of this feature is to allow automation of other applica-
tions, including Microsoft Office, on Windows. For example, you may want to auto-
mate Excel to generate a spreadsheet with a chart, as you’ll do in this section.
 This feature can be used to gain access to a subset of the Windows APIs, specifically
those that support IDispatch. This opens up entire new areas for Silverlight, such as
location and speech. In most cases, if you can script it Silverlight can use it. You’ll look
at examples of both shortly.
 It wasn’t a goal of this feature to allow access to custom COM DLLs you may write;
to DLLs third parties provided for you to package with your Silverlight application; or
to the full desktop CLR. With that disclaimer out of the way, the COM automation fea-
ture of Silverlight is an incredibly powerful way to extend the sandbox, both for good
and for evil. Once you have access to an IDispatch-compatible API, you can do any-
thing you want with it. It doesn’t respect the sandbox otherwise enforced in Silverlight
code; the only security that comes into play is operating system–level security based on
the identity of the user running the application.

834
CHAPTER 32
COM, Native Extensions, and p-invoke
32.1.1 Detecting COM automation availability
COM automation may not be available in any particular running instance of your
application. Reasons for this may be that the user has declined the elevation request
or the application is running on a platform other than Windows. In those cases, you
want to nicely degrade the functionality in a way that both respects the user and still
provides a good experience.
 In addition to checking for elevated permissions as described in chapter 6, Silver-
light provides some calls you may use to detect the presence of COM automation. The
first is the call to check that you’re running on Windows. This check is optional, but
you may want to do it so you degrade differently on different operating systems. For
example, on Windows, you may want to tell users they need to provide elevated per-
missions. On the Mac or Linux, you may simply want to remove the button or menu
option. Listing 32.1 shows how to check the OS platform.
switch (System.Environment.OSVersion.Platform)
{
    // Mac
    case PlatformID.MacOSX:                
        break;
    // Unix/Linux
    case PlatformID.Unix:                  
        break;
    // Windows 
    case PlatformID.Win32NT:               
        break;
}
The System.PlatformID enumeration has more values, but not all are supported by
Silverlight. For example, Windows 95/98 is listed, as is Win32s for 16-bit Windows. It’s
been a long time since I booted up Windows for Workgroups 3.11. Because operating
systems from the Windows 2000 branch are all based on the original Windows NT
codebase, all the versions of Windows supported by Silverlight will show up as
PlatformID.Win32NT.
 The final and main check is to see whether COM automation is available. Techni-
cally, this is the only call you’re required to make, but if I kept this book just to the
required parts, it’d be a rehash of the documentation on msdn.microsoft.com and
would seem too much like work. Listing 32.2 shows how to check for automation
availability.
if (AutomationFactory.IsAvailable) 
{ 
    /* do awesome stuff with COM */ 
}
Listing 32.1
Checking the OS platform
Listing 32.2
Checking for COM automation availability
Mac
Linux
Windows

835
COM automation
Once you ensure automation is available, you can start using it to interact with other
applications or automation-capable OS APIs. It truly is a powerful level of integra-
tion with the native code bits of the system. Let’s look at some cool things you can
do with it. 
32.1.2 Using COM automation to make Silverlight talk
As an example of one of the neat OS-level things you can do with the API, let’s look at
speech. System.Speech, available as part of the full .NET Framework, makes speech
easily accessible to any desktop or server application. But System.Speech simply wraps
and makes .NET-friendly the Speech API (SAPI) native to Windows. As luck would have
it, SAPI supports a script- and Silverlight-friendly IDispatch interface. Listing 32.3
shows a simple “Hello World!” speech application using the C# dynamic keyword and
COM automation. (In order to use the C# dynamic keyword, you need to have a refer-
ence to Microsoft.CSharp.dll. The DLL is delivered with the Silverlight SDK.)
if (AutomationFactory.IsAvailable)
{
    using (dynamic voice =
        AutomationFactory.CreateObject("Sapi.SpVoice"))
    {
        voice.Speak("I'm better than any in-page midi file!");
    }
}
IDispatch
IDispatch is COM’s standard interface that supports late binding using the OLE Au-
tomation protocol interface. IDispatch provides methods to allow a client to query
the component to find out what properties and methods it supports as well as a method
to invoke any one of those methods. All method calls are resolved at runtime rather
than compile time.
Each method supported by the COM component is assigned an ID. When the
IDispatch interface’s GetIDsOfNames function is passed a string name of a function,
it returns the ID. The calling code then uses the Invoke function to invoke that
function.
Due to the late binding nature of IDispatch, it supports scripting as well as clients
using the dynamic functionality in .NET 4, along with older clients such as Visual Basic
(pre-.NET). In fact, it was originally created with scripting and Visual Basic in mind.
The method-ID table approach of IDispatch doesn’t perform as well as the early
bound references using custom interfaces. For that reason, consider alternative ap-
proaches when looking at calling many IDispatch methods in a large loop in an
application.
Listing 32.3
Making Silverlight talk
Create COM object

836
CHAPTER 32
COM, Native Extensions, and p-invoke
This shows the AutomationFactory.CreateObject call. This method is the COM auto-
mation equivalent of the "new" keyword, making it possible to create an instance of an
object. It takes in the COM name of the class. Other than that call, everything else
looks like normal .NET code.
TIP
One easy way to figure out the COM automation class name is to look at
examples of scripting using Windows Scripting Host or even classic ASP. If
that doesn’t give you anything, you can spelunk the registry and get the name
from the object’s actual registration entry.
However, if you typed the code into Visual Studio rather than running the download-
able source code, you probably noticed that you received no IntelliSense cues to help
you identify the available methods of the voice object. Recall that COM automation
objects are late-bound—that is, they’re resolved at runtime. Because of this, one real
downside to using COM automation is you get zero compile-time help. One way to mit-
igate the lack of compile-time help is to type the code into a console application that
uses the early-bound COM interface version of what you’re trying to access and then
paste that code into the Silverlight version. Doing so works really well in situations
such as automating Microsoft Office, which has identical early- and late-bound APIs.
 Another interesting use of COM automation is access to the Windows Location API.
32.1.3 Accessing GPS data using COM automation
I wrote the original version of this section of the chapter on the return trip from
speaking at an event in Iceland (in-flight power and limitless coffee are a real win,
despite how hot my US power supply is from the 240V power). Right above my multi-
touch tablet screen is a small seat-back console that displays the graphical representa-
tion of our geographical position on the world map. (For reference, we’re above
Canada between the amusingly named Goose Bay and Gander.) 
 Watching that reminded me that all the nifty GPS work I’ve done with WPF on Win-
dows 7 is also available in Silverlight because the native API supports IDispatch. Loca-
tion-aware Silverlight applications? Awesome.
 Access to location information was first offered as part of the full .NET 4 Frame-
work in the System.Device.Location namespace. Much like System.Speech, Sys-
tem.Device.Location simply (or not so simply if you’re the one who had to write it)
wraps and makes .NET-friendly the Windows 7 Location API. Though you do lose some
convenience such as the INotifyPropertyChanged implementation (see chapter 16)
by going directly against the native COM API, it’s still pretty usable.
 Listing 32.4 shows how to access location information, specifically the latitude and
longitude reported by a GPS receiver such as the u-blox device included with Micro-
soft Streets and Trips 2010 (and, to the best of my knowledge, only with that specific
version). Note that this example requires a version of Windows 7 or later that supports
the Sensor and Location API (all versions except the Starter edition).

837
COM automation
if (AutomationFactory.IsAvailable)
{
  using (dynamic factory = 
    AutomationFactory.CreateObject("LocationDisp.LatLongReportFactory"))
  {
    AutomationEvent newReportEvent = 
      AutomationFactory.GetEvent(factory, "NewLatLongReport");
    newReportEvent.EventRaised += (s, ev) =>
    {
      using (dynamic report = factory.LatLongReport)
      {
        LatitudeDisplay.Text = factory.Latitude.ToString();
        LongitudeDisplay.Text = factory.Longitude.ToString();
      }
    };
    factory.ListenForReports(1000);
  }
} 
In addition to working only on a Windows 7 or later PC (I don’t check for the OS ver-
sion in this example, but you really should), this code will only work if you have a GPS
attached to your PC and you’re in a spot where you can get a satellite signal. If you
don’t have a different Location API–compatible receiver, I recommend getting the
inexpensive u-blox one and downloading the Location API drivers from http://www
.ublox.com/en/drivers-a-middleware/usb-drivers/windows-7-driver.html. The device
itself is fairly simple, reporting only latitude and longitude (no altitude, speed, or
heading) but is otherwise quite capable.
 Speech and location are fun and likely to be used by lots of applications, but the
one example requested more than any, and the one feature many people have
requested of the Silverlight team, is the automation of Microsoft Office applications
such as Outlook and Excel.
32.1.4 Automating Excel
Many business applications need to generate documents or spreadsheets from the
data gathered from users or pulled from the database. Some people decide to reim-
plement that functionality in code, but many decide to automate an existing Microsoft
Office application. You get the full power of the Office products with a minimal
amount of code.1
 The canonical example of using COM automation in Silverlight is to automate
Excel to populate data and create a chart, such as the one shown in figure 32.1. List-
ing 32.5 shows the code required to create this worksheet and chart.
Listing 32.4
Accessing GPS through COM Automation
1 The Office team didn’t pay me to say that. If you work on that team and are reading this, I’m more than happy
to take donations.

838
CHAPTER 32
COM, Native Extensions, and p-invoke
Figure 32.1
An Excel worksheet 
and chart generated 
through COM 
Automation Interop 
using Silverlight 
elevated trust mode
if (AutomationFactory.IsAvailable)
{
  dynamic excel = 
    AutomationFactory.CreateObject("Excel.Application");
  excel.Visible = true;
  dynamic workbook = excel.workbooks;
  workbook.Add();                                 
  dynamic sheet = excel.ActiveSheet;
  int i = 1;
  double[] data = new double[] { 1.0, 5.0, 9.5, 2.7, 3.2, 0.6 };
  foreach (double d in data)                               
  {
    dynamic cell = sheet.Cells[i, 1];
    cell.Value = "Row " + i;                                  
    cell.ColumnWidth = 10;
    cell = sheet.Cells[i, 2];
    cell.Value = d;                                 
    i++;
  }
  dynamic shapes = sheet.Shapes;
  shapes.AddChart(-4100, 120, 2, 300, 200);           
}
Note that the communication need not be one way as shown in listing 32.5. You can
also wire up Excel data change events to update the data back in your own Silverlight
application, essentially making Excel an extension of your application as opposed to
simply a report writing tool.
 That’s impressive from what’s otherwise thought of as a web application technol-
ogy. Though you can’t actually embed Office UI (such an Excel worksheet) into your
application, the ability to automate Excel and other Office applications helps to make
Silverlight ready for business.
 Special among the elevated trust features, the COM capabilities are almost endless
but should be used with discretion and caution. This feature provides yet another
option for creating Windows client applications.
Listing 32.5
Automating Excel to create data and a chart
Create worksheet
Add value to cell

839
Native Extensions for Silverlight
COM automation is exciting, powerful, and a little scary. The sky is the limit with
what you can do. A great example of COM automation taken to the next level is the
Native Extensions for Silverlight, which I’ll cover next.   
32.2
Native Extensions for Silverlight
With the release of .NET 4, WPF gained access to a number of Windows 7–specific APIs
through XAML and additional classes. WPF applications could work with sensors and
location, integrate with the taskbar, use speech, and much more. This left Silverlight
developers wanting for capabilities only present in their big brother. COM automation
provided some of the features, but the delta between WPF and Silverlight was huge.
 Some enterprising folks at Microsoft then developed and released a set of COM
automation servers and Silverlight wrapper classes to help close that gap. Considering
this was a side project of mostly one person, the amount completed here was amazing.
With these servers and libraries, collectively referred to as the Native Extensions for
Silverlight (NESL), Silverlight gained access to almost everything WPF had in terms of
Windows 7 integration.
 You can obtain the installer for NESL from http://archive.msdn.microsoft.com/
nesl, and you’ll install it in a moment. Here’s a sampling of the features provided by
NESL:
■
Sensor and device access
■
Touch gesture, manipulation, and inertia support
■
Notification icon integration
■
Speech and speech recognition
■
Taskbar buttons, toolbars, thumbnails, progress bars, and more
Although the functions are necessarily limited to Windows-only machines, NESL sig-
nificantly expands the capabilities available to Silverlight applications. It also serves as
a fascinating example of how to extend Silverlight.
 The architecture of the NESL is quite interesting. First, you have the COM automa-
tion servers. These are written in C++ and wrap a fair bit of existing Win32 API and
COM code, transforming it into COM automation APIs that may be consumed by Sil-
verlight. Then, on the consumer side you have a number of Silverlight classes that
handle the COM calls and expose strongly typed versions of the APIs—APIs that hap-
pen to look very similar to those already exposed in .NET 4. There’s nothing magical
about NESL—if you know C++ (or another language that can write COM automation
libraries), you can create your own NESL-style wrappers for anything you want, includ-
ing custom devices that may not otherwise be accessible to Silverlight.
NESL comes with complete source for the Silverlight libraries but not for the C++
automation servers. For most Silverlight developers, this will be sufficient. NESL also
includes a great set of examples with complete source code. One of them, the
ChildrensBook sample project, shows off speech and some of the sensors.

840
CHAPTER 32
COM, Native Extensions, and p-invoke
 In this section, you’ll learn how to use NESL in your own applications. You’ll first
look at the accelerometer, something both fun and useful, especially on tablets and
slates. The sample application will enable you to use an accelerometer much like
you’d use a joystick. Then, you’ll see how to integrate with the Windows 7 taskbar to
provide a progress indicator. This is a great way to light up your Silverlight application
when running on Windows. Finally, because it’s interesting in how it was accom-
plished and teaches you some tricks you can use in your own applications, you’ll look
at how the COM automation servers are installed on end-user PCs.
32.2.1 Accessing an accelerometer
An accelerometer is a device, often as small or smaller than a shelled sunflower seed,
that can report movement in some combination of the X, Y, and Z planes. Some accel-
erometers only do X and Y, which is sufficient for joysticks. Others will handle all
three. When you tilt your phone (or iPad or Windows slate) to play a game that moves
a marble around the screen, you’re using an accelerometer. Accelerometers are also
used to quickly shut down and park an old-fashioned spinning hard drive in the event
that the device is dropped.
 Accelerometers are typically built into devices. However, external USB accelerome-
ter boards may be purchased from the likes of Freescale Semiconductor. They have an
external board called the JMBADGE2008 (http://bit.ly/JMBadge), which includes an
accelerometer as well as several other Windows Sensor API–compatible sensors. This
board is somewhat difficult to find now, but there are still some out there.
 Of course, you can’t really follow this particular example unless you have one of
those sensor boards installed on your system. I have information on setting up the Fre-
escale sensor on your system at my blog: http://bit.ly/10RemFreescale. Even if you
don’t have the sensor, you’ll want to follow the next steps and install and recompile
the Native Extensions. 
INSTALL AND RECOMPILE THE NATIVE EXTENSIONS
First, download and install NESL from the URL given in the introduction to this sec-
tion. You’ll want to download both the Runtime and the Source zip files. Once they’re
downloaded, unzip both files into a known location on your machine—for example,
in a subfolder of your projects folder.
 Run the included installer for the COM Automation libraries. This is a simple MSI
that installs some native code onto your machine.
 Because this is the first Silverlight 5 project you’ve built with the Native Extensions,
and because the Native Extensions target Silverlight 4, you need to do a small recom-
pile. Open the solution found in the Source folder. On the version I’m writing
against, it’s named NESLSourcev2.sln.2
2 After I wrote this chapter, a patch bringing everything up to version 2.1 was released. Use the latest version.

841
Native Extensions for Silverlight
The solution has two folders, one for libraries and one for the samples. If you’re using
a free version of Visual Studio, those folders may not be present. You’ll be working
with the Silverlight libraries first.
 For each of the Silverlight libraries projects, go to its project properties and
change the target version to Silverlight 5, as shown in figure 32.2.
 I admit that this isn’t strictly necessary, but I hate referencing DLLs from other ver-
sions of any framework, especially Silverlight. Recompiling to Silverlight 5 guarantees
that you’ll get the expected behavior and compile-time warnings or errors, when avail-
able, due to any breaking changes.3
 Once you’ve completed that, do the same for the samples. Because they’re in the
same solution, you’ll need to update them to avoid a whole mess of compile errors.
Once complete, do a Rebuild All, and you’re done with that part. Take note of where
the projects are stored and compiled to.
PROJECT SETUP
Now create a new Silverlight 5 project; I named mine NeslSensorDemo. Add a refer-
ence to the Microsoft.Silverlight.Windows.dll from the NESL bin/debug folder. This
3 Mostly it just gives me a warm fuzzy.
Figure 32.2
Change each of the library project’s build properties to target Silverlight 5.

842
CHAPTER 32
COM, Native Extensions, and p-invoke
will drag along a dependency on Microsoft.CSharp.dll for the dynamic keyword, as
seen in section 32.1. Remember, NESL is just using COM automation under the covers.
 The library you’ll be primarily working with is the Microsoft.Silverlight.Win-
dows.Sensors library. That has a dependency on Microsoft.Silverlight.Windows.Plat-
form, so add references to both of those as well.
 Before you create the test UI, you’ll need to create the AccelerometerJoystick
class. This class interfaces with NESL to perform the hard work of creating the acceler-
ometer and then translating its movement to the cardinal points of a compass. Listing
32.6 has the code required to find the accelerometer and initialize it.
using System;
using System.Linq;
using System.Windows;
using Microsoft.Silverlight.Windows.Platform;
using Microsoft.Silverlight.Windows.Sensors;
namespace NeslSensorDemo
{
  public class AccelerometerJoystick : IDisposable    
  {
    private SensorManager _sensorManager = null;
    private Sensor _accelerometer = null;
    private PropertyKey _keyXGs = null;
    private PropertyKey _keyYGs = null;
    public AccelerometerJoystick()
    {
      if ((Application.Current.HasElevatedPermissions) &&
          (AutomationFactory.IsAvailable))
      {
        _sensorManager = new SensorManager();
        _accelerometer = GetFirstAccelerometer();
          if (_accelerometer != null)
          {
            _keyXGs = new PropertyKey(                    
              MotionDataFields.Base, 
              MotionDataFields.SENSOR_DATA_TYPE_ACCELERATION_X_G);
            _keyYGs = new PropertyKey(
              MotionDataFields.Base,
              MotionDataFields.SENSOR_DATA_TYPE_ACCELERATION_Y_G);
            _accelerometer.SensorDataUpdated += 
              new EventHandler<SensorDataUpdatedEventArgs>(
                Accelerometer_SensorDataUpdated);
          }
          else
          {
            throw new Exception("No accelerometers found.");
Listing 32.6
The AccelerometerJoystick class structure and main functions
IDisposable
Property keys

843
Native Extensions for Silverlight
          }
        }
        else
        {
          throw new Exception(
             "Elevated permissions required to use the accelerometer.");
        }
      }
    private Sensor GetFirstAccelerometer()             
    {
      Return  _sensorManager.GetSensorsByCategory(
              SensorCategories.SENSOR_CATEGORY_MOTION)
              .ToList()
              .FirstOrDefault();
    }
                                                     
  }
}
Listing 32.6 includes the definition for the AccelerometerJoystick class as well as the
initialization functions. When using the Sensor API in Windows, without a friendlier
wrapper the data you get back is based on key-value pairs. A good practice is to set up
the property keys ahead of time, and set them aside for use in the sensor reporting
event. That’s what you did here. Note that you’re only getting the X and Y accelera-
tion G force values. You’re ignoring the Z force.
 Inside the GetFirstAccelerometer function, the code looks for the first accelerom-
eter in the system and uses it. That’s hardly robust, but typically a computer won’t have
more than one accelerometer. So, for the sake of demonstration, it’s good enough. 
public bool IsPointedNorth { get; private set; }         
public bool IsPointedSouth { get; private set; }        
public bool IsPointedEast { get; private set; }       
public bool IsPointedWest { get; private set; }       
private const double _sensitivity = 0.3;        
public event EventHandler OrientationChanged;     
private void Accelerometer_SensorDataUpdated(
            object sender, SensorDataUpdatedEventArgs args)
{
  var values = args.NewData.GetSensorValues(
          new PropertyKey[] {_keyXGs, _keyYGs}).ToList();
  double gForceX = Convert.ToDouble(values[0].Value);   
  double gForceY = Convert.ToDouble(values[1].Value);    
  bool north = false, south = false, 
       east = false, west = false ;
  if (Math.Abs(gForceX) > _sensitivity)
Listing 32.7
The AccelerometerJoystick class reporting code
Get accelerometer
Remaining 
methods 
go here
Direction 
properties
OrientationChanged
Get data

844
CHAPTER 32
COM, Native Extensions, and p-invoke
  {
    if (gForceX > 0)
      east = true;
    else
      west = true;
  }
  if (Math.Abs(gForceY) > _sensitivity)
  {
    if (gForceY > 0)
      south = true;
    else
      north = true;
  }
  if (east != IsPointedEast || west != IsPointedWest ||
      north != IsPointedNorth || south != IsPointedSouth)
  {
    IsPointedNorth = north;
    IsPointedSouth = south;
    IsPointedEast = east;
    IsPointedWest = west;
    if (OrientationChanged != null)                 
      OrientationChanged(this, EventArgs.Empty);
  }
}
Listing 32.7 contains the AccelerometerJoystick code for reporting the g-force
changes back in the form of joystick directions represented by four bool properties,
each representing a cardinal point.
 Each time the sensor reports a new set of values, the code uses the cached property
keys to retrieve the X and Y g-forces. It then checks to see if the value reported is
greater than the sensitivity constant. This is to allow some tilt without constantly
changing direction on you. For my accelerometer (and presumably most others), the
values reported back are 0 for center, and negative or positive values for the opposite
directions on a given axis. Finally, it checks to see if the new direction is different from
the currently set direction. If that’s true, it sets the properties and raises an Orienta-
tionChanged event.
 The NESL SensorManager and Sensor classes both implement IDisposable.
Because you’re keeping class-level references to them, you also need to implement
IDisposable. Remember, this code bridges out to COM, so releasing those resources
is extra important. The code for the IDisposable implementation4 is in listing 32.8.
~AccelerometerJoystick()                             
{
  Dispose();
}
Listing 32.8
The AccelerometerJoystick class cleanup code
4 You can find an overview of the Dispose pattern here: http://bit.ly/DisposePattern.
Raise OrientationChanged
Finalizer

845
Native Extensions for Silverlight
private bool _disposed = false;
public void Dispose()                          
{
  Dispose(true);
  GC.SuppressFinalize(this);
}
protected virtual void Dispose(bool disposing)
{
  if (!_disposed)
  {
    if (disposing)
    {
      if (_accelerometer != null)
        _accelerometer.Dispose(); 
      if (_sensorManager != null)
        _sensorManager.Dispose();  
     }
     _accelerometer = null;
     _sensorManager = null;
   }
 }
The code in listing 32.8 handles the cleanup of the class and its resources, to help
ensure that the COM objects are properly released. Place it near the end of the Accel-
erometerJoystick class and you’re ready to start using it.
 The demo application will show how to use the X and Y axes of the accelerometer,
so you’ll create something like a joystick. You’ll light up the appropriate location in a
nine grid when the accelerometer is tilted in that direction. The application will look
like figure 32.3.
Dispose 
implementation
Dispose resources
Figure 32.3
The running accelerometer 
demo application

846
CHAPTER 32
COM, Native Extensions, and p-invoke
The UI consists of a nine grid, like a tic-tac-toe board, implemented as a regular old
grid. Inside each of the outer cells, you have a rectangle and text. The default style for
the rectangle is defined using an implicit style (see chapter 14). The style for the
TextBlocks with the compass points is also defined using an implicit style. I’ll talk
some more about the styles in use after the code. Listing 32.9 shows the full XAML for
the UI.
<UserControl x:Class="NeslSensorDemo.MainPage"
  xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
  xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
  xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
  mc:Ignorable="d"
  d:DesignHeight="400" d:DesignWidth="400">
  <UserControl.Resources>
    <Style x:Key="BaseRectangleStyle" TargetType="Rectangle"> 
      <Setter Property="Fill" Value="White" />
      <Setter Property="Stroke" Value="Gray" />
      <Setter Property="Margin" Value="5" />
    </Style>
    <Style TargetType="Rectangle"
           BasedOn="{StaticResource BaseRectangleStyle}" />
    <Style x:Key="SelectedRectangle" TargetType="Rectangle" 
           BasedOn="{StaticResource BaseRectangleStyle}">
      <Setter Property="Fill" Value="LightGreen" />
      <Setter Property="Stroke" Value="Black" />
    </Style>
    <Style x:Key="DeselectedRectangle" TargetType="Rectangle"
           BasedOn="{StaticResource BaseRectangleStyle}" />
    <Style TargetType="TextBlock">                   
      <Setter Property="FontSize" Value="40" />
      <Setter Property="HorizontalAlignment" Value="Center" />
      <Setter Property="VerticalAlignment" Value="Center" />
    </Style>
  </UserControl.Resources>
  <Grid x:Name="LayoutRoot" Background="White">
    <Grid x:Name="NineGrid" Width="300" Height="300"   
          Background="LightGray">
      <Grid.ColumnDefinitions>
        <ColumnDefinition />
        <ColumnDefinition />
        <ColumnDefinition />
      </Grid.ColumnDefinitions>
      <Grid.RowDefinitions>
        <RowDefinition />
        <RowDefinition />
Listing 32.9
The UI XAML for the accelerometer demo application
Base 
rectangle 
style
Selected
style
Deselected
style
TextBlock style
Nine grid

847
Native Extensions for Silverlight
        <RowDefinition />
      </Grid.RowDefinitions>
      <Rectangle x:Name="NorthWest" Grid.Row="0" Grid.Column="0" />
      <Rectangle x:Name="North"     Grid.Row="0" Grid.Column="1" />
      <Rectangle x:Name="NorthEast" Grid.Row="0" Grid.Column="2" />
      <Rectangle x:Name="WestWest"  Grid.Row="1" Grid.Column="0" />
      <Rectangle x:Name="East"      Grid.Row="1" Grid.Column="2" />
      <Rectangle x:Name="SouthWest" Grid.Row="2" Grid.Column="0" />
      <Rectangle x:Name="South"     Grid.Row="2" Grid.Column="1" />
      <Rectangle x:Name="SouthEast" Grid.Row="2" Grid.Column="2" />
      <TextBlock Text="NW" Grid.Row="0" Grid.Column="0" />
      <TextBlock Text="N"  Grid.Row="0" Grid.Column="1" />
      <TextBlock Text="NE" Grid.Row="0" Grid.Column="2" />
      <TextBlock Text="W"  Grid.Row="1" Grid.Column="0" />
      <TextBlock Text="E"  Grid.Row="1" Grid.Column="2" />
      <TextBlock Text="SW" Grid.Row="2" Grid.Column="0" />
      <TextBlock Text="S"  Grid.Row="2" Grid.Column="1" />
      <TextBlock Text="SE" Grid.Row="2" Grid.Column="2" />
    </Grid>
  </Grid>
</UserControl>
In addition to the styles already mentioned, listing 32.9 includes two important keyed
styles as resources. The first style defines what the rectangles should look like when
they’re selected—that is, what they should look like when the joystick is pointed in
their direction. The second defines the deselected look. Because deselected is the
default look, the style is empty except for referring back to the base style.
 When the joystick is moved in a particular direction, the rectangle representing
that direction is “lit up” using the appropriate style. 
using System;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Shapes;
namespace NeslSensorDemo
{
  public partial class MainPage : UserControl
  {
    private AccelerometerJoystick _joystick;
    private Style _selectedStyle;
    private Style _deselectedStyle;
    public MainPage()
    {
      InitializeComponent();
      Loaded +=new RoutedEventHandler(MainPage_Loaded);
    }
Listing 32.10
Code-behind for the main page

848
CHAPTER 32
COM, Native Extensions, and p-invoke
    private void MainPage_Loaded(object sender, RoutedEventArgs e)
    {
      try
      {
        _selectedStyle =                             
          Resources["SelectedRectangle"] as Style;   
        _deselectedStyle =                           
          Resources["DeselectedRectangle"] as Style; 
        _joystick = new AccelerometerJoystick();
        _joystick.OrientationChanged += 
            new EventHandler(JoystickOrientationChanged);
      }
      catch (Exception ex)
      {
        MessageBox.Show(ex.ToString());
      }
    }
    private void JoystickOrientationChanged(object sender, EventArgs e)
    {
      foreach (UIElement child in NineGrid.Children) 
      {
        if (child is Rectangle)
          ((Rectangle)child).Style = _deselectedStyle;
      }
      if (_joystick.IsPointedNorth &&      
          _joystick.IsPointedEast)          
        NorthEast.Style = _selectedStyle;     
      else if (_joystick.IsPointedNorth &&   
               _joystick.IsPointedWest)      
        NorthWest.Style = _selectedStyle;      
      else if (_joystick.IsPointedSouth &&   
               _joystick.IsPointedEast)     
        SouthEast.Style = _selectedStyle;     
      else if (_joystick.IsPointedSouth &&    
               _joystick.IsPointedWest)   
        SouthWest.Style = _selectedStyle;     
      else
      {
        if (_joystick.IsPointedSouth)        
          South.Style = _selectedStyle;      
        else if (_joystick.IsPointedEast)     
          East.Style = _selectedStyle;        
        else if (_joystick.IsPointedWest)      
          WestWest.Style = _selectedStyle;    
        else if (_joystick.IsPointedNorth)   
          North.Style = _selectedStyle;
      }
    }
  }
}
Cache styles
Resetting of 
all rectangles
Secondary 
compass points
Cardinal 
compass points

849
Native Extensions for Silverlight
The code in listing 32.10 creates the AccelerometerJoystick class and then wires up
the OrientationChanged event. Each time the orientation changes, it updates the UI
by applying a style to the appropriate rectangle. Note how this code translates a simul-
taneous two-point value into one of the secondary compass points (Northeast, South-
west, etc.).
 With this final bit of code in place, run the application. When you tilt the acceler-
ometer, you should see the different squares light up on the screen. If you’re using the
Freescale board and aren’t seeing any results, run their test program to be sure the
board is working and the driver is installed. Don’t forget to enable the sensor in the
Control panel in Windows as described in my blog post at http://bit.ly/
10RemFreescale.
 It may seem like a fair bit of code to accomplish what you did here. But if you think
about what just happened, it’s amazing. You took a web technology, had it talk to a set
of custom C++ COM automation servers, which then talked to the Windows 7 Sensor
and Location API, and returned back g-force information whenever a board was tilted.
That’s awesome. 
 Of course, the accelerometer is interesting and has lots of practical uses. It’s
unlikely, though, that most people will have one on their work PC.5 Another use of
NESL is to integrate with the Windows 7 taskbar, something almost every application
can take advantage of. 
32.2.2 Integrating with the Windows taskbar
Windows 7 introduced a completely new taskbar. Up until then, the taskbar has con-
ceptually remained the same since Windows 95. Windows 7 broke slightly with the
past and added more functionality to the taskbar buttons, enabled pinning them
directly in place, added support for status reporting, and added icon overlays, jump
lists, thumbnail images, thumbnail toolbars, and more.
 Up until the introduction of NESL, Silverlight applications had no way to integrate
with the taskbar. They couldn’t do things like add “Play” and “Pause” buttons and
jump list items to the toolbar and menu. If you wrote media applications, you instantly
looked behind more integrated applications such as Windows Media Player and Zune.
 One of the most commonly used Windows 7 taskbar features is setting the value of
a progress bar that appears on the button for your application. You may have seen this
in use when downloading a large file using Internet Explorer 9.
5 Although a “Tilt your PC to make the data fall in the right text box” or “Tilt to sort the grid” functionality
could be interesting and amusing despite likely not being well received by management.

850
CHAPTER 32
COM, Native Extensions, and p-invoke
 Although you typically see only the green progress state, there are five possible
states in Windows, all included in the TaskbarItemProgressState enumeration.
Table 32.1 lists them.
When deciding whether to use progress reporting on your taskbar button, keep in
mind that it should report something that’s useful when the application doesn’t have
focus. Don’t use it for simple save progress or common “downloading another mes-
sage” progress. I recommend that it not be used for things like generating on-demand
reports and other actions where the user will be sitting in front of the application,
waiting on completion. Do use it when the action could take a long time without typi-
cally requiring any user intervention and when users don’t need to take an action
immediately upon completion.
THE TASKBAR SAMPLE UI
Make sure you have completed the recompile of NESL as shown in the previous sec-
tion. Once that’s complete, you’ll create a small sample out-of-browser application
that shows the different progress bar states. Figure 32.4 shows this application running
with a progress indicator on the taskbar button.
Table 32.1
The five possible taskbar button progress bar states in Windows
State
Example
Use
None
Normal taskbar usage without any progress indicator.
Indeterminate
Indicates a busy state with an unknown duration. Represented by a 
pulsing green indicator.
Normal
A green progress indicator. This is the normal progress indicator.
Error
A red progress indicator. This is used to tell the user that some-
thing went wrong.
Paused
A yellow progress indicator. This is used to tell the user that the 
action has been paused. Perhaps the user paused it, or perhaps 
the application is requesting additional information via a dialog.

851
Native Extensions for Silverlight
The application has buttons for each of the available progress states. In addition, it has
an on-page progress bar that’s used to give you something to compare the taskbar but-
ton progress indicator to. Listing 32.11 shows the XAML for the UI for the application.
<UserControl x:Class="NeslTaskbarDemo.MainPage"
  xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
  xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
  xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
  mc:Ignorable="d"
  d:DesignHeight="300" d:DesignWidth="400">
  <UserControl.Resources>
    <Style TargetType="Button">
      <Setter Property="Margin" Value="5" />
      <Setter Property="Width" Value="160" />
      <Setter Property="Height" Value="25" />
    </Style>
  </UserControl.Resources>
  <Grid x:Name="LayoutRoot" Background="White">
    <Grid x:Name="NoAutomation" Visibility="Collapsed">   
      <TextBlock Text="This example requires COM automation support" />
    </Grid>
    <StackPanel x:Name="Example" Margin="10">
      <Button x:Name="SetNoState" 
              Content="No Progress"
              Click="SetNoState_Click" />
Listing 32.11
The XAML UI for the taskbar progress example
Figure 32.4
The taskbar demo application. Notice how the progress bar on the application 
and the taskbar button on the far right both convey status to the user.
Error overlay

852
CHAPTER 32
COM, Native Extensions, and p-invoke
      <Button x:Name="SetIndeterminateState"
              Content="Indeterminate Progress"
              Click="SetIndeterminateState_Click" />
      <Button x:Name="SetNormalState"
              Content="Normal Progress"
              Click="SetNormalState_Click" />
      <Button x:Name="SetPausedState"
              Content="Paused Progress"
              Click="SetPausedState_Click" />
      <Button x:Name="SetErrorState"
              Content="Error Progress"
              Click="SetErrorState_Click" />
      <ProgressBar x:Name="ProgressBar"               
                   Minimum="0" Maximum="100"
                   Height="18" Margin="20" />
    </StackPanel>
  </Grid>
</UserControl>
The UI is primarily composed of a StackPanel containing buttons that’ll be used to
demonstrate the different progress states. In addition, you include a progress bar so
that you can compare the progress between the bar and the taskbar. Although it’s com-
mon to have both a progress bar and a taskbar progress indicator, it’s not required.
 You also include an overlay grid that’ll display a message if the user doesn’t have
COM automation support. A common pattern in applications that require elevated
trust or COM automation is to hide the UI and simply display a message.
 Listing 32.12 shows the code-behind for the main page of the demonstration appli-
cation. Before adding this code, be sure to add a reference to the NESL DLLs:
■
Microsoft.Silverlight.Windows.dll
■
Microsoft.Silverlight.Windows.Taskbar.dll 
Also add a reference to the Microsoft.CSharp.dll if that’s not automatically pulled in.
using System;
using System.Windows;
using System.Windows.Controls;
using Microsoft.Silverlight.Windows.Taskbar;
using System.Runtime.InteropServices.Automation;
using System.Windows.Threading;
namespace NeslTaskbarDemo
{
  public partial class MainPage : UserControl
  {
    private bool _showingProgress = false;
    public MainPage()
    {
      InitializeComponent();
Listing 32.12
Partial code-behind for the taskbar progress example
Progress bar

853
Native Extensions for Silverlight
      Loaded += new RoutedEventHandler(MainPage_Loaded);
    }
    void MainPage_Loaded(object sender, RoutedEventArgs e)
    {
      if (AutomationFactory.IsAvailable)                
      {
        Example.Visibility = Visibility.Visible;
        NoAutomation.Visibility = Visibility.Collapsed;
        var timer = new DispatcherTimer();
        timer.Interval = TimeSpan.FromMilliseconds(500);
        timer.Tick += (s, ea) =>
        {
          if (_showingProgress)
          {
            ProgressBar.Value += 1;
            if (ProgressBar.Value >= ProgressBar.Maximum)
              ProgressBar.Value = ProgressBar.Minimum;
              TaskbarButton.Current.SetProgressValue( 
                     (ulong)ProgressBar.Value,
                     (ulong)ProgressBar.Maximum);
          }
        };
        timer.Start();
      }
      else
      {
        Example.Visibility = Visibility.Collapsed;
        NoAutomation.Visibility = Visibility.Visible;
      }
    }
                                               
  }
}
When the page is loaded, you first check to see if COM automation is available. If so,
you make the application UI visible and set up and start a timer, which will be used to
update the progress value on both the in-application progress bar and the taskbar
progress indicator. When the progress bar reaches the end, you start it back over. You
wouldn’t normally do this in an application, but it makes sense for a feature demo.
SETTING PROGRESS STATE
The code in listing 32.12 is all of the code-behind except for the button click event
handlers. Listing 32.13 covers those. Each handler is responsible for setting the
appropriate taskbar state, keeping the progress bar state in sync, and updating the
showingProgress variable to indicate whether the taskbar is showing some level of
Check permissions
Set taskbar 
progress value
Click event 
handlers go here

854
CHAPTER 32
COM, Native Extensions, and p-invoke
progress. This last item is required for indeterminate state to work correctly in
the demo.
private void SetNoState_Click(object sender, RoutedEventArgs e)
{
  TaskbarButton.Current.SetProgressState( 
                TaskbarItemProgressState.None);
  _showingProgress = false;
  ProgressBar.IsIndeterminate = false;
}
private void SetIndeterminateState_Click(        
          object sender, RoutedEventArgs e)
{
  TaskbarButton.Current.SetProgressState(
                TaskbarItemProgressState.Indeterminate);
  _showingProgress = false;
  ProgressBar.IsIndeterminate = true; 
}
private void SetNormalState_Click(object sender, RoutedEventArgs e)
{
  TaskbarButton.Current.SetProgressState(
                TaskbarItemProgressState.Normal);
  _showingProgress = true;
  ProgressBar.IsIndeterminate = false;
}
private void SetPausedState_Click(object sender, RoutedEventArgs e)
{
  TaskbarButton.Current.SetProgressState(              
                TaskbarItemProgressState.Paused);
  _showingProgress = true;
  ProgressBar.IsIndeterminate = false;
}
private void SetErrorState_Click(object sender, RoutedEventArgs e)
{
  TaskbarButton.Current.SetProgressState(
                TaskbarItemProgressState.Error);
  _showingProgress = true;
  ProgressBar.IsIndeterminate = false;
}
The handlers are mostly identical, but with different values passed into Set-
ProgressState. The one exception is the indeterminate state, which requires you to
set a flag to stop the timer from updating the progress value. If you update the prog-
ress value while in this state, the taskbar indicator reverts back to displaying a normal
progress bar.
 Run the application and try out the different buttons. Note the color differences as
well as the presentation difference for the indeterminate state. If you got an error
Listing 32.13
Button click handlers for the taskbar demo main page
Indeterminate state
Set progress state

855
Native Extensions for Silverlight
about security, remember to make the application run as an out-of-browser applica-
tion with elevated trust, as described in chapter 6.
 Especially when combined with other taskbar features such as overlay icons, jump
lists, thumbnail buttons, and more, the taskbar progress indicator provides a way to
make your application more seamlessly integrate with the Windows experience. When
used correctly, these features provide that extra bit of oomph that helps your applica-
tion resonate better with your end users.
 The Windows 7 taskbar integration functions are useful in all types of applications,
from consumer to business. They add a touch of professionalism to an application
when they properly integrate with the OS services. 
 One of the most interesting aspects of NESL isn’t a Windows function it surfaces,
but how it goes about installing the bits at runtime.
32.2.3 Runtime automation server installation
NESL requires a number of COM automation servers (DLLs) to be installed on the
local machine in order for it to work. This installation process is well outside the usual
download-and-run approach used by Silverlight.
 I’ve seen similar requirements for applications in the past. What usually ends up
happening is that the application gives the user a link to an MSI or something similar
to run, or in a corporate environment, policy pushes the MSI down to the workstation.
Both are reasonable approaches for a web technology, but the NESL developers
wanted to provide something even easier.
NESL applications can, if you desire, include the MSI with the COM automation
servers right in the XAP. At runtime, you can check to see whether the libraries are
installed and, if not, tell NESL to go ahead and extract the MSI and perform an instal-
lation. A subset of the NESL code that performs the extraction and installation is
shown in listing 32.14. Don’t attempt to type this code in and run it; it’s here only to
show you some of the more interesting parts of Silverlight code (I’ve removed the
error checking and exception handling for brevity). The full source code is included
with NESL and the NESL samples.
public static bool CheckNESLInstalled(int MajorVersion, int MinorVersion)
{
  if (!AutomationFactory.IsAvailable)
    return false;
  dynamic Installer = AutomationFactory.CreateObject(
                       "WindowsInstaller.Installer");     
  dynamic ProductState = Installer.ProductState[ProductCode];
  if ((int)ProductState != INSTALLSTATE_DEFAULT)
    return false;
  string verString = 
     Installer.ProductInfo[ProductCode, "VersionString"] as string;
Listing 32.14
A subset of NESL that handles extraction and installation
Automate 
Windows 
Installer

856
CHAPTER 32
COM, Native Extensions, and p-invoke
  var verParts = verString.Split('.').Select(s =>
     Convert.ToInt32(s)).ToList();
  if (MajorVersion > verParts[0] || 
     (MajorVersion == verParts[0] && 
      MinorVersion > verParts[1]))
    return false;
  return true;
}
public static void InstallNESL(
    Uri NESLPackageUri, bool Remote = true, bool ShowProgress = true)
{
  dynamic Installer = AutomationFactory.CreateObject(
                            "WindowsInstaller.Installer");
  Installer.UILevel = ShowProgress ? 
                    INSTALLUILEVEL_BASIC | INSTALLUILEVEL_HIDECANCEL :
                    INSTALLUILEVEL_NONE;
  string PackagePath = (Remote == true) ? 
                    NESLPackageUri.ToString() :
                    ExtractNESLPackageFromXAP(NESLPackageUri); 
  Installer.InstallProduct(PackagePath, "ACTION=INSTALL");     
  System.IO.File.Delete(PackagePath);
    
 return;
}
private static string ExtractNESLPackageFromXAP(Uri NESLPackageUri)
{
  string PackageTempPath = Path.Combine(
      Environment.GetFolderPath(
              Environment.SpecialFolder.MyDocuments), 
           Guid.NewGuid().ToString() + ".msi");              
  StreamResourceInfo sri = Application.GetResourceStream(NESLPackageUri);
  if (sri != null)
  {
    FileStream fs = new FileStream(PackageTempPath,   
             FileMode.Create, FileAccess.ReadWrite, 
             FileShare.None);
    BinaryReader br = new BinaryReader(sri.Stream); 
    fs.Write(br.ReadBytes((int)sri.Stream.Length), 0,        
                             (int)sri.Stream.Length);        
    fs.Close();
    sri.Stream.Close();
  }
  return PackageTempPath;
}
That’s some nifty COM automation going on here! The code shows how to package
something in a XAP, read it back out, and write it to the filesystem so that it may
Install
Get MSI path
Read/write MSI

857
P-invoke for API calls
be executed. Packaging other components with your XAP, whether they install COM
automation servers, socket servers, or something else, is a nice option to have when
trying to get bits on the end-user machines. Of course, the MSI installation requires
administrator rights on the part of the user, a significant limitation in many cases.
 Nevertheless, I think this is a useful technique that you may wish to exploit in some
of your own applications—for example, if your application integrates with a third-
party device and you must have an automation server installed to use it. You could also
use this approach to install your own DLLs for p-invoke support, our next topic.
32.3
P-invoke for API calls
Platform Invoke (p-invoke) is a .NET feature that enables you to call traditional Win32
API–style DLL functions. P-invoke is all about entry points into a library, resolved as
function pointers. This is in contrast to COM automation, which is interface based and
late bound.
 Functional DLL APIs are one of the oldest technologies in Windows. You used to
make calls out to the Win32 API (back in the Visual Basic 3 days) to handle all the
things VB lacked. When .NET arrived on the scene the better part of a decade later, it
brought with it a huge base class library, which negated the need for many of those
API calls. But the need was still there in cases, so the .NET Framework included
p-invoke. It has been with us ever since.
 Because of how long the Win32 API (and the Windows API before it) has been
around, there are tons of functions available. In fact, each new version of Windows
introduces hundreds and sometimes thousands of new API calls that applications can
use to take advantage of Windows’ features.
 The Win32 API is certainly a driver for including p-invoke in Silverlight, but it isn’t
the only one. Many domain-specific devices come with their own Win32-style DLLs.
Consider medical applications, which must integrate with sensors and medical diag-
nostics equipment; industrial automation applications, which must use machine inter-
faces provided as straight DLLs; and much more. All of these types of uses are now
available with Silverlight through p-invoke.
 Throughout the rest of this section you’ll look at one interesting use of p-invoke:
accessing system printer information. You’ll see how to call the API to get the list of
printers, and learn what types of things to expect when working with Win32 APIs from
Silverlight. You’ll also explore some techniques for encapsulating the call and map-
ping to Silverlight-friendly structures.
32.3.1 Setting up the printer application
There are many different things you can do with the Win32 API. I’ll look at one that
requires a number of support structures, highlight some areas missing in the Marshal
class in Silverlight, and show you how to work around those areas. I’ll also show you
something useful that can potentially be used in a typical Silverlight application. 

858
CHAPTER 32
COM, Native Extensions, and p-invoke
The scenario I chose is enumerating the printers installed on the system. The exam-
ple application will fill a ListBox with all the printers currently installed on the sys-
tem, as shown in figure 32.5.
 The first thing to do is create the XAML UI. For this example, you’ll replace the
standard StackPanel layout of the ListBox with a WrapPanel. Listing 32.15 shows how
the whole UI fits together, including the ListBox ItemsPanel and ItemsTemplate.
<UserControl x:Class="SilverlightEnumPrinters.MainPage"
  xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
  xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
  xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
  xmlns:toolkit=
"http://schemas.microsoft.com/winfx/2006/xaml/presentation/toolkit"             
  mc:Ignorable="d" d:DesignHeight="300" d:DesignWidth="400">
  <Grid x:Name="LayoutRoot" Background="White">
    <ListBox x:Name="PrinterList" Margin="10"
             ScrollViewer.HorizontalScrollBarVisibility="Disabled">
      <ListBox.ItemsPanel>
        <ItemsPanelTemplate>
          <toolkit:WrapPanel />                 
        </ItemsPanelTemplate>
      </ListBox.ItemsPanel>
      <ListBox.ItemTemplate>
        <DataTemplate>
          <toolkit:HeaderedContentControl Margin="20" 
                            Width="275" Height="150">
            <toolkit:HeaderedContentControl.Header>
Listing 32.15
XAML UI for the printer list application
Figure 32.5
The printer enumeration application using a ListBox with a WrapPanel, all bound to a 
collection of printers returned from a Win32 API call
WrapPanel
HeaderedContentControl

859
P-invoke for API calls
              <TextBlock Text="{Binding PrinterName}"
                         FontWeight="Bold" FontSize="14"/>
            </toolkit:HeaderedContentControl.Header>
            <toolkit:HeaderedContentControl.Content>
              <Grid>
                <Grid.ColumnDefinitions>
                  <ColumnDefinition Width="100" />
                  <ColumnDefinition Width="*" />
                </Grid.ColumnDefinitions>
                <Grid.RowDefinitions>
                  <RowDefinition Height="Auto" />
                  <RowDefinition Height="Auto" />
                  <RowDefinition Height="Auto" />
                  <RowDefinition Height="Auto" />
                  <RowDefinition Height="Auto" />
                </Grid.RowDefinitions>
                <TextBlock Text="Server Name" 
                           Grid.Row="0" Grid.Column="0" />
                <TextBlock Text="{Binding ServerName}"
                           Grid.Row="0" Grid.Column="1" />
                <TextBlock Text="Share Name"
                           Grid.Row="1" Grid.Column="0" />
                <TextBlock Text="{Binding ShareName}"
                           Grid.Row="1" Grid.Column="1" />
                <TextBlock Text="Driver Name"
                           Grid.Row="2" Grid.Column="0" />
                <TextBlock Text="{Binding DriverName}"
                           Grid.Row="2" Grid.Column="1" />
                <TextBlock Text="Location"
                           Grid.Row="3" Grid.Column="0" />
                <TextBlock Text="{Binding Location}"
                           Grid.Row="3" Grid.Column="1" />
                <TextBlock Text="Comment"
                           Grid.Row="4" Grid.Column="0" />
                <TextBlock Text="{Binding Comment}"
                           TextWrapping="Wrap"
                           Grid.Row="4" Grid.Column="1" />
              </Grid>
            </toolkit:HeaderedContentControl.Content>
          </toolkit:HeaderedContentControl>
        </DataTemplate>
      </ListBox.ItemTemplate>
    </ListBox>
  </Grid>
</UserControl>
Each of the items in the ListBox is inside a HeaderedContentControl from the Silver-
light 5 toolkit. This control is a convenience for organization; you could replace it
with nested grids or a grid with the top row cells spanning two columns. If you use the
Printer name

860
CHAPTER 32
COM, Native Extensions, and p-invoke
WrapPanel, be sure to add a reference to System.Windows.Controls.Toolkit.dll version
5.0.5.0.
 Where there’s XAML, there’s usually some code-behind. In our case (listing 32.16),
the code-behind makes a call to the printer service and binds the ListBox to the results.
using System.Windows;
using System.Windows.Controls;
namespace SilverlightEnumPrinters
{
  public partial class MainPage : UserControl
  {
    public MainPage()
    {
      InitializeComponent();
      Loaded += new RoutedEventHandler(MainPage_Loaded);
    }
    void MainPage_Loaded(object sender, RoutedEventArgs e)
    {
      var service = new PrinterService();
      PrinterList.ItemsSource = service.Printers;
      service.LoadPrinters(PrinterEnumFlags.Local);
    }
  }
}
The XAML and the code-behind for the example are now complete, but they won’t
compile without some other classes you’ll create shortly. So far, everything looks like
standard Silverlight. You’ll see why in the next section.
32.3.2 The Win32 API interface
When you’re writing p-invoke code in an application, especially when integrating with
the Win32 API, it’s a best practice to hide the internals as much as possible. Let’s face
it, Win32 API calls tend to be ugly when compared to normal .NET code. Not only that,
but they don’t use quite the same types, often expose handles and other pointers, and
tend to be brittle and picky when used by folks doing things the usual .NET way.
 For that reason, I created the PrinterService class. When the page loads, this
code makes a call to the LoadPrinters method of the PrinterService class. Listing
32.17 includes the PrinterService code.
using System;
using System.Runtime.InteropServices;
using System.Collections.ObjectModel;
Listing 32.16
Code-behind for the main page
Listing 32.17
Printer service
LoadPrinters

861
P-invoke for API calls
namespace SilverlightEnumPrinters
{
  public class PrinterService
  {
    [Flags]
    private enum LocalMemoryFlags                 
    {
      LMEM_FIXED = 0x0000
    }
    [DllImport("winspool.drv", CharSet = CharSet.Auto, 
            SetLastError = true)]
    private static extern bool EnumPrinters(PrinterEnumFlags Flags, 
         string Name, uint Level, IntPtr pPrinterEnum, uint cbBuf, 
         ref uint pcbNeeded, ref uint pcReturned);
    [DllImport("kernel32.dll", EntryPoint = "LocalAlloc")]
    private static extern IntPtr LocalAlloc_NoSafeHandle(
         LocalMemoryFlags uFlags, IntPtr sizetdwBytes);
    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern IntPtr LocalFree(IntPtr hMem);
    private const int ERROR_INSUFFICIENT_BUFFER = 122;
    private ObservableCollection<PrinterInformation> _printers = 
                  new ObservableCollection<PrinterInformation>();
    public ObservableCollection<PrinterInformation> Printers
    {
      get { return _printers; }
    }
    public void LoadPrinters(PrinterEnumFlags Flags)
    {
      Printers.Clear();
      uint cbNeeded = 0;
      uint cReturned = 0;
      if (EnumPrinters(Flags, null, 2, IntPtr.Zero, 0,       
                    ref cbNeeded, ref cReturned))
      {
        return;
      }
      int lastWin32Error = Marshal.GetLastWin32Error();
      if (lastWin32Error == ERROR_INSUFFICIENT_BUFFER)
      {
        IntPtr pAddr = LocalAlloc_NoSafeHandle(           
                LocalMemoryFlags.LMEM_FIXED, (IntPtr)cbNeeded);
        if (EnumPrinters(Flags, null, 2, pAddr, cbNeeded, 
                      ref cbNeeded, ref cReturned))
        {
Partial definition
API
declaration
EnumPrinters
API call
LocalAlloc

862
CHAPTER 32
COM, Native Extensions, and p-invoke
          int offset = pAddr.ToInt32();
          int increment = Marshal.SizeOf(typeof(PRINTER_INFO_2));
   
          for (int i = 0; i < cReturned; i++)
          {
            PrinterInformation printer = new PrinterInformation();
            PRINTER_INFO_2 pinfo = new PRINTER_INFO_2();
            Marshal.PtrToStructure(new IntPtr(offset), pinfo);
            printer.Comment = pinfo.pComment;                
            printer.DriverName = pinfo.pDriverName;            
            printer.Location = pinfo.pLocation;              
            printer.PrinterName = pinfo.pPrinterName;        
            printer.ServerName = pinfo.pServerName;              
            printer.ShareName = pinfo.pShareName;       
            Printers.Add(printer);
            offset += increment;
          }
          LocalFree(pAddr);                                
        }
        else
        {
          lastWin32Error = Marshal.GetLastWin32Error();
          throw new Exception("Win32 Error: " + lastWin32Error);
        }
      }
    }
  }
}
Listing 32.17 includes a partial definition of the LocalMemoryFlags enum to help
reduce the size of this listing. The full definition may be found in the downloadable
source code. After that, you can see the API declarations. These are standard
DLLImport statements just as you’d see on the full desktop CLR.
 The main part of the code first checks for the number of printers available. If
there’s at least one, you then allocate enough memory to hold a buffer of all of them.
Then, you take fixed-sized chunks out of the buffer and marshal them into instances
of a class. This is ugly for Silverlight code, but it’s a standard API approach.
 The Silverlight Marshal class doesn’t include all the overloads and methods you’d
find in the full desktop version of the class. For that reason, listing 32.17 had to use a
different overload of PtrToStructure and pass a class instance as opposed to a
struct. You also couldn’t use AllocHGlobal and had to replace it with the
LocalAlloc_NoSafeHandle API call. Similarly, the LocalFree API call replaces the
FreeHGlobal function, which isn’t included in the Silverlight version of the
Marshal class.
Map to new class
LocalFree

863
P-invoke for API calls
 Once I have the class instances, I map them to a new Silverlight-friendly version of
the class. This class has properties instead of fields and therefore supports binding. 
[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
internal class PRINTER_INFO_2                      
{
    [MarshalAs(UnmanagedType.LPTStr)]
    public string pServerName;
    [MarshalAs(UnmanagedType.LPTStr)]
    public string pPrinterName;
    [MarshalAs(UnmanagedType.LPTStr)]
    public string pShareName;
    [MarshalAs(UnmanagedType.LPTStr)]
    public string pPortName;
    [MarshalAs(UnmanagedType.LPTStr)]
    public string pDriverName;
    [MarshalAs(UnmanagedType.LPTStr)]
    public string pComment;
    [MarshalAs(UnmanagedType.LPTStr)]
    public string pLocation;
    public IntPtr pDevMode;
    [MarshalAs(UnmanagedType.LPTStr)]
    public string pSepFile;
    [MarshalAs(UnmanagedType.LPTStr)]
    public string pPrintProcessor;
    [MarshalAs(UnmanagedType.LPTStr)]
    public string pDatatype;
    [MarshalAs(UnmanagedType.LPTStr)]
    public string pParameters;
    public IntPtr pSecurityDescriptor;
    public uint Attributes;
    public uint Priority;
    public uint DefaultPriority;
    public uint StartTime;
    public uint UntilTime;
    public uint Status;
    public uint cJobs;
    public uint AveragePPM;
}
public class PrinterInformation                       
{
    public string ServerName { get; set; }
    public string PrinterName { get; set; }
    public string ShareName { get; set; }
    public string DriverName { get; set; }
    public string Comment { get; set; }
    public string Location { get; set; }
}
Listing 32.18 includes the full definition of the PRINTER_INFO_2 class which is based
on a structure by the same name. I had to create it as a class in order to support the
Listing 32.18
The PRINTER_INFO_2 and PrinterInformation classes
API-required
structure
Partial definition of 
PrinterInformation

864
CHAPTER 32
COM, Native Extensions, and p-invoke
available version of PtrToStructure in the Silverlight version of the Marshal class.
The layout of the PRINTER_INFO_2 class is important, because it’ll be memory-mapped
using API calls.
 Also included in listing 32.18 is a partial version of the Silverlight binding-friendly
PrinterInformation class. This is what’s exposed to the rest of the application. Silver-
light can only bind to properties, and the Marshal class can only deal with mapping to
fields. Combining the two into one class is a recipe for nastiness. 
 As is often the case when you use the Windows API, this example relies on a fair
number of structures and constants. For completeness, listing 32.19 includes the one
used in the previous listing.
[Flags]
public enum PrinterEnumFlags                     
{
  Default = 0x00000001,
  Local = 0x00000002,
  Shared = 0x00000020,
  Network = 0x00000040,
}
The downloadable source code includes a number of other enumerations as well as
additional values for PrinterEnumFlags.
 With all of that in place, run the application. Make sure you’re running in elevated
permissions mode. If everything is right, you should see a list of printers available to
your machine.
 There are a number of other Win32 API calls that let you perform additional oper-
ations with the printer information received. To explore those and others, you can
visit http://pinvoke.net. Keep in mind that the code you find there will be mostly
compatible with Silverlight, but some Marshal overloads may not be present. When in
doubt, use .NET Reflector or something similar to see what the desktop framework is
doing inside those methods; typically it’s another API call you can make yourself.
Listing 32.19
The remaining constants
Bonus feature: unsafe code and pointers
When the Silverlight team brought over the CLR support for p-invoke, they had to sup-
port unsafe code at the same time. Although not officially supported, the unsafe code
support is usable by you in your own applications.
Unsafe code enables pointer arithmetic and other unverifiable operations. For exam-
ple, this code puts part of a string into a TextBlock using pointers:
private void UnsafeButton_Click(object sender, RoutedEventArgs e)
{
    unsafe
    {      
Abbreviated
list of flags

865
Summary
32.4
Summary
Integrating with the OS, and with other applications on the machine, lets you make
your application larger than you could code by yourself. Rather than recreate spread-
sheet functionality, you can simply automate Excel. Need mail merge? Automate
Word. 
 The integration is bigger than just saving time. Integrating with the Windows task-
bar, for example, makes your application a real part of Windows and fulfills the expe-
rience expectations of Windows users. Being able to pull up a list of operating system
resources, such as available printers, makes your user interface that much more
functional.
(continued)
        string st = "This is a test";
        char[] characters = st.ToCharArray() ;
        fixed (char* ch = characters)
        {
            char* pos = ch + 5;
            while (*pos != (char)0)
            {
                AnswerText.Text += *pos;
                pos++;
            }
        }
    }
}
To enable unsafe code in your own project in Windows (again, this isn’t officially sup-
ported, so use it entirely at your own risk), you need to add the following block to the
project file. Place the XML inside each PropertyGroup (or at least the main config).
<AllowUnsafeBlocks>true</AllowUnsafeBlocks>
Once you reload the project, you should see your unsafe block is now allowed. Re-
compile and your unsafe code will work.
If in doubt as to where this setting goes, create a regular .NET desktop application,
and under project properties, select the option Allow Unsafe Code. Save the project,
and then look at the project file inside an XML or text editor.
Pointer arithmetic can be a real performance gain for applications that need to traverse
a lot of memory (my C64 emulator is such an example). But it’s almost never necessary
to use this power in a business application, so make sure you need it before you go
and turn this option on. Oh, and make sure you brush up on how pointers work too. 

866
CHAPTER 32
COM, Native Extensions, and p-invoke
 In this chapter, I showed you several ways to integrate with the OS. The first, COM
automation, is the easiest to use and covers a reasonable number of features. It’s espe-
cially useful for automating other programs. The second, NESL, built on top of COM
automation and enables you to integrate better with Windows 7 and higher. The third,
p-invoke, enables you call API-style functions both in the Win32 API and those pro-
vided by third parties.
 Among the three approaches, you should be able to access just about anything you
could need on the client. The code won’t always be pretty, but you’ll be able to make it
happen.
 This chapter wraps up our exploration of platform integration. In the next chap-
ter, you’ll look at structuring and testing your applications using the MVVM pattern.

Part 6
Best practices
Throughout this book, I’ve shown you a mixture of patterns for building
applications. Sometimes, I used code-behind, other times a view model or simi-
lar pattern. In each case, it was a conscious decision where I weighed the best
practices against how they’d help (or not help) convey the key concepts for that
example. Now, it’s time for us to turn to best practices and some of the advanced
techniques used in Silverlight development.
 First, you’ll explore the popular Model-View-ViewModel pattern (MVVM).
This is a powerful but simple pattern that helps keep the user interface sepa-
rated from the logic in your application.
 Then, because complex applications are…umm…complex, you’ll look at
debugging. Debugging and instrumenting your applications is an important
part of the development and support process.
 Part 6 examines the install experience and use of preloaders. These often-over-
looked parts of the development of a Silverlight application are essential if you
want end users to have a favorable impression from their very first click. 


869
Structuring and testing
with the MVVM pattern
When the community stops worrying about how to do basic things in a particular
technology and starts working out how to do complex things well, you know the
technology has reached a point of maturity. The emergence of architectural pat-
terns and testing capabilities for a platform are a good indicator that the technol-
ogy is ready for real-world use in nontrivial applications. Silverlight hit that point
some time between Silverlight 3 and Silverlight 4.
 One of the main patterns to be applied to Silverlight is the Model-View-View-
Model (MVVM) pattern, also known as the ViewModel pattern.
NOTE
MVVM or ViewModel pattern? Different groups like to call it different
things. I’ll use both interchangeably until the community settles on one over
the other. There are some influential folks on both sides of this debate.
This chapter covers
■
Creating services for use with MVVM
■
Using commands and the CallMethodAction
behavior
■
Testing using the Silverlight Unit Testing 
Framework

870
CHAPTER 33
Structuring and testing with the MVVM pattern
As part of my job at Microsoft and my life as an MVP before that, I give a fair number
of presentations, almost all of which include code demos. For timing and retention
reasons, I’ll often implement the code directly in the code-behind. At least 75 percent
of audience members don’t know anything about patterns such as MVVM, and the few
times I’ve tried to include bits of that pattern in my demos, the audience was lost and
completely missed the main thing I was teaching. So, I’ve taken to explaining MVVM at
a high level before the talk and apologizing for not using it in the demo. Basically, I
say “I’m doing this just to show X. Never write real code this way.”
 It sounds amusing, but in a way, it’s a bit depressing. Many folks aren’t exposed to
the pattern, but many more are exposed and pass on it because they’re presented the
full pattern without any background or helpful ladder rungs to get to the full imple-
mentation. That’s a real problem. In math class, I was always told to show my work,
and I think the same applies here.
 Rather than describe the pattern and take it chunk by chunk in this chapter, you’ll
look at the default technique—using the code-behind approach in order to get a base-
line—then start with an overview of MVVM and a simple implementation of the pat-
tern. Next, you’ll refactor it to take advantage of other best practices typically
associated with the pattern such as using services, commands, and behaviors. I’ll even
throw in a bit of information on using interfaces, view model locators, and Inversion
of Control. Because testing is one of the main drivers when picking a pattern like
MVVM, I’ll follow that up with some testing approaches. 
 My point in this chapter isn’t to provide one official implementation of the MVVM
pattern or tell you how you need to build your applications. Instead, I’m providing
you with the groundwork so you can see how the spectrum of implementations of
MVVM/ViewModel fits into your application development and learn how to make
informed choices about how to use (or not use) the pattern in your next project.
 In addition, I’m not going to use a particular MVVM toolkit in this chapter. Those
toolkits are great, but much like that expensive calculator in math class, they do a lot
of the work for you, so you don’t learn much.
 In the end, you’ll have a spectrum of implementations to choose from, any of which
may be used on your projects as your own requirements dictate. You’ll also gain a better
understanding of what each additional bit of complexity provides you in return.
33.1
Project setup and traditional code-behind approach
You may wonder why I’d start a chapter on MVVM with a bunch of code-behind code.
To understand where you can go, you need to start with where you are. The code-
behind approach is by far the way most applications on the Microsoft stack are built
these days. Acceptance of patterns such as MVVM and MVC is changing that but slowly.
 Starting with the code-behind approach will serve two purposes. First, it’ll give you
a working application baseline for refactoring. Second, it’ll allow you to easily com-
pare the approaches as you move through the chapter.
 In this section, you’ll create a project that’ll serve you for the rest of the chapter.
It’ll be a Silverlight navigation application, much like the one covered in chapter 29.

871
Project setup and traditional code-behind approach
You’ll then take that project and add in service calls to get data from a SQL Server
database, using WCF as the intermediary. Finally, you’ll add a list form and a pop-up
details form to round out the project.
33.1.1 Project and service setup
This solution will be based on the Silverlight Navigation Application template covered
in chapter 29. Create a new solution named MvvmApplication using that template.
Figure 33.1 shows the New Project dialog with the appropriate selections. When
prompted, be sure to host the application in a new website (the default setting). 
 After you have the overall solution structure in place, follow the instructions in
appendix A to set up the database connection and entity data model. When complete,
you should have a solution with an untouched Silverlight Navigation Application tem-
plate–based client and a web project with access to the AdventureWorks database via
the entity data model.
 The next step is to set up a web service to allow the Silverlight client to access that
data.
WEB SERVICES
Silverlight applications run on the client and can talk to server-side databases only via
a service of some sort. You can choose multiple types of services. You could go with a
Figure 33.1
For this solution, you’ll use the Navigation Application template introduced in chapter 29.

872
CHAPTER 33
Structuring and testing with the MVVM pattern
REST-based solution (chapter 21) or something using WCF RIA Services (appendix D
of the ebook). For this, you’ll use a regular Silverlight-enabled WCF service: a SOAP
web service built using WCF. Create a folder named Services in the web project, and
add into it a new Silverlight-enabled WCF service named EmployeeService.svc. Listing
33.1 shows the code for that service.
using MvvmApplication.Web;
[ServiceContract(Namespace = "services.web.mvvmapplication")]
[AspNetCompatibilityRequirements(RequirementsMode =
                AspNetCompatibilityRequirementsMode.Allowed)]
public class EmployeeService
{
  [OperationContract]
  public IList<Employee> GetEmployees()
  {
    var context = new AdventureWorksEntities();
    return context.Employees.ToList();             
  }
}
The service is a basic Silverlight-enabled web service. It uses the entity data model to
return the list of all employees in the database. You could also use a LINQ expression
to be more selective about the list, narrow the number of columns returned (which
would also require a new return type), or sort the data. The function could also return
an IQueryable<Employee> to enable better client-side LINQ integration.
 When the service has been created, add a web reference from the Silverlight appli-
cation to the newly created service. Be sure to do a build first, or the service reference
will typically fail. Name the service reference namespace Services. Be sure to refer to
chapter 20 as needed for more information on services and service references. For the
example in this chapter, be sure to lock the website’s port as instructed in the network-
ing chapters.
EMPLOYEE LIST VIEW
Next, in the Views folder add a new view (Silverlight Page) named EmployeeList.xaml.
The EmployeeList.xaml markup should look like listing 33.2. (Be sure to drag the
DataGrid onto the design surface from the toolbox in order to get all the references
and namespaces automatically set up.)
<Grid x:Name="LayoutRoot">
  <sdk:DataGrid AutoGenerateColumns="True"
                Margin="12,55,119,12"
                x:Name="EmployeesGrid" />
  <Button Content="More Vacation!"
          Height="23" Width="101" Margin="0,55,12,0"
Listing 33.1
WCF service to expose data to the Silverlight application
Listing 33.2
EmployeeList.xaml markup
Return all 
employees, 
unsorted

873
Project setup and traditional code-behind approach
          HorizontalAlignment="Right" VerticalAlignment="Top"
          x:Name="AddMoreVacation" />
  <Button Content="Edit"
          Height="23" Width="101" Margin="0,110,12,0"
          HorizontalAlignment="Right" VerticalAlignment="Top"
          x:Name="EditEmployee" />
  <Grid x:Name="LoadingProgress"
        Background="#CCFFFFFF"
        Visibility="Collapsed">
    <ProgressBar Height="25" Width="200"
                 IsIndeterminate="True" />
  </Grid>
</Grid>
Listing 33.2 includes a DataGrid that contains all the employees, as well as two buttons
for manipulating the data. Finally, a semitransparent white overlay named Loading-
Progress is displayed when the data is being fetched.
 Next, add the new employee list page to the navigation menu. The process to do
this was covered in chapter 29, but for reference, you’ll need to add a new hyperlink
button and divider to the LinksStackPanel in MainPage.xaml:
<HyperlinkButton x:Name="EmployeeListLink" 
                 Style="{StaticResource LinkStyle}"
                 NavigateUri="/EmployeeList" TargetName="ContentFrame"
                 Content="employees" />
<Rectangle Style="{StaticResource DividerStyle}" />
After the employee list view is set up, you’ll add an employee detail view.
EMPLOYEE DETAIL VIEW
In the Views folder, add a new ChildWindow named EmployeeDetail.xaml. (Child win-
dows were covered in chapter 28.) This will be a pop-up window used to edit a subset
of the fields of the Employee object. This window, in the designer, looks like figure
33.2.
Figure 33.2
Designer view of the ChildWindow 
used to edit employee details

874
CHAPTER 33
Structuring and testing with the MVVM pattern
After the button definitions, but inside the LayoutRoot grid in the EmployeeDetail
ChildWindow XAML, add the XAML from listing 33.3.
<TextBlock Height="23" Margin="12,18,0,0"
           HorizontalAlignment="Left" VerticalAlignment="Top"
           Text="First Name"/>
<TextBox Height="23" Width="140" Margin="127,14,0,0"
         HorizontalAlignment="Left" VerticalAlignment="Top"
         x:Name="FirstName"
         Text="{Binding Contact.FirstName, Mode=TwoWay}" /> 
<TextBlock Height="23" Margin="12,47,0,0"
           HorizontalAlignment="Left" VerticalAlignment="Top"
           Text="Last Name" />
<TextBox Height="23" Width="140" Margin="127,43,0,0"
         HorizontalAlignment="Left" VerticalAlignment="Top"
         x:Name="LastName"
         Text="{Binding Contact.LastName, Mode=TwoWay}" /> 
<TextBlock Height="23" Margin="12,76,0,0"
           HorizontalAlignment="Left" VerticalAlignment="Top"
           Text="Title"/>
<TextBox Height="23" Width="239" Margin="127,72,0,0"
         HorizontalAlignment="Left" VerticalAlignment="Top"
         x:Name="TitleField"
         Text="{Binding Title, Mode=TwoWay}" /> 
<CheckBox x:Name="Salaried" Height="16" Margin="127,101,0,0"
          HorizontalAlignment="Left" VerticalAlignment="Top"
          Content="Salaried" 
          IsChecked="{Binding SalariedFlag, Mode=TwoWay}" />
<TextBlock Height="23" Margin="12,127,0,0"
           HorizontalAlignment="Left" VerticalAlignment="Top"
           Text="Hire Date"/>
<TextBox Height="23" Width="87" Margin="127,123,0,0"
         HorizontalAlignment="Left" VerticalAlignment="Top"
         x:Name="HireDate"
         Text="{Binding HireDate, Mode=TwoWay}" />
<TextBlock Height="23" Margin="12,156,0,0"
           HorizontalAlignment="Left" VerticalAlignment="Top"
           Text="Vacation Hours"/>
<TextBox Height="23" Width="33" Margin="127,152,0,0"
         HorizontalAlignment="Left" VerticalAlignment="Top"
         x:Name="VacationHours"
         Text="{Binding VacationHours, Mode=TwoWay}"/>
<TextBlock Height="23" Margin="12,185,0,0"
           HorizontalAlignment="Left" VerticalAlignment="Top"
           Text="Sick Leave Hours"/>
<TextBox Height="23" Width="33" Margin="127,181,0,0"
         HorizontalAlignment="Left" VerticalAlignment="Top"
         x:Name="SickLeaveHours"
         Text="{Binding SickLeaveHours, Mode=TwoWay}"/>
You’ll use this project for the remainder of the chapter. You may change a few binding
statements later, but for the most part, the XAML will stay the same.
Listing 33.3
Additional XAML for EmployeeDetail ChildWindow controls 
TwoWay binding
for all fields

875
Project setup and traditional code-behind approach
 With the UI in place, it’s time to turn our attention to the code. As promised, I’ll
first show a typical code-behind approach.
33.1.2 A typical code-behind solution
The first stop along the way to structuring your applications with the ViewModel pat-
tern is to look at what, for most applications of any complexity, can be considered an
antipattern: the heavy code-behind approach. Unfortunately, the tooling and infor-
mation all help you fall into writing code this way. That’s because it’s easy for begin-
ners to grasp, and it’s perfectly acceptable for smaller applications.
 So far, you have XAML for two views and a service you can use to populate them.
The next step is to put in code to call the service and populate the DataGrid. Listing
33.4 shows the code-behind for the Employee List page.
public partial class EmployeeList : Page
{
  public EmployeeList()
  {
    InitializeComponent();
    NavigationCacheMode = NavigationCacheMode.Enabled; 
  }
  protected override void OnNavigatedTo(NavigationEventArgs e)
  {
    if (EmployeesGrid.ItemsSource == null)                     
    {
      LoadingProgress.Visibility = Visibility.Visible;         
      var client = new EmployeeServiceClient();
      client.GetEmployeesCompleted += (s, ea) =>
        {
          LoadingProgress.Visibility = Visibility.Collapsed;
          EmployeesGrid.ItemsSource = ea.Result;    
        };
      client.GetEmployeesAsync();
    }
  }
}
Listing 33.4 includes enough code to load the DataGrid. When the page is navigated
to, you first check to see whether the DataGrid already has data. If it doesn’t, you show
the LoadingProgress overlay and call the service, loading the result into the
DataGrid. This check is done because the pages are cached (per the setting in the
constructor), and you’d rather not make extra service calls. When you run the appli-
cation, it should look like figure 33.3. Note that I’ve scrolled over a little; you’ll have a
number of cutoff columns at the left due to the automatic inclusion of relationships in
the results.
 As you can see by the grid results, you haven’t done anything to reduce the num-
ber of columns showing up or to display the values from the nested class. This could
Listing 33.4
Employee list code-behind
Cache this page
Load into grid

876
CHAPTER 33
Structuring and testing with the MVVM pattern
be easily accomplished by manually defining columns in the DataGrid or by using a
specialized purpose-built class as the return value from the service. Although you’ll fix
that when I talk about MVVM, it’s not a deficiency with the code-behind pattern itself.
 Next, you need to add the code-behind for the Employee Detail window and then
come back to this list page to fill out the rest of the code.
 The Employee Detail ChildWindow needs code to take in an Employee object and
bind the UI. Listing 33.5 shows this code.
public partial class EmployeeDetail : ChildWindow
{
  public EmployeeDetail()
  {
    InitializeComponent();
  }
  private Employee _employee;
  public Employee Employee                       
  {
    get { return _employee; }
    set { _employee = value; DataContext = _employee; }
  }
  private void OKButton_Click(object sender, RoutedEventArgs e)
  {
    this.DialogResult = true;
Listing 33.5
Employee detail code-behind for ChildWindow
Figure 33.3
The Employee List page shown with an item selected in the grid. Note that the scrollbar 
is scrolled to the right to get past the columns you don’t need.
Employee property
Data context

877
Project setup and traditional code-behind approach
  }
  private void CancelButton_Click(object sender, RoutedEventArgs e)
  {
    this.DialogResult = false;
  }
}
Listing 33.5 shows the additions to the ChildWindow code-behind. The additions are
the Employee member variable and property, and the setting of the DataContext
when the employee property is set. The setting of the DataContext allows the binding
system to use the _employee object as the base for all binding statements in XAML.
 One issue you’ll see in the code-behind is that you don’t clone the Employee or
something to allow for undo/cancel. That’s certainly doable in this instance, but I’ve
left it out for this example. As was the case with the column definitions in the list view,
this isn’t a limitation of the code-behind approach itself.
 With the ChildWindow code in place, let’s turn our attention to the last two parts of
code: the functionality of the two buttons on the main Employee List view. 
public EmployeeList()
{
  InitializeComponent();
  NavigationCacheMode = NavigationCacheMode.Enabled;
  AddMoreVacation.Click += new RoutedEventHandler(AddMoreVacation_Click);
  EditEmployee.Click += new RoutedEventHandler(EditEmployee_Click);
}
...
private EmployeeDetail _employeeDetail = new EmployeeDetail();
void EditEmployee_Click(object sender, RoutedEventArgs e)
{
  _employeeDetail.Employee = EmployeesGrid.SelectedItem as Employee;
  _employeeDetail.Show();                  
}
void AddMoreVacation_Click(object sender, RoutedEventArgs e)
{
  var selectedEmployee = EmployeesGrid.SelectedItem as Employee;
  if (selectedEmployee != null)
  {
    selectedEmployee.VacationHours += 10;
  }
}
Note that in listing 33.6, you go back and modify the EmployeeList constructor to add
the two event handlers. This could be done in XAML, but I’ll show you alternatives to
event handlers when I discuss the MVVM version of this code.
 The code in this listing enables the pop-up EmployeeDetail ChildWindow as well as
a simple function to add 10 vacation hours to the selected employee. Run the applica-
tion, select a row in the grid, and click the Edit button. You should see a pop-up that
looks like figure 33.4.
Listing 33.6
Employee list code-behind for functions
Display child
window

878
CHAPTER 33
Structuring and testing with the MVVM pattern
That’s it for the code-behind version of the application. For space reasons, and
because it doesn’t change your approach, I’ve left out deleting and saving changes.
For a solid way to handle those, look at WCF RIA Services in appendix D of the ebook. 
 The main things I needed to demonstrate here are filling a list from a service call
and passing information from one view to another. Now that the basic application is
set up and covers both of these scenarios, I’ll show you an MVVM version. 
33.2
Model-View-ViewModel basics
Originally conceived for WPF around 2005, and first presented in a blog posting by John
Gossman,1 the MVVM pattern has become the most popular architectural pattern for
Silverlight and WPF applications and, more recently, is gaining serious traction in the
JavaScript world. In this book, we’ll talk only about the Silverlight implementation.
 The MVVM pattern is a specialization of the Presentation Model pattern by Martin
Fowler. Whereas Fowler’s pattern was platform-independent, Grossman’s specializa-
tion was created to take advantage of the capabilities of WPF and Silverlight. Other-
wise, they’re conceptually identical.
 If you’re familiar with the Model View Controller (MVC) pattern, you’ll find simi-
larities. The MVVM pattern is optimized more for modern UI models whereas the UI
1 John Gossman, Introduction to the Model/View/ViewModel pattern for building WPF apps, http://blogs.msdn.com/
johngossman/archive/2005/10/08/478683.aspx (October 8, 2005).
Figure 33.4
The employee detail pop-up view, showing the information from the selected employee

879
Model-View-ViewModel basics
markup is completely separated from the logic, using messages and binding to pass
information back and forth, assuming the UI and ViewModel can both be stateful. 
 By default, most people build applications with a good bit of code in the code-
behind, just as you saw in the previous section. They may use external services or enti-
ties and even reusable logic, but at the end of the day, the vast majority of programs
still end up with critical logic buried in the code-behind, in a place where they can’t
be easily tested or reused.
 A typical code-behind approach looks like figure 33.5.
 This comes in degrees, of course. Some code-behind applications are better archi-
tected than others. You’ll find, though, that those that are architected well tend to
have less logic in the code-behind. Instead, they have UI support code, or maybe bind-
ing wire-up. Critical calculations and similar functionality take place outside of the
code-behind.
 Why is that important? Why take the extra step to move this code out from the
code-behind?
 Testing is certainly one reason. After you decouple the logic from the UI, you’re
then able to test the logic. Ease of UI design is another. With a well-architected appli-
cation that has a strong separation of concerns between the logic and the UI, a
designer can create the user interface and drop it into the project. As a developer, you
can even provide the designer with mock interfaces or dummy classes to use to design
against, as long as those classes adhere to the same interface or contract as your own
support classes.
 One reason the MVVM pattern works well for developers is because it eliminates
many of the binding problems you run into when coding in code-behind. Often devel-
opers find they have to work some convoluted code to get the XAML to bind to a
DependencyProperty defined in the code-behind, messing with overriding DataCon-
text at different layers or otherwise making a horrible mess of the code and XAML. It
happens to the best of us. It’s a pit that you can easily fall into when you don’t follow a
pattern such as MVVM.
 What does an MVVM application look like in contrast to a code-behind applica-
tion? Figure 33.6 shows the architecture of a basic MVVM implementation.
XAML
Code Behind
Data
Services
Services
UI
Services / Logic
Data
Figure 33.5
In the usual code-behind 
approach, a fair bit of logic is tightly 
coupled to the UI and to other layers. 
Services in this case mean both web 
services and logical services (utility 
functions, reusable business logic, and 
so on).

880
CHAPTER 33
Structuring and testing with the MVVM pattern
As you can see, when using the MVVM pattern, the application is made up of three main
parts: the Model, the View, and the ViewModel. Table 33.1 describes their function.  
Taken to logical ends, the structure of an MVVM application would include interfaces
at all the key points, allowing you to easily swap out individual layers or objects for
equivalents either manually or via dependency injection. You’ll investigate those sce-
narios later in this chapter. 
 In this section, you’ll take your code-behind solution from the first section and
refactor it into a basic MVVM application. You’ll pull the code-behind apart, put much
of the functionality into a ViewModel class, and ready it for additional refactoring and
Table 33.1
The three main parts of the MVVM pattern
Part
Description
Model
The model of the business or the model of the data, sometimes also called the model of 
the application. This can contain entities and services (web services, business services, 
logic services, and so on), data access, and more.
View
The XAML file and its code-behind. Its sole responsibility is interaction with the user. The 
only code here should be code that’s logically part of the View itself (managing interac-
tions between view elements or animations, for example).
The View typically has enough knowledge of the structure of the ViewModel to bind to it 
but knows nothing of the rest of the system.
ViewModel
The interface between the View and the Model. This is part entity, part façade, and part 
controller, but it contains minimal logic of its own. Use binding to let the View pull/push 
data, and commands or behaviors (messages) to call methods.
The ViewModel has no knowledge of the structure of the view.a
a. One of the tech reviewers suggested I put this in a blink tag or marquee or something to make 
sure the point is driven home. The ViewModel has no knowledge of the view. Perhaps if you break 
the rule, you should have to put a big red label on the code: “Warning! Lark’s Vomit!” (thank you, 
Mr. Cleese).
XAML
Code Behind
Data
Services
Services
View
Services / Logic
Data
ViewModel
Binding /
Messages
ViewModel
Model
Figure 33.6
In the MVVM pattern, the View contains minimal code-behind and uses binding and 
messages (actions or commands) to communicate with the ViewModel. The ViewModel provides a single 
façade into the rest of the system, optimized for that specific view. Keep in mind that services doesn’t 
always mean web services; they’re anything that provide a service to the application.

881
Model-View-ViewModel basics
application of patterns later in this chapter. Before you do that, though, let’s dispel a
few myths about MVVM.
33.2.1 Myths about MVVM Model-View-ViewModel
MVVM is a pretty simple pattern. As you’ve seen so far, it incorporates a Model, a View,
and a ViewModel. That’s it—nothing else is part of the pattern. You’ll often hear about
additional patterns such as Inversion of Control(IoC)/Dependency Injection (DI), the
Command pattern, the Locator pattern, the Repository pattern, and others. In fact, I’ll
cover a few of those in this chapter. Those patterns, though very useful when under-
stood and implemented to solve specific problems, aren’t required to use MVVM.
 If you hear someone say something like “If you’re not using IoC, you’re doing it
wrong,” back away slowly, turn around, run like crazy, and don’t let them touch your
code. Blanket statements like that have turned many beginning developers off to
MVVM and have made the burden of knowledge required to use MVVM far more than
is necessary.
 What’s more important is to know what the additional pattern brings to the table
and to understand whether you need that in your own application.
 Another myth is the idea that an application must have no code-behind for it to be
using MVVM. Hogwash! The MVVM pattern says nothing about limiting the amount of
code in the code-behind. For example, in many cases view logic (such as manipulating
storyboards or dealing with the navigation framework) is better located right there in
the code-behind for the view. How you decide what goes in the code-behind generally
revolves around where it has affinity and what you’ll need to do to test it. 
 Smart decisions about what goes into a ViewModel and what goes in the code-
behind will save you a lot of effort and headaches over the development of the appli-
cation. Plus, the decisions you make will almost certainly vary with the complexity of
the application you’re writing. You and your team are the only ones who can make
those decisions.
 Taking a lot of effort to essentially make your ViewModel a new code-behind is
hardly useful. In fact, that’s why the Silverlight team has been reticent to make the
ViewModel approach the default way to work in Visual Studio: it’d simply become a
new dumping ground.
 So to be very clear, MVVM isn’t:
■
Zero code-behind (although that’s an “ideal”)
■
IoC, repositories, services, and other sometimes helpful patterns
■
Something that should get in your way
■
Something to stress out over—it should make your life easier
I’ll show you what code I’d move to the ViewModel in the application in this chapter.
I’ll also show you a number of MVVM features and some supporting patterns such as
the Command pattern. You need to make an educated decision whether to use
specific features in your own applications based on your requirements, schedule, and
knowledge. As long as you know what each feature or pattern brings to the table, and

882
CHAPTER 33
Structuring and testing with the MVVM pattern
what you may possibly give up by not using it (or take on by using it), you can support
your decision and properly architect your application.
 Absolutes tend to get you in trouble in computer science. If you said you must have
the best possible performance and smallest memory footprint, I’d tell you to whip out
the assembler. All programs have compromises. Compromise isn’t a bad word—it sim-
ply means you weighed the options and decided on the approach that best balances
your needs.
 With all of that in mind, let’s start at the simplest point: a basic ViewModel imple-
mentation.
33.2.2 Keep it simple: a basic ViewModel implementation
So far, you have a simple and tight code-behind application running. It’s small. In fact,
it’s small enough that showing you the MVVM version will make you wonder why
you’re adding so much code. As with many examples, it has to start small both to get
the concepts across and to fit in a book like this. 
 That said, if you stick with me throughout this section, you’ll see how the structure
set up by the MVVM pattern makes it possible to add functionality to the application
without shoehorning it into some dark corner of code.
 In this section, you’ll make basic changes to factor some of the code out of the
code-behind and into a ViewModel. Although this isn’t a “full” ViewModel/MVVM
implementation, it provides many of the benefits and is a good, understandable place
to start. Most of my early experiments with the pattern looked much like what you’ll
see in this section.
Who owns the ViewModel?
Let’s jump right into controversy on your very first foray into this pattern! 
I’m writing this book, so I could put my opinion forth as the definitive approach, but
I’d rather not have coders with pitchforks and burning torches marching down my drive-
way in a few months. Instead, let’s look at the three main approaches in this space.
■
The code owns the ViewModel.
In this case, the code-behind for the view instantiates the ViewModel in a con-
structor or loaded event, setting it as the DataContext for the view. This is con-
venient and provides a clean way to create the ViewModel. But it doesn’t allow
the View to be reused in situations where the ViewModel may be provided ex-
ternally, as is the case in a Detail edit View.
■
The markup owns the ViewModel.
This is, in a real sense, the same as the first option. From an implementation
standpoint, though, it looks very different. In this case, the ViewModel is instan-
tiated right in the markup either as a static resource or directly in the
<navigation:Page.DataContext> property. From a coupling standpoint,
there’s no difference. What you usually gain is the ability to have even less code
in the code-behind.

883
Model-View-ViewModel basics
The first step in working with the pattern is to create a short base class from which all
ViewModel classes will derive.
BASE VIEWMODEL
The base ViewModel class provides the common INotifyPropertyChanged implemen-
tation. As you may recall from chapter 16 on binding, INotifyPropertyChanged is
required whenever other classes may be bound to your class, except when using
dependency properties—which don’t really belong in a ViewModel.
 In a larger implementation, the base ViewModel class may contain other useful func-
tionality or may be factored into several classes to support specialized types of View-
Model implementations. Regardless, this is the class you’ll use as the base class for the
other ViewModels created in this project, starting with the list page ViewModel.
 In the Silverlight project, add a new folder named ViewModels. In the View-
Models folder, add a class named ViewModel. Listing 33.7 shows the code that makes
up this class.
using System.ComponentModel;
namespace MvvmApplication.ViewModels
{
  public abstract class ViewModel : INotifyPropertyChanged
  {
    public event PropertyChangedEventHandler PropertyChanged;
    protected void NotifyPropertyChanged(string propertyName)
    {
      if (PropertyChanged != null)                     
(continued)
Both approaches involve the View owning the ViewModel. They’re simple to implement
and are often appropriate for early forays into the ViewModel pattern. You may even
find that they work well for the majority (or all) of the applications you create. But one
more approach is worth investigating.
■
The ViewModel is provided externally.
Most MVVM toolkits of merit provide some sort of functionality for locating the
appropriate ViewModel for a View. In some cases, the ViewModels are created
in a separate holding class that provides the ViewModel when requested. This
ensures significant flexibility in terms of sourcing the ViewModel. 
Note also that dependency injection can come into play here. An Inversion of
Control (IoC) container can provide the ViewModel to the views based on types,
convention, or configuration. Some MVVM toolkits use IoCs or IoC-like function-
ality to supply the ViewModel.
In this case, the ViewModel isn’t owned by the View; it’s used by the View. As
you progress further in your understanding of MVVM, I encourage you to inves-
tigate this approach.
Listing 33.7
The base ViewModel class
Raise Property-
Changed event

884
CHAPTER 33
Structuring and testing with the MVVM pattern
        PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
    }
  }
}
In my implementations, I often have a base class named Observable that includes the
functionality shown in this ViewModel class.2 I then derive a ViewModel base class from
Observable. This enables me to support INotifyPropertyChanged with entities and
other non-ViewModel classes and still have a base ViewModel that can be used for
other shared functionality.
LIST PAGE VIEWMODEL
Typically, each view in the ViewModel pattern has its own dedicated ViewModel. This
isn’t written in stone, but it’s how most applications end up being designed. A 1:1 rela-
tionship between View and ViewModel eliminates the need to shoehorn in the inevita-
ble compromises, because Views that share the ViewModels diverge in functionality
when many Views share the same ViewModel. It’s also acceptable, when using smaller
ViewModels or nested UserControls, to have a 1:n relationship between the View and
the ViewModel. The situation to avoid in most cases is n:1 between View and View-
Model.
TIP
When naming your ViewModel, pick a consistent convention. I typically
name mine with the view name plus ViewModel, so the EmployeeList view has
an EmployeeListViewModel class. Some MVVM toolkits expect you to follow a
convention so their locator services can find the correct ViewModel for a
View.
In the ViewModels folder, create a new class named EmployeeListViewModel. This
ViewModel will include the functionality required for the EmployeeList page, includ-
ing calling the web service and providing the functionality currently located in the
button click code. Listing 33.8 includes the code for the EmployeeListViewModel
implementation.
using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using MvvmApplication.Services;
namespace MvvmApplication.ViewModels
{
  public class EmployeeListViewModel : ViewModel
  {
    private Employee _selectedEmployee;
    public Employee SelectedEmployee         
    {
2 For more information on how this all plays into threading and the dispatcher, and for a slightly more robust
version of the Observable class, see my blog post: http://bit.ly/SLDispatch.
Listing 33.8
 EmployeeListViewModel implementation
Selected employee

885
Model-View-ViewModel basics
      get { return _selectedEmployee; }
      set 
      { 
        _selectedEmployee = value;
         NotifyPropertyChanged("SelectedEmployee"); 
      }
    }
    private ObservableCollection<Employee> _employees;
    public ObservableCollection<Employee> Employees  
    {
      get { return _employees; }
      private set 
      { 
        _employees = value; 
        NotifyPropertyChanged("Employees"); 
      }
    }
    public event EventHandler EmployeesLoaded;
    public void LoadEmployees()
    {
      var client = new EmployeeServiceClient();
      client.GetEmployeesCompleted += (s, ea) =>
        {
          Employees = ea.Result;
          OnEmployeesLoaded();
        };
      client.GetEmployeesAsync();
    }
    public void AddVacationBonusToSelectedEmployee()   
    {
      if (SelectedEmployee != null)
        SelectedEmployee.VacationHours += 10;
    }
    protected void OnEmployeesLoaded()
    {
      if (EmployeesLoaded != null)
        EmployeesLoaded(this, EventArgs.Empty);
    }
  }
}
In listing 33.8, you have the full implementation of a basic ViewModel class. This
includes all the functionality required to load the list of employees and make it avail-
able to the DataGrid on the view. 
 The Employees property contains the collection with all the employees returned
from the service call. This is used to populate the DataGrid, but because it’s available
here, it could also be manipulated in ViewModel code to sort, filter, or perform other
operations.
 The SelectedEmployee property is used to keep track of which employee is
selected in the grid. Exposing it in your ViewModel keeps the responsibility for main-
taining this information away from the UI control. This makes it easier to use different
Full set of employees
Add vacation bonus

886
CHAPTER 33
Structuring and testing with the MVVM pattern
types of controls in the UI. In addition, you can manipulate this property from within
the ViewModel (for example, to highlight something based on a search or hotkey),
and the UI will automatically respond.
UPDATED LIST VIEW XAML
The following code includes the updates to the view to bind the DataGrid to the
Employees collection and the SelectedEmployee property:
<sdk:DataGrid AutoGenerateColumns="True"
       ItemsSource="{Binding Employees}"
       SelectedItem="{Binding SelectedEmployee, Mode=TwoWay}"
       Margin="12,55,119,12"
       x:Name="EmployeesGrid" />
The updates to the DataGrid element involved first setting the ItemsSource to the
Employees collection on the ViewModel class, then binding the SelectedItem to the
SelectedEmployee property of ViewModel. Note that the binding on Select-
edEmployee is TwoWay, so both the DataGrid and code may update this value.
UPDATED LIST VIEW CODE-BEHIND
With the addition of the ViewModel and the changes to the XAML, you need to make
changes to the code-behind for the EmployeeList page. Listing 33.9 shows the new
code-behind with those changes included.
public partial class EmployeeList : Page
{
  public EmployeeList()
  {
    InitializeComponent();
    NavigationCacheMode = NavigationCacheMode.Enabled;            
    AddMoreVacation.Click +=
              new RoutedEventHandler(AddMoreVacation_Click);
    EditEmployee.Click += 
              new RoutedEventHandler(EditEmployee_Click);
  }
    private EmployeeListViewModel _viewModel = null;
    protected override void OnNavigatedTo(NavigationEventArgs e)  
    {
      if (_viewModel == null)
      {
        _viewModel = new EmployeeListViewModel();    
        _viewModel.EmployeesLoaded += (s, ea) =>
          {
            LoadingProgress.Visibility = Visibility.Collapsed;
          };
        DataContext = _viewModel;
        LoadingProgress.Visibility = Visibility.Visible;
        _viewModel.LoadEmployees();                
      }
    }
    private EmployeeDetail _employeeDetail = new EmployeeDetail();
Listing 33.9
EmployeeList view code-behind
OnNavigatedTo
Create ViewModel
Load Employees

887
Factoring out reusable code
    void EditEmployee_Click(object sender, RoutedEventArgs e)
    {
      _employeeDetail.Employee = _viewModel.SelectedEmployee;
      _employeeDetail.Show();
    }
    void AddMoreVacation_Click(object sender, RoutedEventArgs e)
    {
      _viewModel.AddVacationBonusToSelectedEmployee();            
    }
}
The OnNavigatedTo function  now includes code to create the ViewModel if it’s not
already present and to call the LoadEmployees method on the ViewModel. In addi-
tion, the event handler for the Add More Vacation! button now calls directly into the
ViewModel to execute the code.
 Now you have the same functionality as the code-behind solution but with quite a
bit more code. In fact, you have just as much code-behind as you did in the code-
behind-only solution! Keep in mind that this is just the first layer of the onion, so you
haven’t received all the benefits of MVVM yet. What you’ve gained is subtle: 
■
The DataGrid is now divorced from the code-behind, using only binding to get
its items and synchronize the selected item. A designer could now change the
DataGrid to be a ListBox or some other type of control if desired, and the code
wouldn’t need to change.
■
The data access (service call) is now removed from the page, giving you the
potential to substitute a different type of service call without making any changes
to the page code. You’ll find an even better spot for it later in this chapter.
■
The business logic to add the vacation bonus to the selected employee is now
pulled out of the page. Like with the service call, you can do better, and you will
later in this chapter.
■
The code-behind is no longer manipulating the Employee type directly. This
makes it easier to replace the Employee type later, should you want to do so.
At this point, you have a ViewModel that’s essentially the code-behind for the View.
You’ve taken your first steps into the MVVM pattern and away from packing all your
code in the code-behind. To build on this, it’d be nice if you could refactor to take
advantage of some best practices associated with the ViewModel pattern and with cod-
ing in general. In the next section, I’ll dive deeper into the pattern and show you how
to factor out common code such as service access and business rules.  
33.3
Factoring out reusable code
The Single Responsibility Principle (SRP) states (surprisingly enough) that every object
should have a single responsibility3 and that every object should have one and only
3 Robert C. Martin, Principles of OOD, http://www.butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod
(May 11, 2005).

888
CHAPTER 33
Structuring and testing with the MVVM pattern
one reason to change. I don’t try to adhere to this as though it were dogma but rather
make informed decisions based on this principle representing the perfect state. 
SRP can sometimes be difficult to apply to something as façade-like as a ViewModel
class, but it’s obvious we didn’t even try here. The ViewModel class for the list page is
responsible for tracking page state, calling the web service to load data, and applying a
vacation bonus to selected employees. If the vacation bonus changes, this class must
also change. If the service access changes, this class must change. You need to do
something about that.
 In this section, you’ll do a little refactoring to make the ViewModel class a bit lighter
and allow reuse of code, starting with the business logic to add the vacation bonus.
33.3.1 Business rules and logic
The easiest thing to pull out of the EmployeeListViewModel is the code that adds the
vacation bonus. You can deal with this several ways—I prefer using a service approach.
That is, rather than bake the bonus into a special employee class, you have a service
you can call that deals with bonuses using a simple function call. This is distinct from
the idea of a web service.
 Create a new folder named Services in the Silverlight client. In that folder, add a
class named EmployeeVacationBonusService. Listing 33.10 shows the code for this
class.
public class EmployeeVacationBonusService
{
  public static void AddVacationBonus(Employee employee)  
  {
    int vacationBonus;
    DateTime dateOfHire = employee.HireDate;
    DateTime today = DateTime.Today;
    int yearsInService = today.Year - dateOfHire.Year;
    if (dateOfHire.AddYears(yearsInService) > today)
      yearsInService--;
    if (yearsInService < 5)
      vacationBonus = 10;
    else if (yearsInService < 10)
      vacationBonus = 20;
    else if (yearsInService < 20)
      vacationBonus = 30;
    else
      vacationBonus = 40;
    employee.VacationHours += (short)vacationBonus;
  }
}
The vacation bonus algorithm has been beefed up. Rather than a blanket 10 hours,
you use some of the data to reward those with the longest time at the company. You
also implement the functionality using static methods here. Some developers prefer
Listing 33.10
The EmployeeVacationBonusService class
Dependency 
on Employee

889
Factoring out reusable code
to use instance methods. Either way is fine as long as you understand why you’re
doing it and what flexibility you lose when going with static methods (such as the abil-
ity to mock), and you have some consistency to your decisions.
 There are also multiple ways you can model this class. For example, it could modify
the class directly as shown in listing 33.10 or it could return a bonus amount based on
a set of parameters such as current vacation hours, date of hire, some sort of level
information, and so on. Taking in individual parameters like that, rather than passing
in an Employee object, helps reinforce the SRP and decouple from the rest of the sys-
tem because the class no longer needs to be changed if the Employee class changes. 
 Listing 33.11 shows the final version of this service, taking individual parameters
rather than the Employee object.
public class EmployeeVacationBonusService
{
  public static int GetVacationBonus(DateTime dateOfHire)
  {
    int vacationBonus;
    DateTime today = DateTime.Today;
    int yearsInService = today.Year - dateOfHire.Year;
    if (dateOfHire.AddYears(yearsInService) > today)
      yearsInService--;
    if (yearsInService < 5)
      vacationBonus = 10;
    else if (yearsInService < 10)
      vacationBonus = 20;
    else if (yearsInService < 20)
      vacationBonus = 30;
    else
      vacationBonus = 40;
    return vacationBonus;
  }
}
In the listing 33.11 version, it’s the responsibility of the calling code to add the bonus
to whatever employee class it happens to be working with. That removes the depen-
dency from this class and makes it reusable in places where you may have different
employee entities or perhaps just a few key fields.
 With that change made, the EmployeeListViewModel code to add the employee
vacation bonus now looks like this:
public void AddVacationBonusToSelectedEmployee()
{
  if (SelectedEmployee != null)
  {
    SelectedEmployee.VacationHours += 
            (short)EmployeeVacationBonusService.GetVacationBonus(
                    SelectedEmployee.HireDate);
  }
}
Listing 33.11
A better version of the EmployeeVacationBonusService class

890
CHAPTER 33
Structuring and testing with the MVVM pattern
The EmployeeListViewModel class is no longer responsible for calculating the vacation
bonus. That’s one extra responsibility down. Now, let’s look at that web service logic. 
33.3.2 Data access and service calls
In Silverlight, it’s a given that data will come from a web service. Or will it? Who says
the data can’t come from reading a local file in elevated trust mode or from isolated
storage? Perhaps with the new Elevated Trust mode, one of the pure-.NET SQL data-
bases will be an option. Plus, for all you know, a future version of Silverlight may have
local database access built in.
 If every ViewModel class in the project is making a web service call to get the data,
that means you have to change each and every one of them if anything about the ser-
vice call changes—obviously, not great design. In a small project like this, it’s not a
huge problem, but when you get into an application with dozens of pages and View-
Models, it gets pretty ugly.
 I’ve seen myriad great examples of how to abstract service or data access calls away
from the rest of the application. Some use singleton classes with names like Applica-
tionData to host a number of collections and load functions, with built-in caching.
Others use individual classes, each responsible for a specific type of data. Others use
combinations of the two ideas, but with no singleton involved so dependency injec-
tion works better. I’m not going to weigh in on the merits of the various approaches; I
don’t think there’s a one-size-fits-all solution. Instead, you’ll create a simple example
to solve just the problem at hand. The version I’m showing doesn’t support cross-view
data caching, because you’d need to keep an instance of the data service alive in a
locator class or an IoC container.
 In the Services folder, add a new class named EmployeeDataService. The code for
this class is shown in listing 33.12.
using System;
using System.Collections.ObjectModel;
namespace MvvmApplication.Services
{
    public class EmployeeDataService
    {
        private ObservableCollection<Employee> _employees;
        public ObservableCollection<Employee> Employees   
        {
            get { return _employees; }
            private set {_employees = value; }
        }
        private bool _areEmployeesLoaded;
        public bool AreEmployeesLoaded
        {
            get { return _areEmployeesLoaded; }
            private set { _areEmployeesLoaded = value; }
        }
Listing 33.12
The EmployeeDataService class used for loading Employee data
Employees 
collection

891
Factoring out reusable code
        public void LoadEmployees()
        {
            var client = new EmployeeServiceClient();
            AreEmployeesLoaded = false;
            client.GetEmployeesCompleted += (s, ea) =>
            {
                Employees = ea.Result;
                AreEmployeesLoaded = true;
                OnEmployeesLoaded();
            };
            client.GetEmployeesAsync();
        }
        public event EventHandler EmployeesLoaded;    
        protected void OnEmployeesLoaded()
        {
            if (EmployeesLoaded != null)
                EmployeesLoaded(null, EventArgs.Empty);
        }
    }
}
The sole purpose of this class is to provide an interface to the employee data. In this
case, that’s performed using a service call. In a larger system with more moving parts,
you may want to factor this class into two pieces: one that provides connection infor-
mation for the web service and this class, which makes the service call. You may also
consider caching this class on the client (via a locator or similar collection of classes)
so the data can be shared across multiple ViewModels. The AreEmployeesLoaded
property has been defined with that in mind. Listing 33.13 shows the changes needed
in the EmployeeListViewModel class to support the user of the new EmployeeData-
Service class.
private EmployeeDataService _dataService = new EmployeeDataService();
public event EventHandler EmployeesLoaded;
public void LoadEmployees()
{
    if (_dataService.AreEmployeesLoaded)
    {
        Employees = _dataService.Employees;
        OnEmployeesLoaded();
    }
    else
    {
        _dataService.EmployeesLoaded += (s, e) =>
            {
                Employees = _dataService.Employees;    
                OnEmployeesLoaded();
            };
        _dataService.LoadEmployees();
    }
}
Listing 33.13
Updates to the EmployeeListViewModel class
Employees 
loaded event
Employees in
data service

892
CHAPTER 33
Structuring and testing with the MVVM pattern
With this example, you now have a ViewModel class that’s responsible only for passing
through information and functionality specific to the related View. This makes the
code more easily reused, as well as more easily testable. You still have a fair bit of code
in the code-behind, including some event handlers that could be handled differently.
In the next section, you’ll work to remove this extra layer and provide better View-to-
ViewModel communication without so much event handler code.  
33.4
Better separation from the UI
“Good fences make good neighbors.” As it turns out, good fences (or perhaps, good
chasms)—strong separation between otherwise independent classes—make for better
code. You’ve already seen how pulling code out of the code-behind and into the View-
Model, and then out of the ViewModel and into services, has made the code less brit-
tle and more reusable. At the end of this chapter, you’ll also see that it has made the
code more testable.
 One of a few places where you’re still tightly coupled is via the use of events and
event handlers to intercept clicks from the UI and call functions on the ViewModel.
This isn’t horrible; it limits the things that can listen for and respond to the UI actions,
and it makes testing a little harder because there’s code in the code-behind that must
be duplicated in the test.
 In this section, you’ll see two ways you can have elements in XAML invoke methods
in the ViewModel. The first approach, ICommand, is the traditional way initially intro-
duced in WPF and supported in most MVVM toolkits. The second, the CallMethod-
Action behavior, is a new approach introduced with Expression Blend 4.
 Structured method invocation isn’t the only way to separate the UI from the rest of
the system. Some slightly more insidious couplings have made it through right under
our noses; I’ll need to address them. The first is the use of entities coming from your
database model. You can do this if you really want, but for a number of reasons to be
explained, I don’t like to. The second coupling is through the use of concrete types
referenced from your various classes. In section 33.4.4, I’ll take a conceptual look at
what’s involved in reducing this coupling. 
33.4.1 Using commands
The commanding system in WPF and Silverlight isn’t tied directly to the ViewModel pat-
tern. Instead, it’s a generic approach to wiring functionality directly to buttons in XAML
UI. In the commanding system, rather than respond to something in a button click
event, you bind the command to the button and allow the button to execute it directly.
 In WPF, this approach was first used for application-wide commands and to allow
menu options, keystrokes, and toolbars to all execute the same functionality and keep
their UI state in sync.
 When the MVVM pattern was introduced, the commanding system was incorpo-
rated into it to wire the XAML UI to the ViewModel class. But because the ViewModel
held the functionality, different types of commands were created to allow forwarding
or relaying the call to the ViewModel.

893
Better separation from the UI
 The ICommand interface is the core of the commanding system in Silverlight. The
button-derived controls (and menus) that support binding to commands do so
through the ICommand interface. Similarly, the custom commands created for the
MVVM pattern also implement this interface. Table 33.2 shows the three members of
ICommand. 
A commonly used implementation of ICommand for the MVVM pattern is a command
that accepts delegates for both the Execute and CanExecute members. This allows you
to reuse the same command implementation rather than create unique commands
for every logical command.
 In the Silverlight project, in the ViewModels folder, add a new class named View-
ModelCommand. The code for the generic command is shown in listing 33.14.
public class ViewModelCommand : ICommand
{
  public ViewModelCommand(Action<object> executeAction,      
                          Predicate<object> canExecute)
  {
    if (executeAction == null)
      throw new ArgumentNullException("executeAction");
    _executeAction = executeAction;
    _canExecute = canExecute;
  }
  private readonly Predicate<object> _canExecute;
  public bool CanExecute(object parameter)     
  {
    if (_canExecute == null) return true;
    return _canExecute(parameter);
  }
  public event EventHandler CanExecuteChanged;  
  public void OnCanExecuteChanged()                      
  {
    if (CanExecuteChanged != null)
      CanExecuteChanged(this, EventArgs.Empty);
  }
  private readonly Action<object> _executeAction;
  public void Execute(object parameter)     
Table 33.2
The ICommand interface members
Member
Description
CanExecute
Property that returns true if this command is allowed to execute. For 
example, if the command is an undo command, it returns false if the 
undo stack is empty.
Execute
Method that executes the function the command represents.
CanExecuteChanged
Event raised when the value of CanExecute changes. This is typically 
used to update UI state to show the action is now available.
Listing 33.14
Silverlight MVVM-friendly implementation of ICommand
ICommand.CanExecute
ICommand.CanExecuteChanged
ICommand.Execute

894
CHAPTER 33
Structuring and testing with the MVVM pattern
  {
    _executeAction(parameter);
  }
}
This command implementation takes into the constructor delegates for CanExecute
and Execute and exposes a public method OnCanExecuteChanged to force raising the
CanExecuteChanged event. In the ViewModel, any code that affects the CanExecute
function should call this method to raise the event.
 There are lots of implementations of this type of command. If you pick an MVVM
toolkit to work with, you’re almost guaranteed to have a command similar to this one
included in the library. It may be called something similar to DelegateCommand or
RelayCommand.
 To surface the command to the page, hang it off the ViewModel as a public prop-
erty. Listing 33.15 shows how to do this for the vacation bonus functionality on the
EmployeeListViewModel class.
private Employee _selectedEmployee;
public Employee SelectedEmployee
{
    get { return _selectedEmployee; }
    set 
    { 
        _selectedEmployee = value; 
        NotifyPropertyChanged("SelectedEmployee");
        AddVacationBonusCommand.OnCanExecuteChanged();      
    }
}
...
public bool CanAddVacationBonus
{
    get { return SelectedEmployee != null; }
}
private ViewModelCommand _addVacationBonusCommand = null;
public ViewModelCommand AddVacationBonusCommand      
{
    get
    {
        if (_addVacationBonusCommand == null)               
        {
            _addVacationBonusCommand = new ViewModelCommand
            (
                p => AddVacationBonusToSelectedEmployee(),
                p => CanAddVacationBonus
            );
        }
        return _addVacationBonusCommand;
    }
}
...
Listing 33.15
Surfacing the vacation bonus functionality as an ICommand
ICommand

895
Better separation from the UI
These changes to the ViewModel show both the call to OnCanExecuteChanged and the
exposing of the AddVacationBonusCommand. This command is created as needed the
first time it’s referenced. I’ve also seen implementations where these commands were
created as static members in the class.
The command is then wired up to the UI directly in the XAML. Because the View-
Model has already been set as the data context, a simple binding statement on the but-
ton is all you need:
<Button Height="23" Width="101" Margin="0,55,12,0"
        HorizontalAlignment="Right" VerticalAlignment="Top"
        Content="More Vacation!"
        x:Name="AddMoreVacation"
        Command="{Binding AddVacationBonusCommand}" />
Lambda magic
Note how the CanAddVacationBonus property in listing 33.15 is passed in to the
canExecute constructor parameter. How exactly does that work when the parameter
is defined as Predicate<object> canExecute?
The => syntax is a shortcut for creating an anonymous delegate. I’ve used it a number
of times in the book, but it isn’t until this example that things get slightly confusing.
p => is a shortcut for writing (p) =>, meaning that the delegate takes a single pa-
rameter that I’ll refer to as p. If the delegate took two parameters, you’d write (p,q)
=> and name the parameters p and q. The type is inferred from the delegate signature.
Okay, but how exactly does that let you pass a property like CanAddVacationBonus
in place of a method? It doesn’t. The examples so far can be further expanded to
something like this:
(p) => 
  {
    return CanAddVacationBonus;
  }
You see, you’re creating a method and simply wrapping it with a function. Because
you don’t need to use the parameter, you simply ignore it. If you had to pass the pa-
rameter into another function, it could look something like this:
(p) => 
  {
    if (DoSomething(p))
    {
      return CanAddVacationBonus;
    }
    else
      return false;
  }
The lambda syntax approach can save a fair bit of ceremonial code. But unless you
realize what’s going on, it can be confusing. I hope this clears it up for you.

896
CHAPTER 33
Structuring and testing with the MVVM pattern
The last line of XAML is the new line, binding the Command property to the new com-
mand you added to the ViewModel. Don’t forget to remove the event handler wire-up
from the code-behind. This button no longer needs that.
 You’ll notice now that the More Vacation! button is disabled by default and enabled
only when you select a row in the DataGrid. That’s a function of the CanExecute prop-
erty and the CanExecuteChanged event working together and being updated from
within the SelectedEmployee property setter. The Button class has built-in code to
change its enabled state based on the command’s CanExecute property.
Commands are the traditional and still most common way of performing this function-
ality. They have deep support in WPF and decent support in Silverlight. A new approach
to accomplishing this has recently been introduced by the Expression Blend team. This
approach eschews commands and instead uses designer-friendly behaviors.
33.4.2 Using the CallMethodAction behavior
Introduced with Expression Blend 4, the CallMethodAction behavior provides an
easy and designer-friendly way to wire any event from any control to a method. In
some ways, it’s an alternative to using ICommand and may even seem redundant. But
many applications will use both approaches due to the usefulness of ICommand with
buttons and menus and CallMethodAction’s support for other controls, and events
other than Click.
Wait, what about the Edit button?
Most MVVM toolkits include their own good command implementations based on
ICommand. Some MVVM toolkits also include a robust messaging structure that may
be used in place of events, and in some cases in place of commands and behaviors.
Many even include specialized messages used to request that the View display the
dialog UI. That messaging system for invoking a dialog is something missing in this
implementation. Rather than show you an approach that’ll likely never be used by any-
one, I recommend you use the approach recommended by the toolkit you’re using.
If you’re really curious, here’s how I would’ve done it. The command would call an
EditSelectedEmployee method on the ViewModel. That method would check to see
whether SelectedEmployee was null. If not, it’d raise an event named EditEmployee
(or similar) with a custom EventArgs class that included the selected employee as
a property. That event would be caught in the code-behind, and the code-behind would
show the dialog.
Why not do that all from the ViewModel? The ViewModel shouldn’t be in the business
of showing dialogs or message boxes of any type. Instead, it should message the UI
layer saying it needs some UI to be displayed. In this way, not only is the ViewModel
potentially agnostic of Silverlight/WPF/other technology, it remains testable because
the event handler in the test code could directly manipulate the values rather than
show the dialog. This also allows the code-behind to keep its affinity with the View,
being presentation-layer code rather than other logic.

897
Better separation from the UI
 You can either install Expression Blend or download the Blend SDK. In either case,
add a project reference to the Blend SDK assembly from your main MvvmApplication
project. The main assembly you want is Microsoft.Expression.Interactions.dll. You’ll
also need System.Windows.Interactivity.dll to support that.
 The behavior approach doesn’t give you everything the command approach
does—specifically, it lacks the ability to enable or disable the button—but it provides
support for controls other than buttons—a key limitation of the command approach.
 Listing 33.16 shows how to use the CallMethodAction behavior to create the link
between the More Vacation! button and the ViewModel method that implements that
behavior.
<Button Height="23" Width="101" Margin="0,55,12,0"
        Content="More Vacation!"
        HorizontalAlignment="Right" VerticalAlignment="Top"
        x:Name="AddMoreVacation">
  <i:Interaction.Triggers>
    <i:EventTrigger EventName="Click">                       
      <ei:CallMethodAction                      
          MethodName="AddVacationBonusToSelectedEmployee"
          TargetObject="{Binding}" />
    </i:EventTrigger>
  </i:Interaction.Triggers>
</Button>
The EventTrigger responds to the firing of the click event. The action taken is the
CallMethodAction, which is responsible for calling the method on the current object
in the data context: in this case, the ViewModel. It’s a simple and elegant solution that
works with just about any event and any parameterless function.
 In support of this, the following two namespaces were added to the top of the
XAML file:
xmlns:i="http://schemas.microsoft.com/expression/2010/interactivity"
xmlns:ei="http://schemas.microsoft.com/expression/2010/interactions"
Those namespaces are required for the EventTrigger and CallMethodAction to be
visible to XAML. Both are implemented inside the Blend SDK DLL you added as a ref-
erence.
 Despite the limitations (a potential performance hit due to use of reflection, and
the inability to set the IsEnabled property automatically), the CallMethodAction
behavior is a good low-code-overhead approach to wiring up method calls. And
remember, unlike ICommand, the CallMethodAction is supported on just about any
event on any control.
 Commands and behaviors are a great way to help separate the View from the View-
Model, keeping the contract at just a binding statement or name of a method. But
they’ve done nothing to fix the tight coupling problem you have between the data-
Listing 33.16
Using the CallMethodAction behavior instead of the command
Behavior

898
CHAPTER 33
Structuring and testing with the MVVM pattern
base, the ViewModel, and the UI. For that, you’ll turn to creating View-specific entities
or ViewModels.
33.4.3 View-specific entities and ViewModels
So far, you’ve been passing the data entities straight through to the UI. Although this
is common, it’s often not a great idea; you’ve introduced coupling from your UI all the
way back to the database, with a service and some serialization thrown in as a bonus. A
change to the database entity now means changes throughout the application. Take,
for example, the columns you see in the grid. There’s a fair bit of information that’s
not helpful at the UI level but that’s required to maintain data integrity. One way to
handle that would be to ignore it at the UI layer by defining columns directly in the
DataGrid. Another way would be to have the web service return a purpose-built entity
with only the columns you want.
 Neither solution is helpful from a reuse standpoint. In many systems, different
screens show different aspects of what could be the same entity. Others, such as this
example, have to compose two data entities into a single displayable result. Working
with entities shaped like that can be a pain. Returning only a subset of the information
back from the web service may help, but only if no other information is required for a
successful update and no other areas of the system need the remaining information.
 One way to deal with situations like this is to create per-View entities. The View-
Model surfaces a collection of these View-specific entities, doing the shaping behind
the scenes. This way, the designer of the View needn’t be concerned with composing
entities, combining fields such as first and last name, and more. 
 In the MVVM pattern, those entities are frequently promoted up as ViewModels
themselves. If you consider that the definition of a ViewModel includes both the data
and the functionality required for a View, this makes sense. Consider that these View-
Models can provide the functionality for calling the vacation bonus service and can
then be reused in the detail pop-up, and you can quickly see how these entity-like
ViewModel classes can be helpful.
 For this example, you’ll update the application to use new EmployeeViewModel
classes in all the client-side places that once used the Employee data entity. First, listing
33.17 shows the new EmployeeViewModel class. Add it as a new class in your View-
Model folder.
using System;
using System.ComponentModel.DataAnnotations;
namespace MvvmApplication.ViewModels
{
  public class EmployeeViewModel : ViewModel
  {
    private string _firstName;
    [Display(Name="First Name")]
    public string FirstName
Listing 33.17
 EmployeeViewModel class

899
Better separation from the UI
    { 
      get { return _firstName; }
      set 
      {  
        _firstName = value; 
        NotifyPropertyChanged("FirstName");
        NotifyPropertyChanged("FullName"); 
      }
    }
    private string _lastName;
    [Display(Name = "Last Name")]
    public string LastName
    {
      get { return _lastName; }
      set 
      { 
        _lastName = value; 
        NotifyPropertyChanged("LastName"); 
        NotifyPropertyChanged("FullName"); 
      }
    }
    [Display(Name = "Full Name")]
    public string FullName
    {
      get { return LastName + ", " + FirstName; }    
    }
    private string _title;
    public string Title
    {
      get { return _title; }
      set { _title = value; NotifyPropertyChanged("Title"); }
    }
    private DateTime _hireDate;
    [Display(Name = "Hire Date")]               
    public DateTime HireDate
    {
      get { return _hireDate; }
      set { _hireDate = value; NotifyPropertyChanged("HireDate"); }
    }
    private short _vacationHours;
    [Display(Name = "Vacation Hours")]
    public short VacationHours
    {
      get { return _vacationHours; }
      set 
      { 
        _vacationHours = value; 
        NotifyPropertyChanged("VacationHours"); 
      }
    }
Calculated field
Friendly field name

900
CHAPTER 33
Structuring and testing with the MVVM pattern
    private short _sickLeaveHours;
   [Display(Name = "Sick Leave Hours")]              
    public short SickLeaveHours
    {
      get { return _sickLeaveHours; }
      set 
      { 
        _sickLeaveHours = value; 
        NotifyPropertyChanged("SickLeaveHours"); 
      }
    }
    private bool _salaried;
    public bool Salaried
    {
      get { return _salaried; }
      set { _salaried = value; NotifyPropertyChanged("Salaried"); }
    }
  }
}
Note that this class looks like most entity classes. There’s a calculated field for the
FullName, as well as direct exposure of each of the other properties of interest in the
employee data class. You use Display annotations from System.Component-
Model.DataAnnotations to make the DataGrid show friendly column names for these
properties. Annotating for display was discussed in chapter 17. You could also include
validation annotations from chapter 18, but that’s unnecessary for this example.
 Whether you consider this class to be a ViewModel depends on how you’ll use it. If
you add functionality to call services, for example, it becomes more clear-cut in most
people’s eyes that this is a real ViewModel. For me, ViewModel or entity isn’t a huge
issue, as long as you follow the separation of concerns you’ve been working toward
throughout this chapter.
 The EmployeeListViewModel class also needs to change to support the new
EmployeeViewModel class. Listing 33.18 shows the changed properties and methods of
the EmployeeListViewModel class. Note that the other properties and methods,
including the AddVacationBonusToSelectedEmployee method, the OnEmployees-
Loaded method, the CanAddVacationBonus property, and the AddVacationBonus com-
mand property, all stay the same.
private EmployeeViewModel _selectedEmployee;
public EmployeeViewModel SelectedEmployee
{  ...  }
private ObservableCollection<EmployeeViewModel> _employees;
public ObservableCollection<EmployeeViewModel> Employees
{  ...  }
...
public void LoadEmployees()
{
  if (_dataService.AreEmployeesLoaded)
Listing 33.18
Changes to EmployeeListViewModel class
Friendly field name

901
Better separation from the UI
  {
    ShapeAndLoadEmployees(_dataService.Employees);
  }
  else
  {
    _dataService.EmployeesLoaded += (s, e) =>
      {
        ShapeAndLoadEmployees(_dataService.Employees);
      };
    _dataService.LoadEmployees();
  }
}
private void ShapeAndLoadEmployees(IList<Employee> employees) 
{
  var shapedEmployees = new ObservableCollection<EmployeeViewModel>();
  foreach (Employee emp in employees)
  {
    EmployeeViewModel vm = new EmployeeViewModel
    {
      FirstName = emp.Contact.FirstName,             
      LastName = emp.Contact.LastName,             
      Title = emp.Title,
      Salaried = emp.SalariedFlag,
      SickLeaveHours = emp.SickLeaveHours,
      VacationHours = emp.VacationHours,
      HireDate = emp.HireDate
    };
    shapedEmployees.Add(vm);
  }
  Employees = shapedEmployees;
  OnEmployeesLoaded();
}
The largest change in the class in listing 33.18 is the LoadEmployees method. You add
a bit of data shaping and flatten the two-class Employee/Contact combination into a
single EmployeeViewModel class with only a few properties. The majority of this work is
done in the ShapeAndLoadEmployees method. It iterates through the employees in
the data service and builds the ViewModel classes, assigns the collection to the
Employees property, and raises the data-loaded event.
 The last place affected by this change is the EmployeeDetail ChildWindow. Listing
33.19 shows the changes to the two TextBox instances and one CheckBox instance in
the EmployeeDetail pop-up XAML.
<TextBox Height="23" Width="140" Margin="127,14,0,0"
         HorizontalAlignment="Left" VerticalAlignment="Top"
         x:Name="FirstName"
         Text="{Binding FirstName, Mode=TwoWay}" />
...
<TextBox Height="23" Width="140" Margin="127,43,0,0"
Listing 33.19
Changes to EmployeeDetail.xaml
Shape 
and load 
employees
Flatten structure

902
CHAPTER 33
Structuring and testing with the MVVM pattern
         HorizontalAlignment="Left" VerticalAlignment="Top"
         x:Name="LastName"
         Text="{Binding LastName, Mode=TwoWay}" />
...
<CheckBox x:Name="Salaried" Height="16" Margin="127,101,0,0"
          HorizontalAlignment="Left" VerticalAlignment="Top"
          Content="Salaried"
          IsChecked="{Binding Salaried, Mode=TwoWay}" />
The only changes required in listing 33.19 are the binding statements, due to the dif-
ferent property names and property paths for the new simplified class. Con-
tact.FirstName becomes FirstName, Contact.LastName becomes LastName, and
SalariedFlag becomes Salaried. The code-behind requires even fewer changes—
just the Employee property, in this case:
private EmployeeViewModel _employee;
public EmployeeViewModel Employee 
{
  get { return _employee; }
  set { _employee = value; DataContext = _employee; }
}
The EmployeeList.xaml and related code-behind require no changes. With all the
other changes in place, run the application. The first thing you’ll notice is the
reduced column count in the DataGrid, as well as the friendly column headers. Figure
33.7 shows the newly refactored application. There’s also the calculated Full Name
field, which was unavailable in the entity data model. 
Figure 33.7
View of the application using the newly minted EmployeeViewModel entity ViewModel
class. Note the reduced column count as well as the nice column headers. Note also the Full Name 
calculated field.

903
Better separation from the UI
33.4.4 Interfaces, IoC, and ViewModel locators
So far, all the changes you’ve made have improved the separation of concerns in the
application and have helped its overall structure. But although you may have elimi-
nated onerous coupling, such as that between the UI and the database, each of the
classes are still tightly coupled to each other. For example, the View is tightly coupled
to a ViewModel, using a new statement in the code-behind to create it. Similarly, that
EmployeeListViewModel is tightly coupled to the EmployeeDataService and the
EmployeeVacationBonusService.
 At first glance, you may think “So?” and I wouldn’t blame you. This is definitely
one area where the benefits are highly proportional to the size of the system and the
amount of code churn. If you have a highly active development project or a really
large system, or a really fickle customer, you’ll want to pay extra attention.
INTERFACES AND IOC
By implementing ViewModels and services as interfaces, you can allow them to be
swapped in and out with alternative implementations. This can be useful when you’re
developing and don’t yet have the real data store, when you’re designing the UI and
don’t want the designer to have to have the full development environment, and when
you’re testing where you may want to substitute scenario-driven classes and data that
will return specific results each time.
 Inversion of Control (IoC) enables developers to design the system in such a way
that they don’t new up (directly create) any objects of consequence in their code.
Instead, they ask an IoC container to resolve for an object of a given type. The IoC
container can make a number of decisions based on the request—returning a test ver-
sion or a production version, for example. The IoC container can also serve up a sin-
gle shared class instance, effectively a singleton without the singleton plumbing.
 Some developers use interface-based development and IoC for everything because
they’ve mastered its use and have found it speeds up their work. I’m not one of those
developers, but I can certainly appreciate where mastery of this pattern can allow
effective use across projects regardless of size or complexity.
 Another interesting concept is that of the ViewModel locator. Often, ViewModel
locators are themselves implemented using IoC.
VIEWMODEL LOCATOR
A ViewModel locator is a service that can supply a ViewModel instance to a View. That
instance may be internally cached, hard-coded, or delivered via IoC. I’ve even seen some
interesting implementations that use the Managed Extensibility Framework (MEF).
 An extremely simple ViewModel locator that keys off the view name may look some-
thing like listing 33.20. Create the ViewModelLocator class in the ViewModels folder.
using System.Collections.Generic;
namespace MvvmApplication.ViewModels
{
Listing 33.20
A simple ViewModel locator using hard-coded ViewModel instances

904
CHAPTER 33
Structuring and testing with the MVVM pattern
  public class ViewModelLocator
  {
    private Dictionary<string, ViewModel> _viewModels = 
          new Dictionary<string, ViewModel>();
    public ViewModelLocator()
    {
      _viewModels.Add("EmployeeList", new EmployeeListViewModel());
      _viewModels.Add("EmployeeDetail", new EmployeeViewModel());
    }
    public ViewModel this[string viewName]      
    {
      get { return _viewModels[viewName]; }
    }
  }
}
In practice, a real locator would have a much more robust mechanism for discovering
and adding ViewModel instances to its internal list. In this example, they’re all hard-
coded, and you don’t allow for more than one instance of any specific type. Addition-
ally, the only usable one is the EmployeeListViewModel, because the EmployeeDetail
would need instancing.
 The ViewModel locator is surfaced as a resource to be used in binding. The
resource itself would be defined in a resource dictionary merged into App.xaml in
order to have application-wide scope. Listing 33.21 shows an updated App.xaml with
this resource included and a new Resources.xaml file in the Assets folder.
App.xaml:
<Application x:Class="MvvmApplication.App"
  xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
  <Application.Resources>
    <ResourceDictionary>
      <ResourceDictionary.MergedDictionaries>
        <ResourceDictionary Source="Assets/Styles.xaml" />
        <ResourceDictionary Source="Assets/Resources.xaml" />
      </ResourceDictionary.MergedDictionaries>
    </ResourceDictionary>
  </Application.Resources>
</Application>
Assets/Resources.xaml:
<ResourceDictionary
   xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
   xmlns:vm="clr-namespace:MvvmApplication.ViewModels"
   xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
  <vm:ViewModelLocator x:Key="ViewModelLocator" />     
</ResourceDictionary>
Listing 33.21
 The ViewModel locator in XAML
Indexer for binding
Merged 
dictionary
ViewModelLocator

905
Better separation from the UI
To use this locator, you eliminate the ViewModel creation from the code-behind and
bind to this resource. In the EmployeeList.xaml file, this is as easy as adding the fol-
lowing line to the navigation:Page element:
DataContext="{Binding [EmployeeList], 
➥ Source={StaticResource ViewModelLocator}}"
That code sets the DataContext of the page to the value returned from the calling the
ViewModelLocator’s indexer function, passing in the string EmployeeList. 
 You then change the EmployeeList code-behind so the OnNavigatedTo event uses
the ViewModel provided by the locator rather than one created in the code-behind.
Listing 33.22 shows the updated OnNavigatedTo method.
private EmployeeListViewModel _viewModel = null;
protected override void OnNavigatedTo(NavigationEventArgs e)
{
  _viewModel = DataContext as EmployeeListViewModel;
  _viewModel.EmployeesLoaded += (s, ea) =>
    {
      LoadingProgress.Visibility = Visibility.Collapsed;
    };
  LoadingProgress.Visibility = Visibility.Visible;
  _viewModel.LoadEmployees();
}
Note that this is one place where an interface makes good sense: have the locator
return a class that implements the interface, and have the code in the code-behind
aware only of that interface, not of the concrete class itself. After all, if you’re going to
go through the effort to dynamically resolve the ViewModel, it makes little sense to
work with concrete types that could be instantiated.
 A larger discussion around these topics, especially interface-based development
and IoC, would take more room than I have in this chapter, but I did want to make
you aware of them because they’re often used with the ViewModel pattern. Many
MVVM toolkits include support for interface-based design as well as various types of
locators. When evaluating those toolkits, you’ll now know how they’re used.
 Commands and behaviors help decouple the UI from the code that supports it.
Rather than having concrete compile-time hooks into various other classes in the sys-
tem, the hooks are more dynamic and resolved via binding or even string lookup at
runtime. One of the more egregious couplings in the system was the entity data-model
types permeating all layers, effectively tying the entire application to the database
schema. Fixing that by introducing the entity-type ViewModel goes a long way toward
freeing the front end from the back end. The use of interfaces, ViewModel locators,
and patterns such as IoC take the decoupling to a higher level, making the application
Listing 33.22
Updated OnNavigatedTo method in the EmployeeList code-behind

906
CHAPTER 33
Structuring and testing with the MVVM pattern
as a whole more resilient to change and easier to maintain. In addition, this loose cou-
pling makes it easier to break these pieces apart, especially for testing.
 In the next section, you’ll learn how to test Silverlight applications, specifically
those that have been designed with the principles in this chapter in mind.  
33.5
Testing MVVM applications
Most developers consider patterns such as MVVM specifically for the testability they
enable in an application architecture. Oftentimes, other benefits are secondary. A pat-
tern such as MVVM, which separates the UI logic from the application and business
logic, naturally lends itself to making testing easier and more complete.
Testing is a heavily overloaded word. For some people, it’s a way to spec out a sys-
tem, using tests as the drivers and documentation. For others, it means running
through a few verification steps as part of a build process. For still others, it’s a project
manager banging away at a keyboard and “trying to break the system.”
 Each of those definitions has tools that best support it. Many great unit-testing,
test-driven development, and keyboard-jockey testing tools are available out there,
both free and open source as well as commercial.
 For this section, I’ll focus on unit testing of Silverlight functionality, using the free
Silverlight Unit Testing Framework. You’ll first try a few tests that have nothing to do
with your application. Then, because it must be broken apart to support testing, you’ll
refactor the application into two projects. When the refactoring is complete, you’ll try
three simple tests to exercise synchronous logic through the ViewModel class. The
final test will be an asynchronous data-loading test, used to verify that the employees
are being correctly downloaded from the server. 
33.5.1 Introduction to the Silverlight Unit Testing Framework
The Silverlight Unit Testing Framework consists of a test runner and test metadata
developed as part of the Silverlight toolkit. To use the Silverlight Unit Testing Frame-
work, you’ll need to install the Silverlight Toolkit. If you don’t already have it installed,
you can grab the latest version from http://silverlight.codeplex.com.
 When you have the toolkit installed, you’ll get a new template in Visual Studio.
Continuing with the same solution you’ve been working with for this chapter, add a
new Silverlight Unit Test Application project. I named mine MvvmApplication.Tests.
Figure 33.8 shows the Add New Project dialog with the correct options selected.
 When prompted, add this project to the same website that’s already in your
solution.

907
Testing MVVM applications
The project template automatically includes a single default test. You’ll replace that
with three simple tests that show how to use the Assert object and its functions. List-
ing 33.23 shows the three tests in place in the default Tests class.
namespace MvvmApplication.Tests
{
  [TestClass]
  public class Tests
  {
    [TestMethod]
    public void TestToMakeSureTrueIsActuallyTrue()
    {
      Assert.IsTrue(true);
    }
    [TestMethod]
    public void TestToMakeSureTheListObjectIsNotNull()
    {
      List<int> l = new List<int>();
      Assert.IsNotNull(l);
    }
    [TestMethod]
    public void ThisTestShouldFail()
    {
      Assert.IsTrue(false);
    }
  }
}
Listing 33.23
Simple tests
Figure 33.8
Adding a new Silverlight Unit Test Application to the solution. I named the project 
MvvmApplication.Tests, but the name isn’t important.

908
CHAPTER 33
Structuring and testing with the MVVM pattern
The tests include two that should pass without any issue and one that should fail 100
percent of the time. Set the automatically added test ASPX file in the web project to
the start page and run (run; don’t start in debug mode unless you want to break on
the exception). When you do, it’ll look something like figure 33.9.
 Simple tests are…simple. They help you understand how the test system works, but
they’re not doing anything useful for you yet. You want to test functionality in the
application itself. To do that, you’ll need to put all the testable stuff into one or more
class libraries. To keep things simple, you’ll move everything but the views into a sin-
gle core project.
 Create a Silverlight Class Library named MvvmApplication.Core. Then, go into its
project properties and set the default namespace to MvvmApplication, as shown in fig-
ure 33.10.
Figure 33.9
Silverlight unit test runner with two passed tests and one failed test
Figure 33.10
Setting the default namespace on a class library project

909
Testing MVVM applications
Setting the namespace will allow you to keep everything the same as it was in the main
Silverlight application.
 Next, create a Services folder and a ViewModels folder in the new class library proj-
ect. Drag the contents of those folders from the old project to the new, then remove
the folders and their contents from the old project.
 The next step is to swap the service reference over to the new project. In the
MvvmApplication.Core project, right-click and choose Add Service Reference. Pick the
web service in the web project, and set the namespace to Services as you did in the orig-
inal project. Then, delete the service reference from the original Silverlight project.
 Before you do any in-code/markup cleanup, you need to add a project reference
from the main application to the core application. Right-click the MvvmApplication
project, choose Add Reference, and select the MvvmApplication.Core project.
 Do a build, and clean up the errors. You’ll need to add a reference to System.Com-
ponentModel.DataAnnotations in the core project. When that’s done, open the
Resources.xaml file and change the vm prefix to point to
xmlns:vm="clr-namespace:MvvmApplication.ViewModels;
➥ assembly=MvvmApplication.Core"
The last step is to delete the old ServiceReferences.ClientConfig from the MvvmAppli-
cation Silverlight project and add the one from core as a reference. When you’ve
deleted the old file, right-click the MvvmApplication project and choose Add > Exist-
ing Item. Navigate to the core project, and select the ServiceReferences.ClientConfig
file. Click the drop-down arrow on the Add button, and select Add As Link, as shown
in figure 33.11.
Figure 33.11
Add the ServiceReferences.ClientConfig file from the core project to the main project 
using the Add As Link option.

910
CHAPTER 33
Structuring and testing with the MVVM pattern
If you do this correctly, you’ll now see the ServiceReferences.ClientConfig file in the
main MvvmApplication project. Its icon will have the standard shortcut arrow overlay,
which indicates it’s a link. The build action should be automatically set to Content.
 The last step is to add a project reference from the MvvmApplication.Tests project
to the MvvmApplication.Core project. Right-click the MvvmApplication.Tests project,
select Add Reference, and select the MvvmApplication.Core project.
 When you’ve completed all these steps, set the application test page in the web
project as the start page and run the solution. Make sure the Silverlight app is running
and working as it did before. If everything is good, you’re ready to move on to doing
some real testing. 
33.5.2 Testing the ViewModel
In a well-architected MVVM application, testing the ViewModel covers the majority of
the scenarios you’d normally test through UI automation. The more value converters
or UI magic in use, the less meaningful the ViewModel test becomes. I don’t want to
scare you away from using awesome things such as value converters or validation
annotations, but it’s something you need to keep in mind when you’re testing.
 Caveats aside, testing the ViewModel will give you a pretty high level of confidence
that the majority of the system is working as designed, so let’s start there. In the test
project, remove the test class you created earlier. Add a new Silverlight Test Class file
to the MvvmApplication.Tests project and name it EmployeeListViewModelTests.
Listing 33.24 shows your first two tests.
[TestClass]
public class EmployeeListViewModelTests
{
  [TestMethod]
  public void SelectedEmployeeCanBeSetAndRetrieved()    
  {
    EmployeeViewModel employee = new EmployeeViewModel();
    EmployeeListViewModel vm = new EmployeeListViewModel();
    vm.SelectedEmployee = employee;
    Assert.ReferenceEquals(employee, vm.SelectedEmployee);
  }
  [TestMethod]
  public void EmployeeVacationBonusIsProperlyApplied()  
  {
    EmployeeViewModel employee = new EmployeeViewModel();
    EmployeeListViewModel vm = new EmployeeListViewModel();
    vm.SelectedEmployee = employee;
    employee.VacationHours = 0;
    employee.HireDate = DateTime.Today.AddYears(-4);
    vm.AddVacationBonusToSelectedEmployee();
    Assert.AreEqual(employee.VacationHours, 10);
    employee.VacationHours = 0;
    employee.HireDate = DateTime.Today.AddYears(-8);
Listing 33.24
The first ViewModel tests
SelectedEmployee
Bonus test

911
Testing MVVM applications
    vm.AddVacationBonusToSelectedEmployee();
    Assert.AreEqual(employee.VacationHours, 20);
    employee.VacationHours = 0;
    employee.HireDate = DateTime.Today.AddYears(-15);
    vm.AddVacationBonusToSelectedEmployee();
    Assert.AreEqual(employee.VacationHours, 30);
    employee.VacationHours = 0;
    employee.HireDate = DateTime.Today.AddYears(-25);
    vm.AddVacationBonusToSelectedEmployee();
    Assert.AreEqual(employee.VacationHours, 40);
  }
}
The first test tests the utility of the SelectedEmployee property. It checks to see that
when you assign an object to the property, the object can be retrieved. The second test
exercises the vacation bonus logic. Note that this test doesn’t have 100 percent cover-
age for the full domain of hire dates and vacation hours; to do that, every value from
zero through some reasonable upper bound would need to be tested.
 Both of these tests cover synchronous functionality only—you do something and
hang around until the result comes back. If you want to test anything network related
in Silverlight, you need to use an asynchronous test.
33.5.3 Testing asynchronous operations
Testing asynchronous operations takes a little extra work. You’ll need a different test
base class and the asynchronous methods it exposes. Listing 33.25 shows an asynchro-
nous call test against the EmployeeDataService class.
[TestClass]
public class EmployeeDataServiceTests : SilverlightTest
{
  [TestMethod]
  [Asynchronous]
  public void TestEmployeeServiceCallReturnsData()
  {
    var service = new EmployeeDataService();
    service.EmployeesLoaded += (s, e) =>
      {
        Assert.IsNotNull(service.Employees);
        Assert.IsTrue(service.Employees.Count > 0);
        EnqueueTestComplete();                 
      };
    service.LoadEmployees();
  }
}
Listing 33.25 shows the test class inherited from the SilverlightTest base class. This
immediately makes your class fall outside of code compatibility with the full Visual
Studio testing framework. That’s a concern only if you want to share your tests with
Listing 33.25
Asynchronous call test
Mark as complete

912
CHAPTER 33
Structuring and testing with the MVVM pattern
full .NET projects, or if you have plans to migrate them to another testing platform in
the future.
 The SilverlightTest base class supplies the critical EnqueueTestComplete
method. That method tells the test framework that the method is complete, and the
framework can release it from the holding pattern created by the [Asynchronous]
attribute.
 Before running the test, there’s one more step. Just as you did when breaking the
original Silverlight project in two, you need to add the ServiceReferences.ClientCon-
fig file to the MvvmApplication.Tests project, as a link. That file is generated by the
project that has the service reference, but it must be located by the project that’s the
main entry point of execution.
 The Silverlight Unit Testing Framework is a capable test framework for Silverlight.
When it first came out, there were no other supported Silverlight testing frameworks.
Now you have several choices.
 The Silverlight Unit Testing Framework has some trade-offs, such as not being inte-
grated with any build processes and requiring a run to see the results rather than keep-
ing an open window or a docked pane in the IDE. You’ll need to evaluate those for your
own projects and stack up the framework against other robust unit-testing frameworks.
 When you structure your application using MVVM principles and good coding and
architecture practices, it makes your applications much easier to test. It’s important to
test. It’s critical to unit-test functionality and to keep those tests up to date. It’s benefi-
cial to use tests to drive functionality using a TDD-derived approach. If there were no
way to test Silverlight code, you definitely wouldn’t be in your happy place. I hope the
simplicity of the Silverlight Unit Testing Framework will help you integrate testing
into your own application development cycle. 
33.6
Summary
When you get into developing applications of complexity beyond basic samples, your
code can get pretty ugly quickly if you don’t follow a good architectural pattern such
as MVVM. In this chapter, you’ve moved from a basic-but-common code-behind solu-
tion to a decent MVVM implementation. To take it to the next level, you’ll want to
incorporate an MVVM toolkit and use the facilities built into that.
MVVM, or the ViewModel pattern, isn’t scary when you peel the onion back layer
by layer, refactoring between each and incorporating features as you understand
them. Silverlight includes support for behaviors and commands to help separate the
UI from the functions the UI calls. The patterns you follow will help you reuse code
between different ViewModels or between different parts of the system.
 When you have an application with decent separation of concerns between compo-
nents and layers, you open up the ability to easily test the components. The Silverlight
Unit Testing Framework is a nice in-box (well, in-toolkit) solution for unit-testing Sil-
verlight applications. It’s not the only game in town, but it’s certainly a decent player.
 While you’re looking at what it takes to build real systems, you’ll turn to WCF RIA
Services in the next chapter.

913
Debugging your
application
I’ve recently gotten into electronics. I blame the Netduino, and later the .NET Gad-
geteer and related microcontrollers for being the gateway drugs that got me into
that. I’ve learned to connect basic circuits and use ICs, diodes, and so forth. I’m
currently working to learn how to use transistors effectively. When the circuit works
as intended, all is great. I haven’t let the magic blue smoke out of anything yet, but
sometimes the circuit just doesn’t work as I thought it would. In those cases, I have
to find ways to debug it.
 Nothing makes you aware of your actual knowledge level more than debugging.
Just as with electronics, many of our colleagues can design applications and write
code, but the true test of knowledge comes when the code doesn’t work as
intended, and they need to debug it. 
This chapter covers
■
Using general debugging techniques 
■
Debugging binding statements
■
Debugging network and services issues

914
CHAPTER 34
Debugging your application
 Good debugging skills come only with experience and practice. If certification
tests really wanted to judge knowledge, they would contain nothing but debugging
questions. That said, you have to start somewhere, and knowing some basic tech-
niques and tools to help you get started is important. 
 In general, Silverlight debugging is like debugging on any other .NET-based plat-
form. But because so few third-party debugging tools work with Silverlight, it’s worth
taking a look at some of the tried-and-true debugging approaches Silverlight develop-
ers can use.
 In this chapter you’ll first start with the basics of debugging, such as using the built-
in Debug class to display status information and to break on certain conditions, using
breakpoints, and even using MessageBox as a last resort. You’ll then look at a few spe-
cific debugging scenarios, including several techniques for binding debugging and
then using Fiddler to debug network and service issues.
34.1
Debugging basics
Regardless of which technology you work with, some basic techniques for debugging
span just about any type of problem you’re working on. Printing information about
the status of the application as it’s running goes all the way back to blinking lights on
early computers and teletypes shortly thereafter.1 Back when I was learning C in col-
lege, we’d printf the heck out of everything just to figure out what was going on,
because we had no IDEs, and most of us had no idea how to use the debugging tools
on those Unix machines. Compilers were just command-line affairs at the time.
 Developers new to .NET or new to Visual Studio may not realize what facilities are
available to them for debugging. Developers who know .NET inside and out may be
surprised to learn how little of the .NET debugging and tracing infrastructure is actu-
ally included in Silverlight. Silverlight supports just enough to get you by, without
including all the advanced tracing and pluggable event listening functionality present
on the full version of the framework.
 This section starts with a survey of the Debug class. You’ll learn how to use it to write
information to the output window and to stop execution based on a condition in code.
After that, you’ll take a look at IDE breakpoints and how to use them in your applica-
tions. This section wraps up with a brief discussion of the MessageBox and how to use
it for debugging, including how to create a special-purpose DebugMessageBox class.
34.1.1 Using the Debug class
Most platforms have built-in support for debugging—.NET is no different. The debug-
ging support in Silverlight is a little trim compared to the full .NET Framework, but
nevertheless, it can be useful.
 The System.Diagnostics namespace in the system assembly in Silverlight contains
only a single class: Debug. You won’t find the performance counter information,
1 There were two teletypes in the computer room at my college, but I studiously avoided them. And no, I’m not
quite old enough to have had to debug apps via blinking lights, although I do that a lot now with electronics.

915
Debugging basics
StopWatch, trace event listeners, event log writing, or other features from the full .NET
framework.
 The Debug class has two methods: Assert and WriteLine, each with a number of
overloads. The two methods together comprise the most common approach to debug-
ging Silverlight applications.
DEBUG.WRITELINE
I constantly use Debug.WriteLine in my own applications; it’s a quick and easy way to
spit some text out at runtime without creating a special presentation surface within
your application.
 Given the absence of other types of listeners, output from Debug.Write in Silver-
light is sent to the IDE’s output window. For example, to show some text in the output
window in the IDE you’d simply write:
Debug.WriteLine("Hello World");
When you run it, you’ll see it in the output window along with everything else, as
shown in figure 34.1. To help it stand out, you may want to prefix the text with aster-
isks or the word “DEBUG” or something else that will be easy for you to see.
 The output window is useful, but it tends to get spammy during the run of a large
application. Lots of different components send output there, and after a while, even
the proliferation of strings from your own application can be a bit much. That said,
it’s one of the most useful ways to track what’s going on in your application without
interrupting its flow.
 Sometimes, you do want to interrupt flow. In those cases, Debug.Assert is exactly
what the doctor ordered.
Figure 34.1
The output window showing the text displayed from Debug.WriteLine. Unfortunately, 
the helpful rectangle highlighting the output is a feature of Microsoft Paint, not of the IDE.

916
CHAPTER 34
Debugging your application
DEBUG.ASSERT
The Debug.Assert function is useful for adding debug-time checks directly in code.
The most common place to do this is to check parameters being passed to internal non-
public functions. You control the function, and you control the callers of the function.
Therefore, you don’t necessarily need the overhead of guard conditions in the produc-
tion code, but you do want to check for them during development. For example:
private void Foo(int index)
{
  Debug.Assert(index > 0, 
               "Index not > 0. What do you think this is, C?");
}
The Assert function takes in a Boolean condition as well as a number of other
optional parameters. The most commonly used overload is the one shown here,
where you have the condition as well as a message that’s displayed when the condition
isn’t met. When the Boolean statement evaluates to false, you’ll get a message box
with the option to continue or to stop and debug, as shown in figure 34.2.
 If you click OK in the dialog, the code will proceed. If you click Cancel, you’ll get
popped into the IDE where you can use the normal debuggers and inspectors avail-
able during breakpoints. Speaking of breakpoints, that’s my favorite approach to use,
so I’ll cover that next.
34.1.2 IDE breakpoints
Visual Studio, like most modern IDEs, supports adding breakpoints to code. A break-
point is, as the name implies, a point at which the application will stop executing and
break into the code editor. At that point, you can inspect values in scope, step through
code one statement at a time, and generally look at the code and state of the application.
 Breakpoints are always in executable code, not in markup or data files. Silverlight 5
also allows a new type of breakpoint: a binding breakpoint in XAML. More on that
when I cover binding debugging.
Figure 34.2
The Assertion 
Failed dialog produced by 
Debug.Assert. My error 
message wasn’t particularly 
helpful because I didn’t display 
the value that was passed. At 
least it’s better than the old 
Abort, Retry, or Fail messages.

917
Debugging basics
Silverlight doesn’t support editing code while in break mode. This feature, called Edit
and Continue, is typically associated with Visual Basic applications because that’s the
platform that pioneered it. But the Silverlight development environment and runtime
don’t permit Edit and Continue with any language.2
CREATING AND USING BREAKPOINTS
To create a breakpoint in the IDE, click the column in the editor to the left of the code
listing. You’ll see a red dot that indicates a breakpoint. Breakpoints may only be placed
on executable statements, so variable declarations (for example) can’t have a break-
point associated with them. Figure 34.3 shows a breakpoint on a line of code with the
inspector open. The inspector automatically pops up when you hover over a property.
 The most common way to use breakpoints is to set them by clicking in the gray bar
to the left of the text editor. In those cases, the breakpoint will always stop when hit. In
Pro and higher versions of Visual Studio, you can also add conditional statements to
control when breakpoints are hit, much like using Debug.Assert. You set these
options by right-clicking the red breakpoint marker.
 Breakpoints are a standard VS2010/.NET feature, so I won’t go into much more
detail on them.3 But there’s one consideration that, though not unique to Silverlight,
tends to be much more common in Silverlight applications: breaking in async code.
BREAKPOINTS AND ASYNC CODE
Breakpoints present different challenges when using async operations and events.
This has always been the case, but on desktop and server .NET applications, async
operations tended to be the exception, not the rule.
 When debugging async code paths, you need to put a breakpoint in the async call-
back code or the code will never stop there. Putting a breakpoint in the caller code
isn’t sufficient. In addition, a breakpoint in the calling code interrupts the application
flow, typically masking any race condition errors you may have.
2 You’ll find that Edit and Recompile works pretty well, though. 
3 For a detailed look at how to use breakpoints, see this MSDN content: http://bit.ly/MSDNBreakpoints.
Figure 34.3
A breakpoint on a line of code. I ran the application, and execution stopped when I hit this 
line. Note how I can inspect the values of variables.

918
CHAPTER 34
Debugging your application
Figure 34.4 shows the usual two-step breakpoint setup for an async operation. The
first breakpoint is in the calling code; the second breakpoint is in the callback. Both
are optional depending on what exactly you need to debug.
 Breakpoints and stepping through code are together one of the most common
and useful ways to see exactly what your code is doing and see the values of variables at
runtime. As you saw with the Debug object, though, it’s not the only way to tackle this
problem. In the days before most of us had decent in-IDE debugging, we relied on a
tried-and-true (if a big ugly) approach to tracing our code: the MessageBox.
34.1.3 The good old MessageBox
Sometimes, the most convenient way to debug code is to add some MessageBox
instances. This can be useful in cases where you don’t see the same behavior while
stepping through (although the MessageBox will definitely derail any race condition
debugging) or to see full error messages.
 As a debug approach of last resort, the MessageBox is useful. But you need to make
sure you don’t accidentally leave the code in the production application. More than
one application has made it to end users with a strange “DEBUG: This branch should
never execute” message popping up on the user’s machine.
 For that reason, I encourage you to do one of two things:
■
Put #if DEBUG blocks around any MessageBox calls, and be sure to compile the
final version to release mode.
■
Create your own DebugMessageBox class, which is itself wrapped in #if DEBUG
blocks, and use only that when printing debug messages.
The first approach is simple but requires everyone to remember to put those pesky
blocks in their code. The second is much easier to remember and obvious when you
see the code. Third-party libraries are available that handle logging and debug dis-
plays, but I’ve included a short version of DebugMessageBox in listing 34.1.
using System;
using System.Windows;
using System.Diagnostics;
Listing 34.1
A simple DebugMessageBox implementation
Figure 34.4
A breakpoint pair in an async operation

919
Debugging basics
namespace DebugTools
{
  public class DebugMessageBox
  {
    public static void Show(string message)
    {
#if DEBUG                         
      Show("DEBUG", message);            
#endif
  }
    public static void Show(string prefix, string message)
    {
#if DEBUG
      string text = prefix + ": " + message;
      MessageBox.Show(text, "Debug Message", 
                      MessageBoxButton.OK);
      Debug.WriteLine(text);
#endif
    }
  }
}
Creating a separate class like the one in listing 34.1 gives you the option to change the
behavior in the future. For example, you could have it display a message in a child
window in out-of-browser applications, avoiding the modal interruption.
 This example makes use of the DEBUG conditional compilation symbol to define a
class with code that exists only when the application is compiled in debug mode.
When you compile to release mode, the class still exists, but the methods end up
being empty, and very likely optimized out by the JIT (Just In Time) compiler.
 Silverlight also defines the TRACE compilation symbol, which could be used for out-
putting custom trace code. Whether or not these symbols exist in your application is
controlled by the Build tab in the project properties, as seen in figure 34.5.
DEBUG symbol
Figure 34.5
The Debug configuration of the project, showing that the DEBUG symbol 
is defined. If you switch to Release mode, by default DEBUG is no longer defined, and 
the code optimization check box is checked. TRACE is defined in both cases.

920
CHAPTER 34
Debugging your application
You can see in figure 34.5 that Silverlight projects also define the SILVERLIGHT symbol
by default. This is useful for conditional compilation when you want to share the same
source code across multiple platforms.
All combined, the Debug class, IDE breakpoints, and the simple MessageBox make for
a useful set of tools for debugging your applications. I tend to start with breakpoints,
turning to Debug.Write only when breakpoints interrupt the flow, causing the prob-
lem to go away. I use Debug.Assert when designing internal APIs, for the guard code
mentioned earlier. I use MessageBox only as a last resort, typically only for cases when
the error doesn’t appear when the application is running from the development
environment.
 These techniques work for the normal types of code debugging and they will, by
far, be the most often used tools in your arsenal. But one type of debugging that pres-
ents a unique problem to Silverlight developers is binding debugging. 
34.2
Binding debugging
If you polled 100 Silverlight developers and asked them what the most difficult thing
to debug is, most of them would tell you it’s XAML binding. This is true for a number
of reasons. The most prevalent is it can be hard to just look at code and tell what the
binding context is going to be for a given element. Other issues are caused by the
many different layers that come into play, from templates to the page’s data context,
to dynamically changed element data context values set via code or via some other
binding statements. To further complicate things, binding statements in XAML are
simply strings. 
 Unfortunately, the binding system is full of strings as it uses reflection to resolve
names. Binding statements in XAML use strings for the source names, and property-
changed notifications in code typically use strings for property names as well.
 Whenever you represent code symbols (such as property names) as strings, you
create a wonderful opportunity for a lengthy and enjoyable debugging session. Mis-
spelling a word, failing to keep a string updated with the property name after a code
change, or even using incorrect casing can all cause silent binding failures. 
Debugging on the Mac
As great a job as the team did on making Silverlight work well on the Mac, there will
be times when your application has some strange behavior only reproducible on a real
Apple Mac. In those cases, you’ll want to use the Visual Studio Silverlight remote de-
bugging support.
In this book, I’ve generally only written about things I’ve done myself. Not owning a
Mac, this is not an area I have any experience with. Instead, I recommend reading
the MSDN article on remote debugging on the Mac here: http://bit.ly/MacRemote
Debug.

921
Binding debugging
 There are neat but slower approaches for eliminating the strings in code, mostly
using lambda expressions to represent property names, but in XAML, strings are here
to stay. In any case, the string alone isn’t the only possible point of failure; you could
simply have two types that can’t be converted to each other by the binding system.
 Because you can’t change the system, you need good approaches for debugging
when things go wrong. In this section, I’ll show you a few approaches for debugging
binding statements in XAML, starting with using the information in the output win-
dow. I’ll then show you a technique that uses custom value converters, and I’ll wrap up
with a look at Silverlight 5 support for binding statement breakpoints in XAML.
34.2.1 Viewing binding errors in the output window
When binding fails in XAML, you don’t typically see a runtime error or some other
obvious indicator that something bad happened. Instead, you see that your field
doesn’t contain a value or that the value wasn’t updated in your database. These can
be notoriously hair-pulling occurrences during development.
 In Silverlight 1 through 3, there was no support at all for debugging binding.
Then, sometime between Silverlight 3 and 4, Silverlight started spitting out fairly
detailed binding error information, viewable in the output window in Visual Studio
2010. These can be easily lost during the noise of a running application, but luckily
you can also view the output window after the application has closed.
 For example, I have a view model that has a CurrentPerson property of type
Person that contains FirstName and LastName properties. In XAML, I mistakenly
bound to just LastName rather than to CurrentPerson.LastName. The error that
showed up in the output window looked like this:
System.Windows.Data Error: 
BindingExpression path error: 'LastName' property not found on 
'DebuggingBindings.ViewModels.MainViewModel' 
'DebuggingBindings.ViewModels.MainViewModel' (HashCode=40362448).
BindingExpression: Path='LastName' 
DataItem='DebuggingBindings.ViewModels.MainViewModel' (HashCode=40362448);
target element is 'System.Windows.Controls.TextBlock' (Name='');
target property is 'Text' (type 'System.String').
I formatted the error myself; in the IDE, it’s all on one unbroken line and therefore
easily missed, but it’s there.
 That’s a helpful error message: it tells you right off that the LastName property isn’t
found on the view model. It then shows the binding expression used in XAML as well
as the type of element (TextBlock) that was attempting the binding. If the TextBlock
had a name, it’d be displayed here as well.
 A look through the output window will now help you with most binding errors you
run across. But because it can still be useful at times, let’s also take a look at a common
technique used before this feature was available: using custom debug value converters.

922
CHAPTER 34
Debugging your application
34.2.2 Debugging with custom value converters
One trick many of us used from the early days of Silverlight on was to create custom
value converters whose sole purpose in life was to provide a place for you to put a
breakpoint and inspect the values and types involved in the binding expression.
 I covered how to create and use value converters in chapter 15, so I won’t go into
detail on that here. But the value converter itself is simply blank, implementing the
interface but doing nothing more inside the methods than, perhaps, using Debug.Write
to display helpful information and provide a place for you to hang a breakpoint. The
value converter is then applied to any binding statement giving you difficulty. 
 When the binding statement is executed, the value converter’s methods will be
called. If you have a breakpoint in there, it will be hit, and the code will stop. Once
inside the converter, you can see the value being sent over as well as the type informa-
tion associated with it. This is by no means perfect (you don’t get the complete pic-
ture), but it does give you a window into what’s normally all framework code with no
user code hooks. 
 Once you solve the binding problem, you then need to remove the value converter
from the XAML statements. Much like using MessageBox in code, using custom debug
value converters is an intrusive debugging approach. With Silverlight 5’s new support
for binding XAML breakpoints, custom value converters are rarely seen except in
older applications.
34.2.3 Using XAML breakpoints
So far, the debugging approaches for binding have been pretty primitive. Using the
Output window requires you to scan through a heap of stuff to find the nugget you’re
looking for. Custom value converters can give you a window into the system, but they
require modifying the markup to debug it. There has to be a better way.
 Gladly, there is. The Silverlight 5 runtime and the Visual Studio tools for Silverlight
5 together enabled a new debugging feature: XAML breakpoints. Now, the notion of a
breakpoint in a markup language is just…strange. The markup isn’t executed like
code is, line by line, but rather parsed and converted into a set of trees of objects. So
how does this work?
 The trick is that the breakpoints aren’t on arbitrary XAML; they’re breakpoints spe-
cifically on binding in XAML. The only place in XAML where you can put a breakpoint
is on a Binding statement. Figure 34.6 shows two breakpoints set on the binding state-
ments in a bit of XAML.
Figure 34.6
Two binding breakpoints in XAML. The little “+” symbol inside the usual breakpoint 
marker means there’s a condition attached.

923
Troubleshooting network operations
If you want the statements to execute only when there’s an error, you can set a condi-
tional breakpoint. The conditional is why you see the little “+” symbols in the break-
points in figure 34.6. The condition is a little convoluted, so I’m including it here:
((System.Windows.Data.Debugging.BindingDebugState)
➥ BindingState).Error != null
It’s long only because of the large cast in parentheses. What it’s really saying is if the
BindingState.Error property has anything other than null, then break at this point.
 Once the breakpoint is hit, the locals window is populated with a ton of useful
information from the BindingState property. This includes any error information, as
well as the ability to drill down into all the objects involved as both the source and tar-
get of the binding statement. Figure 34.7 shows a small portion of this information.
 When compared to the relatively crude methods of inspecting the output window
for some text, or modifying the application to include the debug value converters, the
ability to debug XAML binding statements from within the IDE is a huge and key pro-
ductivity improvement for Silverlight 5. Binding debugging can still be a somewhat
painful experience, but this is like that lollipop they give you at the doctor’s office; it
helps take the edge off.
 Binding debugging is a problem confined mostly to XAML-based technologies:
WPF, Silverlight, Windows Phone, and Windows 8 XAML. One other type of debug-
ging, network debugging, is common across all sorts of environments; you can learn
from the solutions that web and other developers have come up with and apply them
to Silverlight. 
34.3
Troubleshooting network operations
Most Silverlight applications connect to the network to use services. Some of those ser-
vices are internal, such as a WCF SOAP Service to load your customer information.
Others are external, such as Twitter or Flickr web APIs. Internal services tend to be a
Figure 34.7
A small subset of the binding information available at the XAML 
binding breakpoint. This can be found in the locals window.

924
CHAPTER 34
Debugging your application
bit easier to debug, because you (usually) have access to the source code for the
server-side end of the project. In many cases, you can even load that source into your
project and debug it from there.
 But what about cases where you don’t have access to server-side source, or the
source isn’t helping you? In those situations, I’ve always turned to Fiddler, the web
debugging proxy. I was turned on to Fiddler by my web developer friends who would
often use it to help debug Ajax (and now, jQuery) applications. 
 Fiddler is a freeware web debugging proxy that logs HTTP and HTTPS traffic
between your computer and a service, whether that service runs on localhost, your
corporate server, or a third-party service. Fiddler is prolific in what it logs. It can be
enlightening to let it run on your machine just to see what applications are “phoning
home” during the day. You may be surprised.
 In this section, you’ll install Fiddler and get it running. You’ll then see what traffic
it logs on your machine. Finally, you’ll use it to troubleshoot problems by inspecting
the messages going between a Silverlight application and the service it’s using.
34.3.1 Installing Fiddler
Fiddler is a port 8888 proxy that, while running, sits in the middle of the HTTP(S) net-
work calls on your machine. Written by Eric Lawrence, Fiddler is a free download
from http://fiddler2.com/. Although Fiddler is free, consider sending Eric a little
something via PayPal (there’s a link on his site) if you find Fiddler useful. You can also
use his Amazon link to send him a commission without any cost to you, a win for both. 
 The installation package makes it easy to install on your machine. Although you
can install Fiddler on the server to debug specific things from the server point of
view,4 it’s almost always installed on the client as that’s the safest place for a proxy to
run, and also it’s typically the most appropriate place for debugging.
 The installer is self-explanatory: run it from the website and let it install on your
machine. Once done, launch the application. By default, it’ll start logging traffic in
real time. This traffic logging or monitoring is the primary use for Fiddler. 
34.3.2 Monitoring and logging traffic
Any application that supports using an HTTP proxy can be set up to use Fiddler. In the
case of Silverlight on Windows, this happens automatically through the WinINET cap-
ture in Fiddler. If you want to capture traffic to or from other stacks, you may need to
manually configure a proxy.
 If you use Fiddler with versions of Internet Explorer prior to IE9 localhost traffic
won’t be captured by default.5 With IE9 and later, you don’t need to do anything
4 This can be especially useful when you think the problem may be a proxy or piece of networking equipment
in your organization. Install Fiddler on the server (presumably a development or test server) and run Fiddler.
Then, compare what you receive there with what you sent from the client. If they’re not the same, you’ve
found your problem.
5 For more information on setting up monitoring of localhost for older versions of IE, see the Fiddler FAQ
here: http://bit.ly/FiddlerLocal.

925
Troubleshooting network operations
additional to allow Fiddler to capture traffic going to localhost; it’s supported
automatically. 
 The Fiddler traffic display shows you the HTTP status code, the protocol being
used, the host being called, the URL on that host, the size of the message, the content
type, the calling process, and much more. Figure 34.8 shows an example of what the
traffic display looks like.
 Fiddler lets you filter the connection information by a number of criteria. The
most often used feature for Silverlight developers is the Any Process button on the
toolbar. If you drag that over the running Silverlight application, you’ll see only calls
made from that process. The traffic details should be sufficient for you to figure out
which process hosts your application. But if you’re not sure which process is hosting
the app, a simple way is to open Task Manager and gently move the application
around the screen. Task Manager will show a small CPU spike for that application,
which you can then use to pinpoint the process number.
 Once you’ve isolated the process, you’ll want to inspect the network calls it’s making.
Simulating slow connections
Did you know that Fiddler can also be used to simulate slow connections? This can
be useful when you’re developing on a LAN (or on fiber like I do), and you need to
show what a consumer connection may look like. To do that, choose Rules > Perfor-
mance > Simulate Modem Speeds to slow everything down. Just don’t forget to turn
the option off later or you may end up wondering what on earth happened to your awe-
some developer PC.
Oh, and this makes a great prank to play on other developers in the office. Set this
up while they’re at lunch. For added fun, set the user agent to one of the mobile agents
to force them to get the mobile versions of the various sites.
Figure 34.8
A sampling of traffic captured by Fiddler during a few minutes one day

926
CHAPTER 34
Debugging your application
34.3.3 Inspecting individual requests
I ran the WCF RIA Services MVVM application from appendix D of the online
resources, logged in, clicked the button to calculate the vacation bonus, and then
saved the data. The traffic for that session is shown in figure 34.9.
 From the figure, you can see that the first request made is to the ASP.NET test page
hosting the Silverlight app. It then downloaded Silverlight.js and checked to see if I
have the latest version. It then downloaded the XAP. At that point, the Silverlight
application started running. I logged into the app, which caused calls to GetUser and
Login on the server. Then, the employees were loaded using the call to GetEmployees
with the additional sorting criteria.
 Clicking on that row in the list, I can inspect the request and response using the
inspectors on the right side pane of Fiddler. The request is on top and the response
below it. The whole pane is shown in figure 34.10.
Figure 34.9
Traffic from the RIA Services application covered in appendix D of the online resources
Figure 34.10
The Fiddler request and response view pane showing the raw view of the 
request at the top and the response on the bottom

927
Troubleshooting network operations
The unprintable character funkiness in the text is because RIA Services is using the
proprietary but more efficient binary encoding supported by WCF and Silverlight.
That aside, you can see the request URI in the top, formed as an HTTP request. You
can see the user agent as well as any other headers sent up. If the request also
included a body, as would be the case in a POST request, that would be shown as well.
 Below the request section, you can see the response. It shows a 200 OK status code
as well as content type and other headers. Below that, the actual response from the
server is shown. 
 Both panes are useful when you want to figure out if you’re sending up what you
think you’re sending, and if the server is returning something useful, even if your Sil-
verlight app isn’t showing it. They can also show you the direct results from any calls
looking for a ClientAccessPolicy.xml file, something that often trips up developers.
 The panes support much more functionality as well. Fiddler is named “Fiddler”
because you can modify the requests and even build new ones from scratch to test
your server. This can really help if you want to quickly test the effect of a change with-
out trying to figure out how to implement it in code.
 One of the other features supported is a basic traffic analysis that gives you an idea
of how your application is performing. You can see that in the Statistics tab. Here’s a
subset of the information captured and calculated:
Request Count:  1
Bytes Sent:     762(headers:762; body:0)
Bytes Received: 7,365(headers:261; body:7104)
ACTUAL PERFORMANCE
--------------
ClientConnected:21:56:37.244
ClientBeginRequest:21:56:37.796
ClientDoneRequest:21:56:37.796
ServerConnected:21:56:37.796
FiddlerBeginRequest:21:56:37.796
ServerGotRequest:21:56:37.796
ServerBeginResponse:21:56:38.402
ServerDoneResponse:21:56:38.402
ClientBeginResponse:21:56:38.402
ClientDoneResponse:21:56:38.402
Overall Elapsed:00:00:00.6060606
While certainly no substitute for formal profiling, it can quickly help you determine
whether your network is the bottleneck in your application or if you need to look else-
where.
 Network operations are often opaque, happening well behind the UI layer of the
application. In addition, the code that makes the call is often buried inside client
proxies and other generated code. For those reasons, these operations can be difficult
to debug in a meaningful way. To effectively debug these calls, and avoid spending
time in code when the problem may be external, you need tools that can look at the
messages going over the wire.

928
CHAPTER 34
Debugging your application
 Fiddler is one of the most useful tools you can have when it comes to debugging
network calls in your Silverlight applications. It certainly helps that it’s also a free tool
and is highly respected and well used in the web development community. There are
other tools worth investigating as well if you need even lower-level information when,
for example, diagnosing sockets calls. One that I’ve used in the past is called Wire-
shark. You can easily find it on the internet, and it’s also free. 
NOTE
Most browsers include debugging tools right in the browser. If you’re
running the Silverlight application in-browser and not using the client net-
working stack, you can use those tools as well. They’re heavily optimized for
HTML/JavaScript applications in most cases.
34.4
Summary
Debugging is one of the most important skills you can have. If you can’t debug it, you
probably shouldn’t be getting paid to write it. A bold statement, for sure, but a realis-
tic one. Debugging (and testing) is as critical a part of the development process as any
other step. In fact, most developers spend the majority of their time on debugging,
not on laying down fresh code. Some people estimate debugging is as much as 80 to
90 percent of the time spent developing a complex system!
 In the end, it’s the quality and thoroughness of the debugging and testing, as
much as the design and coding, that determines the stability of the system.
 In this chapter, you saw a number of tools and techniques, including debug
objects, breakpoints, the output window, Fiddler, and MessageBox. Much like a car-
penter’s hammer, these are the tools you can use, but you’ll only get the experience
on the job or in your own development projects. I encourage you to exercise them as
often as possible, even on simple systems, to build up your own toolbox of techniques
to call on in the future.
 The next chapter is the final chapter of this book. Fittingly, I’ll look at what’s often
one of the last things added to a project: a good end-user install experience and
preloader.

929
The install experience
and preloaders
An often-overlooked aspect of putting a plug-in-based application on the internet
is the experience of a brand-new user. Truthfully, plug-in apps aren’t unique in
this. I’ve seen many Windows client applications that depended on Registry entries
or other files created during normal use but not present at first install. It’s easy to
be sloppy about testing that scenario because it’s so far removed from our day-to-
day lives.
 Nevertheless, not everyone in the world has Silverlight installed on their
machines, and not everyone has your application in their download cache. Any-
thing that gets between your user and using your application is a barrier that will
cause attrition. You need to continue to entice users to install the plug-in and wait
for your application to download (if it’s large) in order not to lose them.
 In this chapter, you’ll first learn how to customize the initial plug-in install and
upgrade experience. Then, because some applications can be large and have lots of
assets, I’ll show you approaches for building a custom preloader using XAML and
JavaScript. 
This chapter covers
■
Handling “Silverlight not installed” scenarios
■
Creating a custom preloader or splash screen

930
CHAPTER 35
The install experience and preloaders
35.1
Handling the ‘Silverlight not installed’ scenarios
Although Silverlight has achieved excellent
market penetration since it was first intro-
duced (it’s around 80 percent as of this writ-
ing), you’re still going to run into instances
where the plug-in isn’t installed on the user’s
machine. In those cases, the user will get the
default Please Install Silverlight image, as
shown in figure 35.1.
 The default install image is okay, but it
almost certainly doesn’t fit with the design of
your application. More important, it offers
no information about what your application
will provide after Silverlight is installed.
 Research has shown that in order to get users to install the plug-in, they need to
see what immediate benefit they’ll get by doing so. The usual way to handle this is to
show information about your application—perhaps an explanation, almost certainly
screenshots—as part of the appearance. You then provide your own Click Now to
Install button over those graphics. One of the best examples of this is the Netflix
player, shown in figure 35.2.
Figure 35.1
The default image shown 
when users don’t have Silverlight installed 
on their machines
Figure 35.2
An older version of the Netflix player. This is an excellent example of a 
Silverlight install prompt. It includes a ghosted image of the player, information about 
the movie you’ve selected, and a clear call to action. (Image courtesy of Tim Heuer.)

931
Handling the ‘Silverlight not installed’ scenarios
This example has everything a good install prompt needs: 
■
It’s on-brand and consistent with the site—Using the default prompt would’ve been
jarring. By using a screenshot of the existing player, you maximize consistency
while also showing the purpose of the plug-in.
■
It’s about the content, not the plug-in—The install prompt doesn’t extol the virtues
of Silverlight; it focuses on what you’ll get (the movie Lean on Me) after you
install it. Make the decision about the content and benefits, not the technology.
■
The call to action is simple—The only real action to take on this page is the install.
If you look hard, there’s a link with pop-up instructions, but there’s no other
prompting, account creation, or other cruft in the way.
In this section, you’ll create a simple replacement plug-in install prompt, covering the
changes to the object tag and the HTML within it. It won’t be as pretty as the Netflix
prompt, but it’ll show how you can get there. I’ll wrap up with information on how to
further customize the experience.
35.1.1 Creating your own install experience
The experience you create to prompt for the plug-in must exist without any plug-in
installed. That means it’s all HTML and JavaScript. Typically, it’s some static images
and perhaps some text. Truly complex versions could have an application walk-
through complete with a jQuery slideshow of screenshots of the application. The
point is that you want something nice that entices the user to install the plug-in.
 Whatever HTML you decide to provide, you can easily place it inside the object tag.
Any HTML you include inside the object tag will be displayed when the plug-in isn’t
installed. For example, you could go with the silly text-only install prompt shown in
figure 35.3.
 In reality, you probably want to try a little harder than that, but you get the idea.
The URL I used came right from the default install experience included with the
Figure 35.3
The new 
custom prompt to 
install Silverlight. I 
don’t know about you, 
but I’m totally ready to 
install Silverlight now!

932
CHAPTER 35
The install experience and preloaders
template. Whatever design you or your web designers come up with is fair game here.
Listing 35.1 shows how to insert the HTML into the object tag.
<object data="data:application/x-silverlight-2," 
        type="application/x-silverlight-2" 
        width="100%" height="100%">
   <param name="source" value="ClientBin/LoaderSample.xap"/>
   <param name="onError" value="onSilverlightError" />
   <param name="background" value="white" />
   <param name="minRuntimeVersion" value="5.0.61118.0" />
   <param name="autoUpgrade" value="true" />
...
  <p style="font-size:30px;margin:30px"> If you 
  <a href="http://go.microsoft.com/fwlink/?LinkID=149156&v=5.0">
  ➥ install Silverlight</a> you will see the most amazing 
  ➥ application in the world. In the WORLD! Unicorns, 
  ➥ rainbows, dogs and cats living together ... mass 
  ➥ hysteria!</p>
</object>
Everything that’s not a param but otherwise inside the object tag will be invisible when
Silverlight is installed and displayed when it’s not. The sky is pretty much the limit for
what you can do.
ALWAYS GRABBING THE LATEST PLUG-IN
By default, the tooling provides a link to the version you built against. But a better
approach is to remove the version number completely, because you should always pro-
vide the latest plug-in to your users. To do that, remove everything after the link ID:
<a href="http://go.microsoft.com/fwlink/?LinkID=149156">
That will automatically grab the latest version of the plug-in when the user clicks the
link. Note that the parameter LinkID is case-sensitive. 
HANDLING THE VERSION-UPGRADE SCENARIO
In the object tag, you saw the autoUpgrade and minRuntimeVersion properties. Those
two properties work together to handle scenarios where the user has Silverlight
installed but it’s an old version. If the user’s version isn’t the latest but it’s equal to or
higher than the minRuntimeVersion, the user won’t be prompted to upgrade. But if
your application requires a newer version and you have autoUpgrade set to true, users
will receive a standard Silverlight version dialog prompting them to upgrade.
 If you prefer to handle the upgrade process yourself, you can set autoUpgrade to
false and handle the 8001 - Upgrade required and 8002 - Browser restart
required errors in the OnError function. Although those errors will fire regardless of
the value of autoUpgrade, typically you’ll only do something meaningful with them
when you’re handling the process manually.
 Silverlight.js, discussed in chapter 3, includes a number of helper functions and
properties such as getSilverlight, isInstalled, isBrowserRestartInstalled, and
Listing 35.1
A replacement Silverlight plug-in install prompt

933
Using a custom preloader 
WaitForInstallCompletion that make the new install and upgrade experiences
highly scriptable from JavaScript.
 After you’ve tackled the “no plug-in installed” scenario or the upgrade scenario
and the user has the plug-in installed, you should then turn to the application-loading
scenario and build a custom preloader or splash screen.  
35.2
Using a custom preloader 
Silverlight applications come in all shapes and sizes. Many of the more complex appli-
cations take a few seconds or more to load, because they have many images, large
binaries, media, or more. This is one place where the Flash developers had a real leg
up due to all the prior art. Every Flash application I’ve ever used has had a custom pre-
loader that displays appropriate branding and, often, real creativity. Blogs and even
entire sites have been created with no purpose other than to show some of the awe-
some preloaders that exist out there. Take a peek for yourself: www.bing.com/
search?q=best+flash+pre-loaders.
 Preloaders can be image-based or XAML-based and can include application-spe-
cific branding. A preloader is a chance to provide something interesting and creative
to increase anticipation and excitement for the application. Some preloaders even
include minigames, but unless your application takes 20 minutes to load, that may be
overkill.
 Think of the preloader like the start of a movie. Although you typically want the
opening cuts to finish in short order so you can watch the movie, the best ones add to
the overall story, increase awareness of what’s to come, and help generate excitement.
 When it comes down to it, you can have the best-looking
Silverlight application out there, but if it shows several seconds
of the default Silverlight loading animation, no one will con-
sider it a complete experience. Figure 35.4 shows the default
“spinning blue ball” loading experience. 
 The default experience is there to ensure that your users
know the application is doing something while the application
or the application and required assets are downloaded.
 In general, you want to avoid both the default loader and
the double-download situation whenever possible. It’s easy to
create your own custom download experience, including
downloading media assets and more. 
 Throughout this section, you’ll learn how to create a custom preloader. The first
step in this three-step process is creating the appearance of the preloader using
XAML. After it’s created, you can integrate the preloader with your solution to ensure
it’s used while a Silverlight application is being downloaded. While this download is
proceeding, you can choose to monitor its progress and update the visuals. All these
steps will be shown as a basic preloader is implemented.
Figure 35.4
The 
default Silverlight 
“spinning blue ball” 
loading experience

934
CHAPTER 35
The install experience and preloaders
35.2.1 Creating the appearance
Preloaders, or splash screens, are shown when the loading time of your application
exceeds a certain threshold, roughly half a second. The first step in creating a custom
splash screen is defining its appearance. You must take three important facts into con-
sideration:
■
The preloader is used while a XAP file is being downloaded, so it doesn’t make
sense to create the splash screen’s XAML inside your Silverlight application.
Instead, you must create the XAML within the website that hosts your Silverlight
application.
■
The preloader can’t use managed code, so you must use a scripting language
such as JavaScript for any runtime features of a custom splash screen. 
■
You’re not limited to the Silverlight 1.0 API. Enhancements were made to the
JavaScript API post-Silverlight 1.0, such as additional panels and types of
animation. 
With these constraints in mind, you can move forward with creating your own pre-
loader. Although a good preloader is a highly branded experience that seamlessly
blends into the design for your application, you’ll create a simple animation here for
space and complexity considerations. Such an animation might be defined in an XML
file on the website called SilverlightLoader.xaml and look like the code in listing 35.2.
Result:
XAML:
<?xml version="1.0" encoding="utf-8" ?>
<Grid xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
      xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
  <Grid.Background>
    <LinearGradientBrush>
      <GradientStop Color="#FFFFFFFF" Offset="0.25" />
      <GradientStop Color="#FFFFAF00" Offset="1.5" />
    </LinearGradientBrush>
  </Grid.Background>
  <Grid.Triggers>                                   
    <EventTrigger RoutedEvent="Grid.Loaded">
      <BeginStoryboard>
        <Storyboard Storyboard.TargetName="EllipseRotateTransform" 
Listing 35.2
The XAML for a custom splash screen: SilverlightLoader.xaml
Uses trigger to 
start animation

935
Using a custom preloader 
                    Storyboard.TargetProperty="Angle">
          <DoubleAnimation From="0" To="360"
                           BeginTime="00:00:00" Duration="00:00:01"
                           RepeatBehavior="Forever" />
        </Storyboard>
      </BeginStoryboard>
    </EventTrigger>
  </Grid.Triggers>
  <Grid HorizontalAlignment="Center" VerticalAlignment="Center"
        Height="80" Width="80" Margin="10">
    <Ellipse x:Name="myEllipse"
             Stroke="#FF000000" RenderTransformOrigin="0.5,0.5">
      <Ellipse.RenderTransform>
        <RotateTransform x:Name="EllipseRotateTransform" />
      </Ellipse.RenderTransform>
      <Ellipse.Fill>
        <RadialGradientBrush GradientOrigin="0.06,0.8">
          <RadialGradientBrush.RelativeTransform>
            <TranslateTransform X="-0.007" Y="0.008" />
          </RadialGradientBrush.RelativeTransform>
          <GradientStop Color="#FFCAFFB4" Offset="0" />
          <GradientStop Color="#FF39AF07" Offset="0.8" />
          <GradientStop Color="#FF7BCE09" Offset="1" />
        </RadialGradientBrush>
      </Ellipse.Fill>
    </Ellipse>
    <Ellipse Height="55" Width="55" Fill="#FFFFFFFF" Stroke="#FF000000" />
    <TextBlock x:Name="ProgressTextBlock" Width="55" Height="20"
               FontFamily="Verdana" FontSize="14" Text="0%"
               TextAlignment="Center" />
  </Grid>
</Grid>
The listing defines a basic set of shapes and animation within a Grid element. This
animation rotates an Ellipse around a TextBlock, which shows the progress of the
download. The progress of the download will be updated as the download progresses.
TIP
If you want to try this yourself on an empty project, create a new Silver-
light application with a website as usual. Then, on the Silverlight app, embed
some enormous file, such as a video or big zip file, into the XAP, so it’s large.
As long as the download takes more than 0.5 seconds or so, you’ll see your
preloader screen. The more latency you have, the more you’ll see of your pre-
loader. You can even constrain your download bandwidth (time to dig out the
old 9600 bps Hayes compatible) to help it show off.
The root element of a preloader must be one of the Panel elements mentioned in
chapter 7, so you can’t use a UserControl element as you would if you were defining a
page. This has to do with the fact that managed code can’t be used with a splash
screen. After you’ve chosen a Panel and created the appearance of the splash screen,
you can integrate it with your web application.  

936
CHAPTER 35
The install experience and preloaders
35.2.2 Integrating the custom splash screen
The second step in using a custom splash screen is integrating it with a web applica-
tion. You reference the XAML of the splash screen when you create an instance of the
Silverlight plug-in. You can reference this XAML by using the splashScreenSource
property of the object tag, as shown next.
<object data="data:application/x-silverlight-2," 
        type="application/x-silverlight-2" 
        width="100%" height="100%">
  <param name="source" value="ClientBin/LoaderSample.xap"/>
  <param name="onError" value="onSilverlightError" />
  <param name="splashScreenSource" 
         value="SilverlightLoader.xaml" />          
  <param name="onSourceDownloadProgressChanged"
         value="appDownloadProgressChanged" />
  <param name="onSourceDownloadComplete" 
         value="appDownloadComplete" />
...
</object>
Listing 35.3 uses the splashScreenSource property to reference the splash screen cre-
ated in listing 35.2. This property isn’t required by the createObjectEx function. By
using this property, you can point to where a custom splash screen’s XAML is stored. For
security reasons, the XAML must be located on the same website as the page with the
object tag and the Silverlight XAP file. When the splash screen’s XAML is loaded,
you have the option of using the onSourceDownloadProgressChanged and onSource-
DownloadComplete event handlers to monitor the load progress.
35.2.3 Monitoring the load progress
The third, but optional, step in creating a preloader is monitoring the load progress.
To accomplish this, you wire up JavaScript event handlers to the onSourceDownload-
ProgressChanged and onSourceDownloadComplete events defined by the plug-in.
These event handlers are shown in listing 35.4.
<script type="text/javascript"> 
function appDownloadProgressChanged(sender, args)
{
  var progressTextBlock = sender.findName("progressTextBlock");
  progressTextBlock.Text = (Math.round(args.progress * 100)) + "%";
} 
function appDownloadComplete(sender, args)
{}
</script>
Listing 35.3
Associating the preloader with the Silverlight application
Listing 35.4
The JavaScript event handlers used for monitoring download progress
XAML URL

937
Summary
I typically include these event handlers in the same JavaScript script block that holds
the default Silverlight error handler. Listing 35.4 shows the onSourceDownload-
ProgressChanged and onSourceDownloadComplete event handlers referenced in list-
ing 35.3. The onSourceDownloadProgressChanged event will fire any time the
progress of a download has changed by 0.5 percent or more. If this event is triggered,
you may access the total progress through the second parameter of the onSource-
DownloadProgressChanged event. This parameter exposes a floating-point property
called progress. The value of this property is between 0.0 and 1.0, so you must multi-
ply the value by 100 in order to convert the value to a percentage. When the progress
has reached 1.0, the onSourceDownloadComplete event will fire.
 The onSourceDownloadComplete event will fire when the requested Silverlight
application has been completely downloaded. Because the Silverlight application will
automatically start when it’s completely downloaded, you probably won’t use this
event. Instead, you’ll probably use the in-application Application.Startup event
mentioned earlier in this book, because at this point, you can begin using managed
code instead of relying on scripted code.
 Sometimes you need to provide more than just a preloader. Sometimes you need a
way to download whole portions of the application on demand, or at least in a lazy
way. For these scenarios, the Managed Extensibility Framework is the way to go.
There’s a ton of good information, including some third-party open source module-
loader frameworks, all built on MEF and made free to the public. You can find these
on CodePlex among other sites. 
35.3
Summary
A custom, branded install experience for the plug-in and a custom preloader are both
extremely simple to create—far less work than the overall application. If you have a
designer on-team, it can often be as simple as a few graphics and some basic XAML.
 But those little touches are what differentiate a great application from a good
application. They’re also the types of changes that keep users engaged and reduce the
drop-off of new users. The return is great compared to the effort involved.
 The first customization is for the plug-in install. When new users without the Silver-
light plug-in come to your application, you have the opportunity to engage them and
get them to install Silverlight. It’s through solid efforts in this space that Silverlight
gains market penetration and becomes easier to use in your applications.
 The second customization is for the application preloader or splash screen. This is
what you want to show the user while your application is loading. Most applications
with a significant number of images or other media, packaged into the XAP to avoid a
multitude of lazy loads later, are big and benefit from some download progress infor-
mation. Sure, you could use the generic Silverlight spinning balls animation, but to
look professional, you want to use something that fits the design of your application
and seamlessly sits in your site.

938
CHAPTER 35
The install experience and preloaders
 Combine both customizations, and you have a winning combination that’ll help
increase eyeballs and keep visitors interested and engaged.
 I hope you’ve enjoyed this book; I welcome your comments! If you liked it, I
encourage you to write an online review on your blog or on a retailer’s website (such
as Amazon.com). The official forum for this book can be found on the publisher’s
website at www.manning.com/Silverlight5inAction, where you can ask questions, post
comments, and report any errata. You can also reach me on twitter at @Pete_Brown
and on my website at http://10rem.net. I encourage you to join me in both places to
get updates and expansions to the content in this book and more. Thank you!

939
appendix A:
Database, connection,
and data model setup 
In several examples in this book, including those in the printing (see chapter 31),
MVVM (see chapter 33), and WCF RIA Services (see ebook appendices D, E, and F),
you need to work against database data and an entity data model. For this you’ll
need SQL Server with the AdventureWorks database loaded.
 In this appendix, you’ll install the database, then create the database connec-
tion and the entity data model. The entity data model will be added to the ASP.NET
web project in your Silverlight solution. The steps are intended to be performed as
part of a larger project setup. You’ll be referred to this appendix at a specific point
in each of the chapters, by which time you’ll already have a basic solution setup.
A.1
Install the AdventureWorks database
If your database installation doesn’t already contain the AdventureWorks database,
visit http://msftdbprodsamples.codeplex.com/ to download the latest version for
your database version.
 The CodePlex database sample site includes a number of database releases for
the various editions of SQL Server, up to SQL Server 2010 RC0 as of this writing. My
own dedicated database server is running SQL Server 2008, and I have a local SQL
Server Express 2008 database instance that came with Visual Studio 2010. The sam-
ple databases will install on either one.
A.1.1
Installing on a dedicated SQL Server instance
In this setup and in all of my examples, I’m using SQL Server 2008 on a dedicated
server. You can install locally or use a separate server or virtual machine (VM). Though
I haven’t tested with older versions, this should also work on SQL Server 2005. A
default installation of Visual Studio 2010 up-level versions (such as Pro and Ultimate)

940
APPENDIX A
Database, connection, and data model setup 
includes SQL Server Express 2008. If you have an MSDN subscription, you can also down-
load the developer editions of SQL Server through your subscription program.
 If you have a full SQL Server 2008 installation, you can download the full MSI and
install the suite of databases. Once the database is installed, you can set up the data-
base connection and create the entity data model.
 The CodePlex site includes a walkthrough (kept current with the releases) show-
ing how to install the sample databases. Depending on the engine you’re using and
the options selected when you installed your database server, some databases may not
be available to you. The only database you use in this book is AdventureWorks, also
called AdventureWorks OLTP. You can ignore the warehousing and reporting data-
bases if you wish—I don’t use them in the examples. There are so many of them, you
should simply not bother installing the warehouse databases unless you know you
need them for something else.
 If you’re not using a full dedicated installation of SQL Server, you’ll want to install
using SQL Server Express.
A.1.2
Installing on SQL Server Express 
SQL Server Express comes with most editions of Visual Studio and installs by default.
It’s the default database server used for ASP.NET membership, role, and session infor-
mation on a development machine. But because it doesn’t install any client tools,
many folks don’t realize it’s there.
 As with the dedicated SQL Server instance install, you can download the full MSI
and install the suite of databases. You can safely ignore the warehousing and reporting
databases. Once the database is installed, you can set up the database connection and
create the entity data model.
 If you’re not running a full instance of SQL Server, the databases will install locally
with SQL Server Express. When using SQL Server Express, you have two options:
■Install the databases locally, then use them like any other SQL Server installation
(this doesn’t work in all install scenarios).
■Install the databases locally, then drag the AdventureWorks.mdb file into your
App_Data folder on the ASP.NET project.
I prefer the second option; it simplifies the creation of the database connection, and
it’s supported in most installation scenarios. But either option will typically work.
 Regardless of whether you used a local SQL Server instance or a remote one, once
you have the AdventureWorks database installed you’ll need to create the database
connection and the entities. 
A.2
Database connection and entities
First create a Silverlight project for the example you’re following. Be sure you create
the associated web project (the default action), because that’s where the connection
information and any services will live. The new project dialog for the default
Silverlight project type will look like figure A.1. The dialog for the Silverlight Business

941
Database connection and entities
Application template will be different and will have the options already set; WCF RIA
Services projects using the business application template will automatically create the
correct projects by default.
 Once you have the project created, the next step is to add the database connection
and create some entities.
 Right-click the web project in the Solution Explorer and choose Add New Item. In
the Data section of the installed templates, select ADO.NET Entity Data Model. Name
that entity data model AdventureWorksEntities.edmx. Figure A.2 shows the dialog
with the correct template selected and named.
Figure A.1
When creating the 
Silverlight application, be sure to 
host the application in a new web 
application.
Figure A.2
Creating the AdventureWorksEntities entity data model

942
APPENDIX A
Database, connection, and data model setup 
Once you click Add, Visual Studio will walk you through a wizard that makes the pro-
cess of generating the model pretty easy. In the first page of the wizard, choose Gener-
ate from Database and click Next. The other option, Empty Model, would require you
to build the entities from scratch. Figure A.3 shows the wizard dialog with the correct
option selected.
 You’ll then be presented with the Choose Your Data Connection step, as shown in
figure A.4. If the AdventureWorks database isn’t located in the connection list, click
the New Connection button and create a new Microsoft SQL Server (SqlClient) con-
nection to your database.
 If you already have a connection for AdventureWorks set up, simply select that.
The authentication method chosen will differ depending on your SQL Server setup.
Figure A.5 shows how my dialog looks, with all the overly interesting parts redacted.
 Once the connection is created, allow the dialog to save the entity connection
string as AdventureWorksEntities. Also, if you’re using SQL Server authentication,
check the option to include the sensitive data (password) in the connection string, as
shown in the two radio buttons in the middle of figure A.4. 
 If saving the connection information makes you uncomfortable, you can either try
with Windows Authentication (depends on the machine or network setup) or create a
dedicated SQL Server account with limited rights just for the sample. Of the choices, I
recommend the dedicated SQL Server account.
 Once the connection is picked or newly set up, you’ll be prompted to select the
entities to be added to the model.
Figure A.3
The first step of 
the Entity Data Model 
Wizard. Be sure to choose 
Generate from Database.

943
Database connection and entities
Figure A.5
Creating a new connection
to the AdventureWorks database.
Be sure to test the connection.
Figure A.4
The Choose Your 
Data Connection dialog box. If 
you don’t already have an 
AdventureWorks connection 
created, click the New 
Connection button. This 
screenshot shows the data 
connection dialog with a valid 
data connection already 
selected by default.

944
APPENDIX A
Database, connection, and data model setup 
A.2.1
Choosing the entities to create
On the Choose Your Database Objects page, select the Employee (Human Resources)
table and the Contact (Person) table. Leave the other options as is, including setting
the namespace to AdventureWorksModel. Figure A.6 shows the correct selected tables
and the correct model name.
 You can name the model anything you’d
like. But to follow the examples in the book
and use the code listings, you’ll want to use
the names indicated in the screenshots here.
 At this point, you’re able to finish the wiz-
ard. The wizard will process for a few seconds,
and then add the connection information to
your configuration file and the model .edmx
and .edmx.cs files to your web project. The
created .edmx file should look something like
figure A.7 when opened in the designer.
 Once you have the data model in place,
build the solution to get all the types loaded,
and then continue with the rest of the sam-
ple in the chapter. 
Figure A.7
The AdventureWorks model viewed
in the model designer. Double-click the EDMX file in
the web project to view it on the design surface.
Figure A.6
Select the Contact 
and Employee tables from the 
AdventureWorks database. Leave 
the model namespace set to 
AdventureWorksModel.

945
index
Symbols
.NET CLR. See CoreCLR
.NET DateTime values 773
.NET Framework colors 614
.NET types to HLSL types 628
.xap file 50, 314–315
displaying a splash screen dur-
ing download 934
Numerics
2D triangle in 3D space 669
3D design in the business 
world 650
3D in Silverlight based on 652
3D space and 2D triangle 669
96dpi 206
A
absolute
file path 793
sizing 174–175
URIs 315
acceleration
when required 143
See also hardware acceleration
accelerometer 840–849
orientation changes 849
AccelerometerJoystick class 842
creating 849
placing cleaning-up code 845
reporting direction 
changes 843
AcceptsReturn property 227
access webcam and 
microphone 118
access-policy element 477
accessing
cross-domain 476–481
special folders 778
Action property 194
actions. See  behaviors
Activate property 108
ActiveX, when used 58
ActualHeight property 145
ActualWidth property 145
Add Service Reference dialog 
box 495
adding
assemblies 753
links to top menu 741
menu items 754
new page 740
views 740
AddOrUpdate method 528
AddProperty method 389
AddPropertyValue method 239
Adobe AIR 99
Adobe Flash cross-domain 
policy 479
AdventureWorks database 816, 
871, 939–944
choosing entities 944
connecting 940–944
installing 939–940
installing on dedicated SQL 
Server 939
installing on SQL Server 
Express 940
alert 69–70
Alert method 80
allow-from element 477
Alt modifier key 184
AmbientLightColor 
property 681
AMD 657
anchorPostion parameter 238
Angle property 149
angles, start and stop 354
AngleX property 151
AngleY property 151
animations 273–302, 703
application performance 276
bouncing ball 292
controlling playback speed 280
defining a storyboard 
resource 289
delayed start 283
easing functions 297–302
episodic 280
fade 274
fluid 278
From property 277
grouping into storyboards 283
jerky 278, 281
keyframe 698–706
keyframe timing 296
keyframing 291–297
looping 281
playing in reverse 282
property types 275
Rectangle 284
reset to begining 282
specifying target 285
spring 642

INDEX
946
animations (continued)
storyboarding 283–291
text hinting 202
time-based 706
time-related properties 280
timeline 275–283
triggering in response 290
value precedence 34
x and y coordinates 276
antipattern 875
Any-Source Multicast. See ASM
API calls and p-invoke 857–865
APIs
bitmap 10
Media Stream Source 10
App.xaml file 310
Apple
Command key 184
Macintosh default font 205
modifier key 184
OS X 184
See also Mac
Application 52
ResourceDictionary 313
Application class, loading 
embedded resources 317
Application object 52–55, 102
Application_Startup 52
Application_Unhandled-
Exception 53
Application.Current.InstallState 
property 102
applications
connecting to others 595–599
creating elevated trust 120, 
122
creating out-of-browser 100
cross-domain 68
dependencies 55
headless 84
initialization 52
manifest files 51
navigation application 738
signed 121
startup process 49–50
themes 742
unsigned 120
ApplicationUnhandled-
ExceptionEventArgs 53
ApplyTemplate method 250
AppManifest.xaml 50, 55
AppManifest.xml out-of-
browser 100
ArcSegment class 612
Arial font 205
arrange
pass 145
step 351
Arrange method 146
ArrangeOverride function 145
arranging content 164, 170, 172
ASM 593
ASP.NET 262, 314
data binding 370
SOAP service Silverlight-
compatible 492
vs. WCF for services 497
ASP.NET MVC 4
installing 523
ASP.NET SOAP services
492–500
ASP.NET Web API
creating RESTful service
522–539
flexibility 531
assemblies
adding 753
Microsoft.Expression.Intera-
ctions.dll 897
navigating to others 753–755
System.Windows.Interactivity.
dll 897
assembly caching 56
AssemblyPart 51
asynchronous communica-
tion 469–476
service call 498
testing 911
asynchronous validation
446–451
Atom 19, 566–573
attached properties 35–36, 134, 
162, 172
layout 35
OrbitPanel example 349
TargetName 274, 284
TargetProperty 274, 284
Triggers 290
attributes
for validation 452
uri 478
authentication credentials 485
Authors property 567
AutoGenerateColumns 
property 411
AutoGenerateField 
property 430
AutoGenerateFilter 
property 430
Automatic duration value 280
automatic sizing 174
AutoReverse property 282
autoUpgrade option 932
AvailableFreeSpace 
property 794–795
AvailableSpace parameter 145
B
Babylon 706
Babylon 3D 660
Back button 737
BackEase class 299
background 65
adding and texturing 691
Background property 65, 179, 
248, 318
base types 355
BasicEffect class
three-point lighting 681
BasicHttpBinding class 497
BasicHttpSecurityMode 
enumeration 497
Begin method 287
BeginGetRequestStream 
method 545
BeginGetResponse event 
handler 545
BeginningEdit event 417
BeginPrint event 800–801, 803
BeginStoryboard class 274, 290
BeginTime property 282
behaviors 302–306
CallMethodAction 896
Bézier curve 294
BezierSegment class 612
BiDi text 12
bidirectional text. See  BiDi text
binary message encoding 503
Binding 497
See also data binding
binding
data 369
DataForm class 421–424
debugging 920–923
dynamic properties 386
element 379
RelativeSource Self 380
source 373–394
source and target 369
support in INotifyDataError-
Info interface 448
syntax 325, 369–371, 397, 413
to collections 383–394
to indexed elements 381

INDEX
947
binding (continued)
to objects 376–378
to properties 374–376
to UI elements 378–381
ValidatesOnDataErrors 
property 441
Binding class 371
basics 368
ConverterCulture 
property 398
binding errors, viewing in the 
output window 921
binding modes 371
OneTime 371
OneWay 372, 375
TwoWay 372, 375, 396, 413
BindingMode enumerator 371
bitmap API 10
bitmap images
creating at runtime 632–638
creating from UI 
elements 634–636
Deep Zoom 638–643
direct pixel access 635
stretching 643–647
supported formats 631
bitmap printing, forcing 808
BitmapImage class 268, 631
BitmapSource class 632
blog, author’s 13
blur, Radius property 620
BlurEffect class 620
BlurRadius property 622
Body property 76
Bold element 234
BorderBrush property 248
BorderlessRoundCorners-
Window 109
BorderThickness property 248
Bottom enumeration value 132
BounceEase class 299
bouncing ball animation 292
breakpoints
and async code 917
in executable code 916
in Silverlight 5 916
placement of 917
using XAML 922
browser
cache 791
Internet Explorer 8 481
journals 735
name 82
navigation 81, 735–737
networking API 469
plug-in 74
properties 81
redirecting 81
security 791
browser HTTP stack 481–483
browser journals 735
controlling 759
BrowserHttp property 483
BrowserInformation class 82
BrowserVersion property 82
Brush 613–620
Background property 179
color changing 
animation 286
Foreground property 209
Brush class 604
coordinate space 615
brushes 613–620
color animation 277
Fill 604
ImageBrush 618
LinearGradientBrush
614–616
on Canvas 619
on TextBlock 619
on TextBox 619
RadialGradientBrush 616
SolidColorBrush 613
Stroke 604
VideoBrush 619
bubbling 37
build actions 316
Resource 317
buildPromptHTML 61
built-in effects 624
blur 620
drop shadow 621
bundled resources 315–317
business logic
factoring 888, 890
Button class 254, 323
states and groups 330
visual states 329
ButtonBase class 253, 356
buttons 253–258
By property 279
C
cache visualization 143
cached composition 140–142
caching 482
assemblies 56
frame cache settings 752
pages 751
callback
creating 578
interface 578
CallMethodAction behavior 896
Camera class 665
Cancel property 417
CanExecute property 893
CanExecuteChanged event 893
CanGoBack property 747
CanGoForward property 747
Canvas 195
Canvas element 161
arranging content 164
position offsets 162
setting offset position 
programmatically 162
stack order 163
CAS 114
CASPOL 114
Categories property 567
cells
customizing boundaries 177
spanning 172
Center
enumeration value 132
property 617
center text alignment 211
CenterX property 149–151
CenterY property 149–151
certificates 121
change-notification handler 374
CheckAndDownloadUpdate-
Async 105
CheckAndDownloadUpdate-
Completed event 105
CheckBox class 257
three-state checkbox 258
visual state management 330
checkboxes, three-state 258
Checked visual state 330
child elements 161
Children property 76, 161, 284
ChildWindow class 713
opening 716
ChildWindow element
customizing 717
members 715
properties 717
Chrome 58
chrome, custom window 109
CircleEase class 299
classes
EllipseGeometry 610
PropertyMetadata 348

INDEX
948
ClearType 11, 200
not supported on the 
Mac 202
orientation 202
ClearType font 623
Click event 253, 255
ClickMode
enumeration 254
property 254
client HTTP stack 483–489
creating 483
using automatically 484
clientaccesspolicy.xml 477, 590
ClientBin directory 314
ClientHttp property 483
clip space 695
clipboard 231
user-initiated access 118
Clipboard class 231
clipping 354, 609
clock tick 137
Close method 715
CloseAsync method 498
Closed event 715
Closing event 715
closing window 729
CLR 4
TimeOfDay property 370
types
converters 342–345
wrappers 348
CLR. See also CoreCLR
Code Access Security Policy. See 
CASPOL
code classification 115
code-access security. See CAS
code-behind 377, 870–878
and web services 871
compared to Model-View-
ViewModel pattern 879
compared to ViewModel 887
factoring out into 
ViewModel 882
moving code out 879
MvvmApplication sample 
application 875–878
code, factoring 887–892
codecs, H.264 10
CodePlex 13, 624, 638, 937
WPF Pixel Shader Effects 
library 625
Collapsed
enumeration value 130
visual state 360, 362
collecting
ink 195
sensitive data 232
collections, data binding
383–394
Color class, XNA vs. Silverlight/
XAML 663
Color property 197, 614, 622
and Offset property 615
ColorAnimation class 277
colors
hexadecimal 344
multiple transitions 616
Column property 172, 413
ColumnDefinitions 
property 170
columns and rows
adding programmatically 176
removing 
programmatically 176
ColumnSpan attached 
property 172
COM 107, 119
automating Microsoft 
Excel 107, 837–839
automation 833–839
detecting availability 834–835
Location API 836
using for speech 835
COM automation 833–839
objects are late-bound 836
ComboBox class 262
Comic Sans font 205
CommandButtonsVisibility 
property 423
commands 892–896
in XAML 38
surfacing to page 894
Commodore 64 96
Common Language Runtime. 
See  CLR
CommonStates visual state 
group 330
communication APIs 489
communication, 
asynchronous 469–476
Completed event 287
Completed flag 703
complex data types 500–511
complex property 320
components, reusable 308
composing dzi files 643
composite geometries 612
CompositeTransform 152
CompositionMode property, set 
only in XAML 659
CompositionTarget class 137
conditional compilation 538
configuration file 511
Confirm method 80
connected line segments 607
connecting
service references 495
to AdventureWorks 
database 940–944
to other applications 595–599
to sockets 589–593
connections, increasing 482
constructors, XAML rules 28
consuming RESTful services 539
content
build actions 316
files 315–316
overlapping 163
rendering 163
Content property 251, 253, 325, 
357, 401, 570
ContentControl 251–253, 324
buttons 253–258
data templates 400
flexibility 252
ContentControl class 356
ContentManager class 662, 687
ContentPresenter class 252, 
325, 360
ContentTemplate property 251, 
253, 357, 400
context parameter 71
contextual ligatures 217
contracts, control template 357
Contributors property 567
Control class 132, 248–251, 323, 
356
buttons 253–258
lookless controls 250
Control element 181
modifier key 184
controlling browser 
journals 759
controls
customizing 355–363
properties 324
reusable 265
templates 323–324
contract 357
visual states 361
vs. panels 355
WebBrowser 87–92
WebBrowserBrush 92

INDEX
949
ControlsLib namespace 353
ControlStyles.xaml file 311
ControlTemplate class 323–324
parts 331
using as part of a Style 328
conversion matrices. See  matri-
ces
Convert method 396
ConvertBack method 396
Converter property 397
ConverterCulture property 398
ConverterParameter 
property 398
CookieContainer property 487
cookies 791
managing 486
with Silverlight 482
CookiesEnabled property 82
coordinate spaces 605, 695–698
conversion matrices 696
used in 3D system 695
coordinates, right-hand 
system 696
Copyright property 567
CoreCLR 50, 97
can identify security level 116
Courier font 205
Create method 566
CreateDirectory method 793
createObject 61
createObjectEx 70
createObjectEx function
parameters 62–64
parentElement parameter 63
source parameter 63
createObjectEx method 936
creating
AdventureWorks entities 944
bitmap images 632–638
client HTTP stack 483
custom panels 345–355
images from UI 
elements 634–636
Mandelbrot fractals 636–638
navigation application 738
reusable templates 328
templates 323–329
creating a WCF service, 
example 817
Credentials property 486
critical code, calling 116
cross-domain 476–481
access 476
applications 68
other policy files 479
policy element 477
policy file 315
policy files required 479
structuring the file 477
cross-field validation 443–445
cross-thread 552
crossdomain.xml 
restrictions 479
CSS 204, 319
and FontStretch 207
and Silverlight TextBlock 204
class 76
defining styles 321
handling information 78
tags and microformats 573
CssClass property 76
CubicEase class 299
CultureInfo 396
reflects Language value 398
curly braces 338, 370
syntax 397
Current property 655
CurrentSource property 747
Cursor property 129
cursors, web standards 129
custom controls 355–363
base types 355
control template contract 357
default template 359
properties 356
testing 362
visual states 360
custom pixel shader 
effects 624–629
setting up environment 625
custom preloaders
creating 934–935
integrating 936
monitoring load progress 936
CustomEffect.slfx 653
Customer class, adding to REST-
ful service 525
CustomerController class 529
CustomerRepository class 526
customizing
controls 355–363
field descriptions 424
field labels 424
layout 350–354
out-of-browser 
navigation 756–759
panels 345–355
Silverlight install 
experience 931–933
CustomTypeHelper class, 
responsibilities 388
CustomValidationAttribute 
class 452
D
data
annotating 428–431
cookies 482
displaying 411–417, 419–420
downloading 495
formatting 23
integrity 480
loading from a file 762
receiving 495
sending 499
data access, factoring 890–892
data annotations 428–431
for validation 451–458
data binding
binding modes 371
binding syntax 369–371
converting values 395–399
customizing display 395–399
dependency properties 370, 
374
design time binding 370
fallback values 399
formatting values 395
null values 399
relative source binding 379
runtime 369
source 373–394
string format 395
to collections 383–394
to dynamic properties 386
to indexed elements 381
to keyed (string indexed) 
elements 382
to objects 376–378
to properties 374–376
to UI elements 378–381
value converters 395–399
data source, unbind 370
data templates 400, 425
creating 400–409
with ContentControl 400
with ItemsControl 402
data types
complex 500–511
float 628
DataAnnotations assembly 429
databases, connecting 940–944
DataContext 381
setting in XAML 377

INDEX
950
DataContext property 371
binding multiple properties to 
UI 376
DataContractJsonSerializer 
class 558
DataForm class 418–428
binding 421–424
customizing 424
displaying data 419–420
templates 425
DataGrid class 411–418
automatically generating 
columns 412
customizing data rows 414
customizing row and column 
headers 416
displaying data 411–417
editing data 417
manually generating 
columns 413
sorting 417
vs. ItemControl 412
DataGridBeginningEditEvent-
Args parameter 417
DataGridBoundColumn 
class 412
DataGridCheckBoxColumn 
class 412
DataGridHeaders 
enumeration 416
DataGridRowDetailsVisibility-
Mode enumeration 415
DataGridTemplateColumn 
class 413
DataGridTextColumn class 412
DataLoaded event, example 821
DataTemplate 23, 308
creating 426
defined as a resource 402
DataTemplate class 414, 821
DataTemplate property, 
example 827
DataTrigger behavior 303
DateTime 497
DDE 595
Debug class 914
Debug.Assert
adding checks into code 916
Assertial Failed dialog 916
Debug.WriteLine output 
window 915
debugging 920–923
basics 914–920
exposing exception 
information 515
MessageBox 918
network operations 923–928
on the Mac 920
with custom value 
converters 922
declarative resources 308–314
defining 309
referencing at runtime 313
declaring
dependency properties 343
namespaces 31
Deep Zoom 638–643
Composer 643
showing images 639
viewport 641–643
zooming 639–641
DeepZoomImageTileSource 
class 639
default value, value 
precedence 34
DefaultStateKey property 250
deferred download 55
DELETE, removing 
resources 546
DeleteDirectory method 793
DeleteFile method 793
Delta property 191
dependencies 55
dependency properties 33–35, 
347
attached properties 35–36
data binding 370, 374
declaring 343
LeftProperty 134
local value 34
OrbitPanel example 348
PrintPageCount 803
TopProperty 134
value precedence 34
DependencyObject 134, 268, 370
DependencyProperty 135, 267, 
320, 384
naming guidelines 269
See also  dependency proper-
ties
DependencyPropertyChanged-
EventArgs class 268–269
Deployment element 51
Deployment.ExternalParts 56
Deployment.Parts 51, 56
Description property 430, 567
DescriptionViewerPosition 
property 424
design patterns
Inversion of Control 883, 903
Model-View-Controller 26, 878
Model-View-ViewModel 27, 
869
PresentationModel 878
design time binding 370
development
Expression Blend 13
setting up environment 13
UIs 16
diacritic characters 230
dialog boxes 11, 712–717
displaying with ChildWindow 
control 713–717
DialogResult property 715–716
dialogs, open and save 762–770
digital rights management. See 
DRM
Direction property 622
DirectlyOver property 194
directories
checking for existence 774
creating and deleting 775
creating within isolated 
storage 793
determining if empty 777
getting the root 774
listing contents 777
timestamps 772
working with 770–780
Directory class
.NET DateTime values 773
create and delete methods 775
functions 770
listing contents 777
methods require elevated 
permissions 770
DirectX 652, 667
common primitives 671
shapes are connected 
triangles 672
DirectX 9 652
DirectX SDK 624–625
dirty state 428
Disabled visual state 330
discrete
interpolation 296
keyframe types 293
DiscreteColorKeyFrame 
class 293
DiscreteDoubleKeyFrame 
class 293
DiscreteObjectKeyFrame 
class 293
DiscretePointKeyFrame 
class 293

INDEX
951
discretionary ligatures 217
Display attribute 429–430
display, customizing 395–399
DisplayIndex property 413
displaying
bitmap images 631–647
data 411–417, 419–420
order 413
rich text 233–245
text 204–223
validation errors 440
DisplayMemberBinding 
property 413
DisplayMemberPath 
property 384, 402
DnsEndPoint 591
DnsSafeHost property 591
Document Object Model. See 
DOM
DocumentElement property 76
DocumentUri property 79
DOM 62–64, 73–75
accessing the browser 
window 79
calling from managed 
code 75–79
enabling access to 67
variants supported by 
Silverlight 75
W3C specification 75
domain element 478
domain name, for authentica-
tion 486
domains, cross-domain 
access 476–481
dots per inch. See dpi
DoubleAnimation class 274, 276
downloading data 495
DownloadStringAsync 
method 466
dpi 805
DragMove method 111
DragResize method 112
Draw event 659
handler called once for each 
frame to be rendered 663
drawing line art 607
DrawingAttributes property 197
DrawingSurface 658–659
a FrameworkElement 659
SizeChanged event 659
DRM 5, 10
DropDownClosed event 262
DropDownOpened event 262
DropShadowEffect class 621
properties 622
duplex service 576
polling 580
Duration property 280
dynamic properties
data binding 386
dynamic resizing 177
dzi file 643
E
EaseIn easing mode 298
EaseInOut easing mode 298
EaseOut easing mode 298
easing functions 297–299, 
301–302
Eastern Asian fonts 205
Editable attribute 430
editing grid data. See  DataGrid 
class
editing text 226, 233
EditTemplate property 425
Effect property 621
effects 620–629
built-in 624
drop shadow 621
state-based 331
transitioning 332
tricks and considerations 623
ElasticEase class 299
element binding 379
element tree 135
ElementName parameter 379
elements
finding 135
properties 32
TextBlock 204–224
elevated trust 119–124
capabilities of 119
creating applications 120
detecting 124
full-screen mode 732
in-browser applications 122
signed applications 121
unsigned applications 120
Ellipse class 604, 606
animation 275
comparison with 
EllipseGeometry 610
control templates 325
keyframe animation 293
properties 607
EllipseGeometry class 610
comparison with Ellipse 610
EMBED tag 63
embedded files 315, 317
URL for 317
embedded mode 732
embedding fonts 223
Emoticon
sort by Keys property 418
sort by Name property 418
Emoticon class, keyboard 
shortcut 414
Emoticon objects 402
emoticons 376
Employee class
binding source 434
binding TextBox to 440
implements 
INotifyPropertyChanged
435
modifying name property 439
EmployeeDataService class, 
loading Employee data 890
EmployeeReport class
adding ItemTemplate 821
creating 820
Print method 823
report writer example 827
EmployeeReportItem class, 
example 817
EmployeeViewModel class 898
EnableCacheVisualization 
property 143
EnableFrameRateCounter 66
EnableGPUAcceleration 
parameter 142
EnableGPUAcceleration-
Property 143
enableHtmlAccess 67
encryption 796
end where you started 278
EndPoint property 615
EndpointAddress class 497
EndPrint event 801, 803
entering rich text 233–245
entry point 50, 52
EntryPointAssembly 51
EntryPointType 51
EnumDataTypeAttribute 
class 452
Environment.GetFolderPath 
method 778
error handling 70, 516
with WCF 513
with WCF SOAP faults 516
Error property 441
errorArgs 70
errors, unforeseen 53
ErrorsChanged event 446
event bubbling 37

INDEX
952
event handlers 497
attaching from code 37
EventArgs class 514
EventTrigger class 274, 290, 897
Excel, automating with 
COM 107, 837–839
Exception 53
exception information, 
exposing 515
ExceptionObject 53
Execute method 893
Exit event 53
Expanded, visual state 360, 362
Expander class 356, 360
control’s visual state 361
explicit styling 321
ExponentialEase class 299
Expression Blend 12–13, 
296–297, 302, 896
edit control template 334
enforcing the contract 358
supports parts and states 
model 335
Expression Blend 4 SDK 897
ext namespace 263
extended controls 411
System.Windows.Controls 
assembly 263
TabControl 263
Extensible Application Markup 
Language. See XAML
ExtensionPart 56
extensions, markup 338–342
F
factoring
business rules and logic 888, 
890
code 887–892
data access 890–892
service calls 890–892
fade animation 274, 276
FallbackValue 399
Farkas, Shawn 115
Fiddler 465, 541
installing 924
monitoring and logging 
traffic 924
request and response view 
pane 926
traffic display 925
fields
customizing descriptions 424
customizing labels 424
File class 783
creation methods 784
management functions 790
writing and file Open 
functions 786
FileInfo, properties and 
methods 766
FileMode 796
files
.xap format 50
creating 784
getting and setting 
metadata 789
manifest 51
open and save dialogs
762–770
reading from 787
Silverlight.js 60
utility 60
ways to open 796
working with 780–791
writing to 785
XAP, what it contains 55
filesystem
access restrictions 792
available free space 794
deleting files and 
directories 793
listing files and 
directories 792
writing files 795–796
Fill
property in XAML 614
stretch option 646
FillBehavior options 282
FillRule property 612
EvenOdd 612
Nonzero 612
filter, specifications must include 
wildcard symbol 765
FinalSize parameter 146
finding elements 135
FindName method 135, 290
Firefox 75
and MouseWheel event 191
and the HTTP Referer 485
toolbar hotspot 730
FirstOrDefault method 528
float type 628
flow control 208–209
FluidMoveBehavior 
behavior 304
Focus method 181, 249
focus, setting via JavaScript 181
Focused visual state 330
FocusStates visual state group 330
folders. See also directories
font stretch constants 207
font weight constants 206
FontFamily property 205, 318
fonts
Arial 205
capitals 219
ClearType 11
Comic Sans 205
Courier 205
Eastern Asian 205
embedding 223
Gabriola 216
Gabriola and fractions 220
Gabriola stylistic sets 217
Georgia 205
Italic style 207
Lucida 205
Normal style 207
OpenType support 215
subsetting 223
Times New Roman 205
Trebuchet 205
TrueType 205
Verdana 205
See also  font name
FontSize property 206, 318
animation 276
pixels versus points 206
FontStretch property 207
FontStyle property 207
FontWeight property 206, 318
footers 827–830
Foreground property 209, 249
Forever duration value 280
formatting 23
fractions and numbers 220
selected text 239
Forward button 737
Fowler, Martin 878
fractals. See Mandelbrot fractals
FragmentNavigation event 748
fragments. See hashtags
Frame class 748–751
Frame.CacheSize property 752
frameRate 66
FrameReported event 193–194
frames, cache settings 752
FrameworkElement class 128, 
821
common properties 128–134
data binding 371
ResourceDictionary 313
styles 319

INDEX
953
From property 276–277, 333
default behavior 278
optional 278
full-screen mode 730–733
normal 731–732
trusted applications 732
FullScreenChanged event 732
functions
createObjectEx function
62–64
of Silverlight.js utility file 60
G
Gabriola
font in Windows 7 216
setting fractions 220
stylistic sets 217
GAC 115
Gecko 75
Generator property 567
generic entities, limitations 536
geometries 609–613
composite 612
path 611
simple 609–611
Geometry class 609–613
animation 277
GeometryGroup class 612
Georgia font 205
GET 520
GetDirectoryNames method 792
getElementById 63
GetElementById method 76
GetElementsByTagName 
method 76
GetErrors method 446
GetFileNames method 792
GetIDsOfNames function 835
GetIsNetworkAvailable 
method 489
GetLayoutClip method 147
GetLayoutSlot method 146
GetLeft method 162
GetPosition method 186
GetPrimaryTouchPoint 
function 193
GetProperty method 77
GetPropertyValue method 239, 
389
GetResourceStream method 317
GetResponseStream method 463
GetStyleAttribute method 78
GetStylusPoints method 196
GetTemplateChild method 358
GetTop method 163
GetUserStoreForApplication 
method 792
GetUserStoreForSite 
method 792, 794
GetValue method 135, 348
GIF banner ads 86
Global Assembly Cache. See GAC
GoBack method 746
GoForward method 746
Google Chrome
in full screen 730
See also Chrome 730
Gossman, John 878
GoToState method 333
GPS 836
GPUs
enable acceleration 657
hardware acceleration 142
gradient
beginning and ending 615
elliptical 617
radial 617
GradientBrush class, declared as 
a resource 308
GradientOrigin property 617
GradientStop class 614, 616
GradientStop property 287
grant-to element 478
graphics
effects 620–629
raster 618
raster-based 603, 644
vector-based 603
GraphicsDeviceManager
checking for ED 
availability 656
detects 3D capabilities
654–658
Grid
ColumnDefinitions 
property 170
dimensions of a row or 
column 173
RowDefinitions property 170
spanning content across 
cells 172
Grid element 169–179
absolute sizing 175
adding rows or columns 
programmatically 176
arranging content 170, 172
automatic sizing 174
dynamic resizing 177
removing rows or columns 
programmatically 176
star sizing 174
grid lines 171
GridLength value 173
GridSplitter element 171, 
177–178
Group Policy settings 123
grouping animations 283
GroupName property 256, 330, 
430
H
H.264 codec 10
Hammock 548
Handled property 53, 186, 191
handling text 226–228
handwriting 194
hardware acceleration 142
See also acceleration
HasCloseButton property 717
HasElevatedPermissions 124
HasErrors property 446
HasHeader property 264
hashtags 736
HasMorePages property
804–805
Header property 264, 416
headers 484–485, 827–830
HTTP Referer 484–485
HeadersVisibility property 416
headless application 84
Height property 145, 173, 318
Rectangle 606
Heuer, Tim 625
hexadecimal colors 344
historical ligatures 217
hit-testing 609
HLSL 620, 680
pixel shader 624
types, from .NET types 628
HoldEnd enumeration 
value 282
horizontal offset 162
HorizontalAlignment 
property 131
HorizontalContentAlignment 
property 249
Host property 54
host window
basic properties 108
changing chrome 109
controlling 107
minimizing and 
maximizing 110
moving 111
resizing 111
restoring and closing 110

INDEX
954
hosting HTML 86–94
Hover click mode 254
HTML
EMBED tag 63
hosting 86–94
ID 64
OBJECT tag 63
table element 170
tags, no support 398
HTML DOM. See DOM
HTML5 vs. Silverlight 5
HtmlAttributeEncode 61
HtmlDocument class 75, 85
HtmlDocument object 78
Body property 76
DocumentElement 
property 76
GetElementById method 76
GetElementsByTagName 
method 76
HtmlElement class 77, 85
navigation properties 76
HtmlPage class 75, 79, 83
HtmlWindow class 79, 85
HTTP
accept header in XML or 
JSON 542
browser stack 481–483
client stack 483–489
status codes 465
verbs 520
HTTP Referer header 484–485
http-request-headers 
attribute 477
HTTPS 480
HttpWebRequest
additional properties 463
HttpWebRequest class 487, 539, 
541
calling a REST GET 
method 543
two ways to create 462
Hyperlink element, inline 235
HyperlinkButton class 255
hypermedia 540
I
ICollectionView interface 417
ICommand interface 
members 893
icons, out-of-browser 105
ICustomTypeProvider
creating custom 
properties 390
helper classes 388
overview 387
Id property 77, 567
IDataErrorInfo 441, 446
IDataErrorInfo interface 441, 
446
combining with 
exceptions 445
comparison with 
INotifyDataErrorInfo 446
cross-field validation 445
simple validation 442
IDE breakpoints 916
creating and using 917
IDispatch 835
IDisposable 543
IEditableObject interface 427
IEnumerable 384
IEnumerator interface 824
ignoreBrowserVer 67
IList interface 417
Image class 631
animating the Opacity 
property 274
animation 278
data binding 377
pixellation 647
preserving aspect ratios 645
referencing loose 
resources 314
stretching 644
supported image formats 631
ImageBrush class 618
ImageLoaded event 634
images
bitmaps 631–647
creating at runtime 632–638
creating from UI 
elements 634–636
Deep Zoom 638–643
direct pixel access 635
Mandelbrot fractals 636–638
manipulating 633
pixellation 647
preserving aspect ratio 645
screenshots 634
showing with Deep Zoom 639
stretching 643–647
zooming 639–641
ImageSource property 618, 631
ImageUrl property 567
IME 225
understanding 228–230
implicit styling 322
in-browser
comparison with out-of-
browser 95
elevated trust 
applications 122
include-subpaths attribute 478
IncreaseQuotaTo method 794
independent software vendor. 
See ISV
indeterminate state 854
indexed elements, data 
binding 381
indexed TriangleList. See 
TriangleList
indexed vertices. See vertices
individual files, working 
with 780–791
initialization parameters 52, 70
InitializeComponent 38
initParams 52, 70–71
ink 194
collecting 195
styling 197
InkPresenter element 195, 198
inline
properties 32
styles 234
XAML 63
Inline flow control 
element 208–209
Inlines property 208
InlineUIContainer element 236
INotifyDataErrorInfo interface
binding support 448
comparison with 
IDataErrorInfo 446
implementing 447
INotifyPropertyChanged 
interface 374, 435, 883
input devices, keyboard
181–185
input method editors. See IME
Install method 104
installation 58, 66
installing
AdventureWorks 
database 939–940
Silverlight plug-in 930–933
InstallState 102
Insulter class 581–582
connecting multiple 
clients 588
IntelliSense 498, 836
creating namespaces 32
interfaces, ViewModels as 903

INDEX
955
Internet Explorer
and MouseWheel event 191
and Silverlight 58
colors 614
DHTML Object Model 75
in full screen 730
Silverlight and ActiveX 
model 48
understanding limits 97
Internet Explorer 8 481
interpolation 292
curves 296
discrete 296
linear 294
spline 294
types 293
InvalidateSurface 659
important for animation 
systems 663
InvalidOperationException 255
Inversion of Control 
pattern 883, 903
Invoke method 85
InvokeScript method 90
IsActive property 108
IsChecked property 256
IsDropDownOpen property 262
IsEnabled property 249
IsFullScreen property 732
IsItemsHost property 347
ISM 593
isolated storage 791–796
available free space 794
creating directories 793
deleting files and 
directories 793
increasing quota 794
listing files and directories 792
per domain quota 794
quota 98
reading files 796
sensitive data 796
writing files 795–796
isolated storage quota 
increase 118
IsolatedStorageException 793
IsolatedStorageFile class 791–792
IsolatedStorageFileStream
795–796
IsPressed property 253
IsReadOnly property 227, 236, 
417
IsTabStop property 249
IsThreeState property 258
ISV 57
IsValid property 428
isWindowless 65
Italic element 234
Italic font style 207
Items property 259, 326, 383, 441
ItemsCollection 258
ItemsControl
data binding 383
data templates 402
ItemsControl class 258–265, 
324, 356
ItemSource property 22
ItemsPanel class 326
ItemsPanel property 259
ItemsPresenter class 325
ItemsSource property 259, 383, 
402
ItemTemplate
property 259, 402
report writer example 821
IValueConverter 396
J
JavaScript
calling managed code 82–85
creating a Silverlight 
control 61
custom splash screens 934
invoking 90
script tag 60
setting focus in Silverlight 181
JavaScript Object Notation. See 
JSON
JournalOwnership property 759
journals, controlling 759
joystick 844
JPG image format 631
jQuery vs. Silverlight 5
JSON 61, 314, 540, 558–566
converting 558
serialization 562
syntax 68
testing RESTful service 530
JsonObject class 558
JSP 58
K
Key property 184
keyboard 181–185
input limitations 731
modifier keys 184–185
responding to events 183
Keyboard class 184
KeyDown event 182, 640
keyed elements, data 
binding 382
KeyEventArgs class 
properties 183
KeyEventArgs parameter 182
KeyFrame class 698
only holds data 699
KeyFrame, naming 
template 293
KeyFrameAnimation class 706
members 700
KeyframeAnimation class 698
keyframes 291–297
adding 700
animation 698–706
timing 296
types 293
KeySpline property 295
control points 295
curves for interpolation 296
keystrokes 181–185
modifier keys 184–185
KeyTime property 296
KeyUp event 182, 640
L
LabelPosition property 424
lambda expressions 19, 716
in debugging 921
lambda syntax 895
Language property 567
LastName property 439
LastOperation property 592
LastUpdatedTime property 567
layout
arrange pass 145
arrange step 351
calculation 174
customizing 350–354
in Silverlight 144
in WPF 144
layout system 144–148
measure pass 145
measure step 350
multipass 144, 146
orbital 346
performance 147
radial 346
sizing and positioning 148
slots 146
subpixel rendering 163
virtualization 147
with attached properties 35

INDEX
956
layout dimensions vs. onscreen 
dimensions 813
layout panels
Canvas 161, 164
Grid 169–179
nesting 169
StackPanel 165–169
layout system 144–148
LayoutCompleted event 146
LayoutInformation class 146
LayoutRoot control
rerooting 812
Left enumeration value 131
Left property 162
left text alignment 211
LeftProperty dependency 
property 134
libraries, referencing 30
ligatures 216
contextual 217
discretionary 217
historical 217
lighting
the scene 681
vectors 680–687
Line class 604–605
comparison with 
LineGeometry 609
x and y coordinate pairs 605
linear
interpolation 294
keyframe types 293
LinearColorKeyFrame class 293
LinearDoubleKeyFrame 293
LinearGradientBrush class 318, 
614–616
animation 286
declared as a resource 308
LinearPointKeyFrame 293
LineBreak flow control 
element 208
LineGeometry class, compari-
son with Line 609
LineHeight property 213
LineSegment class 612
linked files, and cross-
compilation 507
Links property 567, 570
links, adding to top menu 741
LINQ 471
and web services 872
LINQ to XML 14, 550
Atom document parsing 19
parsing with 20
retrieving data 551
Linux, checking OS 
platform 834
ListBox class 259, 261
control templates 326
defining items at design 
time 260
defining look and feel 260
selecting items 261
ListBox control
binding 21
data binding 384
ListBoxItem class 260
Load method 44
load progress, monitoring 936
Loaded event 290
LoadEmployees method 901
local space. See model space
LocalMessageReceiver 
object 596
LocalMessageSender object 597
Location API 836
logical trees 40
lookless controls 250
looping animation 281–282
loose resources 314–315
referencing relatively 314
retrieving with absolute 
URI 315
loose XAML 63
Lucida font 205
M
Mac
and ClearType 202
checking OS platform 834
debugging on 920
no Silverlight mouse wheel 
support 191
See also Apple
MainDrawingSurface_Draw 
stubbed out 659
MainViewModel class 552
MainWindow object 110
managed code
and scripting 82
calling DOM 75–79
calling from JavaScript 82–85
Managed Extensibility Frame-
work. See MEF
Mandelbrot fractals 636–638
manifest file. See AppMani-
fest.xaml
manipulating images 633
MapUri method 749
Margin property 132
markup extensions 338
StaticResource 309–310
TemplateBinding 324
Marshal class 857, 862
matrices 695
conversion 696
Matrix class 696
methods and properties 697
Matrix3dProjection 157
MatrixTransform 153–155
MaxDropDownHeight 
property 262
maximizing window 729
MaxLength property 227
measure
pass 145
step 350
MeasureOverride function 145
media
bitmap images 631–647
spring animations 642
Media Stream Source API 10
MediaElement, VideoBrush 619
MEF 55, 903, 937
menus, adding items 754
merging resource 
dictionaries 310
Message property 596
MessageBox, debugging 918
MessageReceivedEventArgs 
class 596
microformats 573
microphone and webcam 
access 118
Microsoft Excel. See Excel
Microsoft Expression 643
Microsoft Office 784
Microsoft Public License. See 
Ms-PL
Microsoft.Expression.Interac-
tions.dll assembly 897
minimizing window 729
Mode property 369, 371
mode, Visible 415
Model 880
model
space 695
transparency 115
Model-View-Controller. See MVC
Model-View-ViewModel
myths 881
what it isn’t 881

INDEX
957
Model-View-ViewModel 
pattern 869
basics 878–887
commands 892–896
compared to code-behind 879
history 878
separation from UI 892–906
See also  Model
See also  View
See also ViewModel
modes
full-screen 118
pinned 118
modifier keys 184–185
ModifierKeys enumeration 184
motion animation 276
MotionFinished event 642
mouse
location 186
scrolling 11
wheel 191–192
mouse events 185–192
collecting ink 195
custom click event 190
mouse wheel 191
MouseButtonEventArgs 188
MouseEnter event 186
MouseLeave event 186
MouseLeftButtonDown 
event 111, 188, 195
MouseLeftButtonUp event 188, 
195
MouseMove event 186, 195
MouseOver visual state 330, 332, 
334
MouseRightButtonDown 
event 188
MouseRightButtonUp event 188
moving elements program-
matically 162
movingPosition parameter 238
Mozilla Firefox 75
Ms-PL 60
multicast
ASM 593
ISM 593
sockets 593–595
SSM 594
multiline text support 227
multipage printing 816–830
prerequisites 816–820
multipass layout 144, 146
MultiScaleImage class 638–639
composing dzi files 643
viewport 641
zooming programmatically 640
MultiScaleTileSource class 639
multitouch 11, 193
MVC design pattern 26
MVVM design pattern 27, 534
MvvmApplication sample 
application 871–878
AddVacationBonusCommand 
command 895
and web services 872
base ViewModel class 883
busines logic 888, 890
button functionality 877
CallMethodAction 
behavior 897
code-behind solution 875
DataGrid code 875
Edit button 896
employee detail view 873
employee detail window 876, 
901
employee list view 872, 875
EmployeeDataService class 890
EmployeeListViewModel 
class 884, 888, 891, 900
Employees property 885
EmployeeVacationBonus-
Service class 889
EmployeeViewModel 
class 898
list page ViewModel 884
LoadEmployees method 887, 
901
LoadingProgress overlay 873
OnNavigatedTo method 887, 
905
pop-ups 877
SelectedEmployee 
property 885
SilverlightTest class 911
testing 906–912
updated list view 886
View-specific entities 898
ViewModel locator 904
ViewModelCommand 
class 893
my namespace 270
N
Name property 82, 330, 430
namescope 42–43, 596
bug in Silverlight 2 43
NameScope property 596
namespaces
declaring 31
in SML 21
in XAML 29–32
multiple 29
standard XAML 30
synchronizing 505
System.Windows.Input 129
Native Extensions for Silverlight. 
See NESL
native window, creating 717–730
Navigate method 81, 87, 746, 
749
Navigated event 748
NavigateToBookmark 
method 81
NavigateToString method 89
NavigateUri property 255
Navigating event 748, 752
navigating to other 
assemblies 753–755
navigation 81
back and forward 737
browser journals 735
browsers 735–737
cancelling 752
custom controls 756–759
fragments. See hashtags 736
hashtags 736
history 735–737
navigation application 738
Navigation Application 
template 738–744
out-of-browser 755–759
Tab-key 249
to pages 744–755
Navigation Application 
template 738–744
NavigationCacheMode 
property 752
NavigationContext 
property 751
NavigationFailed event 748
NavigationService class 744, 
746–748
events 748
functions 746
properties 747
NavigationStopped event 748
NESL 839–857
accelerometer 840–849
and AccelerometerJoystick 
class 842
architecture 839
Install and recompile 840
integrating with the Windows 
taskbar 849
requires COM automation 
servers 855

INDEX
958
nesting layout panels 169
nesting objects 28
Netflix install page 931
Netscape 58
Netscape Plug-in API. See NPAPI
Netscape Server Application 
Programming Interface. See 
NSAPI
NetTcp protocol 512
NetworkAddressChanged 
event 489
NetworkCredential 
constructor 486
NetworkInformation 
namespace 489
networking
client HTTP stack 483–489
stack 9
networks
calls, blocking 469
cross-domain access 476–481
operations, debugging
923–928
requests, spread across 
subdomains 482
NewItemTemplate property 426
NewValue property 269
None stretch option 644
Normal font style 207
normal planar triangles 139
normal vectors 680–687
Normal visual state 330, 334
normals. See normal vectors
notification toast 106
NotificationWindow class 106
NotificationWindowClose 
method 107
NPAPI 191
NSAPI 58, 191
NuGet 471, 524
null values 399
nVidia 657
O
OBJECT tag 63
object trees 29, 39–42
visual trees 40
objects
application object 52–55
data binding 376–378
in XAML 28–29
nesting 28
Settings 143
Observable class 375, 884
Offset property
and Color property 615
where color begins 615
offsets 162
OldValue property 269
OLE Automation 835
OnApplyTemplate method 358
onError 53, 68
event 69
OneTime binding mode 371
OneWay binding mode 372
OnFragmentNavigation 
event 745
onLoad 68
OnNavigatedFrom event 745
OnNavigatedTo event 745
OnNavigatingFrom event 745
onscreen dimensions vs. layout 
dimensions 813
onscreen information, 
printing 810–816
onSourceDownloadComplete 
event 936
onSourceDownloadProgress-
Changed event 936
Opacity property 129, 622
animation 274, 278
Open file mode value 796
OpenFileDialog class 762
properties 763
safe and secure design 766
OpenType
and fractions 220
font support 215
options
RenderAtScale 142
selecting from a list 258, 262
OrbitPanel
IntelliSense 353
Orbits property 347
OrbitPanel example 345–355, 
362
CalculateOrbitSpacing 
method 352
Children property 346
ControlsLib namespace 353
dependency properties 347
markup 352
MeasureOverride 
method 350
Orbit property 349
OrbitPanel class 346
possible enhancements 354
project setup 346
properties 347
SortElements method 350, 352
Order property 430
orientation
ClearType 202
horizontal 165
vertical 165
Orientation property 165
OriginalSource property 186, 191
OS X 184
See also Mac
Oscillations property 300
out parameter 513
out-of-browser
application settings 100
capabilities 98
checking network state 489
comparison with in-browser 95
controlling user 
experience 102–105
creating applications 100
custom window chrome 109
customizing icons 105
elevated trust 120
end-user experience 98–100
forcing out-of-browser 
mode 102
host window 107
implementing 97
installation process 99
minimizing and maximizing 
windows 110
moving windows 111
navigating 755–759
notification toast 106
resizing windows 111
restoring and closing 
windows 110
restrictions 98
updating 105
Windows 7 integration 98
OutlineColor property 197
OutOfBrowserSettings.xml 100
Icons section 105
Window element 109
overlapping content 163
OverlayBrush property 717
OverlayOpacity property 717
P
p-invoke
accessing system printer 
information 857
for API calls 857–865
writing code 860
packaged XAML 63

INDEX
959
Padding property 132, 214, 249
Page class 740, 744–745
navigation-related 
functions 744
PageMargins property 804–805
pages
caching 751
navigating to 744–755
new 740
numbers 827–830
page parameters 750
requesting 520
surfacing commands 894
PageVisual property 804, 806
Panel class 267, 327
animation 276
Children property 347
clipping 354
custom panels 345–355
possible enhancements 354
Panel. See OrbitPanel example
panels vs. controls 355
Paragraph element 233
Parent property 77, 135
parentElement 63
pARGB 635
parts 331
and states model 335
Password property 232
PasswordBox element 232
PasswordChar property 232
passwords 232
Path attribute 478
Path class 604, 779
path geometries 611
PathFigure class 611
PathGeometry class 611
segment types 612
PathSegment class 611
Pause method 287, 619
per-frame rendering callback 137
performance hit 65
Person class 454
PHP 58
pixel processing, combines tex-
ture and geometry 652
pixel shaders 624–629, 680
custom effects 628
model 624
pixel shader class 626
profile 624
setting up environment 625
using 628
WPF Pixel Shader Effects 
library 625
pixels 206
PixelShader class 627
PlaneProjection 155, 157
Platform Invoke. See p-invoke
Platform property 82
PlatformKeyCode property 184
plug-in. See browser plug-in
PNG
image format 631
support in Silverlight 11
Point class 607, 616, 642
PointAnimation class 276
points 206
Points property 608
policy element 477
policy file, serving 590
polling 576
PolyBezierSegment class 612
Polygon
draws closed shape 608
Points property 608
versus Polyline 608
Polygon class 133, 604
See also  Polygon
Polyline
coordinate pairs 607
draws open shape 607
PointCollection 607
versus Polygon 608
Polyline class 604
Polyline class. See Polyline
PolyLineSegment class 612
PolyQuadraticBezierSegment 
class 612
pop-up windows 11
pop-ups 712–717
MvvmApplication sample 
application 877
Popup class 713
Port attribute 478
portable network graphics. See 
PNG
position
absolute 605
offsets 162
relative 605
Position property 194
POST 520, 544
POSTing to a RESTful 
service 544
PostScript
advantages 800
converting to 807
power of 2 688
PowerEase class 299
POX 540
See also XML
PreferredMultiSampleCount 
property 659
preloaders 933–937
default 933
defining the appearance 
of 934–935
JavaScript 934
monitoring load progress 936
PreparingCellForEdit event 417
Press click mode 254
Pressed visual state 330
primitives 671–678
rendering the sphere 676
TriangleList 672
TriangleStrip 673
Print method 800–801
PrintableArea property 804–805
PrintDocument class 800–804
PrintedPageCount 
property 801, 803
PRINTER_INFO_2 class 863
printer, setting up 
application 857
PrinterFallbackSettings 
class 809
PrinterInformation class 863
PrinterService class 860
printing 799–810
and page margins 804
and trust 802
at different size 813
bitmap-based 808
clipping 815, 825
dpi 805
forcing vector 809
header and footer 827–830
how it works 799–810
in Silverlight 9
large documents 808
letting user cancel 806
line items 820–825
onscreen information
810–816
page breaks 825
page numbers 827–830
rasterization 807
resolution. See dpi
scaling to fit 814–815
tracking page size 825
two modes 799
visual tree 820–825
printing line items, 
example 820

INDEX
960
printing onscreen informa-
tion 810–816
as is 810
rerooting 812
PrintPage event 800–801, 
804–806
report writer example 828
PrintPageEventArgs class 804
processing pixel 652
progress property 937
project structure 659–667
camera 665
renderable scene objects 663
scene 660
project templates, installing 653
projection
space 695
transforms 155–159
Projection matrix 696
Prompt method 80
Prompt property 430
property 255
Property attribute 319
property path 36
syntax 287
Property property 269
PropertyChanged event 375
PropertyChangedCallback 
class 269
PropertyChangedCallback 
property 268
PropertyChangedEventArgs 376
PropertyMetadata class 268, 348
Protocol attribute 478
PublishDate property 570
Q
QuadraticBezierSegment 
class 612
QuadraticEase class 299
QuarticEase class 299
query string 750
accessing 78
QueryString property 751
QuinticEase class 299
Quota property 794
R
RadialGradientBrush class 616
RadioButton class 255, 257
grouping 256
RadiusX property 617
Rectangle 606
RadiusY property 617
Rectangle 606
RangeAttribute class 452
RangeBase class 356
raster 603, 618, 807
rasterization 138, 144, 807
raytracing 140
Reactive Extensions. See Rx
ReadObject method 562
ReadOnlyTemplate 
property 426
ReceiverName property 596
receivers, creating 596
receiving data 495
Rectangle
bulging 606
Height property 606
rounded 606
Width property 606
Rectangle class 604
animation 284
comparison with 
RectangleGeometry 610
Rectangle class. See Rectangle
RectangleGeometry class 610
comparison with 
Rectangle 610
redirecting the browser 81
redraw regions 143
referencing
events 37
inline properties 32
libraries 30
Silverlight.js utility file 60
Refresh method 746
regions, for hit testing 609
Register method 268, 347
RegisterAttached method 349
registers 626
RegisterScriptableObject 
method 83
RegularExpressionAttribute 
class 452
relative
position 605
sizing 64
source binding 379
URIs 315–316
Release click mode 254
Remove method 314
RemoveAt method 176
removing resources using 
DELETE 546
render transforms 148–155
RenderAtScale option 142
rendering 135–144
cached composition 140–142
content 163
order 139
subpixel rendering 163
user Silverlight control 64–68
Rendering event 93, 138
rendering pipeline 652
rendering process 135–144
cached composition 140–142
clock tick 137
occlusion 139
order 139
per-frame rendering 
callback 137
rasterization 138–144
steps 136
RenderingEventArgs class 138
RenderingTime property 138
RenderMode property 656
RenderModeChanged event 656
RenderModeReason 
property 656
reparent. See rerooting
RepeatBehavior
property 281–282
takes precedence over 
Duration 281
replacing selected text 240
Repository pattern 526
Representational State Transfer. 
See REST
request/response pattern 461, 
474
simplifying 465
requesting a page 520
RequiredAttribute class 452
rerooting 812
ResourceDictionary 309
Resources
attribute 314
property 289, 309, 313
resources
animation 289
bundled 315–317
declarative 308–314
dictionaries 310
element 478
loose 314–315
referencing 310, 313–314
removing using DELETE 546
retrieving with absolute 
URI 315
scoping 310
updating by POSTing 544

INDEX
961
ResourceType property 430
Response property 596
REST
any service that isn’t SOAP 520
consuming services 539
GETting from 540
helper libraries 548
Rest# 548
RESTful service
adding the Silverlight 
project 531
creating controller 528
creating using ASP.NET Web 
API 522–539
decides format of data 541
POSTing data to 544
shared model project 525
testing using a browser 530
Resume method 287
reusable
components 308
controls 265
templates 328
RGB 614
aRGB format 614
RxGyBz format 614
RIA 3
Rich Internet Application. See 
RIA
rich text 233–245
retrieving as XAML 240
RichTextBox
control 12
element 233–245
Right enumeration value 131
right text alignment 211
right-clicking 11
right-hand coordinate system 696
RootVisual 53
RotateTransform 148–149
rotating objects 149
rotation 703
CreateFromYawPitchRoll 704
routed events 37
RoutedEvent property 290
Row property 172
RowDefinitions property 170
RowDetailsTemplate 
property 414
RowDetailsVisibilityMode 
property 414
rows and columns
adding programmatically 176
removing program-
matically 176
RowSpan attached property 172
RSS 566–573
Run flow control element 208
runtime
binding 369
loading XAML 44–46
parsing XAML 44
RuntimeVersion attribute 51
Rx 471
S
Safari 58, 75, 97
Webkit-based 86
safeguards
full-screen mode 
restriction 731
limits to user input 731
SaveFileDialog class 767–770
and Save As 769
properties and methods 767
SaveToString method 92
ScaleTransform class 148, 150
instead of animation 276
ScaleX property 150
ScaleY property 150
scaling, rotating, translating. See 
SRT
scene
lighting 681
manages information for 3D
660
renderable objects 663
Scene class 654
AmbientLightColor 
property 681
loading triangle and its 
shader 670
main class in 3D system 661
SceneObject instances 663
SetupLights method 681
SceneObject class 664
screen mode
normal full-screen mode
731–732
resizing content 732
toggling 732
screenshots 634
ScriptableMember attribute 83
ScriptableType attribute 83
ScriptAlias property 83
scripting and managed code 82
SDK
DirectX 625
Expression Blend 4 897
SDKStyles.xaml file 742
security
and reflection 117
attack 731
safe browsing 791
Seek method 287
segments
Arc 612
Bézier 612
Line 612
PolyBezier 612
PolyLine 612
PolyQuadraticBezier 612
QuadraticBezier 612
Select function 238
selected text 237–245
formatting 239
SelectedIndex property 261
SelectedItems property 261
SelectedText property 228
selecting
from a list 258, 262
text 228
Selection property 238
SelectionLength property 228
SelectionStart property 228
Selector class 261, 356
sender, creating 597
SenderDomain property 596
sending data 499
Sensor class 844
SensorManager class 844
service calls, factoring 890–892
service proxy 497
service references 495
ServiceError class 516
ServiceReferences.ClientConfig 
file 511
SetBinding method 370
SetLeft method 162
SetProperty method 77
SetPropertyValue method 389
SetStyleAttribute method 78
Setter class 319
Settings object 143
SetTop method 163
SetValue method 135, 348
Shader Model 2 
specification 624
Shader Model 2.0 652
shaders
CustomEffect.slfx 653
See also  Shader Model 2
simple vertex color 667
vertex 670, 680

INDEX
962
ShadowDepth property 622
Shape class 604–608
exposes Stretch property 644
shapes
circular 606
closed 608
five-pointed star 609
geometric 609
open 608
shared model project 525
SharePoint 487, 566
sharing
type definitions 505
visual states 335
Shazzam 625
shearing transform 150
ShortName property 430
Show method 107, 715
ShowGridLines property 171
showing
dialog boxes 712–717
pop-ups 712–717
signing applications 121
SilverChat 595
Silverlight
accessing the browser 
window 79
Ajax 5
and ActiveX 58
and H.264 10
and printing 9
and proxies for RESTful 
services 540
and SOAP services 492
animation 273–302
application 58
application defined 48
application model 48
asynchronous communica-
tion restriction 469
BiDi text 12
bitmap API 10
business features 8
ClearType fonts 11
code transparent by 
default 116
code-behind 870–878
collect handwritten 
information 194
commands 892–896
communication APIs 489
configuration dialog 67
connecting to Twitter 14–24
connecting to web 
services 495
creating a dedicated RSS 
reader 573
creating an application 16
customizing install 
experience 931–933
defined 4
development 12–14
dialog boxes 11
differences from WPF 40
DRM 10
entry point 50
every page a UserControl 266
excels at media 6
font support 205
fonts 11
Group Policy settings 123
hosting 16
hosting server 63
improvement over 
HTML 258, 261
initializing 70
installation 58
integration with a web 
page 65
JavaScript 5
latest plug-in version 932
layout 144
making it talk 835
media enhancements 10
Media Stream Source API 10
microphones 10
mouse scrolling 11
multitouch support 11
networking APIs 489
networking stack 9
new features 12
occlusion culling at the brush 
pixel level 140
performance 65
plug-in not installed 930–933
PNG support 11
pop-up windows 11
printing from 799–830
printing in raster mode 805
printing limitations 816
quitting application 53
RichTextBox control 12
right-click support 11
SDK 13, 152, 411
security levels 115
security model 118
security safeguards 731
SOAP 1.1 protocol 
support 492
startup events 68–70
supported DOM variants 75
supporting platforms 184
supports Shader Model 2 652
supports XNA “Reach” 
profile 652
testing 906–912
text 200
TextBlock and CSS 
equivalent 204
the HTML DOM 62–64
the web 5
transformation matrix 153
types of applications 6
UIs 16
upgrading 932
use of cookies 482
user initiation and 
consent 117
user interaction 11
validation 9
versus HTML 5 5
versus jQuery 5
visual prompts 713
WCF RIA Services 9
webcams 10
within Internet Explorer 58
workflow 370
WPF 6
Silverlight 1.0, migrating to Sil-
verlight 2.0 71
Silverlight 2, validation 434
Silverlight 3, new features 12
Silverlight 4, new features 12
Silverlight application
bundled resources 315
content files 316
declarative resources 309
embedded files 317
loose resources 314–315
site of origin 314
storing data on the local 
filesystem 791–796
Silverlight control 58, 74
creating from JavaScript 61
height 64
integrating with a web 
property 62
keyboard input 181
width 64
Silverlight Object Model 135
Silverlight plug-in 58
creating from JavaScript 61
default install badge 930
input focus 181
installing 930–933

INDEX
963
Silverlight plug-in (continued)
integrating with a web 
property 62
latest version 932
Netflix install page 931
not installed 930–933
security 791
setting focus via 
JavaScript 181
upgrading 932
Silverlight Unit Testing 
Framework 906–910
installing 906
Silverlight.js file 932
Silverlight.js utility file 60
functions 60
referencing 60
Silverlight.net
website 60
Silverlight/XAML 663
Silverlight/XNA 3D API
652–654
SilverlightFaultBehavior 
class 516
SilverlightHost class 55, 84, 732
simple geometries 609–611
simple properties 319
Simple Sandboxing API 115
SimpleTriangle class 668, 670
SineEase class 299
Single Responsibility 
Principle 887
site of origin 314, 476
Size property 194
SizeChanged event 659
sizing
user-controlled 177
sizing precedence order 175
SkewTransform 148, 150
sllauncher.exe 97
SOAP services 492–500
socket-resource element 478
SocketAsyncEventArgs class 592
sockets
bidirectional 589
implementation 
restricted 589
multicast 593–595
opening a connection 591
response, handling 591
TCP 589–593
SocketType 591
SolidColorBrush 209
SolidColorBrush class 613
declared as a resource 309
sorting. See DataGrid class
SortMemberPath property 417
Source property 87, 315, 369, 
639, 747
referencing an image 631
source URI 63
Source-Specific Multicast. See 
SSM
SourceFeed property 570
SourceName property 619
spaces, coordinate 695–698
Span element 234
spanning cells 172
special folders, accessing 778
SpecialFolder enumeration 779
Speech API 835
SpeedRatio property 280
impact on duration 280
sphere
convert to triangles 674
rendering with primitives 676
texturing 688
Sphere class 673
drawing code 676
tessellation code 675
splash screens 933–937
defining the appearance 
of 934–935
integrating 936
monitoring load progress 936
splashScreenSource 
property 936
spline
interpolation 294
keyframe types 293
SplineColorKeyFrame class 293
SplineDoubleKeyFrame 293
SplinePointKeyFrame class 293
spoofing 731
spring animation 642
Springiness property 300
SQL Server Express 940
SQL Server, installing 
AdventureWorks on 939
SSL 497
SSM 593
saves bandwidth 594
stack order 164
StackPanel
class 327
element 165–169
layout of invisible 
elements 130
StandardColors.xaml file 311
star sizing 173
start and stop angles 354
StartPoint property 615
startup
events 68–70
process 49–50
Startup event 52, 937
StartupEventArgs 52
state-based effects 331
states 329
change between 333
manage change between 331
management and 
transition 329
visual 329–335
See also visual states
StaticResource markup 
extension 309–310
Stop
enumeration value 282
method 287, 619
StopLoading method 746
Storyboard class 274, 283–291, 
308, 330
controlling 287–289
defined 283
defining as a resource 289
programmatic control 287
triggering in response 290
storyboard control 287–289
storyboarding 283–291
StreamReader 796
StreamResourceInfo class 317
StreamWriter object 795
Stretch enumeration value 132
Stretch property 643–647
Fill option 646
None option 644
Uniform option 645
UniformToFill option 647
stretching 643–647
Fill option 646
None option 644
Uniform option 645
UniformToFill option 647
string-indexed elements, data 
binding 382
StringLengthAttribute class 452
Stroke 195
Style class 317, 319–323
style setters, value 
precedence 34
styling 317–323
explicit 321
implicit 322
ink 197

INDEX
964
styling (continued)
reusable templates 328
state-based effects 331
states 329
templates 323–329
transitioning effects 332
visual states 329–335
stylistic sets 217
StylusDevice
object 196
property 186, 191
StylusPoint 198
subnavigation, responding 
to 745
subpixel rendering 163
subsetting 223
Summary property 570
synchronous validation 441–446
syndication feed
downloading and 
processing 568
reading 566
SyndicationFeed class 19, 566
Items collection 569
SyndicationItem class
available properties 569
syntax, URIs 753
System.Collections 
namespace 417
System.ComponentModel 
namespace 375, 441, 446
System.ComponentModel.Data-
Annotations
assembly 451
namespace 451, 900
System.Device.Location 
namespace 836
System.Drawing namespace 614
System.Exception exception 452
System.IO.IsolatedStorage 
namespace 791
System.Net namespace 462
System.Net.Sockets 
namespace 593
System.PlatformID 834
System.Runtime.Serialization 
namespace 495
System.Runtime.Serializa-
tion.Json namespace 562
System.ServiceModel 
namespace 495
System.ServiceModel.Channels 
namespace 495
System.ServiceModel.Web 
assembly 562
System.Speech namespace 835
System.Threading.Tasks 
namespace 474
System.Windows 
namespace 329
System.Windows.Browser 
namespace 75, 81, 83
System.Windows.Controls 
namespace 177, 411, 744
System.Windows.Controls.Data 
assembly 411
System.Windows.Controls.dll
263
System.Windows.Controls.Navi-
gation namespace 740
System.Windows.Documents 
namespace 208
System.Windows.Ink 
namespace 197
System.Windows.Input name-
space 129, 180, 184, 198
System.Windows.Interactivity 
library 305
System.Windows.Interactivity.dll 
assembly 897
System.Windows.Interop name-
space 833
System.Windows.Markup name-
space 44
System.Windows.Media name-
space 614
System.Windows.Media.Imaging 
namespace 632
System.Windows.Messaging 595
System.Windows.Resources 
namespace 317
T
tab navigation 249
TabControl class 262
defining look and feel 264
TabIndex property 249
TabItem, visual tree 262
TabNavigation property 249
TabStripPlacement 
property 265
tabular format 170
TagName property 77
TargetName 255
TargetName property 274, 277, 
284
TargetNullValue 399
TargetProperty property 274, 
277, 284
TargetType property 321
Task class 474
Task Parallel Library. See TPL
taskbar
progress bar states 850
See also Windows 7
TCP sockets 589–593
Template property 250, 323
TemplateBinding markup 
extension 324
templated properties, value 
precedence 34
TemplatePart attribute 358
TemplatePartAttribute class 331
templates
control 323
custom control default 
template 359
Navigation Application 
template 738–744
project 653
reusable 328
styling 323–329
visual states 361
TemplateVisualState 
attribute 361
TemplateVisualStateAttribute 
class 330
tessellating a sphere 674
testing 906–912
asynchronous operations 911
custom controls 362
definitions 906
report writer example 819
Silverlight Unit Testing 
Framework 906–910
ViewModel 910
text 200
alignment 211
ClearType 200
copying to clipboard 231
displaying 204–223
editing 226, 233
entering 233
flow control 208
font properties 204–208
formatting 202
free-form layout 242
handling 226–228
hinting 201, 204
inline styles 234
input method editors 228–230
inserting 240
Italic font style 207
layout 242

INDEX
965
text (continued)
multiline support 227
Normal font style 207
pixel size 206
point size 206
rendering 203
replacing 240
rich text 233–245
selected 237–245
selecting 228
spacing 212–223
subpixel rendering 200
text properties 209, 212
viewing 226
text hinting 201, 204
animation 202
Text property 226
TextAlignment property 211
TextArea element 227
TextBlock 161, 171
aligning text 211
flow control 208
text wrapping 209
TextBlock class 498
animation 276
using resource brushes 308
TextBlock element 204–224
font properties 204–208
line spacing 212
TextBox 171
data binding 369, 377
TextBox class
styles 317
using in a UserControl 265
TextBox element 226–228
multiline support 227
wrapping text 227
TextChanged event 226
TextDecorations property 209
TextHintingMode property 201
TextInput event 229
TextInputStart event 229
TextTrimming property 210
texture
applying 687–694
UV coordinates 689
TexturedPlane class 691
TexturedSphere class 682
texturing tasks for project 688
TextWrapping property 209, 227
themes 742
Thickness property 805
three-state checkbox 258
Timeline class 275, 282–284
TimeOfDay property 374
Times New Roman font 205
TimeSpan class 283, 296
TimeSpan structure 280
timestamps directory 772
Title property 567, 717
To property 276, 333
and animation type 279
toast 106
ToggleButton class 256, 258, 
356
toolbar, customized 423
toolkits, necessity of 660
ToolkitStyles.xaml file 742
Top
enumeration value 132
property 162
TopMost property 108
TopProperty dependency 
property 134
ToString method 384, 402
TouchDevice property 194
TouchFrameEventArgs class 193
TouchPoints class 193
TPL 9, 474
Transform element 148–155
transformations, multiple 151
TransformGroup 151
transitioning effects 332
transitions
elliptical 616
multiple color 616
TranslateTransform 148, 151
transparency model 115, 129
transparent 65
trapezoid 608
Trebuchet font 205
triangle
adding to the scene 670
building using vertices 668
triangle list, versus triangle 
strip 673
triangle strip, versus triangle 
list 673
TriangleList
control winding order 685
primitive 672
TriangleStrip primitive 673
triggering event 290
Triggers property 290
triggers. See behaviors
TrueType fonts supported within 
Silverlight 205
trust 476–481
and printing 802
trust mode, elevated 115
Trusted Certificate Root 121
tweening. See interpolation
TweetDeck 99
Twitter
connecting to 14–24
follow author 13
search API 18
TwitterService class 405
TwitterUser class 404
TwoWay binding mode 372
type definitions, sharing 505
TypeConverter class 343
types
base types 355
type converters 342–345
U
u-blox 836
UDP multicast sockets 593
UdpAnySourceMulticastClient 
class 593
UdpSingleSourceMulticast 
class 593
UIElement 161
class 267
common properties 128–134
keyboard events 183
mouse events 188
transforms 148
UIElement class 128
UIs
design composition 29
elements, data binding
378–381
in Silverlight, complex 135
separation from 892–906
virtualization 412
Underline property 209
Unfocused visual state 330
UnhandledException event 53
Uniform stretch option 645
UniformToFill stretch 
option 647
UpdateSourceTrigger 386
uploading to server 762
UploadStringAsync method 467
UriMapper class 749
UriMappings property 749
URIs 255, 748–751
absolute 315
destination 541
mapping 749, 753
relative 315
syntax 753

INDEX
966
URL for embedded files 317
user control
calling the control 270
defining appearance 266
defining behavior 267
development 266
user data 791
user experience 64–68
controlling out-of-browser 
experience 102–105
out-of-browser 98–100
user initiation 117
user interaction 11
user Silverlight plug-in
rendering 64–68
user-controlled sizing 177
user-initiated
clipboard access 118
UserAgent property 82
UserControl
data binding 377
keyboard events 183
UserControl class 265–271
customizing 355
UseSprings property 642
using statement 551, 569
cleaning up 526
UV coordinates 626, 689
V
ValidateSalaryAndLevelAsync 
class 450
ValidatesOnDataErrors 
property 441, 445
ValidatesOnExceptions 
parameter 438
ValidatesOnExceptions 
property 441, 445
validation
asynchronous 446–451
calling external 
functions 454–456
client service code 449
combining messages 439
comparison of 
approaches 457
cross-field 443–445
custom code 439
custom validators 456
data annotations 451–458
displaying errors 440
employee example 434–440, 
442, 447–451, 453–457
exception-based 438–440
handling errors 438
IDataErrorInfo interface 442
in common function 443
in Silverlight 2 434
input 9
synchronous 441–446
via attributes 452
WCF web service 448
with exceptions and IData-
ErrorInfo interface 445
ValidationAttribute class 452
ValidationContext class 455
ValidationException 
exception 452
ValidationResult class 454
Value attribute 319
value converters 395–399, 922
value precedence 34
Value property 293
values, Application.Cur-
rent.InstallState 102
VCR control 422
Vector3, holds 3 points of 
data 667
vectors
graphics 603
lighting and normal 680–687
printing, forcing 809
verbs, GET 540
Verdana font 205
version 66
vertex shaders 680
vertex. See vertices
VertexColorEnabled 
property 681
VertexPositionColor class 669
vertical offset 162
VerticalAlignment property 131
VerticalContentAlignment 
property 249
vertices 667–671
adding triangle to a scene 670
building a triangle 668
color 669
creating a simple triangle 668
define a point in 3D 
space 671
indexed 684
VideoBrush class 619
View 880
and ViewModel 
relationship 884
definition 880
View-specific entities 898–902
View-to-ViewModel ratio 884
view frustum 695
View matrix 696
view space 695
View-Model-ViewModel pattern
View-specific entities 898
View-specific entities
and ViewModel 898–902
ViewModel 880
and View relationship 884
and View-specific 
entities 898–902
as interface 903
base class 883
compared to code-
behind 887
data access 890–892
definition 880
implementation 882–887
list page 884
locators 903
naming 884
ownership 882
service calls 890–892
testing 910
View-to-ViewModel ratio 884
ViewModel class 392
ViewModel pattern. See Model-
View-ViewModel pattern
viewport 638, 641–643
defined 641
managing 641
setting the size 641
ViewportOrigin property 642
ViewportWidth property 641
views, adding 740
virtual filesystem. See filesystem
virtual PC 490
virtualization 147
visibility modes
All 416
Collapsed 415
Column 416
Row 416
VisibleWhenSelected 415
Visibility property 130
visual
parts 331
tree 135
visual state groups
CommonStates 330
FocusStates 330
visual states 329–335, 360
change between 333
Checked 330
Collapsed 360, 362

INDEX
967
visual states (continued)
Expanded 360, 362
in control template 361
MouseOver 332, 334
Normal 334
sharing 335
transition 330
Visual Studio 51, 523, 688, 836
adding breakpoints to 
code 916
build actions 316–317
creating service 
references 495
generates test certificate 121
keeping the web server port 
constant 463
NuGet package manager 471
Visual Studio 2010 15
downloading 13
signing a XAP 121
visual trees 40, 260
TabItem 262
traversing with 
VisualTreeHelper 41
VisualState class 332, 335
Control enters 331
VisualStateGroup class 332
VisualStateManager class
329–335, 360
effects 331
parts and states model 329
VisualStateTransition class 332
VisualTransition class 335
VisualTreeHelper class 41
W
W3C 75
WCF
duplex services 576–589
error handling 513
RIA Services 9
vs. ASP.NET for services 497
web service for validation 448
WCF service
and complex data types
500–511
creating Silverlight-
enabled 501
WCF service implementation 
example 818
Web Platform Installer. See 
WebPI
web properties 74
integrating the Silverlight 
control 62
Web Service Description Lan-
guage. See WSDL
web services
and code-behind 871
and LINQ 872
MvvmApplication sample 
application 872
WebBrowser control 87–92
must have a size 94
WebBrowserBrush control 92
webcam and microphone 
access 118
webcams 10
WebClient class 55, 465, 541
properties and methods 467
simple event-based 
approach 542
WebKit 58, 97
WebPI 523
WebRequest class for 
networking 462
WebRequestCreator class 483
websites
10rem.net 13
Channel 9 13
helpful 13
Silverlight Cream 13
Silverlight TV 13
Whack-a-Mole 296
White Screen of Death. See WSOD
Width property 145, 173, 179, 
318
Rectangle 606
Wilcox, Jeff 122
Win32 API interface 860–865
window
closing, minimizing, and 
maximizing 729
creating native 717–730
customizing chrome 723
moving 725
required shape 728
resizing 725
setting state 720
Window class 108, 718
Content property 719
Window property 79
Windows 7
taskbar 849
Windows Aero 723
Windows Communication Foun-
dation. See WCF
Windows Forms
colors 614
compared to XAML 27
Windows Logo key 184
Windows modifier key 185
Windows Presentation Founda-
tion. See WPF
Windows Workflow Foundation. 
See WF
WindowState property 108
WindowState, possible 
values 720
WindowStyle, values 724
Wireshark 928
World matrix 696
world space 695
World Wide Web Consortium. 
See W3C
World-View-Projection matrix. 
See WVP
WPF 4, 6
and FontStyle options 208
commands 892–896
data binding 370
differences from 
Silverlight 40
layout 144
supports pixel shaders 624
TextDecorations property 209
Visibility enumeration 131
WPF Pixel Shader Effects 
library 625
WrapPanel, in Silverlight 
toolkit 167
WriteableBitmap class 632, 634
creating Mandelbrot 
fractals 637
direct pixel access 635
WriteObject method 562
WSDL 493
creating service references 495
WSOD 59
WVP 696
X
X property 151
x:Key attribute 309, 321
XAML 4
alternate default namespace 30
and CLR objects 17
basics 27–39
binding breakpoints 922
CLR namespaces 30
colors 344
commands 38
compared to Windows 
Forms 27

INDEX
968
XAML (continued)
CompositionMode 659
constructor rules 28
data binding 369–371
declaring value converters 395
defining a Line 605
defining an Ellipse 606
dependency properties 33–35
event handlers 37
events 36–38
extensions 43
from rich text 240
inline 63
loading at runtime 44–46
loose 63
Name vs. x:Name 29
namespaces 29–32
objects 28–29
overlay to obscure 
DrawingSurface 659
parsing at runtime 44
properties 32, 36
runtime parsing 44
setting DataContext 377
standard namespaces 30
Testing RESTful services 531
XAML breakpoints 922
XAML files, editing 27
XAML markup extensions
338–342
XamlParseException 310
XamlReader 342
XamlReader class 44
XAP 48, 50
decrease file size 51
sign 120
XDocument class, resolving 21
XML 550
XmlReader class, reading 
XML 566
XmlSerializer class 554
XmlSerializerNamespaces 
class 557
XmlWriterSettings class 556
XNA
“Reach” profile 652
and BasicEffect 670
Color class 663
stock effects 680
XNA Game Studio 4.0 3D core 
libraries 652
XNA Studio 4 653
Y
Y property 151
Z
z-ordering 659
ZIndex property 164
zoom in or out 150
ZoomAboutLogicalPoint 
method 639
zooming 639–641

Pete Brown
T
his hands-on guide explores Silverlight from the ground up, 
covering every feature in rich, practical detail. It is readable 
and the coverage is comprehensive. You’ll master network-
ing, MVVM, and more, with dozens of code samples you can use 
in Visual Studio or the free Visual Web Developer Express.
Silverlight 5 in Action teaches you how to build desktop-quality 
applications you can deploy on the web. Beginners will appreci-
ate the progression from simple examples to full applications 
that employ good design and coding practices. Seasoned .NET 
developers will love how the sample code embraces and extends 
what they already know.
 
What’s Inside
● 2D and 3D graphics and animation
● Business application services, rules, and validation
● Th e MVVM pattern and testing
● 5 free appendixes (200 pages) available online
A background in C# or VB.NET is helpful, but no knowledge of 
Silverlight or XAML is required. Th is book is a revised edition of 
Silverlight 4 in Action. 
Pete Brown leads Microsoft ’s Silverlight/XAML Developer 
Community team. He’s been a Silverlight MVP, an INETA 
speaker, and successful RIA Architect.
To download a free eBook plus additional content in PDF, ePub and Kindle 
formats, owners of this book should visit manning.com/Silverlight5inAction
$59.99 / Can $62.99  [INCLUDING eBOOK]
Silverlight 5 IN ACTION
SILVERLIGHT/.NET
M A N N I N G
“
As entertaining as it is 
educational. Pete covers 
Silverlight 5 like 
no one else!”
 
—Joe Suchy, ATC Transportation 
      
“
Th e go-to source for 
real Silverlight 5 answers 
and examples.”
—Dave Campbell, WynApse
       
“
Hands down THE best  
  reference for everything 
   Silverlight.”
—Michael Crump,  Telerik
       
“
A must-have book for every
  Silverlight developer.”
—Dave Davis
  BlueMetal Architects Inc.
SEE  INSERT

