 
 

The Complete Python Book 
 
2
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
The Complete Python Book 
Copyright © 2024 by Haroun Education Ventures, Inc. 
 
All rights reserved. No part of this book may be reproduced or 
transmitted in any form or by any means without written permission from 
the author. 
 

The Complete Python Book 
 
3
  
IMPORTANT NOTE:  
 Welcome to the Complete Python Book, where we will make 
Python fun and easy to learn.  Python is a beginner friendly, and it 
is one of the most important and independent programming 
languages to learn in order to take your company or career to the 
next Level.  
Please note that there are 4 ways to read this comprehensive 
Python book, depending on what you want to learn, as follows:  
[B] Beginner Track: There's a Beginner Track which assumes you 
have no experience with Python or coding in any programming 
language at all.  
[I] Intermediate Track: There’s an Intermediate Track for students 
with some experience in programming, but not in Python.  
[G] Genius:  There's also a Genius Track that assumes you have 
some Python experience, but you want to learn or revisit only more 
advanced Python topics.  
[A] All Track: Lastly, there’s an All Track that assumes that you want 
to learn all the content in the [B] + [I] + [G] Tracks.  
At the beginning of each Chapter in this book, you will see the 
letters [B], [I], [G] or [A], which will help you decide which Chapter 
to read.  
Thanks 
 
 

The Complete Python Book 
 
4
CONTENTS:  
[B/I/G/A] Introduction .................................................................................. 16 
[B/I/G/A] Python Introduction & How to Use this Book ............................... 17 
[B/I/G/A] Level 1: Introduction to Python ..................................................... 23 
[B/I/G/A] Introduction to Python (What, Why and Why of Level 1) ............. 24 
[B/I/A] How to Use Python Online Using Google Colab for Free ................... 26 
[B/I/A] Exercise 1.1: Our First Python Code: “Hello World” .......................... 33 
[B/I/A] Answer 1.1: Our first Python Code: “Hello World”? .......................... 35 
[B/I/A] Who Uses Python and What are the Pros and Cons of Python? ....... 37 
[B/I/A] Quiz for Level 1 .................................................................................. 41 
[B/I/A] Level 2: Data Types and Variables ...................................................... 44 
[B/I/A] Intro to Data Types and Variables (What, Why and How of Level 2) 45 
[B/I/A] How to Code Data Types & Variables in Python (String & Integer 
Variables) ....................................................................................................... 47 
[B/I/A] Exercise 2.1: Using String and Integer Data Types ............................ 60 
[B/I/A] Answer 2.1: Using String and Integer Data Types ............................. 62 
[B/I/A] Floating and Boolean Data Types ...................................................... 64 
[B/I/A] Exercise 2.2: Using Floating and Boolean Data Types ....................... 69 
[B/I/A] Answer 2.2: Using Floating and Boolean Data Types ........................ 71 
[B/I/A] How to Change the Content or Data Type of a Variable ("Casting") . 73 
[B/I/A] Exercise 2.3: How to Change the Content or Type of a Variable ....... 77 
[B/I/A] Answer 2.3: How to Change the Content or Type of a Variable ........ 79 
[B/I/A] Quiz for Level 2 .................................................................................. 81 
[B/I/A] Level 3: Python Math (Meaning Operators) and "Strings" ................. 84 

The Complete Python Book 
 
5
[B/I/A] Introduction to Python Math (Operators) & Strings (What, Why & How 
of Level 3) ...................................................................................................... 85 
[B/I/A] Arithmetic Rules in Python ................................................................ 87 
[B/I/A] Exercise 3.1: Arithmetic Rules in Python ........................................... 90 
[B/I/A] Answer 3.1: Arithmetic Rules in Python ............................................ 92 
[B/I/A] Stringing Together Variables ............................................................. 94 
[B/I/A] Exercise 3.2: Stringing Together Variables ........................................ 97 
[B/I/A] Answer 3.2: Stringing Together Variables ......................................... 99 
[B/I/A] Quiz for Level 3 ................................................................................ 101 
[B/I/G/A] Level 4: Built in Functions & Creating Basic Functions ................. 104 
[B/I/G/A] Intro to Built-In/Creating Functions (What, Why & How of Level 4)
 ..................................................................................................................... 105 
[B/I/A] Basic Built in Python Functions that Use Math ................................ 107 
[B/I/A] Exercise 4.1: Built in Functions that Use Math ................................ 111 
[B/I/A] Answer 4.1: Built in Functions that Use Math ................................. 113 
[B/I/A] Input Built in Python Function ......................................................... 115 
[B/I/A] Exercise 4.2: Input Built in Python Function .................................... 117 
[B/I/A] Answer 4.2: Input Built in Python Function & Stringing Together 
Objects ......................................................................................................... 119 
[B/I/A] Creating Basic Custom Functions Part 1 .......................................... 121 
[B/I/A] Exercise 4.3: Creating Custom Functions Part 1 .............................. 123 
[B/I/A] Answer 4.3: Creating Custom Functions Part 1 ............................... 125 
[I/G/A] Creating Basic Custom Functions Part 2 .......................................... 127 
[I/G/A] Exercise 4.4: Creating Basic Custom Functions Part 2 ..................... 129 
[I/G/A] Answer 4.4: Creating Basic Custom Functions Part 2 ...................... 131 

The Complete Python Book 
 
6
[I/G/A] Creating Advanced Functions (Keyword and Default Values) ......... 133 
[I/G/A] Exercise 4.5: Creating Advanced Functions Keyword and Default 
Values) ......................................................................................................... 136 
[I/G/A] Answer 4.5: Creating Advanced Functions (Keyword and Default 
Values) ......................................................................................................... 138 
[I/G/A] Returning Values from Custom Functions ....................................... 140 
[I/G/A] Exercise 4.6: Returning Values from Custom Functions .................. 142 
[I/G/A] Answer 4.6: Returning Values from Custom Functions ................... 144 
[B/I/G/A] Quiz for Level 4 ............................................................................ 146 
[B/I/G/A] Level 5: The List Data Type and the Sum Function ....................... 150 
[B/I/G/A] Intro to List Data Type (What, Why and How of Level 5) ............ 151 
[B/I/G/A] How Does the List Data Type Work (and Using the SUM Function)?
 ..................................................................................................................... 153 
[B/I/G/A] Exercise 5.1: The List Data Type Work (and Using the SUM Function)
 ..................................................................................................................... 156 
[B/I/G/A] Answer 5.1: The List Data Type Work (and Using the SUM Function)
 ..................................................................................................................... 158 
[B/I/G/A] Quiz for Level 5 ............................................................................ 160 
[B/I/G/A] Level 6: Logic and Loops .............................................................. 163 
[B/I/G/A] Intro to Logic and Loops (What, Why and How of Level 6) ......... 164 
[B/I/A] The IF, ELSE Statement .................................................................... 166 
[B/I/A] Exercise 6.1: The IF, ELSE Statement ............................................... 169 
[B/I/A] Answer 6.1: The IF, ELSE Statement ................................................ 171 
[B/I/A] Using A Nested IF Statement ........................................................... 173 
[B/I/A] Exercise 6.2: Using A Nested IF Statement ...................................... 175 

The Complete Python Book 
 
7
[B/I/A] Answer 6.2: Using A Nested IF Statement ....................................... 177 
[B/I/A] Using ELIF in an IF Statement and the OR & AND Logic................... 179 
[B/I/A] Exercise 6.3: Using ELIF in an IF Statement and the OR & AND Logic
 ..................................................................................................................... 183 
[B/I/A] Answer 6.3: Using ELIF in an IF Statement and the OR & AND Logic
 ..................................................................................................................... 185 
[B/I/G/A] Using the MATCH and CASE Logic ............................................... 187 
[B/I/A] Formatting ....................................................................................... 189 
[B/I/A] Slicing ............................................................................................... 191 
[B/I/A] For Loop ........................................................................................... 193 
[B/I/A] Exercise 6.5: For Loop ...................................................................... 196 
[B/I/A] Answer 6.5: For Loop ....................................................................... 198 
[B/I/A] While Loop ....................................................................................... 200 
[B/I/A] Exercise 6.6: While Loop .................................................................. 203 
[B/I/A] Answer 6.6: While Loop ................................................................... 205 
[B/I/G/A] Quiz for Level 6 ............................................................................ 207 
[B/I/G/A] Level 7: 3 More Data Types: Tuple, Dictionary and Set ................ 211 
[B/I/G/A] Intro to More Data Types (What, Why and How of Level 7) ....... 212 
[B/I/G/A] Tuples Explained How is it Different from a List? ........................ 214 
[B/I/G/A] Exercise 7.1: Tuples ..................................................................... 219 
[B/I/G/A] Answer 7.1: Tuples ...................................................................... 221 
[I/G/A] Introduction to Dictionaries ............................................................ 223 
[I/G/A] Dictionary Methods/Functionality .................................................. 226 
[I/G/A] Introduction to Sets ......................................................................... 230 

The Complete Python Book 
 
8
[I/G/A] Exercise 7.2: Sets ............................................................................. 232 
[I/G/A] Answer 7.3: Sets .............................................................................. 234 
[B/I/G/A] Quiz for Level 7 ............................................................................ 236 
[B/I/G/A] Level 8: Methods and Advanced Strings ...................................... 239 
[B/I/G/A] Intro to Methods and Advanced Strings (What, Why and How of 
Level 8) ........................................................................................................ 240 
[B/I/A] What is a Method and How do Get the Methods for An Object? ... 242 
[B/I/A] Exercise 8.1: Methods ..................................................................... 247 
[B/I/A] Answer 8.1: Methods ...................................................................... 249 
[B/I/G/A] String Methods ............................................................................ 251 
[B/I/G/A] Exercise 8.2: String Methods ....................................................... 255 
[B/I/G/A] Answer 8.2: String Methods ........................................................ 257 
[I/G/A] Advanced String Operations ............................................................ 259 
[I/G/A] Exercise 8.3: Advanced String Operations ....................................... 265 
[I/G/A] Answer 8.3: Advanced String Operations ........................................ 267 
[B/I/G/A] Quiz for Level 8 ............................................................................ 269 
[B/I/G/A] Level 9: Object Oriented Programming (OOP) & Classes .............. 272 
[B/I/G/A] Intro to OOP (What, Why and How of Level 9) ........................... 273 
[B/I/G/A] Understanding Classes and Instances.......................................... 275 
[B/I/G/A] Exercise 9.1: Creating Your First Class and Instance .................... 291 
[B/I/G/A] Answer 9.1: Creating Your First Class and Instance ..................... 293 
[B/I/G/A] Defining Methods in a Class ........................................................ 295 
[I/G/A] Class Attributes Versus Instance Attributes .................................... 299 
[I/G/A] Exercise 9.2: Classes, Instances and Attributes ............................... 303 

The Complete Python Book 
 
9
[I/G/A] Answer 9.2: Classes, Instances and Attributes ................................ 305 
[I/G/A] Inheritance: Extending Functionality .............................................. 307 
[I/G/A] Encapsulation: Hiding Information .................................................. 315 
[I/G/A] Exercise 9.3: Implementing Encapsulation ...................................... 322 
[I/G/A] Answer 9.3: Implementing Encapsulation ....................................... 324 
[I/G/A] Understanding Magic Dunder Methods .......................................... 326 
[G/A] Understanding Composition and Aggregation .................................. 337 
[B/I/G/A] Quiz for Level 9 ............................................................................ 341 
[I/G/A] Level 10 Mastering NumPy (Numerical Python) .............................. 345 
[I/G/A] Intro to NumPy (What, Why and How of Level 10) ......................... 346 
[I/G/A] Libraries Explained and Installing NumPy ....................................... 348 
[I/G/A] Arrays Data Type ............................................................................. 362 
[I/G/A] NumPy Array Creation Methods ..................................................... 372 
[I/G/A] Operations with Arrays ................................................................... 382 
[I/G/A] Slicing NumPy Arrays ....................................................................... 398 
[I/G/A] Exercise/Project 10.1: Slicing and Indexing with NumPy ................ 416 
[I/G/A] Answer 10.1: Slicing and Indexing with NumPy .............................. 420 
[I/G/A] Loops Versus Vectorization ............................................................. 429 
[I/G/A] Exercise/Project 10.2: Vectorization ............................................... 440 
[I/G/A] Answer 10.2: Vectorization ............................................................. 443 
[I/G/A] Universal Functions ......................................................................... 447 
[I/G/A] Conditional Filtering ........................................................................ 458 
[I/G/A] Reshaping Arrays ............................................................................. 466 
[I/G/A] Handling Missing Values Using NumPy ........................................... 482 

The Complete Python Book 
 
10
[I/G/A] File Handling .................................................................................... 494 
[I/G/A] Quiz for Level 10 .............................................................................. 500 
[I/G/A] Level 11: Pandas and Polars ............................................................ 503 
[I/G/A] Intro to Pandas & Polars (What, Why and How of Level 11) .......... 504 
[I/G/A] Installing Pandas and Polars ............................................................ 506 
[I/G/A] Loading Data Using Pandas and Polars ........................................... 510 
[I/G/A] Reading Data in Different Ways ...................................................... 524 
[I/G/A] Exercise 11.1: First Pandas/Polars Exercise ..................................... 539 
[I/G/A] Answer 11.1: First Pandas/Polars Exercise ...................................... 542 
[I/G/A] Understanding Series ...................................................................... 548 
[I/G/A] Dataframe Operations ..................................................................... 559 
[I/G/A] Dealing with Missing Data ............................................................... 575 
[I/G/A] Map and Transform ......................................................................... 585 
[I/G/A] Merging and Joining ........................................................................ 593 
[I/G/A] Exercise 11.2: Second Pandas/Polars Exercise ................................ 601 
[I/G/A] Answer 11.2: Second Pandas/Polars Exercise ................................. 604 
[I/G/A] Strings .............................................................................................. 611 
[I/G/A] Sales Data Visualization ................................................................... 619 
[I/G/A] Exercise 11.3: Third Pandas/Polars Exercise ................................... 625 
[I/G/A] Answer 11.3: Third Pandas/Polars Exercise .................................... 628 
[I/G/A] Quiz for Level 11 .............................................................................. 633 
[I/G/A] Level 12: Data Processing and ETL (Extract, Transform and Load).... 637 
[I/G/A] Intro to Data Processing and ETL (What, Why and How of Level 12)
 ..................................................................................................................... 638 

The Complete Python Book 
 
11
[I/G/A] Data Cleaning Part 1 ........................................................................ 640 
[I/G/A] Data Cleaning Part 2 ........................................................................ 649 
[I/G/A] Label Encoder and Data Transformation Part 1 .............................. 656 
[I/G/A] Label Encoder and Data Transformation Part 2 .............................. 664 
[I/G/A] Label Encoder and Data Transformation Part 3 .............................. 669 
[I/G/A] Handling Imbalanced Data .............................................................. 676 
[I/G/A] Data Partitioning ............................................................................. 685 
[I/G/A] Quiz for Level 12 .............................................................................. 688 
[B/I/G/A] Level 13: Writing Clean and Efficient Code .................................. 692 
[B/I/G/A] Intro to Writing Clean/Efficient Code (What, Why and How of Level 
13) ................................................................................................................ 693 
[B/I/G/A] Clean and Modular Code ............................................................. 695 
[B/I/G/A] Python Naming Conventions ....................................................... 701 
[B/I/G/A] Documentation ............................................................................ 704 
[B/I/G/A] Testing Your Code ........................................................................ 709 
[I/G/A] Working with Teams on GitHub ...................................................... 713 
[I/G/A] Questionnaire on How to Conduct a Code Review ......................... 719 
[B/I/G/A] Quiz for Level 13 .......................................................................... 721 
[I/G/A] Level 14: Using Python in Excel........................................................ 725 
[I/G/A] Introduction to Using Python in Excel (What, Why and How of Level 
14) ................................................................................................................ 726 
[I/G/A] How to Install Python In Excel ......................................................... 728 
[I/G/A] How to Use Python In Excel ............................................................ 735 
[I/G/A] Exercise 14.1: Using Python in Excel ............................................... 743 

The Complete Python Book 
 
12
[I/G/A] Answer 14.1: Using Python in Excel ................................................ 745 
[I/G/A] Using Dataframes with Python in Excel ........................................... 747 
[I/G/A] Exercise 14.2: Using Python Dataframes in Excel ............................ 754 
[I/G/A] Answer 14.2: Using Python Dataframes in Excel ............................. 756 
[I/G/A] How to Create a Linear Regression Using Python In Excel .............. 760 
[I/G/A] Quiz for Level 14 .............................................................................. 765 
[G/A] Level 15: Mojo ................................................................................... 767 
[G/A] Intro to Mojo (What, Why and How of Level 15) .............................. 768 
[G/A] What is Mojo and Why is it a Gamer Changer for Python Developers?
 ..................................................................................................................... 770 
[G/A] Complied Versus Interpreted Programming When It Comes to Mojo
 ..................................................................................................................... 779 
[G/A] Coding with Mojo............................................................................... 783 
[G/A] Variables in Mojo (Mutability and Immutability)............................... 786 
[G/A] Data Types in Mojo ............................................................................ 792 
[G/A] Else If in Mojo .................................................................................... 803 
[G/A] Loops in Mojo .................................................................................... 809 
[G/A] Functions in Mojo .............................................................................. 818 
[G/A] Struct Versus Class in Mojo ................................................................ 824 
[G/A] Error Handling in Mojo ...................................................................... 831 
[G/A] "Inout, Borrowed and Owned" in Mojo ............................................. 837 
[G/A] Importing NumPy in Mojo ................................................................. 843 
[G/A] Quiz for Level 15 ................................................................................ 848 
[B/I/G/A] Level 16: All Built-In Python Functions ......................................... 852 

The Complete Python Book 
 
13
[B/I/G/A] Intro to All Built-In Python Functions (What, Why and How of Level 
16) ................................................................................................................ 853 
[B/A] Absolute Value Built-In Function: abs( ) ............................................. 855 
[B/I/A] All Built-In Function: all( ) ................................................................ 858 
[B/I/A] Any Built-In Function: any( ) ............................................................ 861 
[G/A] ASCII Built-In Function: ascii( ) ........................................................... 863 
[G/A] Bin Built-In Function: bin( ) ................................................................ 866 
[B/I/G/A] Bool Built-In Function: bool( ) ...................................................... 868 
[I/G/A] Breakpoint Built-In Function: breakpoint( ) .................................... 872 
[G/A] Bytearray Built-In Function: bytearray( ) ........................................... 875 
[G/A] Bytes Built-In Function: bytes( ) ......................................................... 877 
[I/G/A] Callable Built-In Function: callable( ) ............................................... 879 
[I/G/A] Chr Built-In Function: chr( ) ............................................................. 881 
[I/G/A] Classmethod Built-In Function: classmethod( ) ............................... 883 
[G/A] Compile Built-In Function: compile( ) ................................................ 885 
[G/A] Complex Built-In Function: complex( ) ............................................... 889 
[I/G/A] Dict Built-In Function: dict( ) ........................................................... 892 
[I/G/A] Dir Built-In Function: dir( ) ............................................................... 894 
[B/I/G/A] Divmod Built-In Function: divmod( ) ........................................... 896 
[G/A] Enumerate Built-In Function: enumerate( ) ....................................... 898 
[I/G/A] Eval Built-In Function: eval( ) ........................................................... 900 
[I/G/A] Exec Built-In Function: exec( ) ......................................................... 902 
[B/I/G/A] Filter Built-In Function: filter( ) .................................................... 904 
[B/I/G/A] Float Built-In Function: float( ) ..................................................... 906 

The Complete Python Book 
 
14
[B/I/G/A] Format Built-In Function: format( ) ............................................. 908 
[I/G/A] Frozenset Built-In Function: frozenset( ) ......................................... 910 
[I/G/A] Hash Built-In Function: hash( ) ........................................................ 912 
[B/I/G/A] Help Built-In Function: help( ) ...................................................... 914 
[I/G/A] Hex Built-In Function: hex( ) ............................................................ 916 
[I/G/A] ID Built-In Function: id( ) ................................................................. 918 
[B/I/G/A] Input Built-In Function: input( ) ................................................... 920 
[B/I/G/A] Int Built-In Function: int( ) ........................................................... 922 
[G/A] Isinstance Built-In Function: isinstance( ) .......................................... 924 
[I/G/A] Issubclass Built-In Function: issubclass( ) ........................................ 927 
[I/G/A] Iter Built-In Function: iter( ) ............................................................ 930 
[B/I/G/A] Len Built-In Function: len( ) ......................................................... 932 
[B/I/G/A] List Built-In Function: list( ) .......................................................... 934 
[G/A] Map Built-In Function: map( ) ............................................................ 936 
[B/I/G/A] Max Built-In Function: Max( ) ...................................................... 938 
[B/I/G/A] Min Built-In Function: Min( ) ....................................................... 940 
[I/G/A] Next Built-In Function: next( ) ......................................................... 942 
[G/A] Oct Built-In Function: oct( ) ................................................................ 944 
[I/G/A] Open Built-In Function: open( ) ....................................................... 946 
[I/G/A] Ord Built-In Function: ord( ) ............................................................ 948 
[B/I/G/A] Pow Built-In Function: pow( ) ...................................................... 950 
[B/I/G/A] Print Built-In Function: print( )..................................................... 952 
[B/I/G/A] Range Built-In Function: range( ) ................................................. 954 
[I/G/A] Repr Built-In Function: repr( ) ......................................................... 956 

The Complete Python Book 
 
15
[B/I/G/A] Reversed Built-In Function: reversed( ) ....................................... 958 
[B/I/G/A] Round Built-In Function: round( ) ................................................ 960 
[I/G/A] Set Built-In Function: set( ) .............................................................. 962 
[I/G/A] Slice Built-In Function: slice( ) ......................................................... 964 
[B/I/G/A] Sorted Built-In Function: sorted( ) ............................................... 966 
[B/I/G/A] Str Built-In Function: str( ) ........................................................... 968 
[B/I/G/A] Sum Built-In Function: sum( ) ...................................................... 970 
[B/I/G/A] Tuple Built-In Function: tuple( ) ................................................... 972 
[B/I/G/A] Type Built-In Function: type( ) ..................................................... 974 
[I/G/A] Zip Built-In Function: zip( ) .............................................................. 976 
[B/I/G/A] Level 17: Conclusion and Next Steps ............................................ 978 
[B/I/G/A] CONGRATULATIONS & Next Steps! ............................................. 979 
 
 
 

The Complete Python Book 
 
16
 
 
 
 
 
 
 
[B/I/G/A] INTRODUCTION   
 
 
 
 

The Complete Python Book 
 
17
 
 
 
 
 
 
 
 
 
[B/I/G/A] Python Introduction & How to Use 
this Book 
 
 
 
"Everyone should learn how to program because it 
teaches you how to think." 
- Steve Jobs 
 
  
 

The Complete Python Book 
 
18
Welcome to The Complete Python Book! 
 
Python is beginner friendly, and it is one of the most important and 
in demand programming languages to learn in order to take your 
company or your career to the next Level.   
If you want you can skip the rest of this introduction Chapter and 
get started learning Python or continue reading for a detailed 
overview of the course.  
The inventor of Python, Guido van Rossum, has a fun and great 
sense of humor and called the language Python after the comedian 
group called Monty Python. We will ensure that this book is fun for 
you as well. 
Python is so much more than a single programming language, 
because you can easily install powerful libraries within Python like 
Pandas and Polars, which helps you use Python for powerful data 
science and analytical purposes.  

The Complete Python Book 
 
19
Learning Python is like building a Lego set on brick at a time, which 
is so much fun. Python is the platform, and we learn the basics one 
brick at a time.  
Let’s talk about the Levels meaning sections in this comprehensive 
book. There are 17 Levels meaning 17 sections of this book. As 
explained at the beginning of this book, there are 4 Tracks, meaning 
ways to read this book per the image below:  
  
[B/I/A] Level 1: Introduction to Python 
In Level 1, we discuss an introduction to how to quickly start using 
Python so you can use it on any device when programming with us 
in this book. We also do our first “Hello World” exercise together. 
[B/I/A] Level 2: Data Types and Variables 
Then we Level up to the next Level, which is Level 2 where we will 
learn how to use data types like text meaning a string, or a number, 
meaning integer, Boolean or floating. We will also discuss how to 
declare variables as text or a number 
[B/I/A] Level 3: Python Math (Meaning Operators) and "Strings" 
Moving on to Level 3 where we will discuss how to use math in 
Python and how to string together data.  
[B/I/G/A] Level 4: Built in Functions & Creating Basic Functions 
In Level 4 we will learn about how to use the built in Python 
functions. In this course we will cover how to use every single built 
in Python function.  

The Complete Python Book 
 
20
[B/I/G/A] Level 5: The List Data Type and the Sum Function 
In Level 5 we will discuss how to use the powerful and easy to use 
list data type.  
[B/I/G/A] Level 6: Logic and Loops 
Then in Level 6 we will learn how to use logic like “ and” as well as 
“or” when we code. We will also learn about how to use if 
statements, the for and while loops as well as how to use the match 
and case logic, which was introduced to Python in late 2021.  
[B/I/G/A] Level 7: 3 More Data Types: Tuple, Dictionary and Set 
In Level 7 we will learn about 3 very important additional data 
collection types, which are tuples, dictionaries and sets. These data 
types will allow us to take our programming skills to the next Level.  
[B/I/G/A] Level 8: Methods and Advanced Strings 
Moving on to Level 8 of 17, where we will discuss how to use 
methods, which are things we can do to change variables like make 
text uppercase. We will also learn about advanced strings by 
learning about many “methods” or things we can do with them.    
[B/I/G/A] Level 9: Object Oriented Programming (OOP) & Classes 
In Level 9 We will learn about a type of programming called object 
oriented programming where we can create reusable code in the 
form of classes. Think of classes as templates of code for making 
objects. This will become much more clear as we progress together 
through Level 9.   
[I/G/A] Level 10 Mastering NumPy (Numerical Python) 

The Complete Python Book 
 
21
Next up we have Level 10, where we will learn about importing 
something called Numerical Python, which is also called NumPy, 
which is many times faster than just using Python to create and 
work with data in arrays format. 
[I/G/A] Level 11: Pandas and Polars 
In Level 11 we will learn about  how to install and use [snake prop] 
Pandas and Polars in Python, which are incredible data analysis 
libraries. Pandas and Polars are great for loading and analyzing 
data. 
[I/G/A] Level 12: Data Processing and ETL (Extract, Transform and 
Load) 
Then in Level 12 of 17 we will learn about an introduction to data 
processing and ETL in Python. ETL stands for Extract, Transform and 
Load.   
[B/I/G/A] Level 13: Writing Clean and Efficient Code 
In Level 13 we will learn about how to write clean and efficient 
code.  This is a crucial skill set for developers because clean and 
efficient code runs much faster, which can help us save a lot of time 
and money when it comes to using computer resources. If we write 
clean and efficient code, it makes it easier for us and anyone 
reading the code in the future to read, debug and maintain the 
code.     
[I/G/A] Level 14: Using Python in Excel 
In Level 14 we will learn how to use Python inside of Microsoft 
Excel. Why should we learn about using Python in Excel? Because 
Microsoft has sold more than one billion copies of Excel since it was 

The Complete Python Book 
 
22
released and although Python is much more powerful than Excel 
for data analysis, Excel is easy to use for quick data analysis and is 
used by many less tech savvy senior executives. 
[G/A] Level 15: Mojo 
Next up we have Level 15, we will learn about Mojo, which was 
released in 2023. Think of Mojo as Python on steroids or as they 
call it a superset of Python. Why should we learn about Mojo? 
Because Mojo not only allows you to run Python much faster, but 
also as secure or safe as languages such as Rust. Many developers 
are predicting that Mojo will be the future of AI development. 
[B/I/G/A] Level 16: All Built-In Python Functions 
In Level 16 we will learn in alphabetical order how to use every 
single built in Python function. Think of this Level as an index that 
you can always refer to when you want to use a built-in Python 
function. Knowledge of these built in Python functions can help us 
work smarter and not harder when using Python.   
[B/I/G/A] Level 17: Conclusion and Next Steps  
Lastly, in Level 17 we will have our conclusion and next steps. 
Python is easy and so much fun to learn one brick meaning one step 
at a time. Together we will have fun building our dreams together 
with Python! Let’s begin.   
 
 

The Complete Python Book 
 
23
 
 
 
 
[B/I/G/A] LEVEL 1: 
INTRODUCTION TO PYTHON  
 
 
 
 
 
 
 

The Complete Python Book 
 
24
 
 
 
 
 
 
 
 
 
[B/I/G/A] Introduction to Python (What, Why 
and Why of Level 1) 
 
 
 
 
 
  
 

The Complete Python Book 
 
25
Welcome to Level 1. In terms of the what, why and how of Level 1, 
let’s kick it off with the what. What will we Learn together? We will 
discuss how to code Python using Google’s free online platform 
called Google Colab, which is short for collaboration. We will also 
do our first exercise together. Then we will discuss who uses 
Python and what are the pros and cons of using Python.  
In terms of why. Why are we going to discuss using Google’s free 
online collaboration product when learning how to code? Because 
you can use Google’s Colab product for free on any device.  
Lastly how. How are we going to learn to code in Python here in 
Level 1. We will do our first exercise together using Google Colab 
to print “Hello World.” 
Although we will be using Google Colab to teach Python in this 
book, you can actually use any other Python platform that you 
want to, while reading this book and doing the exercises mentioned 
in this book. 
In addition to the exercise we will do during Level 1, at the end of 
Level 1 we also have a short quiz to help us reinforce what we have 
learned together.  
 

The Complete Python Book 
 
26
 
 
 
 
 
 
 
 
 
 
[B/I/A] How to Use Python Online Using 
Google Colab for Free 
 
 
 
 
 
  
 

The Complete Python Book 
 
27
There are many different ways to code with Python for free. You 
can download software for Windows or for Mac or for Linux. What 
we prefer for this book is to use a free online service from Google 
for coding in Python called Google Colab, which works on a 
desktop, a laptop and even mobile devices as it is based in the cloud 
similar to Gmail.  
Google Colab refers to Google Collaboratory, which can be 
accessed at this website: https://colab.research.google.com/ . 
The great thing about using Google Colab for Python coding is that 
everything we need to code is available for us to use. You don’t 
have to download anything, which means that the code you create 
in Google Colab will work on a laptop, a desktop or even a mobile 
phone.  
For this book, there is no need to pay for the Pro version of Google 
Colab. With the Pro version, you can get access to more powerful 
GPUs. 
Let’s go to Google Colab together. Per the image below, with Colab 
you create notebooks, which are stored on your Google Drive. In 
order to use Google Colab, you need to have a Gmail address, 
which is free and easy to set up.  

The Complete Python Book 
 
28
 
Please click on new notebook so we can learn how to use Google 
Colab and write our first Python program together here in Level 1. 
We will explain more advanced topics of course as we Level up 
meaning as we do Levels 2 through 15 in this book.  
Per the image below, similar to Google Docs or Google Sheets, you 
can share your notebooks by clicking the share button in the top 
right hand corner. 
 

The Complete Python Book 
 
29
To code, per the image below, you simply type your code beside 
the play button and then you click the play button to run your code. 
 
You can click +text to add notes to explain your code in this 
notebook.  
What we prefer to do though instead of adding text is we add 
comments to our code. Per the image below, the way we do this is 
we type the # or hash sign and then we write our comment. The 
comment is in green and when we click the play button Python 
does not read this green commented line.  
It’s crucial to add many comments to your code in case someone 
you are working with wants to understand what the code does or 
in case you come back to read your code in a few months or in a 
few years and you want to understand what you coded. We will 
discuss writing clean code in Level 13.   

The Complete Python Book 
 
30
 
When we use Google Docs or Google Sheets or Gmail, we don’t 
have to click the save button as everything is saved in the cloud. 
Same thing with writing Python in Google Colab.  
Per the image below, If we click on the name of the file in the top 
left hand corner we can name our code.  
 
The extension “ipynb” stands for “Interactive Python Notebook.” 

The Complete Python Book 
 
31
 
Per the image below, if we go to the file menu you can save a copy 
of your code or we can even save or export the notebook to 
https://github.com/ which is a Microsoft owned website where 
people share code.  
 
In the many exercises in this book, we will show you how Google 
Colab uses autocomplete to help you while you are coding. 
In terms of the pros and cons of using Colab, the pros are:  
In addition to no installation issues, it offers free GPU usage, easy 
sharing, and it's perfect for collaborative work.  
The cons or limitations include GPU limitations - if you use it way 
too much then you might have to consider paying for the Pro 
version. We are teaching Python in this book using the free version 
- there is no need to pay for the Pro version.  
Another negative aspect of using Colab is that it is not secure 
enough for corporate use as it runs in the cloud and not on your 

The Complete Python Book 
 
32
computer. Despite these limitations, Google Colab is an incredible 
free tool to use when learning how to code in Python.  
 
 

The Complete Python Book 
 
33
 
 
 
 
 
 
 
[B/I/A] Exercise 1.1: Our First Python Code: 
“Hello World” 
 
 
  
 

The Complete Python Book 
 
34
Welcome to our first exercise. For this exercise, there are three 
steps, as follows:  
Step 1: Sign up for an account at 
https://colab.research.google.com/   
Step 2: Create a new notebook 
Step 3: Type 2 lines of code and play the code as follows:  
Line 1: Create a comment that says: 
This code prints Hello World 
Line 2: Print Hello World 
After you have completed these steps, then in the next Chapter 
we'll explain the answer. If you ever get an error message, don't 
worry, we're just at the beginning.  
 

The Complete Python Book 
 
35
 
 
 
 
 
 
 
 
 
[B/I/A] Answer 1.1: Our first Python Code: 
“Hello World”? 
 
 
 
 
 
  
 

The Complete Python Book 
 
36
Per the image below, click on the blue button called New 
Notebook,  and it will create a new notebook for us.  
 
Next step is it’s time to code. The 2 lines of code are shown in the 
image below:   
 
In order to run the code, please press the play button play button. 
That's it. Great job! See you in the next Chapter. 

The Complete Python Book 
 
37
 
 
 
 
 
 
 
 
 
[B/I/A] Who Uses Python and What are the 
Pros and Cons of Python? 
 
 
 
 
 
  
 

The Complete Python Book 
 
38
Google makes extensive use of Python in its web search systems 
and used to employ Guido van Rossum, who invented Python in 
1991. 
Today Python is mostly associated with AI and data analysis, which 
we are going to cover extensively in this book. Some of the largest  
companies are using Python for their machine learning and data 
processing, including Goldman Sachs, JP Morgan, Microsoft, 
Spotify and Pixar. 
But did you know that Python can be used for many different things 
and learning Python unlocks many career opportunities for 
advancement in your company. For example, Python is used in web 
programming at some of the largest companies in the world. In 
fact, the YouTube video sharing service is largely written in Python.  
Netflix also uses Python for their streaming platform. There are so 
many applications of Python in different industries, including 
algorithmic trading, risk and portfolio management, financial 
modeling, autonomous vehicles, national security and supply chain 
management etc.  
What are the pros and cons of using Python? Let’s kick it off with 
the pros. Many AI applications have and will be using Python in the 
future. Python like building with Legos is relatively easy to learn. 
Also, Python is free to use and is open sourced with so many 
different libraries that you can easily import like Polars and Pandas, 
which we will discuss in more detail in Level 11.  
Another pro of learning Python is that it has a massive user base, 
so you can easily get access to code on places like Github.com.  

The Complete Python Book 
 
39
Many companies will likely be hiring Python programmers more 
than almost any other language also because of the use of Python 
to create AI applications.  
What are the cons or the downside of using Python? Python is 
slower than “compiled” languages like C++. In this comprehensive 
book, we will teach you how to use products to make Python faster 
like NumPy, Pandas, Polars and Mojo. 
What is a “compiled” language like C++ vs an “interpreted” 
language like Python and why is this important to know about? A 
compiled language, like C++ is pre-assembled like this assembled 
James Bond car, per the image below. 
 
An interpreted language like Python is a do it yourself assembly kit 
like an unassembled version of the same car, per the image above 
(see the unassembled Lego car on the left).   
 

The Complete Python Book 
 
40
If you want to build a very fast application if you are making a video 
game for example, then C++ which is compiled and hence fast 
might more sense to use in many situations rather than Python.  
Think of programming languages like toy cars. Some are ready to 
zoom right out of the box, while others let you enjoy the journey of 
putting them together piece by piece.  
Interpreted languages like Python are like an unassembled Lego 
car. You can start playing with it piece by piece. Each line of code is 
read and executed on-the-fly when you hit the play button like we 
did in the exercise earlier here in Level 1. This means you can see 
the results almost instantly, which is so much fun. Just hit the play 
button! 
Compiled languages are like the completed Lego car. Before you 
can drive—or in coding terms, run your program—you need to 
assemble it entirely. In the coding world, this is called compiling. 
Languages like C, C++, and Rust are examples of compiled 
languages. 
Why are we discussing compiled languages like C++ and interpreted 
languages like Python? Because if speed is really important, like 
when making video games, then Python might not be the optimal 
programming language to use in most cases. 
 
 

The Complete Python Book 
 
41
 
 
 
 
 
 
 
 
 
[B/I/A] Quiz for Level 1 
 
 
 
 
 
  
 

The Complete Python Book 
 
42
Please answer the following multiple choice questions. At the end 
of the quiz are the answers.  
1) What are the pros of using Google Colab? 
a. There is nothing to install as we use Google Colab in 
a browser.  
b. It offers free GPU usage. 
c. It’s easy to share your code with others, which is 
great for collaboration.  
d. All of the above are correct. 
 
2) What are the cons of using Google Colab? 
a. There are GPU limitations - if you use it way too 
much then you might have to consider paying for 
the Pro version 
b. it is not secure enough for corporate use as it runs 
in the cloud and not on your computer.  
c. Both answers above are correct. 
 
3) When commenting code, what symbol should we use 
before typing our comments?  
a. @ 
b. # 
c. ! 
d. * 
 
4) Which line of code prints Hello World? 
a. print(Hello World) 
b. print “Hello World”  
c. show(“Hello World”) 
d. print(“Hello World”) 

The Complete Python Book 
 
43
 
Answers:  
1) d 
2) c 
3) b 
4) d 
 
 

The Complete Python Book 
 
44
 
 
 
 
 
 
 
 
 
[B/I/A] LEVEL 2: DATA TYPES 
AND VARIABLES 
 
 
 
 

The Complete Python Book 
 
45
 
 
 
 
 
 
 
 
 
 
[B/I/A] Intro to Data Types and Variables 
(What, Why and How of Level 2) 
 
 
 
 
 
  
 

The Complete Python Book 
 
46
Welcome to Level 2. In terms of the what, why and how of Level 2, 
let’s kick it off with the what. What will we learn together? We will 
learn about data types like text meaning a string, or a number, 
meaning integer, Boolean or floating. We will also discuss how to 
declare variables as text or a number.  
In terms of why. Why are we going to discuss whether a data type 
is text or a number? Because Python needs to know if an item is a 
number so it can potentially do calculations with it.  
Lastly how. How are we going to learn about data types and 
variables together? We will have several exercises that we will do 
together during Level 2, in order to understand how to declare a 
variable as a data type or text, meaning string and how to declare 
a variable  as a data type of number, meaning an integer, floating 
point or Boolean.  
Please note that we will discuss more advanced strings and data 
types like arrays and these items in Levels 3, 5, 7 and 8. 
In addition to the exercises that we will do during Level 2, at the 
end of Level 2 we also have quiz to help us reinforce what we have 
learned together. 
 
 

The Complete Python Book 
 
47
 
 
 
 
 
 
 
[B/I/A] How to Code Data Types & Variables in 
Python (String & Integer Variables) 
 
 

The Complete Python Book 
 
48
Python syntax is simple and easy to read, making it perfect for 
beginners and pros alike. Understanding syntax is like learning the 
grammar of a language. It's the foundation upon which all your 
future coding projects will be built. So, let's talk about variables 
first, meaning the orange blocks we see in the image below: 
 
Let’s write our first line of code. We are going to create a line of 
code to name Mr. Skywalker. Name = Skywalker:  

The Complete Python Book 
 
49
 
Mr. Skywalker here is in quotes, as you can see. We created a 
variable called name, and we assigned the variable name in quotes, 
Mr. Skywalker.  
Let’s go together to Google Colab, and from now on, let’s just call 
it Colab. And we're going to click on new, and we're going to create 
a new notebook: 

The Complete Python Book 
 
50
 
Per the image below, let's enter the following code. Name = “Mr. 
Skywalker” which is the color orange. We try to color code all this 
stuff. Now if we run the code by pressing the play button, it looks 
like nothing happened, but something did. 

The Complete Python Book 
 
51
 
What happened when we ran this code is we taught Python that 
our variable, meaning name is assigned a value of “Mr. Skywalker.” 
Instead of using double quotes, what we can also do is we can use 
single quotes and it will also work.  
Python knows that what we just created was a string because we 
put Mr. Skywalker in quotes. What we can also do is we can rewrite 
this line of code as follows using a data type of string:  

The Complete Python Book 
 
52
 
String is the data type and there's other data types that we'll talk 
about in this book. 
For now, just think of strings as text or anything in quotes. 
Strings can get more complicated, and we're going to continue to 
build on this logic throughout this book. These bricks are using 
lowercase on purpose, because Python is case sensitive.  
 

The Complete Python Book 
 
53
If I change this code to put string on the outside with capital S T R, 
then per the image below we get an error (Python is case sensitive): 
 
It's great to get errors because this is how we learn. Let's change it 
back now to lowercase str, And we see we do not get an error. 
 
Now, there's several different types of data, or different data types, 
as you can see from these four blocks right here: 

The Complete Python Book 
 
54
 
Let’s now discuss another data type, which is int, for integer. We 
know that integer means a whole number, like one, two, or three. 
What if we define the name Mr. Skywalker as an integer, and we 
ran the code. What do you think would happen? 
 
We get an error. 
Let's now add another line of code to define age as 44.  

The Complete Python Book 
 
55
 
Python is smart enough to know that 44 is an integer. We can also 
add int to get the same result:  
 
Functions:  
In the exercise in Level 1, we used print to show Hello World to the 
user. This is called a function; the print function has only one goal, 

The Complete Python Book 
 
56
which is to show the message, meaning show information back to 
the user. Print is a function. 
There are many built-in Python functions, to make our lives so 
much easier by accomplishing a certain task for us. We can even 
define our own functions, which we will discuss in Level 4. 
 
And we're going to talk about functions in more detail in this Level 
you see right here. So let's go back to Colab together. And I want to 
see if you can add a second line of code to Colab and print the 
variable called name. Okay, so pause me if you want to. And do this 
if you want to in Colab and then press play to run the code. 
Let’s use the print function to print the variable called name:  

The Complete Python Book 
 
57
  
Notice we didn't need to put quotes around name. We don't need 
quotes because we already defined the variable name as Mr. 
Skywalker.  
 
Please remember to comment your code, just in case we ever come 
back to see our code in the future, to see what we are trying to 
accomplish, or if somebody else is going to look at our code as well, 
to see what we're trying to do.  

The Complete Python Book 
 
58
 
We know that Python is going to skip the commented line of code. 
We can also type comments after the code: 
 
How can we tell if a variable is a string or an integer? We can use 
the type() function. Per the image below, the type function tells us 
that our variable is a string type.  

The Complete Python Book 
 
59
 
Per the image below, we can also ask Python to tell us what type of 
variable is age. The result is int for integer. 
 
Soo we will discuss how to change a variable from string to integer. 
Changing a data type from one type to another is called casting. 

The Complete Python Book 
 
60
 
 
 
 
 
 
 
 
 
 
 
[B/I/A] Exercise 2.1: Using String and Integer 
Data Types 
 
 
 

The Complete Python Book 
 
61
Exercise Instructions: 
Step 1 for Line 1 of Code: Define name as a string variable 
& call it Darth Vader 
Step 2 for Line 2 of Code: Print the name Darth Vader 
Step 3 for Line 3 of Code: Define age as an integer variable 
and make it 19 
Step 4 for Line 4 of Code: Print the age 
 
 
 

The Complete Python Book 
 
62
 
 
 
 
 
 
 
 
 
[B/I/A] Answer 2.1: Using String and Integer 
Data Types 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
63
Below is an image of the solution:  
 
 
 
 

The Complete Python Book 
 
64
 
 
 
 
 
 
 
 
 
 
[B/I/A] Floating and Boolean Data Types 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
65
Now that we understand how to use string and integer data types, 
let's talk about two more data types, which are float and Boolean 
right here.   
Let’s kick it off with floating point, which is called float. We know 
that an integer is a round number like one, two, or three.  If we go 
to Colab and we type this, pi = 3. 14. And then we type print(pi), 
and then we type type(pi), then we get a data type of float:  
 
 
Float means floating point, which means numbers that have 
decimal points. 
We can also type float on the first line of code to get the same 
result:  

The Complete Python Book 
 
66
 
Another data type is Boolean, which refers to true or false. In the 
programming world, this can also be written as 0 or 1. 1 always 
means true and 0 always means false when programming.  
Below is an example of using Boolean and the resulting answer and 
data type:  
 
 

The Complete Python Book 
 
67
Notice that the T in true is uppercase. It has to be uppercase 
because lowercase true will result in an error. 
We can also write bool and then (True) to get the same result:  
 
Replacing True with 1 provides the same result:  
 
If we change 1 to 0, the result is False: 

The Complete Python Book 
 
68
 
Why is this important?  Because with advanced programming that 
we'll do later in this book together, we might want to use true or 
false logic.  
 
 

The Complete Python Book 
 
69
 
 
 
 
 
 
 
 
 
[B/I/A] Exercise 2.2: Using Floating and 
Boolean Data Types 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
70
Exercise Instructions:  
Step 1 for Line 1 of Code: Define a Boolean variable called i 
cannot do it as false 
Step 2 for Line 2 of Code: Print the variable 
Step 3 for Line 3 of Code: Define a floating variable called 
the answer as 42.01 
Step 4 for Line 4 of Code: Print the variable    

The Complete Python Book 
 
71
 
 
 
 
 
 
 
 
 
[B/I/A] Answer 2.2: Using Floating and 
Boolean Data Types 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
72
Here is the answer:  
 
 
 

The Complete Python Book 
 
73
 
 
 
 
 
 
 
 
 
[B/I/A] How to Change the Content or Data 
Type of a Variable ("Casting") 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
74
Let's say that we have two lines of code as follows: 
 
How do we change the contents of name from Darth Vader to Mr. 
Skywalker?  We can add a third line of code as follows (and a 4th to 
print the variable change):  
 
 

The Complete Python Book 
 
75
Let's discuss how to change a variables data type from string to 
integer.  In the previous Chapters, we used str for string, int for 
integer, and float for floating numbers,  and also bool to define our 
variables in different data types.  
Now, let's make a variable called age, and instead of making it equal 
to 100, let's define this number in double quotes: 
 
Python interprets age as a string because we put 100 in quotes.  
In order to convert age from str to int, we can type the following 
code (starting in line 39):  
 
Another thing to keep an eye on is consequences of converting a 
floating number into integers. Whenever we convert a number that 
has a decimal point, meaning a floating to an integer, no matter 
how close it is to the next number, it will just discard everything 

The Complete Python Book 
 
76
after decimal point and keep the first number, which may lead to 
losing some precious information: 
 
No matter how many numbers we have after the decimal point, 
everything will be discarded and just the first number will be kept.  
This does not round numbers, it just cuts them off. Later on in this 
book, we will discuss the rounding function. 
 

The Complete Python Book 
 
77
 
 
 
 
 
 
 
 
 
[B/I/A] Exercise 2.3: How to Change the 
Content or Type of a Variable 
 
 
 
 

The Complete Python Book 
 
78
Please complete the following steps below:  
C3P0 is 1.75 meters tall & R2D2 is 1.09 meters tall.  
Step 1: Create a variable called height as a string type 
Step 2:  Assign the height a value of 1.09 
Step 3:  Print the height of R2D2 
Step 4:  Change the height data type from string to floating 
Step 5:  Add 0.66 to 1.09 
Step 6:  Print the new height 
 
 
 

The Complete Python Book 
 
79
 
 
 
 
 
 
 
 
 
[B/I/A] Answer 2.3: How to Change the 
Content or Type of a Variable 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
80
Here is the answer: 
 
 
 
 

The Complete Python Book 
 
81
 
 
 
 
 
 
 
 
 
[B/I/A] Quiz for Level 2 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
82
Please answer the following multiple choice questions. At the end 
of the quiz are the answers.  
1) Which line of code defines a variable called name to 
equal Luke Skywalker” 
e. name is “Luke Skywalker” 
f. “Luke Skywalker” = name 
g. name =  Luke Skywalker 
h. name =  “Luke Skywalker”  
 
2) Which line of code will result in an error?  
a. name = int(“Mr. Skywalker”) 
b. name = STR(“Mr. Skywalker”) 
c. name = str(Mr. Skywalker) 
d. All answers above result in an error. 
 
3) Let’s assume that we typed the following line of code:  
name = “Mr. Skywalker" 
What line of code can we add to find out if name is an 
integer or a string? 
a. type(“Mr. Skywalker”) 
b. type(Mr. Skywalker) 
c. type(name) 
d. type(“name”) 
 
4) Which of the following is the correct syntax for defining 
a Boolean variable as true?  
a. boolean_variable = true 
b. boolean_variable = TRUE 

The Complete Python Book 
 
83
c. boolean_variable = True 
d. None of the answers above are correct. 
 
5) What is the result if we run this line of code: 
print(int(3.6) 
a. 4 
b. 3.5 
c. 3 
d. None of the answers above are correct. 
Answers:  
1) d 
2) d 
3) c 
4) c 
5) c 
 
 
 

The Complete Python Book 
 
84
 
 
 
 
 
 
 
 
[B/I/A] LEVEL 3: PYTHON MATH 
(MEANING OPERATORS) AND 
"STRINGS" 
 
 

The Complete Python Book 
 
85
 
 
 
 
 
 
 
 
 
 
[B/I/A] Introduction to Python Math 
(Operators) & Strings (What, Why & How of 
Level 3) 
 
 
 
 
 
  
 

The Complete Python Book 
 
86
Welcome to Level 3. In terms of the what, why, and how of Level 3, 
let's kick it off with the what. What will we learn together?  We will 
learn about arithmetic in Python.  
There is another concept that we're going to introduce as well that 
allows us to tie together variables called “strings”. I mentioned 
strings in double quotes here because we don't want to confuse 
this with the data type called str or the string data type; this will 
make much more sense by the time we're done here with Level 
three.   
In terms of why, why does it make sense to bother talking about 
math when it comes to Python? Because sometimes we need to 
use a double equal sign instead of just one equal sign. Python has 
a few other math rules that we need to be aware of. 
Lastly, how? How are we going to learn about math and string 
concepts together here in Level three?  We will have several 
exercises that we will do together to understand how to use Python 
math and strings.  Also, at the end of Level 3, we also have a short 
quiz to help us reinforce everything that we learned. 
 
 
 

The Complete Python Book 
 
87
 
 
 
 
 
 
 
 
 
[B/I/A] Arithmetic Rules in Python 
 
 

The Complete Python Book 
 
88
Once we have a variable of a data type that is integer or floating,  
then we can use math.  We're going to introduce more data types 
that use math very soon. The typical math rules apply in Python, as 
multiplication and division takes precedence over plus and minus.  
 
For example, per the image below if we type age equals 44. Then 
we print the age+1*2, the answer is 46.4. 
 
 
What if we wanted to add 1 before multiplying by 2? Per the image 
below, we would put age +1 in brackets:  
 

The Complete Python Book 
 
89
Similar to using Microsoft Excel, once you create an open bracket, 
you have to create a closing bracket as well.  
 

The Complete Python Book 
 
90
 
 
 
 
 
 
 
 
 
[B/I/A] Exercise 3.1: Arithmetic Rules in 
Python 
 
 
 
 

The Complete Python Book 
 
91
Here are the exercise instructions:  
Ahsoka is 1.70 meters tall, Yoda is 0.66 meters tall, R2D2 is 1.09 meters tall and 
C3P0 is 1.75 meters tall 
Step 1: Get the average height of the 4 characters 
 
Step 2:  Print the average height 
 
Step 3:  Define 4 variables in your calculations as follows:  
 
    Ahsoka heigh, Yoda height, R2D2 height, C3P0 height 
 
 
 
 
 
 
 

The Complete Python Book 
 
92
 
 
 
 
 
 
 
 
 
 [B/I/A] Answer 3.1: Arithmetic Rules in 
Python 
 
 
 

The Complete Python Book 
 
93
Here is the answer:  
  
 
 

The Complete Python Book 
 
94
 
 
 
 
 
 
 
 
 
[B/I/A] Stringing Together Variables 
 
 

The Complete Python Book 
 
95
Let's talk about stringing together variables, meaning including 
them together. And let's talk about how to use name in a sentence. 
Per the image below, we use the + sign to string together 
information.  
 
Notice that I also put a space here after Your name is. If I didn't put 
a space in here and we ran it, we would see “Your name isYoda.” 
Per the image below, we cannot use int data types when using the 
print statement. We must convert int to str in order for the print 
statement to not provide us with an error:  
 

The Complete Python Book 
 
96
This will temporarily change the data type to string, so we can use 
it in a print statement.  
The rule is that when you string together variables, they have to be 
classified as strings 
 
 

The Complete Python Book 
 
97
 
 
 
 
 
 
 
 
 
[B/I/A] Exercise 3.2: Stringing Together 
Variables 
 
 

The Complete Python Book 
 
98
Please complete the following steps: 
Step 1: Define 2 names as Jack & Rose 
Step 2:  Define the year as 1912 
Step 3:  Using the 2 name variables and the year variable, 
print this:  
    Jack and Rose were on the Titanic in 1912 
 
 
 

The Complete Python Book 
 
99
 
 
 
 
 
 
 
 
 
[B/I/A] Answer 3.2: Stringing Together 
Variables 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
100
Here are the answers:  
 
 
 
 

The Complete Python Book 
 
101
 
 
 
 
 
 
 
 
 
 
[B/I/A] Quiz for Level 3 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
102
Please answer the following multiple choice questions. At the end 
of the quiz are the answers.  
1) If we have 2 lines of code (shown below), what is the result 
if we run the code?  
age = 50 
print((age+2)*2) 
i. 102 
j. 104 
k. Both answers above are incorrect. 
 
2) Let’s assume that we have one line of code as follows: name 
= “Jack” 
What line of code should we type in order to print this: 
Jack is friends with Rose.   
a. print(name+“ is friends with Rose”.) 
b. print(name&“ is friends with Rose”.) 
c. print(“name+ is friends with Rose”.) 
d. print(“name& is friends with Rose”.) 
 
3) Let’s assume that we typed the following line of code:  
age = 51 
What line of code can we add to print this:  
 
Chris is 51 years old. 
a. print("Chris is "+age+” years old.”) 

The Complete Python Book 
 
103
b. print("Chris is "+int(age)+” years old.”) 
c. print("Chris is "+str(age)+ " years old.") 
d. print("Chris is "+ (age)+ " years old.") 
 
Answers:  
1) b 
2) a 
3) c 
   
 
 

The Complete Python Book 
 
104
 
 
 
 
 
 
 
 
[B/I/G/A] LEVEL 4: BUILT IN 
FUNCTIONS & CREATING BASIC 
FUNCTIONS 
 
 

The Complete Python Book 
 
105
 
 
 
 
 
 
 
 
 
[B/I/G/A] Intro to Built-In/Creating Functions 
(What, Why & How of Level 4) 
 
 
 

The Complete Python Book 
 
106
Welcome to Level 4. In terms of the what, why, and how of Level 4, 
let's kick it off with the what, what we learned together.  We're 
going to learn about the built in functions in Python. We have 
already discussed the print and type built in functions,  and we will 
introduce more of the built in functions here in Level 4.  
In terms of why, why should we learn about using Python's built in 
functions?  Because it can save us so much time when we're 
programming.  What if Python doesn't have a built in function that 
I want to use or I need? Well, that's okay, because here in Level 4 
we'll also teach you how to create your own custom functions.  
Lastly, how? How are we going to learn about functions together 
here in Level 4? We will have several exercises that we will do 
together to understand how to use the built in functions and how 
to define and use our own functions.   
In addition to exercises that we will do together during Level 4 to 
learn about functions, at the end of Level 4 we also have a short 
quiz to help us reinforce everything that we learned together so 
far. 
 
 

The Complete Python Book 
 
107
 
 
 
 
 
 
 
 
[B/I/A] Basic Built in Python Functions that 
Use Math 
 
 

The Complete Python Book 
 
108
So far, we've talked about two different types of functions, the type 
and the print functions. Recall that the type function will tell us if 
an object is a number or a string, meaning text or a different data 
type.  In this Chapter we will talk about some of the basic built in 
Python functions that we use math in. 
In Microsoft Excel, we know that if we type =min(), we get the 
minimum value in cells. Similarly, in Python, there are built in 
functions that are like this. Per the image below, we can use the 
min function using the syntax of min(value1,value2,value3). 
 
Similarly, per the image below, the max function works the same 
way.  

The Complete Python Book 
 
109
 
In order to find the absolute (positive) value of a number, we use 
the abs function as follows:  
 
When using the round function, the syntax is as follows:  

The Complete Python Book 
 
110
 
 
If we wanted to round the number to 2 decimal points, we would 
type this: a = round(a, 2) 
. 
 

The Complete Python Book 
 
111
 
 
 
 
 
 
 
 
 
[B/I/A] Exercise 4.1: Built in Functions that Use 
Math 
 
 

The Complete Python Book 
 
112
Please complete the following steps:  
Ahsoka is 1.70 meters tall, Yoda is 0.66 meters tall and R2D2 is 1.09 
meters tall   
Step 1: Create the variables of height for the 3 characters 
Step 2: Create a print line of code that prints this: 
The average height is [put the average height here]. 
The maximum height is [put the maximum height 
here]. The minimum  height is [put the maximum 
height here]. 
Step 3: This is tricky, but fun, you have to create additional 
variables for the average, minimum, and maximum heights 
 
 
 
 
 
 

The Complete Python Book 
 
113
 
 
 
 
 
 
 
 
 
[B/I/A] Answer 4.1: Built in Functions that Use 
Math 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
114
Here is the answer:  
 
Then add the following line of code:  
Print(“The average height is “ +str(average_height)+”. The 
maximum height is “+str(maximum_height)+”. The minimum 
height is “+str(minimum_height)) 
 
The output is as follows:  
 
The average height is 1.150000000000001. The maximum height is 
1.7. The minimum height is 0.66 
  
 

The Complete Python Book 
 
115
 
 
 
 
 
 
 
 
 
[B/I/A] Input Built in Python Function 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
116
Now that we understand how to use some math functions, let's talk 
about a function that doesn't use math, which is my favorite 
function, and it's called input function. I love this one because we 
can interact with our user using the input function.  
Here is an example of how to use the input function:  
 
Per the image above, when we run the code we assigned a variable 
called name to whatever our user entered when prompted for their 
name.  
 
 

The Complete Python Book 
 
117
 
 
 
 
 
 
 
 
 
[B/I/A] Exercise 4.2: Input Built in Python 
Function 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
118
Please complete the following steps: 
Step 1: Create code that asks for your name and then your 
age. 
Step 2:  Print this:  
Your name is [your name]. Your age is [your age]. 
   
 

The Complete Python Book 
 
119
 
 
 
 
 
 
 
 
 
[B/I/A] Answer 4.2: Input Built in Python 
Function & Stringing Together Objects 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
120
Here is the answer: 
 
 
 

The Complete Python Book 
 
121
 
 
 
 
 
 
 
 
 
 
[B/I/A] Creating Basic Custom Functions Part 1 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
122
Now that we understand how to use some Python built in 
functions, let's learn how to make custom functions, and this is a 
lot of fun. The way we do this is we start by type def, per the image 
below for define.  
 
Then we name our function and include (): at the end of the name, 
per the picture above.  
Then on the next line we indent and type our code. If we don’t 
indent, then the function won’t work.  
Lastly, the way to call the function to run, per the image above, is 
we do not indent, and we simply type the function name, followed 
by () 
 

The Complete Python Book 
 
123
 
 
 
 
 
 
 
 
 
[B/I/A] Exercise 4.3: Creating Custom 
Functions Part 1 
 
 
 
 

The Complete Python Book 
 
124
Please complete the following steps:  
Step 1:  Define a function called age_of_rey 
Step 2:  In the function, ask "How old is Rey? " 
Step 3:  In the function print Rey's age is 19. 
Step 4:  Call the function and enter Rey's age, which is 19. 
 
 
 

The Complete Python Book 
 
125
 
 
 
 
 
 
 
 
 
[B/I/A] Answer 4.3: Creating Custom Functions 
Part 1 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
126
Here is the answer:  
 
 
 

The Complete Python Book 
 
127
 
 
 
 
 
 
 
 
 
[I/G/A] Creating Basic Custom Functions Part 
2 
 
 
 

The Complete Python Book 
 
128
Let's talk about passing parameters, meaning data, to a function 
when we call it.  We'll create code that asks for a person’s name 
and age, and then we're going to call a function that tells us how 
old the person will be in one year, per the image below:  
 
Please remember to indent after you define the function.  
Also, when we call the function (per the image above), we need to 
make sure that we do not indent the last line of code that calls the 
function.  
Also, please remember that whenever you're using a 
concatenation, meaning attaching strings together or stringing 
stuff together, it has to be in the form of a string and not an 
integer. 
 
 

The Complete Python Book 
 
129
 
 
 
 
 
 
 
 
 
[I/G/A] Exercise 4.4: Creating Basic Custom 
Functions Part 2 
 
 

The Complete Python Book 
 
130
Please complete the following steps:  
Step 1:  Ask who was on the Titanic? 
Step 2:  Ask what year is it currently? 
Step 3:  Print: Jack and Rose were on the Titanic, which sunk 
112* years ago.  
*This number will be higher if you take this course after 
2024. 
 
 
 
 

The Complete Python Book 
 
131
 
 
 
 
 
 
 
 
 
[I/G/A] Answer 4.4: Creating Basic Custom 
Functions Part 2 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
132
Here is the answer:  
 
 
 
 

The Complete Python Book 
 
133
 
 
 
 
 
 
 
 
 
[I/G/A] Creating Advanced Functions 
(Keyword and Default Values) 
 
 

The Complete Python Book 
 
134
So far with our custom functions, we've assumed that the 
arguments were passed in order. For example, per the image 
below, name and then age are passed to the function in order. At 
the bottom of the code we see two different ways of passing the 
parameters to this function.  
 
One way is we select the variables in order, name and age. And the 
other way is we passed two values for the variable, my name (Chris) 
and my age (51).   
What if we wanted to pass the items not in order? Meaning, 
instead of name and then age, We want to send age and then 
name.  This is referred to as keyword arguments. 
And the way to do this is, (per the image below) we type 
age_in_one_year(age=”51”, name=”Chris”). 
In brackets we can reorder the variables, when we call the custom 
function 
What if we call the custom function, but we don't put in a value in 
brackets? Well, what we can do is we can set a default value if 
nothing is entered, per the image below:  

The Complete Python Book 
 
135
 
When we defined the name, in brackets we typed name=”Yoda” 
Then, per the image above, if we call the function and we don’t 
type anything in brackets, then the code will return the default 
value, which is Yoda.  
 
 
 

The Complete Python Book 
 
136
 
 
 
 
 
 
 
 
 
[I/G/A] Exercise 4.5: Creating Advanced 
Functions Keyword and Default Values) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
137
Please complete the following steps:  
Step 1:  Create a function called my_age with 1 variable in 
brackets called age.  
Step 2:  In the custom function, print my age is [your age]. 
Step 3:  Call the function, using the age of 39.  
Step 4:  Change the default age in the function to 19.  
Step 5:  Call the function with nothing in brackets. 
 
 

The Complete Python Book 
 
138
 
 
 
 
 
 
 
 
 
[I/G/A] Answer 4.5: Creating Advanced 
Functions (Keyword and Default Values) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
139
Here is the answer: 
 
 
 

The Complete Python Book 
 
140
 
 
 
 
 
 
 
 
 
[I/G/A] Returning Values from Custom 
Functions 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
141
Let's discuss how to get return values from custom functions. Per 
the image below, we defined a custom function called  convert-
fahrenheit_to_celsius. We then convert Fahrenheit to Celsius by 
using the return word.  
 
 
 
 
 

The Complete Python Book 
 
142
 
 
 
 
 
 
 
 
 
[I/G/A] Exercise 4.6: Returning Values from 
Custom Functions 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
143
In this exercise, please complete the following step:  
Step 1 of 1: Create a custom function that converts Celsius 
into Fahrenheit. 
Please use the word return in your function. 
 
 
 

The Complete Python Book 
 
144
 
 
 
 
 
 
 
 
 
[I/G/A] Answer 4.6: Returning Values from 
Custom Functions 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
145
Here is the answer:  
 
 
 
 

The Complete Python Book 
 
146
 
 
 
 
 
 
 
 
 
[B/I/G/A] Quiz for Level 4 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
147
Please answer the following multiple choice questions. At the end 
of the quiz are the answers.  
1) If we have 3 lines of code (shown below), and the result when 
we run the code is 12, then what is the function we should use 
(meaning fill in the blank in line 2)? 
a = -12 
___(a) 
print(a) 
a. absolute 
b. ABS 
c. Abs 
d. None of the answers above are correct.  
 
2) If we have 3 variables a, b and c then what line of code will 
calculate the minimum value?  
 
a. Minimum(a,b,c) 
b. Min(a,b,c) 
c. min(a,b,c) 
d. min(a&b&c) 
 
3) What line of code should we type to ask the user to enter 
what their name is?  
  
a. Input(“What is your name? “) 
b. input(“What is your name? “) 
c. Input(What is your name? ) 
d. input(What is your name?) 

The Complete Python Book 
 
148
 
4) What is wrong with the code below that defines a function 
(lines 1 and 2) and then calls the custom function (line 3)?  
 
Def print_hello_world_function() 
print(“Hello World”) 
print_hello_world_function: 
 
a. Def should be all lower-case 
b. We need to add a : to the end of the first line 
c. The second line should be indented 
d. We need to remove the : in line 3 and replace it with 
() 
e. All of the answers above are correct (meaning they 
all 
identify 
issues 
with 
the 
code).  
 
5) If we run the following code, what will the result be?  
def your_name(name=”Yoda”): 
 
print(“Your name is “+name) 
your_name() 
 
a. Nothing will show – the answer is blank 
b. Your name is  
c. Your name is Yoda 
d. None of the answers above are correct 
Answers:  
1) C 
2) C 
3) B 
4) E 

The Complete Python Book 
 
149
5) c 
 
 

The Complete Python Book 
 
150
 
 
 
 
 
 
 
 
[B/I/G/A] LEVEL 5: THE LIST 
DATA TYPE AND THE SUM 
FUNCTION 
 
 

The Complete Python Book 
 
151
 
 
 
 
 
 
 
 
 
 [B/I/G/A] Intro to List Data Type (What, Why 
and How of Level 5) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
152
Welcome to Level 5. We're making amazing progress. In terms of 
the what, why, and how of Level 5, let's kick it off with the what. 
What will we learn together?  We already discussed how to use 
several data types. We'll discuss another data type called the lists 
data type.   
In terms of why, why are lists important to learn? Because we can 
populate lists with lots of data, separated by commas for example, 
and not just a single piece of data. And this will help you take your 
Python game to the next Level.   
Lastly, how? How are we going to learn about lists together? After 
explaining how lists work and why they are so awesome, we will do 
exercises together during Level 5. Then, at the end of Level 5, there 
is a quiz to reinforce everything that we learned together.. 
 
 

The Complete Python Book 
 
153
 
 
 
 
 
 
 
 
 
[B/I/G/A] How Does the List Data Type Work 
(and Using the SUM Function)? 
 
 

The Complete Python Book 
 
154
A great way to learn programming is to experiment and try lots of 
new things and make mistakes, which is what I will do and I do all 
the time.  It's a lot of fun because it's like a video game, because 
programming is like a puzzle or like building with Legos. So please 
embrace errors as fun and part of the learning process as well. 
In this Chapter we will introduce the sum function and we're also 
going to introduce something called lists, which is mind blowing. 
Per the image below, in the 3rd line we created a list that stores 2 
items. We use square brackets, and we separate the items with 
commas.  
 
Then, per the image above, we can use the sum function on the 4th 
line to add the items together that were included in the list.  
The image below shows another example of using lists, which is a 
powerful data type.  

The Complete Python Book 
 
155
 
 
 

The Complete Python Book 
 
156
 
 
 
 
 
 
 
 
 
[B/I/G/A] Exercise 5.1: The List Data Type 
Work (and Using the SUM Function) 
 
 

The Complete Python Book 
 
157
Please complete the following steps:  
Step 1: Create a list called height, which has 3 numbers in it 
as follows: Ahsoka is 1.7 meter, Yoda is 0.66 meters and 
R2D2 is 1.09 meters. 
Step 2: Print the type of variable that height is. 
Step 3: Print the sum of the list called height. 
 
 

The Complete Python Book 
 
158
 
 
 
 
 
 
 
 
 
[B/I/G/A] Answer 5.1: The List Data Type 
Work (and Using the SUM Function) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
159
Here is the answer:  
 
 
 

The Complete Python Book 
 
160
 
 
 
 
 
 
 
 
 
[B/I/G/A] Quiz for Level 5 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
161
Please answer the following multiple choice questions. At the end 
of the quiz are the answers.  
1) Below is code that prints the number 50. Please fill in the 
blanks on all 3 lines (meaning the ____ shown on all 3 lines).  
twenty_plus_thirty = [20_30] 
sum_of_list = sum(__________) 
print(_______) 
a. _ from line 1 is , (meaning a comma), _____ from 
line 2 is sum_of_list and _____ from line 3 is 
sum_of_list 
b. _ from line 1 is + (meaning a plus sign), _____ from 
line 2 is twenty_plus_thirty and _____ from line 3 is 
sum_of_list 
c. _ from line 1 is & (meaning the and sign), _____ from 
line 2 is twenty_plus_thirty and _____ from line 3 is 
sum_of_list 
d. None of the answers above are correct.  
 
2) Below is code that prints the number 30. Please fill in the 
blank _____(meaning the ____).  
person_1_experience_in_years = 20 
person_1_experience_in_years = 10 
1_and_2_experience = 
[person_1_experience_in_years, 
person_2_experience_in_years] 

The Complete Python Book 
 
162
total_experience = ______ 
print(total_experience) 
a. sum(1_and_2_experience) 
b. sum[1_and_2_experience] 
c. sum(1_and_2_experience) 
d. sum[1_and_2_experience] 
 
 
Answers:  
1) a 
2) a 
 
 

The Complete Python Book 
 
163
 
 
 
 
 
 
 
 
[B/I/G/A] LEVEL 6: LOGIC AND 
LOOPS 
 
 

The Complete Python Book 
 
164
 
 
 
 
 
 
 
 
 
 [B/I/G/A] Intro to Logic and Loops (What, 
Why and How of Level 6) 
 
  
 
 

The Complete Python Book 
 
165
Welcome to Level 6. In terms of the what, why, and how of Level 6, 
let's kick it off with the what. What will we learn together?  We will 
learn how to use logic like and as well as or when we code.  We will 
also learn about how to use if statements, the for and while loops, 
as well as how to use the match and case.  
In terms of why, Why should we learn and care about these logic 
and loop topics? Because this will take our Python skills, coding 
skills, to the next Level. As we can decide how our code will adapt 
and function given different scenarios.   
Lastly, how? How are we going to learn about logic and loops 
together here in Level six?  We will have many exercises that we 
will do together during Level six in order to understand how to add 
much more functionality to our code, which makes the whole 
programming experience much more fun.  In addition to exercises 
we will do during Level six to learn about the logic and loop 
concepts, at the end of Level six, we also have a quiz to help us 
reinforce what we learned together. 
 

The Complete Python Book 
 
166
 
 
 
 
 
 
 
 
 
[B/I/A] The IF, ELSE Statement 
 
 

The Complete Python Book 
 
167
Let's talk about the if statement. This is a fun one.  At the bottom 
of the image below, we have Jedis who are holding a lightsaber.  
Those that are not holding lightsabers are not jedis. Let’s write 
some code using the if statement to see if the character is a Jedi or 
not.   
 
Per the image above, we start with an input line of code on line 1. 
We ask what is the name of the character? Then on line 2 we ask if 
the character is holding a lightsaber.  
Then on line 4, we create our if statement. When using if 
statements, when we use equals, we have to write it as follows: == 
Similar to defining functions (meaning def), we must also put a 
colon at the end of the if statement (on line 4) and we must indent 
the next line, or Python won’t understand that it should be part of 
the if statement.  

The Complete Python Book 
 
168
In line 4, if we enter Yes for the question in line 2, then we execute 
the final line of code, which is to print the name of the character 
and state that that character is a jedi.  
If the user enters anything other than Yes, then the print line will 
not be executed.  
Per the image below, we can add an else: statement in case the 
user did not enter the word Yes. The else statement must have a 
colon beside it and it must not be indented. Then whatever we type 
below the else statement must be indented.  
 
 
 

The Complete Python Book 
 
169
 
 
 
 
 
 
 
 
 
[B/I/A] Exercise 6.1: The IF, ELSE Statement 
 
 

The Complete Python Book 
 
170
Please complete the following step:  
Step 1 of 1: Ask the user if Rose is holding a lightsaber. If 
they type Yes, then type a message saying Yes. If they type, 
No, then type a message saying No. 
 
 
 

The Complete Python Book 
 
171
 
 
 
 
 
 
 
 
 
[B/I/A] Answer 6.1: The IF, ELSE Statement 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
172
Here is the answer 
 
 
 

The Complete Python Book 
 
173
 
 
 
 
 
 
 
 
 
[B/I/A] Using A Nested IF Statement 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
174
Let's build upon what we've learned in the past couple of Chapters  
by adding an if statement inside of an if statement. Meaning, we're 
going to add a nested if statement, per the image below. In our 
example, we will ask is the character holding a lightsaber. If the user 
enters Yes, then we will ask them if the lightsaber is red. If the user 
enters red in the nested if statement, then we will inform the user 
that the character is Darth Vader.  
 
When we add a nested if statement, we must indent the entire 
nested if statement, per the image above. 
. 
 

The Complete Python Book 
 
175
 
 
 
 
 
 
 
 
 
[B/I/A] Exercise 6.2: Using A Nested IF 
Statement 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
176
Please complete the following exercise:  
In this exercise create 2 if statements, as follows:  
1: Is the character holding a lightsaber? 
2: Is the lightsaber green. If so, then print: 
    The character is Yoda. 
 
 
 

The Complete Python Book 
 
177
 
 
 
 
 
 
 
 
 
[B/I/A] Answer 6.2: Using A Nested IF 
Statement 
 
 
 

The Complete Python Book 
 
178
Here is the answer to the exercise:  
 
 
 
 

The Complete Python Book 
 
179
 
 
 
 
 
 
 
[B/I/A] Using ELIF in an IF Statement and the 
OR & AND Logic 
 
 

The Complete Python Book 
 
180
If statements using else are helpful if we have two outcomes, 
meaning yes or no.  But what if we had three outcomes instead of 
two?  Well, we can use the if else logic, but it gets long and 
complicated, especially when you use lots of nested if statements.  
Instead, we can use the if and elif logic. And elif means else if.  
Per the image below, we have code that helps us to use 3 scenarios, 
which is perfect for the elif statement.  Per the 4th and 6th lines of 
code below, we type elif and then we create our statement. We 
have to remember to include a : at the end of the line of code and 
then indent the next line of code.  
 
Per the image below, we can even add an else statement to the end 
of the code, in case we want to catch more than 3 inputs from the 
user, meaning if the user enters 4, 5 or 6, instead of 1, 2 or 3.  
 
Also, please remember to always use == when using the elif 
statement.  

The Complete Python Book 
 
181
Per the image below, we can also use the not equals logic. Not 
equals is written as != 
 
Let’s use the or statement, which means one thing is true or the 
other thing is true. Per the image below, the last 4 lines of code 
show how the or statement works. 
 
Per the example below, we can also use the and statement, which 
means one thing is true and the other thing is true.  

The Complete Python Book 
 
182
 
. 
 

The Complete Python Book 
 
183
 
 
 
 
 
 
 
 
 
 [B/I/A] Exercise 6.3: Using ELIF in an IF 
Statement and the OR & AND Logic 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
184
Please complete the following exercise:  
Team 1 contains Yoda. Team 2 contains Jack and Rose. Team 3 has 
Darth Vader and Leah 
Part 1: Use the if, elif, else logic: 
Select Team 1, Team 2 or Team 3. Then print:  
"You picked team 1, which has 1 character, which is Yoda" 
"You picked team 2, which has 2 characters, Jack & Rose" 
"You picked team 3, which has 2 characters, Vader & Leah" 
 
Part 2: Use the and logic. Add additional code to the bottom of Part 
1 as follows:  
"The number of people on the team you selected is odd."  
"The number of people on the team you selected is even." 
 
 
 

The Complete Python Book 
 
185
 
 
 
 
 
 
 
 
 
[B/I/A] Answer 6.3: Using ELIF in an IF 
Statement and the OR & AND Logic 
 
 

The Complete Python Book 
 
186
Here is the answer:  
 
 
 
 

The Complete Python Book 
 
187
 
 
 
 
 
 
 
 
 
[B/I/G/A] Using the MATCH and CASE Logic 
 
 

The Complete Python Book 
 
188
Remember how we coded a few Chapters ago on how to used the 
or and the and statements with selecting an army?  Well, it got 
confusing because of the many combinations of armies, meaning 
one, two, or three and selecting good or not good. Well, this is 
where the match case logic comes in handy. 
It's awesome and this is a relatively new Python feature as it was 
released in Python version 3. 10 in late 2021.   
Per the image below, match case matches the user selection with 
their input. In the first line of code, the user enters 1, 2 or 3. Then 
the match logic looks at the team_selection, followed by a : 
Then 3 case statements (all indented) check to see if the user 
entered 1, 2 or 3.  
If the user entered 2, for example., then the case 2 line of code is 
run and anything below it indented is also run.   
 
 
 

The Complete Python Book 
 
189
 
 
 
 
 
 
 
 
 
 
[B/I/A] Formatting 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
190
If you want to insert a line in Python, you use backslash then 
lowercase n, per the example below:  
 
Now, let's talk about how to format data. Per the image below, 
instead of stringing together data with the + sign, we can use the 
letter f after we type print ( 
Then we can type the variable in curly brackets, as {ticket} in our 
example.  
 
We can use the curly brackets to format data with 2 decimal places 
as well in the example below:  
  

The Complete Python Book 
 
191
 
 
 
 
 
 
 
 
 
[B/I/A] Slicing 
 
 

The Complete Python Book 
 
192
Slicing refers to extracting part of the data. For example, per the 
image below let's type this  full name  equals  James  Bond.  And 
then what I'm going to do is I am going to slice meaning extract 
information: 
 
What we did was we got the full name, James Bond, and now we're 
going to pull out of this, just the first name.  The way we do that is 
we type first_name = full_name[0:5]. It's a little bit confusing 
because you think that zero to five means six numbers: 0. 1, 2, 3, 4 
and 5. It’s also confusing why we start with 0. 
Then for the last name, we used 6:10 in brackets, per the image 
below. 
 
But let me first of all, type the last name now.  
Let's talk about the first name, which is James. Notice how we 
started at 0 and not 1. Why is that?  Because Python starts 
counting at 0.   
But then you might think, why did you include the 6 numbers, 
meaning 0, 1, 2, 3, 4, 5?  Well, James is 5 characters, not 6...this 
doesn't seem to make sense.  0:5 in Python means start at the first 
character (Python starts counting at 0) and then the 5 means end 
at position 6, but do not include position 6.  
 

The Complete Python Book 
 
193
 
 
 
 
 
 
 
 
 
[B/I/A] For Loop 
 
 

The Complete Python Book 
 
194
The for loop can save us a lot of time when coding. For example, 
let's say I wanted to print Darth Vader is a Jedi, Rey is a Jedi, Yoda 
is a Jedi, etc. It would take a long time to code, per the image below:  
 
 
There's got to be a better way.  Well, there is. Per the image below, 
we can use the for loop as follows.  First we define an object called 
jedis. with the name of the six jedis in square brackets. 
 
Then we create our a for loop by typing for x in jedis:   
We didn't have to type . We can replace X with almost anything. 
Also, similar to other loops we have already discussed, we need to 

The Complete Python Book 
 
195
put the : at the end of the first line and then indent everything 
below it, so that it remains in the for loop.  
Per the image below, we can place an if statement indented in the 
for loop and then use the word break to stop running the code after 
the name Yoda is reached:  
 
Another way to use the for loop is with the word range, per the 
image below:  
 
 
 

The Complete Python Book 
 
196
 
 
 
 
 
 
 
 
 
[B/I/A] Exercise 6.5: For Loop 
 
 

The Complete Python Book 
 
197
Please complete the instructions below:  
Step 1 of 1: Create a for loop, that prints 2 lines as follows:  
Leia I am your father.  
Luka I am your father. 
 
 
 

The Complete Python Book 
 
198
 
 
 
 
 
 
 
 
 
[B/I/A] Answer 6.5: For Loop 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
199
Here is the answer: 
 
 
 
 

The Complete Python Book 
 
200
 
 
 
 
 
 
 
 
 
[B/I/A] While Loop 
 
 

The Complete Python Book 
 
201
The while loop is awesome because it loops while a condition is 
true.  Now Yoda, per the image below holding the lightsaber is 900 
years old. And baby Yoda is actually 50.  Now baby Yoda is dying to 
use the lightsaber. And he asks Yoda if he can use it every single 
year. 
 
And it drives Yoda cray cray, poor guy. So what we're going to do is 
we're going to help Yoda here because we care, with a while loop. 
The image below shows us how we use the while loop to help Yoda 
: )   

The Complete Python Book 
 
202
 
We defined Baby Yoda’s age as 50, which is automatically created 
as an integer.  Then we add the while loop. Remember to please 
put a : at the end of the while loop.  
The while loop states that  while Baby Yoda's (BY) age is less than 
or equal to 100, print, you cannot use a lightsaber until you're 100, 
you're currently X years old. This loop stops running when BY 
reaches 100.  
Lastly, as with the other loops we have discussed, we have to 
indent the code below the loop.  
 
 

The Complete Python Book 
 
203
 
 
 
 
 
 
 
 
 
[B/I/A] Exercise 6.6: While Loop 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
204
Please complete the following instructions:  
Step 1 of 1: Create a while loop, that prints this:  
The year is 1912 and nobody has found the Titanic yet.  
The year is 1913 and nobody has found the Titanic 
yet.  
... 
Repeat the loop, until 1984. 
 
 
 
 

The Complete Python Book 
 
205
 
 
 
 
 
 
 
 
 
[B/I/A] Answer 6.6: While Loop 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
206
Here is the answer:  
 
 
 

The Complete Python Book 
 
207
 
 
 
 
 
 
 
 
 
[B/I/G/A] Quiz for Level 6 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
208
Please answer the following multiple choice questions. At the end 
of the quiz are the answers.  
1) Below is code that asks if a user is hungry. If they type Yes, 
then they see the message: Please eat something. If they 
type anything other than Yes, then they see the message: 
Cool; please eat when you are hungry then."). What is/are 
the mistakes with this code (if any)?  
 
are_you_hungry = Input("Are you hungry? ) 
if are_you_hungry ="Yes" 
print("Please eat something.") 
else 
 
print("Cool; please eat when you are hungry then.") 
 
a. Input must be written as input 
b. On line 1, we need to add ” after the question mark 
c. On line 2, we need to replace = with == 
d. On line 2, we need to add : to the end of the line of 
code 
e. Line 3 must be indented 
f. Else needs to have a : at the end of the line of code 
g. All of the answers above are correct – meaning they 
all highlight problems with the code 
h. There are no mistakes with the code.  
 
2) The code below asks the user to enter 1, 2 or 3 and then 
tells the user if the number they chose is odd or even. What 
is wrong with the code below (if anything)? 

The Complete Python Book 
 
209
select_number = input("Enter 1, 2 or 3 ") 
if select_number == "1" and select_number == "2": 
     print("You selected an odd number") 
else: 
     print("You selected an even number")  
a. == is not correct as we should have used = instead 
b. We should have used or and not and  
c. The print lines should not be indented 
d. There is nothing wrong with the code 
 
3) Assuming we defined a variable, called price, which is equal 
to 9.99999. What would we place in the blank below 
(meaning _____) in order to change the price to read as 
9.99? print(f”The price of is _____ dollars”) 
  
a. +price.2.digits+ 
b. +”price.2f” 
c. {price.2f} 
d. None of the answers above are correct.  
 
4) If we had a line of code that is name = “Luke Skywalker” 
then what should we type in order to print Luke?  
 
a. print(name[1:4]) 
b. print(name[0:4]) 
c. print(name[0:5]) 
d. None of the answers above are correct.   
 

The Complete Python Book 
 
210
5) Below, we have 3 lines of code that prints Rose was in a 
movie. Luke was in a movie. What is/are the errors with this 
code?  
names = [Rose, Luke] 
for x in Names:  
print(f"{x} was in a movie.") 
 
a. We need quotes around Rose and Luke 
b. names must be in lower case 
c. The print line should be indented 
d. All of the answers above are correct, meaning they 
highlight errors with the code.  
Answers:  
1) g 
2) b 
3) c 
4) c 
5) d 
 
 

The Complete Python Book 
 
211
 
 
 
 
 
 
 
 
[B/I/G/A] LEVEL 7: 3 MORE 
DATA TYPES: TUPLE, 
DICTIONARY AND SET 
 
 

The Complete Python Book 
 
212
 
 
 
 
 
 
 
 
 
[B/I/G/A] Intro to More Data Types (What, 
Why and How of Level 7) 
 
 
 
 

The Complete Python Book 
 
213
Welcome to Level 7. In terms of the what, why, and how of Level 7, 
let's kick it off with a what. What will we learn together?  In Level 
6, we introduced how to store a collection of data in a list.  Here in 
Level 7, we're going to learn about three very important additional 
data collection types, which are referred to as tuples, dictionaries, 
and sets.  
In terms of why, why should we learn about these three additional 
data types? Because tuples, for example, unlike lists, do not let us 
change any value in its data collection.  Dictionaries allow us to 
connect, what are called keys and values together, while sets do 
not allow any data duplication.  There are other differences for 
aforementioned data types that we will discuss and explain here in 
Level 7.  
Lastly, how?  How are we going to learn about tuples, dictionaries, 
and sets together here in Level 7?  We will have exercises that we 
will do together during Level 7 in order to understand the power of 
using different data type collections.  In addition to exercises that 
we will do during Level 7 to learn about tuples, dictionaries, and 
sets, at the end of Level 7, we will also have a quiz to put everything 
into context and reinforce what we learned together. 
 
 

The Complete Python Book 
 
214
 
 
 
 
 
 
 
 
 
[B/I/G/A] Tuples Explained How is it Different 
from a List? 
 
 

The Complete Python Book 
 
215
In the first six Levels, we covered basic data types, converting from 
one to another and creating basic functions.  But to get a full 
capacity of Python functionality, we need to touch upon two 
different data types that we didn't talk about just yet. Those are 
tuples and dictionaries. 
Per the image below, when we worked with lists in the previous 
sections, we define it and then we added values, such as one, two, 
three and four. We used square brackets with a list. 
 
You can name any type of data inside of a list and of course you can 
access any item in that list in a way that we already covered. 
But one thing that we didn't touch upon was mutability of data 
types. In any programming language, you have the concept of 
mutability, meaning can we change the value inside some variable 
or not?  When you define something, let's say a list, if I want to 
change value of a number of an element using the index 3, I can 
just set to 10,  and it will work, per the image below. Recall that 
Python starts counting at 0. 

The Complete Python Book 
 
216
 
 
And if I visualize all elements from list one, you will see that now, 
instead of 1, 2, 3, 4, I have 1, 2, 3, and 10, which means that list and 
list in Python is mutable. This means that with a list, we can change 
inside the values inside of the list. 
Let’s discuss another data type, called the tuple.  Per the image 
below, defining a tuple is similar to how you would define a list, 
except instead of square brackets, we use round brackets. 

The Complete Python Book 
 
217
 
And when we visualize the element on index 3, so far it works 
basically the same as the list before.   
However, per the image below, when we try to change the value of 
an element in a tuple, we get an error.  
 
We cannot change the values inside the tuple,  which makes the 
tuple immutable and that is the main difference between a list and 
a tuple.  
The reason we would use a tuple is if we have data that we do not 
want to be changed, like the price of an item. Or perhaps we are 
extracting information from a database about a user and we do not 
want to change the contents of the database (think of it as read 
only).  
 

The Complete Python Book 
 
218
Separately, per the image below, if we type a “.” After a list, there 
are many things we can do with that list. 
 
In the image above, we see the word append, meaning we can add 
something to the list.  
If we did the same thing with a tuple (meaning add a period after 
the tuple), we can only do 2 things, which are index and count.  
 
 

The Complete Python Book 
 
219
 
 
 
 
 
 
 
 
 
 [B/I/G/A] Exercise 7.1: Tuples 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
220
Please complete the following exercise:  
Step 1 of 1: Add Darth Vader to the Tuple. 
 
Tip: Use casting (which means change a variable type). 
       Change the Tuple type to List type. 
 
 
 

The Complete Python Book 
 
221
 
 
 
 
 
 
 
 
 
[B/I/G/A] Answer 7.1: Tuples 
 
 
 

The Complete Python Book 
 
222
Here is the answer: 
 
We need to change the tuple to a list and then append (meaning 
add) an item to the list and then we change the tuple back to a list.  
 
 

The Complete Python Book 
 
223
 
 
 
 
 
 
 
 
 
[I/G/A] Introduction to Dictionaries 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
224
The dictionary data type is a more advanced and it has a lot of 
functionality used in data science, in AI, and in general data 
processing. Because in most cases, when you store some data in 
external files and load them back to Python, this will be stored in 
dictionary format.  
When we define a list, we discussed indexing, and indexing of lists 
consists of using a single number, telling you that a certain element 
will be stored in index 0, for example, or index 1. 
Per the image below, a dictionary allows us to use something called 
key value pairs. And to define a dictionary, we're going to define a 
basic dictionary, which is instead of normal brackets or square 
brackets, it will be curly brackets.  
 
When you define a dictionary, you will first define a key. The key 
can be a certain string. It can be anything that you might imagine. 
Per the image above, we defined define a key, which is zero, 
because our first index in any Python list is zero. And the element 
is 1. 
Then, per the image below, we added 3 more elements to our 
dictionary.  
 

The Complete Python Book 
 
225
Per the image below, we can access the number 1 in our dictionary 
as follows (meaning the first element):  
 
The 0:1, 1:2, 2:3 and 3:4 is in this format: key: value 
Per the image below, we can even use strings in our dictionary and 
then call them by entering our key of “0”, which results in a value 
of 1.  
 
We can use the dictionary to access a key of “name” in order to get 
a value of “Luka,” per the image below. 
 
 
 

The Complete Python Book 
 
226
 
 
 
 
 
 
 
 
 
[I/G/A] Dictionary Methods/Functionality 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
227
Per the image below, we have a dictionary called user. We can add 
a key to our dictionary using the first line of code in the image 
below.  
 
We can also change the value of an existing key in a dictionary, per 
the image below:  
 
We can also change the dictionary contents by typing . after the 
dictionary, per the image below (this is called a method):  

The Complete Python Book 
 
228
 
Per the image below, the items method will show us the items in 
the dictionary:  
 
Per the image above we even created a sub dictionary with adress. 
We can even use the keys method to show the keys in our main 
(not our sub) dictionary:  
 

The Complete Python Book 
 
229
In order to access the sub dictionary keys, we would type the 
following:  
 
 
 

The Complete Python Book 
 
230
 
 
 
 
 
 
 
 
 
[I/G/A] Introduction to Sets 
 
 

The Complete Python Book 
 
231
The main difference between lists and sets or other data types is 
that set will make sure that you don't have duplicates inside of it. 
So we are using sets when you need to make sure that it does not 
contain any duplicates. 
Per the image below, set1 does not list the number 1 twice.  
 
We can also use . as we have before to show all the methods for 
the set, and we can add an item using the add method. However, 
it will not add a duplicate.   
. 

The Complete Python Book 
 
232
 
 
 
 
 
 
 
 
 
[I/G/A] Exercise 7.2: Sets 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
233
Please complete the following using the 2 lines of code shown in 
this image:  
 
Step 1 of 1: Find out which storm trooper is to multiple 
groups. 
 
 
 
 

The Complete Python Book 
 
234
 
 
 
 
 
 
 
 
 
[I/G/A] Answer 7.3: Sets 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
235
Here is the answer:  
 
 
 
 

The Complete Python Book 
 
236
 
 
 
 
 
 
 
 
 
[B/I/G/A] Quiz for Level 7 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
237
Please answer the following multiple choice questions. At the end 
of the quiz are the answers.  
1) What is the output is we run the code below? 
data1 =(1,2,3,4) 
data2=[1,2,3,4] 
print(f"{data1} is a {type(data1)} and {data2} is a 
{type(data2)}.") 
a. (1, 2, 3, 4) is a <class 'tuple'> and [1, 2, 3, 4] is a <class 
'list'>.  
b. (1, 2, 3, 4) is a <class 'list'> and [1, 2, 3, 4] is a <class 
'tuple'>.  
 
2) Will the code below result in an error?  
data=(1,2,3,4) 
data.append(5) 
print(data) 
a. No because append will add the number 5 to data. 
b. Yes because data is defined as a tuple, and we can’t 
append with a tuple.   
 
3) Assuming we have a dictionary defined per the line of 
code below, what would we type to print Luke 
Skywalker?? 
character_dictionary 
= 
{"over_confident":"Han 
Solo", "humble":"Luke Skywalker"} 

The Complete Python Book 
 
238
 
a. print(["humble"]) 
b. print(character_dictionary[1]) 
c. print(character_dictionary[:1]) 
d. print(character_dictionary["humble"]) 
 
 
4) What is the output if we run the following code?  
list = [0,0,0,0,1,2,3,4] 
set(list) 
 
a. {0, 0,0,0,1, 2, 3, 4} 
b. {0, 1, 2, 3, 4} 
 
 
Answers:  
1) a 
2) b 
3) d 
4) b 
 
 

The Complete Python Book 
 
239
 
 
 
 
 
 
 
 
[B/I/G/A] LEVEL 8: METHODS 
AND ADVANCED STRINGS 
 
 

The Complete Python Book 
 
240
 
 
 
 
 
 
 
 
 
[B/I/G/A] Intro to Methods and Advanced 
Strings (What, Why and How of Level 8) 
 
 
 
 

The Complete Python Book 
 
241
Welcome to Level 8. In terms of the what, why, and how of Level 8, 
let's kick it off with a what. What will we learn together?  We will 
learn about methods, which are things that we can do to change 
variables, like make a variable uppercase.  We will also learn about 
advanced strings by learning about many methods or things that 
we can do with strings.  
In terms of why. Why should we learn about methods? Because it 
will allow us to change our variables using built in methods.  
Lastly, how? How are we going to learn about methods here in 
Level 8? We'll have several exercises that we'll do together during 
this Level to understand how to use methods to take our code to 
the next Level. In addition to the exercises that we will do together 
during Level eight to learn about methods and advanced strings, at 
the end of Level 8, we will have a quiz to help us reinforce what we 
have learned together.  
 

The Complete Python Book 
 
242
 
 
 
 
 
 
 
[B/I/A] What is a Method and How do Get the 
Methods for An Object? 
 
 

The Complete Python Book 
 
243
Methods are a game changer. You're going to love this Level. Per 
the image below, we can use methods to change an object.  For 
example, we can add dot upper after the name and then select 
upper, in order to change the case to uppercase.  
 
What other methods can we use with our variable called name? Per 
the image below, if we type dir(name) we will see a bunch of things 
we can do to name. For now, please ignore anything with 
underscore,  but if we scroll here, we see the word capitalize, that 
we can also use as a method for name.  
 

The Complete Python Book 
 
244
Per the image below, if we use the method called lower, we can 
make our name lowercase. 
 
 
You'll notice that after the method,  we have brackets. Why do 
these brackets exist?  Some methods you need to put something in 
brackets. For example,  if we use the counts method, we need to 
put in brackets, what we want to count:  

The Complete Python Book 
 
245
 
 
Let's now use the replace method. We need to put 2 things in 
brackets. Why two?  Because we need to replace something with 
something else, which is logical.  Per the image below, let's replace 
the letter y in ray  with  d.   

The Complete Python Book 
 
246
 
 
 

The Complete Python Book 
 
247
 
 
 
 
 
 
 
 
 
[B/I/A] Exercise 8.1: Methods 
 
 

The Complete Python Book 
 
248
Please complete the following:  
Step 1: Create a variable called name and assign to it this: 
C3P0. 
Step 2: On one line of code use the print function and the 
replace method to change the name from C3P0 to R2D2. 
 
 
 
 

The Complete Python Book 
 
249
 
 
 
 
 
 
 
 
 
[B/I/A] Answer 8.1: Methods 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
250
Here is the answer:  
 
 
 
 

The Complete Python Book 
 
251
 
 
 
 
 
 
 
 
 
[B/I/G/A] String Methods 
 
 
 
 

The Complete Python Book 
 
252
Per the image below, let's take a look at the upper method in a little 
bit more detail. We created a name and then we printed it with the 
upper method, and then we printed it without the upper method. 
Please note that name was temporarily changed to uppercase.   
 
Let’s discuss string methods in more detail.  There's lots of methods 
you can use with string. And we know that methods means the 
information that comes after we type . after a variable, per the 
image below. 
 

The Complete Python Book 
 
253
The first method that I want to discuss is called isdigit. Per the 
image below, it says here false meaning the variable name is not a 
digit.  
 
Similarly, per the image below, the method isalpha is true.  
 
Per the image below, the isspace method checks to see if the only 
contents are spaces or a single space and nothing else.  So let's 
replace this contents of name with nothing in quotes.  And let's run 
the code.  We get false because the strings contents does not have 
a space in it. 

The Complete Python Book 
 
254
 
.  
 

The Complete Python Book 
 
255
 
 
 
 
 
 
 
 
 
[B/I/G/A] Exercise 8.2: String Methods 
 
 

The Complete Python Book 
 
256
Please complete the following:  
Step 1: Define a variable as jacks_name and assign it to the 
value Jack 
Step 2: Define another variable called empty_glass_case 
and assign it to one " " 
Step 3: Use the method isalpha with jacks_name and get 
Python to tell us is the result is true or false 
Step 4: Use the method isspace with empty_glass_case and 
get Python to tell us if this is true or false 
 
 
 

The Complete Python Book 
 
257
 
 
 
 
 
 
 
 
 
[B/I/G/A] Answer 8.2: String Methods 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
258
Here is the answer: 
 
 
 

The Complete Python Book 
 
259
 
 
 
 
 
 
 
 
 
[I/G/A] Advanced String Operations 
 
 
 
 

The Complete Python Book 
 
260
In this Chapter, we will talk about 12 more string methods. Let's 
kick it off with split. Per the image below, the split method splits 
the contents of a variable into different parts. On the example 
below the string was converted into a list.  
 
Our next method is splitlines, which looks for \n and then splits the 
text into different lines:  
 
The join method joins together data from variables:  

The Complete Python Book 
 
261
 
The strip method removes leading and trailing spaces:  
 
The rstrip method removes spaces from the end of the variable: 
 
The lstrip method removes spaces from the beginning of the 
variable: 

The Complete Python Book 
 
262
 
The find method tells us where a word or letter is located at for a 
variable. Per the example below, Vader starts in position 6. Recall 
that we start counting at 0 in Python. 
 
The index method is identical to the find method, except if the find 
can’t find the item you are looking for, it gives you an output of -1, 
where the index method provides us with an error:   
 

The Complete Python Book 
 
263
The replace method replaces an item in a variable: 
 
The count method counts how many times text appears in a 
variable:  
 
The startswith method provides us with True or False if our variable 
starts with a specific character or characters:  
 
The endsswith method provides us with True or False if our variable 
ends with a specific character or characters:  

The Complete Python Book 
 
264
 
 
 

The Complete Python Book 
 
265
 
 
 
 
 
 
 
 
 
[I/G/A] Exercise 8.3: Advanced String 
Operations 
 
 

The Complete Python Book 
 
266
Please complete the following:  
Step 1: Create a variable called name1, and assign it a value 
of Princess Leia.  
Use the split method to split Princess and Leia into 2 words 
and then print the results. 
The answer should look like this: ['Princess','Leia'] 
Step 2: Create a variable called name2 and assign it the 
value of Baby Yoda.  
Then use the lstrip method to remove the word Baby from 
his name. Then print the results.   
Step 3: Create a variable called name3 and assign it the 
value of Baby Yoda.  
Then use the replace method to replace the word Baby with 
Master. Then print the results. 
 
 

The Complete Python Book 
 
267
 
 
 
 
 
 
 
 
 
[I/G/A] Answer 8.3: Advanced String 
Operations 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
268
Here is the answer:  
 
 
 
 

The Complete Python Book 
 
269
 
 
 
 
 
 
 
 
 
[B/I/G/A] Quiz for Level 8 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
270
Please answer the following multiple choice questions. At the end 
of the quiz are the answers.  
1) Why do we get an error when using the replace method 
for the variable name in this code? 
name = str(“hi”) 
print(name.Replace() 
a. Because we need to put 2 parameters in 
brackets to tell the method what letter to 
replace.  
b. Because Replace should be lowercase. 
c. Both answers are correct, meaning they 
both highlight issues with the code.   
 
2) What is the output if we run the following code?  
name = “yoda” 
print(name.upper()) 
print(name) 
name.isalpha() 
a. 
Line 1 will show: YODA, Line 2 will show: 
yoda, Line 3 will show: True 
b. 
Line 1 will show: YODA, Line 2 will show: 
YODA, Line 3 will show: True   
c. 
Line 1 will show: YODA, Line 2 will show: 
YODA, Line 3 will show: False   

The Complete Python Book 
 
271
d. 
Line 1 will show: YODA, Line 2 will show: 
yoda, Line 3 will show: False 
 
 
3) What is the output if we run the following code?  
movie 
= 
“Star\nWars\nis\nthe\nbest\nmovie\never!” 
x = movie.splitlines() 
print(x) 
 
a. 
Star\nWars\nis\nthe\nbest\nmovie\never!  
b. 
Star Wars is the best movie ever! 
c. 
StarWarsisthebestmovieever! 
d. 
[‘Star’,  ‘Wars’, ‘is’, ‘the’, ‘best’, ‘movie’, 
‘ever!’] 
 
Answers:  
1) c 
2) a 
3) d 
 
 

The Complete Python Book 
 
272
 
 
 
 
 
 
 
 
[B/I/G/A] LEVEL 9: OBJECT 
ORIENTED PROGRAMMING (OOP) 
& CLASSES 
 
 
 

The Complete Python Book 
 
273
 
 
 
 
 
 
 
 
 
 
[B/I/G/A] Intro to OOP (What, Why and How 
of Level 9) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
274
Welcome to Level 9. In terms of what, why, and how of Level 9, let's 
kick it off with what. What will you learn together?  We will learn 
about object-oriented programming.   
Why should you learn about object-oriented programming and 
classes in object-oriented programming?  Because with classes and 
object-oriented programming, you can create reusable code. 
Think of classes as a kind of a template for your code, for making 
objects. Now this, this will become much clearer as we progress 
through Level 9.   
Lastly, how. How are we going to learn about object-oriented 
programming together here in Level 9?  We will have many 
exercises that we will do together during Level 9 to understand how 
to be much more efficient at programming by leveraging object-
oriented programming.  
In addition to exercises that we will do during Level 9 to learn about 
object-oriented programming, at the end of Level 9, we'll also have 
a quiz to help us reinforce everything that we learned together.   

The Complete Python Book 
 
275
 
 
 
 
 
 
 
 
 
 [B/I/G/A] Understanding Classes and 
Instances 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
276
There are a couple of different types of programming in the world. 
One is functional programming that we've been using so far, where 
basically you define a set of functions, you define a set of rules, and 
then program executes as you define it, from top to the bottom.  
There is something called object-oriented programming.  
Object oriented programming uses something called classes.  
Classes are a blueprints or templates that you're going to create of 
objects in Python.  Now, we've been using this so much in the past 
couple of sections, but we didn't call them just like that. Because in 
Python, everything is defined in classes, background for us, and in 
objects.  
And even variables, when we define them, they're classes of string 
of Integer, floating numbers, and so on.  Now we called something 
functions, something methods, and we are going to discuss what is 
the difference in this very section.  So, instances, or when you 
create and create a copy of this class, is called the instance.  
And that is individual object of this class.  Let's define this together.  
I'll have this class called Dog.  Now, you can put open and close 
brackets. It's optional. I love to put open and close brackets.  And, 
for now, I'll just define Pass.  It will allow us to create this class, but 
we didn't do anything with this.  

The Complete Python Book 
 
277
 
We created just class of this Dog.  Now, we will add more and more 
functionality to this class in upcoming chapters.  Just for your sake, 
we created a class called a dog, and to define that, we called it,  the 
first keyword was class, then we said a dog,  open and close 
brackets, which, as I said, is optional, so you can do without them.  
But I love to do open and close brackets.  And the body of a class 
for now has only one word, which is pass.  Now pass says, don't do 
anything. Just continue executing and there is nothing to see here.  
When you create a class of a dog or anything else, you can go and 
reference it and create variables called instances.  
Every variable unique to itself. When we define a variable that is 
equal to the class, it is called an instance or object of a class, and 
you can create as many as you like.  And you will see the difference 
between them in a second. So, when I execute this, it doesn't seem 
to have a difference at all. Because like when you type it, it’s a dog. 

The Complete Python Book 
 
278
 
And when you type dog one, it’s still a dog. Now, for now, because 
class dog doesn't do anything, we don’t have a way to differentiate 
dog1 versus dog2. But imagine that you can provide a name to it. 
Now, that becomes a more interesting thing.  What we have so far, 
we defined two dogs.  And both are instance of a same class called 
a dog. 
We defined these two instances of the Dog class. Now you can 
define as many as you like. You can define so many that you can't 
even believe.  And in most cases, it's going to be, for example, a 
class of a user. And then you're going to put information such as 
password, username, and stuff like that to contain information 
about the single user. 

The Complete Python Book 
 
279
And when you call user1, then it's going to have that information 
that you like.  Now, let's focus on dogs, for example. Instances are 
unique for itself.  They're unique for themselves, and they don't 
have anything connecting them except being an instance of the 
same class.  And class contains the data for the object and methods 
that, to manipulate that object, or the data in the data.  
I know this sounds really confusing right now, but bear with me. It 
will be everything clear in a couple of chapters.  Let's try to define 
something underneath this class Dog, and not only have a pass.  
When you define a function, so you have a function,  and that 
function,  so I'll just take this apart these are two objects of a dog, 
and we have a class.  
When you define a function as itself, that function is defined as any 
other Python thing, like def, some function, and then you define it.  
But when the function is defined underneath a class, that functions 
become a part of the class and it’s called a method.  So instead of 
calling a function, when you're defining inside of a class, it becomes 
a method.  
Method is nothing more than a function as a part of a class. Now, 
we know so many methods at this stage.  When we talked about 
strings, we called so many of this, if you remember.  So, all of this 
is method,  or methods that is containing in class called String.  So 
in Python, when we defined a variable of a String, it’s actually 
calling a class  called String.  
So that's helping us to understand that this has so many methods 
inside of that class.  Now let's define the first method called the 
__init__.  

The Complete Python Book 
 
280
And you're defining the same way. We are going to just define 
print.  Hey I am a dog.  
 
Now, let's talk about the self-keyword in more detail.  Self-word is 
a reference to the current object of instance. So, instance of a class 
is this. So, within our methods, If you want to access some variables 
form our class in general, within our method, you always need to 
call self-dot something.  
 

The Complete Python Book 
 
281
Self-keyword allows us to access within and or after the reference 
and variables and everything that we're going to define within our 
class. Additionally, it needs to be the first parameter of any method 
that we define in a class. We'll demonstrate this in more detail 
through code. 
 
If you want to call, for example, walk or bark, and you don’t have 
this self as a first keyword, it wouldn't work.  So self as it tells It’s 
not reserved keyword, so you can name it whatever you want. But 
it's a convention that everybody's using this self. Now, in other 
programming languages, the self keyword is mostly called “this.” 

The Complete Python Book 
 
282
 
Self refers to instance itself, so it is used to access instance 
attributes and methods. Now, what if I want to access the name 
from Bark and say, this dog, John, or let's change it to Rose, and 
let's change this to Cutie.  
 

The Complete Python Book 
 
283
Now we have two dogs called Rose and Cutie. And I want, when 
somebody calls Bark, I want to say, Rose says, Woof. So right here, 
what we can do, we can go and say name plus says, or we can use 
this, says poof.  Now, it already underscores that and says it's not 
defined. 
 
But how is not defined? We define it right here.  that's why because 
we didn't define it on the class Level, we define it only on the 
function Level. So we need to define self-dot name is equal to 
name.  Now you can, you don't have to name it in the same way. 
Of course, you can name this, whatever, dog's name.  

The Complete Python Book 
 
284
 
Now, this is what we provide when we define a class.  And this bark 
needs to define dog's name.  But it's still underscored.  Why is that 
we just put itself in front of it? Always when you're defining it, you 
need to put self. So self, which means Dog, the class we are 
creating, dot whatever we define inside of it.  

The Complete Python Book 
 
285
 
So here we defined self.dogs_name, which can be accessed from 
anywhere in, within the class.  So if you go to Dog, And see this dot,  
you will have two things bark, which is our method and dog's name, 
which now returns or checks our dog's name because this is what 
we defined with this self. 

The Complete Python Book 
 
286
 
Self, as we defined it previously, allows you to access this 
information within  the class and outside with their objects.  So now 
that you define here, I want, I would like to, I would like to provide 
one more information to you. Let's define another method, which 
we'll be calling walk.  And we know that self is a keyword where we 
need to define as a first time always.  

The Complete Python Book 
 
287
 
And here I'm going to just print out self-dot dog's name is walking 
towards, and then we need some address or location. better 
location.  Now this location is not defined. We don't have any 
location in this class. So, what you can do, you can provide a 
location as an argument to the method  and call it from inside. 
 

The Complete Python Book 
 
288
As a first argument we have self, which is the must for class itself. 
But then location is for that method alone. So now we can use that 
location inside of this method.  However, you can't access this 
location within the other parts of our class, because it is only 
defined right here.  
 
Because we didn't have this self.  But location is equal to location. 
And if we did this, we could have accessed it from other parts of 
class, but we don't want that. We just need that information in the 
walk.  So now when I call bark, it still works. But now when I go and 
say dog one dot walk, and now if I call it like this, it will say, Oh, 
location is missing. 

The Complete Python Book 
 
289
 
So, I'll just provide the park as our location.  
 
And now Rose is walking towards the park or towards center. of a 
city.  

The Complete Python Book 
 
290
 
 
  
 

The Complete Python Book 
 
291
 
 
 
 
 
 
 
 
 
[B/I/G/A] Exercise 9.1: Creating Your First 
Class and Instance 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
292
Please complete the following:  
Step 1: Use the class keyword and then type the name of 
your class that you are going to define. Please use a person's 
name. 
 
Step 2: Use the init constructor to create the initial behavior 
of this person. This person needs 2 pieces of information. 1 
is the name and 2 is the age.  
 
Step 3: Print the 2 pieces of information. 
 
 
 

The Complete Python Book 
 
293
 
 
 
 
 
 
 
 
 
[B/I/G/A] Answer 9.1: Creating Your First Class 
and Instance 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
294
Here is the answer:  
 
 
 
 

The Complete Python Book 
 
295
 
 
 
 
 
 
 
 
 
[B/I/G/A] Defining Methods in a Class 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
296
We talked about classes and their relationship with methods or 
functions. When you define any function underneath a class, it 
becomes a method. It functions the same way, but we are referring 
to it as a method because it helps class to work or behave in a 
certain way.  So, methods are functions that are defined within a 
class.  
They're used to define behaviors for objects or objects of a class. 
for, from a different perspective. And methods always take at least 
one argument. So self, which we talked about, which refers to the 
object of instance, and they can be accessed and modify object 
state and class state.  So, I know this sounds all new and that's cool 
because we are learning.  
 
Let's define a certain method within a dog class. Now, what dog can 
do? It can walk, it can swim, it can bark. Let's define, for example, 
for bark. And that's going to be a bark method.  And underneath it, 
I'm going to define print statement that is going to be woof.  So 

The Complete Python Book 
 
297
when I do this and define my dogs, now, when I do this,  You'll see 
bark.  
 
However, if we just call it we will get an error. This is happening 
because we didn't provide anything inside of it.  And that's the rule. 
Yes, in the next Chapter, we'll talk about more about self-keyword.  
Just for your information, whenever you define some method 
inside your class, always use self.  

The Complete Python Book 
 
298
 
This self makes sure that it can be reached by the objects dog1 and 
dog2 of our class.  When I exit again, I can go and call it, and now it 
works.  How amazing is that? Let's answer with a dog2 with a bark.  
And yes, our dog2 barks as well.  
 

The Complete Python Book 
 
299
 
 
 
 
 
 
 
 
 
 
 
[I/G/A] Class Attributes Versus Instance 
Attributes 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
300
 
Class attributes are defined directly within the class and shared 
across all instances. These two are instances of that class. So 
objects are instances of the Dog calss. We have two dogs 
(instances) created, and we can have as many as you like, but  each 
of the dog has some unique features, which is called instance 
attributes, like name.  
For example, we defined location for the walk function, these are 
method-based variables/arguments. But you can define something 
on top of everything in a doc and say, for example, how many legs? 
Four. In general, they have four legs. Whatever amount of dogs you 
define, they're by default going to have four legs. 
And that's going to be a class attribute, because that is a dog in 
general.  But instance attributes are unique to these instances of 
this class. Like name, age, gender.  Class attributes are accessed 
using the class name. While instance attributes are used by using 
self and changing class attributes affect all instances while changing 
an instance attribute only affect that dog or that instance 
individually. 
Let's see how to do that with our, within our class. And we can 
change it afterwards, of course.  So, what I did here, I define inside 
the class itself a variable called number_of_legs. I didn't change 
anything below. And now when I do this, what I can do is call dog 
one dot number of legs. 

The Complete Python Book 
 
301
 
And this number of legs is four. Now, I can't change it from our dog 
number one, because that is on a class Level here on a dog.  Now, 
if you go and change this to and get this information for the dog 
number two, it will be four again.   
 

The Complete Python Book 
 
302
For example, if you have a, instead of a dog, you can use this type 
of attribute to define dog type - golden retriever.  
 
 

The Complete Python Book 
 
303
 
 
 
 
 
 
 
 
 
[I/G/A] Exercise 9.2: Classes, Instances and 
Attributes 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
304
Please complete the exercise:  
Step 1: Define a class called car. 
Step 2: Define a class attribute called wheels. 
Step 3: In the constructor define 1: maker of the car and 2: 
model of the car 
Step 4: Print the name and how many wheels there are. 
 
 

The Complete Python Book 
 
305
 
 
 
 
 
 
 
 
 
[I/G/A] Answer 9.2: Classes, Instances and 
Attributes 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
306
Here is the answer: 
 
 
 

The Complete Python Book 
 
307
 
 
 
 
 
 
 
 
 
[I/G/A] Inheritance: Extending Functionality 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
308
When we speak about object-oriented programming, the first 
concept that we need to learn is class.  Additionally, we have some 
functionality, such as constructor, we have class Level or instance 
Level attributes.  Now, sometimes you don't want to have all the 
functionality inside of one class. 
You would like to have main class, for example, a vehicle, while you 
have a subclass called a car, a truck, or something else. And then 
you define most of the stuff in vehicle, and then unique stuff to a 
car, in a car class, and unique stuff to the truck class. So, you don't 
have to define everything under one class. 
Inheritance allows a class to inherit methods and attributes from 
the top class. So, if our top class is a vehicle and underneath, we 
have a car or a truck, that car and a truck will inherit all of the 
information from the car class. 
The new class called a subclass, which is a car, gets all the 
capabilities of the existing class.  termed as a super class.  And we 
can add or override some methods and attributes. We don't have 
to get all the information. We are going to get it, but we don't have 
to stay with it. We can change it as we need or want.  
Inheritance promotes code reuse and establishes a relationship 
between the superclass and subclass using the class keywords, 
followed by a subclass name, then the superclass name in a 
parental parenthesis to define a subclass.  

The Complete Python Book 
 
309
 
Now, how to do that? When you define this car, in these brackets 
provide the top class, which is Vehicle. And this is it.  And I'm just 
going to put pass under the Car class. So, we don't have any 
information in this car.  Create an instance of the Car class and 
suddenly the car has one thing connected to it called start_engine.  

The Complete Python Book 
 
310
 
We have the start_engine that came from the top class, Vehicle. 
This is inheritance. Now let's practice this in more detail. Let's 
define a class called truck.  This truck will have vehicle as a top class.  
Additionally, create a constructor for the Truck class. 
 

The Complete Python Book 
 
311
Print “IM A TRUCK” in its constructor.  Truck also has this start 
engine due to the  top class.   
 
Since we added a new method to Vehicle, all sub classes will get it 
as well. h 

The Complete Python Book 
 
312
 
 
Instead of always using base methods from the top class (such as 
start_engine), we can define a specific version for each sub-class. 
For example, in the Truck class, we can write: Truck engine roars 
for life.  

The Complete Python Book 
 
313
 
So now when I call this, I have this new message, truck engine roars 
for life. And this is called overriding.  Now we have the main class, 
the sub superclass, and we put all of that information inside of our 
car and the truck. But if you define the method, underneath that 
subclass with the same name, it will override its behavior from the 
superclass. 

The Complete Python Book 
 
314
 
We worked with the dog class before. So maybe use this as a super 
class and then define your classes like golden retriever as a kind of 
a subclass. 
 

The Complete Python Book 
 
315
 
 
 
 
 
 
 
 
 
[I/G/A] Encapsulation: Hiding Information 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
316
Encapsulation involves hiding the internal state of an object and 
requiring all interactions to be performed through methods.  
Encapsulation restricts access to certain attributes, or methods 
making them private or protected.  This helps in preventing 
accidental modification of internal data, or just object integrity as 
it is. 
Use a single or double underscore to denotate protected or private 
attributes because Python as itself doesn't have that option by 
default. And creating public methods to prevent controlled access 
to these attributes. So let's make a class called Bank. account.  At 
this bank account we'll have our constructor, which is in it, balance.  
 
Now we, when we create an account, we want to have some 
balance, and this balance will be private. When a method starts 
with an underscore, it means that we are working with a private 
method. For example init, we never call a bank account dot init, 

The Complete Python Book 
 
317
we're just calling a bank account, and by default it will happen.  So 
this init will have balance specified inside of it. 
 
Now, this balance can be accessed through outside of the class, but 
it will denotate to users that it is a private one because this has 
underscore in front of it. So after that, we can go and define deposit 
and this will go and say amount.   And this amount will go in self.  

The Complete Python Book 
 
318
 
balance plus equal to amount.  Then we can go and define 
getBalance.  with only self as an argument.  And we are going to 
return self.  balance.  Now you can see this pattern because we are 
never accessing that information or balance through directly 
getting the balance information. If you want to see the balance, 
you're going to get getBalance.  

The Complete Python Book 
 
319
 
If you want to deposit something to the balance, you're going to 
call the deposit and stuff like that. So if I want to create an account, 
I'm going to say account equal to bankAccount with 100.  And then 
I'm going to deposit another 50 to it.  And now I suppose I should 
have 150.   

The Complete Python Book 
 
320
 
This is encapsulation in the nutshell. Even if you try to access it like 
the account, and then you have underscore balance, it will tell you 
that it doesn't have balances as an attribute. 
 
The way to access its value is through method called get_balance.  

The Complete Python Book 
 
321
 
 
 

The Complete Python Book 
 
322
 
 
 
 
 
 
 
 
 
[I/G/A] Exercise 9.3: Implementing 
Encapsulation 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
323
Please complete the following:  
Step 1: In cell A1 type Jack 
Step 2: In cell A2 type Rose 
Step 3: Using Python code in Excel, in cell A10 define 2 variables. One is 
name1 and the other is name2. Assign the name Rose to name1 and 
assign the name Jack to name2 by referencing what you typed in cells 
A1 (meaning Jack) and A2 (meaning Rose). 
Step 4*: In cell A11 use Python code to write this: Rose should have 
given Jack a lifesaver and not a lightsaber.  
*For Step 4, please make sure to reference the variables Jack and Rose 
meaning name1 and name 2.  
 
 
 
 

The Complete Python Book 
 
324
 
 
 
 
 
 
 
 
 
[I/G/A] Answer 9.3: Implementing 
Encapsulation 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
325
Here is the answer:  
 
 
 
 

The Complete Python Book 
 
326
 
 
 
 
 
 
 
 
 
[I/G/A] Understanding Magic Dunder 
Methods 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
327
If you ever called a the method on something like this, and you 
would be able potentially to see a lot of those underscore 
something  underscore methods.  Now we've been using one which 
is called init and that was is indeed magical because allows us 
immediately when we define an object of or of an instance of a 
book to call everything in here and set it up for us.   
 
That's why it's called magic or Dunder method. Now it allows us to 
work with certain behavior that is built in function. An amazing 
thing about that we can over override its behavior. So magic 
methods, also known as a Dunder method, are special methods in 
Python with double underscores at the beginning and at the end. 
For example, we have init, we have string, add, and so on. Let me 
demonstrate this to you. I'm going to define a class called book. It 
will accept two arguments title and author as a part of its 
constructor.  

The Complete Python Book 
 
328
 
Now, when you add underscores after your object, you will get all 
the magic methods that you have by default. For example, we have 
hash format. dir, dict, and so on.  
 

The Complete Python Book 
 
329
Now, what will happen if I go and print out this book?  It will tell me 
that, this is a method of a book, or object of a book,  with some 
number.  Now, I don't really want that. When I print this book, I 
want it to say this is the book with this title, by the author of this. 
To achieve this, define str underscore and we are going to provide 
here return statement that's going to be self-dot title plus by and 
then plus self-dot  self.author.  When we execute the print of the 
book again, it will be in the format we wanted.  

The Complete Python Book 
 
330
 
Let’s experiment now with another class called Number. We are 
going to define a value and this value will be self. value.  And when 
I define an instance of the number with the value of 1000, I want 
to be able to perform computation on top of it, such as addition. 
But  when I try to call add the number with 10, it will throw an error, 
telling us that I can't support number object and init. 

The Complete Python Book 
 
331
 
To solve this, we will define __add__ magic method.  And this add 
We'll get a value, and this value will be returning self. value, plus, 
new_number which is an argument of this function.  
 
 And if I execute this, now it works.  

The Complete Python Book 
 
332
 
And that's why it's called magic because now Python will know 
what to do with inside of this class.  So right now, if I go and say, 
okay, cool, is this equal to whatever? Now you can add it. 
 

The Complete Python Book 
 
333
You can add directly to the value inside of the number that we 
defined.  You can do more than that. You can go number equal. to 
1000.  Of course, it's going to be false, because this number is a 
class.  And when we compare it to itself, it's going to be true. But 
when we compare it to 1000, and when I get number dot value,  of 
course, it's 1000. 
 
To solve this there is a method for that, which is called EQ, which 
gets some new number as an input and return self dot value equal 
to the new number.  

The Complete Python Book 
 
334
 
So now when I execute this, now it's true.  Okay, if I change it to 
number one, one thousand and one, it won't be true anymore.  
 

The Complete Python Book 
 
335
When you define just the number equal to ten,  this is actually a 
class inside of a Python. 
 
And whenever we call some operators on top of these numbers, 
they call magic functions in the background. 

The Complete Python Book 
 
336
 
 
 

The Complete Python Book 
 
337
 
 
 
 
 
 
 
 
 
[G/A] Understanding Composition and 
Aggregation 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
338
Let's talk about another way to create a relationship between 
classes. Now, we talked about one of the ways, which is 
inheritance. Now, and this way is called composition. Composition 
allows you to create basically One class in, inside of another, an 
instance of that class inside of another instance, which is a bit weird 
and that is creating a layer of a class  under class and so on.  
I have here a class called engine that has only one method called 
start. And when you call this start method, it will be print engine 
star. Now, you can go and inherit this, but car is not a type of an 
engine, so it doesn't make sense. So, if you had a vehicle, that 
would make sense. But in this case, you need composition, which 
is another way to create a relationship between these two classes.  
 
So how to do that under underneath this.  This method I'm going 
to or constructor. I'm going to define engine and that's going to 
have or be the type of engine class, which is this one right here, and 
this is called composition.  

The Complete Python Book 
 
339
 
What's happening right now when I define a car inside of this in it.  
method or constructor, the engine will call this class and create an 
instance of it inside of this. So what I can do, I can go and say car 
engine start and this start engine started will call this. So because 
this engine, which is this car dot engine and then this engine has 
this start method, which is this one, because it is an instance of the 
class called engine.  

The Complete Python Book 
 
340
 
Now, this helps you tremendously when you can create a direct 
relationship with inheritance, but you need to create some kind of 
relationship, which is in this case composition, using it to create, 
basically, a way to enhance some functionality inside one class by 
using another one.  
 

The Complete Python Book 
 
341
 
 
 
 
 
 
 
 
 
[B/I/G/A] Quiz for Level 9 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
342
Please answer the following multiple choice questions. At the end 
of the quiz are the answers.  
1) What is the purpose of the self keyword in Python classes? 
 
a.  To refer to the global variables of the module. 
b.  To declare static methods. 
c.  To reference the instance of the class on which a 
method is called. 
d. To import methods from parent classes. 
 
2) Which of the following Is true about class attributes in 
Python? 
 
a. They are unique to each instance of the class. 
b. They are shared across all instances of the class. 
c. They cannot be accessed by class methods. 
d. They are created inside methods. 
 
 
3) What does encapsulation refer to in OOP? 
 
a. The practice of restricting access to methods and 
variables to prevent data from being modified 
directly. 
b.  They ability of a class to inherit properties from 
another class. 
c.  The process of creating new instances of a class. 
d. The concept of breaking a program into smaller 
parts. 

The Complete Python Book 
 
343
 
 
4) What is the main advantage of inheritance in OOP? 
 
a.  It allows classes to be instantiated. 
b.  It provides a way for a class to use all the methods 
and properties of another class. 
c.  It prevents classes from using methods of other 
classes. 
d.  It restricts the access to methods so they can’t be 
overridden. 
 
5) Which of the following best describes ‘magic dunder 
methods’ in Python? 
 
a.  They are methods that start and end with a double 
underscore and are not meant to be invoked directly 
by you, but by Python internally. 
b.  They are the methods used to encapsulate data 
within a class. 
c. They are used to perform arithmetic operations like 
addition and subtraction of custom objects.  
d.  They are special methods used to initialize 
modules. 
Answers:  
1)  C – To reference the instance of the class on which a method is 
called. 
2) B – They are shared across all instances of the class. 

The Complete Python Book 
 
344
3) A – The practice of restricting access to methods and variables 
to prevent data from being modified directly. 
4) B – It provides a way for a class to use all the methods and 
properties of another class. 
5) A – They are methods that start and end with a double 
underscore and are not meant to be invoked directly by you, but 
by Python internally. 
 
 

The Complete Python Book 
 
345
 
 
 
 
 
 
 
 
[I/G/A] LEVEL 10 MASTERING 
NUMPY (NUMERICAL PYTHON) 
 
 
 

The Complete Python Book 
 
346
 
 
 
 
 
 
 
 
 
 
[I/G/A] Intro to NumPy (What, Why and How 
of Level 10)  
 
 
 
 
 
 
 
 

The Complete Python Book 
 
347
Welcome to Level 10. In terms of what, why, and how of Level 10, 
let's kick it off with the what. What we learned together.  In Python, 
creating arrays, meaning groups of data, is great. But it can be a 
slow process. We will learn about importing something called 
Numerical Python, which is also called NumPy.  
Why should we learn about NumPy? Because NumPy is so much 
faster than just regular Python to analyze the data in arrays.   
Lastly, how? How are we going to learn about NumPy together here 
in Level 10?  We'll have exercises that we'll do together during Level 
10 in order to understand how to install and use NumPy in order to 
take our data analysis skill set to the next Level.  
In addition to all the exercises that we'll do during the Level 10 to 
learn NumPy, at the end of Level 10 you will have the quiz to help 
us reinforce what we have learned together. 
 
 

The Complete Python Book 
 
348
 
 
 
 
 
 
 
 
 
[I/G/A] Libraries Explained and Installing 
NumPy 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
349
Resources for this Chapter: 
Mac NumPy Installation: 
https://www.youtube.com/watch?v=RFeIn2ywxG4&t=292s&ab_chan
nel=DaveEbbelaar  
Windows NumPy Installation: 
https://www.youtube.com/watch?v=itVBw_rNYjI&ab_channel=Geeky
Script  
Linux NumPy Installation: https://www.youtube.com/watch?v=7-
naqq9fvZE&ab_channel=ProgrammingKnowledge  
So far, we have been using Normal Python normal, the pure 
Python, without any extra help.  That is not a real power of Python. 
Python became really powerful when the community started 
gathering around it. And then everybody, for companies, 
individuals, open-source developers, started making a lot of nice 
stuff around it, which we call libraries.  
And that's where lies the real power of Python. For everything that 
you can imagine, we have a library that will help us.  Some of those 
are the most popular ones, such as NumPy that we are going to 
cover in this section. We have Pandas, Polars, Matplotlib, SQL, 
everything to help your data science journey feel smooth and easy.  
In this part of the book, we're going to cover the two most 
important NumPy in this section and the next one Pandas and 
Polars, which will unlock the opportunity for you to work with files.   
When you install Python, you will get some of the libraries like 
working with dates. However, NumPy is not in that scenario. So we 
will need to install it before you start working with it.  And the 
installation on numpy, it really depends on the platform that you're 

The Complete Python Book 
 
350
using. And if you install something locally, like Anaconda, you get 
everything ready for you. 
Additionally, If you are using Google Colab, you won’t have to 
worry about these libraries. Everything is prepackaged for you.  
Before you can work with any library in Python, you need to import 
it before. To import a library in Python, you will write import. And 
now you can select which library you want to import. In our case, 
it's going to be NumPy.  You can leave it as is. And whenever you 
call something from NumPy, you will refer it always by name.  
NumPy dot a function you want to use. But imagine that you're 
going to call this NumPy for, 200 times in your code. That's 200 
times that you need to write NumPy.  
 
To shorten your suffering here you can shorten the name that 
you're going to refer to this library. And to do that, you can use a, 
as, or as, and then put something that you can refer back in your 
code. In tradition to NumPy, it's np.  You don't have to follow this, 
but wherever you start looking for through others codes, for 
example, on GitHub, you will always see as NP when somebody 
refers to NumPy.  
 
And when I import it, it's going to be there.  Now, wherever I type 
something like NP dot, it will showcase everything that can be done 
with NumPy. And there is quite a lot of stuff.  But let's not jump 
straight to NumPy.  We work with lists. for quite a long time now. 

The Complete Python Book 
 
351
And when you define a list, let's say like this, it's a simple list.  You 
can print out the list, you can access an element, let's say an 
element on index one, and even you can go and slice it up and say 
I want elements from two to index four,  which is amazing, right? 
So, you can access the sub part of this list. You can even access the 
individual element. 
 
You can change the element. You can append. You can do all great 
stuff with normal Python lists.  But then why do we need a NumPy 
for doing much more than that?  Imagine that we want to add one 
to every single element in this. Python list. This becomes 2, 3, 4, 5, 
and 6. What if I try to add 1 to all of the elements? It fails. 

The Complete Python Book 
 
352
 
Pure Python lists consider this to be concatenation. So if I provide 
it in a form of a list, it will work.   
 

The Complete Python Book 
 
353
To achieve what we initially wanted – i.e. adding 1 to all elements, 
will require us to go through the list with a for or a while loop ad 
add 1 to each element individually. 
 
However, you can see that this becomes really slow when you have 
a list of thousands of elements or, I don't know, millions 
sometimes. And even if there is a sub list, you have to have two for 
loops. to go through one and another one inside of it, which 
becomes really impractical really fast.  So to overcome this and 
many more problems that Python lists have inside of them, we'll 
have a NumPy list.  
And it’s really simple to define.  You will start with np, which if you 
recognize this, it's the way that we recognized in above. Then we 
will start writing array.  So lists in NumPys are considered arrays 
and we will do the same thing. One, two, three, four, and five.  Once 
I do that, I'll have my NumPy array defined.  

The Complete Python Book 
 
354
 
As you can see right here, it’s no longer a simple list, but it has this 
array key around it. And even though you have these values, you 
can go and type of A and B. And then it's going to show, showcase 
that it's NumPy n dimensional array, which stands this np, n 
dimensional.   And yeah, so let's access the first element like we did 
before.  

The Complete Python Book 
 
355
 
 
So let me try to do what we wanted to do before, just add one on 
top of it. And like a magic, it works. I can add one, I can multiply it 
by two, I can do all sorts of multiplication and addition on top of it. 
So that's the real power of NumPy. In a split of a second, it will allow 
you to do all the multiplication and mathematical operations on top 
of your NumPy arrays.  

The Complete Python Book 
 
356
 
This becomes really useful when you start working with huge 
amounts of data. In most cases those data sets will be stored in 
some kinds of NumPy arrays. And then you want to filter out 
something, you want to remove something, you want to add one, 
for example, to every single element of that data set.  

The Complete Python Book 
 
357
 
And I'll define 2d array (a matrix): 
 

The Complete Python Book 
 
358
No matter the size or shape of your arrays everything will work the 
same (all operations as we tested before). Additionally, if you want 
you can access a specific part of the array and perform these 
operations only on that part. 
 
You can see this how useful NumPy can be on a larger scale. And 
trust me, while we go together through this whole section, you will 
learn a lot of great stuff about NumPy, how to create a lot of big 
arrays, how to handle them, how to vectorize even functions. So 
you don't have to wait for minutes or hours to execute, you can do 
it in a split of a second. 
 And since the NumPy array allows us to call a lot of properties on 
top of it, which traditional Python does not have, and let me 
showcase that. So if I go to 2D and call a dot, now you can see  a 
huge list of everything that you can do. On top of this array through, 
for example, arg max, what is the maximum argument or what is 
the maximum value inside this array minimum value, then you can 

The Complete Python Book 
 
359
sort all sorts of like you can sort all the indices in this in this array 
based on, for example, size. 
 
Then you can clip, for example, everything above four will become 
four, and so on. You can fill, flat, we'll talk about all of that.  Okay, 
now, one thing that we didn't have in traditional list is actually 
checking the shape, or if you wanted to go in this list before A and 
call something like this, it doesn't work.  
But you had this. A of len, or len of A, which will just tell us how 
many elements are there. But if we had two different lists inside of 
a list, this will just showcase generally number of those sublists. So, 
this len does not scale as we go deeper in the number of different 
dimensions.  Array in NumPy have the function called shape and 
this shape will tell you exactly how many elements you have on the 
top and how many of those you have inside of this or each of these 
sub arrays and it becomes really useful. 

The Complete Python Book 
 
360
 
You can call size which is actually number of all elements and so on.   
There is a third option, which is  ndim.  And ndim will give you two 
because you have two by two, or in this case, three by three.  In 
most computer vision applications, you, when you load an image 
inside your application, it's going to become an array, exactly 
NumPy array. 

The Complete Python Book 
 
361
 
 
 
 

The Complete Python Book 
 
362
 
 
 
 
 
 
 
 
 
[I/G/A] Arrays Data Type 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
363
In traditional Python, we worked a lot with different data types, 
and we said there is integers, floats, strings.  even lists, dictionaries, 
and other, there are many data types that we can use and in 
different ways using Python. And that becomes a really crucial 
element of NumPy as well. So I have here imported my NumPy 
library and just a pure array with numbers from one to five, and if 
use this a dtype on top of it we will get int64. 
 
By default, if this has only integer inside of it, it'll be int64. Now, so 
far, we know that we used integer, but we didn't have different 
types of integers, such as int64, 32, 16, 8, and so on.  The difference 
is how many different numbers we can store inside of this. If you 
have for example, int of 8, you will have a much smaller pool of 
numbers that you can store instead of int64. 
And by nature, int64 will take the most space inside your RAM 
memory. Now, don't worry about that. You won't optimize on that 
Level just yet. But just to know, if you have int in any of those 

The Complete Python Book 
 
364
numbers behind it, it's only the integer. So whatever you use, int 
32, 64, it's going to be completely But that becomes a bit of a 
problem. 
 
When you have something like this, it's from the last video, where 
you have 1, 2, 3, 4, 5, 6, and so on. And I can do the same and call 
this, on top of this, the type. It's still going to show in 64.  But 
because it has the option to change any value inside of it, we can 
go and set it to hello.  And instead of 5, we have hello. 

The Complete Python Book 
 
365
 
As you can see, Array still works, but then it becomes a bit unclear 
what this data type actually stands for. Because this means an 
object, so because it's ununified, sometimes you will have integers, 
sometimes strings, it can't be determined generally what is the 
data type. So, it means that you have multiple data types inside of 
it.  

The Complete Python Book 
 
366
 
But if you go to, for example, zero and then type data type, it's still 
going to be or if you go to the individual Level, it becomes much 
clearer.  Okay, so that is helping us to determine or try to help us 
to determine whether or not there is a unified or ununified set of 
data types inside of our library. 

The Complete Python Book 
 
367
 
But let's copy this and paste it again right here. Now, when you 
define a NumPy array. You can set a lot of different things, as you 
can see right here.  I know that their documentation does not look 
pretty, but it's quite useful. When you use, start using NumPy in 
more and more use cases down the line, you will find that their 
documentation, not right here, but on their website, is well 
defined.  

The Complete Python Book 
 
368
 
While defining arrays, we can explicitly specify what dtype we 
want. We can choose anything and let's say 32.  It will break 
because it will define and say, oh,  sorry for that, but hello is 
something that I cannot convert or cast into integer. 

The Complete Python Book 
 
369
 
The same goes for normal Python. So if you call this int on top of 
hello, it will throw the same error.  Now this error is actually quite 
useful because it tells us which element is causing our error to, to 
pop up. That is the reason behind it. You can try even to float 32 
and it will still show the same error. 

The Complete Python Book 
 
370
 
But now, imagine that this has 10 different columns, and each 
column has thousands of elements.  Do you really need to go 
through every single element and change it to something else? Not 
really. There are many mechanisms that we are going to do and use 
to help us achieve just that. If you wanted to do that by hand, you 
don't really need NumPy.  
But if you want to convert something that is convertible, NumPy 
will handle that for us. And as you can see right here, when you 
visualize the NumPy array again, everything becomes the floating-
point number as we tried to define it right here.  This is the magic 
of NumPy. When you want and can convert every single item to 
some value, it will be done for you. 

The Complete Python Book 
 
371
 
 
 
 

The Complete Python Book 
 
372
 
 
 
 
 
 
 
 
 
 [I/G/A] NumPy Array Creation Methods 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
373
When creating NumPy arrays, there are a couple of options that we 
can use to create those arrays with a specific value or values. This 
can be quite useful in many cases when You are building some 
pipelines or trying to vectorize your data. Let’s jump to a couple of 
examples and then discuss use case by use case while we go 
through it.  
The first method that I want to show you is an np.  full, where I will 
say np. full. And when you open the brackets, it will tell you, okay, 
return a new array of a given shape and type. Okay, cool. Looking 
for this weird set of variables or arguments that you can provide to 
it. The first one is shape.  
What is the shape of the newly created array?  And that should be 
a tuple, as you can see right here. It's always two by three, if you 
want different sizes. Now, if you want two by two, you can only 
provide the two.  And in that case doesn't have to be a topple, but 

The Complete Python Book 
 
374
it's always going to be symmetrical. Five by five, two by two, 10 by 
10, and so on.  
But now when you created that shape or RA with a.  You need some 
value to put on top of it. And that is the second argument that we 
need to provide, which is called Feel value.  Feel value, accept any 
value. And that's going to take that and define the data type as we 
discussed in the previous Chapter of that particular value.  
 

The Complete Python Book 
 
375
 
Now, where would somebody use this?  The short answer is 
creating dummy data.  In most cases when analyzing data sets you. 
You may need to create some kind of array filled with a consistent 
value to serve as a control group or a comparison. For instance, if 
you are A B testing two different strategies, you might use an array 
of constant values to represent the baseline strategy.  
Padding sequences in time series analysis is another use case 
where this comes in really handy. In financial, for example, or sales 
time series data, you might encounter sequences of different 
lengths. Padding these sequences with a default value, for 
example, zero, or none, or unknown value, makes them easier to 
analyze consistently. 
You can make a apply some algorithm on top of it that works with 
consistent amount of data every single time.  These are just a 
couple of examples that we can go about and use. Now, another 

The Complete Python Book 
 
376
one which is quite useful is allocating portfolio weights. In finance, 
you might want to start with an equally weighted portfolio. 
And portfolio might be an action or a stock that you will invest in. 
When back testing different investment strategies, you want to use 
different, for example, weighting strategies as well. Using np. full 
makes it easy to create an array where each element represents an 
equal proportion of the portfolio.  
The other strategies of creating NumPy arrays might be np. ones or 
np. zeros. These are working the same way, but generally speaking, 
the only difference is the amount or the number that is going to be 
generated. For example, ones, and then we call ones like this. And 
here, you want to define shape, so it's going to be four by four.  
 
And let's copy this with zeros.  And instead of ones, I'm going to 
define zeros right here.  Both work the same way. But the ones 
allows you to, for example, multiply it by some number. And then, 

The Complete Python Book 
 
377
let's say, six.  And in this case, it works basically the same as we 
have with np. full. But instead of providing two different 
arguments, you're just going to do this.  
 
It can be in line, like this. So, you don't have to split into two 
different operations as well.  Now, this is an interesting trick often 
used in data ETL, which is extract, transform, and load. And it's 
creating one and multiplying by some other numbers so that you 
can get a tensor or array of those numbers instead.  

The Complete Python Book 
 
378
 
Similar to Python range functions, this arange is another one that 
can be used to generate an numpy array. The arange function 
accepts a couple of arguments. Starting point, ending point, and 
step size.  It's basically the same order as the Python’s normally 
range function we used for for-loops. 

The Complete Python Book 
 
379
 
If I start with 10 and then provide 100, it will tell you that I'm in this 
second version of this function with a start, start number, stopping 
number, and we don't have to provide, but we can, a step between. 
When you go to documents, it will tell you that,  for example, like 
this, it will tell you that  start is included.  

The Complete Python Book 
 
380
 
But stop is not included. So, make sure that if you want to include 
100 as well, go with 101 and then use that. So that's going to make 
sure that it's going to be included as well. Okay, so that's a thing 
that you need to think about while using these kinds of functions.  
The other way that we can generate data instead of Some range is 
with lean space.  

The Complete Python Book 
 
381
 
 
 
 

The Complete Python Book 
 
382
 
 
 
 
 
 
 
 
 
[I/G/A] Operations with Arrays 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
383
Resources for this Chapter: 
Colab Resource: Broadcasting NumPy: 
https://colab.research.google.com/drive/1mU_aPZ4-
jRSv6L13APCCXBQcZYVdaQIH?usp=sharing  
Starting from this Chapter to the end of this section, for every single 
Chapter, we will have a separate Google Colab kind of a template 
file provided for you. You can simply go to the resources of this 
Chapter and there. For every single Chapter in the future and find  
the Google template file that you can just open with your account, 
create a copy and start working with it.  
Today, we are going to start by using some operations on top of our 
NumPy arrays. And then we'll switch to something we call 
broadcasting. We'll jump to that in a bit. So here I have two, just 
normal Python arrays. One is L1. L two. Just note, I just use Python 
arrays. It's Python lists, but you can refer them to Python array 
since we are now in the numpy.  
 

The Complete Python Book 
 
384
 
Now, this allows us to do any operations on the arrays.  
 

The Complete Python Book 
 
385
But we also can do something like this.  As you can see, it's element 
wise addition of two arrays.  
 
Besides addition, we can do any operations on top of our arrays.  
Or doing full mathematical computations on top of it, for example, 
summing this two up and then multiplying that by five, make sure 
that priority of operations still stays the same as you introduce 
whole arrays as well.  

The Complete Python Book 
 
386
 
But what happens if we have two arrays of different shape and 
sizes? Take a look at a1_new and a2_new. 
 

The Complete Python Book 
 
387
By adding them together, we are creating a new array that will do 
element wise and array wise addition. This 2, 3, 4, which is here, 
and then 3, 4, 5, which is right here.  But, if we add one more 
dimension to A2, it won't work because of the something that we 
can call broadcasting. 
 
NumPy won't be sure what to do with it.  Besides general 
operations, NumPy has operations such as np.sqrt or square square 
root, np.sin, np.log that can be applied to individual numbers. And 
to the whole arrays as well. So, let's, before we start our 
broadcasting journey together, let me just showcase that, for 
example, squared can be applied to a one new, for example.  

The Complete Python Book 
 
388
 
And that will showcase that for every single element inside of that, 
which is one, two, and three, we'll get square root of that exact 
element.   
 
Let me explain that in more detail.  NumPy broadcasting is a 
powerful feature that allows you to perform element wise binary 
operations on arrays of different shapes without explicitly, 
replicating the smaller array to match the shape of the larger one.  
Now this makes NumPy operation more effective in terms of 
memory and computational resources.  
The basic idea of this is behind broadcasting is to stretch or 
broadcast the smaller array across the larger array so that their 

The Complete Python Book 
 
389
shapes match. Now this is a virtual copying, occurring, and it's 
simply conveying abstraction. Broadcasting has some kind of a rule 
that we need to follow if we want to have the broadcasting actually 
happening to us. 
So first one is dimensionality compatibility.  Starting from the 
trailing dimension, the dimension of the arrays must either be the 
same or one of them must be one.  Stretching is another 
broadcasting rule. And the rule as it states right here, if the sizes 
along dimensions are not the same, NumPy will try to stretch the 
array with the size of one along the dimensions of the matching of 
the other one, which in most cases is going to be larger. 
 
And if I just call the shape right here, we'll have two by three. These 
two comes from array right here, and this one from our array in the 
number one.  The last rule, which is resulting shape. The shape as I 
just showed you is the shape of the resulting array in the maximal 
size along each dimension from the input array.  

The Complete Python Book 
 
390
 
Let’s define a new array, which is going to be just a simple NumPy 
array of one, two, and three.  This will work perfectly.  And we've 
done this before, but resulting array of a scalar, or just a single 
number, is new array that has all elements influenced by that 
scalar. So, in this case, if we print this out, it's going to be 6, 7, and 
8. 
 
Nothing new so far.  Let’s try with 2d array 

The Complete Python Book 
 
391
 
And instead of using this simple r, array function, let's use ones that 
we used in the previous Chapters. And we just want to have right 
here as a dimension.  I want you to see this one right here, because 
it’s a kind of a new concept of using just one.  So if I add these two 
arrays together, what do you think will be a resulting dimension?  

The Complete Python Book 
 
392
 
 
If you said three by two by three, you are correct because we just 
simply added to every single element the element from this one 
right here. And this became two, three, four, and this became five, 
six and seven. So we basically increased everything by one, which 
will happen with our scalar operation as well like this. 

The Complete Python Book 
 
393
 
Now, what if we have two different shapes? When it works, when 
it doesn't work, it's still a bit of a messy subject right now. Let’s 
define two arrays A (3, 2) and B (1, 2) shapes. 
 

The Complete Python Book 
 
394
 
This works due to the fact that B has exactly the same dimension 
as A on the 2nd part, which is two elements. But if we expend B by 
a single element, making it 1x3 vector, this broadcasting would fail. 
 

The Complete Python Book 
 
395
To perform broadcasting we should either have the same 
dimensions or one of the arrays should have 1 as a dimension used 
for broadcasting. 
 
 
So when you speak about general practical application, the first one 
is data normalization. In many cases you will have the raw data that 
is not quite useful by machine learning or any data science 
pipelines when you start working. You will go out along the way 

The Complete Python Book 
 
396
and work with your data to make sure that data is actually like 
workable in a sense that you can actually put it in machine learning. 
That’s data normalization and there are many things that you can 
do with it depending on the data itself. You can perform 
calculations such as mean, square root, adding, dividing, and so on.  
The other application is image manipulation.  We talked about that 
in most cases when you load an image to your application to your 
Python file It's going to be in a format of a numByArray  Okay, so 
that this communicates to us that when we do this we can apply 
this division normalization  So much more that Python provides, for 
example, resizing it sometimes, or basically always machine 
learning algorithms needs to have images in the same size. 
So if you have different shapes and sizes, you want to make sure 
that they are aligned with an input data that you want to accept 
into your algorithm, or you want, for example, to have the RGB 
image be a gray scale one that can be done with MPI as well.  And 
mathematical modeling is the third one of many more, not listed 
here, that can be done with this NumPy broadcasting. 
Now, there's a couple of caveats, or limitations. When you're 
working with broadcasting, it makes your code less explicit, 
because it has those convoluted operations inside of them and 
sometimes it will lead to bugs because people are not actually 
understanding what is in front of them. So don't worry if you're not 
getting this broadcasting just yet. 
You will along the way, of course, but it will take some time.  And 
the other one is memory efficiency. When you do broadcasting, it 
might save your memory by avoiding a lot of different arrays.  
hanging around, but it might lead to memory loss or memory 

The Complete Python Book 
 
397
leakage when you have two large operations to happen in a 
broadcasting space.  
 
 

The Complete Python Book 
 
398
 
 
 
 
 
 
 
 
 
[I/G/A] Slicing NumPy Arrays 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
399
Resources for this Chapter: 
Colab Resource: Slicing Arrays: 
https://colab.research.google.com/drive/1R_T0uAttoVby2nSWmN-
bZSOL-Es7fgfT?usp=sharing  
When we started working with Python lists, one of the operations 
that we really wanted to get down was slicing indexing of elements, 
how to get to the one element under Python array, or how to go 
into that array, extract sub array of that, or list in this case.  This is 
the same approach that goes into NumPy arrays as well.  
 
And there are a couple of things that I want to go around with you 
and showcase how you can actually slice NumPy arrays. Later down 
this section, we'll talk about conditional slicing, which actually 
allows you to set a rule on how to approach certain items. And 
that's actually really interesting, and we'll talk about that later. 

The Complete Python Book 
 
400
 
Now, as before, the resource for, or the link to this file, is in the 
resources of this very video.  So, let's start with a basic slicing. One 
of the operations that we worked hard to understand with Python 
lists was actually indexing and slicing.  How to access a certain 
element in that Python list or how to get a certain sublist from that 
Python list.  
All of that is really useful when you want to extract the relevant 
information or just focus on different parts of that array.  And the 
same rules apply here in NumPy.  You have many more options.  
Later down the section, we'll talk about conditional slicing or 
making your condition actually work for you to select elements 
which you want to extract from that very NumPy array. 
Let's first import our NumPy array, so a NumPy library.  And I'll 
define a simple NumPy array, which will be exam scores.  And this 
will have just a couple of elements for example, 90 90, 85, 77, 92.  

The Complete Python Book 
 
401
And when we do this, the first thing, as always, when you program 
the first element is not one or index is not one, but zero. 
 
If you want, or if a task for you was to get the scores for the first 
student in this list, you will go in this, do this, for example, the first 
students score or we need double quotes here.  So we can use this 
single quote, Right here to score  and then you can is  and then here 
I'm going to say exam scores of zero.   

The Complete Python Book 
 
402
 
This will print out the exact score for that first student. This 
becomes quite more interesting, and I would say to some degree 
more advanced when we talk about multidimensional arrays. 
When you want to index a couple of different data points inside of 
a two day or 2d or 3d array. 

The Complete Python Book 
 
403
 
Let’s define a new one called sales data.  And the sales data will be 
set not by array, of course. And here I’m going to define,  let's say 
three subarrays. One is going to have 200, then 220, 250. And then 
we will have Similar results like to 10,  to 30 to 75.  And then we 
want to have, let's say 1 92, 0 5  to 35,  and this is basically telling 
us for each month of how many or how much of each of the 
products, let's say we have product 0, 1, and 3 is going to tell us. 

The Complete Python Book 
 
404
 
And that's quite normal information to have. And later down this 
course, we'll have actually the full data set for the first time in this 
course that you are going to import and work with for data analysis 
using only NumPy.  
 

The Complete Python Book 
 
405
Let’s say the query is to ask and or get the information about the 
sales of the first product for January of this year. Now we know that 
every single row is for each month and for each month we have 
information for three different products. First product, second 
product and third product. 
This is for January. February and March. And if we want to get the 
sales information about the, this right here, how would you 
approach it? If you want to do it alone, stop this video right here 
and refresh when you think you're done. If I want to access that 
data, first, I need to access this row right here. 
 
And this row will be accessed with zero because it's a zero indexed.  
Now, this is every single sales information about January, but we 
want under this to go and use information such as the first product.  
And on top of that, you can use zero like this. And this is 
information about the January of first product right here.  

The Complete Python Book 
 
406
 
The other approach is not to use two brackets, but one. And do it 
like this, like coordinates. It will work the same. Let's say March of 
the second product. How would you approach this? Using this 
knowledge here.  
 

The Complete Python Book 
 
407
Two and one will give us the information about two or five, which 
we wanted. March of second product.   
 
No matter how many of the arrays or let's say dimensions we have 
in the future, this rule applies. If we had the subarray right here. 
However, using more dimensions as there are, would case an error. 
 

The Complete Python Book 
 
408
When we have more complex data structures, it requires index 
stacking.  
 
A bit of a more complex examples right here.  Now, slicing is just a 
way or approach to use that information to access a couple of 
different items or sub items in that array. Let's use monthly 
revenue as an example, in thousands or whatever, so some 
numbers. 
 

The Complete Python Book 
 
409
And then we'll define 200, 220, 250, 275, you can imagine anything, 
340, 4 then 350, then we will have some drop right here, 400, 420, 
450 and 450 again, maybe. Let's see.  Okay, so we have monthly 
revenue. It doesn't matter how many elements. I went a bit, maybe 
over the board with the number of elements right here for this 
example.  
 
What you can do right here is you can go and say, okay, so now I 
would like to have, let's say, monthly revenue of elements from 
five.  And this will actually get elements from four or elements or 
fifth element ninth.  So that's basically how this works. And if you 
want to do something like this, you can as well. 
 

The Complete Python Book 
 
410
If you want to change a step and, let's say two, it will work. And 
now we're starting with 344. Then we are skipping one element. 
And then jumping on 320, 420, and 450. So that is this step notation 
right here. 
 
Now, one interesting thing is you can do like this. you are starting 
from the first, then going to the last because you are not stopping 
anywhere and then defining this as a kind of a step you can go from 
beginning to the end and select every third or every second. 
 

The Complete Python Book 
 
411
Minus one will reverse the order. So that works basically in a bit of 
a contra, contra intuitive way, but it will start from the beginning 
and then basically read it from the last to the first. 
 
And if you want a fast way to reverse the whole array, this is the 
one. And sometimes for questions on the interview, this is the way 
to answer because that's what they will ask you to do. Now, besides 
this, we can use something which we call rule based or conditional 
based conditional based I would say slicing. 
 
So let's remove this and now let's create a new element called 
average, avg. It's going to have np. mean, so this is a new function, 

The Complete Python Book 
 
412
which allows you to have monthly revenue mean. And let's print it 
out, and it's going to be 334 by this. Now, I know the information 
from the last year, for example, and I want to select only months 
where  this is above  certain average. 
 
In this case, this average.  If I go and do this, above, avg, it will 
return another array  with a true or false.  Now, this is not what we 
wanted, of course, but this will tell you what is about to happen.  If 
you want to achieve this and select from monthly revenue only 
months that actually will tell you what is above the average, you 
can by doing this.  
 

The Complete Python Book 
 
413
This is conditional accessing of the points.  You are accessing the 
list and here you are asking a question telling you which months 
are above certain average. In this case, you have a couple, like I 
think five or six. And if I execute this, it will just filter out everything 
that is true and leave behind everything that was false. 
 
How amazing is that? This will help you tremendously when you 
start working with your data, for example. finding out the missing 
data as well. Now, it's important to mention some problems, I 
would say when you're accessing some information.  When you go 
do this, and let's say this, basically what we did right here,  this is 
just a view or an array that is on the fly,  created for you, and 
immediately removed. 

The Complete Python Book 
 
414
 
If you want to save this, you can. And then you can define oops, 
two times the same, we don't need that. So above avg, and when 
you do this, you can manipulate this array, because it's a new array 
that's no longer removed, but stored in a certain variable that you 
can now access and work with.  

The Complete Python Book 
 
415
 
Just important, and all additionally, it's really important for you to 
know where data types became an end, because sometimes when 
you have mixed match, as you saw before, with a different shapes 
or different types of each of the elements, it becomes a bit more 
challenging slicing, but we'll have that in much more detail down 
the line. 
 
 
 

The Complete Python Book 
 
416
 
 
 
 
 
 
 
 
 
[I/G/A] Exercise/Project 10.1: Slicing and 
Indexing with NumPy 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
417
Resources for this Chapter: 
Colab Resource: Slicing and Indexing with NumPy: 
https://colab.research.google.com/drive/1NUYLMcOf0kyDmaNYRCe
RAkFy_9BqZ85Q?usp=sharing   
Welcome to the first mini project of this section. We'll have a 
couple of them.  In this mini project, you will apply everything that 
we learned so far.  And the resource or the link to this template, 
you can find in the resource of this Chapter.  
 
 So you will have One DRA, which I already gave to you right here, 
that you need to extract some relevant information, answer basic 
tasks. 

The Complete Python Book 
 
418
 
And you have a couple of them, as you can see right here. The first 
one is pretty simple. Go and extract information about January and 
December.  Then you want to extract quarterly information. You 
want to modify sale data to repair some information in April, for 
example, it was more  or less, you will see that when you load the 
file. 
 
Then you want to extract information about summer sales and then 
above average months, which we already covered, but for you to 
practice. Okay, so this is it for this intro. Go to the link in the 
resources of this very video. Have fun with this. It will take you 
some time to go over. And always, if you need some help, in the 

The Complete Python Book 
 
419
next video, I have a solution for you where I'm going to go through 
each single task and explain along the way why I did certain thing. 
 
. 
 

The Complete Python Book 
 
420
 
 
 
 
 
 
 
 
 
[I/G/A] Answer 10.1: Slicing and Indexing with 
NumPy 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
421
I hope you had a lot of fun with this mini project. So, let's go 
through every single task that we have here and answer one by 
one.  
 
 I'll execute the first cell to have my data loaded. And the first task 
asks us for printing out the sales data for January. of our first month 
and December or the last month, because this is the data for the 
first year. 
 
So to have this information, I can either create a new variables or 
can just print January data or info,  whatever you like,  and then 
print out. So it's sales, oops,  sales data, which is called right here, 

The Complete Python Book 
 
422
monthly sales. Okay, cool. So monthly sales. And then we will use 
monthly_sales[0]. To speed up this, I'll just do December right here.  
 
And instead of this, we will use, you have two different ways. To 
use minus one as the last index, I'll just count from zero to 11 and 
use that as an index. I'll stick with minus one. When you execute 
this, you will have December 475 and 200 for this one right here. 
This was really simple for this one right here. 
 
Now we need sales for every single quarter, and then print out that 
information back to the user or back to us in this case. So for Q1,  
Q1 sales, or let's shorten to Q1s for Q1 sales. I'm going to use 

The Complete Python Book 
 
423
monthly sales. I just need this. And the first Three months are 
quarterly information about Q1.   
 
So up to the free. Free, you can use from zero to free. Oops, from 
zero to free, or just leave it out and use this. Let's copy and paste 
this for four, three more times to get Q2, Q3, and Q4. Now we need 
to change this free here, because we know that this is up to the 
certain index. 0, 1, and 2, not including 3. 
 
The next number right here should be 3, because we want to 
include that. 3, 4, and 5, but not including 6. So, we are going to go 
from 3 to 6.  Here, same pattern, so 6, 7, 8, up to 9.  And the last 
quarter is 9 right here.  To finish up, we can just print out and say 

The Complete Python Book 
 
424
Q, Q1S, and then  basically print four more times, three more times, 
and then use information for each causal. 
 
And then that's it.  This is the sales information about each quarter. 
We didn't do any computation on top of it. It's just there for us to 
basically do that. Now when you have that, you can go and do 
information like mean of Q1 S and then convert it. Yeah. To have, 
to basically compare it to other quarters and stuff like that. 
 
We already know that Q4 was the best one, but you can compare.  
Okay, then the third task was saying this. Assume that there was an 
error in the data entry for the month of April. The correct sales 
figure is 280, 000. We know that this is in thousands, so just 280.  

The Complete Python Book 
 
425
Add this value in the array. Print the updated array to confirm the 
change. 
 
The first is monthly sales. Let's copy this for later. And then we 
know April is the fourth month, so it would be January, February, 
March, and April. 0, 1, 2, and 3. So we'll go, oops, too fast, we'll go 
to 3, and then set to 280.  And below, I'm just going to print out, 
and this is here, 280. Now that we have that, we are going to 
extract and print sales information data for sales months. 
 
June, July, and August.  Calculate the average of these months, and 
then print the average to the user. What we need to do is this.  
Summer months, that’s going to be  monthly sale  of, so we have  

The Complete Python Book 
 
426
June. You know that June is sixth month, but because we are 
starting with index of zero, it's one less, so five. 
 
So we are starting with fifth, and we have June, sixth, July is sixth, 
and then August is seventh. So up to seven, including seven, so up 
to eight. These are summer months. We can print them out.  
 
Summer months. And then, after that, we need to calculate the 
average of this. avg of summer is going to be np. mean of summer 
months. And print that back to user, avg of Summer.  As you can 
see, we got 320, 350, 370, and then the average right here. We got 
everything so far. Now the task file was something that we did 
previously. 

The Complete Python Book 
 
427
 
We need to go and get average of all months to calculate the first 
thing, which is average of monthly sales. And then because we have 
this, we want to identify and print the months where the sales were 
above average. It’s pretty simple. You have a couple of ways to do 
that. The simplest one was monthly_sale of monthly_sale  above.  
 
And this was just this. This is whatever we worked so far, and I hope 
you had a lot of fun applying this to these tasks. If so, yeah, amazing 
job so far, guys. Let's continue with more advanced stuff into 
vectorization, where actually NumPy really shines. 

The Complete Python Book 
 
428
 
 
 

The Complete Python Book 
 
429
 
 
 
 
 
 
 
 
 
[I/G/A] Loops Versus Vectorization 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
430
Resources for this Chapter: 
Colab Resource: Loops vs Vectorization: 
https://colab.research.google.com/drive/1duCregwOGnpkkEGs29P8
0j0f88ahx_9A?usp=sharing   
 
We learned about for and while loops, and how to iterate through 
certain lists, certain objects, and how to utilize them in a way to 
repeat some code if needed. And they are really useful, and you 
will use them all over the place. But sometimes you will need to 
automate certain things or make it faster because, trust me, for 
loops and while loops are not that fast, especially in Python. 
So there are ways to speed them up, and that's called vectorization, 
or putting them everything in one line of code, which we already 
learned with some of the operations with NumPy. But let's learn 
more deeper on how to vectorize more and more of our code.  So 
here you have the resources of this very template in the resources 
of this picture as well.  
 
Okay, we have daily users. Those are just for everything for some 
application. Now what they want to calculate is daily average users 

The Complete Python Book 
 
431
for Past four days and in the traditional Python sense, I would go 
and define average users to be zero and then for  I in range or just 
entry  in daily users  and then I have avg_users plus equal to E.  
 
And then here I will print out to just to know that this is summed 
up in a way that I want.  And here, if I wanted to do this, I would 
basically divide it by len of daily users to get the average.  And this 
is 236 by 25. And this is our daily average amount of users we have 
in our application.  Now, this can be done in a really simple way 
using NumPy. 
 

The Complete Python Book 
 
432
The first thing that we need to do is go and do convert this to 
NumPy. So daily user, I'll just shorten it to du_np is equal to NumPy 
array.  
 
Here, I'm going to use daily users as a, as an input, and I can just 
print np mean of du_np.   
 
This allows you to actually go and get the same score.  But instead 
of using Python loops, you can use that in a simple line of code. So 
what's actually happening in the background, the code is translated 
to C because NumPy is written in C, not Python. And in a fast way, 
it allows us to actually print or do the operation in a split of a 
second.  

The Complete Python Book 
 
433
 
You can monitor the time of every single operation in different 
ways, but generally speaking, NumPy is much, much faster. So, 
speaking of comparisons, I want to prove to you that NumPy is 
actually faster performance comparisons between these two. So I'll 
define some large array that’s going to have crazy amount of 
elements, like millions. 
 
And then I'm going to use that np. random.  randint, which actually 
allows you to generate some random integers from low to high.  

The Complete Python Book 
 
434
 
So my low will be 1, high will be 100, and size will be 1 million. You 
can do it like this.  Like this.  Million.  Is this one million? Yes, it is. 
Okay, so we have some large array, and I don't really want to show 
to, yeah, show it, but let's do it. 
 
I don't know if it's going to take crazy amount of time or just show 
a couple. Yeah, just a couple. And if I go to size, it should show us 1 
million. Okay, that's cool. We have a large array.  Now, I want to 
import one built in Python framework or library called time.  So, 
time, there is a time it also, but I don't want to get even more 
confused. 

The Complete Python Book 
 
435
 
Measuring how many seconds or something is executed.  
 
And then print of avg divided by 1 million and execute the code, 
but I want to time it, or I want to find out how many seconds or 
milliseconds this is going to take. So start time is equal to time dot 
time.  Really creative, right?  And then here I'll do the same, but I'm 
going to call end time.  

The Complete Python Book 
 
436
 
And just print out end time minus start time.  And when I execute 
this, it will take 0.  35 seconds.  Yeah, on this scale not that large. 
But let's increase that to 10 million.  I'll add one more zero, large 
array, and divide here by 10 million.  now,  it becomes 1. 6 seconds.  
Okay, I added a lot of more, a lot more information to it.  
 
But I have all the code, so let's create a new cell. I don't need to 
import it again, but let's just paste it right here and use our NumPy 
code, which is this.  And let me paste it instead of all of this.  Okay, 
and daily active users, I don't need that. I want to do this with a 
large array.  large array. I actually even define it, so I don't need to 
define it twice. 0. 02 seconds for 10 million.  You see the difference? 

The Complete Python Book 
 
437
 
It's 1. 6 seconds, and this is 0. 02 seconds.  And that becomes even 
more important when you're not working with just a random set of 
integers. And yes, 10 million of them, but when you start working 
with crazy amounts of data points, neural networks and algorithms, 
you want to automate or speed up certain things. 
 
This actually changes everything here. And yeah, basically 
everything here and print is print. Print does not get any additional 
overload.  So now you can use vectorization techniques to even 
vectorize more robust or more important, I would say real world 
examples. Now, I pitched to you that vectorization is amazing for 
everything. 

The Complete Python Book 
 
438
 
Yes, in most cases vectorization is going to be a good case. But then 
there are some cases where pure vectorization in this sense the 
best solution is not. When you have multiple checks, when you, for 
example, filter sales. filtered third  users amount or whatever. And 
then for user amount in daily user.  
 
And then I want if users user M amount is bigger than 200 and  User 
n is divisible by two,  for some reason.  I want to append that to 
filter user.  

The Complete Python Book 
 
439
 
And this still can be vectorized in more difficult way, which we are 
going to discuss in the future chapters. But in a traditional sense 
that we discussed in this case, it's much better to leave it as it is. 
Okay, so that's it for this Chapter. Let's continue learning about 
more advanced techniques about NumPy. 
 
 
 

The Complete Python Book 
 
440
 
 
 
 
 
 
 
 
 
[I/G/A] Exercise/Project 10.2: Vectorization 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
441
Resources for this Chapter: 
Colab Resource: Vectorize a Given Python Loop:   
https://colab.research.google.com/drive/1icw7DnnxD9hqvPSWm
QUQu7ahF-XGmv6g?usp=sharing  
Now that we've learned vectorization, basic vectorization, let's put 
that in practice. and go through a couple of tasks in this second mini 
project of this section to get most out of it. So, your objective is 
basically to use whatever we learned so far, you can use even 
beyond that, so before, to learn about how to, how not to use some 
Python loops and yeah, basically that. 
 
Imagine that you're working with a dataset containing a monthly 
sales data, again, from a retail business. You want to apply a 10 
percent discount to each month sales figures to calculate new sales 
numbers.  Okay, so task one is straightforward to create that sales 
information. You can use whatever approach that you already 
know, and then initialize an empty list called discount sales. 

The Complete Python Book 
 
442
 
And then you basically look through and apply that. Now you do 
the same thing, but with NumPy.  Let's try that. See you in the next 
video with a solution of this exercise.  
 
 
 

The Complete Python Book 
 
443
 
 
 
 
 
 
 
 
 
[I/G/A] Answer 10.2: Vectorization 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
444
Now, the first thing that we are going to do is to create this monthly 
sale list. You can follow a straightforward approach and use just like 
a normal Python list, but I'm too bored to use that information right 
now or to use that technique because we need numbers. 
 
I’ll cheat a bit. And I'm going to import NumPy just yet.  Then I'm 
going to define this as np random that ran  end,  and this, as you 
can see, like when I go, let's import first.  
 
So let's import first and then I'm going to put do random dot, 
random end rand.  Now rand int takes a couple of things lower. I'll 
put 1000 is the lowest, 2000 is the biggest and 12 and.  If I print out 
monthly sales, it will give all the information to me.  

The Complete Python Book 
 
445
 
I created this because I didn't specify how. Now, initialize the empty 
list or discount the sales. I would say like this. This should be like 
this.  And then for element in monthly sales, I'm going to append 
here element times 0. 9, because that is 90 percent of this or 10 
percent of discount. 
 
 And if I print out discounted, discount sales, it’s going to give me 
that same information, but discount.  Now, the second task for us 
was to convert this to NumPy array, which I already did, but using 
this I'll go and immediately define this, and that's going to be my 
monthly sales times 0. 9.  And if I print discounted sales NP, but let's 
see the results.  

The Complete Python Book 
 
446
 
Okay, so this was a short and sweet exercise how to use what we 
learned so far. Now let's build on top of this and go even in more 
details on how to utilize NumPy for everything that we do in data 
science. 
 
 
 

The Complete Python Book 
 
447
 
 
 
 
 
 
 
 
 
[I/G/A] Universal Functions 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
448
Resources for this Chapter: 
Colab Resource: Universal Functions: 
https://colab.research.google.com/drive/1nfybjd949chykffxbhz-
K50TqB_6-8nQ?usp=sharing    
 Universal functions in NumPy are simply mathematical functions, 
or U functions, as you might read about.  It's just a term that we 
gave to mathematical functions in the NumPy library. NumPy 
provides various universal functions that cover a wide variety of 
operations.  These functions include standard trigonometry 
functions like sine, cosine, etc. 
Functions for arithmetic operations. And many more. Handling 
complex numbers, statistical functions, and other. Like all this is 
just a package of functions that we can use to apply to basically any 
NumPy array, no matter what its size is, to get that calculation on 
top of it. And it can be element wise, operations, in most cases. 
It's really fast element wise operation. Python functions can also be 
converted as a and be universal functions inside of the NumPy 
library. And I'll teach you how to do that in this video as well.  Some 
functions are called automatically when we do correspond 
arithmetic operators, for example, addition. 

The Complete Python Book 
 
449
 
But sometimes you can also call, for example, np. add. It's called for 
you if you need. Okay, so the file for this video is in the resources 
of this video, so go check it out, create a copy for you, and let's get 
started.  The first thing that I want to explain is what are generally 
universal functions, and just to showcase that.  
 
For that we need to import NumPy. And we'll define some product 
prices.  And that's going to be NumPy array. That's going to have a 
couple of product prices, like 25, 33, 37, and so on. Maybe one 
more.  Now that we have this imported and defined for us, let's call 
the first universal function, which is np. sqrt, or square root.  

The Complete Python Book 
 
450
 
When I call that on product prices, It will do that for every single 
element in that product price list, in this case. This is 5, for example, 
and maybe this is discontinued prices, and if we just print out 
discontinued prices, and then print it out, this is the result.  Now, 
some common arithmetics can be done using these functions as 
well. 
 
You don't have to use np.add. For example, you have np.add, then 
you can add two different things, as you can see, x1 and x2. Then 
there is np.subtract.  This is MP applying on X1 and X2. Then we can 
have mul, which means multiply, and so on.  So the one thing that 
we are going to do for this one, let's define  two simple arrays.  

The Complete Python Book 
 
451
 
And that's going to be an umpi array.  That's going to have a couple 
of elements. You can define any number. It doesn't matter for this 
exercise. I'll define like this, so it doesn't matter that I have two  and 
then I'll copy and paste to just to save us time and I'll define 
expenses  and here it's going to be two thousand  and here is going 
to be one point five thousand for some reason and here 2.5 
thousand for some reason  now, of course we are going not going 
to do MP dot add because when you have revenue you want to 
calculate the net profit or Yeah, basically after that.   
 
Array – array does the same thing as np.subtract, and in actuality, 
np.subtract is called when we use a simple minus sign. This is a 
uniform function that is a general function for us.  You can call 
many different functions like a trigonometry, np.sin, cos, log, exp, 
and many others.  
Let’s now show an example with a variable called principle, which 
is 1000.  Then rate is 5%.  And then years, I'm going to define as an 
array, which is going to have five years. Now that we have this, we 
can do compound an interest and define that as a compound  

The Complete Python Book 
 
452
interest,  which is going to be principle,  principle times np.exp of 
rate times years 
 
This will compute amount that I’m about to earn based on the 
compound interest for 1000. In the 5 percent interest rate. Now 
that you know how to combine NumPy functionality, try to change 
every operator to native numpy operations. 

The Complete Python Book 
 
453
 
 
Now you can do comparisons and logical functions as well. And I'll 
use two of my revenue expenses example before, so we don't have 
to create again. So I want to find out where, for example, is the 

The Complete Python Book 
 
454
largest, I don't know less than 2000 in the sense of  in the sense of 
expenses. 
 
Let’s call np.less_equal, and then you can put expenses.  And here 
you can put 2000 if that is the number that you want. It's going to 
be true, false.  But you can put expenses here,  and then put that 
as a kind of a rule to get the numbers right here.  
 
Now, this is called automatically when you just do this. For 
example, expenses less or equal to 2, 000 without this bracket right 
here. It's going to be the same result because these are actually 
calling this set comparisons functions. So, you don't have to use 
them. I actually never use them in my life because they are there. 

The Complete Python Book 
 
455
 
Besides native Numpy functionalities, you can vectorize any python 
function using np.vectorize. This is a real vectorization where you 
can put the full function under the belt of NumPy. As we know, 
we're going to define a function which is going to call calculate NPS. 
 
And then let's define a score.  Okay, so yeah, basically you can 
define anything. But if score is bigger than nine, we are going to 
print or return, depending on how you like, promoter.  Then, and if 
score is bigger or equal to seven, you can return  passive and else 
we are going to return  detractor.  

The Complete Python Book 
 
456
 
So now we have this weird function that I found.  And  what is going 
to happen is going to nps u function  and then np.vectorize,  
vectorize. And as you can see, the argument we need to provide is 
Python function. And I'm going to provide here this.  
 
Here I have this Python function. So now. you can call it. If you, for 
example, have some scores and np.numpy.  array is going to have 
some scores for us, 9, 8, 6, or 5, doesn't matter really, 7, 6, 6.  And 
then  I want to call this On top of scores. So here I'm going to find 
scores and actually is going to automatically apply that to us. 

The Complete Python Book 
 
457
 
It doesn't have to have loops. It’s going to be called for every single 
item in the same time.  How amazing is that? Now you know how 
to do and work with unified functions and how to actually do that. 
 
 
 

The Complete Python Book 
 
458
 
 
 
 
 
 
 
 
 
[I/G/A] Conditional Filtering 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
459
Resources for this Chapter: 
Colab Resource: Conditional Selection: 
https://colab.research.google.com/drive/172ae_PSHdIrmuG39_IXFQj
9j7E-Edxkp?usp=sharing  
Earlier, I promised you that we were going to talk about conditional 
filtering or different ways on how to tell NumPy which elements to 
select and which not, and that to do that automatically even.  Okay, 
so we've done some of those, like for example, scores of scores 
where that and then we can basically ask between those. 
 
But there are more advanced ways to do that than that. There is a 
function called np. Where it’s going to take np. where and we can 
provide scores larger than 80.  And this will return this. As you can 
see, it's a tuple of indices where this is correct. 

The Complete Python Book 
 
460
 
It’s going to be 0, 1, so 0, 1, 3, and 4.  If you say 0, 8, 85, not including 
85, it should be one and then three and four.  So, this is something 
that we started.  But then you have some options right here. Now, 
when this condition is correct, you can go and define something 
that's going to happen.  If, let's say we want to find out if somebody 
is eligible to do something, you want to define eligibility, for 
example. 
 
When you provide these two arguments, it's not going to return 
only indices, but actually a new array where it's going to be 
chained. One thing that this is quite useful is in the real world, 
where, for example, you have a data set, where the data is, for 

The Complete Python Book 
 
461
example, gender male or female.  And then you want to say, okay, 
where the gender is equal to this, I want to say zero or one because 
computers can't work with strings or text. 
 
We need to convert that in some way. We're going to talk about it 
in the future sections in the workable. data, so integers or floating 
numbers or some kind of vectors.  And this is quite useful and I'm 
using that quite a lot every single day. Okay, now you might be 
thinking of, this is great, but how if I have, for example, a  question 
or a task to filter out just scores below 88 or below 87 and above 
90? 
 

The Complete Python Book 
 
462
You don't want to include 90 and 88, you want to go around them. 
With this, you can do that. But let's copy this and paste it right here 
to improve it with some other thing.  You need to put right here in 
the brackets. And after that, you need to call, open other brackets 
and say, I don't know, let's say below 87. And here you want scores 
of 90. I need to change this to less than.   Then you have two things, 
two operators that you can add. One is and this will allow you to, 
let's print eligibility.  
 
Let's print it right here.  And of course, There is no number that is 
less than and greater than that.  But then you have a pipe in 
programming languages called pipe, which allows you to say OR. 
So, this will filter out everything that is below 87, as you can see the 
first one, which is 1. Then, you have 78, then you have 92.  

The Complete Python Book 
 
463
 
That's cool.  Now I want to add here, for example, I don't want 78. 
Larger than 80. And I don't want anything except 90 plus. Here we 
filter out this 78, I don't want that, but I want like this above 80, 
below 78, and above.   
 
Now, one thing that you might not use that quite often is 
combining np. where statements together in a crazy way. Let's take 
this np.where that I have right here  and try to change it, for 
example, like this. I would go and say np.where below 87 is yes, and 
then you have something else that is, and this is something that 
you might not use that quite, that often. 

The Complete Python Book 
 
464
 
We have this where if it's above 90 it will say yes, otherwise no. 
Let's change that to be below 70 or 80. Let's say 80. 78 should be 
yes, otherwise no. Let's execute that. 
 
However, I don't want this to be here. Instead of no, I will put this 
above 90. So this will work, and it will tell us, okay, so if this is not 
correct, you can add here another condition and another condition, 
and then nest them as much as you want.  Okay, so it is very useful, 
but you won't use it as often as other approaches. 

The Complete Python Book 
 
465
 
 
 

The Complete Python Book 
 
466
 
 
 
 
 
 
 
 
 
[I/G/A] Reshaping Arrays 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
467
Resources for this Chapter: 
Colab Resource: Reshaping Arrays: 
https://colab.research.google.com/drive/1igAEfOi5We426z7kFRotKP
ePmjFTWIq3?usp=sharing    
When we work with the traditional lists, it became quite obvious 
that changing from that shape to another is quite a tedious process. 
It is possible, yes, but we need a lot of for loops, steps and so on.  
But reshaping is completely normal part of working with data, 
especially when you're building a data pipeline. 
 
You need to make sure that, for example, dot product can be done. 
You need to transform, you need to transpose, you need to 
reshape, all those sorts of great stuff. We'll touch upon quite a lot 
of different ways to actually do and change the shape of an array.  
So right here, I have a data array, just random numbers.  

The Complete Python Book 
 
468
 
And if you check the shape of this array is 100 now this 100.  comma 
something. In most cases it will screw you up, a lot, because it won't 
allow you to do dot product, it won't allow for broadcasting, so you 
need to be careful of this quiet shape. It is a vector, but it is not 100 
by 1, it is still 100. 
 
And this is where reshaped comes into play. So you can reshape 
that to 100. by one.  Now, this will allow you to create a kind of a 
mini arrays of a single number right here.  One thing that you need 
to notice or remember is when you don't know how many items 
you have, you can place a number one there. 

The Complete Python Book 
 
469
 
So that can be done only in a one, one place. For example, you can 
do minus one and minus one. It won't work.  Try. It will show an 
error saying that can only be specified one unknown dimension.  If 
I change this to 100, and then 1, minus 1, it will still work.  Now, 
this is fine, and you can still reshape it in many different ways. 
 
For example, you can reshape it by 50 by 2. But one thing to note 
is always it should have the same number of elements when you 
started. 100. So for example, I can't reshape by 50 by three because 
there are not many elements there. For that I would need 150.  So 
I can work with, I can't work with this because it's still less, I can 

The Complete Python Book 
 
470
work with this, or you can work by  decreasing this for 25 and then 
putting four here. 
 
That would work. Or 20. And then five right here, that will still work 
as well. You can put 10 by 10, and that will work as well. And all 
sorts of combination work. This reshape does not change the 
structure of data. The order will always stay the same. So, it will go 
like this.  
 
So however, you reshape the data, every time it'll follow the same 
pattern.  Another thing to note is, as you can see, this is original 
data. I didn't change it. If you check the shape, It’s still 100 comma.  

The Complete Python Book 
 
471
 
You need to allocate this and say data equal to this reshape if you 
want to keep that reshaped version of your data, for example, like 
this.  
 
Other things that you can provide right here, order and stuff like 
that. But in most cases, you will only provide your shape and go 
with that. And that's it.  So, the reshape method is there for you to, 
in a simple way to reshape your data.  Now, there is another way 
when, for example, have, when we have multidimensional array. 

The Complete Python Book 
 
472
 
For example, let’s say again, data, and that's going to be 
np.random, but the size will be  10, let's say. 10, yes. And then I 
would reshape that to data2. reshape of 5x5. Or, oh really? Yeah, 
of course, it's not possible. 2x5.  I Actually want 5x5, so it's 25 Okay, 
cool.  This right here, data, let's visualize it together. It will have 25 
elements. When we check the shape, okay, it will be 5x5.  
 
Now, there is a way to put it in a vector space back. Basically, back 
it to one dimensional array.  It is quite useful when you are doing, 
for example, multiplications, or when you're doing stuff like 
convolutional neural networks or general neural networks. You 

The Complete Python Book 
 
473
need to make sure that your data is not two dimensional, but single 
dimensional.  
 
There are other areas of application as well, but this is the most 
prominent one.  So here, if I do this and call flatten will go and make 
it in the same array.  Now, there is another one we'll call ravel and 
it will work the same, but the difference is one will create  and let's 
call it again. 
 
To return a copy, so the order, it both will return an array.  Now the 
difference is this right here. It's really important.  What will happen 
is this. Let me demonstrate. If I have Let's say data three.  That's 

The Complete Python Book 
 
474
going to be flattening.  And then I will have data four that's going 
to be data two of Ravel.  
 
So, when I go and make some changes, so data four has these 
elements, and let's see data two, which is our original data.  When 
I go and change of element of zero to ten thousand, just to know 
the difference.  And execute this. Here, we manipulated the data 
as well.  
 
When you do ravel, it will only create a reference to the view of 
that data. When you change it, it will change the data in the original 
as well.  So when you're working with your files, data, make sure 

The Complete Python Book 
 
475
that you know what you're doing. So here, data free.  Let's go to 
data3. You will see that it's still 86. 
 
And when we go and, let's say, change the tenth element to million,  
whatever,  million, like this, and visualize data3,  it will have the 
million right here, but the data2  won't have that. Because we 
created a copy, so we are working on a new data.  
 
And you can change it, you can do whatever with it. But when you 
do the change, it will stick to that change. 

The Complete Python Book 
 
476
 
Another fun thing to do is transpose. There are two ways, they're 
called np. transpose or t. So when I do, for example, data2 let's call 
this dot T, it will transpose.  It doesn't matter because it is going to 
be the same. But let's resize it.  It's difficult to find a good size 
because it's five way five.  
 
Let's generate a new one. data test. Data T is equal to np.  Random. 
Random. Random eye end.  of 10 to 100, and then, I don't know 20 
elements,  and then we're going to resize it.  I think you can do it, 
everything like stacked like this, reshape, and that's going to be 2 
by,  yeah,  I didn't do this correctly.  

The Complete Python Book 
 
477
 
When I have this new data, let's visualize it, it’s going to be like this, 
but when I transpose it, it's going to be like this. Transpose does 
basically that, what it tells you, transpose.  Now, resize can change 
the size of an array. And it works in a similar way as reshape, resize. 
You will see that you will have for example, some array. 
 
Let's use our data T.  And then the second one is a new shape. For 
example, we want 5 by 4.  And this will tell you exactly that. So 
basically that. You're giving the size, and it will do this. Now if I put 
the same size that doesn't work, what will happen?  It will work. It 
will basically do some crazy data. 

The Complete Python Book 
 
478
 
What you can see, it will continue append the data.  So yeah, 
basically that's something that you can do, but make sure that you 
always stick to your data or data size.  Now, there is concatenate, 
split, and other stuff that we can do with data as well. This will 
come in handy later on when you start working with your projects. 
 
But it's really important just to quickly or briefly explain what each 
does. np. concatenate works as it is. Let’s define two data points or 
data arrays. Data one t just to have the difference. And then I'll 
have here 100 and 1500. And then let's do the same, but instead of 
one, let's put two. 

The Complete Python Book 
 
479
 
And here I'll have 202, 500 when I do this. Now, what I can do is 
concatenate, so np.concatenate, if you go there, it will tell you. 
Arrays that you are going to concatenate.  You can basically get the 
number or add here. For example, data one t data one t and data 
two T like this.  
 
Only integer colors arrays can be converted to a color integer.  
What you need to do, you need to put them inside like this. And it 
will work. 

The Complete Python Book 
 
480
 
Now there is additional stuff like that you can do, for example, MP 
V Stack, which means basically vertical stacking. And the same goes 
add this data one T and data.  2d. Now vertical stack will add them 
one after the other, so like rows, and there is h stack, which will 
horizontally stack them together, which is basically as a 
combination.  
 
So that's it, like you can do that, you can split them together, split 
into smaller chunks, like np.split, and this will split to array into 
indices, or  for example, when you call the array, it's going to work 
like this.  

The Complete Python Book 
 
481
 
We learned a lot about internals of NumPy, how to work with the 
reshaping and restructuring of your arrays. That's going to be so 
handy when we start working on different projects in the future.  

The Complete Python Book 
 
482
 
 
 
 
 
 
 
 
 
[I/G/A] Handling Missing Values Using NumPy 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
483
Resources for this Chapter: 
Colab Resource: Handling Missing Values Using NumPy: 
https://colab.research.google.com/drive/1VKv84GQ7m9Ie7Hqpq2jO
29NUjqF3HHkS?usp=sharing  
 Whenever you work with any data set, one of the first steps in the 
data processing or analysis is to check whether or not you have 
some missing values. In most cases, when we work with real world 
data, you will have some missing values for some reason. There are 
many different reasons why that might be. 
For example, imagine that you had a company where you 
registration data. Basically, when you go and put an email address 
and stuff like that. And you know that on those websites that 
sometimes that information might be optional. So you just decided 
to have some information optional for example, address.  
But then for some reason, business decision, God knows why, you 
decided that those information is needed now, and you 
unfortunately need to inform the customers that from now on, 
they need to provide that information while registering on your 
service.  
 

The Complete Python Book 
 
484
At the very beginning, I have this import NumPy and have customer 
data and everything seems normal at first, but We have this np.nan, 
which is non defined value. And when I execute, everything works 
smoothly. But now, whenever I want to do something like, for 
example, sum up or maximum value or whatever, it's going to have 
this none. 
 
And let's say max.  And if I call that, None is the actually maximum. 
Because in Python or NumPy, that sometimes is considered to be 
infinite, which is of course not true. It's just a missing value. And in 
most cases, you need to identify that and then talk about how to 
handle that. There is a lot of rules, or I would say directions that 
you can take while thinking about missing values. 

The Complete Python Book 
 
485
 
In this chapter, we're just going to measure some of them. And the 
whole strategy of how to handle data, you need to have the main 
knowledge. You need to go around and ask your colleagues. You, if 
you're working for a client, you need to know the main knowledge 
of the project that you're on.  Find out the rules, how to handle that 
missing data. 
Handling missing data is not an easy task. So, there is a lot of 
research needs to be done while handling that.  Okay, so one thing 
that we can use here, np.isnan.  And that we can provide customer 
data and that's going to provide true whether if it's missing or not. 
In this case, we know that third item is missing. 
 

The Complete Python Book 
 
486
So, this is true. The false is if it's not missing.  Now we can store that 
and say missing values. And potentially use that in the future.  So 
we can also go and do some calculation on top of it. Imagine that 
you have thousands of different numbers or thousands of different 
entries. In this case, we have only five. 
 
So if you want to calculate how many of those you have, you can 
say print, we have  this many missing values.  
 
And then I'm going to do np.sum of missing values. And then I'm 
going to do np. sum of missing values.  So just remember that 1, 
true is always 1, false is always 0. So, this is basically going to count 
how many true values we have in this. Is it none or not?  So now 

The Complete Python Book 
 
487
that we identified that we have indeed some missing values, We 
need to know how to handle them. 
 
And MPI has different solutions for us. For example, we can go and 
say, np.nan.  This np.nan to Num, will allow us to basically go and 
replace that NAN with.  And yeah, so we can go and say customer 
data. And if we do that now, this is zero and not none.  So, zero 
filled and we'll do that. 
 
But sometimes you will find out that zero might not be a best 
strategy. For example, let's say that we have weather data. Imagine 
that suddenly, because one day is missing, you fill in with zero. So, 

The Complete Python Book 
 
488
we have degrees, normal degrees, depending on where you are, 
like Celsius or Fahrenheit, whatever. 
And then suddenly tomorrow is zero. It's not normal. Imagine it in 
summer.  And you can't do that. So, filling with zero can be good 
sometimes, but in most cases, it's not a great strategy. There is 
another way that we can do and fill in with mean information or 
median information.  You can also do like information with like 
mean  of not the whole value, but  value before and build value 
after that. 
So one thing that we can do is NAN mean  and that's going to fill in 
with mean value,  customer data.  
 
And as you can see, that's going to have, replace missing value with 
mean, median or a specific value using NAN mean.  

The Complete Python Book 
 
489
 
We are going to fill that information there. But unfortunately, it 
does not do the same as this one. Define data_mean_filled.  And 
that is np where np is nan customer data.  Then where that is true, 
we're going to do mean data,  else we're going to do customer data.  
 
And when I execute that, it's going to fill in exactly this, what we 
want. Sometimes it's much better for you to remove that item 
instead of just replacing it with some arbitrary value. 

The Complete Python Book 
 
490
 
Because doing that, like it can be a mean value right here and it 
might be the best value to fill in, but sometimes it's a noise. And 
noisy data is a bad data for your model.   
 
This will only allow me to see one because it will select only that 
where it's true. And this is true where the numbers are missing. To 
negate that, we need to use this tilde sign, and this will negate that 
and use everything contra. So, this will be the opposite from what 
we had.  

The Complete Python Book 
 
491
 
It’s a way to remove the data.  Now, there is another way and that 
is basically using methods to fill missing value based on 
neighborhood elements. It's a bit more like here and there, like 
method. It allows, definitely requires a lot more work to be done.  
 
So first off, I'm going to define a copy of customer data, and that's 
going to be np.copy of customer data. So, this will help us define, 
and not change the original data, what we had. Then I'm going to 
define something we call mask, which is going to tell me where the 
missing data is. To achieve this, we will use np.isnan 

The Complete Python Book 
 
492
 
Now, call np.roll, which takes elements along a given axis.  
Elements that roll beyond that last position are reintroduced at the 
first. 
So, we are basically shifting the element. When we do this, 
everything is going to shift in buy number of steps we defined.  
 
If we visualize the copy right now, it becomes 200. Now, we could 
have done that in more straightforward way, but that's just one 
way to do. Now, there is a way to shift everything one step forward, 
which instead of this minus one, it will be one, and then you will 
use that. 

The Complete Python Book 
 
493
 
Another approach that you can use in neighboring elements is 
calculate one, one before, one another. We can combine these two 
approaches together and use the average, but not from the whole 
spectrum, but in between those items. And that is only usable if 
you have time series data.  
 

The Complete Python Book 
 
494
 
 
 
 
 
 
 
 
 
[I/G/A] File Handling 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
495
Resources for this Chapter: 
Colab Resource: File Handling: 
https://colab.research.google.com/drive/1h3dmt1ge9fSd4VIan6tQjx
Ywer-GBpEp?usp=sharing  
 When you start working in data science, it means that you are 
going to work with a tremendous amount of different data files. In 
most cases, those files will come from different sources, and 
working with files in different ways is really important and crucial 
for you to learn.  
We will talk more about the general data handling in the next 
section when we talk about Pandas, but let's focus now on how to 
handle saving and loading NumPy arrays. So let's define a simple 
NumPy array, which is called as np,  And we can call age.  And then 
we'll save that in some data file, which is 18, 25, 33, 44, 25 again, 
or 22, let's change a bit, 45, and so on.  
 
Now, so this will allow us to create a normal NumPy array. And 
especially when you are working with a lot of data, when you are 
processing, handling data, and stuff like that.  And those can take 
couple of hours. You don't want to start all over again if you need 

The Complete Python Book 
 
496
to restart your work tomorrow. Let’s see how to save these 
processed arrays for later. 
 
And for that NumPy has a function called np. save.  Save or save as, 
that will allow you to save either a single array or single or multiple 
arrays.  In this case, we are saving only one array, and that's going 
to take a file, we can call it whatever, so we can call age.npy, that 
is an extension for NumPy, and then we're also going to save age. 
 
If we check these files, you will see here age.npy.  Now that we have 
this stored, it's time to load back and start working with it. Imagine 
that we came back to work tomorrow. And yesterday we saved this 

The Complete Python Book 
 
497
file. So now it's time to load. To load age data use np.load. And then 
here load will take just the file name. 
 
So here we have age.mpy.  When I execute, no errors. And if you 
miss something and there is no file, it will throw an error because 
there is no file or directory named with that string.  It loaded 
successfully. Let's go and visualize the loaded age.  
 
Let’s talk now about saving text. Save text allows you to save in a 
textual format. So, we can do that in a really simple way. To achieve 
this we will np.savetext. text, and this save text will tag the file 
name. So, our age.txt, then I'm going to provide my age data, which 
is loaded Age. And then you can define the limiter, which is going 

The Complete Python Book 
 
498
to be comma for me to know that they are going to save in that 
way. So here is my age data, as you can see right here.  
 
And to load text data, you can use np.loadtxt file to load the data 
back to your program.   
 
Now, we already talked about the delimiter when we defined load 
data, but you also can use columns, skip rows, and those sorts of 
stuff when you are saving the file.  

The Complete Python Book 
 
499
 
You can just put that in a save or load TXT file, but make sure that 
you are using that as a normal information. And you can basically 
use that and either skip certain rows or use some columns or 
discard some columns when you define this.  Make sure that you 
test it yourself. 
It's simple. Use that via load text or save text file, and it's going to 
help you by understanding how to load and save text in more 
detail. But at the end of the day, it's going to be the same as this 
one. 
 
 
 

The Complete Python Book 
 
500
 
 
 
 
 
 
 
 
 
[I/G/A] Quiz for Level 10 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
501
Please answer the following multiple-choice questions. At the end 
of the quiz are the answers.  
1) What is NumPy primarily used for in Python? 
a. Web development 
b. Data Analysis and scientific computing 
c. Game development 
d. Mobile applications 
 
2) What functions in NumPy can be used to create a new 
array with a specified filled and zeros? 
 
a. np.zeros_like() 
b. np.empty() 
c. np.zeros() 
d. np.arange()  
 
3) What is the main advantage of vectorization in NumPy 
over traditional for loops? 
 
a. Vectorization can only be used with 
multidimensional arrays. 
b.  Vectorization provides a more pythonic way of 
writing loops. 
c.  Vectorization leverages efficient C code under 
the hood, often resulting in performance 
improvements. 
d. Vectorization is required to use universal 
functions. 
 
 

The Complete Python Book 
 
502
4) Which of the following is true about universal functions 
(ufuncs) in NumPy? 
 
a. They are Python functions that can only be 
applied to single values. 
b.  They operate element-by-element supporting 
broadcasting and type casting. 
c.  They cannot be used with NumPy arrays. 
d.  They are used to concatenate arrays. 
 
5) How can you handle missing values in a NumPy array? 
 
a.  Using the np.missing_values() fucntion 
b.  By replacing them with the mean value of the 
array. 
c.  Using the np.nan value to represent missing 
values. 
d.  Missing values are automatically handled by 
NumPy and do not need any special treatment.  
Answers:  
1) B) Data Analysis and scientific computing 
2) C) np.zeros() 
3) C) Vectorization leverages efficient C code under the 
hood, often resulting in performance improvements. 
4) B) They operate element-by-element, supporting 
broadcasting and type casting. 
5) C) Using the np.nan value to represent missing data. 

The Complete Python Book 
 
503
 
 
 
 
 
 
 
 
[I/G/A] LEVEL 11: PANDAS AND 
POLARS 
 
 
 

The Complete Python Book 
 
504
 
 
 
 
 
 
 
 
 
[I/G/A] Intro to Pandas & Polars (What, Why 
and How of Level 11) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
505
 Welcome to Level 11. In terms of what, why, and how of Level 11, 
let's kick it off with a what. What will we learn together?  We will 
learn about using Pandas and polars here in Python, which are 
incredible data analysis tools. Now, think of NumPy, which we 
covered in the previous Level, as being amazing for creating and 
working with arrays. Pandas and polars are great for loading and 
analyzing data.   
In terms of why should we learn about Pandas and Polars? Why 
both? Why not just learn one or the other, especially since Polars 
is much faster than Pandas? Because the install base of users of 
Pandas is massive. It was released back in 2008, while Polars, 
although faster, was released in 2020. Your clients or other 
developers you work with might be used to using Pandas.   
Lastly, how? How are we to learn about polars and Pandas together 
here in Level 11? We'll have exercises that we'll do together during 
Level 11 in order to understand how to install and use both Python 
libraries. In addition to the exercises that we will do during this 
Level to learn about Pandas and polars, at the end of Level 11, we 
will have a quiz to reinforce everything that we learned together. 
 
 

The Complete Python Book 
 
506
 
 
 
 
 
 
 
 
 
[I/G/A] Installing Pandas and Polars 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
507
 Resources for this Chapter: 
Mac Installation: 
https://www.youtube.com/watch?v=RFeIn2ywxG4&t=292s&ab_chan
nel=DaveEbbelaar  
Windows Installation: 
https://www.youtube.com/watch?v=itVBw_rNYjI&ab_channel=Geeky
Script  
Linux Installation: https://www.youtube.com/watch?v=7-
naqq9fvZE&ab_channel=ProgrammingKnowledge 
As with any Python library, when you want to use it, if you don't 
have it, you need to install it. And depending on the platform that 
you are using to follow this course, or just working on your own, 
you need to make sure that you have it installed. If you're using 
Anaconda, it already has prepackaged these, these two libraries. 
One is Pandas, you see two Pandas here, and polars as a new kind 
of a way to load and work with data.  Polars does not support 
everything that Pandas has, but it is much faster and more 
optimized. We're going to compare both in this section. Every 
single exercise that we're going to do will be done in both libraries, 
Polars and Pandas. 
Here is how to install these libraires in your EDA: 

The Complete Python Book 
 
508
 
Please note, if you are installing through terminal/CMD you won’t 
need to use an exclamation mark. 
 
As per convention, we will import pandas and call id pd. Of course, 
you don't have to follow these rules, but when you start working 
with other data scientists, they are already used to this convention. 
Now to import polars, I'm going to use and import polars. And to 
import polars use polars as pl. Polars will allow you to read CSV and 
do all those great stuffs that we're going to do with Pandas as well. 
Now that you have these two Python libraries installed in your 
respective environment, you can start working towards the 

The Complete Python Book 
 
509
chapters  in this in this section. Just bear in mind, if you're not using 
Google Colab and you're using the local system, The installation of 
these libraries might vary, so it might be a bit more difficult to 
install on Mac than, for example, on Windows, and vice versa. 
 
 
 

The Complete Python Book 
 
510
 
 
 
 
 
 
 
 
 
[I/G/A] Loading Data Using Pandas and Polars 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
511
 Both libraries that we are going to discuss in this section, pandas 
and polars, have great capabilities to allow us to work with 
different sources of data. It can be CSV, it can be a TSV, or even SQL 
data and Excel file. 
These two libraries allow you to load that data inside your Python 
program and start working with it, making some calculations on top 
of it and so on.  In this section, we'll start by learning how to load 
the data, because that's the starting point. Before we start applying 
any of their respective capabilities on processing the data, we need 
to load it. 
 
 
I’ll use the dummy data list for an example. Now, you can name 
these anything you really want. Now, the idea is to have some 
names or some strings.  

The Complete Python Book 
 
512
 
You can use states, you can use countries, anything that you like 
(instead of these exemplary names). However, the first number will 
represent indices. It's good to have like order numbers like one, 
two, and three. In Pandas, you have  something we call DataFrame. 
DataFrame is an object that allows you to load the data inside of it 
create data with it, and even create your own DataFrames. And 
DataFrame is a kind of a packaged information inside of the Pandas 
ecosystem. So, if you want to do any computation on top of it, 
visualize the data even do some calculations, it should be in some 
form of a Pandas object. 
 

The Complete Python Book 
 
513
But besides DataFrame we have another format called Series. And 
we'll talk about both and the differences in the future chapters. But 
for starters, DataFrame is the basic data structure used in Pandas. 
And as you can see here, it contains some indices and every single 
Part of data frame. We'll see that a bit later. 
We'll contain rows and columns, so columns will always be named. 
And if you don't define the name, Pandas will do that for us. If we 
provide this list of lists that I just created to the DataFrame, we'll 
do the data to design this to some variable in a second. If we just 
do this, it'll create our data frame, and as you can see, it has some 
indices.  
 
For now, it has 0 and 1 as a column.   So, if you don't specify column 
names, they are going to be specified for you. And because 
DataFrame does not know what is the data type, or what is the 
reference to this data, you need to make sure that you provide that 
information to it, because if you don't, it's going to be named 0 and 
1. 
When you are creating or loading DataFrame,  you can provide 
another, a variable, or another argument called columns. And 

The Complete Python Book 
 
514
under columns, that's going to be a list, you can provide a set of 
values that are going to be considered. As your column names. 
 
So here I'm going to define ID. And under the second column, we're 
going to define it is a Name.  You see now our data frame, instead 
of using zero and one, will have this ID and name.  And now we can 
reference this in much more robust way, such as, I want all IDs. I 
want all names. I want names that start with A. 
 
Everything of those operations can be done using just pure Pandas.  
And in the last section on NumPy, we tried to load a CSV file that 
we are going to load in a second in this video.  Using pure Pandas 
and pure NumPy. Now, you saw that it's difficult to do. You need to 

The Complete Python Book 
 
515
specify a lot of information to be able to load it in an okay way, so 
workable way for us.  
 
Now, all of that will be handled automatically in a split of a second 
with Pandas or We'll see that in a second. So, I'll do this and define 
data frame. pd or Pandas. You can name it as whatever you want 
from list.  And this is going to contain our data frame.  Now, this 
has our data frame and we can start referencing it and so on.  
 
Before we continue, let's see how to do that in polars. So in polars, 
it's really similar.  I would say that basically the same. And instead 
of using this PD, I'll just use PL. And Polars has the same data frame 

The Complete Python Book 
 
516
structured as our Pandas. So DF, Polars instead of Pandas, and 
instead of PD, I'll just say PL.  
 
However, Polars doesn’t have the same attribute names as pandas. 
Take from Pandas, and they used  new terms to define. So instead 
of columns, we need to define a new keyword, which is called 
schema.  
 
Like to for example, SQL.  And when I do that, you will see that 
df_polars will have the same information. But now one interesting 
thing happened right here. Polars gave you more information than 
Pandas. And let's analyze that together. So first off, if I just print out 
here in Pandas, I'll just have all the information right here.  

The Complete Python Book 
 
517
 
Now in Polars, Shape is printed as well. That's the first.  The second 
thing is for every single column, you will automatically get what is 
the data type. So, in this case, it's string. And because it's a string, 
it's going to be under quotes and ID. Will be associated with our 
column ID.   
 
So that's an extra line of work for us.  Polars does this for us.  And 
it can just define, okay, so this is ID. And now I can start accessing 
data with that information to us.  So yeah, basically that, that’s 
something that that's the main difference.  

The Complete Python Book 
 
518
 
Yeah, so polar sometimes Pandas in most cases, but then this 
information is amazing and that's fine. However, you’re not going 
to do this in a real world You won't define like list of lists Well in 
most cases and then go and use DataFrame to load around it. That's 
why we need some kind of a source of information and that's we're 
going to name it reading external files,  data or files  using Pandas. 
 
This will allow you to load any amounts of data to your Python 
program and then start working with it.  Both libraries have many 
functions to do that. If you type just read, underscore, you will see. 
You have CSV, Excel, Feather, some of the things that I never heard 
about, HTML, JSON, Parquet, PQL, SAS, and so on, even SQL. 

The Complete Python Book 
 
519
 
From the last section, we have this sales data. csv. So it has four 
columns, month, product ID, sales, revenue.  And this is just the 10 
entries out of everything that we have. Its CSV, I'll use read CSV file 
right here.  
 
Reading CSV has so many arguments that you can provide, and it 
can be a bit overwhelming. There is a reference online that you can 
always go and refer to in the Pandas documentation.  

The Complete Python Book 
 
520
 
So that being said, I'll provide our sales data. csv, which if you check 
that is the name of our file right here, and if I load it as it is, all extra 
stuff that we've done in the previous section is automatically done 
for us. So right here you have the full data set for us. And I'll just 
define it right here. 
 
PD CSV loaded. Now we know how to do that in Pandas. Is it a bit 
of a different when we speak about Polars? Not really. So I'm going 
to change this to PL and then PL has read CSV as well. And if you 
check what are the arguments of that, it still has similar number of 
arguments. 

The Complete Python Book 
 
521
 
New columns do, does it have some specific data type and so on. 
But in most cases, as before, providing just a path to your file will 
be enough. So, if we visualize what is the structure of this loaded 
file, it will be the same. But to things that we mentioned before, 
now we are going to have this data information, and this won't 
create that additional file for us or additional column for us, stating 
that it is ID. 
 
In this case, it's going to have a month and we can add additional 
column that's going to work as an ID. But yeah, this is it. So this is 
just a pure idea of how to load it. Now. The loading other files or 

The Complete Python Book 
 
522
loading other information is similar. So, if you have an Excel file, 
you would be able to go and do pd read_excel.   
 
And then you can provide like path to the Excel. Or is there a sheet 
name that you want to read? If not, it'll read all sheet names or the 
first one depending on the library. But in most cases, you can 
provide even a sheet name if you have multiple. So, you can read 
all that depending on the file, you can read both of them or 
bullshits in different variables that you can store and work with. 
 
Now you can read JSON, for example, if you have a JSON file, that's 
going to do some configuration, for example, for you, and then you 
can provide a path to it and then work with it as a dictionary or a 

The Complete Python Book 
 
523
data frame inside of both Polars and Pandas.   So that's basically it 
for loading the file. 
 
Now we have this file loaded. It's time to start performing some 
analysis and learn internals of both libraires. Now, in the next 
section of this course/book, we'll talk about ETL, extract, transform, 
and load, and give you more information of what it goes in from 
starting the loading of the file, what we did just now, to actually 
doing some analysis on top of it and some predictions at the end. 
 
 

The Complete Python Book 
 
524
 
 
 
 
 
 
 
 
 
[I/G/A] Reading Data in Different Ways 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
525
 Now that we have our data loaded, both in Pandas and polars data 
frames, it's time to see how to explore some pieces of this data.  
 
So far, you visualize just all the information we had in our polars or 
Panda’s data frame. Now, this file has only 36 entries and you can 
see it start breaking down and say, okay, I want to show all the 
information, but just some of them like at the beginning at the end.  
 
That's fine, but now, what happens if you have, for example, tens 
of thousands of rows in the file? You, of course, can't visualize all 
of them, and it would be difficult to find some patterns inside of 
that data.  Okay, so there are a couple of useful tools or methods 

The Complete Python Book 
 
526
that you can call on top of your data frames, no matter if you're 
using Pandas or Polars, it works basically the same. 
 
So here I have a Polars file. Let's start with that. And then we'll 
switch to Pandas in a second. The first thing is to go and call head 
method head by default, we'll show first five rows. of your data. So 
now it's time to analyze those first five rows, and you can see, here 
is the data that they have.  
 
Now, always, you can change this information from less to more. If 
you want to showcase first three rows, just provide ahead.  If you 
want more, let's say 10, then you can do that as well by providing 

The Complete Python Book 
 
527
more information to it.  So that's basically this, the structure of 
head method. By default, it's going to always be five.  
 
The same goes for Pandas. So Pandas, if you want to showcase first 
five rows, I'm going to switch this to PD and it works. Now you can 
see here the difference that Pandas will have the indices, in Polars 
not so much.  Now, this is fine, this is the beginning of the file. How 
about the end of the file or last five or n layers or rows? 
 
There is a function for that called tail.  Let's see how to apply tail to 
both of our Pandas and Polar's data frames. So, I have my Polar's 
data frame copied right now. And instead of head, I'll write tail.  Tail 
will provide last five or N things. 

The Complete Python Book 
 
528
 
If you check what is the argument, it's only one. And that gets the 
more yeah, the last N and letters or n rows. Now, as you can see 
here, numbers of rows to return. If a negative value is passed, 
return all rows except the last first, the first one. Abs of n.   
 
And you can go in more detail, read about it right here, but basically 
that's it.  Now you can also do that with. our Pandas. So, let's do 
that. And here I'm going to call pd instead of pl. I know the names 
naming convention will be better, trust me, because when we start 
applying that to the real projects, you can choose any of those two 
libraries. 
 

The Complete Python Book 
 
529
 
So go there and analyze first couple of rows, last couple of rows to 
see if there are any patterns, just as you can look at it and see.  But 
this is descriptive, I would say, but not so much.  And that's why we 
have a function called describe. to make it more descriptive.  In 
pandas call describe on top of your dataset.  
 
Describe will showcase all the information that it can about product 
ID, sales, and revenue. For example, you can see count, mean, STD, 
which is standard deviation, mean, which is minimum, maximum 
value, and then 25 percentile, 50 percentile, and 75. However, the 
describe actually removes or doesn't show information about one 
of the columns.  

The Complete Python Book 
 
530
 
And that's our mount column because that mount column is in the 
format of strings. Unfortunately, describe only works with 
numerical features or numerical columns, as you can see right here.  
 
Then standard deviation here is really big and then we have 
minimum of 3, 000, maximum of 6, 000, almost 6, 000. And yeah, 
you can see already what the range of features is if you want to 
scale something, if you want to work with them. Now you can 
basically start building on top of that knowledge.  But sometimes 
you want to see if there are some missing values. 

The Complete Python Book 
 
531
 
What are the data types? And of course, we are missing one of the 
columns, so we don't really want that to happen. For that, we have  
another function which is really informative for us, and that goes in 
a pair we described, which is called info.  
 
Here we have information of what is the number of entries that 
indices are going from zero to 35 and we have four columns now, 
four columns, column names. Does it have some non-null count, or 
does it have some null values? And then what is the data type?  You 
see here that month is our first column, and that is going to be an 
object because that is a string.  

The Complete Python Book 
 
532
 
And then we have int64 by default, that is for our product ID, sales, 
and revenue. Our data and here one new feature that Pandas 
added is adding how much of the storage you need to load this 
data. In this case, it's 1. 2 kilobytes. And if we say verbose to true, 
let's see if it change not because the verbose is true by default. 
 
But if we change it to false, it will Remove all the extra column 
information, but provide only the necessary information that is a 
minimal information used to report the structure of us.  Okay, now 
this is cool, but let's say you want to locate some of the. Indices or 
some of the rows inside of this, there are many ways and methods 

The Complete Python Book 
 
533
to call and do use on in Panda’s ecosystem to recognize or load a 
specific row or specific item inside of that data frame. 
 
And we'll talk about all of those methods in the future chapters, 
but it's important to know two most basic of them - LOC  and ILOC. 
And the difference between those two.  
 
Now, the first thing that we are going to call is LOC.  The LOC will 
get, will get a certain argument. Accessing a group of rows, any 
column by label or boolean array. 

The Complete Python Book 
 
534
 
This means that what is the label or ID and using those to  basically 
use and get that value. So sometimes your index will be named 
sometimes, like for example, if we change the month, and then you 
can lock it by using January.  So now we have index of zero, which 
is going to locate our first entry.  
 
This is going to be January 101, 197, and 3, 940. So, to make sure 
that we are accessing the right data point, let's visualize the first 
five rows with head that we learned before. As you can see, that is 
our first. To access the third entry, or forth row, use [3] 

The Complete Python Book 
 
535
 
Now there is another one which is called ILOC. So, if I called PD CSV 
loaded, ILOC now it still accesses it by looking at in indexes. But now 
that in index indexes not really a value. So, if it is a string, you won't 
be able to use ILOC with a certain string, like January. So what ILOC 
does, it basically goes and counts what is the index of that label. 
 
It's a bit weird because in this case it's going to be the same, but if 
you, for example, had a February here, you would tell it 3 instead 
of February. So if we provide 3 right here, we should be getting the 
same row as before. 

The Complete Python Book 
 
536
 
Now, if you change the index, this will be, for example, becoming 
our index.  And then when you call January, you would return these 
three items right here. And that can be done with LOC. 
 
And we'll do that in much more detail later down the road. But if 
you had for example, January on the index of two, you would be 
able to recognize that and only access this row by using ILOC. So, 
lock will use explicitly what is written here. And I look, we'll use the 
order or index of index, basically.  

The Complete Python Book 
 
537
 
A bit overviewed, but those are useful to recognize.  Now, in Polar’s 
ecosystem, you still have a describe. And if you have PL CSV loaded, 
describe, when you call it, it will do the same, but in more detail.  
And as you can see here now Polars goes even further and counts 
for string as well.  
 
Okay, so here we have month of how many months does it have 
some now. So right now, it combines both information from info in 
pandas and describe. Now we have min, max, median standard 
deviation, null count, everything under the same roof.   
When it comes to checking out the amount of columns and the data 
points, you can go and use PD CSV loaded dot shape and that shape 

The Complete Python Book 
 
538
will show you how many rows and how many columns you have 
where in the Polars ecosystem you have something called schema 
and that's not present in Pandas but only in Polars. 
 
Checking the polar’s shape works the same as in Pandas. So now 
you know how to check what is the structure of your data, how to 
check the main statistics of the data. At this stage we know how to 
load the data set and to perform a couple of first analysis steps on 
top of your data. 
 
 
 

The Complete Python Book 
 
539
 
 
 
 
 
 
 
 
 
[I/G/A] Exercise 11.1: First Pandas/Polars 
Exercise 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
540
 Resources for this Chapter: 
Colab Resource: First Pandas/Polars Exercise:  
https://colab.research.google.com/drive/1-NQR--_zoGzw44-
M_1ZAgrtVodkg7ZMB?usp=sharing  
Welcome to the first exercise of the, this section on pandas, or, and 
polars. So, for this exercise and any that we are doing in the future, 
you can choose what you want to do, either pandas or polars. The 
goal of this is just to introduce you to Polars because it's a new thing 
and most data scientists are using it. 
 
And don't worry about data sets. I'll show you one amazing trick.  
This exercise is five parts. From data loading to some basic 
information structuring. Everything that we covered so far. But one 
thing that I didn't intentionally cover was data loading with URLs.  
So far, we just uploaded the data in a CSV format and it magically 
worked by using this read CSV file. 

The Complete Python Book 
 
541
 
You can simply provide a URL to publicly available CSV or general 
file and you can directly provide it to read_csv function. 
So, the first step of this exercise is just that, load this data.  After 
that, use functions that we mentioned so far to extract basic 
information about the dataset. And then after that you go and do 
some column analysis and see if there are missing values. Okay, 
good luck with this. 
 
 
 

The Complete Python Book 
 
542
 
 
 
 
 
 
 
 
 
[I/G/A] Answer 11.1: First Pandas/Polars 
Exercise 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
543
The first thing that I need to do is to execute the first cell.  
 
We have 144 rows and if we have months and passengers or 
number of passengers per that month.  The next step is to show 
first five rows. If you remember, that is our head function. By 
default, you don't have to provide any additional information to it. 
We'll show that.  The basic information or the second task for us is 
to use the info method to get a summary. 
 
Now this is something that we want, we have, we want to see for 
each of the customers, or sorry, each of the columns, what we can 
or can't do. In the case of the passengers, we have the integer, so 

The Complete Python Book 
 
544
just a number. And we have month, which is the object because it 
is, as you can see right here, a string.  
 
This will provide information about the data types and numbers of 
null entries if there are any. In this case we don't have any.  The 
next step would be to provide describe.  
 
We have 144 mean is about 280.  And then we have standard 
deviation of 119, which is a lot on this number. Now we have a 
maximum and minimum number of passengers, which means that 
some months are crazy in the sense of the passenger numbers, 
while some others are not so active.  

The Complete Python Book 
 
545
 
Then this will provide you with a lot of information about statistics, 
which it did.  Now select a single column from the data set and 
display the first 10 values. Okay, so what you can do is we can go 
and say data, passengers,  and then it will show all the passengers 
and what they can do is show first 10. 
And this is basically that what it asks us to do.  Additionally, use the 
value count method to use the frequency or unique values in the 
selected columns. Okay, so let's see how that works, because so 
far, we didn't use this. So, for you, if you got stuck here, the best 
solution would be to go to some documentation and see how value 
count actually works.  
 

The Complete Python Book 
 
546
Now, value count will provide. Provide us with values and I can go 
and provide like this passenger.  Okay, provide it right here. And 
you will see that on the left-hand side, we will have a specific 
number of passengers and on the right hand side, how many times 
that appear. That's cool. So this is basically the answer to that. 
 
Not so informative just yet, but it has some months that are the 
most active and, in these cases, some months that are repetitive. 
In this case, 2 229 passengers repeated free times. We had three 
months of that many passengers.  What we have now to do is to 
call, is now to see whether or not we have some missing values. 
 

The Complete Python Book 
 
547
When you call this, it will provide true or false for every single value 
inside your data frame. Now, this alone is informative if you want 
to go by hand and look at, look inside of it. 
 
However, what you can do is call sum, which by default will sum 
like this. X is zero, and it will tell us whether or not there is some 
missing values. 
In this case, we don't have any missing values. Okay, that's it, the 
solution for the first exercise of this pandas exercise. 
 
 
 

The Complete Python Book 
 
548
 
 
 
 
 
 
 
 
 
[I/G/A] Understanding Series 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
549
 So far, we talked about a structure of data called data frames, and 
both in Polars and Pandas, you have the same way of abstracting 
the data into those data frames.  And the knowledge about data 
frames is useful when you start working with massive amounts of 
data. So essentially when we tell, when you say data frame, it's a 
table of data. 
It has multiple columns, it has some data types associated with it, 
it has indices, and sorts of stuff related to it.  But there is another 
way to represent the data called series. The series is just a single 
point, or I would say single column, inside your data frame. And it 
is suitable when you have time series data, when you have just one 
column, one list of data that you want to work with. 
Series does not have all of the unlocked opportunities that data 
frame, for example, has.  It allows you to do the massive amounts 
of computation on top of that one row, one list of data that you 
might have. So right here, I in the previous file that you will have 
the access to inside of inside of this chapter as well. 
 
Let's define a new section called Series, and this has an option to 
convert a Python list, for example, that we have here. That's going 
to be pd. series of simple list. Let's start with that. Now when you 

The Complete Python Book 
 
550
check as pandas, it will be basically looking the same as the two 
columns, but not header. 
 
We don't have the column name. So, you have indices that are 
automatically associated with every element, and it has a data 
type. Now, if you go and check the type of that, it’s going to be 
pandas. series. series, not DataFrame.  So that's the first difference. 
And now if you go and check what are the methods unlocked for 
us, you have many that you can append, you can add, aggregate, 
all sorts of stuff that we are going to cover in the future.  
 
When you have continuous amounts of data that you want to 
convert inside of inside of some Python object that is not native, 

The Complete Python Book 
 
551
for example a list, and you want to do some aggregation on top of 
it, you want to do some computation, lagging calculation and 
everything, that Is allowed using these two libraries, but in a just a 
quick way without creating additional information around.  
 
Then you have this Polars, we're going to define together now. 
Polars that has the same thing going to be called Serious.  And when 
you define it, the first thing that you need to see as a kind of a 
difference is the name. Instead of just providing the data source, 
you need to provide the name. And this is going to be an example 
of series.  
 

The Complete Python Book 
 
552
When we check our data source, now you see that this has the 
name because we provided to it. It doesn't have the indices that we 
did before, but you still, you’re able to access individual elements 
in the individual way that you want.  
 
So now if you want to access, for example first element in let's start 
with pandas. So as pandas, and you want to access the first 
element, you can with this zero.  And as we talked before with the 
lists, you can slice this in different ways. If you want to go and do 
as pandas from one to four, that is unlocked for us that we can use 
that. 
 

The Complete Python Book 
 
553
And you can use this as a kind of a subset or sub element of our 
panda’s serious data frame and a serious object.  Now you can see 
that this operation right here created another error. Series object 
that we can use and utilize in the same way as we did with normal 
one, with the original one that we just created. 
 
When you slice them, you can, but it's going to create additional 
object that you can work with in different ways.  Now, for polars, is 
a bit different. In polars you can access the one individual element 
in the same way, no matter which one.  But slicing does not work 
in the same way.  
 

The Complete Python Book 
 
554
And if you go and define it like this, it will work. But it has a bit of a, 
like a downside, which is slower. But if you want to use the 
complexity and the speed of powers, You are going to use slice, and 
the slice will provide you what is the offset, what is the first one, 
and what,  until which element you want. 
 
And this is going to give you the free elements that we want to get 
as well.  Just bear in mind, this, as you can see is length of the slice. 
is going to be the length, so number of elements that you want 
from that point on, and not like until which element you would like 
to achieve that. This is a bit different, so instead of using 1 to 4, you 
just say from which element or index you would like to do that and 
how many of the elements you like to, do you have that.  

The Complete Python Book 
 
555
 
This is amazing, right? And it allows us to work with different data 
types and different data sources in a really compact way.  It also 
allows you to call a lot of different methods on top of it, or it has 
some attributes that we can use to help us with the different 
operations. So let's call accessing data attributes.  
 
Data attributes can be anything from name, shape, size, and stuff 
like that. So if we go and use pandas, and here, when I call this, I'll 
have a lot of stuff that can be called. One of this is data type, that 
is going to be derived from our data and it's going to be int. 64.  
Besides this, let's copy this maybe two more times.  
 

The Complete Python Book 
 
556
 
Now, you can provide the name also in, in pandas, but in a different 
way.  For Polars, it's a bit of a similar story. You have Polars, that is 
going to be data type, as for data type, and that it's going to be 
extracted as an integer 64, but now the object and not only the 
string that is named.  
 
You can call len to find out what is the amount of elements inside 
of the serious object.  We didn't check this, but if you call Polars for 
type, you'll see that it's same as for in  pandas. 

The Complete Python Book 
 
557
 
Speaking of built-in functions.  Both of these libraries, have the 
same set of functions that we can call on top of their objects. You 
have s_pandas or s_polars, and we have an option to call sum on 
top of it, for example, if you want to sum all elements inside of it. 
 
Then you have the option to call mean.  When you want to calculate 
the average and also one interesting thing you can call unique to 
on top of it to get unique elements.  

The Complete Python Book 
 
558
 
That’s why we have unique. The same set of functions exist in 
Polars as well.  
 

The Complete Python Book 
 
559
 
 
 
 
 
 
 
 
 
[I/G/A] Dataframe Operations 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
560
 We learned about DataFrame and Series, two ways to represent 
data in both pandas and Polars. But we didn't discuss more details 
on how to apply some operations on top of data frames. 
 
Now I have my data loaded inside of this of this Google Colab. Now, 
if you check the data frame of pandas, one thing that we noticed 
before is using that information to actually have that index as 
generated by our pandas. 
 
Let’s maybe use month and see if we can use month as our index. 
So, if I go on that and call setIndex; it's intuitive. setIndex will allow 
you to go and column you want to set as an index by its name.  

The Complete Python Book 
 
561
 
However, in pandas, In most cases in polars as well, the operation 
that you apply on top of your data won't affect the data 
immediately because it is a barrier of making a mistake.  
 
What needs to happen is we need to either create a new object or 
do something called in place. So, if you create an object and have a 
data that is a bit larger than 1. 2 kilobytes, you’re going to create a 
double that. So that alone will. use and consume a lot of your 
memory, which might need be needed for some other operations 
on top of the data.  
So here we have this inplace equal to true. By default, it's false. And 
when I call this, it won't showcases the data again. But if I go and 

The Complete Python Book 
 
562
showcase the head, for example, now It has this option where, or 
now the option is applied.  Now you can either reset index as well. 
If sometimes you apply some operations, create sub-indices and 
stuff like that. 
 
And then indices are all over the place. You can restart them. Now 
we don't have to do that because we just did, but you can. So, for 
example, if you go, let's test it out, reset index.  And then just do 
this. It will go back. So go back to the original one. Now, this is not 
applied because we need to have this in place through also here to 
make sure that this reset index took the care of our resetting the 
index. 
 

The Complete Python Book 
 
563
If you messed up and did something like this or created a different 
part of your data in a different part of your program, sometimes 
resetting the index is necessary to make sure that everything goes 
from zero to whatever amount of indices you might have. Okay, 
let's comment this out so I don't have this reset index here. 
 
One quick note before we continue in the couple of Chapters 
before we talked about LOC and ILOC. If I want to use LOC and 
provide zero as an index, now zero is not there because now our 
indices are actually months. So, if we put January.  I can do that and 
now it will provide free entries for that because we have free 
indices for January. 
 

The Complete Python Book 
 
564
It's not unique. So yes, it's not a good in this index as well, but it can 
be done.  Now, the difference between ILOC and LOC will be 
evident here. ILOC does not work with values as we said, but it 
works with order of index.  
 
Polars does not have that option by default inside of it. So you can't 
just simply go and set the index, because if you go there, and let's 
call this PL set index, you will see that it will throw an error, let's 
say month again, because it will tell us that data frame object does 
not have setting the indexes as a kind of an option. 
 
It's a hacky situation, but I don't recommend it. So, if you need to 
change indices, just go with pandas, it's much better supported for 

The Complete Python Book 
 
565
that.  I'm going to create a new cell and paste the solution from 
Stack Overflow. Polars has the option to go from pandas. 
 
So, create a from pandas like data frame to Polars data frame, but 
it has also to pandas. What you need to do, you’re going to convert 
it to pandas, send the index, and go back to Polars if you want to 
change that.  I don't recommend you do this, but there is an option 
to do that. So, the same goes for resetting index as well. 
 
Besides indexing, the slicing is something that is really important 
when processing your data. We talked about slicing in pandas, for 
example, and let's use sales data.  So this works with pandas, even 
though we changed the indices. 

The Complete Python Book 
 
566
 
The slicing works with positional stuff like rows or columns instead 
of just going there and using the index that we now change to 
January. But if you want to go and select specific columns, you can 
do that as well. If you want to say sale, for example, only you can. 
And it will provide the month is now index, and now sales is this 
what we extracted.  
 
One interesting thing which we learned in the previous Chapter, 
every single column is a series, and this one becomes a series as 
well.  If you take a look at type, it will become a Python append a 
series because it is just a one column for the whole data frame. If 
you check that for the whole sales data PD, it will be our data frame. 

The Complete Python Book 
 
567
 
Now, when you go here and put this in square brackets, it still 
works. and now it changes because it will be a kind of a data frame 
of data frame. So, if you check the type of this, it won't be Series 
anymore. It will be a kind of a smaller data frame.  This data frame 
can have multiple columns as well. 
 
For example, if you want just to extract sales and you want to 
extract revenue, so you can list it right here as a revenue.  You can 
select a couple of columns here that will allow you to basically do 
that.  That’s it for recognizing or doing a partial selection of that. 

The Complete Python Book 
 
568
 
In Polars, slice option still works when you can go and select dot 
slice with all of that. And in Polars, one thing that you need to do is 
this, when you have sales data of PL, you are going to go and select, 
and this select will take a list of columns, so columns to select.  
 
If you want to select a couple of columns from your data frame, you 
need to use select statement in Polars. 

The Complete Python Book 
 
569
 
Accessing some information will be done on a kind of a queue or 
on a question. So, you want to do a rule-based selection of certain 
datapoints. In pandas, you can do that by simply going sales data. 
pd. And I know I didn't explain it just yet what I mean by this, but 
what's possible is to use this as a kind of a sub argument and ask, 
okay, where sales is above, let’s say  150.  
 
This will showcase only where the column sales, is above 150.  And 
when you go and check the amount of data, you can call shape on 
this.  

The Complete Python Book 
 
570
 
It will showcase it now has 36. So, if you go and define 200, for 
example, it will show 23 because now we have less data where 
sales are above 200. Now you can define this and then select 
months, for example, that are, there and stuff like that.  Let’s do 
the same thing in Polars. 
 
In Polars, you are going to go and say sales data, PL. And now you 
have an option to go and call filter.  There is a filter function as well 
inside of the pandas, but it requires more things to build on top of 
it. And we'll talk about that in future of this section.  Now, this filter 
will take basically the same question. 

The Complete Python Book 
 
571
 
So, I want to take sales data of Polars, where the sales.  is larger 
than 200.  And it will showcase the same thing.  Now, instead of, as 
you can see, 23 elements. Instead of just straight going through 
that bracket, you're going to use filter, which sometimes it's more 
elegant solution. But yeah, now you are not locked to only follow 
this solution as well. 
 
And if you remember, with NumPy you could have used and or 
signals as well. In the brackets, and I'm going to say, okay, and for 
example, let's paste this. So we don't write everything from scratch 
and where product ID is equal to  103.  

The Complete Python Book 
 
572
 
So right now, you have only entries where for product 103, we sold 
more than 200 samples.  How cool is that?  So just simply in a, yeah, 
simple statement, you can check that. Now, OR works the same 
way, where instead of this AND, you will use Oops. Now, of course, 
without anything, it will break. You will use this. 
 
And suddenly you have more data, of course, because now it's 
either looks for sales of 200 or where the or where this is equal to 
one, one or three. Sometimes it will go less than 200, as you can 
see right here, because it is one or one or three for the product.  
This works the same way in the filter statement right here. 

The Complete Python Book 
 
573
 
If you put it in the brackets. And now you can put here and let’s 
copy and paste this.  And instead of using this, we're going to use 
product ID.  And I need a lot of uppercase P is equal to 103.  So, 
when I call this, it will just select a couple of the examples where 
it's equal to 103 and sales are above 200. 
 
Now it works the same as with a pipe and that's it. We have this 
option with query method to go and do with pandas, but you can 
read more about it in the resources of this chapter. However, I, in 
most cases, I'm going to use what we did here.   

The Complete Python Book 
 
574
 
 
 

The Complete Python Book 
 
575
 
 
 
 
 
 
 
 
 
[I/G/A] Dealing with Missing Data 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
576
As a data person, data scientist, data analyst. One of the most 
important skills that you can learn is handling bad data. It can be 
outliers; it can be missing data or information that we're going to 
cover briefly in this video.  Now, I know handling missing 
information is a huge area. It can be covered in books, in courses 
individually, but we are going to cover a couple of techniques that 
you can use Pandas for or Polars to handle information that is 
missing in your data.  
Handling missing information will tell you how quality of your 
results you can expect. If you have bad data, you can't expect 
better results. And that's illogical to say, but in most cases, people 
expect more from their algorithms than it can achieve.  Okay, so 
here on the screen I have my sales data loaded. 
 
It's going to be potentially used. to test some of these approaches. 
But to plastically explain some of the techniques, we created the 
toy datasets.  Pandas’ Pandas dataset and Polar's dataset. And as 
you can see, they have A and B columns, and they have just three 
entries. And some of the data is missing, like you can see all of that 
transparently right here. 

The Complete Python Book 
 
577
 
Now, speaking about missing information, the first thing that you 
can do, which is not suggested, is automatically removing those 
entries, or dropping those missing values. So, if you go and just call 
drop NA on our pandas data frame, it will just leave one row, which 
is the first one, because it does not contain any missing 
information. 
 
Now, from three entries, we lost 66 percent of your data. 
Sometimes you will learn how to handle it better, but in most cases 
when, for example, missing a name, or missing a surname, or 
missing a country where somebody is from, you can't really put that 
together and pull that information from nowhere and put that 

The Complete Python Book 
 
578
instead of missing information you can't do anything better than 
just either removing or starting to collect more and more data to 
handle those missing information from the domain expertise. For 
example, there is a famous Titanic data set that everybody has 
been talking about in the Kegel. So, whenever you start some data 
science journey, before or after you're going to start Speaking or 
trying to do or solve any data set. 
It has a lot of missing information and some of the columns that 
you can find there are name, surname, cabin, tickets, and stuff like 
that.  In most cases, you, the best to either not use those columns 
or just remove those entries, those Titanic passengers. Because you 
can't just from thin air imagine that this is from California or London 
or somebody else. 
And this is called Maria or Luke or whatever. So those kinds of 
information that are personal, that you can't go and find out 
without asking the proper person, you are better using this drop a 
function.  Now, in Polars you have similar function called pl, and 
with i, I called it pl pandas, NA, oh let's change it. 
 
Pl polys, LA NA. Yeah, we know what you're doing. Okay polars, N, 
A. And it has drop nulls.  Instead of drop N, A, it will drop nulls. And 

The Complete Python Book 
 
579
as you can see, the same result here, which will allow you to leave 
only with one entry point. Now, instead of dropping the 
information, you might go and say, okay, let's fill that information 
in. 
 
If you have the proper knowledge and understanding of your data 
set. If you, let's create a new segment and say, filling the missing 
info. And instead of just dropping everything, what you can do is 
pd pandas na, fill in.  And here you can use zero.  This won't drop 
it, but here we'll have two zeros telling us that this was indeed 
missing, but now we have that as a kind of a non-missing 
information.  
 

The Complete Python Book 
 
580
But what is this feature? We don't know because this is a toy 
dataset, of course. And imagine that you are, for example, having a 
weather data that you need to fill in. You can't simply go and put 
zero because putting zero on a, like a weather data, it means 
something. It means that it's zero degrees in whatever Fahrenheit 
of Celsius. 
 
So, whatever you do, you need to consult somebody as an expert 
system or the expert expertise that has expertise in that area to 
learn from them how to fill in that information. So just bluntly 
putting zero might not be the best option.  And this did not change 
the structure. Make sure to either create a new object or you can 
go and do in place true, that will go, that's going to fill in that 
information for us. 

The Complete Python Book 
 
581
 
We can go and then define this, for example, filled.  
 
Now, similarly, we have the option right here and that's going to 
take PL polars. And that we have fill none as a kind of an option 
where you can put zero and this will a fill in that information.  Now 
this has two options in first one sometimes works, sometimes not.  

The Complete Python Book 
 
582
 
Why doesn't? So, if you go here and check the arguments. You'll 
see the value and fill floating point NAN values and expression 
values. Instead of using this, it will fill in with just null values. Okay? 
It won't fill with explicit numbers. So for that, use fill null instead.  
So now you know how to fill in with the basic information. 
 
Now you can put any number here. You don't have to put zero, of 
course.  Then there is another amazing stuff that you can do, which 
is called interpolation. Interpolation is a method that is most likely 
going to be the one that you're going to use in your project. And 
that's going to look at the data points around the missing 
information and use that as a kind of educated guess. 

The Complete Python Book 
 
583
 
To fill in that range of information. For example, if in a weather 
condition, if you have yesterday a certain degree, let's say 27 
Celsius, today is missing. Tomorrow, you have 28. You can suddenly 
have zero in between. You can have some drop, but you don't have 
that rule that is immediately there.  
To do that, you have this pd. pandas. And then you can call 
interpolate on top of it. This will use that information and fill in the 
information, because how it's going to do is going to do mean 
between these two information, or if it's the last one, it's going to 
copy and paste.  So now you have. 
 

The Complete Python Book 
 
584
Other rules that you can find here, method is linear, which is going 
to do just that, as I explained. But you have different ways to do 
that. Now, of course, it should be in place if you would like to keep 
this change. And I would say that this one is the best to do 
interpolation on. So, if you want to do like a new variable, let's say 
inter, that can be done like this.  
 
Now, unfortunately, Polars at the time of this recording does not 
support similar functions like interpolation. So, what you can do, 
you can go and convert your Pandas, or sorry, Polars to Pandas and 
then do the interpolation and convert it back to Polars 
 
 

The Complete Python Book 
 
585
 
 
 
 
 
 
 
 
 
 [I/G/A] Map and Transform 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
586
 Transforming the data in some capacity is a crucial part of feature 
engineering and working with data in general.  Now, there are a 
couple of functionalities inside of Pandas, not Polars at the time of 
recording, that allows you to either transform whole columns, 
individual values, or even whole data frames in a single swoop.  
Those are called map, apply, and transform.  In this video, we'll talk 
about each of them and how to apply them to our sales data using 
only pandas in this video. So, the first thing that I did is define a 
simple function from our from Python that's going to double every 
value. So whatever value is going to be here, we are going to put it 
times two. 
 
Now, when you have like map, so this is the first, this is the first 
thing that we're going to learn. It's applicable only on series. So not 
the whole data frames. So if I wanted to, for example, double the, 
let's say revenue, because we suddenly wanted to do that, we need 
to access revenue  and it's going to return the series. 

The Complete Python Book 
 
587
 
And now what you can do, you can either call map and this map 
will take the function. You can go and use this double value, or you 
can define a lambda function. So, we talked about lambda 
functions before, but lambda function allows you to go define input 
and what's going to happen with that input like this in the one line. 
 
This is the same way as I did before with this double value.  So now 
this is. not in place. You can change the revenue or create a new 
column called double revenue or something like that. But yeah, so 
that is one thing that you can do. Another thing is to map our 
Python function and the result should be the same. 

The Complete Python Book 
 
588
 
It is, as you can see, which allows you to basically either use the 
lambda or more complex ones as a normal function. So let me 
comment this so we don't have this huge scroll.   Another thing that 
you can do is apply something, some change on top of certain 
column or certain row. Apply is more flexible and when you want 
to work on a different like axis, so rows or columns, you can. 
 
This actually works on a whole data frame as well. So let me copy 
this and here I can go and say apply.  Apply will take the same 
function. Let’s go with either double value.  double value. And what 
it's going to do is going to double everything in a single swoop.  So 

The Complete Python Book 
 
589
of course, we don't want that because you have March, February, 
and so on.  
 
But it's not in place. So, we can always revert.  Polars does not have 
this kind of a flexibility. Yes, it does have the apply function. You 
can go and test it out in documentations of Polars, but it's still here 
and there lesser and more flexible than this one. 
 
The transform is the last step that you can use for transforming 
your data. And in most cases you are going to combine, like 
sometimes when you go and let's say you want to do this  and you 
can define x's  of one,  you can go and define this.  You can go and 

The Complete Python Book 
 
590
define like axis of zero. And because we are doing that on a whole 
data frame, of course, it's going to be the same. 
 
You can go and define multiple things. Additionally, this can be 
done on aggregation standpoint as well. Now, transform is less 
flexible than apply, so it does not allow you the whole scale. 
operation as you find found right here. But in transform, you're 
most likely going to use with lambda functions. 
 
So let me copy the whole line and go there. Instead of this 
transform I could have just copied the name, transform.  This 
transform, as you can see, will take some function, and apply like a 

The Complete Python Book 
 
591
lambda. Then make some change. Top of it.  If you are making 
aggregation, this transform is amazing to combine with it. 
 
So for example, when aggregate to, so for example, when you 
aggregate data to together, you can apply this method on 
aggregated data, which is subsets of your data based on some rule. 
And that can be done to do some analysis. So here, let's test it out. 
S lambda of X. And x squared, that's going to help you with the 
same results, to achieve the same results as we did with So no 
matter what you choose, it's going to help you  calculate or do 
some operations on top of your data frames. 
 

The Complete Python Book 
 
592
I do not suggest doing this on the whole data frame, so do that on 
the Level of columns or rows, and then it's going to be fine.   
 
 

The Complete Python Book 
 
593
 
 
 
 
 
 
 
 
 
[I/G/A] Merging and Joining 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
594
 In most cases, when you start working on a different project, 
especially when you're working with a company for a project that 
is completely new.  You're more than likely to have data from 
different sources, like from email, from this call storage, from the 
hot storage, then you're going to combine them and becomes 
quickly an issue because you don't know how to combine.  
In today's Chapter, we're going to talk about only Panda’s way to 
merge and join data frames, because sometimes you will load 
multiple data sources in a different, from different areas of your 
system. And now when you have that, it's time to basically apply 
some joining method. So, you can work with a single file within a 
single file on top of that.  
So, the first method is merging.  Then we have merge, which 
basically means together. Then you have joins. We have inner join, 
outer join, left and right. We'll talk about all of them in a bit. When 
we start with the merge, the first step is basically you have two 
different data frames. Those are key. 
 
Those are toy data frames just for us to understand them better.  
Now, as you can see here, we have a key column and have value 
sum 5, 6. Now, I want to connect them together so we get the one, 

The Complete Python Book 
 
595
one method to do it. So here we have merge.  And as you can see 
here, we are going to provide two data frames, left and right. 
 
This is really important because there is a join on the left and the 
right. So we're going to explain that in a second. So I'm going to say 
DF one, DF two on. Then you need to make sure on which column 
that's going to happen. I'm going to provide that key, which is the 
name of the column, and then how, which is a method.  
 
So inner will make sure that it preserves all the values from every 
single column. Now, when you have left, for example.  it will make 
sure that preserves to prioritize the left. So for example, if let's say 
let's remove this and I need to remove three as well here.  

The Complete Python Book 
 
596
 
So I have a, b and then here I have a, b and c of values four, five and 
six. So now if I do this and call left, what's going to happen? Because 
my left is the one. It's going to preserve only keys that are  there in 
the left.  If you choose it's going to keep the right keys,  but then it 
will fill in the information for a value of the left one because we 
don't have that information. 
 
So we have only A and B and C is not existing.  The inner one will 
make sure to preserve where both merges together. So a, like a 
intercept of both.  So that's basically how you're going to do that. 
There is outer as well, but  in most cases I don't know how it's even 
outer like this. It makes sure that takes everything together and 

The Complete Python Book 
 
597
make sure that fill is an information, but in most cases you're going 
to go with left or right. 
Or inner. Outer I used maybe once in my career, maybe twice. 
Yeah, you don't need that one too much. So that's basically on 
joining. Now you have methods on what to preserve, on how to 
scale those things. What you can also do is do this in in pandas 
where you go and set index to be your key, because we define that 
as our key.  
Now we can join that, and now join will tell, okay, which is the other 
data frame that you want to, and in our case, that is df2. But we 
need to set index on df2 as well, because our index was 0 over the 
ones. Here, you need to define on, you can, but how,  which is 
inner. And we are going to get the same result. 
 
But in this case, this index will be the one that we are going to use. 
So merge will be per column, and this join will be per index.  Polars 
at this time does not have this option.  Now, there is another thing 
that we can do, and that is called concatenate. So when you go and 
call pd. concat,  you can do that strictly from that from data frame. 

The Complete Python Book 
 
598
 
So you need to call it from the pandas. And then here you're going 
to provide a list of  data frames that you would like to concatenate. 
So df1 and df2.  Now,  after that, if I just execute this, it's going to 
be a bit of a crazy situation, which is  But then you need to provide, 
okay, in what, which axis you want to provide, zero being this is the 
zero, one in most cases is going to fail, or not. 
 
In this case, it's going to be like this. So it's going to stack like this.  
Now,  if you want, you can select ignore indices also as a true. So if 
you want to concatenate them in any other way, you can say, okay, 
don't look at index, just look at the data itself. Yeah, that's an 
option, but yeah, in most cases you're going to do this. 

The Complete Python Book 
 
599
 
Another thing that you can do, which is stacking. So stacking is a 
really a common thing to do when we speak about data science.  So 
this works as the same as a stacking in NumPy. So we had a 
horizontal stacking, which is in this axis one, or vertical stacking, 
which is axis zero. So concatenation was basically stacking those 
together and not removing the items. 
 
As you can see, we got even missing values right here, because we 
didn't have that information. Okay, that's it for this video. We 
learned a lot how to work with merging, joining stuff, and then 
finally concatenating. 

The Complete Python Book 
 
600
 
 
 

The Complete Python Book 
 
601
 
 
 
 
 
 
 
 
 
[I/G/A] Exercise 11.2: Second Pandas/Polars 
Exercise 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
602
 Resources for this Chapter: 
Colab Resource: Second Pandas/Polars Exercise:  
https://colab.research.google.com/drive/1yk10_kkbPiHhDDSVl2t-
EL9Bd5e8GI0Q?usp=sharing  
 Welcome to the second exercise of this section. So far, we learned 
a lot about handling missing data or even transforming the data 
using apply, transform and map. This exercise will be just that. How 
to apply and transform and handle missing information from 
unknown data set. As I promised before, every exercise will have 
some of the new data sets that you can encounter. 
 
Some data set that you're going to load, and I prepared the loading 
for that because it has some quick quirks before. So the first 
exercise for you would be to load, test it out and use appropriate 
methods to fill in the information that is missing. After that, the 
second one is to transform it. 

The Complete Python Book 
 
603
 
Be creative here. No guidance here, because we are not doing a 
real data preprocessing. Just use some map or apply to make sure 
that it actually works.   
 
 
 

The Complete Python Book 
 
604
 
 
 
 
 
 
 
 
 
 [I/G/A] Answer 11.2: Second Pandas/Polars 
Exercise 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
605
I hope you had a lot of fun with this one. So, I loaded the dataset. 
it's a bit weird.  
 
So if you go and. look, for example, the first five rows, you will see 
that there are 80 28 columns. We don't have names. And that's why 
I use this header equal none because it does not have names. 
 
But now we need to handle these missing values, so first off, let's 
see if there are many missing values. So I'm going to use is Now, 
and then this one is going to provide true or false, but then I'm 
going to use my sum method that's going to tell me whether or not 
or how many missing values I have. 

The Complete Python Book 
 
606
 
And as you can see here, I have so many missing values. In some of 
the columns, even 200 of those are missing in some of those, just 
one. And then I have a 60 50 and so on. So, there are a lot of missing 
values in this data set. So, our task would be how to basically 
handle that. So how to handle this many data missing data. 
There are two approaches that we discussed. One would be just 
discarding all the missing values, and that will leave us with the data 
set with many rows of data just missing. So, if we look at the shape 
currently, we have 300, if we remove 200 of those samples, that’s 
going to be a lot. 
 

The Complete Python Book 
 
607
Missing or I would say removing all of this would not be a great 
benefit. If we go and use mean, for example, this will go and 
calculate the mean for every single column.  So what I can do right 
now and follow along, fill in fillna, and what I'm going to do is fill in 
with data mean. 
 
So instead of using just general zeros and stuff like that, for every 
respective column, I used its data mean.  Okay, so now that I have 
this, I'm going to create a new data object that's going to contain 
only data sets that has all  or none missing values.  How amazing is 
that? really simple in one line of code. 
 

The Complete Python Book 
 
608
Now, we don't understand what is behind this dataset because we 
don't know it. So yes, using just a pure mean on every single column 
might be a bad idea, but still, we can go around it with this. Okay, 
cool. And one more thing that I wanted to show And if I call isNull 
now, and sum it.  Now we have all zeros. 
 
Because we did this analysis and filled it. Okay, so now that we have 
this. Let's jump to the second task of today. And that is 
transforming our data. So, we have some data sets or that is around 
horses, maybe some competition horses. Now it's time to do some 
transformation on top of it.  Okay, so what we can do here, we can 
either use map or apply. 
 

The Complete Python Book 
 
609
You can choose both if you want. And for example, we have data, 
and we'll call adjusted column or whatever. It's going to be data of 
3.  And now we are going to map on top of it, a function. This free 
can be any column we are just experimenting here. Now, on top of 
this, we are going to apply lambda, which is going to take x, and 
then that x will be multiplied by 1. 
 
And to practice with apply, we can do a row wise mean, for 
example. Data, mean, row, and then that's going to be data dot. 
apply, and here we're going to call lambda row dot mean, and then 
here x is equal to.  Once you do that, we are going to execute the 
data to see what happened, and the very last column will be mean 
row, which is calculating the row, mean value for every single one 
of them.  

The Complete Python Book 
 
610
 
So that, that was the exercise you can, this was just my solution. 
The only important is to apply map and apply function. If you 
applied on a whole data set, it would be completely This was just 
an exercise for me and you to get our hands dirty with apply and 
mean.  
 
 
 

The Complete Python Book 
 
611
 
 
 
 
 
 
 
 
 
[I/G/A] Strings 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
612
 Resources for this Chapter: 
Regular Expressions Cheat Sheet: 
https://web.mit.edu/hackl/www/lab/turkshop/slides/regex-
cheatsheet.pdf   
 Working with data generally is a bit tricky. And now with ultra GPT 
fame and everything most companies are going to start working 
with text more and more.  And whenever you start learning about 
text and working with text, you will see the complexity of what you 
need to think about when you start working with text.  
And especially when a text is in a format of data frame, it becomes 
trickier to handle because it is not an easy task to do. So here I have 
our sales data that we used before, and we have one column that 
is text based, so month.  So here I'm going to call month, and this 
is going to provide us with our now, when you want to achieve 
something with text, the first thing that you're going to do is call str 
on top of your column.  
 
This alone won't do anything, but it will allow you to call a certain 
thing. In the spectrum of data. You can go lower, upper, and so on.  
I'm going to call lower. And as you can see, in a split of a second, 

The Complete Python Book 
 
613
everything become, became lower.  Now, for example, you go, you 
can go even more and stack. So that's called stacking. 
 
So for example, contain, contains, and this contains will go, for 
example, J for January. And if January is there, will, or June, or July. 
You will see true, otherwise false. So now we can filter out only 
months that start with J.  And not so useful, but we can.   The next 
thing that you want to do is called something called regular 
expressions. 
 
And regular expressions allow you to do replace and extract. So 
here, if you want to, for example, replace any data where this is j, 
you can. And for example, here, let's say dot instead of contains, 

The Complete Python Book 
 
614
let's use replace and replace will take with whatever you want to 
do and then with what you want to replace. 
 
For example, I'm going to replace j with Jan with j tests.  I don't 
know. Let's do it.  So right now, everything starts with J will be 
replaced with the J test, a, and stuff like that. Or let's be clearer and 
then remove this test and then put like this. So, it's your jewel J 
underscore U L for June. 
 
We have J underscore UN and stuff like that. So replace will allow 
you to remove some things or add more things if you need and in 
most cases that's going to work as a regex expression. There is a 

The Complete Python Book 
 
615
whole lot of to learn about regex expression and trust me, don’t try 
to even learn it. When you try, you will always forget it.  
 
Make sure to have a cheat sheet of all regex comments, which is in 
the description of this video in the resources. Which is a PDF, so 
you can download and have it on your side whenever you need to 
work.  Now, more advanced stuff that you can do with strings. And 
let's not let's copy this and put it here. 
 
Now, what I want to do is this.  I want to split or slice or find, and 
for example, what I can do, I would like to slice everything from 
zero to, and what's going to happen, that's going to explain only 

The Complete Python Book 
 
616
the first two letters of every month, which is fine, but we don't 
really want that, but yeah, you can do that.  
 
There are many more things that you can achieve with this. You can 
either slice, you can change the reference to the column. You can 
even go into details and split something or find, so let's go and find 
something, and this find will allow me, let's check what this find will 
allow you to find exactly whether or not something starts with 
something, like j. 
 
If there is a starting with a J, it will be zero, otherwise minus one.  
So yeah, that's how you know. Now, if you go with the underscore, 
it will be zero because it is case sensitive. Make sure to either go or 

The Complete Python Book 
 
617
then do the first. str, lower, and then start to find with the j, 
because in that case it will be.  
 
This is the stacking method, which is more advanced stuff working 
with text. And now you can go and do a lot of great stuff with our 
text.  Just bear in mind, then this stacking is going to be executed 
in a specific order. 
 
If you execute like this.  it won't work like this because first of all 
this will return true or false so this is Boolean it's not a string so 
unfortunately you can't do this so it's really important in what 
which order you execute especially when you for example do this 

The Complete Python Book 
 
618
upper for some oops upper  it won't recognize this j because it is 
lowercase. 
 
 
 

The Complete Python Book 
 
619
 
 
 
 
 
 
 
 
 
[I/G/A] Sales Data Visualization 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
620
 Before we start to do actually ETL or extract, transform and load, 
we need to visualize the data and data visualization will help all of 
us to understand better the data that we have in front of us. Now, 
like we did describe as we did before, and yes, we did see those all 
sorts of amazing stuff as a statistic, but that statistics is not as 
informative as you might think. 
 
Yes, it will get some information there, but on top of that, you don't 
have that much value. So, plotting or visualizing the data is really 
important. Now, this is going to be a short video on visualization 
because we're going to talk more on that in the practical Chapter 
of ETL next section. But so right now, if you want to visualize any 
column, so you go and call your sales data. 

The Complete Python Book 
 
621
 
And then you have plot. Plot will allow you to provide a lot of 
different arguments. What is the X? What is the Y? What kind of 
the graph you like? As you can see, there is a lot of different graphs. 
You can go with the line, we can bar chart, you can area pi and stuff 
like that. Let’s say if we go and define X will be sales, and then kind 
will be bar.  
 
If I do this, it will showcase the sales data for all of my information. 
Now, if I do for example, Y, X should be  product ID, and then  Y is 
our sales.  

The Complete Python Book 
 
622
 
You will see per product ID, what is going to happen with sales.  So 
now, because we don't, we didn't group them. We, what you can 
do is group by, we didn't learn group by, but it's going to group by 
basically product ID. And now we have this information on top of 
that.  
 
Now, what you can do on top of that is sum, sum everything up and 
then showcase the sum for every single product for sale.  Now this 
can be done because of course there should be a couple of more 
iterations there, but you understand the gist. So now you can see 
that we have graphs that are based on every single product per 
month or per any category, whatsoever. Now, imagine that I want 

The Complete Python Book 
 
623
to see what the linear graph of our sales is, of our revenue per 
month. So, I'm interested in that because I want to see what the 
fluctuation in seasonality are because the revenue might be 
seasonal as well, especially if we are for example, a hotel. 
If we have sales data PD, then I'm going to go plot. And then for X. 
X is going to be month.  Y is going to be revenue.  And then kind.   
 
It's going to be like, so when I visualize this, you will see the 
fluctuation is there. We have the droppage in February, then April 
becomes more, more frequent because they are potentially like 
some summer holidays. 
 

The Complete Python Book 
 
624
Oh, sorry. Eastern holidays. And then a small drop. And then we 
have the revenue In, in Jul, July, and then again, it's keeping the 
high rays during the summer and then again drop. Of course, that's 
depending on the type of the product that we are selling or the 
service and stuff like that. This is going to be different, but this is 
how you're going to visualize. 
Visualization is really important. I do suggest going through their 
documentation and then just. check different check different kinds 
of graphs that are going to showcase different types of visualization 
that you can do. We're going to discuss them more in the ETL 
section of this book. 
 
 

The Complete Python Book 
 
625
 
 
 
 
 
 
 
 
 
[I/G/A] Exercise 11.3: Third Pandas/Polars 
Exercise 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
626
Resources for this Chapter: 
Colab Resource: Third Pandas/Polars Exercise: 
https://colab.research.google.com/drive/1yNyWTuSFAewVLsrOhi-
mMmOkwBCSrcgo?usp=sharing  
Welcome to the last. exercise of this section. I hope you had a lot 
of fun learning about pandas because I certainly did.  
 
To put everything together, we'll do one more exercise with the 
airline passengers that we mentioned before in this section.  But 
we need a bit more analysis. So right now, because we work with 
the strings, now you need to separate the date inside of this into 
two different columns, year and month. 
 

The Complete Python Book 
 
627
Okay, so you need to do that. After that, you need to identify or 
whether or not there is a missing value. If yes, cool, then you need 
to know how to handle. If not, just leave it as it is. And finally, we 
are going to create another column called AdjustedPassengers that 
will apply a function to adjust passengers from our data set. 
 
It's going to be multiplied by 1. 1 or whatever. It's just going to 
change the value of passengers just a bit, so we know that it's 
adjusted.  It's for practice for you and I hope you have a, will have 
a lot of fun with this. The file or the link to this file is in the resources 
of this chapter. 
 
 
 

The Complete Python Book 
 
628
 
 
 
 
 
 
 
 
 
[I/G/A] Answer 11.3: Third Pandas/Polars 
Exercise 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
629
 So, the first step to our solution is to load our data and that's what 
I did right here. Now we know to check to if you would check like 
for example month. That's going to, if I write it correctly, that's 
going to be an object. So if I go and apply str and then split on here, 
we are going to have for every single one of them, we are going to 
have a one element or no. 
 
If I go and do this is not going to work. One thing that you need to 
do is call string again and then use zero or one. If you want months, 
this is going to be this.  I want years before, and I'm going to copy 
this twice.  And here I'm going to call data.  year that's going to be 
equal to this.   
 

The Complete Python Book 
 
630
Here we are going to do one.  And I'm going to either override, so 
you have both possibilities, to override the month that is currently 
inside of data or create a new column which is called new month 
or something like that. I'm okay with overriding it.  So right now, if 
you take a look at  our data, you will see that we have a new column 
called month. 
 
Which is the same and year and now with those two we can play 
around and see whether or not there are some things that we can 
work with. So even because we have this now you can go and call 
describe and see what is the structure of it. But one more thing 
there are still strings.  You need to convert that to integer, but you 
don't have to do it now. 

The Complete Python Book 
 
631
 
It's just a kind of information for you.  Okay, so now that we have 
this, we need to handle missing values, if there are any. So, we are 
going to call isNull.  And if we have this, we're going to say, okay, 
cool, so let's sum it up. And we don't have any missing value, which 
is amazing for us, right?  Now that we have selected the data set, 
we split the date into two different columns, one for year, one for 
month. 
 
We have now checked whether or not there is missing values. It's 
time to perform additional transformation on top of this and create 
adjusted passengers.  

The Complete Python Book 
 
632
 
Here I'm going to apply lambda x times 1. 1 for example, and this 
will create a new column that's going to be a passenger's passenger 
list times 1. 1. So we are adding 10 percent of that number to that 
exact entry. You can see this one is becoming 66. That brought 
everything together. Like there, there is much, much more around 
pandas and we will discuss that in the future, wherever we add new 
projects. 
 
  
 
 

The Complete Python Book 
 
633
 
 
 
 
 
 
 
 
 
[I/G/A] Quiz for Level 11 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
634
Please answer the following multiple-choice questions. At the end 
of the quiz are the answers.  
1) What is the primary purpose of the Pandas library in 
Python? 
 
 
a.  Data manipulation and analysis  
b.  Machine learning 
c.  Web development 
d.  Creating graphical user interface 
2) When working with Pandas, what is Series? 
 
 
a.  A specialized data structure for time series data. 
b.  A one-dimensional labeled array capable of 
holding any data type. 
c.  A two-dimensional data structure with labeled 
axes. 
d.  A method for serializing objects to a byte stream. 
 
3) Which Pandas method is typically used to combine two 
DataFrames by linking rows with columns values in one or 
more columns? 
 
 
a.  concat() 
b.  merge() 
c.  join() 

The Complete Python Book 
 
635
d.  Both – merge() and join() 
 
4) How can missing data be handled in Pandas? 
 
 
a.  Using the isnull() method to find missing values 
b.  Replacing missing values with fillna() 
c.  Dropping missing values with dropna() 
d.  All of the above 
5) What is the purpose of the map() and apply() functions in 
Pandas? 
 
 
a. To iterate over DataFrame rows only   
b.  To apply a function to each element in a Series or 
DataFrame 
c.  To merge DataFrame to each element in a Series 
or DataFrame 
d.  To sort the DataFrame by a specific criterion 
Answers:  
1) A) Data manipulation and analysis 
2) B) A one-dimensional labeled array capable of 
holding any data type 
3) D) Both merge() and join() 
4) D) All of the above 

The Complete Python Book 
 
636
5) B) To apply a function to each element in a Series or 
DataFrame 
 
 

The Complete Python Book 
 
637
 
 
 
 
 
 
 
 
[I/G/A] LEVEL 12: DATA 
PROCESSING AND ETL (EXTRACT, 
TRANSFORM AND LOAD) 
 
 
 

The Complete Python Book 
 
638
 
 
 
 
 
 
 
 
 
[I/G/A] Intro to Data Processing and ETL 
(What, Why and How of Level 12) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
639
 Welcome to Level 12. In terms of what, why, and how of Level 12, 
let's kick it off with the what. What we learned together.  We will 
learn about data processing and ETL in Python.  ETL stands for 
extract, transform, and load.   
In terms of why, what would you learn and care about data 
processing and ETL in Python? Because you might be working with 
massive data sets, and we need to understand how to extract, 
transform, and load data, and also how to process these massive 
data sets to extract relevant information.   
Lastly, how, how are we going to learn about data processing and 
ETL together here in Level 12? At the end of this Level, we'll have a 
quiz to help us reinforce everything that we'll learn.  
 
 

The Complete Python Book 
 
640
 
 
 
 
 
 
 
 
 
[I/G/A] Data Cleaning Part 1 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
641
Resources for this Chapter: 
Resource on Regression with Comparisons: 
https://jmlr.csail.mit.edu/papers/volume21/19-505/19-505.pdf   
When you start working on a data science project, the data 
cleaning is arguably the most important step in the whole cycle of 
your data project, starting from data initiative to whole data 
production.  It never will go to data production if you didn't do data 
cleaning. before correctly. If you are not doing data cleaning 
correctly, it means that garbage or bad data will go into the model 
and the same quality of the predictions will go out. 
That’s something that you don't want to happen, and you want to 
predict with any means possible. In this section we'll discuss just 
what you can do, what is the mindset around handling the data in 
different ways. Now there is much more to what we are going to 
discuss and what we're able to discuss in one single. 
Module or section. So, there are a lot of courses on top of that, that 
you can go and check it out on online.  The first step that you need 
to check is there any missing data? Now, I know we talked about it 
in the previous sections. Of this course, but let's go a bit deeper, 
deeper now and see different cases on how to handle them.  
When you go and look at the data set, now we have a toy data set 
right here and it looks really simply. But trust me when I tell you 
that this case of having let’s say NAN here and before, it's a difficult 
case to handle.  Now, when you see this np.NAN or just NAN or 
none and special marks, like question marks and stuff like that 
means that you are missing some of the information.  

The Complete Python Book 
 
642
 
Now, in the previous sections, we handled those with a kind of a, 
either dropping out or removing them, or completely replacing 
them with some mean or something like that.  Sometimes you will 
be able to do that. Why I say sometimes? Because, Look at this 
example right here.  How are we going to extrapolate and say the 
name of this person without actually asking that person? 
 
And who is that person? We don't know. We can't use just an 
average or mean of previous names and say, hey, this is John or 
whoever, like another Maria. You can't say that.  Again, the same 
goes for age. We know for Chris that age is missing because he was 
too shy to tell us now.  You can't just simply put any random age 

The Complete Python Book 
 
643
here, or just do the average of all the numbers right here, because 
that would be wrong.  
 
And sometimes you can't do that. Now, there are cases when you 
can, for example, weather data, and that is time series data, which 
means that it's, yes, it might be some fluctuation between those 
two data points, but you can use the average of those two and say 
in between, when it's missing, some kind of a relevant information 
to those two will happen.  
Now, in this case right here, we want. But what to do now? When 
you have this information, the best case is to go and ask the person 
what their age is. Now, of course I can go and call the Chris and say, 
hey, what is your age? And please tell us. And let's say he told us 
44. Now I know this is not real age of Chris. 

The Complete Python Book 
 
644
 
I want this to discuss his real age right here. So, I handled that 
missing point by just by calling Chris and asking him to do that. 
Now, I need to know how to handle this information right here. 
Unfortunately, we can't right now.  Before we continue, it's 
important to know how to detect those. We talked about different 
cases and we can just test it out one more time and say, isna() and 
that's going to tell us true if the data point is missing.  
 
Now that we know the data point is missing, we know, we need to 
know how, what to do with it. Now, let's say we, we are in a team 
and said, okay, we can't find out what is this person? It is a scientist 
of 35. We need to discard it. So, let's do it. And in this case, I'm 

The Complete Python Book 
 
645
going to call another method on top of this, which is called df 
dropna.   
 
This dropna We'll remove that and instead of having now four 
individuals, I'll have, and if you check the df again, oh, but here is it 
back.  This is also something that we need to make sure that we are 
doing. If you're going to drop, either create another copy or use in 
line,  in place.  So now when I go and execute this again, I won't 
have this missing data point.  
 
But bear, bear with me here. Only use this dropna if you must, 
when you need to have some information removed, when you 
don't have enough evidence to support it with other information 

The Complete Python Book 
 
646
from that data set.  Now, there are other ways to do imputing of 
data, for example, as I said, here, we just asked Chris, and that is 
called data imputation. 
 
If you don't have that, if you don't have a Chris's number and say, 
hey, let's, I don't know, let's call somebody or let's do something 
like that. You can, you should remove it. Or if you just must, you 
can fill it in. Now filling the information is really simple with fillna.  
And then you're going to provide which is the number, like a zero 
or some random average, stuff like that.  
 
Now, we don't have any more missing data, so we don't need to do 
that. But if you need it, that’s how you would do that.  There are a 

The Complete Python Book 
 
647
lot of techniques depending on the nature of the data that you can 
use to perform imputation. Always consider the impact of 
imputation to the data at hand. 
 
Whenever you choose to add some information to your data set, 
which is not original, you are creating a noise. Noisy data is bad 
data for your model, so you need to compensate that on other 
places, either with a larger model, with more data and stuff like 
that. Now, it's not as simple as that, so you always, if you must, 
impute. 
 

The Complete Python Book 
 
648
If you can, go and collect data in a natural way. I hope you had a lot 
of fun with this chapter. Let's see how to continue with our data 
cleaning process right now. 
 
 

The Complete Python Book 
 
649
 
 
 
 
 
 
 
 
 
[I/G/A] Data Cleaning Part 2 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
650
Resources for this Chapter: 
Dataset Transformations Resource: https://scikit-
learn.org/stable/data_transforms.html  
 When we speak about data, one of the terms that always picks up 
when we speak about bad data is outliers.  Outliers represent data 
that is not according to standard. For example, you have all blue-
collar workers in a data set and suddenly there is an executive with 
salary three times higher. Now, I know it's not always the case, but 
that would be an outlier. 
Because you have thousands of employees and suddenly one 
person that has salary that is three, three times higher, which 
means that one person might move and shift the statistics of the 
whole data.  So, you need to make sure that you either remove 
them or handle them in some way. Now, detecting outliers is as 
important as removing them or handling them. 
And here we have a simple data that is called transactional amount. 
And if you visualize it, it's just going to be one column called 
transaction amount. And everything except this one is normal, I 
would say.  And one thing that I forgot to put here is zero because 
this was supposed to be 250.  So, One thing that we can do with 
this data is to do Z score. 

The Complete Python Book 
 
651
 
And for that, we are using something called SciPy, which is scientific 
Python. And with that, we have statistics, which allows us to do that 
automatically based on this very information. Z scores represent 
how many standard deviations we have. or a certain point have 
from the mean. So standard deviation is basically how likely is it 
that point to fall in that region around the mean number. 
 
A common threshold for outlier detection is a test score of 2 or 
minus 2, meaning standard deviation in either way between mean. 
Always consider the distribution of the data and always it should 
be like as normal as possible.  Test scores are more effective for 
normal, normally distributed data, which is normal, of course. 

The Complete Python Book 
 
652
So, if you have skewed data, you have all the information right 
here, but then you have a long tail, then it might be the wrong 
decision or a bit difficult for you to handle everything.  So, let's see 
how to do just this. What I'm going to do right now I'm going to 
define setScore, and that setScore is going to be equal to stats 
setScore, of tf. txt.   
 
And then we are going to provide the color.  And if you check DF 
right now, you will see that this one is far above  everything is in 
the range, but this one is far above too. So now what you can do is 
hey, this one is above two standard deviations. Let's remove that. 
from the data set.  
 

The Complete Python Book 
 
653
Now there is a technique called win zoning.  When you have 
outliers as we do right here, the win zoning replaces extreme values 
such as 9, 999 data values with less extreme values. The limit 
parameter specifies the percentage of data to clip from each end. 
It can be in either way direction of extremes. 
 
We are clipping to be in that range that we want. This technique is 
really useful when you want to keep all data points but limit the 
influence of outliers. For example, if you have limited and you just 
want to keep this information inside your data set, that would be 
but if you want to do that, you need to make sure that it's not 999, 
but it's actually less than that. Because if you train any model on 
top of this or do any statistics, it's going to shift everything that you 
have. inside of this.  
So, let's see how to do just that. So first off, I'm going to use 
winsorize, Winsorized_Amount  equal to stats.mstats.winsorize 

The Complete Python Book 
 
654
 
And then we are going to provide transaction amount and limit is 
generally 5%.  
 
If we check, this is the changed value.  It didn't change and at all.  
Now, besides using this technique, there is a simpler technique 
called thresholding data. And we can remove data points that are 
above certain thresholds. And for example, if we set a threshold to 
be 500, so for example, threshold is equal to 500, what we can do 
is we can say df dot truncate is equal to df of  Truncated amount or 
transaction amount where it is less or equal to threshold.  

The Complete Python Book 
 
655
 
And let's use it. And now we basically have that information inside 
of this. So, truncation is completely And sometimes. It will be 
removed based on the patterns that you have in your data, which 
is really simple to do and very effective. So not, you're not guessing 
whether or not you should remove certain data. 
 
Now you can use that for set score as well. And if you know that set 
score of 2 or minus 2 is bad for your data and that's considered 
outlier, you can use those to remove educated, as a kind of 
educated guess outliers from your data. 
 

The Complete Python Book 
 
656
 
 
 
 
 
 
 
 
 
[I/G/A] Label Encoder and Data 
Transformation Part 1 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
657
 Now that we have our data checked, we know statistics, we know 
distribution, we checked for missing values, handled those missing 
values, now it's time to handle outliers, we've done that as well.  If 
you have the data ready, it's time to make some transformation on 
top of it. It really depends on the task at hand that, and the features 
that you have, which data transformation techniques you're going 
to use. 
Now, it always comes to a couple of them.  And one of, one of the 
things that we are going to talk about today is called label encoder.  
Label encoder allows you to encode categorical variables that are 
basically, for example, male, female, low, medium, high, for 
example, for ratings, into some numbers. Or numerical variables 
that you can use in your algorithms because no algorithm in the 
world can work with string information or text information. 
So that text information needs to be encoded in some way so you 
can actually do some calculations on top of it. Okay, so right now, 
here, I have my pandas imported, of course, and then I have sklearn 
preprocessing. So sklearn is a library that has a lot of machine 
learning stuff inside of it. So, it's a machine learning package. 
 

The Complete Python Book 
 
658
It has algorithms, it has data preprocessing steps inside of it, and 
one of them is label encoder.  The data that we have today is called 
the ratings. We have low, medium, high, medium and low. And 
now, because we want to, for example, make some 
recommendations on top of it, we need to encode it.  
And how to do that? First is label encoder. I'm just going to call it 
LE. It's going to be label encoder. You don't have to provide any 
information inside of it. Now that you have that, we are going to 
create another column called encoded ratings. That's going to be 
le. One is fit, which will take your data and understand what the 
structure of the data is and determine which, which file or which 
info will be encoded to what value. Now, because we want 
immediately to return that information encoded, you can go and 
use fit transform, which will actually lead learn those patterns of 
matching. 
 
And on top of that, return the matched information. So, for me, it's 
going to be df of ratings.  Now, when you check the rating, you will 
see that low became one, high became zero, and medium became 
two. For now we don't really care which number is which label, but 
this can lead to some potential consequences when you do this. 

The Complete Python Book 
 
659
 
Now, in this case, we have rating, which is fine, like low I would 
reverse this and say that low is zero medium is one and high is two, 
because mathematically speaking, those can lead to a couple of 
different things inside the mathematical algorithms. Which means 
that, for example, high being the two might influence the 
computation much more than, for example, low.  
When you do some calculations, let's say a simple machine learning 
algorithm, linear regression, which is X times A plus B. You see the 
problem. X is some amount of data, which is this now encoded 
information. A is some number. B is some other number. Y is our 
prediction.  So X, being the encoded information, can go from 0 to 
14.  
This means that when you multiply something by 14, anything that 
a is plus b, of course, it's going to have larger influence to change 
in a and b than, for example when x is zero.  

The Complete Python Book 
 
660
 
 So that is artificially adding influence of the variables inside the 
algorithm, which can learn those patterns and make bad 
predictions later on. 
You don't really want that. If, however, the rating in this case needs 
to influence something and you want the strand from those 
influential to be encoded as well, that's completely but please 
make sure to think about those things when you start encoding.  
The other type of encoding is called one hot encoding, which 
handles this problem. 
Now let's, I'll keep the same data set.  Now, one hot encoding 
allows us to basically use information and encode it in a set of kind 
of variables where we are going to create a column for every single 
value. So, what I'm going to do, I'm going to say pd. Get dummies. 
And here I'm going to provide df of rating.  

The Complete Python Book 
 
661
 
And basically here you can say drop first to true just to make sure 
that we have everything. In this case, we have low medium. If you 
have this to false.  We'll have one more, which you have high, low, 
and medium. Now you can add this to your data frame and have 
three different columns. And now this will not influence any 
algorithm, more or less. 
 
When you have Everything like high, low and medium. In this case, 
you are You have all the information, but this might be too much 
information because when it's 00, this means that this should be 
one so that by combinations, you can determine which values are 
present right here. 

The Complete Python Book 
 
662
 
If any of those are one, this must be zero. And if both of these are 
zero, this must be one as well. You have that information encoded 
right here. We know that high is one, and we know that everything 
from inside of this is zero.  So, this is called one hot encoding. And 
sometimes you will use one hot encoding to make, to create binary 
columns for each category to make sure that you are predicting 
that as a kind of a feature at the end of your machine learning cycle. 
 
It's useful for normal variables where the order of categories is not 
really important.  However, it can increase the dimensionality of 
your data set, and potentially lead to something called curse of 

The Complete Python Book 
 
663
dimensionality. Link to this, to the resources about curse of 
dimensionality. 
 
 

The Complete Python Book 
 
664
 
 
 
 
 
 
 
 
 
[I/G/A] Label Encoder and Data 
Transformation Part 2 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
665
 Now we explained when we have categorical variables on how to 
transform them from strings to something that we can work with. 
Sometimes categorical variables will be in integer format, and you 
can encode them still into one hot encoding.  But another way to, 
or another thing that we need to think about is how to scale our 
features to be in the same, like a shape or same scale.  
That's where the numerical feature scaling comes into play. So why 
is this even important? For the same reason as we talked in the 
previous Chapter, when you have encoded those variables from 0 
to 14, for example, with a label encoder, now suddenly that 14 will 
have more influence to your algorithm, something that becomes 0 
by default with random choice.  
This can be handled with something called numerical scaling or min 
max scaling for one example. This makes all variables in the dataset 
equally in the same scale. So that difference is still present, but 0 
to 1.  And this is something where it shines to make sure that we 
have all data scaled in a way that we can actually work with it. 
And no matter of what algorithm to use, all features in that data 
set will influence that algorithm the same way.  Okay, or the same 
capacity. Now we have a small data set right here that we can scale 
to make sure that all values are on the similar scales.  So, I'm going 
to define a scalar that's going to be min max scalar.  

The Complete Python Book 
 
666
 
And this min max scalar, you can use a feature range. You don't 
have to, because we want to scale it from zero to one.  Now that I 
have this, it's the same as before. We are going to say scaled values.  
And now this is going to be scalar dot fit transform with df of value.  
 
If I do this, by default, I'll get an error. So why is this an error? If you 
take a look, this shape, when I check it, will be just five comma 
something. And this works only with the vector.   

The Complete Python Book 
 
667
 
So right now, you can't reshape series. Oh, what to do? You can call 
and call values.  This one asks for more operations on top of it. And 
now it suddenly works. You can see that 10 becomes 0, 50 becomes 
1, and all between becomes scaled on a scale of 1 0 to 1, depending 
on how you look. 
 
And now when you do that, some calculations on top of it, this will 
influence the most, but this will influence on a similar scale, so this 
won't influence times 50.    

The Complete Python Book 
 
668
 
Besides this type of transformation, which is min max 
transformation, you have many others. In computer vision, for 
example, in most cases, because images have pixels that goes from 
0 to 255, so scaling in that sense will be just dividing the whole 
image by 255,  making all pixels from 0 to 1. And that we are 
achieving basically the same as we did right here. 
Now, there's a set transformation, log transformation, and many 
others that you can apply. Choosing between those can be tricky 
because it really depends on your data and everything that you're 
doing. But your resources to this will be in the res or links to those 
will be in the resource of this Chapter. 
So you can check out by yourselves and learn about all those 
transformation on your own time.  
 
 

The Complete Python Book 
 
669
 
 
 
 
 
 
 
 
 
[I/G/A] Label Encoder and Data 
Transformation Part 3 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
670
 The last step or the last technique that we are going to discuss in 
this section about data pre processing, data transformation is 
feature engineering. Sometimes the data that you got might not be 
as useful as you might think. So you need to think about the other 
aspects of how to be creative with your data that you have, create 
another set of information around it.  
That might be binning or creating, let's say, a feature about 
polynomial values, like for example, giving that everything to the 
step of two. The feature engineering is a really creative process, 
and there is no one size fits all. It really depends on you as a 
designer. data scientist and your team to decide on how to handle 
your feature engineering. 
So let's discuss a couple of techniques from feature engineering. So 
first of all is called binning and we'll discuss and create a data frame 
that's going to have age.  We can name it like this.  This age will 
have 22, 35, 55, 42,  and 68.  So this will create a small data frame 
for us. Now we need to apply binning on top of this. 
 
So what's going to happen is this, we are going to define two 
different sets of. Two, two different lists in Python. One is bins. 
That's going to be zero, 30, 50, and 100. This is going to set cuts or 

The Complete Python Book 
 
671
thresholds. What's going to happen inside of those bins. Then we 
are going to label them. And we are going to label as young. Then 
we'll, after that, we're going to define as middle aged. And then 
senior.  So we have this.  
 
Now that we have this, we're going to create a different column 
called  been aged or been  age, which is going to be defined like this  
PD dot cut. And now we're going to use cut. So cut will take first of 
all, our age as a kind of a data source. The bins we're going to set 
two bins and labels. We are going to set to labels.  
 
After I execute this and check out the bin, you will see that this 
becomes binned or class, classed thing that we can apply and see 

The Complete Python Book 
 
672
how to approach. So in most cases, you will see when we are 
speaking about the age that they are going to do ranges like from 
0 to 10, 25 to 30 or 20 to 30 and stuff like that. 
 
Just to make sure that you have a categories between their users 
to make sure that they are actually able to extract some relevant 
information.  Another technique is called polynomial features. And 
we can use SQLearn as we did before to do just that. So we need to 
do two things. First of all, let's import from SQLearn dot 
preprocessing  import polynomial  features. 
 
The second thing is let's create another data set. So this is going to 
be  data set. pd. dataframe.  And this data set will consist of size,  

The Complete Python Book 
 
673
and this size will be for like square feet and then room numbers,  
which, or just rooms, or amount of rooms that we have in this  
Specs. We have two, three, and four.  
 
So now that we have this, we need to define our poly features. This 
is going to be polynomial features.  The first thing that we need to 
define is degree. If you want to just Step it up or square it. Use 
degree of 2.  And let's define it so we know what's happening.  Now, 
you can include bins or not, so it really comes to you whether or 
not you're going to include  that as well. 
 
Include bias.  Okay, it's false.  So now that I have this, let's define 
our polynomial features. So what I'm going to do, I'm going to 

The Complete Python Book 
 
674
define df of poly, which is going to be pd dot data frame  of 
polynomial  poly features dot fit transform  of Our df, which is 
defined right here.  So what's going to happen here? 
 
I'm going to basically get  polynomial features for every single 
column inside of my data frame. And here I need to get feature 
names.  Let me remove this.  Feature names,  df columns.  So polyf 
is this one right?  The mistake that happened to me is this. So here 
we have names, and this will tell you that you don't have feature, 
get feature names as this. 
 
Sometimes in the past, it was get feature names as a kind of a way 
to get this, but when they upgraded, it's now get feature names 

The Complete Python Book 
 
675
out, which just generates this information. Now, when you do this, 
you have the whole information right here.  Hope you had a lot of 
fun. The feature engineering is an amazing set of skills that you can 
develop. 
Now, with all new algorithms coming out every single day, it 
becomes less prevalent as a kind of a core skill set of a data 
scientist. But it's still really useful for you to know this because it 
will have help you understand the data and how to structure it for 
your algorithms in the future.  
 
 

The Complete Python Book 
 
676
 
 
 
 
 
 
 
 
 
[I/G/A] Handling Imbalanced Data 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
677
Resources for this Chapter: 
SMOTE Resource:  
https://www.analyticsvidhya.com/blog/2020/10/overcoming-class-
imbalance-using-smote-techniques/  
 In many cases, you will have unbalanced data set, and that's really 
dangerous because it will create bias towards certain class or 
certain direction in your data. Now, that means that your 
predictions will be more concentrated towards that group or that 
group. part of your data that you initially didn't want to handle in 
that way. 
So that is really common in, in cases of security, for example, fraud 
detection or airport detection and stuff like that, where you have 
millions and millions of transactions and people that are positive in 
a sense, like they're okay, they're cool, but the negative sample of 
fraud or negative, basically what you wanted to detect are just a 
couple of examples. 
So you have millions of non fraudulent transactions and a couple of 
them that are fraudulent. So how to create a dataset of that? Now, 
there are a lot of techniques on doing so. One of that is called 
undersampling or uppersampling. So it really depends on how you 
approach it. Now, here we have this dataset, which calls df dataset 
of class.  

The Complete Python Book 
 
678
 
We have Five zeros and two ones and some features. It doesn't 
matter.  So the first thing that we're going to do is called 
DfMajority,  which is going to be Df of Df.  class equal to zero.  So 
when I execute this will sometimes go and do well, but because the 
class is a keyword, I can't do it like this.  
 
So unfortunately, if you have a class or a label or something like 
that has actually a non keyword on Python, it will work for you. 
Now, I want to do this for minority class as well. So I'm going to 
change this to one.  Then here I need to change this to minority.  So 
now I have these two up already. 

The Complete Python Book 
 
679
 
What I need to do is call this esky learn tools for resample. So right 
now I'm going to define DF under sampled.  So under sample mean 
that we are taking the class that are not as present as the class that 
is dominating. For example, this case once. So for fraud detection, 
it would be fraudulent transactions. 
 
And you're going to generate, basically artificial samples in that 
many cases to match equally the amount of data that you have for 
a positive sample. Or though, that, that is. More of it there. So I'm 
going to call resample.  And this resample, first off, will take 
dfMinority,  dfMajority.  Then it will replace.  

The Complete Python Book 
 
680
 
So replace, if you scroll down,  we'll see whether or not It will 
basically say replace, implement resampling with replacement in 
false. This will implement sliced random permutations. So do we 
have copies of the same item or not?  Then when we want to see 
how many  samples we have. So we are going to have len of df 
minority.  
 
And then you need to set, or you don't have to, random state, 
which we can set to 42. When you execute this and check it out, 
you will see that we have two more samples of zero.  But then,  this 
is going to be like, your two classes that resampled from my 

The Complete Python Book 
 
681
majority. So you are going to take that and bring it down to your 
minority data. 
 
So what you're going to do is, let's say, optimized or balanced.  We 
are going to pd. concat  and then use it. For example, our minority, 
dfMinority, minority and DF undersampled.   
 
So this  becomes our new data, which is balanced. And instead of 
having  seven different samples, we have only four that are 
balanced equally in the amount of data. Now, this is, in my opinion, 
much better if you need to do something, because when you're 
doing oversampling, and we will do that in a second, you're going 
to generate new samples. 

The Complete Python Book 
 
682
 
Now you generated this. But you generate it by selecting.  What 
exactly has we have here? They're in majority. So you didn't 
generate artificial examples so far You just selected which one of 
those two to do now there is a method called oversampling where 
you can basically go and use this method to basically create 
artificial samples in in amount of majority. 
So you're going to generate them and then you have equal amount 
of minority class as equal to majority. So let me use this resample 
again, but in this case, it's over oversampled, so this case  
oversampled, and we are going to do just change, so let me copy 
this,  and I'm going to copy this,  and paste it right here. 
 

The Complete Python Book 
 
683
Everything else stays the same. Now, one thing that you will notice 
here is it will fail because we set this replace to false, and because 
it has less amount of elements that it can select over. So it's still like 
just creating artificial examples that look exactly as we have in the 
data set, and that's shown right here. 
 
So we have 4 of 3 and 1 of 6. Now you can do the same thing and 
execute to see whether or not it's different. Let's change this to do 
512 and we have one more 6. Still better, but it has a lot of noise 
because this introduces artificial samples that are not really there.  
Now, there are better techniques for oversampling either creating 
that type of  balance in the sense of  sense of data. 
 

The Complete Python Book 
 
684
We won't cover it in much detail in this chapter, but amazing 
resource is provided to you in the resources of this very chapter. 
It's called SMOTA,  which is Synthetic Minority Oversampling 
Technique. Basically, what this technique entails is to generate 
synthetic samples in the feature space. So it gets all information 
from your current data and start using that information to generate 
a new one. 
Unlike single oversampling, SMOTE  does not create exact copies, 
reducing the risk of overfitting or just creating a noise. in your data.  
So it is really important to make sure that you're using these 
techniques in a good way, because sometimes you might have 
balanced data, but it might have a lot of noise. 
 
 

The Complete Python Book 
 
685
 
 
 
 
 
 
 
 
 
[I/G/A] Data Partitioning 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
686
What is the goal of machine learning or any AI?  It is there to 
generalize on unseen data, which means when you train a machine 
learning algorithm to some data that you have in house. You want 
it to be generalized enough to work really well on data that is about 
to be uploaded by your users. You don't really know when it's going 
to happen, it will.  
So you are making sure to do everything in your power to do 
feature  engineering, to do data pre processing, sampling, and stuff 
like that. to make sure that your machine learning model works 
really well.  And that's what data scientists and machine learning 
engineers really do. Now, one thing that you can do, because you 
don't know what is the data going to go in your way, is to create 
data partitions, or parts of data that are going to be  there for you 
for a separate ways, or I would say separate ideas.  
One way is called train test split. Train test split will make sure that 
you are splitting your data into two or three parts. One is for 
training, which is going to be there to train your machine learning 
model. Then another one is for validation. which is going to validate 
that your model actually works on some unseen data. 
But those two data sets might have some data leakage between 
them, might not be as representative as such. But because you are 
testing a lot of models, that validation data set will make sure that 
you are actually choosing the model that best performs on that 
validation data.  Besides that, you have that Test set or holdout set, 
which in most cases is going to be locked somewhere and not used 
until you're ready to test it on something as close as production.  
That holdout set or test set,  we need to make sure that it 
represents the user's environment as closely as possible. So it will 

The Complete Python Book 
 
687
make sure, we will make sure that every single class is represented 
in the quality that we have enough information inside of it, that all 
data is there to be represented as such. 
Now there is a technique called cross validation. Cross validation is 
a method where you want to make sure that you are training the 
model on different parts of your data. So you will take your training 
set and split it into, for example, ten different  parts. You're training 
on nine, testing on one. 
And then that one becomes part of the training and then you're 
choosing and basically training it in a such a way that you are every 
single time choosing different that part to be a validation set. So 
you have 10 trainings on your model and then you're using the 
basically average of all the accuracies to make sure that is the 
report one that you're going to use.  
That's it for data partitioning, make sure that you have divided a lot 
of time to designing your test set. In some products and companies 
that I worked for,  basically had two full time engineers only 
engineering that test set or holdout set that's going to be tested for 
our production. So it's a really important job, and you're going to 
spend a lot of time doing that. 
In most courses, in most online educations and like projects, 
they're going to do just train test split using sklearn and then say, 
that's fine.  But in reality, you're going to spend hours and hours 
designing the test set to be as perfect as possible to represent our 
users as much as we can.  
 
 

The Complete Python Book 
 
688
 
 
 
 
 
 
 
 
 
[I/G/A] Quiz for Level 12 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
689
Please answer the following multiple-choice questions. At the end 
of the quiz are the answers.  
1) What is the primary goal of data cleaning in the ETL 
process? 
 
 
a.  To optimize the performance of database queries 
b.  To enhance the visual appeal of data charts 
c.  To ensure the accuracy and consistency of data 
d.  To encrypt sensitive information 
2) In the context of ETL, what does the Label Encoder step 
typically involve? 
a.  Converting labels into numerical format to be 
used in machine learning models 
b.  Encrypting labels to secure the data 
c.  Creating new labels for data categorization 
d.  Sorting labels alphabetically 
 
3) What is data transformation in ETL primarily concerned 
with? 
a. Changing the data format, structure, or values to 
prepare for analysis    
b.  Transferring data from one database to another 
c.  Visualizing data for reporting purposes 

The Complete Python Book 
 
690
d.  Partitioning data for distributed storage 
 
4) What does handling imbalanced data in a dataset 
typically involve? 
a.  Ignoring the imbalance and processing the data 
as is 
b. Using algorithms that are insensitive to imbalance  
c.  Applying techniques to adjust the class 
distribution within the dataset 
d.  Partitioning the data into more balanced datasets 
5) What is the purpose of data partitioning in the context of 
ETL? 
a. To divide the data into training and testing sets 
for machine learning models   
b.  To delete unnecessary parts of the data 
c.  To classify data into different categories based on 
labels 
d. To compress the data for faster processing   
Answers:  
1) C) To ensure the accuracy and consistency of data 
2) A) Converting labels into numerical format to be used 
in machine learning models 

The Complete Python Book 
 
691
3) A) Changing the data format, structure, or values to 
prepare for analysis 
4) C) Applying techniques to adjust the class distribution 
within the dataset 
5) A) To divide the data into training and testing sets for 
machine learning models 
 
 

The Complete Python Book 
 
692
 
 
 
 
 
 
 
 
[B/I/G/A] LEVEL 13: WRITING 
CLEAN AND EFFICIENT CODE 
 
 
 

The Complete Python Book 
 
693
 
 
 
 
 
 
 
 
 
[B/I/G/A] Intro to Writing Clean/Efficient Code 
(What, Why and How of Level 13) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
694
 Welcome to Level 13. In terms of the what, why, and how of Level 
13. Let's kick it off with the what. What will we learn together?  We 
will learn about how to write clean and efficient code.   
Now in terms of why should we learn about these topics? Because 
clean and efficient code runs much faster, which can help us save a 
lot of money and time when it comes to using computer resources.  
If we write clean and efficient code, it makes it easier for us and 
anyone else that wants to read out code, debug it and maintain it 
in the future.   
Lastly  how are we to learn about clean and efficient coding 
together here in Level 13?  We'll have a quiz at the end of this Level 
to really reinforce what we've learned together, because it's crucial 
to understand how to create code that not only runs faster, but is 
more readable by our business partners and end users. 
 
 

The Complete Python Book 
 
695
 
 
 
 
 
 
 
 
 
[B/I/G/A] Clean and Modular Code 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
696
 Up until now, we used code that is more optimized towards 
Chapters.  And in most cases, in production, it's going to be much 
more robust, which we can call production code.  So software that 
we run, either data science software, general one, is running on 
production service.  And those are computers that are somewhere 
in the world. 
It can be some GCP or Google Cloud providers, AWS and stuff like 
that.  Those servers are there to handle live users and data of 
intended audience or our users. Login data, information like that 
and stuff like that.  Note that this is different from production 
quality code. which describes code that meets expectation from 
production in reliability, efficiency, and other aspects. 
Ideally, all code in production meets these expectations. But in 
most cases, trust me, it's not the case. Especially when you have 
different users or different programmers on that job.  Now, after 
that, we have something that we consider clean code. We have 
clean and dirty code.  Not only production code,  but only a clean 
code.  
So production code can be a dirty code as well, but clean code is 
something completely different.  And when we say a clean code, 
there is a whole book on top of that, amazing book, but not only 
one, many.  And it's more about readability of code, how to write 
it. Is it a simple or is it more of a robust code that is not as efficient 
as we could get it? 
And is it concise? So sometimes people will write Whole a lot of 
code for something that can be written in just a small amount of 
code.  So clean production quality code is Crucial when you work in 

The Complete Python Book 
 
697
teams and it's crucial when you work in long term projects so you 
can maintain it And you can upgrade it when needed.  
Sometimes people, I worked in many different companies and 
teams,  they will write a lot of code in  one function,  one file. 
Sometimes that's good, but in most cases, that's not something 
that we really want.  So making it more optimized, modular, that 
solves one single thing is really important.  So you need to make it 
in a Smaller chunks that are logical as itself  and it should be clean 
and production ready. 
So that is something that you are striving for.  So modular code 
needs to be organized in separate files that are separately 
organized per their need. Efficient, so fast and reusable. So when 
you work with that, you need to actually go and make it better.  
Now, writing a clean code  starts with names. And in most cases, 
people will just say, okay, it's a name. 
Who cares about it? I'm just going to give this variable this name 
and then,  yeah, basically forget about it.  Now,  I'm one of people 
that are,  they care about names, but when it comes to 
implementing that in practice,  I get bored. So I start doing 
something and then forget about it.  But trust me when I say writing 
clean names, correct names, depending on your on your 
programming language is something that you really need to do, 
especially when you work in the larger teams.  
For example, rules are like this. When you have a Boolean, You start 
with is and then underscore, or has underscore. Like for example, 
is user, is admin, is color, is this, has color, for example, for images.  
So it needs to be clear. So whenever you can explain with your 
code,  don't use comments. So that's a rule. 

The Complete Python Book 
 
698
You need comments, and we're going to talk about that in a 
second.  Whenever you can explain with your code, use it.  Then,  
verbs used for functions, nouns for variables, and stuff like that.  
aNd we need to be consistent. If we are going to use like age or 
name, list, then don't start doing ages or age, just it, like always be 
striving for consistency. 
So people that are not as proficient with coding as you are, juniors, 
for example, that are just starting out, they need to learn from you.  
And avoid abbreviations as much as you can, or single letters. 
Sometimes as a counters, that's fine. But when you need to go and 
make fully functional or fully  workable production code, make sure 
that those are just counters, not more, not less.  
So you need to determine what, when to make those exceptions, 
of course.  So if you're working with other data scientists, certain 
variables may be common knowledge.  While if you work with a full 
stack engineers,  You are working with the different engineers that 
have different way of learning and different variables, different 
everything. 
So you need to make sure that this is unique to them. And if it is,  
try to follow that.  And long names are not as good as you might 
think. You want to go into that extreme where everything is 
descriptive or as describable as possible.  Yes. You should strive for 
that, but not with this long names. 
So you need to make sure that  these are consistent, these are short 
enough, but also informative enough.  If you can't make it as 
informative as it needs to be from the code, use comments.  And 
you need to try to test how efficient our names are by giving the 
code to somebody and trying to re understand it. 

The Complete Python Book 
 
699
And that's a good metric to follow.  Now,  there is another thing 
from writing link code, and it is white spaces.  Make sure that you're 
organizing your code consistency, and especially in Python where 
indentation is a crucial part of it. You need to make sure that you're 
using those indentation as consistent as possible. 
If you are deciding as a team to go with spaces, do them. If you go 
with tabs, do the tabs.  It's fine, but make sure that those are 
consistent and make sure that spaces above and and below certain 
parts are considered as well. Don't make four spaces between the 
two functions and then one space after the second function. 
So if you are making four spaces between two functions or four 
lines of code that are empty,  Keep that, but make sure that it's 
everywhere that you are making that.  And additionally, spaces 
between and after, like before and after certain mathematical 
symbol, like equal, if you're making before and after, keep that. 
Don't make somewhere.  And before and somewhere after and 
stuff like that.  And in Python, for example, there is something we 
call DAP8,  which is a standard or guidelines on how to structure 
our code.  And that's an amazing reference. You don't have to know 
every single detail. There are programs, linterns that are going to 
help you to actually understand that and make it better 
automatically. 
So you don't have to do it manually. There is a rule that you have 
to have about 79 characters  in the line. to be consistent with the 
PEP 8 style.  You can change this. Sometimes you need to change 
this. Don't follow every single guideline as described. Sometimes 
those will be fine, sometimes not. So it's up to you and up to your 
team to decide.  

The Complete Python Book 
 
700
And yeah, of course, go to a PEP 8 for that. There is a method or 
thing that we need to follow which called dry. Don't repeat 
yourself.  So if you are repeating the same code couple of times, 
make it a function  or make it a separate file that you are going to 
call, but don't repeat your code. Now, another thing that I wanted 
to teach you is about functions.  
Always strive to have one single thing to do in a single function. So 
functions should be doing only one thing.  Focus on that. If you see 
that one function is doing a couple of things, break it down. make 
it more functions and call it each other. So you need to make sure 
that you're refactoring code where needed. 
So if you have big functions that are multiple things, refactor it  and 
make sure that your names are generally like focus on what 
functions or whatever you're doing.  Now,  Another thing about 
functions,  arguments are really important because functions are 
living because of that. So you need to send some data to it.  
There is a rule that sometimes I follow, sometimes I don't, to have 
at most  three arguments per function.  nO more than three 
arguments when possible. Now, there will be Some cases where 
this is a hard rule to follow, and that's completely okay, but make 
sure that is, there is a crucial reason why is that.  
If you can break it down to less functions. If you need to follow that 
and have only three, more than three arguments, that's still okay, 
but you need to make sure that you know why you're doing that. 
 
 

The Complete Python Book 
 
701
 
 
 
 
 
 
 
 
 
[B/I/G/A] Python Naming Conventions 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
702
 In the previous Chapter, we talked about briefly on how to name 
your variables or anything.  In Python, variable names should be 
descriptive to make the code more readable. For example, instead 
of naming a variable x, you can name it age. And if it stores age 
value, of course. The convention in Python is to use lowercase 
letters and underscores to separate words. 
And that is called snake case.  Python. Sometimes in other 
programming languages, instead of using that underscore, you will 
have uppercase. So for example, snake and then uppercase.  And 
that's called camel case. So if your variable stores a list of customer 
names, a good name would be customer underscore names, in the 
case of Python, of course.  
Now, when it comes to function names, descriptiveness is, again, a 
key.  Function names often include verb to indicate what function 
does. For example, if a function calculates the average,  call it 
calculateaverage.  Just like with variable names, it starts with a 
lowercase and has snake case for the function names.  
We have more than classes, of course and variable names. There 
is, there are classes.  So classes in Python are often different 
conventions to know, and that's called camel case. So we are 
starting with a big letter or uppercase letter, and every single new 
word We'll start with the uppercase as well. 
In this style, the first letter of each word is capitalized and there are 
no underscores between words. So this is only for naming classes.  
So for example, if you're building a class for a model as a car, a 
suitable name would be automobile, using a as the uppercase, 
rather than the auto or car object, which is everything under a 
lowercase. 

The Complete Python Book 
 
703
Module names or files should be kept short and all lowercase. 
Underscore can be used in the module name, so to improve 
readability. For example, utils, rather than util functions and using 
capital case. Okay, and this keeps the name  short and easy to type, 
which is really important when you call these modules from other 
parts of your code.  
And the best way to learn this and to find it in the real world is to 
go to GitHub, and look at some Python projects and start looking at 
how they do it.  
 
 

The Complete Python Book 
 
704
 
 
 
 
 
 
 
 
 
 
[B/I/G/A] Documentation 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
705
 When it comes to either internal or external projects, open source 
or not open source or closed source, the documentation is a crucial 
part. And it's not only for external users, but it's for other users, 
which are your fellow programmers. or other stakeholders that 
needs to have some exposure to your code. 
So documentation is there to give another context. So it's 
additional text or illustration or both to basically help you 
understand what is the code about and software. And it is helpful 
to clarify complex parts of code, especially complex parts. When 
you have a certain algorithms that, for example, AI algorithm that 
you want to explain the data flow,  making your code easier to 
navigate and the whole project easier to understand. 
So it's really important to have good documentation in your 
products.  There are several types of documentation that you might 
have. One is inline comments. And yes, that is considered 
documentation. So when you program, you can sometimes add 
inline comments to explain your code in more details.  
When you are making a modules or functions, you're, or classes, 
you're going to create doc strings. That will allow you to understand 
what is about in that function in plain English, and also understand 
what are the types and expected arguments. to that function.  And 
on a top Level, which you're not going to do alone, of course, you 
are if you're working solo, but if you're working in a team, the 
whole team is there to work project documentation. 
So it's there to basically explain everything.  Now let's break down 
each of those. We have inline comments. Inline comments are text 
followed by hash symbol. We used it a lot throughout the course. 

The Complete Python Book 
 
706
And this is in case of the Python, of course. In other programming 
languages, the starting symbol is a bit different.  
They are used to explain parts of your code, and really help further 
contribution and understanding of your work.  Comments often 
document the major steps of complex code. Readers may not have 
to understand the code to follow what it does, but comments can 
explain it. However, Other would argue that it is using comments 
to justify bad code. 
So it really comes to whatever you prefer. I would say that 
whatever you can explain with a code, use the code. Whatever 
needs to be. explain further with the comments, use comments. 
And that's a good rule of thumb.  Comments are generally valuable 
for explaining where code cannot. For example, the history behind 
why a certain method was implemented in the first place. 
Sometimes an unconventional or seemingly arbitrary approach 
might be applied because of some obscure extreme variable. 
causing this side effect. You forget about it, and when some new 
program comes to your team or you go away, those are not really 
nice ways to explain your code.  Now, besides those inline 
comments, you have doc strings. 
Doc strings or documentation strings are a really crucial part of 
documenting a certain module or a function. And ideally, It's every 
single function should have one docstring. Docstrings are 
surrounded by triple quotes in Python. And the first thing is to 
explain briefly what function it does. 
After that, if you have some arguments, you're going to explain 
what those arguments are, how to provide those, and then explain 
what are the types of data that is expected inside of that in that 

The Complete Python Book 
 
707
function. Additionally, if you have some functional return or return 
statement. So some value that you're going to return further, you 
need to explain what people should expect. 
So yeah, that's basically it.  Finally, it is common to provide some 
description of the output, as I said, for the return. But it really 
depends on how you structure your other piece of code.  Besides 
that, we have the project documentation. And as I said, You're not 
going to do that alone.  If you're on the GitHub, there is a readme 
file that needs to consist of everything. 
And if you're building an API, you have API documentation. So 
stating every single call, what's going to happen. And that's really 
important to know, because sometimes you're going to have 
additional arguments, additional comments and stuff like that.  So 
generally speaking about like the whole package and about the 
whole project, readme file, is it minimal?  
It should explain its dependencies, what is, how to set it up, how to 
start working with it. Is it for new developers or for external 
partners? It really depends on who is your target audience. Ideally, 
both. But then if both, you're going to split up to different files. So 
one is going to be for your fellow programmers, another for your 
external partners.  
Now, the translating your ideas and thoughts formally on the paper 
can be a little difficult, but you'll get better over time. And of 
course, following others and best practices in the place will help 
you a lot. When you set it up. Writing this documentation can also 
help you improve the design of your code, as you're forced to think 
about design decisions more thoroughly. 

The Complete Python Book 
 
708
It also helps future contribution to follow your original intention, 
which is really important.   
 
 

The Complete Python Book 
 
709
 
 
 
 
 
 
 
 
 
 
[B/I/G/A] Testing Your Code 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
710
 When you develop your program, the testing is a crucial part to 
guarantee your quality of the code. Because sometimes you will 
focus more on the functionality, but not on design principles, and 
then the speed or lacking some protection will be in place. So, 
testing to make sure that every scenario that you can predict is 
covered, tested, and then users are not experiencing that in 
production is really good practice. 
There are several ways to test those. One, the simplest one, is the 
unit test. A unit test is just a small piece of code that will test a 
single function or single functionality of that function. To make sure 
that that covers or if there is a bug to uncover those bugs and when 
while you develop there are two ways to do that you can develop 
tests and then develop the function that you're going to test or vice 
versa. 
Then we develop the function and then test it while you are 
developing it further.  Both approaches work for different people. 
Me personally, I like to write the function and then test it after.  
Whatever works for you. The unit test is a, as I said, small piece of 
code that you're going to execute to make sure that this small piece 
of code will prevent that case to happen. 
For example, if you are logging in, to predict, for example, when 
something let's say, might occur in the case of, I don't know, 
sending a free or empty string. That might be bad. If you are not 
handling the empty string, that might cause the user to experience 
that themselves. For example, clicking the send button 
unintentionally and sending that login with the empty string 
attached.  

The Complete Python Book 
 
711
Now, the unit test, as I said, will test that piece of code. However, 
in most cases, the combination or, Connection between different 
pieces of code will cause the error. And that's called integration 
testing. To make sure that integration between different pieces of 
code will make sure that they work seamlessly together.  
And yes, you need to test individual parts, make sure that those are 
working flawlessly by themselves. Now when you're sure that those 
are not making mistakes by themselves, now you want to integrate 
them together, which is the goal of your system. So how the login 
will interact with your database is the database preventing like with 
checks and stuff like that.  
And this is an important function that works well with in isolation, 
but you need to make sure that everything from end to end is 
tested. Now, there are many different tests that you can perform 
on your code while developing like small tests, functional testing, 
and so on.  One more thing that I want to show you and or share 
with you in this video is functional testing. 
Functional testing is a type of testing that focuses on the 
completing functionality of a specific application. For example, 
when you're already ready to deploy something, you would like to 
test it in unconventional ways. It's most cases going to be in the 
games, for example, going out of bounds, shooting different things 
or doing friendly fire in some applications in games. 
Then in the web applications, you might go and test it and log in 
with the different scenarios, clicking those buttons and stuff like 
that, going to admin page without being an admin, all those sorts 
of stuff like, so basically as a user. Derek. A lot of different testing 

The Complete Python Book 
 
712
cases that you can employ to do that automatically, so you don't 
have to do that manually and check everything, but you still can. 
Okay, so basically whenever you start developing something, it's 
important to have some test coverage. It doesn't have to be 100%, 
but you need to make sure that you are testing it in the right way, 
in the right cadence, so you're not leaving a lot of untested code 
behind that might cause the error in production when you put that 
in the user head. 
 

The Complete Python Book 
 
713
 
 
 
 
 
 
 
 
 
 
[I/G/A] Working with Teams on GitHub 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
714
Resources for this Chapter: 
Comprehensive Resource for Using GitHub Like a Pro: 
https://www.freecodecamp.org/news/how-to-use-git-and-github-in-a-
team-like-a-pro  
Please note, on the following page is a helpful image that we will refer 
to during this Chapter. Thanks 
 
 

The Complete Python Book 
 
715
 
 
 

The Complete Python Book 
 
716
GitHub is one of the best places to start working with your teams. 
And in most corporations today, GitHub is the only place where 
you're going to collaborate. Like your teams collaborating on a 
certain project in a certain repository, you're going to work 
together on making that large piece of software flawlessly 
deployed. 
You need to make sure that it works in the intention, intended way.  
And when you start working on GitHub in a more of a casual way, 
alone in your room, that might not be translating directly to 
something that you might occur, that might occur in the 
production. As you can see here on this image, this is just a normal 
flow of Working with some teams. 
You will have one master branch that nobody can contribute 
automatically. You need to pass all the tests that we mentioned in 
the previous video. So that master will be something that user sees. 
Now, between master and Dev, you have something that we call 
staging, and that staging will have just first, uh, set of tests passed. 
We are deploying that to a certain version, testing it manually and 
everything. And then that, that is generally a test staging 
environment that basically behaves normally as a production, as a 
master environment. But it's only available for us or a closed group 
of people.  This is done just by a couple of people in your team. 
You are not one. In most cases, you're not the one who is going to 
deploy that to the master or to the staging. But some of the senior 
colleagues will do that. for you.  Or if you have the full DevOps 
team, them are who are going to do that.  Then you have a dev 
branch. Dev branch has everything. inside of it. 

The Complete Python Book 
 
717
So, some of the features that you might not release, some of the 
features that you are going to release in the future, but generally 
everything that works will be in the dev branch.  Now imagine that 
everybody is contributing to the branch every time that somebody 
wants. When you start working on your feature that somebody 
gave you to do as a task, you're going to create a subbranch from 
dev, it’s going to be called as a name of that, uh, or idea of that 
particular task that you're going to solve. 
That can be v1. 2 or 1. 5, whatever.  That's your feature branch. On 
that feature branch, you're going to contribute, work, work, work 
alone with, uh, with colleagues and start everything, like testing. 
You have all the standards for writing a clean code, for writing a 
testable code, everything that you need to do in your branch 
separate until you are actually ready to deploy that.  
When you're ready, when that feature that you deployed or 
implemented works, you need to make a pull request. Pull request 
is something that is really common in development. We're going to 
talk about that later. But generally, that is a set of checklists, 
basically, that people, somebody from the team will go through 
your code that you wanted to merge now with the, with the dev 
branch. 
And Check everything if there is according to their team standard.  
Is the commented code documented, testable, workable, 
optimized, everything. If that is fine, then you go and do the merge. 
They approve or disprove, they disprove, you go back, remove that 
or add some of those things, change the things and when they are 
ready, merge them to the dev.  

The Complete Python Book 
 
718
Dev constantly goes and functions and functions until you reach to 
deploy some new version, which is branching off from the dev to 
staging and then Uh, master. So yeah, this is just an explanation of 
this graph. Um, it's a fast explanation on GitHub that how it works 
in the real world in the production. 
 
 

The Complete Python Book 
 
719
 
 
 
 
 
 
 
 
 
 
[I/G/A] Questionnaire on How to Conduct a 
Code Review 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
720
Here is an amazing resource on a questionnaire for code reviews: 
https://www.sdlcforms.com/PDFClientsDownload/Code_Review_
Checklist.pdf 
 
 
 
 

The Complete Python Book 
 
721
 
 
 
 
 
 
 
 
 
 
[B/I/G/A] Quiz for Level 13 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
722
Please answer the following multiple-choice questions. At the end 
of the quiz are the answers.  
1) Why is writing clean and modular code important in 
software development? 
a.  It allows code to be reused and maintained more 
easily 
b. It ensures that the code runs faster on the 
computer  
c. It automatically documents the code  
d. It is required for all Python software to be 
compliant with the latest version. 
2) What is a convention in Python naming for a variable? 
 
 
a.  CamelCase 
b.  CAPITALIZED_WITH_UNDERSCORES 
c.  Leading underscore followed by camelCase 
d.  lowercase_with_underscores 
 
3) In Python, what is the purpose of documentation strings 
(docstring)? 
 
 
a. To optimize code execution speed   
b.  To provide a detailed explanation of how the 
code works 

The Complete Python Book 
 
723
c.  To serve as a placeholder for future code 
d.  To exclude code from the execution 
 
4) What is an important reason for testing your code? 
a.  To make the code look more complex and 
sophisticated 
b. To confirm that the code operates as expected 
under various conditions   
c. To increase the compilation time   
d.  To use up more memory resources efficiently 
5) Why is beneficial to use version control systems like 
GitHub when working with teams? 
 
 
a.  It provides a backup of the code 
b.  It tracks changes to the codebase and allows for 
collaboration among developers. 
c.  It automatically writes and tests code 
d.  It makes code run faster due to distributed 
version control 
Answers:  
1) A) It allows code to be reused and maintained more 
easily. 
2) D) lowercase_with_underscore 

The Complete Python Book 
 
724
3) B) To provide a detailed explanation of how the code 
works 
4) B) To confirm that the code operates as expected 
under various conditions 
5) B) It tracks changes to the codebase and allows for 
collaboration among developers 
 
 

The Complete Python Book 
 
725
 
 
 
 
 
 
 
 
[I/G/A] LEVEL 14: USING PYTHON 
IN EXCEL 
 
 
 

The Complete Python Book 
 
726
 
 
 
 
 
 
 
 
 
 
[I/G/A] Introduction to Using Python in Excel 
(What, Why and How of Level 14) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
727
 Welcome to Level 14. In terms of the what, why, and how of Level 
14, let's kick it off with a what. What will we learn together? We 
will learn about using Python inside of Microsoft Excel.   
In terms of why should we learn about using Python in Excel? 
Because Microsoft has sold more than 1 billion copies of Excel since 
it was released. And although Python is much more powerful than 
Excel for data analysis, Excel is easy to use for quick data analysis 
and it is used by many less tech savvy senior executives.  Also, 
Microsoft has made it so easy to run Python in Excel as a Python 
code is not run in Excel, rather it's run in a container in the cloud 
and then sent back to Excel. Now, to be objective, this could be a 
security risk for your company.   
Lastly, how? How are we going to learn about using Python in Excel 
together here in Level 14? We'll have exercises that we will do 
together during Level 14 in order to understand how to access 
Python in Excel and how to simply type equals py, open and close 
brackets, in Excel in order to add infinitely more power to your 
Excel spreadsheets.  
Now, in addition to the exercises that we will do during Level 14 to 
learn about Python in Excel, at the end of Level 14, we also have a 
quiz to help us reinforce what we have learned together. 
 
 
 

The Complete Python Book 
 
728
 
 
 
 
 
 
 
 
 
 
[I/G/A] How to Install Python In Excel 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
729
Resources for this Chapter: 
How to Run Windows on a Mac: https://www.parallels.com/  
 If you click on the formula bar here and you see the Python icon 
right here. Then you have Python installed in Excel. If so, please skip 
the rest of this Chapter.  
 
Now, eventually Python in Excel is going to be available for all users 
of Excel. But at this point, it's a beta feature. And as of the recording 
of this video, Python is only available in the Windows version of 
Excel.  
However, I'm using a Mac with Windows on it, using a program 
called Parallels. In order to run the Windows version of Excel on my 
Mac. And for more details on installing Windows on a Mac, please 
see the resources in this Chapter. Let's talk about installing Python 
in Excel on Windows. So step one in Excel, what you do is you go 
here to File. 

The Complete Python Book 
 
730
 
Then what you do is you go down here to Account.   

The Complete Python Book 
 
731
 
Then you select the Microsoft 365 Insider right here.   
And then here in this dropdown, you're going to select the Channel 
to Beta.  

The Complete Python Book 
 
732
 
The beta channel here, change the channel for beta, and what will 
happen is you'll be able to make sure you select this beta here.  
 

The Complete Python Book 
 
733
Now if at this point you still can't see the Python icon, then please 
do one of the following three things. 
Number one, contact your technology administrator at your 
company.   
Number two, search for how to install Python and Excel on 
Windows.  
Or number three, go to the following website.  
https://config.office.com/    
Then please follow these steps:  
 
 

The Complete Python Book 
 
734
Please note that if you work in a big company, your technology 
administrator might not want to enable the Python feature for 
security reasons, as Python is run in the cloud when you use Excel. 
 
 

The Complete Python Book 
 
735
 
 
 
 
 
 
 
 
 
 
 [I/G/A] How to Use Python In Excel 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
736
 Let's talk about how easy it is to use Python and Excel. So let's go 
here to the formula ribbon. And then what you can do is you can 
click here on this Python icon here to insert code.   
 
Then what you do is you start typing your formula right here.   
 
What you can also do is in any cell, you can type equals py and then 
open brackets. And then you put the code right here.  You can even 
click on a cell and go up here directly, and then type equals p y open 
brackets, and it will switch directly to, to Python mode. You don't 
have to close the brackets after that, just switch it to Python mode.  

The Complete Python Book 
 
737
 
I recommend entering the code up here in the formula bar. Drag 
down this box here so you can get some more space where you can 
enter in your code.  
 
And  if you can't see this formula bar here this line here, what you 
can do is you select view and then you select the formula bar right 
here.   

The Complete Python Book 
 
738
 
Now, when we use Google Colab for Python, we know that if we 
want to use a variable, let's say in a formula, you have to define it 
above the formula, or the formula won't recognize the variable 
when it runs the code in most cases. 
In Excel with Python, it's a similar process. If you define a variable, 
for example, in a certain cell,  then what you can do is you can 
reference it if you type the code in a cell below it or to the right, 
but not above it.  
And I'm going to show you an example of this. What I'm going to 
do right now is I'm going to go here, I'm going to type equals py for 
Python,  and then I'm going to type this: name = “Titanic.”   

The Complete Python Book 
 
739
 
In order to run this code you press control and enter to run the 
code or commit the code. So control and enter, control and return.  
Okay, so now we see that Jack is in this box in cell G5. 
 
Now, right below this cell, what I'm going to do is I'm going to insert 
more Python code, per the image below. 

The Complete Python Book 
 
740
 
Now, sometimes the more code you type, the longer it takes for it 
to run, because what happens is, all this stuff is being run in the 
cloud.  
Now, the one thing about Excel is it's a little bit different from 
Google Colab. Colab we know reads top down.  What Excel does 
with Python is it reads left to right and then top to down. So if we 
define a variable and enter the code in cell Z100 and we reference 
the variable in code in cell A1, then it will not work.  
When you're first starting to use a Python Excel, a best practice is 
to define your variables up here in cell A1. And that way the code 
you type on the right of that and below it will still get recognized 
and you'll have fewer errors this way.   
If you defined a variable in a cell on a sheet before the sheet you 
are currently working on, then what happens is that variable name 
takes precedence over the left and top down methodology. 

The Complete Python Book 
 
741
What if we wanted to reference the contents of a cell using Python 
code in Excel? Per the image below, we type xl and then open 
brackets:  
 
In fact, if you are typing Python code in Excel and you click on a cell, 
Python adds the xl(contents) code for you.  
When you run the code from a certain cell,  it runs every single cell 
in Excel.  And, if you have code in tons of different cells, that can 
really slow down your computer.  
What you can do is, you can turn this feature off, so that it only 
calculates or runs the code in a particular cell when you hit the 
checkbox or you hit control, enter. 
Let me show you (per the image below).  So what you do is you go 
here to formulas  and then calculation options.  And then right 
here, it's set to automatic. So every cell automatically updates 

The Complete Python Book 
 
742
when we're using Excel, even when we're not using Python.  But 
we can click here partial. And what partial will do is it won't update 
every cell, just the cell we're typing in.  
 
Or what you can do, and I don't recommend this, is you can go to 
manual, which basically won't allow you to calculate anything in 
Excel or Python in Excel unless you hit enter in an Excel cell. Or you 
hit control enter when you're typing Python directly in a cell. I 
prefer to leave calculations on automatic.  
Per the image below, a cell you see an image that is an object or a 
group of objects. If you click the object, what you'll see is that this 
here is a string and you also see the output of the object’s code.   
 

The Complete Python Book 
 
743
 
 
 
 
 
 
 
 
 
 
 [I/G/A] Exercise 14.1: Using Python in Excel 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
744
Please complete the following steps:  
Step 1: In cell A1 type Jack 
Step 2: In cell A2 type Rose 
Step 3: Using Python code in Excel, in cell A10 define 2 
variables. One is name1 and the other is name2. Assign the 
name Rose to name1 and assign the name Jack to name2 by 
referencing what you typed in cells A1 (meaning Jack) and 
A2 (meaning Rose). 
Step 4*: In cell A11 use Python code to write this: Rose 
should have given Jack a lifesaver and not a lightsaber.  
*For Step 4, please make sure to reference the variables 
Jack and Rose meaning name1 and name 2.  
 
 
 

The Complete Python Book 
 
745
 
 
 
 
 
 
 
 
 
 
 [I/G/A] Answer 14.1: Using Python in Excel 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
746
Here are the answers:  
Steps 1-3:  
 
Step 4:  
 
 
 

The Complete Python Book 
 
747
 
 
 
 
 
 
 
 
 
 
[I/G/A] Using Dataframes with Python in Excel 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
748
 The power of using Python and Excel is you can use data frames, 
which are awesome.  Now in the third chapter of Level 11, per this 
graphic, we discuss data frames. Now that chapter is called, that's 
the third Chapter in Level 11. It's called Loading Data Using Pandas 
and Polars. Now, if you haven't read that Chapter, if you want, 
please read that Chapter, and then come back to read the rest of 
this Chapter.  
Python in Excel uses Pandas, which is amazing when working with 
data. When we use Colab, if we wanted to use pandas, recall we 
had to import pandas. But in Excel, the cool thing is that you don't 
need to import it. It just works when Excel runs with Python code 
in the cloud using Anaconda. That's the Python code used up in the 
cloud, the Python product. 
And that's a version of Python, Anaconda, snake reference again, 
that data scientists love to use. But for our purposes, for now, 
please think of dataframes. as being a simple table.   
Per the image below, I created a table in Excel:  

The Complete Python Book 
 
749
 
Then I named the table startanic, so we can reference it in our 
Python code: 
 
 

The Complete Python Book 
 
750
In cell D6 let’s create a dataframe: 
 
Now let’s run the code and if we click on the dataframe in the cell, 
we can see the contents of the dataframe:  
 
If we want Excel to show the contents of the data frame, we select 
Excel Value:  

The Complete Python Book 
 
751
 
Now we can see the contents of the cell:  
 

The Complete Python Book 
 
752
Per the image below, we can click on Diagnostics beside the Python 
icon and we can get information on our code, and also see errors, 
just like we see in Colab. We also see that libraries like NumPy and 
Pandas are already installed for us.  
 
Per the image below, in cell D12 I can get information about the 
dataframe by typing titanic_dataframe.describe() 

The Complete Python Book 
 
753
 
 
 

The Complete Python Book 
 
754
 
 
 
 
 
 
 
 
 
 
[I/G/A] Exercise 14.2: Using Python 
Dataframes in Excel 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
755
Please complete the following:  
Download the Excel file (not the CSV) from 
github.com/chrisharoun/Titanic_Data  
 
Step 1: Highlight all the data and make a named range 
called titanic_data. 
 
Step 2: In any cell on the right of the titanic data, create 
Python code to assign titanic_dataframe to the  range 
created in Step 1.  
 
Step 3: Use the describe method to describe the Age 
column and find out what the mean meaning average age 
was of the people on the Titanic. 
 
 
 

The Complete Python Book 
 
756
 
 
 
 
 
 
 
 
 
 
[I/G/A] Answer 14.2: Using Python 
Dataframes in Excel 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
757
Step 1:  
 
 
 
 

The Complete Python Book 
 
758
Step 2:  
 
 
 

The Complete Python Book 
 
759
Step 3:  
 
 
 

The Complete Python Book 
 
760
 
 
 
 
 
 
 
 
 
 
[I/G/A] How to Create a Linear Regression 
Using Python In Excel 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
761
 Let's use the exact same Titanic data set for our regression analysis. 
So we're going to start by highlighting all this data here and naming 
it Titanic data, which we already did before: 
 
And what I'm going to do is I'm going to type equals py(. Then what 
we're going to do is we're going to import an incredible Python data 
visualization library called Seaborn.  By typing this we'll type import  
seaborn as sns.  

The Complete Python Book 
 
762
 
Now we define our dataframe:  

The Complete Python Book 
 
763
 
Let’s create a regression analysis for age and fare: 
 
 
And let's run this: 

The Complete Python Book 
 
764
 
 
We see  we have a very slight correlation between age and fare. 
I actually ran a separate regression analysis on this using the data 
analysis, a regression feature in Excel. And it was a couple of 
percent above a 50 percent correlation. 
 
 

The Complete Python Book 
 
765
 
 
 
 
 
 
 
 
 
 
[I/G/A] Quiz for Level 14 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
766
Please answer the following multiple choice questions. At the end 
of the quiz are the answers.  
1) True or false: If you define a variable using Python code 
in Excel in cell Z100 and then in cell A1 you reference the 
variable using Python code in Excel, then you will get an 
error.  
a.True 
       b. False 
 
2) When using Python in Excel, the way to enter code that 
references cell A1 is as follows:  
a. xls(“A1”) 
b. xl(A1) 
c. xls[“A1”] 
d. xl(“A1”) 
 
3) If we wanted to see statistics about a dataframe called 
titanic_data that we created using Python in Excel, we 
would use the following code:  
a. titanic_data.describe() 
b. titanic_data.describe 
c. describe.titanic_data() 
d. describe.titanic_data 
Answers:   
1) a 
2) d 
3)  a 
 

The Complete Python Book 
 
767
 
 
 
 
 
 
 
 
[G/A] LEVEL 15: MOJO 
 
 
 

The Complete Python Book 
 
768
 
 
 
 
 
 
 
 
 
 
[G/A] Intro to Mojo (What, Why and How of 
Level 15) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
769
 Welcome to Level 15. In terms of what, why, and how of Level 15, 
let's kick it off with the what. What will we learn together?  We will 
learn about Mojo, which was released in 2023. Now, think of Mojo 
as Python on steroids.   
In terms of why should we learn about Mojo? Because Mojo not 
only allows you to run Python much faster, but also is secure and 
safe as languages such as Rust. And people say it is going to be a 
future of AI development.   
Lastly, how? How are we going to learn about Mojos together here 
in Level 15?  We will learn how to install Mojo and how to use Mojo 
online without any installation. At the end of Level 15, you will have 
a quiz to help you reinforce what you learned together. 
 
 
 

The Complete Python Book 
 
770
 
 
 
 
 
 
 
 
 
 
[G/A] What is Mojo and Why is it a Gamer 
Changer for Python Developers? 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
771
Resources for this Chapter: 
Mojo Website: https://www.modular.com/max/mojo  
Mojo Programming Manual: 
https://docs.modular.com/mojo/programming-manual.html  
Modular: 
https://developer.modular.com/login?redirect=http%3A%2F%2Fplayg
round.modular.com%2Fauth_callback  
Matrix Multiplication in Mojo: 
https://docs.modular.com/mojo/notebooks/Matmul.html  
Modular on GitHub: https://github.com/modularml/mojo  
 
 I'm more than excited that we will cover module programming 
language in this course as well.  Me personally, I've been working 
and using Python for past 7 years, and it is my favorite language by 
far. And I know and I did use 10 of those in my career.  And Python 
is my favorite.  But when they announced Mojo, and with all the 
advantages of this programming language as it's marketed, I 
couldn't buy notice that it has amazing advantages over Python, 
and it is marketed as a future of AI development or programming 
languages for AI developers.  
And when we start thinking about this course, I wanted you to get 
the taste of new programming language as well because we've 
been covering Python so far. And from now on, I want to just get a 
little bit of a taste of what Mojo can do. And as they develop Mojo 
in the future, we will update this module as well. 
So, you will be on the frontier of learning this programming 
language as well. And I already noticed some of the job positions 

The Complete Python Book 
 
772
around the world are already asking for beginning, beginner 
knowledge of Mojo because. it is by far faster of Python. Python is 
amazing, but it has some quirks, for example, it is really slow. 
It is a really difficult to do, almost impossible to do threaded 
programming or parallel programming. So, when it comes to AI 
development any library is developed in C and C to make it. a bit of 
a small bit of faster. When it comes from normal Python 
programming to lower Python programming, in most cases you will 
lose a lot of speed.  
When they announced Mojo and the developer of Mojo is Modular 
you can go to the links, every link that we're going to talk about in 
this video and the future ones are going to be listed as a resource 
for this very video.  So Modular is a company that works for 
basically around tools for developers and their biggest project so 
far is module or most public one, I would say. 
And it, because it's a new programming language, it was 
announced by five weeks ago and it was announced before, but it 
is announced by like given to the public five, five weeks ago. So, it's 
a really new programming language. And of course, because of it. 
It doesn't have all capabilities of Python. 
And we'll talk about which capabilities are limited now.  Now, I 
wanted to give you a brief of introduction right now to Mojo and 
give you more of a context where to find more information. So this 
is the homepage of Modular, where you can find all about Mojo 
and their development life cycle and what it needs to do and stuff 
like that. 
Also sorts of great stuff that you actually need to have or to know 
to actually unlock the full potential of  everything. And as you can 

The Complete Python Book 
 
773
see, one thing that I mentioned here for Python, for example, it's 
single threaded execution always. But in Mojo, parallel execution 
with multi course, like it's using hardware as best as it can.  
When it comes to multiplication of matrices or execution of your 
algorithms, you might think this is going to save you a lot of time. 
And I'm going to walk you through a couple of examples in a bit, 
but you can see here that it's up to 68, 000 faster than Python.  So, 
68, 000, which is crazy. And right here, for example, in Python 10, 
which is the newest one, some task that they tested on took about 
1000 seconds,  but in Mojo, it took 0. 
 
03 seconds.  When it comes to execution of these tasks in AI, the 
slowest one is training. And it can take days, weeks, and months to 
finish the training process of your AI algorithm. And imagine that 
you rewrite the whole process from Python to Mojo. And you will 
see in the future chapters that it's going to be easy. 

The Complete Python Book 
 
774
 
Not as difficult as you might think. So yeah, there is a lot of things 
that you can do. There are a couple of already Python libraries 
supported inside of Mojo. If you already know how to do, how to 
work with NumPy and Pandas, you will switch like this to module.  
Because it's a new programming language, right now it's supported 
only on Linux by native. 
And yes, there are some ways to install them on Mac or Windows. 
I'm using either Mac or Windows, so I'm not a Linux user right now. 
So, for me, it took some of the Justifications or adjustments, sorry, 
to install it properly. Now, in the future, they are going to smooth 
that process much better for us. 

The Complete Python Book 
 
775
 
This is the programming manual, the link in the resources of this 
very video. And the programming manual covers everything that 
you need to know about Mojo. Now, we're going to cover a lot 
more and broader than programming manual, but you will have 
this as a kind of a backup option to go forward. Matrix 
multiplication is just an example, also linked in the resource, to 
showcase. 
 

The Complete Python Book 
 
776
If you scroll down, they optimize it tremendously. And after so 
many optimization iterations, they ended up having this many 
times, 308, 000 times faster over, over Python. And this is 100, 000 
times faster. Then there is some 77 times faster. 98, 1000 and so 
on.  
 
And this one, for example, 77 times, 77, 000 times faster over 
Python. It becomes Clearer and clearer that if you know how to 
optimize this using Mojo, and trust me, it will get some experience 
to be able to work on this Level and optimize code in this way that 
they do. But when you're up there, you will be able to optimize your 
code in no time.  

The Complete Python Book 
 
777
 
The second thing that I wanted to show you is their GitHub account. 
So, all of the updates that they're going to talk about and they are 
actively working on it. As you can see one hour or like a go on the 
time of recording this video, they updated something. 
You, you will see everything happening here and working on 
module programming language. You can either find some error and 
propose to them that, hey, this will be amazing to implement. Now, 
at the time of recording, you will see some quirks like, for example, 
not natively supporting classes and object-oriented programming.  

The Complete Python Book 
 
778
 
And that's fine. In the future, they will add that as well. And we'll 
add that In the course, the next link is their playground, because 
there is a bit of a struggle right now to start working with those 
natively on your computers, because we can do all that in this 
virtual environment online by them, which is linking the resources 
of this video, so you don't have to install anything and you can start 
working with Mojo immediately. 
Okay, so that's one note, please, if you don't want to install or don't 
have an option to install it. please go and install and work on this 
playground that is online and free to use.    
 
 
 

The Complete Python Book 
 
779
 
 
 
 
 
 
 
 
 
 
 [G/A] Complied Versus Interpreted 
Programming When It Comes to Mojo 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
780
 Before we start working and actually programming Mojo, I wanted 
to explain one more thing.  We talked earlier in the Python course 
about compiled versus interpreted languages, and I just want to 
refresh that knowledge.  So, Python as itself is called interpreted 
language, while C, and now mojo is compiled. 
What is the difference? When you write some code in Python, and 
you execute it on the fly, it will take all of your bricks, all lines of 
code, and assemble them on the go.  So, you have this is your code, 
every single line of code, every single instruction is your small 
piece, right here.  And you want to achieve this.  
 
You want this car. These are actually the same places we bought 
two cars for this chapter. You have this car. This is what you want. 
This is your program that you are imagining that you're 
programming so far. Now, this is what you want to achieve, but this 
is your Python program.  So when you execute Python program, it 
will piece everything together and put this at the end.  

The Complete Python Book 
 
781
 
And that's why it's slow. And that's why it's interpreting languages. 
Our interpreted languages are much slower than compiled.  So, this 
is you interpret your language. Let's, let me take just one, one of 
the one of, one bag. So, you're writing code and every single piece 
has some weight and every single piece has some time to execute.  
But finding the right place, what, where to put that piece is also 
timely. And also, putting everything together is also timely.  And 
you can't execute these lines of code if you are not putting them 
together.  When you execute Python, what's happening, it will take 
all the pieces, find the instructions, put them together, put the car 
together, and drive. 
That all the things that happen before driving takes a lot of time. 
So, when you compare Mojo, C and other programming languages 
that are compiled they don't have that initial step, which is 
execution, or I would say making the program.  So, they are already 
in the format of this. They are already a car.  
Okay, so this car is compiled, already assembled, already there for 
you to drive. Now I can just use and drive that, drive it anywhere 

The Complete Python Book 
 
782
that I like.  But Python code is not like that. It's in a bag. It's in a bag 
that is ready for you to assemble when you start executing. So, you 
will reach this, yes, but it will be much slower because you need to 
go through every single step. 
And that is interpreted language. While compiled is already here. 
When you write a compiled language like mojo or c plus, you are 
going to compile it, which is going to tell computer, okay, here is 
what you need to do. Here are zeros and ones that you need to 
execute in this order, in this very order, in this sequence.  
And it'll be packaged like this. If you ever worked with games 
installed games on your computer programs, it doesn't have to be 
a game, you have that exit file on Windows.  Exifile is basically a 
compiled code that is a car you are going to click, install, and that 
you're ready to go into the game and play.  
Now, it took several years to make that game and also several 
hours or days to make that executable file, which is a car. On your 
end, you just install it and you're ready to drive.  So that is the 
advantage of compiled versus interpreted. But when it's compiled 
on your computer, you can't call your support and say, hey, please 
change this variable. 
So that's, that can be done on compiled, but it can be done in the 
interpreted languages. When you every language has some 
advantages over the other. And in Python case, it's fast, it's easy. 
It's, I would say the most agile programming language out there, 
but it was not as fast as, for example, C  now we have as agile 
programming language with each module and still much faster than 
C   
 
 

The Complete Python Book 
 
783
 
 
 
 
 
 
 
 
 
 
[G/A] Coding with Mojo 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
784
Lucky for us, Mojo the same syntax as with Python,  so you can just 
execute this.  Yeah, mojo, print, hello world. 
 
Now, because we are using this in their environment online, online 
one, you don't have to provide something called entry function.  So 
because it's because it's a compiled language, you can have as 
many files as you like. You have a starting point on a program and 
that's where everything starts to execute. 
You need to execute or start compiling. The rule is, okay, first set 
the base and then start building the base and start building every, 
everything after that. Now that rule is called function main.  Don't 
worry about syntax of this just yet. We'll talk about that in a second. 
So, if I go and print hello world like this,  

The Complete Python Book 
 
785
 
You will have the main function, which can be called  and hello 
world works.  Now, this is something called entry point. Entry point 
in compile languages in most cases are called name. And as main 
function will be the entry points telling your program, here's where 
to start. Now, because we are in this online environment, we don't 
have to use this, but we'll show you how to do that when you 
switch from this to normal module file.  
 

The Complete Python Book 
 
786
 
 
 
 
 
 
 
 
 
 
[G/A] Variables in Mojo (Mutability and 
Immutability) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
787
 We will define an A, and then define 10, and then basically try to 
increase it, and so on. It will work.  But in compiled languages, you 
have a problem with that. You need to explicitly say which type of 
it is. And that's something that Python does dynamic. So, it's called 
dynamic typing, which by default, it will just from the value itself, 
extrapolate which type or data type, the value that we are defining 
should be.  
 
Now let's see what we have in in Mojo. Mojo, because it's a 
compiled programming language, defines three ways to define 
variables. It's let, var, and alias.  And I want you, yes, you can define 
it like this, but try doing that doing that only with let, var, and alias 
because that is something that Mojo actually prefers. 

The Complete Python Book 
 
788
 
So let is the first way to define a variable.  Let is something that 
allows you to define a variable, its value. but becomes a constant. 
And because it's a constant, it allows you it doesn't allow you to 
change its value. It became immutable. If I go and do this, define 
and add four, it will fail because it, we try to add four to this, and 
we wanted to print out, it will fail.  
 

The Complete Python Book 
 
789
Now, if we go and do this, it will still fail because it's a compiled 
language and it knows that it’s there is a let variable that I wanted 
to change.  Changing a let value is something that we cannot do in 
Mojo. Now the other approach is var. Var is there because it's a 
variable, so it varies, and here it actually works because variable 
allows you to actually use and change its value.  
 
So, if you want to change some value after, after its definition, like 
counters and stuff like that, always use var, because with let you 
can't do it.  Now, the third approach is alias.  Alias is compiled and 
it becomes immutable while compiling. Now, here because of it, it 
actually stored the value and helped me actually to do that in a real 
time. 

The Complete Python Book 
 
790
 
Now, it is still let's change to B to refresh the value. Here, it actually 
became immutable because it stored A previously.  And now it has 
the new value, which is alias. And that's why it became immutable. 
This can be changed, but while compiling, it will become 
immutable.  
 
It is a let equivalent to compile time.  Make sure that you are using 
a var if you want to change variables and values of this.  So now 

The Complete Python Book 
 
791
that we know about let, var, and alias, let's move on and speak 
about data types. 
 
 
 
 

The Complete Python Book 
 
792
 
 
 
 
 
 
 
 
 
 
[G/A] Data Types in Mojo 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
793
 So back in the Python, we had string, integer, floats, and Boolean 
data types. Now, we are not speaking about lists and stuff like that, 
that are considered data types, but more advanced ones.  In Mojo, 
you still have that, but they are functioning in a more restrictive but 
freedom a way. So let me explain that.  
 
When you define a variable here, let's say we are going to define a 
B, or let's change it to C. You can define like this. However, that is 
only available to you when you're refining like in this normal file. 
When we start introducing that into a function and speak about 
functions in Mojo, you can't do that because you need to explicitly 
say which data type you are expecting it to have. 

The Complete Python Book 
 
794
 
It's an extra work, but it's really important because Mojo allows you 
to do that in a really quickly time. So here.  When I define a C, I 
need to provide a data type. How to do that. You can define with 
two dots, and then you define either string. So, there is, let me 
comment above.  There is a string. 
 
There is integer, float, bull and U. And let’s talk about each of them. 
We know about string.  String is as before a text. So let's say it's a 

The Complete Python Book 
 
795
look and instead of see, let's call it a name.  And when I want to 
print it out, I can just print name.  Now, this works, but what if I go 
and define float? Now, it will fail, because it expects floaty number, 
and I gave it a string. 
 
Of course, it's going to fail. And that's why it's a bit trickier to go 
and implement anything in like a straight line of code. Because if 
you define some data type, you are expected to deliver the data 
type, which in Python, you don't have to, you can change anything 
to anything. 

The Complete Python Book 
 
796
 
And many mistakes are happening in Python programming because 
of that. Here. You don't have that mistake.  Now, besides, besides 
string, you can, by the way, you can do any of this let, let var and 
alias to this. It doesn't matter. I'm just going to go with var because 
it's much faster. And you can go and define C, which is going to be 
int, and that's going to be  and here I'm going to name.  
 

The Complete Python Book 
 
797
Sorry, C.  One thing to notice, this I am uppercase.  There is this int, 
which is lowercase, which is similar to Python, but it's not the same.  
Then, we'll explain that in a second. Now, besides integer, you have 
something called uint.  Uint is something that we don't have in 
Python. And this uint require us to, to provide how much 
information, how many bits are going to be inside of this uint. 
 
So uint can be 16 8, 16, 32, or 60, 64. Now, all of that is fine. And 
that just provides how many unique numbers can be, or how long 
the number can be there in that sequence.  Uint stands for 
unsigned integer, which, for example, if you go with minus 10, it 
will become the lowest number that it can get, because it is, it 
should be unsigned, okay? 

The Complete Python Book 
 
798
 
And when you're doing this, make sure that it's going to be integer 
that is positive, okay? It can be negative. If you want positive 
numbers, go with positive.  Besides that, we have float and bool, 
which behaves the same as in Python.  The bool becomes true or 
false, and then you have then you have float to do floating 
numbers. 
 

The Complete Python Book 
 
799
Now, if you want to convert this, for example - d, it can't, it doesn't 
work as in Python.  Now, one thing to know, in Mojo, you might 
notice that the integer as a note, as I told you, is a capital I, which 
is a different from Python int with a lowercase I. The difference is 
on purpose, and it's actually a good thing. 
 
In Python, the integer is a type that can handle really big numbers 
and has some extra features like checking if two numbers are the 
same object. But this comes with some extra baggage. And you 
know that Python comes with a lot of extra baggage and that's why 
it's slow.  But this comes with something that Mojo wanted to 
prevent. 
And Mojo's integer is, because of that, a bit different. It's designed 
to be simple, fast, and to turn from computer hardware to handle 
quickly.  This made the choice for two main reasons.  Given 
programmers who needs to work closely with computer hardware, 
like a system programmer, a transparent and reliable way to 
interact with hardware. 

The Complete Python Book 
 
800
They are on frontier to actually integrate with the CPUs and GPUs 
and they need it. And there is something called just in time 
converters, which is just needs something to be really fast. And just 
in time compilers, not converters, sorry for that, is.  is a way to, 
when you need it, to compile it.  And because of this, Mojo works 
well with Python without causing any issues. 
By using a different name, int instead of int, we can keep both types 
in Mojo without changing how Python actually int works.  And as a 
bonus, int follows the same naming style as other custom data 
types you might create in Mojo in the future. Additionally, int or int 
is a struct that's included in Mojo's standard set of tools that we 
can use right now.  
So yeah, it's a strong typing and even though you can still use 
flexible types like in Python, Mojo lets you use strict type for 
checking. Type checking can make your code more predictable, 
manageable, and secure, and you can't change anything in the 
module because of that, if you're strongly defining and depending 
on your types. 
Okay, so before we close this Chapter, one more thing to note, you 
can define string integer, sorry, with 16, 32, and 64, and depending 
on how many things you can store there. If you define integer 8, it 
doesn't, it can't store like many numbers. It will be like, for 
example, 6, but it can store to 250, 6, and then it will start doing 
again. 

The Complete Python Book 
 
801
 
A loop. So basically, that's why it has end of eight. If I go in 54, it 
will be minus four, minus two. You see, so two 50 minus six.  So, it 
is a bit weird, but yeah it works. As intended.  If you want bigger 
numbers and you want to store all of that, use 60. Now this will 
work perfectly when you know how and which numbers to expect 
in your code. 
 

The Complete Python Book 
 
802
When, for example, when you were talking about neural networks 
and AI algorithms, in most cases, they're going to be float 32 or 
float 60. Four, depending on the precision that they were trained 
on. So, if you want to convert all the algorithms inside of Mojo, you 
are going to care about the weights as well. And that will also save 
a lot of memory and resources on your end. 
 
 
 

The Complete Python Book 
 
803
 
 
 
 
 
 
 
 
 
 
[G/A] Else If in Mojo 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
804
 When you're building a program where that depends and wants to 
execute a certain piece of code, depending on what's happening in 
the inside of the program, you need something called if and else, 
or else if.  And we talked about that in Python. And the structure 
and in the syntax of this is the same as that. 
 
We won't spend a lot of time here. I just wanted to show cases that 
how to work with it and else in module. So, if you have an age that 
we're going to define, let age is going to be 18. And let's use 
everything that they wanted for us. Let's use 18.  And here I want 
to check if age is larger than or equal to 18. 

The Complete Python Book 
 
805
 
If yes, please enter.  Else we can't.  We can do that. So else print.  
Oops. You are too.  Too young.  
 
Yeah, too small. Like this.  Please enter. But if we change this to 14 
or 15, oops. You're too small.  Okay, so this is basically how the 
module actually works. And you can use this in all of the functions 
that we are going to cover in the future. This is just the way that 
module perceives the same structure. 

The Complete Python Book 
 
806
 
If you want to have a couple of questions, for example, let's say 
that we want a name to be a string.  It’s going to be string, and 
that's going to be Chris.  And then we are going to have this. If a 
name is equal to Chris, we are going to say print. Hello, Chris.  Nice 
to meet you.  
 

The Complete Python Book 
 
807
Then we're going to say elif. Else if is basically a way to say if this is 
not, check if something else is happening. We are going to say if it's 
Luka.  If that is Luka, print hello. Just this.  Else, print,  oops, I don't.  
 
So of course, it failed because everything here moved one tab to 
the left. Let’s switch it back and switch this one more time. And 
now it works. If I go and change it to Luka, now it works as well. But 
if I change it to whatever, oops, I don't know.  Basically, this helps 
us to.  execute pieces of code if something else is happening. 

The Complete Python Book 
 
808
 
And as you can see, the structure of everything is the same as in 
Python.   
 
 

The Complete Python Book 
 
809
 
 
 
 
 
 
 
 
 
 
[G/A] Loops in Mojo 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
810
Let’s talk about loops in Mojo.  We know that loops are there to 
execute pieces of code multiple times. So for example, if I wanted 
to print my name, of course, print needs to be happening correctly, 
look  for 10 times, there is an option to print this for 10 times. 
However, that's not a good practice. 
 
That's why in Python and Mojo and any other programming 
language, you have something called. loops. And in Python you, you 
had this for i in range 0 to 10, for example.  And then here you can 
print Luca.  Oops, I forgot here, double quotes.  And one thing that 
is amazing for us, when you're switching from Python to Mojo, this 
for loop actually works the same, has the same structure, range 
works the same. 

The Complete Python Book 
 
811
 
If I want to switch the step here to be every second, everything 
works the same as in Python. So, if you want this to work as it ended 
in Python, if you know how to do it in Python, you will know how 
to do it here as well. So, range works as good as in Python. Now 
one, one thing to note here they have a pretty weird thing about 
lists right now and lists and dictionaries and stuff like that. 
 

The Complete Python Book 
 
812
Those kinds of a more advanced data types, even classes are not 
supported. In the type of recording, which is October of. of 2023, 
they don't have these kinds of things. If you see the chapter inside 
of this module that covers all of this in the future, they added it, 
and we covered it. 
But just for FYI, for now, they don't have that for us.  Now there is 
one thing that before we jump to a second type of loop, which is a 
while now. I want to cover one, one thing, which is exit exiting the 
loop in a different way. So right now, if this happens 10 times, that's 
the only way to finish this loop.  
 
But there is a way to break it before, so if I am equal to five, so this 
break works as same, the same way as in Python. You are going to 
set it up.  you're going to check if i is equal to five. And by the way, 
you can go and set like this, and it won't work. This is not language 
that works as in C So yeah, like you, you should only follow Python 
structure right here. 

The Complete Python Book 
 
813
 
Now here if it's five, otherwise, Yeah, continue. The other one is 
continued, which works the same way as in Python. Continue will 
basically go and check, okay, if this is happening, skip everything 
below and go from the beginning. And to demonstrate this, I'll just 
print I next to it. So you'll see 0, 0, 1, 2, 3, 4, then skipping 5 because 
we jumped back and didn't execute the print and then 6, 7, 8, and 
9, which helps us to do that.  
 

The Complete Python Book 
 
814
Now, we can ask or i is equal to 8. We'll skip it twice so we won't 
have anything happening or printing when it's 5 and 8. As you can 
see right here, we don't have anything for 5 and 8.  So now this is 
something that that module supports. And as you can see, the 
structure and the syntax is the same as with Python.  
 
Now, speaking of the same as the Python, the while loop is basically 
the same. While true, for example, will allow us to execute and 
then, for example, if i is equal to 5, break. Now, one thing that we 
need to note here is this i is not defined in the same way as with us 
for loop. This will not work so, so well. 

The Complete Python Book 
 
815
 
So here, if I go and define, I is equal to five, or to zero, sorry, and 
then here I go and define I plus, I plus equal to one, it will break 
because it is a let, and I try to increase the value. For loop, you need 
to think about the structure of. of Python and the module and then 
use this and use this value of let instead of sorry, var instead of 
letting because it won't allow you to change its structure and 
change its value because it was not defined as a var. 
 

The Complete Python Book 
 
816
As we know before, you can go without strictly typing and saying, 
okay, it's a varlet and stuff like that. But if you want to get the most 
value out of Mojo, make sure to follow, please this thing and use 
varlet and alias. Okay, that’s it on loops. You have two loops, and 
you have a way to control it. 
 
For let's go and you can go and practice for example, while instead 
of this true, you can go and use less than five and then you don't 
need this and basically works the same way. The way that they are 
structuring while in for loop works the same way as in Python. So, 
when you learn that, it will be transferred directly here as well.  

The Complete Python Book 
 
817
 
 
 

The Complete Python Book 
 
818
 
 
 
 
 
 
 
 
 
 
 [G/A] Functions in Mojo 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
819
 Let's speak about functions. Functions is one of the most important 
parts of any programming language. Let’s see how to define them 
using module programming language. Now, you can define it in a 
way that you used in Python so far. For example, add two numbers 
and define a and b and then return a plus b. 
 
Now this would be basically Python's way of defining a function and 
this will still work because what they wanted with Mojo to define a 
superset of everything that Python does so you can transfer that 
Python code to Mojo pretty fast in the future.  Now this works. as 
the, as I said, as a Python function and the speed might be a bit 
slower.  

The Complete Python Book 
 
820
 
However, there is a way that it’s proper way to define it when it 
comes to module. The module structure is something like this. Fn 
instead of def add two numbers.  It's actually two numbers like this.  
Okay, two numbers.  And now if I do this, it will potentially fail. So, 
let's check.  It will fail. Why did it fail? 
 
The first thing you notice instead of def, d e f, which is define you're 
going to use fn, which is function. And if you scroll up to our initial 

The Complete Python Book 
 
821
chapter, we have this fn main, which is our first initial function that 
we define. We didn't explain it back there.  But why did it fail? The 
first thing we need to do is When you're defining a function using 
fn, which is the proper way in Mojo, you need to go and define their 
types. 
 
So here, if I go and define int 16 and here as well, int 16, it will still 
fail because we need to define the output value as well.  If I do this, 
I can call this function.  And define four and five and it will return 
like print,  okay,  return nine. Okay, so that's why you need to have 
integers or floating points or float 32 and this Won't work because 
we need to convert this to float points. 

The Complete Python Book 
 
822
 
You need to make sure that they are actually aligned with both. 
Okay, so in Python, the definition will still work in Mojo. If you are 
still struggling to completely move to Mojo, that's completely So 
you can still use this structure as you can see right here. However, 
the proper way of using functions that are faster and more 
structured in module, it's FN of there's some name,  and then you 
have variables or arguments which if you're providing, that's okay, 
then you need to provide them and you need to provide their data 
type, and on top of that, you need to provide the output value as 
well. 

The Complete Python Book 
 
823
 
Then you're going to call it, and you're going to have the output in 
the format that you're going to define right here.  That's it on 
functions. Everything else functions the same, so you have the 
return you can call functions inside, inside of the functions, all of 
that stuff that is From the Python you can go and apply right here 
as I said you can either copy and paste the Python way of doing or 
go and do it the module way. It's completely up to you, but both 
ways work.  
 

The Complete Python Book 
 
824
 
 
 
 
 
 
 
 
 
 
[G/A] Struct Versus Class in Mojo 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
825
 At this point of the writing of this Chapter, Mojo does not support 
traditional classes as you would have them in Python, but it has 
some data type called struct. Struct has a really similar format as to 
classes in Python. And if I define like this car, you have arguments 
that are that are really similar to on the class Level in Python. 
 
If I go and define max speed, now here you can define value, but 
you can define what is the going, what's going to be a data type?  
When you have var, you need to make sure that they are 
changeable. So here integer, because we don't, we are going to 
have up to seven doors. So, brand, which is going to be string.  

The Complete Python Book 
 
826
 
This is going to be an, on a struct Level arguments that you can 
change. Now, after that, you can't use def. You need to use function 
inside of. inside of this. And as for the way that your constructor 
works, it works the same way as with Python. Now, one thing that 
is, I would say different or not weird, but different than in Python 
is something called in out  self. 
 

The Complete Python Book 
 
827
And then you go and define max speed, which is. Int 16, and then 
it needs to have the same data type as above, and then you have 
doors, which are int 8.  And then you have brand, which is going to 
be string.  Now, this alone is the same.  However, this part is a 
different self is the same as in Python. However, this in out is a 
keyword that we've never seen before. 
 
And that is something unique to Mojo. We'll have a dedicated 
chapter to that in a couple of chapters from now. Stay tuned for 
that. For now, just. Follow along InOut will explain that in a second.  
So here we have maxSpeed, which is going to be maxSpeed.  So, 
then we have selfDoor, which is going to be door. Doors instead of, 
yeah, let's rename this to doors.  

The Complete Python Book 
 
828
 
And then we have self.  Brand, and that's equal to brand.  This  
alone will initialize this structure and allow you to basically do the 
data type of a car. Now, you can go and define a function inside of 
it, which is a method in this case, which is getMaxSpeed.  And then 
you need to define self, but then you need to define also put value.  
And now that we have this car, we can define a car, or we can let 
car is equal to car.   
 

The Complete Python Book 
 
829
And here in the arguments, we are going to provide max speed 100, 
then door 4, and brand, some brand, Audi, it's the shortest one, 
and that's it. Car, we can go and find get max speed.  Oops to get 
the car's max speed, but we always need to put that in print  and 
that's going to be 100.  
 
That's it. Struct right now works as the same, similar to Python's 
classes, but it has some limitations like changing the initial values 
setting the initial values and stuff like that. But overall, it has the 
same structure. And it's a data type, but it does not work as a kind 
of a Python class, which can inherit stuff, which can encapsulate 
stuff and stuff like that. 

The Complete Python Book 
 
830
 
In this case, it does not support all of that, but in the future they 
will add classes as well, which will be behaving the same way as 
with Python. 
 
 
 

The Complete Python Book 
 
831
 
 
 
 
 
 
 
 
 
 
[G/A] Error Handling in Mojo 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
832
 Because there are so many moving parts in general programming, 
especially when you're starting something that is compiled, and 
you need to make sure that everything is up to the notch and that 
everything is in the same data type that you actually expect and 
stuff like that. You need to know how to handle errors. 
 
Let’s define a function called division and basically return.  We're 
going to have two arguments.  Float 32.  B is float 32. We are 
expecting the output to be also float 32.  And A divided by B. Now, 
this is and what I'm going to do, print division of 10 and 5. Oops, 
we are missing one. bracket, and that's going to be what, however, 
if I put zero here, the answer is going to be infinite, which is an error 
because we can divide some number by zero. 

The Complete Python Book 
 
833
 
And you need to prevent that from happening because infinite 
giving the answer to users of infinite is not a good user experience. 
So one thing that you can do is go and define try and then provide 
here except and inside of this except we can either print,  for 
example, oops,  you can't  can do that, whatever. And if we call this.  
And if there was a mistake that would be show. However, because 
this programming language automatically divides this by zero and 
shows the infinite, so it's not considered an error. 
 

The Complete Python Book 
 
834
Now, if you want to raise some error you can go and say raises here. 
This shows, showcases that this function can actually provide an 
error message. So, if there was one, they would basically go and 
showcase this message. Now, what they can do in this case and go 
here, I can go raise error, some error.  
 
This does, we don't have, we don't need this print anymore 
because right now we are actually going to raise some error to user 
and say, Hey, please don't do this, or this is why this happens and 
so on. But now in this case when you are trying something, so 
anything will be Behind this door, it will make sure that it actually 
goes through to accept and then accept will raise the error, but 
then they won't get any result. 

The Complete Python Book 
 
835
 
So if you want to make sure that even if there is an error to get 
some result, you can use finally, and that finally you can return to 
zero, for example, so like this and. It won't change anything 
because we have the correct code. But now, here, you have this 
division by zero, which is now infinite. Okay it didn't report any 
error, but now I have this return statement, which is the one right 
here.  
 

The Complete Python Book 
 
836
You can see the flow. First, you will go into the try, put some code 
that might have some errors inside of it, or you can expect users to 
go into different directions. Then you can accept what's going to 
happen when are you going to show some error or whatever, and 
then finally you can go and return some value, which in this case 
became zero.  
 
 
 
 

The Complete Python Book 
 
837
 
 
 
 
 
 
 
 
 
 
[G/A] "Inout, Borrowed and Owned" in Mojo 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
838
 There was one keyword that we mentioned a couple of videos ago, 
which is in out.  And I told you just to bear with me back then, and 
I'll explain it in the future. And this is the video where we're going 
to tackle that.  In out is not the only keyword that we have for that, 
what we're going to explain. 
 
We have in out, we have borrowed, and we have owned.  These 
are a direction what we can do and let the function know what it 
can or can't do using some variables.  In out, let's say we define in 
out for a.  In out allows us to change some value of a.  And if the 
value is changed in a function, it's going to be changed outside. 

The Complete Python Book 
 
839
 
And that's why it's called in and out. If we go and say a is equal to 
100, and we execute this function, and we print a here and print a 
before. so What's going to happen is, as you can see here, first off, 
we are going to have which is the initial value of A. Then we, okay, 
call this function, which is 100 plus 10, which is 120. And now we 
are printing A again. And now it's 100 because we set it to be 100 
right here. And that's the only reason why the only reason why that 
happened is because of this in out. 
 

The Complete Python Book 
 
840
Now you can also define in and out, in out to other variables as 
well. And then it they could be changed as well inside of the 
function. So sometimes that can make sense if you want to do some 
computation, change the value there if some computation is For 
example, let's say you have some processing of a transaction in a 
bank, and you want to make sure that everything is legit, and if that 
is okay, then you want to increase or decrease the balance. 
 
So that's something that in out would make a lot of sense for.  
Besides in out, we have this borrowed. So borrowed makes the 
immutable for the function. So we can't change inside a function, 
even though, for example, a var can be mutable. Now, if I go and 
define it, to be a borrowed and put it right here. It will fail because, 
of course, it, we didn't have this as a kind of an option.  

The Complete Python Book 
 
841
 
Okay, so for now we can't do this. Let's go and define let here, let, 
and now it works.   
So that's why you can't change because borrowed does not allow 
you. And if you go here and say A plus, plus 10, plus equal to 10, it 
will fail again.  The other option is owned.  And owned overrides 
every option that we have here. So let, for example, A is let. It is 
immutable and we can't change its value. 
 

The Complete Python Book 
 
842
But because it's owned inside of this function, we can go and say A 
plus equal 100.  It will work. And if this executes, you will see that 
right now, yes, it didn't change the outside value of A, but It just 
didn't care it was a let originally, so it just overrode everything and 
say, okay, this is basically what I want to say. 
 
Okay, owned is something that lets function take control of the 
variables and do whatever they want inside the function itself.  And 
that's it. We have in out, if you want to change the value of variable 
from the, within the class structure or a function and apply that 
change to outside value as well. 
Then you have borrowed, which makes sense that, for example, 
you can't do anything, it becomes immutable.  To, to the function 
itself and the final one we have owned, which overrides everything 
that is defined outside of the function and just let it do whatever it 
wants with that value variable inside the function alone, but after 
it is executed, it goes back to the rules outside the function. 
 
 

The Complete Python Book 
 
843
 
 
 
 
 
 
 
 
 
 
[G/A] Importing NumPy in Mojo 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
844
Imagine that you can import a full Python inside the module and 
just use it. We can. From Python, we are going to import Python.  
But instead of this being wrongly typed, we can go and write it like 
this. From Python, we are using Python.  Now, there are a couple 
of modules, or libraries that Python has by default installed in this 
module version of it. 
 
You can, for example, go let np, and that's going to be Python 
import module, and then, in quotes, NumPy.  This will let you 
Import NumPy. You can do that for pandas. You can do it for 
matplotlib. And generally, most of the libraries that are supported 
in the that data science stuff. So if we want to define like some 
NumPy array, you would go and define like np.array  and then 
provide like for it.  numbers that you like.   

The Complete Python Book 
 
845
 
And as you can see here, we can call dot shape and we can print 
out array dot shape and then print and it's going to be four. Now, 
if we reshape that and say re shape that's going to be two by two 
and print it like this, it works. So, everything that you can do with 
NumPy, you can do inside of this version that is basically inside of 
modules. 
 

The Complete Python Book 
 
846
It's a bit of inception, so you can import a full Python language 
inside of the module and actually, use that kind of for data 
processing. Now you can go and do for example, let's test is equal 
to np.random.randint. And then here, if it's going to be one like 
this. And execute test. And let's print it.  
 
And we have 20, 20 numbers of randomly generated numbers from 
Nampa. So that's basically what this allows it's really cool in, in this 
super-fast compiled language, which is mojo. Now you can import 
a full Python and use the capabilities of Python that we all love and 
actually use that in a way that we used it before. 

The Complete Python Book 
 
847
 
So, it's a really easy to do now.  There is a way to import even the 
NumPy lists and just Python lists and Python objects such as 
dictionaries and tuples and sets and stuff like that. You can discover 
all of that in the documentation of Mojo, which I shared in the first 
chapter of this section. But there are some consequences with that, 
like some of them can be sped up, some of them not. 
So, they are not natively supported just yet. In the future they will 
be. But for now, I would say that this is the best of both worlds. You 
can know what the normal syntax of Mojo is, and this is just a 
starting point for you. There is a lot more to learn about Mojo on 
how to do vectorization, how to do optimization of stuff, and yeah, 
all those sorts of great, amazing stuff that Mojo offers. 
And they are going to update documentation as they add all that 
stuff that they wanted initially to add.  Cool. I'll keep you posted 
and update this module as the module evolves. So you will be 
updated as well.  And in the meantime, go check it out, 
documentation and head coding. 
 
 

The Complete Python Book 
 
848
 
 
 
 
 
 
 
 
 
 
[G/A] Quiz for Level 15 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
849
Please answer the following multiple-choice questions. At the end 
of the quiz are the answers.  
1) What is the primary advantage of using Mojo for Python 
developers? 
 
 
a.   It simplifies web scraping 
b.  It enhances game dev with Python 
c.  It offers improved performance through 
compilation 
d.  It provides a better syntax for writing Python 
code 
2) How does compiled programming in Mojo differ from 
interpreted programming? 
a.  Compiled programs are executed directly by the 
operating system. 
b.  Compiled programs cannot be executed until 
they are translated into machine code. 
c.  Interpreted programming does not allow for 
error handling. 
d.  Interpreted programs run faster than compiled 
programs. 
 
3) In Mojo, what is the significance of mutability and 
immutability of variables? 

The Complete Python Book 
 
850
a.  Mutable variables can be changed after creation, 
while immutable variables cannot. 
b.  Immutable variables are for temporary storage, 
while mutable variables are permanent. 
c. Mutability refers to variables naming 
conventions, and immutability refers to error 
handling.  
d.  There is no significant difference; they are just 
two terms for variables. 
 
4) What is the key difference between a struct and a class 
in Mojo? 
 
 
a.  Structs can have methods and classes cannot. 
b.  Classes are used for data encapsulation, while 
structs are not. 
c.  Structs are typically used for simpler, passive 
data structured, while classes can have 
functionality and encapsulation. 
d.  Only classes can be instantiated, not structs. 
5) What does “Inout, Borrowed and Owned” refer in Mojo? 
 
 
a.  File operation modes 
b.  Types of variables based on their score and 
lifetime 

The Complete Python Book 
 
851
c.  Different states of a gaming engine 
d.  Network connection statues 
Answers:  
1) C) It offers improved performance through 
compilation. 
2) A) Compiled programs are executed directly by the 
operating system 
3) A) Mutable variables can be changed after creation, 
while immutable variables cannot. 
4) C) Structures are typically used for simple, passive 
data structures, while classes can have functionality and 
encapsulation 
5) B) Types of variables based on their scope and 
lifetime 
 
 

The Complete Python Book 
 
852
 
 
 
 
 
 
 
 
[B/I/G/A] LEVEL 16: ALL BUILT-
IN PYTHON FUNCTIONS 
 
 
 

The Complete Python Book 
 
853
 
 
 
 
 
 
 
 
 
 
[B/I/G/A] Intro to All Built-In Python Functions 
(What, Why and How of Level 16) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
854
 Welcome to Level 16. In terms of what and why of Level 16, let's 
kick it off with the what. What we learn together.  We will learn in 
alphabetical order how to use every single built in Python function.  
And please think of this Level as an index that you can always refer 
to when you want to use a built in Python function.  
In terms of why should you learn about how to use every single 
built in Python function? Because knowledge of these built in 
Python functions can help you a lot to work smarter and not harder 
when you're using Python. 
 
 

The Complete Python Book 
 
855
 
 
 
 
 
 
 
 
 
 
[B/A] Absolute Value Built-In Function: abs( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
856
 
One of the Python built in function is called abs, which is short for 
absolute value. We use this built in function if we want to get the 
absolute value of a certain number, as shown in the image below. 
 
If you have a positive number and use the abs function, the 
number remains unchanged, per the image below.  

The Complete Python Book 
 
857
 
 
 

The Complete Python Book 
 
858
 
 
 
 
 
 
 
 
 
 
[B/I/A] All Built-In Function: all( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
859
 
Imagine if you have to create a function in Python that checks if 
all the values inside a list are true or above a certain limit.  You 
would need to create a for loop that goes around every single 
element and checks if that is true or not. But there is an easier 
solution for that, which is the all Python built in function, which 
returns true if all of the values inside of that list are true. 
Per the image above, if I define a list, like myList,  and that list 
contains true, true,  false,  true.  Then if I print my list, this is going 
to be false, because we have a single element that's considered 
false.  
Per the image below, if I  change the third element from false to 
true, this will result in true.  So the next time that you want to 
check if every single element inside the list is, for example, above 
five, or true in this case, you can use the all function. 

The Complete Python Book 
 
860
 
 
 

The Complete Python Book 
 
861
 
 
 
 
 
 
 
 
 
 
[B/I/A] Any Built-In Function: any( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
862
 
If you want to build a program, or a function, or just a check, to 
see if at least one item in that list is considered to be true, we can 
use the any function.  
Per the image above, we use the any function with a list that 
contains true, false,  false, and false. If we print our list, the result 
is True, because at least one item in our list is True.  
The next time that you want to build  a program that checks if at 
least a single item in your iterable ( list, dictionary, anything that 
you can iterate over) is True, then please consider using the any 
function in Python. 
 
 

The Complete Python Book 
 
863
 
 
 
 
 
 
 
 
 
 
[G/A] ASCII Built-In Function: ascii( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
864
 
Whenever we type anything in our computers,  computers don't 
really understand symbols such as characters in any language. So 
whenever you type something on your keyboard, it's directly 
moved to a certain number, which is in most often considered an 
ASCII symbol. 
For example, per the table in the image below the ASCII symbol 
for the letter A is  51. 
 

The Complete Python Book 
 
865
Now, there are multiple ways to represent a string using ASCII. 
Per the image below, we converted Hello World in Mandarin to 
ASCII using the ascii function:  
 
 
 

The Complete Python Book 
 
866
 
 
 
 
 
 
 
 
 
 
[G/A] Bin Built-In Function: bin( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
867
 
The lowest level of information in computers are zero and ones, 
which is the binary representation of any data.  And if you want to 
take and represent your string into binary, you can use the bin 
function, per the image above, which converts 10 into binary (the 
text highlighted in the image).  
 
 
 

The Complete Python Book 
 
868
 
 
 
 
 
 
 
 
 
 
[B/I/G/A] Bool Built-In Function: bool( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
869
 
As with every data type in Python, there is a built in function that 
allows us to either define it or cast one version or one value to 
another.  The same goes with bool, short for Boolean. The bool 
function results in a value of True or False.  
Per the image above, if I have num that's equal to zero and then 
print the bool of num, it's going to be False because it's a zero. But 
if I choose any, anything else except for none, zero or False,  it's 
going to be True.  
For example, per the image below, 1000 results to a True value 
using the bool function.  

The Complete Python Book 
 
870
 
Per the image below, a value of 0 results in False when using the 
bool function:  
 
Per the image below, if I define  zero as a string, it's going to be 
True because that's a string and not a number.  

The Complete Python Book 
 
871
 
 
 
 

The Complete Python Book 
 
872
 
 
 
 
 
 
 
 
 
 
[I/G/A] Breakpoint Built-In Function: 
breakpoint( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
873
 
While developing a program in any language, you will have 
something called debugger. The debugger is there to allow us to 
detect what's happening inside of our program.  And there is a 
Python's built in debugger, which can be called with a breakpoint 
function.  
Per the image above, if I define a  function  that doesn't  have any 
arguments, x is equal to five,  then we insert a breakpoint before y 
is equal to 10 and then we run the code, then per the 2 image 
below, we enter debugging mode. 

The Complete Python Book 
 
874
 
 
Using the breakpoint, we can experiment and see what's actually 
happening inside your program while it's executing. 
This is only for development purposes. 
 
 

The Complete Python Book 
 
875
 
 
 
 
 
 
 
 
 
 
[G/A] Bytearray Built-In Function: bytearray( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
876
 
Per the image above, there is a Python's built in function called 
bytearray, which gets an array as an input or a list, depending on 
how you want to call it, and then converts every single item inside 
of it to its byte version of representation.  
This is really useful when we want to modify directly binary data 
and create a list of mutable array of bytes. Mutable means you 
can change it. 
If we define a  mylist is equal to 65,  then 66, and 67, this is a list 
of numbers. But if we define a bytearray of this,  now we'll get 
something else, which is ABC. This is an SQL representation of 
letters, ABC.   
 
 

The Complete Python Book 
 
877
 
 
 
 
 
 
 
 
 
 
[G/A] Bytes Built-In Function: bytes( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
878
 
The main difference between Python's bytearray and bytes is the 
fact that bytes creates immutable list of bytes, which basically 
means that we cannot modify it. So if I use bytes of my list, I will 
get the same result as with byte array.   
Now, the main difference here is if I want to change a value here 
results in an error, because it's an immutable object. If you want 
to change the values inside use bytearray instead of bytes. 
 
 

The Complete Python Book 
 
879
 
 
 
 
 
 
 
 
 
 
[I/G/A] Callable Built-In Function: callable( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
880
 
In Python, we have a paradigm called callable, which basically 
means that an object or a variable is an instance of a class or a 
method or a function itself. So we can call it to perform some 
additional actions on top of it.  Now, sometimes you would like to 
check it out and see if it's an actually instance of such an object 
that can be called. 
Per the image above, we have this callable built in function that 
can take my function, for example, and it's going to return only 
True or False, depending on if that object is callable or not.  
 
 

The Complete Python Book 
 
881
 
 
 
 
 
 
 
 
 
 
[I/G/A] Chr Built-In Function: chr( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
882
 
In computers, we are representing strings or letters in a way that 
are converted directly to either some representation, which are 
integers. And then on top of that, we are representing that with 
binary code that processors can actually understand.  Now,  
because of that, we have something called an ASCII table that 
allows us to represent every character with a certain integer. 
Per the image above, this means that uppercase  A is actually 65.  
Now, if I just print my A, it's going to be 65. However, if you want 
to see actual representation of  this in string, we can use the chr 
built in function that takes this and represents it as A.   
 
 

The Complete Python Book 
 
883
 
 
 
 
 
 
 
 
 
 
[I/G/A] Classmethod Built-In Function: 
classmethod( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
884
 
There is a built in type of a functionality inside of Python called 
classmethod. If we work with classes, which is an object oriented 
programming paradigm,  we can define something that is called 
class variable, which is basically a variable connected to the class 
level itself.  Now to access this particular method, we would need 
to define an object or an instance of a class to call it on top of it.  
If I call my class, I would get a missing error, because Python 
doesn’t really know how to actually call this. But if we call it as we 
have done in the image above, it works.  However, to abstract 
this, we have something called class method, that allows us to call 
this on top of itself, which doesn't require us to define specific 
arguments or to go into details and defining an instance of that 
class itself.  
So for that, if you want to define something class wide,, you go 
with a classmethod defined inside of the Python, per the image 
above. 
 
 

The Complete Python Book 
 
885
 
 
 
 
 
 
 
 
 
 
[G/A] Compile Built-In Function: compile( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
886
 
In Python, we have an amazing function that allows us to do many 
things, which is called compile.   
 
Now,  compile, if you call it per the image above, we see what it 
takes as an argument, it will tell you the source, the file name, for 
example, string, the mode,  and it can be many different things, of 
course.  Now, here, we can define what we actually want to do 
with it, for example, optimize, execute, etc.  

The Complete Python Book 
 
887
 
Now, if we define a code, per the image above, it results in an 
error.  
We can address the issue using the compile function, per the 
image below. So what we do is called another built in function 
called exact, which executes a built in compiled version of the 
code. Okay, so with this you're creating a compiled version of your 
code from string directly, and then you are basically using this 
exact function built in inside of Python to  perform  execution of 
this particular code. 

The Complete Python Book 
 
888
 
 
 

The Complete Python Book 
 
889
 
 
 
 
 
 
 
 
 
 
[G/A] Complex Built-In Function: complex( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
890
 
In mathematics, we have some situations that require us to do 
and to use some complex numbers and every single complex 
number is made of two things, real part and imaginary part or  
imagined part. So  we can't replicate that in direct ways using 
different languages, but in Python, we have a built in function 
called complex,  and it will take a real part, and imagine part. 
So if we provide real part as an adjustment number and image 
part,  it's going to create our imaginary number or complex 
number that is free, which is our real, real part and imaginary 
part, which is a 4j, per the image below.   

The Complete Python Book 
 
891
 
 
 

The Complete Python Book 
 
892
 
 
 
 
 
 
 
 
 
 
[I/G/A] Dict Built-In Function: dict( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
893
 
Besides lists or arrays and many other ways to store multitude of 
data, like tuples, in Python, there is a dict or dictionary that allows 
us to store key value pairs data that can be accessed later on by 
the value or by the key.  And to achieve that we have a built in 
function called dict.   
Now, there are multiple ways on how to achieve or how to use 
this, but easiest way of creating a dictionary with key value pairs 
is, for example, A is equal to  1, B is equal to 2, C is equal to 3. So 
you basically define multiple values, key value pairs, and it's going 
to be converted from these initializations. So the next time you 
would like to create  dictionary directly from variables, then 
please consider using the dict function. 
 
 

The Complete Python Book 
 
894
 
 
 
 
 
 
 
 
 
 
[I/G/A] Dir Built-In Function: dir( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
895
 
In Python, we have something called dir, which is a built in 
function that lists all the attributes and methods available within a 
module and what we can actually do with it  
Per the second image above, if I define a class and if I use dir with 
my class, you will see everything that you can do with this object. 
 
 
 

The Complete Python Book 
 
896
 
 
 
 
 
 
 
 
 
 
[B/I/G/A] Divmod Built-In Function: divmod( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
897
 
In Python we have a built in function called divmod, which takes 
two arguments. It allows us to check when you need both the 
results of division and the remainder, per the image above. So it 
will return  quotients and remainder of the division.   
 
Per the image above, if I use divmod  and provide, for example, 
17,  and 5, now the result will be 3, and remainder will be 2. 
 
 

The Complete Python Book 
 
898
 
 
 
 
 
 
 
 
 
 
[G/A] Enumerate Built-In Function: 
enumerate( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
899
 
Per the image above, mylist is equal to  Apple,  Google,  Microsoft. 
We can use use enumerate to return two things: index and value.   
So the next time that you need both index and get the value of each 
element, use enumerate instead of iterating individually. 
 
 

The Complete Python Book 
 
900
 
 
 
 
 
 
 
 
 
 
[I/G/A] Eval Built-In Function: eval( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
901
There are multiple functions in Python that allow us to execute 
Python code written in different ways; eval is one of those 
functions. Now we might use eval when you need to dynamically 
execute Python code based on user input  or configuration data, 
which means in most cases, those input data will be in, for example,  
a string version. 
So let me demonstrate using the image above;  user_input is equal 
to 3 plus 7.  And if I print  user_input,  it's going to be 10. But what 
happens if I use eval around it? Well, it actually executes the code 
and it finds out whether or not there are errors, then compiles it, 
and executes it, so we can get the result, which is 10.  
So the next time you want to execute a piece of code that is written 
in  this way, use eval for that. 
 
 

The Complete Python Book 
 
902
 
 
 
 
 
 
 
 
 
 
[I/G/A] Exec Built-In Function: exec( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
903
 
Exec will allow us to execute actually the code written in a string 
format, per the image above. 
Now, sometimes this does not work in Google Colab or it works 
slowly because Google Colab is actually running in the 
background. But as you can see in the image above, Hello Maria is 
written, which is exactly what we wanted from this code that we 
wrote. 
 
 

The Complete Python Book 
 
904
 
 
 
 
 
 
 
 
 
 
[B/I/G/A] Filter Built-In Function: filter( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
905
 
Imagine if you have a list called my_list per the image above.  How 
can we filter the list? We can use the filter function, per the image 
below.  
 
 
 
 

The Complete Python Book 
 
906
 
 
 
 
 
 
 
 
 
 
[B/I/G/A] Float Built-In Function: float( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
907
 
To define a floating number,  or a number with a decimal point, 
you can use the float  built in function.  We can use the floating 
function to convert and cast items from one variable type to the 
floating number type, per the image above.  
 
 

The Complete Python Book 
 
908
 
 
 
 
 
 
 
 
 
 
 
[B/I/G/A] Format Built-In Function: format( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
909
 
Per line 6 in the image above, we know that we can use + in order 
to tie together items in a sentence.  
Per the image below, we can also use {} and the format function 
to convert string(s).   
 
 
 

The Complete Python Book 
 
910
 
 
 
 
 
 
 
 
 
 
[I/G/A] Frozenset Built-In Function: frozenset( 
) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
911
 
Beside dictionaries, tuples and lists, in Python, we have something 
called a set. The set is basically a list of numbers that guarantees 
us unique values for every single element; there are no two 
elements that can be repeated.  Now, those can be modified to 
some degree.  
However, there is a keyword called frozen set  that allows you to  
create a set that cannot be changed.  So as you can see in the 
image above from a list, I created a frozen set. Now I cannot add 
new elements. I cannot modify the current ones. So this is the 
best way to, for example, address keys for a database or database 
information that you don’t want to be changed. 
 
 

The Complete Python Book 
 
912
 
 
 
 
 
 
 
 
 
 
[I/G/A] Hash Built-In Function: hash( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
913
 
There is a built in Python function called hash that we can use to 
get the hash value of an object,  which is often used when storing 
objects in dictionary or sets.   
Per the image above, let's take a look how it works.  We have a 
var that has Hello World as a value. We can find out the hash 
value using the hash function.  
 
 

The Complete Python Book 
 
914
 
 
 
 
 
 
 
 
 
 
[B/I/G/A] Help Built-In Function: help( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
915
 
If you don't know what a function does, you can use help.   
Per the image below, we can add the print function around help, 
so we can understand how a function works and what parameters 
(if any) that we can use in a function.  
 
 
 

The Complete Python Book 
 
916
 
 
 
 
 
 
 
 
 
 
[I/G/A] Hex Built-In Function: hex( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
917
 
To convert an integer to hex value, you can the hex function. For 
example, per the image above, if I have a number that is 255, we 
can print the hex value, which is 0xff. 
 
 
 

The Complete Python Book 
 
918
 
 
 
 
 
 
 
 
 
 
[I/G/A] ID Built-In Function: id( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
919
 
The built in Python function called id can be used to obtain a 
unique identifier of an object, which is often used to debug or 
track an object reference.  
Per the image above, If I have x is equal to 42 and y is equal to  x. 
If we use the id function, the id of both x and y are identical. You 
probably won’t use the id function much when programming, but 
it is for debugging purposes to see what is duplicated, what are 
the deep copies, what are the shallow copies, and to understand 
and identify where your objects are stored in memory. 
 
 

The Complete Python Book 
 
920
 
 
 
 
 
 
 
 
 
 
[B/I/G/A] Input Built-In Function: input( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
921
 
If you want to accept user input in Python, you can use the input 
function, as shown in the image above. In this example, we set the 
value of what the user typed in a variable called var.   
 
 

The Complete Python Book 
 
922
 
 
 
 
 
 
 
 
 
 
[B/I/G/A] Int Built-In Function: int( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
923
 
Per the image above, the int function sets (meaning casts) a 
number that you enter in brackets as a whole number, meaning 
an integer. 
 
 

The Complete Python Book 
 
924
 
 
 
 
 
 
 
 
 
 
[G/A] Isinstance Built-In Function: isinstance( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
925
 
In programming, if you are building a function that only accepts 
integers and you want to check if that is actually an integer, we 
can use the isinstance function.  
In the example above, we want to check if the object is an 
instance of an object. And for that, you can use isInstance,  and 
then for example, use 42, which is your input and int, which is 
something that you are checking. And this will return True 
because this is actually an instance of integer.  
This can be applied to classes, to functions, to lists, etc. Per the 
image below,  I can put list here, and that's going to be False 
because this is not a list.  

The Complete Python Book 
 
926
 
 
 

The Complete Python Book 
 
927
 
 
 
 
 
 
 
 
 
 
[I/G/A] Issubclass Built-In Function: issubclass( 
) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
928
 
In object oriented programming, a normal kind of a way of 
programming or paradigm is in classes, and on top of that you 
have inheritance, where you don't want to copy and paste the 
same chunk of code every time. So you are defining it in kind of a 
main class, and then you instantiate that class or inherit that class 
to subclasses that accept that behavior and some extra.  
Now you might use subclass to check if a class is a  subclass of 
another class before using the inheritance relation feature, for 

The Complete Python Book 
 
929
example.  So here is sub class. And here I can check, for example, 
child parent,  and per the image above, this is going to return true 
because child is actually a subclass of a parent class.  
So if you want to make sure that your class that you're working 
with is a subclass of another class, we use the issubclass function. 
 
 

The Complete Python Book 
 
930
 
 
 
 
 
 
 
 
 
 
[I/G/A] Iter Built-In Function: iter( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
931
 
Per the image above, the iter function in Python returns an 
iterator for the given object, enabling traversal through its 
elements in a loop. 
 
 

The Complete Python Book 
 
932
 
 
 
 
 
 
 
 
 
 
[B/I/G/A] Len Built-In Function: len( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
933
 
Per the image above, the len function in Python returns the 
number of items in a container, such as a list, string, or dictionary. 
 
 

The Complete Python Book 
 
934
 
 
 
 
 
 
 
 
 
 
[B/I/G/A] List Built-In Function: list( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
935
 
Per the image above, the list function in Python creates a list 
object from an iterable, like converting a tuple or string into a list. 
 
 

The Complete Python Book 
 
936
 
 
 
 
 
 
 
 
 
 
[G/A] Map Built-In Function: map( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
937
 
Per the image above, the map function in Python applies a given 
function to each item of an iterable, returning an iterator of the 
results 
 
 

The Complete Python Book 
 
938
 
 
 
 
 
 
 
 
 
 
[B/I/G/A] Max Built-In Function: Max( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
939
 
Per the image above, the max function in Python returns the 
largest item from an iterable or among two or more arguments. 
 
 

The Complete Python Book 
 
940
 
 
 
 
 
 
 
 
 
 
[B/I/G/A] Min Built-In Function: Min( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
941
 
Per the image above, the min function in Python returns the 
smallest item from an iterable or among two or more arguments. 
 
 

The Complete Python Book 
 
942
 
 
 
 
 
 
 
 
 
 
[I/G/A] Next Built-In Function: next( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
943
 
Per the image above, the next function in Python retrieves the 
next item from an iterator and advances the iterator by one 
position. 
 
 

The Complete Python Book 
 
944
 
 
 
 
 
 
 
 
 
 
[G/A] Oct Built-In Function: oct( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
945
 
Per the image above, the oct function in Python converts an 
integer to its octal representation, returning a string. 
 
 

The Complete Python Book 
 
946
 
 
 
 
 
 
 
 
 
 
[I/G/A] Open Built-In Function: open( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
947
 
Per the image above, the open function in Python opens a file and 
returns a file object, supporting reading, writing, or both modes. 
 
 

The Complete Python Book 
 
948
 
 
 
 
 
 
 
 
 
 
[I/G/A] Ord Built-In Function: ord( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
949
 
Per the image above, the ord function in Python returns the 
Unicode code point for a given single character string. 
 
 

The Complete Python Book 
 
950
 
 
 
 
 
 
 
 
 
 
[B/I/G/A] Pow Built-In Function: pow( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
951
 
Per the image above, the pow function in Python returns the 
value of a number raised to the power of another. 
 
 

The Complete Python Book 
 
952
 
 
 
 
 
 
 
 
 
 
[B/I/G/A] Print Built-In Function: print( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
953
 
Per the image above, the print function in Python outputs the 
specified message to the screen or other standard output device. 
 
 

The Complete Python Book 
 
954
 
 
 
 
 
 
 
 
 
 
[B/I/G/A] Range Built-In Function: range( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
955
 
Per the image above, the range function in Python generates a 
sequence of numbers, used for iterating over with loops, 
specifying start, stop, step. 
 
 

The Complete Python Book 
 
956
 
 
 
 
 
 
 
 
 
 
[I/G/A] Repr Built-In Function: repr( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
957
 
Per the image above, the repr function in Python returns a 
printable representation of an object, useful for debugging and 
development. 
 
 
 

The Complete Python Book 
 
958
 
 
 
 
 
 
 
 
 
 
[B/I/G/A] Reversed Built-In Function: 
reversed( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
959
 
Per the image above, the reversed function in Python returns an 
iterator that accesses the given sequence in reverse order. 
 
 
 

The Complete Python Book 
 
960
 
 
 
 
 
 
 
 
 
 
[B/I/G/A] Round Built-In Function: round( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
961
 
Per the image above, the round function in Python rounds a 
floating-point number to a specified number of digits after the 
decimal point. 
 
 
 

The Complete Python Book 
 
962
 
 
 
 
 
 
 
 
 
 
[I/G/A] Set Built-In Function: set( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
963
 
Per the image above, the set function in Python creates a set 
object, an unordered collection of unique elements, from an 
iterable. 
 
 
 

The Complete Python Book 
 
964
 
 
 
 
 
 
 
 
 
 
[I/G/A] Slice Built-In Function: slice( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
965
 
Per the image above, the slice function in Python returns a slice 
object representing a set of indices specified by range(start, stop, 
step). 
 
 
 

The Complete Python Book 
 
966
 
 
 
 
 
 
 
 
 
 
[B/I/G/A] Sorted Built-In Function: sorted( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
967
 
Per the image above, the sorted function in Python returns a new 
sorted list from the elements of any iterable, optionally using key 
and reverse parameters. 
 
 
 

The Complete Python Book 
 
968
 
 
 
 
 
 
 
 
 
 
[B/I/G/A] Str Built-In Function: str( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
969
 
Per the image above, the str function in Python converts the 
specified value into a string, often used for converting other data 
types to string. 
 
 
 

The Complete Python Book 
 
970
 
 
 
 
 
 
 
 
 
 
[B/I/G/A] Sum Built-In Function: sum( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
971
 
Per the image above, the sum function in Python calculates the 
total of all numerical items in an iterable, optionally starting from 
an initial value. 
 
 
 

The Complete Python Book 
 
972
 
 
 
 
 
 
 
 
 
 
[B/I/G/A] Tuple Built-In Function: tuple( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
973
 
Per the image above, the tuple function in Python converts an 
iterable into a tuple, an immutable and ordered sequence of 
elements. 
 
 
 

The Complete Python Book 
 
974
 
 
 
 
 
 
 
 
 
 
[B/I/G/A] Type Built-In Function: type( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
975
 
Per the image above, the type function in Python returns the type 
of the specified object, used to determine the class of an object. 
 
 
 

The Complete Python Book 
 
976
 
 
 
 
 
 
 
 
 
 
[I/G/A] Zip Built-In Function: zip( ) 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
977
 
Per the image above, the zip function in Python combines 
elements from multiple iterables into tuples, creating a zip object 
of paired elements. 
 
 
 

The Complete Python Book 
 
978
 
 
 
 
 
 
 
 
 
 [B/I/G/A] LEVEL 17: 
CONCLUSION AND NEXT STEPS  
 
 
 

The Complete Python Book 
 
979
 
 
 
 
 
 
 
 
 
 
[B/I/G/A] CONGRATULATIONS & Next Steps! 
 
 
 
 
 
 
 
 

The Complete Python Book 
 
980
 
 
We hope you enjoyed the book. Now we cover a lot, and we want 
this to be a complete course on Python.  Therefore, we have 
prepared a one question survey monkey survey that asks you what 
topics you would like to us to add to this book. Our goal is to make 
this Level the longest section of this book.  
If you want, please click the link attached to this chapter and 
complete the one question survey.  
https://www.surveymonkey.com/r/Python_topic_requests  
Thank you, 
Chris and Luka 
 
 

