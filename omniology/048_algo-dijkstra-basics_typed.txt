Graph	 Â Primi*ves	 Â 
Dijkstraâ€™s	 Â Algorithm:	 Â 
The	 Â Basics	 Â 
Design	 Â and	 Â Analysis	 Â 
of	 Â Algorithms	 Â I	 Â 

Tim	 Â Roughgarden	 Â 
Single-Â­â€Source	 Â Shortest	 Â Paths	 Â 
Length of path  
= sum of edge lengths 
Input: directed graph G=(V, E). (m=|E|, n=|V| ) 
â€¢â€¯ each edge has non negative length le 
â€¢â€¯ source vertex s 
 
Output: for each          , compute 
   L(v) := length of a shortest s-v path in G 
 
Assumption: 
1.â€¯ [for convenience] 
2.â€¯ [important] 
Path	 Â length	 Â =	 Â 6	 Â 

0,1,2,3	 Â 
0,1,4,7	 Â 
0,1,4,6	 Â 
0,1,3,6	 Â 
One	 Â of	 Â the	 Â following	 Â is	 Â the	 Â list	 Â of	 Â shortest-Â­â€path	 Â distances	 Â for	 Â the	 Â 
nodes	 Â ğ‘ ,ğ‘£,ğ‘¤,ğ‘¡,	 Â respec*vely.	 Â 	 Â Which	 Â is	 Â it?	 Â 
Source	 Â 
vertex	 Â 

Tim	 Â Roughgarden	 Â 
Why	 Â Another	 Â Shortest-Â­â€Path	 Â Algorithm?	 Â 
Question: doesnâ€™t BFS already compute shortest paths in linear 
time? 
Answer: yes, IF le = 1 for every edge e. 
 
Question: why not just replace each edge e by directed path of le 
unit length edges: 
Answer: blows up graph too much 
 
Solution: Dijkstraâ€™s shortest path algorithm. 
 
 

Tim	 Â Roughgarden	 Â 
Dijkstraâ€™s	 Â Algorithm	 Â 
Ini*alize:	 Â 
â€¢â€¯	 Â X	 Â =	 Â [s]	 Â 	 Â 	 Â 	 Â [ver*ces	 Â processed	 Â so	 Â far]	 Â 
â€¢â€¯	 Â A[s]	 Â =	 Â 0	 Â 	 Â [computed	 Â shortest	 Â path	 Â distances]	 Â 
â€¢â€¯	 Â B[s]	 Â =	 Â empty	 Â path	 Â [computed	 Â shortest	 Â 
paths]	 Â 
Main	 Â Loop	 Â 
â€¢â€¯	 Â while	 Â 	 Â XÇ‚V:
	 Â 	 Â 
	 Â -Â­â€need	 Â to	 Â grow	 Â 	 Â 
	 Â 
	 Â 
	 Â x	 Â by	 Â one	 Â node	 Â 
Main	 Â Loop	 Â contâ€™d:	 Â 
â€¢â€¯	 Â 	 Â 
	 Â 
	 Â 
	 Â 
[call	 Â it	 Â (v*,	 Â w*)]	 Â 
	 Â 
â€¢â€¯	 Â add	 Â w*	 Â to	 Â X	 Â 
â€¢â€¯	 Â set	 Â 
â€¢â€¯	 Â set	 Â 	 Â 	 Â 
	 Â 
	 Â  Â 
This array 
only to help 
explanation! 
Already 
computed in 
earlier iteration 

Tim	 Â Roughgarden	 Â 
Example	 Â 
Dijkstraâ€™s greedy 
score for (v, w): 
A[v] + lvw 

Tim	 Â Roughgarden	 Â 
Non-Â­â€Example	 Â 
Question: why not reduce computing shortest paths with negative 
edge lengths to the same problem with non negative lengths? (by 
adding large constant to edge lengths) 
 
Problem: doesnâ€™t preserve shortest paths ! 
 
Also: Dijkstraâ€™s algorithm incorrect on this graph ! 
(computes shortest s-t distance to be -2 rather than -4) 

