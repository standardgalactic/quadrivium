Copyright © MathByte Academy

What this course is about
the Python language
the standard library
idiomatic Python
becoming an expert Python developer
obtaining a deeper understanding of the Python language
and the standard library
this is NOT an introductory course
à refer to prerequisites video or course description
à canonical CPython 3.6+ implementation
Copyright © MathByte Academy

Included Course Materials
lecture videos
Jupyter notebooks
coding videos
projects, exercises and solutions
github repository for all code
https://github.com/fbaptiste/python-deepdive
Copyright © MathByte Academy

Associative Arrays
what are associative arrays?
one concrete implementation
à hash maps
or hash tables
how do hash maps work?
what are hash functions?
Python 3.5+ specific hash map implementation
Copyright © MathByte Academy

classes
modules
sets
namespaces
JSON
YAML
dictionaries
multi-sets
instances
Relational
Databases
Copyright © MathByte Academy

Dictionaries
creating
updating, merging and copying
manipulating
keys, values and items Views
custom classes and hashing
à use instances as keys
Copyright © MathByte Academy

Sets
hash maps
set operations
copying, merging and updating sets
FrozenSets
Dictionary views à keys, items
Copyright © MathByte Academy

Serializing and Deserializing
pickling
JSON serialization and deserialization
use and customize Python's JSONEncoder and JSONDecoder classes
the need for JSON schemas
3rd party libraries
à JSONSchema, Marshmallow, PyYaml, Serpy
Copyright © MathByte Academy

Specialized Hash Maps
defaultdict
OrderedDict
Counter
à multi-set
ChainMap
Copyright © MathByte Academy

Custom Dictionary Types
using class inheritance to create customized dictionary types
inheriting from dict
inheriting from UserDict
Copyright © MathByte Academy

Exercises
exercises after each section
should attempt these yourself first – practice makes perfect!
solution videos and notebooks provided
à my approach
à more than one approach possible
Copyright © MathByte Academy

Copyright © MathByte Academy

Python 3: Deep Dive (Part 3) - Prerequisites
functions and function arguments
packing and unpacking iterables
my_func(*my_list)
f, *_, l = (1, 2, 3, 4, 5)
closures
decorators
nested scopes
free variables
Boolean truth values
named tuples
lambdas
== vs is
This course assumes that you have in-depth knowledge functional programming in Python:
zip
map
sorted
any
all
@lru_cache
@wraps
@singledispatch
chain
Copyright © MathByte Academy

Python 3: Deep Dive (Part 3) - Prerequisites
This course assumes that you have in-depth knowledge of:
sequences
iterables
iterators
list comprehensions
generators and generator expressions
context managers
importing modules and symbols
Copyright © MathByte Academy

Python 3: Deep Dive (Part 3) - Prerequisites
You should have a basic understanding of creating and using classes in Python
class Person:
def __init__(self, name, age):
self.name = name
self.age = age
@property
def age(self):
return self._age
@age.setter
def age(self, age):
if value <= 0:
raise ValueError('Age must be greater than 0')
else:
self._age = age
Copyright © MathByte Academy

Python 3: Deep Dive (Part 3) - Prerequisites
You should understand how special functionality is implemented in Python using special methods
class Point:
def __init__(self, x, y):
self.x = x
self.y = y
def __repr__(self):
return f'Point(x={self.x}, y={self.y})'
def __eq__(self, other):
if not isinstance(other, Point):
return False
else:
return self.x == other.x and self.y == other.y
def __gt__(self, other):
if not isinstance(other, Point):
return NotImplemented
else:
return self.x ** 2 + self.y ** 2 > other.x**2 + other.y**2
def __add__(self, other):
…
Copyright © MathByte Academy

Python 3: Deep Dive (Part 3) - Prerequisites
You should also have a good grasp of:
exception handling
try…except…else…finally…
creating and using simple dictionaries
d = {'a': 1, 'b': 2}
d['a']
d['a'] = 1
Various basic types
int, float, Decimal, Fraction, complex
strings and string formatting
f'result: {result}'
'result: {result}'.format(result=result)
and other basic Python language items: loops, conditionals, etc
Copyright © MathByte Academy

Python 3: Deep Dive (Part 3) - Prerequisites
I will use a limited number of 3rd party libraries in this course
You will need to know how to install 3rd party Python libraries
pip install marshmallow
Most code examples are provided using Jupyter Notebooks
Freely available
https://jupyter.org/
GitHub and git
à recommended but not required
https://github.com/fbaptiste/python-deepdive
Copyright © MathByte Academy

Copyright © MathByte Academy

This section is going to primarily theoretical in nature
what are dictionaries (aka associative arrays)
specifically we'll look at how they can be implemented using hash tables (aka hash maps)
there are many ways to implement dictionaries
This is not a data structure course, so we're not going to look at all the intricacies
just enough to get a rough understanding
à abstract data structure
Copyright © MathByte Academy

Why bother?
Dictionaries are everywhere in Python
modules
classes
objects (class instances)
scopes
your own dictionaries
sets
It is arguably one of the most important data structures in Python
Copyright © MathByte Academy

If you're really not into theory…
or you already understand associative arrays, hash functions, hash maps, etc…
Skip this section!
à maybe just check out the videos on Python's (3.6+) implementation of hash maps
à key-sharing dictionaries
à compact dictionaries
Mark Shannon
PEP 412
Raymond Hettinger
https://mail.python.org/pipermail/python-dev/2012-December/123028.html
Copyright © MathByte Academy

really the main points that come out of this section:
à dictionary keys must be hashable
à dictionary key order is maintained (in order of insertion)
Copyright © MathByte Academy

Copyright © MathByte Academy

persons = [John, Eric, Michael, Graham]
What is an associative array?
0
1
2
3
We can think of the indices as a key for the items in the list
0 à John
Person objects
1 à Eric
2 à Michael
3 à Graham
So when we want to get hold of the Michael object, we just need to remember the key
persons[2]
à Michael
But remembering a number while we write our code???
Copyright © MathByte Academy

there has to be a better way…
persons = [('john', John), 
('eric', Eric), 
('michael', Michael), 
('graham', Graham)]
we have associated a string with an object
to get the Michael object:
à lookup the key 'michael' and return the associated value
(key, object)
scan the persons list until we find a tuple with first element = key
return the second element of the tuple
At least we don't have to remember a number anymore!
Copyright © MathByte Academy

But there really has to be a better way…
Consider our associative array:
persons = [('john', John), ('eric', Eric), 
('michael', Michael), ('graham', Graham)]
And let's break it up:
keys = ['john', 'eric', 'michael', 'graham']
persons = [John,    Eric,   Michael,   Graham]
Notice how the index of 'john'
matches up with the index of John, 
and so on
What if we could define a function h that would return these results - always:
h('john') à 0
h('eric') à 1
h('michael') à 2
h(graham') à 3
To get Michael, we would first call h('michael')
à 2
then persons[2]
persons[h('michael')]
à Michael
Copyright © MathByte Academy

Associative Arrays
An associative array is an abstract data structure
Can be implemented in different concrete ways
that associates keys (keys are unique)
to values
abstractly we can think of it as a collection of (key, value) pairs
Sometimes also called:
maps
dictionaries
They support:
à adding/removing elements
à modifying an associated value
à looking up a value via its key
Copyright © MathByte Academy

Copyright © MathByte Academy

One common concrete implementation of an associative array (aka dictionary) is a hash map
Hash Maps (aka Hash Table)
Suppose we have an array of 7 slots, initially containing nothing
0
1
2
3
4
5
6
Now suppose we are going to want to store these maps
'john' à John
'eric' à Eric
'michael' à Michael
'graham' à Graham
We'll define a function that will return an integer value for all these strings ('john', 'eric', etc)
à that will be unique for each of these strings
à is between 0 and 6
à always returns the same integer for the same string
(deterministic)
Copyright © MathByte Academy

Hash Tables
0
1
2
3
4
5
6
h(s)
'john' à 2
'eric' à 4
'michael' à 0
'graham' à 5
'john'
John
'eric'
Eric
'michael'
Michael
'graham'
Graham
Storing a key/value pair:
à calculate h(key)
à idx
à store value in slot idx
Looking up a value by key:
à calculate h(key)
à idx
à return value in slot idx
Copyright © MathByte Academy

Hash Functions
Creating the function h(key) when we know all the possible keys ahead of time is easy
Reality check:
most of the time we don't know all the possible keys ahead of time
In reality, creating such a function is hard
Bounding the returned index value is not difficult
à modulo
x % 7
à 0, 1, 2, 3, 4, 5, 6
Ensuring uniqueness is hard
how to ensure that h(k1) != h(k2) if k1 != k2
maybe we don't need to…
Copyright © MathByte Academy

Hash Functions
A hash function is a function (in the mathematical sense)
! = # ⇒%(!) = %(#)
(deterministic)
that maps from a set (domain) of arbitrary size (possibly infinite)
to another (smaller) set of fixed size (range)
ℎ: * →,
where - , < -(*)
For our hash tables, we'll also want:
à the range to be a defined subset of the non-negative integers
0, 1, 2, 3, …
à the generated indices for expected input values to be uniformly distributed (as much as possible)
Note that we do allow getting the same output for different keys
i.e.    ℎ/! = ℎ/" ⇏/! = /"
Copyright © MathByte Academy

Example
def h(key, num_slots):
return len(key) % num_slots
h('john', 11) à 4
h('eric', 11) à 4
h('michael', 11) à 7
h('graham', 11) à 6
collision
h('john', 5) à 4
h('eric', 5) à 4
h('michael', 5) à 2
h('graham', 5) à 1
collision
h('alexander', 11) à 9
h('alexander', 5) à 4
Copyright © MathByte Academy

Example
def h(key, num_slots):
total = sum(ord(c) for c in key)
return total % num_slots
ord('a') à 97
ord('b') à 98
ord('z') à 122
ord('A') à 65
ord('Z') à 90
ord('B') à 66
…
…
…
h('john', 11) à 431 % 11 = 2
h('eric', 11) à 419 % 11 = 1
h('michael', 11) à 723 % 11 = 8
h('graham', 11) à 625 % 11 = 8
h('alexander', 11) à 948 % 11 = 2
h('john', 5) à 431 % 5 = 1
h('eric', 5) à 419 % 5 = 4
h('michael', 5) à 723 % 5 = 3
h('graham', 5) à 625 % 5 = 4
h('alexander', 5) à 948 % 5 = 3
All these hash functions have collisions…
Copyright © MathByte Academy

Dealing with Collisions
chaining
0
1
2
3
4
['john', John]
['eric', Eric]
['michael', Michael]
[graham', Graham]
h('john', 5) à 431 % 5 = 1
h('eric', 5) à 419 % 5 = 4
h('michael', 5) à 723 % 5 = 3
h('graham', 5) à 625 % 5 = 4
h('alexander', 5) à 948 % 5 = 3
['alexander', Alexander]
Copyright © MathByte Academy

Dealing with Collisions
probing (linear)
0
1
2
3
4
h('john', 5) à 431 % 5 = 1
h('eric', 5) à 419 % 5 = 4
h('michael', 5) à 723 % 5 = 3
h('graham', 5) à 625 % 5 = 4
h('alexander', 5) à 948 % 5 = 3
['john', John]
['eric', Eric]
['michael', Michael]
['graham', Graham]
['alexander', Alexander]
other types of probing 
à must generate the same sequence of valid indices for any given key
3 à 4 à 0 à 1 à 2
1 à 2 à 3 à 4 à 0
4 à 0 à 1 à 2 à 3
3 à 4 à 0 à 1 à 2
4 à 0 à 1 à 2 à 3
Probe Sequence
Copyright © MathByte Academy

Fetching Elements
h('john', 5) à 431 % 5 = 1
h('eric', 5) à 419 % 5 = 4
h('michael', 5) à 723 % 5 = 3
h('graham', 5) à 625 % 5 = 4
h('alexander', 5) à 948 % 5 = 3
3 à 4 à 0 à 1 à 2
1 à 2 à 3 à 4 à 0
4 à 0 à 1 à 2 à 3
3 à 4 à 0 à 1 à 2
4 à 0 à 1 à 2 à 3
Probe Sequence
0
1
2
3
4
['john', John]
['eric', Eric]
['michael', Michael]
['graham', Graham]
['alexander', Alexander]
find 'michael' à hash = 3
à probe sequence:
is 'michael' at index 3?
à no
à no
à yes
3 à 4 à 0 à 1 à 2
is 'michael' at index 4?
is 'michael' at index 0?
à return item
à in reality more complex than this, but this is the basic idea
find 'alexander' à hash = 3
à probe sequence:
is 'alexander' at index 3?
à yes
3 à 4 à 0 à 1 à 2
à return item
à this is why the hash of a key should not change over it's lifetime
Copyright © MathByte Academy

Sizing Issues
When we create a hash table, how big should it be?
We don't know how big it will become
we can't make it arbitrarily large à memory constraints
à start small, and grow it over time as needed
à resizing is expensive
à recompute hashes
à move data around
à over allocate
(create more slots than necessary)
à algorithms exist to optimize the cost of doing this
Copyright © MathByte Academy

Other Issues
what happens when items are deleted
à this can affect probing algorithm
à compacting the table when items are deleted
choice of hash function
gets complicated
beyond the needs of this course
à https://en.wikipedia.org/wiki/Hash_table
Copyright © MathByte Academy

Copyright © MathByte Academy

Python Dictionaries are ubiquitous
Python dictionaries are everywhere you look!
namespaces
classes
modules
functions
and of course, your own dicts
Dictionaries are such an important part of Python that a lot of time and effort was put into
making them as efficient as possible
key sharing
compact dictionaries
sets
Copyright © MathByte Academy

Key Sharing
class Person:
def __init__(self, name, age):
self.name = name
self.age = age
john = Person('John', 78) 
eric = Person('Eric', 75) 
michael = Person('Michael', 75) 
john
['name', 'John']
['age', 78]
eric
['name', 'Eric']
['age', 75]
michael
['name', 'Michael']
['age', 75]
à multiple instances of the same class
PEP 412
à instance attribute names are the same
'name'
'age'
['John', 'Eric', 'Michael']
[78,      75,     75]
à split-table dictionary
john
eric
michael
Copyright © MathByte Academy

Compact Dictionaries
['john', John]
['eric', Eric]
['alex', Alex]
[
['—', '—', '—'],
[-6350376054362344353, 'john', John],
['—', '—', '—'],
[4939205761874899982, 'alex, Alex],
['—', '—', '—'],
['—', '—', '—'],
[6629767757277097963, 'eric', Eric]
]
wasted space
{'alex': Alex, 'john': John, 'eric': Eric}
0
1
2
3
4
5
6
values = [[4939205761874899982, 'alex, Alex],
[-6350376054362344353, 'john', John],
[6629767757277097963, 'eric', Eric]]
1
3
6
[None, 1, None, 0, None, None, 2]
indices = 
1
3
6
hash('alex') à
hash('john') à
hash('eric') à
key order
different from
insertion order
key order
same as
insertion order
3
1
6
(simplified – in 
reality we may 
have collisions!)
Copyright © MathByte Academy

hash()
Copyright © MathByte Academy

Python hash()
built-in function: hash()
map(hash, (1, 2, 3, 4))
à 1, 2, 3, 4
map(hash, (1.1, 2.2, 3.3, 4.4))
à 1152921504606846977, 1152921504606846978,
1152921504606846979, 1152921504606846980
map(hash, ('hello', 'python', '!'))
à 2558804294780988881, 1235297897608439440, 
-8029463035455593707
hash((1, 'a', 10.5))
à -5053599863580733767
à always returns an int
à if a == b is True, then hash(a) == hash(b) is also True
à Python truncates hashes to some fixed size
(sys.hash_info.width)
à me = 64-bits
Copyright © MathByte Academy

Python hash()
hash([1, 2])
à TypeError: unhashable type
hash({'a', 'b'})
à TypeError: unhashable type
hash((1, 2))
hash(frozenset({'a', 'b'}))
à 3713081631934410656
à 4261914069630221614
mutable
immutable
hash((1, 2, [3, 4]))
à TypeError: unhashable type
Copyright © MathByte Academy

Why?
hash values à used for hash tables (dictionaries)
à position index
a = (1, 2, 3)
d = {a: 'this key is a tuple – immutable'}
hash(a) never changes since a is immutable
a = [1, 2, 3]
d = {a: 'this key is a list – mutable'}
d[a] à looks for a at same index
a.append(4)
à same object
à hash has changed
à looking for a at wrong index!!
à d[a] ???
Copyright © MathByte Academy

Caveat
built-in function: hash()
à always returns an int
à if a == b is True, then hash(a) == hash(b) is also True
à Python truncates hashes to some fixed size
# mod1.py
print(hash('python'))
print(hash('python'))
run 1:
run 2:
1235297897608439440
1235297897608439440
-5750637952798290655
-5750637952798290655
hash values for objects that compare equal remain equal during program run
but they can change from run to run
à never rely on a hash value being the same from one program run to another
à strings, bytes and datetime
à although may be ok sometimes, ex: integers
Copyright © MathByte Academy

Copyright © MathByte Academy

creating dictionaries
common operations
à literals, dict(), comprehensions, and more…
à membership tests, retrieving, adding, removing elements…
updating
à update, packing/unpacking, copy, deepcopy
dictionary views
à keys, items, values and iteration
custom classes as keys
à default hash, custom hashing
Copyright © MathByte Academy

Copyright © MathByte Academy

Dictionary Elements
basic structure of dictionary elements:
key
:
value
value
à any Python object
integer
custom class or instance
module
function
any Python object…
key
à any hashable object
not all objects are hashable
lists are never hashable
strings are hashable
àhash tables require hash of an object to be constant
(for the life of the program)
roughly:
immutable objects are hashable
mutable objects are not hashable
more subtle than that…
Copyright © MathByte Academy

Hashable Objects
Python function: hash(obj)
à some integer (truncated based on Python build: 32-bit, 64-bit)
sys.hash_info.width
à Exception
TypeError: unhashable type
à list
à mutable collection
à tuples
à not hashable
à immutable collection
à hashable only if all elements are also hashable
à strings
à immutable collection
à hashable
à int, float, complex, binary, Decimal, Fraction, …
à immutable
à hashable
à set, dictionary
à mutable collections
à not hashable
à frozenset
à immutable collection
à elements are required to be hashable
à hashable
à functions
à immutable
à hashable
à custom classes and objects
à maybe
Copyright © MathByte Academy

Requirements
If an object is hashable:
à the hash of the object must be an integer value
à if two objects compare equal (==), the hashes must also be equal
later à creating our own custom hashes
à we will also need to conform to these rules
Important:
two objects that do not compare equal
may still have the same hash
(hash collision)
à more hash collisions à slower dictionaries
Copyright © MathByte Academy

Creating Dictionaries: Literals
This is a very common way of creating dictionaries
{ key1: value1,
key2: value2,
key3: value3 }
any hashable object
any object
{'john': ['John', 'Cleese', 78],
(0, 0): 'origin',
'repr': lambda x: x ** 2,
'eric': {'name': 'Eric Idle',
'age': 75}
}
Copyright © MathByte Academy

Creating Dictionaries: Constructor
dict(key1=value1, key2=value2, key3=value3)
must be a valid identifier name
(think variable, function, class name, etc)
any object
dictionary key will then be a string of that name
dict(john=['John', 'Cleese', 78],
repr=lambda x: x ** 2,
eric={'name': 'Eric Idle',
'age': 75},
twin=dict(name='Eric Idle', age=75)
)
{'john': ['John', 'Cleese', 78],
(0, 0): 'origin',
'repr': lambda x: x ** 2,
'eric': {'name': 'Eric Idle',
'age': 75}
}
Copyright © MathByte Academy

Creating Dictionaries: Comprehensions
Just like we can build lists using list comprehensions
or generators using generator expressions (comprehension syntax)
à build dictionaries using dictionary comprehensions
à same basic syntax
à enclosed in {}
à elements must be specified as   key: value
{str(i): i ** 2 for i in range(1, 5)} à {'1': 1, '2': 4, '3': 9, '4': 16}
{str(i): i ** 2 
for i in range(1, 5)
if i % 2 == 0}
à {'2': 4, '4': 16}
(if not, you'll be creating a set!)
Copyright © MathByte Academy

Soapbox!
d = {i: i** 2 for i in range(1, n)}
vs
d = {}
for i in range(1, n):
d[i] = i ** 2
But when things get more complex…
d = {}
url = 'http://localhost/user/{id}'
for i in range(n):
response = requests.get(url.format(id=i))
user_json = response.json()
user_age = int(user_json['age'])
if user_age >= 18:
user_name = user_json['fullName'].strip()
user_ssn = user_json['ssn']
d[user_ssn] = user_name
Copyright © MathByte Academy

Creating Dictionaries: fromkeys()
à creates a dictionary with specified keys all assigned the same value
d = dict.fromkeys(iterable, value)
à class method on dict
any iterable
contains the keys
hashable elements
all set to same value
optional
à None if not provided
d = dict.fromkeys(['a', (0,0), 100], 'N/A')
à {'a': 'N/A', (0,0): 'N/A', 100: 'N/A'}
d = dict.fromkeys((i**2 for i in range(1, 5)), False)
à {1: False, 4: False, 9: False, 16: False}
Copyright © MathByte Academy

Copyright © MathByte Academy

Basic Operations
d[key]
à as an expression returns the value for specified key
à exception KeyError if key is not found
à assigns value to key
d[key] = value
à creates key if it does not exist already
sometimes want to avoid this KeyError exception, and return a default value if key is not found
d.get(key) à returns value if key is found, None if key is not found
d.get(key, default)
à returns value if key is found, default if key is not found
Copyright © MathByte Academy

Basic Operations
membership testing
à test if a key is present in the dictionary or not
key in d
key not in d
à True if key is in d, False if it is not
à True if key is not in d, False if it is
len(d)
number of items in dictionary
clearing out all items
d.clear()
à d is now empty
Copyright © MathByte Academy

Removing Elements from a Dictionary
del d[key]
à removes element with that key from d
à exception KeyError if key is not in d
sometimes we want to avoid this KeyError exception
d.pop(key)
à removes element with that key from d
à and returns the corresponding value
à returns default is key was not found
à exception KeyError if key is not in d
d.pop(key, default)
à removes element with that key from d
à and returns the corresponding value
Copyright © MathByte Academy

Another way to remove items…
Python 3.6+
à dictionary remains ordered in order of insertion
d.popitem()
prior Python 3.6
à removes an item from d 
à returns tuple (key, value)
à KeyError if dictionary is empty
à removes some item – no guarantee which one
>= Python 3.6
à removes last item – guaranteed
à last item is the last item inserted
last inserted à popped first
Last In First Out
à LIFO
à works like a stack
Copyright © MathByte Academy

Inserting keys with defaults
sometimes want to insert a key with a default value only if key does not exist
d = {'a': 1, 'b': 2}
if 'c' not in d:
d['c'] = 0
à combine this with returning the newly inserted (default) value, or existing value if already there
def insert_if_not_present(d, key, value):
if key not in d:
d[key] = value
return value
else:
return d[key]
instead…
result = d.setdefault(key, value)
Copyright © MathByte Academy

Copyright © MathByte Academy

Dictionary Views
Three ways we may want to view the data in a dictionary
à keys only
à values only
à key/value pairs
à (key, value)
d.keys()
d.values()
d.items()
all are iterables
d = {'a': 1, 'b': 2, 'c': 3}
list(d.keys())
à ['a', 'b', 'c']
list(d.values())
à [1, 2, 3]
list(d.items())
à [('a', 1), ('b', 2), ('c', 3)]
Important: order of keys and values (and items) are the same
à the position of an item in one view corresponds to the same position in other views
à Python 3.6+: in addition, this order is same as dictionary (insertion) order
PEP 3106
Copyright © MathByte Academy

They’re dynamic…
more to it than just an iterable
these views are dynamic
à views reflect any changes in the dictionary
à but views are not updatable
d = {'a': 1, 'b': 2}
keys à 'a', 'b'
values à 1, 2
items à ('a', 1), ('b', 2)
d['a'] = 10
keys à 'a', 'b'
values à 10, 2
items à ('a', 10), ('b', 2)
del d['b']
d['c'] = 3
keys à 'a', 'c'
values à 10, 3
items à ('a', 10), ('c', 3)
keys = d.keys()
values = d.values()
items = d.items()
Copyright © MathByte Academy

More than just iterables…
The keys() view is more than an iterable
à behaves like a set
à union, intersection, difference of these key views – just like sets
The values() view does not behave like a set
à in general values are not unique
à in general values are not hashable
à makes sense: keys are unique and hashable
à required for sets
The items() view may behave like a set
à elements of items() are guaranteed unique (since keys are unique)
à if all values are hashable
à behaves like a set
à if one or more values unhashable
à does not behave like a set
Copyright © MathByte Academy

Set operations
We'll come back to sets and dictionary views in a later section
s1 = {'a', 'b', 'c'}
s2 = {'b', 'c', 'd'}
s1 | s2
union
à {'a', 'b', 'c', 'd'}
s1 & s2
intersection
à {'b', 'c'}
difference
s1 - s2
à {'a'}
Can manipulate keys() the same way
if dictionary values are all hashable
Same for items()
Copyright © MathByte Academy

Set Operations on Views
à dictionaries are now considered ordered (insertion order)
à sets are not ordered
d1.keys() and d2.keys() are ordered
but d1.keys() | d2.keys() is a set
à ordering of result is not guaranteed
Copyright © MathByte Academy

Copyright © MathByte Academy

The update method
updates one dictionary based on items in something else
à three forms
d1.update(d2)
d1.update(iterable)
d1.update(keyword-args)
à iterable must contain iterables with 2 elements each: (key, value)
à argument name will become key
à argument value will become value
(similar to dict(a=10, b=20))
Copyright © MathByte Academy

d1.update(d2)
à for every (k, v) in d2
à if k not in d1, inserts (k, v) in d1
à if k in d1, updates value for k in d1
d1 and d2 are two dictionaries
d1 = {'a': 1, 'b': 2}
d2 = {'b': 20, 'c': 30}
d1.update(d2)
d1 à {'a': 1, 'b': 20, 'c': 30}
'b' was updated
'c' was inserted
à insertion order is maintained (3.6+)
Copyright © MathByte Academy

d1.update(keyword-args)
similar to how keyword arguments are used to create a dictionary
à argument names must be valid identifiers
d1 = {'a': 1, 'b': 2}
d1.update(b=20, c=30)
d1 à {'a': 1, 'b': 20, 'c': 30}
'b' was updated
'c' was inserted
à insertion order is maintained (3.6+)
à order of keyword arguments is preserved (3.6+)
Copyright © MathByte Academy

d1.update(iterable)
à must be an iterable of iterables containing two elements
à key, value
[('b', 20), ['c', 30]]
(('b', 20), ('c', 30))
(('b', 20), ['c', 30])
à but also more complex iterables
à even generators
d1 = {'a': 1, 'b': 2}
d1.update(it)
d1 à {'a': 1, 'b': 20, 'c': 30}
d1 = {'a': 1, 'b': 2}
d1.update(((k, ord(k)) for k in 'bcd'))
((k, ord(k)) for k in 'bcd')
à 'b': 98, 'c': 99, 'd': 100
d1 à {'a': 1, 'b': 98, 'c': 99, 'd': 100}
à insertion order is preserved (3.6+)
Copyright © MathByte Academy

Unpacking dictionaries
works similar to unpacking a dictionary into keyword arguments in function calls
d = {'a': 1, 'b': 2}
def func(**kwargs):
print(kwargs)
func(**d)
kwargs à {'a': 1, 'b': 2}
à for function arguments, keys must be valid identifiers
à not for unpacking dictionaries in general
d1 = {'a': 1, 'b': 2}
d2 = {'a': 10, (0,0): 'origin'}
d3 = {'b': 20, 'c': 30, 'a': 100}
d = {**d1, **d2, **d3}
à insertion order is preserved (3.6+)
à last "update" wins
d à {'a': 100, 'b': 20, (0,0): 'origin', 'c': 30}
(argument order 
preserved 3.6+)
Copyright © MathByte Academy

Copying Dictionaries
shallow copies
container object is a new object
copied container element keys/values are shared references with original object
d_copy = d.copy()
d_copy = {**d}
d_copy = dict(d)
à all these methods result in shallow copies
d_copy = {k: v for k, v in d.items()}
à dictionaries are independent dictionaries
à but the keys and values are shared references
(inserts, deletes are independent)
(slower, don't use for a simple copy)
Copyright © MathByte Academy

Deep Copies
If a shallow copy is not sufficient, we can create deep copies of dictionaries
à no shared references
à even with nested dictionaries
can do it ourselves
à sometimes requires recursion, have to be careful with circular references
this might be needed if we don't want a true deep copy, but only a partial deep copy
simpler to use copy.deepcopy
from copy import deepcopy
à works for custom objects, iterables, 
dictionaries, etc
d1 = d.deepcopy()
Copyright © MathByte Academy

Copyright © MathByte Academy

Quick Review
how Python inserts a key/value item in a dictionary (simplified)
hash(key)
à mod dictionary size (allocated)
à start index in hash table (sequence of slots)
à generate probe sequence (sequence of valid indices)
à iterate over probe sequence
à is the slot at that index empty?
yes
à store the new item there (hash, key, value)
no
à hash collision
à continue iteration to 
look for an empty slot
à index
continue loop until 
an empty slot is 
found to store the 
item
more hash collisions à more inefficient
Copyright © MathByte Academy

Quick Review
how Python finds a key in a dictionary (simplified)
hash(key)
à mod dictionary size (allocated)
à start index in hash table (sequence of slots)
à generate probe sequence (sequence of valid indices)
à loop over probe sequence
à is slot empty?
yes
no
à key does not exist in dictionary
à are hashes equal and are keys equal (==)?
yes
à found the key
no
(caused by hash collision upon insertion/resizing)
à continue iteration to find key or empty slot
loop until 
found or 
empty slot
more hash collisions à more inefficient
predictable hashes à subject to DOS attacks
little more complex 
because of 
deletions
Copyright © MathByte Academy

à hash(key) when inserting item
à probe sequence remains the same
so hash of key cannot change after storing in dict
Quick Review
In order for this algorithm to work:
must equal hash(key) when retrieving item
otherwise we're starting our search in the wrong place!
à Python controls that, not us
Copyright © MathByte Academy

Copyright © MathByte Academy

What is a set?
mathematics
à a collection of distinct objects
à notice ordering is not mentioned!
A set is a gathering together into a whole of definite, distinct 
objects of our perception or of our thought -- which are called 
elements of the set.
- Georg Cantor
union
intersection
complement
set membership
size of set (cardinality)
and more…
Copyright © MathByte Academy

Copyright © MathByte Academy

What is a set?
à there is no particular ordering in a set
à objects are distinct
A set is an unordered collection of distinct objects
à {1, 3, 5}    {5, 1, 3}   {3, 5, 1} … are all the same set (equal)
à {1, 1, 3}
à not possible – element 1 is repeated
à Python data type: set
à elements must be hashable
à elements are distinct – they do not compare equal (==)
Copyright © MathByte Academy

Membership
If x is an element contained in some set S
and say x is an element of S
we write
! ∈#
à note that these are statements, not questions
à in Python the in operator is a question that returns True or False
If x is not an element contained in some set S
and say x is not an element of S
we write
! ∉#
x in S
à True
à ! ∈#
x in S
à False
à ! ∉#
x not in S
à False
à ! ∈#
x not in S
à True
à ! ∉#
à similarly with the not in operator
Copyright © MathByte Academy

Unions and Intersections
The union of two sets is a set that combines the items from these two sets, keeping only 
a single instance of any repeating elements
sets à %!, %"
%! ∪%" = ) ) ∈%! *+ ) ∈%"}
à Notice the or
The intersection of two sets is a set that only contains the elements common to both
%! ⋂%" = ) ) ∈%! ./0 ) ∈%"}
à Notice the and
à s1 | s2 | …
à returns a set
à s1 & s2 & …
à returns a set
!!
!"
!!
!"
à s1.union(s2, …)
à s1.intersection(s2, …)
Copyright © MathByte Academy

Differences of two sets
The difference of two sets is all the elements of one set without the elements of the other set
%! −%" = ) ) ∈%! ./0 ) ∉%"}
à s1 – s2 - …
!!
!"
à s1.difference(s2, …)
s1 = {1, 2, 3}
s2 = {3, 4, 5}
s1 - s2 à {1, 2}
s2 - s1 à {4, 5}
in general: s1 – s2  ≠ s2 – s1
Copyright © MathByte Academy

Symmetric Difference of two Sets
The symmetric difference of two sets is the union of both sets without the intersection of both sets
%! ∆%" = %! ∪%" −(%! ∩%")
!!
!"
à s1 ^ s2
à s1.symmetric_difference(s2)
in general: s1 ^ s2  = s2 ^ s1
s1 = {1, 2, 3, 4, 5}
s2 = {4, 5, 6, 7, 8}
s1 ^ s2 à {1, 2, 3, 6, 7, 8}
s2 ^ s1 à {1, 2, 3, 6, 7, 8}
Copyright © MathByte Academy

Empty Set, Cardinality, Disjoint Sets
An empty set is a set that contains no elements
à set()
cannot use {} to create an empty set
à this would create an empty dictionary
Two sets are said to be disjoint if their intersection is the empty set
For finite sets, the cardinality of a set is the number of elements in the set
à len(s)
à len(s1 & s2) à 0
à s1.isdisjoint(s2) à True (Boolean)
à cardinality is 0
Copyright © MathByte Academy

Subsets and Supersets
A set s1 is a subset of s2 if all the elements of s1 are in s2
A set s1 is a proper subset of s2 if s1 is a subset of s2 and s1 is not equal to s2
à i.e. s1 is a subset of s2 and s2 contains some additional elements
%! ⊆%"
%! ⊂%"
à s1 <= s2
à s1.issubset(s2)
à s1 < s2
A set s1 is a superset of s2 if s2 is a subset of s1
A set s1 is a proper superset of s2 if s2 is a subset of s1
à s1 >= s2
à s1.issuperset(s2)
à s1 > s2
{1, 2, 3} <= {1, 2, 3, 4} à True
{1, 2, 3} <= {1, 2, 3} à True
{1, 2, 3} < {1, 2, 3, 4} à True
{1, 2, 3} < {1, 2, 3} à False
Copyright © MathByte Academy

Copyright © MathByte Academy

Python Sets
Python has an implementation of sets that supports many set operations:
membership testing
à in, not in
unions
à s1 | s2, s1.union(s2)
intersections
à s1 & s2, s1.intersection(s2)
differences
à s1 - s2, s1.difference(s2)
symmetric differences
à s1 ^ s2, s1.symmetric_difference(s2)
subsets
à s1 <= s2, s1.issubset(s2)
à s1 < s2
supersets
à s1 >= s2, s1.issuperset(s2)
à s1 > s2
disjointness
cardinality
à len(s)
à s1.isdisjoint(s2)
Copyright © MathByte Academy

Python Sets
The type is 
set
Set literals
à {'a', 10, 10.5}
Empty set
à set()
Notice how the literal notation for sets uses the same braces {} as dictionaries
In fact sets are hash tables as well
Unlike dictionary hash tables, sets only contain the "keys", not the values
à set(iterable)
Copyright © MathByte Academy

Python Sets
elements of a set
à must be unique (distinct)
à must be hashable
a set is a mutable collection
à add and remove elements
à a set is therefore not hashable
à cannot be used as a dictionary key
à cannot be used as an element in another set
à no set of sets
à have no guaranteed order
Copyright © MathByte Academy

Frozen Sets
Frozen Sets are the immutable equivalent of sets
à think of tuples and lists
Can convert any set to a frozenset
à frozenset
elements of a frozenset
à must be unique (distinct)
à must be hashable
à no literal for a frozenset
à frozenset({1, 2, 3})
à frozenset(iterable)
A frozenset is hashable
à can be used as a dictionary key
à can be used as an element of a set (or frozenset)
à have no guaranteed order
Copyright © MathByte Academy

Membership Testing
Testing membership of an element in a set is extremely efficient
(hash table lookup)
In fact, instead of writing code like this:
if a in [10, 20, 30]:
or even
if a in (10, 20, 30):
prefer using (as long as elements are hashable):
if a in {10, 20, 30}:
à higher storage cost
à in, not in
Copyright © MathByte Academy

Some Timings
n = 10_000_000
s = set(range(n))
l = list(range(n))
t = tuple(range(n))
def test_set(s, value):
return value in s
def test_list(l, value):
return value in l
def test_tuple(t, value):
return value in t
timeit('test_set(s, value)', globals=globals(), number=10_000)
timeit('test_list(l, value)', globals=globals(), number=10_000)
timeit('test_tuple(t, value)', globals=globals(), number=10_000)
value = 100
value = 9_999_999
tuple
list
set
0.0186
0.0191
0.0016
1692
1659
0.0021
à list/tuple lookup à scan until found
à set/dictionary à hash table à direct lookup (+ hash collisions)
Copyright © MathByte Academy

Copyright © MathByte Academy

Creating Sets
à {'a', 10, 3.14159}
à set(iterable)
elements must be hashable
empty set
à cannot use a literal
à {} is an empty dict
à set()
à set comprehensions
{c for c in 'python'}
in this case simpler to just do this: 
set('python')
à elements must be hashable
Copyright © MathByte Academy

Creating Sets
à unpacking
unpack iterables
unpack dictionaries
sets are iterable
à can be unpacked too
*my_list
**my_dict
à order in which elements are unpacked is essentially unknown
*my_set
s1 = {'a', 10, 3.14}
s2 = set('abc')
{*s1, *s2}
à {'a', 'b', 'c', 10, 3.14}
[*s1, *s2]
my_func(*s1, *s2)
à works, but what's the order of the arguments???
à ['a', 'a', 'b', 'c', 10, 3.14]
Copyright © MathByte Academy

Copyright © MathByte Academy

len(s)
Cardinality and Membership
à number of elements in s
(cardinality of s)
in, not in
à x in s
à tests if x is in the set s
à like dictionary keys, use equality (==)
not identity (is)
membership testing in sets is fast
membership testing in a list of tuple is slow (in comparison)
à hash table lookup
à linear scan
à but sets have more memory overhead than lists or tuples
à tradeoff – speed vs memory
à we'll look at this in code
Copyright © MathByte Academy

Adding Elements
lists have ordering
à append
à insert
sets have no ordering
à add
s.add('python')
à mutates the set
Copyright © MathByte Academy

Removing Elements
lists have ordering
à can remove element by position
sets have no ordering
à cannot use position
à del l[1]
à can remove specific element
à l.remove(30)
l = [10, 20, 30]
à [10, 30]
à [10]
à can remove specific element
s = {'a', 'b', 'c'}
s.remove('b')
à {'a', 'c'}
s.remove('z')
à KeyError exception
to avoid KeyException
s.discard('a')
s.discard('z')
s à {'c'}
s à {'c'}
s.pop()
à removes and returns an arbitrary element
à KeyError if set is empty
s.clear()
à removes all elements from set
à mutates the set
Copyright © MathByte Academy

Copyright © MathByte Academy

Set Operations
à union
à intersection
à difference
à symmetric difference
à related: testing if two sets are disjoint
à containment
in general, we have two ways of doing these operations
à methods
à s1.intersection(s2)
à operators
à s1 & s2
s2 could be an iterable (of hashable elements)
s1 and s2 must both be sets
à strict and non-strict
Copyright © MathByte Academy

Intersections
{1, 2, 3}.intersection({2, 4})
à {2}
{1, 2, 3}.intersection([2, 4])
à {2}
{1, 2, 3} & {2, 4}
à {2}
s1 & s2 & s3 & s4
s1.intersection(s2, s3, s4)
à returns a new set
Copyright © MathByte Academy

Unions
Similar to how intersections work
{1, 2, 3}.union({2, 4})
à {1, 2, 3, 4}
{1, 2, 3}.union([2, 4])
à {1, 2, 3, 4}
{1, 2, 3} | {2, 4}
à {1, 2, 3, 4}
s1 | s2 | s3 | s4
s1.union(s2, s3, s4)
à returns a new set
Copyright © MathByte Academy

Disjointedness
two sets are disjoint if their intersection is empty
len(s1 & s2) à 0
à empty sets are falsy
if s1 & s2:
print('sets are not disjoint)
if not(s1 & s2):
print('sets are disjoint)
if not s1 & s2:
print('sets are disjoint)
à s1.isdisjoint(s2)
Copyright © MathByte Academy

Differences
{1, 2, 3, 4} – {2, 3}
à {1, 4}
{1, 2, 3, 4}.difference({2, 3})
à {1, 4}
s1 – s2 – s3
s1.difference(s2, s3)
{1, 2, 3, 4}.difference([2, 3])
à {1, 4}
à returns a new set
Beware!!
s1 – (s2 – s3)
not same as
(s1 – s2) – s3
{1, 2, 3} – ({2, 4} – {2, 4})
à {1, 2, 3} – {}
à {1, 2, 3}
({1, 2, 3} – {2, 4}) – {2, 4}
à {1, 3} – {2, 4} à {1, 3}
à left-associative
s1 – s2 – s3
à (s1 – s2) – s3
à s1.difference(s2, s3) à (s1 – s2) – s3
Copyright © MathByte Academy

Symmetric Differences
s1 = {1, 2, 3, 4}
s2 = {3, 4, 5, 6}
s1 ^ s2
à {1, 2, 5, 6}
union - intersection
à (s1 | s2) – (s1 & s2)
s1.symmetric_difference(s2)
s1.symmetric_difference([3, 4, 5, 6])
à returns a new set
Copyright © MathByte Academy

Containment
Remember
strict à not equal
s1 < s2
à is s1 strictly contained in s2
s1 <= s2
à is s1 contained in (possibly equal to) s2
s1 > s2
à is s2 strictly contained in s1
s1 >= s2
à is s2 contained in (possibly equal to) s1
à does s1 strictly contain s2
à does s1 contain (possibly equal) s2
à s1.issubset(s2)
à s1.issuperset(s2)
Copyright © MathByte Academy

Copyright © MathByte Academy

Updating Sets
sets have no ordering
à no indexing
lists
à l[2] = 100
cannot do that with sets
we can add and remove elements
à mutates the set
we can create unions, intersections, differences and symmetric differences
à but these operations create new sets
list analogy
l1 = [1, 2, 3]
l2 = [4, 5, 6]
l1 + l2
à new list
[1, 2, 3, 4, 5, 6]
but
l1 += l2
à mutates l1
l1 à [1, 2, 3, 4, 5, 6]
Copyright © MathByte Academy

Analogous Set Mutating Updates
|=
&=
^=
-=
à all these operations mutate the left hand side
lists: l1 += l2
à appends l2 to l1
à mutates l1
à id of l1 has not changed
à method equivalents
s1 |= s2
s1 &= s2
s1 ^= s2
s1 -= s2
s1.update(s2)
s1.intersection_update(s2)
s1.difference_update(s2)
s1.symmetric_difference_update(s2)
can use iterables too
Copyright © MathByte Academy

Analogous Set Mutating Updates
s1 |= s2 | s3
s1 &= s2 & s3
s1 -= s2 – s3
s1.update(s2, s3)
s1.intersection_update(s2, s3)
s1.difference_update(s2, s3)
BEWARE!!
s1 ß (s1 – s2) – s3
is not the same as 
s1 = {1, 2, 3, 4}
s2 = {2, 3}
s3 = {3, 4}
s1 ß s1 – (s2 – s3)
s1 – s2 à {1, 4}
{1, 4} - s3 à {1}
s2 – s3 à {2}
{1, 2, 3, 4} – {2} à {1, 3, 4}
à set differences are not associative
à in general s1 – (s2 – s3) ≠(s1 – s2) – s3
RHS is evaluated first
Copyright © MathByte Academy

Copyright © MathByte Academy

Shallow vs Deep Copies
As with other types such as dictionaries, lists, etc we have two types of copies
à shallow
à deep
from copy import deepcopy
s2 = s1.copy()
s2 = set(s1)
unpacking
s2 = {*s1}
s2 = deepcopy(s1)
Copyright © MathByte Academy

Copyright © MathByte Academy

Frozen Sets
à immutable sets
à same properties and behavior as sets
à except they cannot be mutated
Their elements can be mutable
If all elements in a frozen set are hashable, then the frozen set is also hashable
à can be used as a key in a dictionary
à can be an element of another set
frozenset()
à no literal expressions to create frozen sets
Copyright © MathByte Academy

Copying Frozen Sets
Think back to tuples and lists
l1 = [1, 2, 3]
l2 = list(l1)
l1 is l2 à False
t1 = (1, 2, 3)
t2 = tuple(t1)
t1 is t2 à True
à safe for Python to not make a copy of the tuple – since it is immutable
Same thing with sets and frozen sets
s1 = frozenset({1, 2, 3})
s2 = frozenset(s1)
s2 = s1.copy()
s1 is s2 à True
Deep copies do not behave that way
Copyright © MathByte Academy

Set Operations
non-mutating set operations
&
|
-
^
these operations can be performed on mixed sets and frozensets
resulting type?
à the type of the first operand
s1 & s2
à set if s1 is a set, even if s2 is a frozenset
à frozenset if s1 is a frozenset, even if s2 is a set
Copyright © MathByte Academy

Equality and Identity
Numbers
1.0 is 1 à False
1 + 0j is 1 à False
True is 1 à False
1.0 == 1 à True
1 + 0j == 1 à True
True == 1 à True
Same thing with sets and frozen sets
s1 = {1, 2, 3}
s2 = frozenset([1, 2, 3])
s1 is s2 à False
s1 == s2 à True
Copyright © MathByte Academy

Application: Memoization
In Part 1 of this series I covered memorization using decorators.
Python has a decorator available for memorization:
à https://en.wikipedia.org/wiki/Memoization
functools.lru_cache
But that decorator (and the one we wrote ourselves), has one drawback
@lru_cache
def my_func(*, a, b):
…
my_func(a=1, b=2)
à result is returned directly from cache
my_func(a=1, b=2)
à result is computed and cached
my_func(b=2, a=1)
à result is computed again, and cached
Copyright © MathByte Academy

Copyright © MathByte Academy

A long long time ago…
how would we iterate over all the keys, values or items of a dictionary?
d.keys()
d.values()
d.items()
à created and returned a list of these things
à list is static
d = {'a': 1, 'b': 2}
keys = d.keys()
à keys = ['a', 'b']
d['c'] = 3
à keys = ['a', 'b']
à list duplicates data – not good for large dictionaries – can be slow
à inefficient for membership testing
d = {'a': 1, 'b': 2}
values = d.values()
2 in values
à linear search
Copyright © MathByte Academy

A long long time ago…
To help with iteration:
d.iterkeys()
d.itervalues()
d.iteritems()
à iterators
better than a new list… did not duplicate data à more lightweight
still does not help with membership testing
also not easy to answer questions such as, given d1 and d2
what keys are common to both?
what keys are in one but not the other?
set questions
after all, keys have to be unique
à keys form a mathematical set
were introduced
Copyright © MathByte Academy

Key View
instead of keys() returning a list, and iterkeys() just being an iterator…
what if keys() was a lightweight object that
maintained a reference to the dictionary
and implemented methods such as:
__iter__
__contains__ 
__and__
__or__
__eq__
__lt__
etc
à iterable protocol
à membership testing
à union of two views
à intersection of two views
à same keys in both views
à is one set of keys a subset of the other
behaves like an iteratable
behaves like a set
does not "own" any data
Copyright © MathByte Academy

Dictionary Views
Three ways we may want to view the data in a dictionary
à keys only
à values only
à key/value pairs
à (key, value)
d.keys()
d.values()
d.items()
all are iterables
d = {'a': 1, 'b': 2, 'c': 3}
list(d.keys())
à ['a', 'b', 'c']
list(d.values())
à [1, 2, 3]
list(d.items())
à [('a', 1), ('b', 2), ('c', 3)]
Important: order of keys and values (and items) are the same
à the position of an item in one view corresponds to the same position in other views
à Python 3.6+: in addition, this order is same as dictionary (insertion) order
PEP 3106
some may have set properties
(as long as the dictionary keys were not modified in between)
Copyright © MathByte Academy

Set Behavior
The keys() view always behaves like a (frozen) set
à since elements are unique (==) and hashable
The items() view may behave like a (frozen) set
à if the values are hashable
à uniqueness of tuples are guaranteed since keys are unique
The values() view never behaves like a set
à values not guaranteed unique
à values not guaranteed hashable
Copyright © MathByte Academy

And also…
dynamic
à views reflect any changes in the dictionary
à but views are not updatable
d = {'a': 1, 'b': 2}
keys à 'a', 'b'
values à 1, 2
items à ('a', 1), ('b', 2)
d['a'] = 10
keys à 'a', 'b'
values à 10, 2
items à ('a', 10), ('b', 2)
del d['b']
d['c'] = 3
keys à 'a', 'c'
values à 10, 3
items à ('a', 10), ('c', 3)
keys = d.keys()
values = d.values()
items = d.items()
immutable
lightweight
à views do not maintain their own copy of the underlying data
à simply implement methods that use the underlying dictionary
à proxy
Copyright © MathByte Academy

Modifying the dictionary while iterating over a view
This is SAFE:
for key in d.keys():
d[key] += 1
This leads to an EXCEPTION:
for v in d.values():
del d['a']
be careful doing this
à modifying values usually not a problem
à modifying keys can lead to exceptions or worse disasters!
à Python does not allow modifying the 
size of the underlying dictionary while 
iterating over a view
You technically can modify the keys as long as you do not change the size of the dictionary
à don't do it!
Python docs:
Iterating views while adding or deleting entries in the 
dictionary may raise a RuntimeError or fail to iterate 
over all entries.
à no guarantee it will work the way you think it should
Copyright © MathByte Academy

Copyright © MathByte Academy

Serializing and Deserializing Objects
à useful for persistence and/or transmission
sometimes we have objects (data)
à want to "save" them somewhere so we can retrieve ("load") them later
à even after program that generated the data has terminated
generically applies to any object
à create a persistent representation of the object
à deserializing
à reconstruct the object from the serialized data
à serializing
à transmit them to someone or something else outside our app
Copyright © MathByte Academy

Pickling and Unpickling
Python specific
à built-in mechanism to serialize and deserialize many objects using 
binary representation
Databases
à relational databases
à e.g. objects like record sets, lists of tuples, etc
à NoSQL databases
à e.g. graphs, documents, etc
JSON
à ubiquitous standard
à MongoDB 
à REST APIs 
à text representation
à more limited data types
à human readable
à Web / Javascript
and more…
Copyright © MathByte Academy

Focus on Serializing Dictionaries
à Pickle will apply to more than just dictionary objects
à focus on dictionaries because of JSON
à easy to serialize dictionaries to JSON
à easy to deserialize JSON to dictionaries
à loss of some data types
à many alternatives
https://marshmallow.readthedocs.io
à beyond scope of this series: marshmallow
Copyright © MathByte Academy

Copyright © MathByte Academy

The pickle Module
Python specific
A way to represent an object in a persistent way
Create an object’s representation
à serializing
Reload object from representation
à deserializing
marshalling
Pickle is a binary serialization (by default)
Focus on dictionaries
à Can be used for other object types
à disk, transmission
obj
101100011001…
serialize
deserialize
obj
Copyright © MathByte Academy

Danger Zone!
Unpickling (deserializing) can execute code
à not safe!
Only unpickle data you trust
Copyright © MathByte Academy

Usage
import pickle
dump
à pickle to file
load
à unpickle from file
dumps
à returns a (string) pickled representation
loads
à unpickle from supplied argument
à store in a variable
Copyright © MathByte Academy

Equality and Identity
equality à ==
identity à is
dict1
pickle
0011
0000
1111
01
unpickle
dict2
id=100
id=200
dict1 == dict2
à True
dict1 is dict2
à False
à Custom objects will need to implement __eq__
Copyright © MathByte Academy

Equality and Identity
While pickling, Python will not re-serialize an object it has already serialized
à recursive objects can be pickled
à shared objects are deserialized as shared objects as well
•
prop1
•
prop2
obj1
pickle / unpickle
•
prop1
•
prop2
obj1
Copyright © MathByte Academy

Copyright © MathByte Academy

JSON
JavaScript Object Notation
à text-based object serialization
à open standard
à human-readable
Very common format for web API's and general data interchange between systems
Unlike pickling, it is considered safe
à may vary based on the JSON deserializer you use
Copyright © MathByte Academy

strings
delimited by double quotes
"python"
integers
floats
unicode
booleans
100
3.14
100.0
true, false
arrays (lists)
[1, 3.1, "python"]
delimited by square brackets
ordered
dictionaries
{ "a": 1, "b": "python"}
key-value pairs
Limited Data Types
keys à strings
values à any supported data type
unordered
empty value
null
numbers
100
3.14
Often, non-standard, additional types are supported:
NaN
3.14e-05
Infinity
-Infinity
3.14E+5
à all floats
Copyright © MathByte Academy

Example
{
"title": "Fluent Python",
"author": {
"firstName": "Luciano",
"lastName": "Ramalho"
},
"publisher": "O'Reilly",
"isbn": "978-1-491-9-46008",
"firstReleased": 2015,
"listPrice": [
{
"currency": "USD",
"price": 49.99
},
{
"currency": "CAD",
"price": "57.99"
}
]
}
reminds you of Python??
Copyright © MathByte Academy

Serialization and Deserialization
JSON is a natural fit for serializing and deserializing Python dictionaries
Of course, Python dictionaries are objects
JSON is essentially a string
import json
dump, dumps
load, loads
dict
{ … }
file
string
dict
serialize
dump, dumps
deserialize
load, loads
Copyright © MathByte Academy

Problems…
JSON keys must be strings
à but Python dictionary keys just need to be hashable
à how to serialize?
JSON value types are limited
à Python dictionary values can be any data type
à how to serialize?
even if we can serialize a complex data type, such as a custom class
à how do we deserialize back to original data type?
à Customize serialization and deserialization
we'll come back to this later…
Copyright © MathByte Academy

Copyright © MathByte Academy

Custom Encodings
As we saw in the previous video, any object can be serialized to JSON
cumbersome à remember to call the JSON serializer for every class
how do we do it for nested dictionaries and lists?
dump
à can provide custom callable
à uses a default instance of JSONEncoder
à we can completely override JSONEncoder
dumps
Copyright © MathByte Academy

Specifying a Custom Encoding Function
à when provided, Python will call default if it encounters a type it cannot serialize
à argument must be a callable
à callable must have a single argument
à that argument will receive the object Python cannot serialize
à can include logic in our callable to differentiate between different types
à or we can use a single dispatch generic function
[ using the @singledispatch decorator from the functools module]
One of the arguments of the dump / dumps function is default
Copyright © MathByte Academy

Copyright © MathByte Academy

dump
In the previous videos we looked at the dump and dumps functions
Beyond the default argument, dump has many other arguments that allow us to control serialization
skipkeys
bool
default is False
à if dictionary keys are not basic types 
(string, int, etc) and skipkeys is set to 
False we will get a TypeError, otherwise it 
just skips the key
indent
int
default is None
à useful for human readability
separators
tuple
defaults to (', ', ': ')
à customizes how the JSON is rendered
sort_keys
boolean
default is False
à if True, dictionary keys 
will be sorted
and more…
cls
Copyright © MathByte Academy

The JSONEncoder Class
Python uses an instance of the JSONEncoder class in the json module to serialize data
The JSONEncoder class shares many arguments with the dump / dumps functions
default
skipkeys
sort_keys
indent
separators
…
The dump / dumps functions have a cls argument
allows us to specify our own version of JSONEncoder
Copyright © MathByte Academy

Why use JSONEncoder at all?
If dump has all the same arguments as JSONEncoder, why use it at all?
To remain consistent in our app, every time we call dump we need to use the same argument 
values
Easy to make a mistake, or forget to specify an argument
à instead use a custom JSONEncoder
and just remember to specify it via the cls argument 
of dump / dumps
Copyright © MathByte Academy

How to create a custom JSONEncoder
à subclass JSONEncoder
à override the default method
à handle what we want to handle ourselves
à otherwise delegate back to the parent class
à custom initialize parent class if we want to
class CustomEncoder(JSONEncoder):
def __init__(self):
super().__init__(skipkeys=True, allow_nan=False, 
indent='---', separators=('', ' = '))
def default(self, arg):
if isinstance(arg, datetime):
return arg.isoformat()
else:
return super().default(self, arg)
inherit from JSONEncoder
custom init parent
override default method
handle what we want to handle
(return the string serialization of arg)
otherwise delegate 
back to parent
Copyright © MathByte Academy

Copyright © MathByte Academy

Loading JSON
We have seen how to serialize Python objects to JSON
Now we need to look at deserializing JSON to Python objects
à load  loads
works out-of-the-box with the standard JSON data types
import json
j = '{"a": 1, "b": {"sub1": [2, 3]}}'
d = json.loads(j)
d à
{
"a": 1,
"b": {
"sub1": [2, 3]
}
}
numbers, booleans, strings, lists, 
dictionaries (key:value pairs)
does not work with other types
j = '{"createdAt": "2020-12-31T23:59:59"}'
interpreted as a string
Copyright © MathByte Academy

One Approach
Use some custom encoding scheme to define both the value and the type of some entry in the JSON file
For example, when encoding a timestamp, we could do it as follows:
j = '''
{ "createdAt": 
{
"objecttype": "isodatetime",
"value": "2020-12-31T23:59:59"
}
}
'''
à load the JSON string into a Python dictionary
à iterate through dictionary (recursively), to find objects with an objecttype == isodatetime
à replace createdAt with the converted timestamp
à tedious
à load JSON, iterate recursively through 
dictionary, and convert as needed
Copyright © MathByte Academy

A Slight Improvement
load and loads have an argument named object_hook
à loads(j_string, object_hook=my_func)
à my_func is called for every object in the JSON data
For example:
j = '''
{ 
"a": 1,
"b": {
"sub1": [1, 2, 3],
"sub2": {
"x": 100,
"y": 200
}
}
}
'''
à object_hook will call for every dictionary (object) in the dictionary
à loads first parses JSON into a dictionary
à root dictionary
à b dictionary
à sub2 dictionary
à dictionary is replaced by return 
value of my_func
(called last)
à handles recursive aspect for us
Copyright © MathByte Academy

Schemas
Deserializing custom JSON types and objects is difficult
à in general we need to know the structure of the JSON data in order to custom deserialize
à this is referred to as the schema
à a pre-defined agreement on how the JSON is going to be structured or serialized
à If JSON has a pre-determined schema, then we can handle custom deserialization
à schema might be for the entire JSON, or for sub-components only
{ "createdAt": 
{
"objecttype": "isodatetime",
"value": "2020-12-31T23:59:59"
}
}
if we see this, replace the dict with the 
custom object/value
Copyright © MathByte Academy

Overriding Basic Type Serializations
Notice that object_hook only allows us to customize deserialization of objects
What about numbers?
à by default floats for real numbers, and ints for whole numbers
What if we want Decimal instead of float, or binary representations for integers?
à can override the way these data types are handled by using some extra arguments in load/loads
à parse_float
à parse_int
à parse_constant
à provide a custom callable
à callable has a single argument
à No overrides for strings
à argument value will be the original string in the JSON
à return parsed value
Copyright © MathByte Academy

Example
from decimal import Decimal
def make_decimal(arg):
return Decimal(arg)
If load / loads encounters this in the JSON data:
"a": 100.5
à loads(j, parse_float=make_decimal)
à calls make_decimal("100.5")
à deserialized JSON will now have Decimal("100.5") instead of float 100.5
Copyright © MathByte Academy

Another argument – object_pairs_hook
à related to object_hook
à cannot use both at the same time
(if both are specified, then object_hook is ignored)
object_hook passes the deserialized dictionary to the callable
à there is no guarantee of the order of elements in the dictionary
What if order of elements in JSON is important?
à lists preserve order
à instead of callable receiving a dictionary it receives a list of the key/value pairs
à key/value pairs are provided as a tuple with two elements
{"a": 1, "b": 2}
object_hook
object_pairs_hook
[ ("a", 1), ("b": 2) ]
Copyright © MathByte Academy

Mixing Basic Type Overrides and Object Hooks
à can specify both parse_... and object_hook
Remember that object_hook (and object_pairs_hook) callables receive a parsed object
This means parse_... (if specified) is used first, before we receive the parsed object in the hooks
Copyright © MathByte Academy

Copyright © MathByte Academy

Recall…
working with serialization, we could use dump or JSONEncoder
Similarly, we can create a custom JSONDecoder class and specify it with the cls argument
à json.loads(j, cls=CustomDecoder)
Just a different way of doing it à might help making sure we use our custom decoder consistently
à works a differently than JSONEncoder
à inherit from JSONDecoder
à override the decode function
à decode function receives entire JSON string
à we have to fully parse and return whatever object we want
Copyright © MathByte Academy

Copyright © MathByte Academy

In this section we are going to look at other specialized types of dictionaries that the Python 
standard library provides
Specialized Dictionaries
defaultdict
OrderedDict
ChainMap
Counter
UserDict
automatic default values for "missing" keys
guaranteed key ordering (based on insertion order), plus some extras
specialized tools for dealing with counters
efficient way of "combining" multiple dictionaries
alternative to subclassing dict for creating custom dictionary types
Copyright © MathByte Academy

Copyright © MathByte Academy

Missing Keys
standard dictionary (dict)
d = {}
d['a']
à KeyError
à can use the get method to handle default values for non-existent keys
d.get('a', 100)
d['a'] = d.get('a', 0) + 1
à general pattern for counters
à we get 100 if 'a' is not present, but 'a' is still not in dictionary
à works, but possibly have to remember to always use the same default in multiple places for same dict
in general: d.get(key, value)
à value could be returned from calling a callable
à easier would be to define the default once (per dict)
Copyright © MathByte Academy

defaultdict
à collections module
à subclass of dict type
(defaultdict instance IS-A dict instance)
defaultdict(callable, […])
callable is called to calculate a default
remaining arguments are simply passed 
to dict constructor
d = defaultdict(lambda: 'python')
à callable must have zero arguments
à default is None
and None will be the default value
d['a']
à 'python'
d à {'a': 'python'}
à entry has been created
d à {}
à referred to as a factory method
à so has all the functionality of a standard dict
Copyright © MathByte Academy

Other Factory Functions
Often we want to initialize values to 0, an empty string, an empty list, etc
int() à 0
defaultdict(lambda: 0)
defaultdict(int)
has the same effect
list() à []
defaultdict(lambda: [])
defaultdict(list)
has the same effect
à factory must simply be a callable that can take zero arguments and returns the desired 
default value
à can even be a function that calls a database and returns some value
à function does not have to be deterministic
à can return different values every time it is called
à factory is invoked every time a default value is needed
Copyright © MathByte Academy

OrderedDict
Copyright © MathByte Academy

OrderedDict vs dict
à prior to Python 3.6 no guarantee of key insertion order being maintained
à if you must have an ordered dictionary and be backward compatible, must use OrderedDict
à if not, OrderedDict still has a few tricks up its sleeve!
à supports reverse iteration
à pop first or last item in dictionary
à move item to beginning or end of dictionary
makes sense since there is an ordering
functionality not built-in to standard dict
Equality comparison (==) does not behave the same way
dict vs dict comparison
à order of keys does not matter
OrderedDict vs OrderedDict comparison
à order of keys matters
dict vs OrderedDict comparison
à order of keys does not matter
à have to "work" to get that behavior
(collections module)
Copyright © MathByte Academy

Copyright © MathByte Academy

Using Dictionaries to Maintain Counters
We've already seen how we can use regular dict and defaultdict for counters
d[key] = d.get(key, 0) + 1
d[key] += 1
d = {}
d = defaultdict(int)
certain operations can be tedious:
count the frequency of characters in a string (or items in an iterable in general)
update one counter dictionary with another counter dictionary (adding or subtracting)
from multiple counter dictionaries, find the max/min counter value for each key
Copyright © MathByte Academy

The collections.Counter class
The Counter class is a specialized dictionary that makes certain operations easier
à acts like a defaultdict and with a default of 0
à supports same constructor options as regular dicts
à iterate through every key, repeating each key as many times as the corresponding counter value
à find the n most common items (by count)
à increment/decrement counters based on another Counter or dict or iterable
à additional functionality to auto calculate a frequency table based on any iterable
à fromkeys is not supported
à update works differently than a regular dict
in-place addition of counts
iterable is just a sequence of elements, not tuples
Copyright © MathByte Academy

Copyright © MathByte Academy

Remember chain from itertools?
from itertools import chain
l1 = […]
l2 = (…)
l3 = generator_func()
for e in chain(l1, l2, l3):
…
à made it look like we had a single iterable – but really just chained them one after the other
collections.ChainMap serves a similar purpose – chaining dictionaries (or mapping types in general)
from collections import ChainMap
d1, d2, d3 à dictionaries
d = ChainMap(d1, d2, d3)
à no extra storage (nothing is copied)
very different from
d = {**d1, **d2, **d3}
à extra storage
à mutating elements in chain may affect underlying dicts
à essentially a shallow copy/merge
à sees changes in underlying dicts
à does not see changes in original dicts
à behaves more like a dictionary view (but is updatable!)
Copyright © MathByte Academy

Reading Keys from a Chain
There's an added complexity chaining maps that we do not have with iterables
The resulting chain should itself be a map
à no repeated keys!
d1 = {'a': 10, 'b': 20}
d2 = {'a': 100, 'c': 30}
d3 = ChainMap(d1, d2)
d3['b'] à 20
d3['c'] à 30
d3['a'] ??
à uses the first instance of the key it encounters in the chain
à unlike {**d1, **d2} where the last instance takes effect
d3['a'] à 10
à iteration works the same way
à first instance of any key is returned – others are ignored
Be Careful!
à unlike a dict there is no guarantee of key order when 
iterating a ChainMap
Copyright © MathByte Academy

Think of it as Parent-Child Relationships
ChainMap(d1, d2, d3)
d3
child
d2
d1
parents
overrides
overrides
In fact, there are attributes to deal with this explicitly
d.parents
à a ChainMap containing the parent elements only
d.new_child(d4)
à adds d4 to the front of the chain (or bottom of the hierarchy)
d3
d2
d1
d4
à same as
ChainMap(d4, d1, d2, d3)
ChainMap(d4, ChainMap(d1, d2, d3))
parents
new child
Copyright © MathByte Academy

Additional ways to update the Chain
The .maps property returns a (mutable) list of all the maps in the chain
The order of the list is the same as the child à parents hierarchy
i.e. first element is the child, other elements are the parents in the same order
This list is mutable
à can modify the chain by removing, deleting, inserting and appending other maps
d = ChainMap(d1, d2, d3)
d.maps à [d1, d2, d3]
d.maps.append(d4)
à ChainMap(d1, d2, d3, d4)
d.maps.insert(0, d5)
à ChainMap(d5, d1, d2, d3, d4)
del d.maps[1]
à ChainMap(d5, d2, d3, d4)
Copyright © MathByte Academy

Mutating Maps via the ChainMap
The ChainMap is mutable
à we already saw we could add and remove maps from the chain
We can also mutate the key/value pairs in the map itself
d = ChainMap(d1, d2)
à d[key] = value
BUT
these mutations affect the child (first) map only
d1 = {'a': 1, 'b': 2}
d2 = {'a': 20, 'c': 3}
d = ChainMap(d1, d2)
d['a'] = 100
d1 = {'a': 100, 'b': 2}
d2 = {'a': 20, 'c': 3}
d['c'] = 200
d1 = {'a': 100, 'b': 2, 'c': 200}
d2 = {'a': 20, 'c': 3}
del d['a']
d1 = {'b': 2, 'c': 200}
d2 = {'a': 20, 'c': 3}
d['a'] à 20
del d['a']
à KeyError exception
even though 'a' is in the chain
à not in the child (first) map
Copyright © MathByte Academy

Copyright © MathByte Academy

Custom Dictionaries
In the previous videos of this section, we looked at a variety of specialized dictionaries.
They extend the plain dict type with additional capabilities geared towards some specialized goal
Sometimes, we want to do the same.
à a dictionary that only allows certain types of keys (strings keys only à JSON)
à a dictionary that only allows keys from some finite set of pre-defined keys
à a dictionary that only allows numerical values
We could just create a custom class that uses a plain dict as a backing structure and write 
custom __getitem__ and __setitem__ methods
à often good enough, but we don't inherit all the functionality that dicts have
Copyright © MathByte Academy

Subclassing dict
We can create a custom class that inherits from dict
We can override various methods to customize the dictionary behavior
But there is a caveat here
If we have a parent class that implements a method and we 
override that method in a subclass
- calling that method on a subclass instance will invoke the 
overridden method
dicts have __getitem__ and __setitem__ methods
d['a']
d.__getitem__('a')
d['a'] = 10
d.__setitem__('a', 10)
We would expect the dictionary class to use these __xxx__ methods internally
.get()
.update()
and so on
These built-in types however, often use direct access to data (in C)
They do not guarantee they actually use these "special" methods
for
Even len(string) does not actually use __len__
Copyright © MathByte Academy

Alternative
If subclassing a dict is causing issues because of the special methods
we can use a predefined Python class:
collections.UserDict
It is not technically a subclass of dict
and implements key functionality we have in dictionaries
it uses a regular dictionary as a backing data structure
it is not a dict, but it is a mapping type
à views: items(), keys(), values()
à __setitem__ and __getitem__
and uses those internally as appropriate
à plus everything else we would expect from a dictionary
So it is essentially a head-start on recreating a Python dictionary from scratch that offers 
different subclassing possibilities
à Code section will help illustrate all this in more detail
Copyright © MathByte Academy

