







Digital Electronics 2






Series Editor 
Robert Baptiste 



Sequential and Arithmetic Logic Circuits 














Digital Electronics 2
Tertulien Ndjountche










)LUVWSXEOLVKHGLQ*UHDW%ULWDLQDQGWKH8QLWHG6WDWHVE\,67(/WGDQG-RKQ:LOH\	6RQV,QF
$SDUW IURP DQ\ IDLU GHDOLQJ IRU WKH SXUSRVHV RI UHVHDUFK RU SULYDWH VWXG\ RU FULWLFLVP RU UHYLHZ DV
SHUPLWWHGXQGHUWKH&RS\ULJKW'HVLJQVDQG3DWHQWV$FWWKLVSXEOLFDWLRQPD\RQO\EHUHSURGXFHG
VWRUHGRUWUDQVPLWWHGLQDQ\IRUPRUE\DQ\PHDQVZLWKWKHSULRUSHUPLVVLRQLQZULWLQJRIWKHSXEOLVKHUV
RU LQ WKH FDVH RI UHSURJUDSKLF UHSURGXFWLRQ LQ DFFRUGDQFH ZLWK WKH WHUPV DQG OLFHQVHV LVVXHG E\ WKH
&/$ (QTXLULHV FRQFHUQLQJ UHSURGXFWLRQ RXWVLGH WKHVH WHUPV VKRXOG EH VHQW WR WKH SXEOLVKHUV DW WKH
XQGHUPHQWLRQHGDGGUHVV
,67(/WG
-RKQ:LOH\	6RQV,QF
6W*HRUJH¬∂V5RDG
5LYHU6WUHHW
/RQGRQ6:(8
+RERNHQ1-
8.
86$
ZZZLVWHFRXN
ZZZZLOH\FRP

¬ã,67(/WG
7KHULJKWVRI7HUWXOLHQ1GMRXQWFKHWREHLGHQWLILHGDVWKHDXWKRURIWKLVZRUNKDYHEHHQDVVHUWHGE\KLP
LQDFFRUGDQFHZLWKWKH&RS\ULJKW'HVLJQVDQG3DWHQWV$FW
/LEUDU\RI&RQJUHVV&RQWURO1XPEHU

%ULWLVK/LEUDU\&DWDORJXLQJLQ3XEOLFDWLRQ'DWD
$&,3UHFRUGIRUWKLVERRNLVDYDLODEOHIURPWKH%ULWLVK/LEUDU\
,6%1

Contents
Preface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
ix
Chapter 1. Latch and Flip-Flop
. . . . . . . . . . . . . . . . . . . . . . . .
1
1.1. Introduction
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1
1.2. General overview
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1
1.2.1. SR latch . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
6
1.2.2. S R latch . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9
1.2.3. Application: switch debouncing . . . . . . . . . . . . . . . . . . . .
11
1.3. Gated SR latch . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
11
1.3.1. Implementation based on an SR latch . . . . . . . . . . . . . . . . .
12
1.3.2. Implementation based on an S R latch
. . . . . . . . . . . . . . . .
14
1.4. Gated D latch . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
15
1.5. Basic JK Ô¨Çip-Ô¨Çop
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
16
1.6. T Ô¨Çip-Ô¨Çop . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
18
1.7. Master-slave and edge-triggered Ô¨Çip-Ô¨Çop . . . . . . . . . . . . . . . . .
20
1.7.1. Master-slave Ô¨Çip-Ô¨Çop . . . . . . . . . . . . . . . . . . . . . . . . . .
20
1.7.2. Edge-triggered Ô¨Çip-Ô¨Çop . . . . . . . . . . . . . . . . . . . . . . . . .
24
1.8. Flip-Ô¨Çops with asynchronous inputs . . . . . . . . . . . . . . . . . . . .
30
1.9. Operational characteristics of Ô¨Çip-Ô¨Çops . . . . . . . . . . . . . . . . . .
33
1.10. Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
34
1.11. Solutions
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
39
Chapter 2. Binary Counters . . . . . . . . . . . . . . . . . . . . . . . . . . .
51
2.1. Introduction
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
51
2.2. Modulo 4 counter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
52
2.3. Modulo 8 counter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
53
2.4. Modulo 16 counter
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
55
2.4.1. Modulo 10 counter
. . . . . . . . . . . . . . . . . . . . . . . . . . .
57

vi
Digital Electronics 2
2.5. Counter with parallel load
. . . . . . . . . . . . . . . . . . . . . . . . .
60
2.6. Down counter
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
62
2.7. Synchronous reversible counter
. . . . . . . . . . . . . . . . . . . . . .
64
2.8. Decoding a down counter . . . . . . . . . . . . . . . . . . . . . . . . . .
65
2.9. Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
66
2.10. Solutions
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
73
Chapter 3. Shift Register
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
85
3.1. Introduction
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
85
3.2. Serial-in shift register . . . . . . . . . . . . . . . . . . . . . . . . . . . .
85
3.3. Parallel-in shift register . . . . . . . . . . . . . . . . . . . . . . . . . . .
85
3.4. Bidirectional shift register
. . . . . . . . . . . . . . . . . . . . . . . . .
88
3.5. Register Ô¨Åle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
90
3.6. Shift register based counter . . . . . . . . . . . . . . . . . . . . . . . . .
91
3.6.1. Ring counter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
92
3.6.2. Johnson counter . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
93
3.6.3. Linear feedback counter
. . . . . . . . . . . . . . . . . . . . . . . .
94
3.7. Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
101
3.8. Solutions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
107
Chapter 4. Arithmetic and Logic Circuits . . . . . . . . . . . . . . . . . .
117
4.1. Introduction
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
117
4.2. Adder . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
117
4.2.1. Half adder . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
117
4.2.2. Full adder . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
119
4.2.3. Ripple-carry adder . . . . . . . . . . . . . . . . . . . . . . . . . . . .
120
4.2.4. Carry-lookahead adder . . . . . . . . . . . . . . . . . . . . . . . . .
122
4.2.5. Carry-select adder . . . . . . . . . . . . . . . . . . . . . . . . . . . .
124
4.2.6. Carry-skip adder . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
125
4.3. Comparator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
127
4.4. Arithmetic and logic unit . . . . . . . . . . . . . . . . . . . . . . . . . .
129
4.5. Multiplier . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
136
4.5.1. Multiplier of 2-bit unsigned numbers . . . . . . . . . . . . . . . . .
136
4.5.2. Multiplier of 4-bit unsigned numbers . . . . . . . . . . . . . . . . .
137
4.5.3. Multiplier for signed numbers . . . . . . . . . . . . . . . . . . . . .
138
4.6. Divider . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
143
4.7. Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
149
4.8. Solutions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
158
Chapter 5. Digital Integrated Circuit Technology . . . . . . . . . . . . .
177
5.1. Introduction
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
177
5.2. Characteristics of the technologies . . . . . . . . . . . . . . . . . . . . .
177

Contents
vii
5.2.1. Supply voltage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
177
5.2.2. Logic levels
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
178
5.2.3. Immunity to noise . . . . . . . . . . . . . . . . . . . . . . . . . . . .
178
5.2.4. Propagation delay . . . . . . . . . . . . . . . . . . . . . . . . . . . .
179
5.2.5. Electric power consumption . . . . . . . . . . . . . . . . . . . . . .
179
5.2.6. Fan-out or load factor . . . . . . . . . . . . . . . . . . . . . . . . . .
179
5.3. TTL logic family . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
180
5.3.1. Bipolar junction transistor . . . . . . . . . . . . . . . . . . . . . . .
180
5.3.2. TTL NAND gate . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
181
5.3.3. Integrated TTL circuit . . . . . . . . . . . . . . . . . . . . . . . . . .
182
5.4. CMOS logic family . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
183
5.4.1. MOSFET transistor . . . . . . . . . . . . . . . . . . . . . . . . . . .
183
5.4.2. CMOS logic gates . . . . . . . . . . . . . . . . . . . . . . . . . . . .
184
5.5. Open drain logic gates . . . . . . . . . . . . . . . . . . . . . . . . . . . .
185
5.5.1. Three-state buffer . . . . . . . . . . . . . . . . . . . . . . . . . . . .
187
5.5.2. CMOS integrated circuit . . . . . . . . . . . . . . . . . . . . . . . .
188
5.6. Other logic families . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
189
5.7. Interfacing circuits of different technologies . . . . . . . . . . . . . . .
189
5.8. Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
190
5.9. Solutions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
193
Chapter 6. Semiconductor Memory
. . . . . . . . . . . . . . . . . . . . .
195
6.1. Introduction
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
195
6.2. Memory organization . . . . . . . . . . . . . . . . . . . . . . . . . . . .
195
6.3. Operation of a memory . . . . . . . . . . . . . . . . . . . . . . . . . . .
197
6.4. Types of memory
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
199
6.4.1. Non-volatile memory . . . . . . . . . . . . . . . . . . . . . . . . . .
199
6.4.2. Volatile memories . . . . . . . . . . . . . . . . . . . . . . . . . . . .
202
6.4.3. Characteristics of the different memory types
. . . . . . . . . . . .
207
6.5. Applications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
207
6.5.1. Memory organization . . . . . . . . . . . . . . . . . . . . . . . . . .
208
6.5.2. Applications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
209
6.6. Other types of memory . . . . . . . . . . . . . . . . . . . . . . . . . . .
218
6.6.1. Ferromagnetic RAM
. . . . . . . . . . . . . . . . . . . . . . . . . .
220
6.6.2. Content-addressable memory . . . . . . . . . . . . . . . . . . . . . .
222
6.6.3. Sequential access memory . . . . . . . . . . . . . . . . . . . . . . .
223
6.7. Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
226
6.8. Solutions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
230
Chapter 7. Programmable Logic Circuits . . . . . . . . . . . . . . . . . .
245
7.1. General overview
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
245
7.2. Programmable logic device . . . . . . . . . . . . . . . . . . . . . . . . .
246
7.3. Applications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
255

viii
Digital Electronics 2
7.3.1. Implementation of logic functions . . . . . . . . . . . . . . . . . . .
255
7.3.2. Two-bit adder
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
257
7.3.3. Binary-to-BCD and BCD-to-binary converters . . . . . . . . . . . .
263
7.4. Programmable logic circuits (CPLD and FPGA) . . . . . . . . . . . . .
263
7.4.1. Principle and technology . . . . . . . . . . . . . . . . . . . . . . . .
264
7.4.2. CPLD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
268
7.4.3. FPGA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
270
7.5. References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
274
7.6. Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
275
7.7. Solutions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
284
Appendix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
307
Bibliography
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
309
Index
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
311

Preface
The omnipresence of electronic devices in everyday life is accompanied by the
size reduction and the ever-increasing complexity of digital circuits. This
comprehensive and easy-to-understand work deals with basic principles of digital
electronics and allows the reader to grasp the subtleties of digital circuits from logic
gates to Ô¨Ånite-state machines. It presents all the aspects related to combinational
logic and sequential logic. It introduces techniques to establish in a simple and
concise manner logic equations, as well as methods for the analysis and design of
digital circuits. Emphasis has been especially laid on design approaches that can be
used to ensure a reliable operation of Ô¨Ånite-state machines. Various programmable
logic circuit structures and their applications are also presented. Each chapter
includes practical examples and well-designed exercises with worked solutions.
This series of books discusses all the different aspects of digital electronics,
following
a
descriptive
approach
combined
with
a
gradual,
detailed,
and
comprehensive presentation of basic concepts. The principles of combinational and
sequential logic are presented, as well as the underlying techniques for the analysis and
design of digital circuits. The analysis and design of digital circuits with increasing
complexity is facilitated by the use of abstractions at the circuit and architecture levels.
This work consists of three volumes devoted to the following subjects:
1) combinational logic circuits;
2) sequential and arithmetic logic circuits;
3) Ô¨Ånite state machines.
A progressive approach has been chosen and the chapters are relatively
independent of each other. To help master the subject matter and put into practice the
different concepts and techniques, topics are complemented by a selection of
exercises with solutions.

x
Digital Electronics 2
P.1. Summary
Volume 2 deals with sequential circuits and arithmetic and logic circuits. The logic
state of the output of a sequential logic circuit can depend, at any given time, on the
inputs but also on the previous logic state of the outputs. Depending on whether a
clock signal is used to synchronize the output state change or not, a sequential circuit
is said to be synchronous or asynchronous. Arithmetic circuits can be used to perform
addition, subtraction, multiplication and division operations on digital data. Volume 2
contains the following seven chapters:
1) Latch and Flip-Ô¨Çop;
2) Binary Counters;
3) Shift Registers;
4) Arithmetic and Logic Circuits;
5) Digital Integrated Circuit Technology;
6) Semiconductor Memory;
7) Programmable Logic Circuits.
P.2. The reader
This work is an indispensable tool for all engineering students on a bachelors or
masters course who wish to acquire detailed and practical knowledge of digital
electronics. It is detailed enough to serve as a reference for electronic, automation
and computer engineers.
Tertulien NDJOUNTCHE
June 2016

1
Latch and Flip-Flop
1.1. Introduction
A latch or Ô¨Çip-Ô¨Çop is a bistable circuit that is most often used in applications that
require data storage. Its chief characteristic is that the output is not dependent solely
on the present state of the input but also on the preceding output state. A bistable
circuit has two complementary outputs that can assume either of the two logic levels
0 or 1.
There are several common types of latches and Ô¨Çip-Ô¨Çops. Latches often have no
dedicated input for the clock signal. They can be combined to implement
level-triggered and edge-triggered Ô¨Çip-Ô¨Çops. Flip-Ô¨Çops can be triggered by one of the
levels or one of the edges of a clock signal (or a digital signal).
1.2. General overview
A simple latch can be implemented using two NOR or two NAND logic gates.
A NOR gate based latch with initial conditions speciÔ¨Åed is represented in
Figure 1.1(a). The characteristic equation for each of the outputs is determined by
assuming that the logic gates have different propagation times1 and this may be
modeled as for a delay, Œî, between a signal that becomes available at the output and
the feedback signal applied to the input. In this way, the logic circuit of the latch, as
illustrated in Figure 1.1(b), may be transformed as shown in Figures 1.1(c)
and 1.1(d).
1 Propagation delays in logic gates are assumed to take the form 1 and 1 + Œî, respectively.
Digital Electronics 2: Sequential and Arithmetic Logic Circuits, First Edition. Tertulien Ndjountche. 
¬© ISTE Ltd 2016. Published by ISTE Ltd and John Wiley & Sons, Inc. 

2
Digital Electronics 2
(c)


(d)
X
A
B
Y
X+
(b)
B
X
A
Y
Y+
A
B
Y
X
(a)
0
1
0
0
A
B
Y
X
Figure 1.1. a) NOR gate based latch with initial conditions speciÔ¨Åed; b)
logic circuit for the latch and representations useful for the
determination of c) Y + and d) X+
Referring to Figure 1.1(c), we can write:
X = B + Y
[1.1]
Y + = A + X
[1.2]
Substituting [1.1] into [1.2] yields:
Y + = A + B + Y
[1.3]
= A ¬∑ B + Y
= A ¬∑ (B + Y )
= A ¬∑ B + A ¬∑ Y
[1.4]
Similarly, the circuit shown in Figure 1.1(d) can be characterized using the
following logic equations:
X+ = B + Y
[1.5]
Y = A + X
[1.6]
By substituting [1.5] into [1.6], we have:
X+ = B + A + X
[1.7]
= B ¬∑ A + X
= B ¬∑ (A + X)
= A ¬∑ B + B ¬∑ X
[1.8]

Latch and Flip-Flop
3
The characteristic equations of the NOR gate based latch are, thus, given by:
X+ = A ¬∑ B + B ¬∑ X
[1.9]
and
Y + = A ¬∑ B + A ¬∑ Y
[1.10]
A
B
X
X+
Y +
0
0
0
0
1
0
0
1
1
0
0
1
0
1
0
0
1
1
1
0
1
0
0
0
1
1
0
1
0
1
1
1
0
0
0
1
1
1
0
0
Table 1.1. State table of the NOR gate based latch
For each output, the next state, X+ or Y +, depends on the present state, X or Y .
In addition to the characteristic equations, the initial conditions must be speciÔ¨Åed to
determine the operation of the latch. Table 1.1 gives the state table for the latch.
It must be noted that the two signals, X+ and Y +, are complementary except when
both inputs, A and B, are set to 1.
Additionally, if the inputs A and B are simultaneously set to 0, the outputs can
no longer be deÔ¨Åned in a unique manner as the characteristic equations are veriÔ¨Åed
by (X, Y ) = (1, 0) or by (X, Y ) = (0, 1). It is therefore impossible to predict the
combination of the states held by the outputs.
In practice, sequential circuits are most often made to operate in the fundamental
mode. This means that only one input can change states at any time. On the other
hand, because of the difference in propagation delays between the logic gates, it is
impossible to guarantee a simultaneous change in the state of two variables. Thus,
the outputs of the latch are deÔ¨Åned by (X, Y ) = (0, 1) when A is Ô¨Årst set to 0 or
by (X, Y ) = (1, 0) when B is Ô¨Årst set to 0. In this case, the Ô¨Ånal state of the circuit
is determined by the transient behavior, which depends on the order in which the
state changes of the inputs take place. In general, if shifting from one state to another
requires a change in at least two state variables, then a race condition will occur.

4
Digital Electronics 2
The race is said to be non-critical if the order in which the variables change state
does not affect the Ô¨Ånal state of the circuit.
If, on the contrary, the circuit can assume two or more stable states depending on
the order in which the variables change state, the race is said to be critical.
B
(b)
(d)
Y
X+
X
X
Y+
Y
X
Y
(c)
1
1
0
1
(a)
B
A
B
B
A
A
A


X
Y
Figure 1.2. a) NAND gate based latch with initial conditions speciÔ¨Åed;
b) logic circuit of the latch and representations useful for the
determination of c) X+ and d) Y +
A NAND gate based latch with initial conditions speciÔ¨Åed is illustrated in
Figure 1.2(a). Taking into account the fact that the differences in propagation delay
of the two logic gates may translate into a delay, Œî, between an output and the
feedback input, an equivalence may be established between the latch in Figure 1.2(b)
and each representation shown in Figures 1.2(c) and 1.2(d).
The following logic equations may be derived based on the circuit shown in
Figure 1.2(c):
X+ = A ¬∑ Y
[1.11]
Y = B ¬∑ X
[1.12]
By substituting [1.12] into [1.11], we obtain:
X+ = A ¬∑ B ¬∑ X
[1.13]
= A + B ¬∑ X
= A + B ¬∑ X
[1.14]

Latch and Flip-Flop
5
In the case of the circuit shown in Figure 1.2(d), the logic equations are written as
follows:
X = A ¬∑ Y
[1.15]
Y + = B ¬∑ X
[1.16]
Substituting [1.15] into [1.16], we obtain:
Y + = B ¬∑ A ¬∑ Y
[1.17]
= B + A ¬∑ Y
= B + A ¬∑ Y
[1.18]
The characteristic equations of the NAND gate based latch are therefore in the
following form:
X+ = A + B ¬∑ X
[1.19]
and
Y + = B + A ¬∑ Y
[1.20]
A
B
X
X+
Y +
1
1
1
1
0
1
1
0
0
1
1
0
1
0
1
1
0
0
0
1
0
1
1
1
0
0
1
0
1
0
0
0
1
1
1
0
0
0
1
1
Table 1.2. State table of the NAND gate based latch
The state table of the NAND gate based latch may be constructed, as shown in
Table 1.2, based on characteristic equations and initial conditions.
We can see that the signals X+ and Y + are complementary except when the two
inputs A and B are set at 0.
In addition, the signals X+ and Y + are only deÔ¨Åned uniquely when the inputs A
and B cannot change states from 0 to 1 simultaneously. Thus, the outputs of the latch

6
Digital Electronics 2
are deÔ¨Åned by (X, Y ) = (0, 1) if the input A is Ô¨Årst set to 1 or by (X, Y ) = (1, 0) if
the input B is Ô¨Årst set to 1. In this case, as the Ô¨Ånal state depends on the order in which
the inputs change states, we have a critical race condition.
Among the combinations of states that the outputs of the latch can take, only those
for which X+ = X and Y + = Y are said to be stable.
1.2.1. SR latch
For the SR latch (S stands for set, and R for reset) represented in Figure 1.3, we
can obtain the characteristic equations from equations [1.9] and [1.10], as follow:
Q+ = R ¬∑ S + R ¬∑ Q = R ¬∑ (S + Q)
[1.21]
and:
Q+ = S ¬∑ R + S ¬∑ Q = S ¬∑ (R + Q)
[1.22]
It must be noted that complementing Q+ does not yield Q+. The state table is
given in Table 1.3.
Q
Q
Q
S
R
(a)
(b)
S
R
Q
Figure 1.3. SR latch: a) logic circuit; b) symbol
S
R
Q
Q+
Q+
0
0
0
0
1
0
0
1
1
0
0
1
0
0
1
0
1
1
0
1
1
0
0
1
0
1
0
1
1
0
1
1
0
0
0
1
1
1
0
0
Table 1.3. State table of the SR latch

Latch and Flip-Flop
7
S
R
Q+
Q+
0
0
Q
Q
No change
0
1
0
1
Reset Q+ to 0
1
0
1
0
Set Q+ to 1
1
1
0
0
Forbidden state
Table 1.4. Truth table of the SR latch
An SR latch whose initial condition is speciÔ¨Åed can also be characterized using the
truth table shown in Table 1.4. The SR latch is said to be reset-dominant 0, as setting
both inputs to 1 causes the output Q to change to 0.
forbidden state
Q
Q
R
S
Figure 1.4. Timing diagram for the SR latch
Figure 1.4 shows the timing diagram of the SR latch where the different operating
modes that appear in the truth table can be observed.
S
R
Q
Q+
0
0
0
0
0
0
1
1
0
1
0
0
0
1
1
0
1
0
0
1
1
0
1
1
1
1
0
x
1
1
1
x
Table 1.5. SR latch state table with do not care states
However, if the forbidden state (S = R = 1) is considered as a do not care state,
the state table takes the form given in Table 1.5. Constructing a Karnaugh map, as

8
Digital Electronics 2
shown in Figure 1.5, we obtain another version of the characteristic equation given
by:
Q+ = S + Q ¬∑ R
and
S ¬∑ R = 0
[1.23]
Q
SR
00
01
11
10
S
0
R
1
1
6
7
x
1
x
1
0
0
0
0
1
2
3
4
5
Q
Figure 1.5. Karnaugh map for the SR latch. For a color version of this
Ô¨Ågure, see www.iste.co.uk/ndjountche/electronics2.zip
This last equation is used for applications where neither of the inputs S and R can
take the state 1.
When a transition requires a change in state for at least two variables, an analysis
based on Karnaugh maps, as shown in Figure 1.6, is necessary to detect the critical
race conditions.
Q
SR
00
01
11
10
S
0
R
1
1
6
7
0
1
0
1
0
0
0
0
1
2
3
4
5
(a)
11
01
S changes first
00
11
10
R changes first
00
SR
00
01
11
10
S
0
R
1
1
6
7
0
1
0
1
0
0
0
0
1
2
3
4
5
(b)
10
00
S changes first
01
10
11
R changes first
01
Q
Q
Q
Figure 1.6. Karnaugh map: a) critical race; b) non-critical race.
For a color version of this Ô¨Ågure, see
www.iste.co.uk/ndjountche/electronics2.zip

Latch and Flip-Flop
9
Let us consider that from the initial state, where S = 1, R = 1, and Q = 0, and
which corresponds to the cell 6 in the Karnaugh map of Figure 1.6(a), both inputs S
and R must be reset to zero.
The state of the input S can change before that of the input R, or vice versa.
The arrows entered in the Karnaugh map are used to illustrate the response of the
latch in each case.
In SR terms, the transition 11 ‚Üí01 ‚Üí00 is produced, and the output is
maintained at the Ô¨Ånal state Q+ = 0, corresponding to cell 0, if the input S changes
Ô¨Årst. However, if the input R changes Ô¨Årst, the transition will be 11 ‚Üí10 ‚Üí00, and
the Ô¨Ånal state of the output is then Q+ = 1, corresponding to cell 1.
In the case of Figure 1.6(b), the Ô¨Çip-Ô¨Çop is initially characterized by S = 1, R = 0
and Q = 1; this corresponds to the cell 5 in the Karnaugh map.
As a result of the possible transitions, 10 ‚Üí00 ‚Üí01 when S changes Ô¨Årst, or
10 ‚Üí11 ‚Üí01 when R changes Ô¨Årst, the output takes the same Ô¨Ånal state, Q+ = 0,
corresponding to cells 3 or 2. This corresponds to a non-critical race condition.
We can verify that the only critical race condition in an SR latch occurs when the
inputs S and R that are initially set to 1 are reset to 0.
1.2.2. S R latch
An S R latch can be implemented using NAND gates, as shown in Figure 1.7(a).
Its symbol is represented in Figure 1.7(b). Based on the truth table shown in Table 1.6,
we can note that the inputs are activated by low-level signals. The S R latch is said to
be set-dominant 1, as setting both inputs to 1 changes the output Q to 1.
(b)
Q
Q
S
R
(a)
Q
Q
S
R
Figure 1.7. S R latch: a) logic circuit; b) symbol
The effect of a race condition on the operation of the latch can be analyzed using
a Karnaugh map.

10
Digital Electronics 2
S
R
Q+
Q+
1
1
Q
Q
No change
1
0
0
1
Reset Q+ to 0
0
1
1
0
Set Q+ to 1
0
0
1
1
Forbidden state
Table 1.6. Truth table of the S R latch
By referring to Figure 1.8(a), we can see that the Ô¨Çip-Ô¨Çop is initially characterized
by S = 0 and R = 0, and Q = 1 (cell 1). The transition of the inputs S and R
to 1 involves a change in two state variables. If, due to the difference in propagation
delays, the input S changes Ô¨Årst, this translates to the transitions, 00 ‚Üí10 ‚Üí11,
and the Ô¨Ånal state of the output is Q+ = 0 (cell 6). If, on the other hand, the input R
changes Ô¨Årst, the latch follows the transitions, 00 ‚Üí01 ‚Üí11, and the output takes
the Ô¨Ånal state Q+ = 1 (cell 7). This is a critical race condition because the Ô¨Ånal state
of the outputs depends on the order in which the variables change.
R changes first
S
R
R
S
S R
S R
00
01
11
10
0
1
1
6
7
0
0
1
0
1
1
1
0
1
2
3
4
5
(a)
10
11
00
01
11
10
0
1
6
7
0
0
1
0
1
1
1
0
1
2
3
4
5
(b)
Q
Q
Q
Q
00
1
10
00
01
10
11
01
S changes first
01
11
00
S changes first
R changes first
Figure 1.8. Karnaugh map: a) critical race; b) non-critical race.
For a color version of this Ô¨Ågure, see
www.iste.co.uk/ndjountche/electronics2.zip
An example of a non-critical race condition is illustrated by the Karnaugh map, as
shown in Figure 1.8(b). Starting from the state S = 1 and R = 0, and Q = 0 (cell 4),
the inputs S and R must be set to 0 and 1, respectively. The two possible transitions
10 ‚Üí00 ‚Üí01 (input S changes Ô¨Årst) and 10 ‚Üí11 ‚Üí01 (input R changes Ô¨Årst)
lead to the same Ô¨Ånal state for the output, Q+ = 1 (cell 3 or 2).
For the S R latch, the only critical race condition occurs when both inputs S and
R move from 0 to 1.

Latch and Flip-Flop
11
1.2.3. Application: switch debouncing
Contact bounces of a push-button switch (see Figure 1.9) during its closing or
opening can be eliminated using a S R latch, as shown in Figure 1.10, where VCC
represents the supply voltage and RP is the polarization resistor.
Bounces
CC
VCC
Tension
Time
t
0
To oscilloscope
Triggering
V
Figure 1.9. Waveform illustrating switch contact bounces
VCC
RP
RP
Q
R
S
(b)
(a)
S
R
Q
Q
Figure 1.10. Debouncing switch
When R = 0, the output Q of the latch is set to 1 as soon as the signal S reaches
the logic level 1 for the Ô¨Årst time. Subsequent Ô¨Çuctuations at the input S no longer
affect the state of Q. Similarly, when S is at 0, the output Q is reset to 0 following the
Ô¨Årst transition attributing the logic level 1 to R.
1.3. Gated SR latch
A gated or level-sensitive SR latch uses a control signal C that can be a clock
signal. The signal C is used to enable (or inhibit) the latch at speciÔ¨Åc time intervals.

12
Digital Electronics 2
1.3.1. Implementation based on an SR latch
The gated SR latch in Figure 1.11(a) is made up of two AND gates and an SR
latch. It is represented by the symbol shown in Figure 1.11(b). It can be characterized
by equations of the form:
X+ = A ¬∑ B + B ¬∑ X
[1.24]
and
Y + = A ¬∑ B + A ¬∑ Y
[1.25]
where:
A = RC,
B = SC,
X = Q,
X+ = Q+,
Y = Q,
and
Y + = Q+
[1.26]
(b)
Q
Q
R
Q
C
Q
S
S
R
C
(a)
Figure 1.11. Gated SR latch based on an SR latch:
a) logic circuit; b) symbol
The characteristic equations are, thus, given by:
Q+ = S ¬∑ C ¬∑ (R ¬∑ C) + (R ¬∑ C) ¬∑ Q
= R ¬∑ S ¬∑ C + (R + C) ¬∑ Q
[1.27]
and
Q+ = (S ¬∑ C) ¬∑ R ¬∑ C + (S ¬∑ C) ¬∑ Q
= R ¬∑ S ¬∑ C + (S + C) ¬∑ Q
[1.28]
‚Äì If C = 0, we have Q+ = Q and Q+ = Q.
‚Äì If C = 1, we have Q+ = R ¬∑ (S + Q) and Q+ = S ¬∑ (R + Q).

Latch and Flip-Flop
13
Table 1.7 presents the state table of the gated SR latch based on an SR latch. The
truth table can be constructed as shown in Table 1.8. An example of the timing diagram
is illustrated in Figure 1.12, for the case where Q = 0 and Q = 1 initially.
C
S
R
Q
Q+
Q+
0
x
x
0
0
1
0
x
x
1
1
0
1
0
0
0
0
1
1
0
0
1
1
0
1
0
1
x
0
1
1
1
0
x
1
0
1
1
1
x
0
0
Table 1.7. State table of the gated SR latch based on an SR latch
C
S
R
Q+
Q+
0
x
x
Q
Q
No change
1
0
0
Q
Q
1
0
1
0
1
Reset
1
1
0
1
0
Set
1
1
1
0
0
Forbidden state
Table 1.8. Truth table of the gated SR latch based on an SR latch
forbidden state
S
R
C
Q
Q
Figure 1.12. Timing diagram of the gated SR latch

14
Digital Electronics 2
1.3.2. Implementation based on an S R latch
Another version of the gated SR latch, whose logic circuit and symbol are given in
Figures 1.13(a) and 1.13(b), is implemented using two NAND gates and an S R latch.
By performing its analysis, the following equations can be derived:
X+ = A + B ¬∑ X
[1.29]
and:
Y + = B + A ¬∑ Y
[1.30]
where:
A = S ¬∑ C, B = R ¬∑ C, X = Q, X+ = Q+, Y = Q, and Y + = Q+
[1.31]
and Ô¨Ånally we have:
Q+ = S ¬∑ C + (R + C) ¬∑ Q
[1.32]
and:
Q+ = R ¬∑ C + (S + C) ¬∑ Q
[1.33]
(b)
R
Q
C
Q
S
R
S
C
Q
Q
(a)
Figure 1.13. Gated SR latch based on an S R latch:
a) logic circuit; b) symbol
The truth table of the gated SR latch based on an S R latch can, therefore, be
constructed as shown in Table 1.9.

Latch and Flip-Flop
15
C
S
R
Q+
Q+
0
x
x
Q
Q
No change
1
0
0
Q
Q
1
0
1
0
1
Reset
1
1
0
1
0
Set
1
1
1
1
1
Forbidden state
Table 1.9. Truth table of the gated SR latch based on an S R latch
(c)
C
D
Q
Q
(b)
C
D
(a)
Q
Q
R
Q
C
Q
S
D
C
Figure 1.14. Gated D latch: a) and b) logic circuits; c) symbol
1.4. Gated D latch
A gated D latch (D stands for data) can be implemented from a gated SR latch, as
shown in Figure 1.14. Connecting an inverter between the S and R inputs prevents the
forbidden state from occurring. By inserting the expressions:
R = D
and
S = D
[1.34]
in any of the following two characteristic equations of the gated SR latches:
Q+ = R ¬∑ S ¬∑ C + (R + C) ¬∑ Q
[1.35]
and
Q+ = S ¬∑ C + (R + C) ¬∑ Q
[1.36]
we obtain, for the gated D latch, the same characteristic equation, given by:
Q+ = D ¬∑ C + D ¬∑ Q + C ¬∑ Q
= D ¬∑ C ¬∑ (Q + Q) + D ¬∑ (C + C) ¬∑ Q + (D + D) ¬∑ C ¬∑ Q
= D ¬∑ C ¬∑ (Q + Q) + C ¬∑ Q ¬∑ (D + D)
= D ¬∑ C + C ¬∑ Q
[1.37]

16
Digital Electronics 2
‚Äì If C = 1, the characteristic equation becomes Q+ = D.
‚Äì If C = 0, we have Q+ = Q.
With a gated D latch, the state of the input D is transferred to the output when the
control (or enable) input C is set to 1, while the state of the output does not change
when the control input is reset to 0; this translates into a characteristic equation of the
form:
Q+ = D ¬∑ C + C ¬∑ Q
[1.38]
The gated D latch is thus said to be transparent when C = 1. It is, therefore,
sensitive to the high level of the signal applied at the input C.
Figure 1.15 shows the symbol of a gated D latch. The truth table of a gated D latch
is represented in Table 1.10, where the outputs Q+ and Q+ are complementary. An
example of the timing diagram for the D latch is given in Figure 1.16, where the output
Q is initially set to 0.
Q
C
Q
D
Figure 1.15. Symbol of the gated D latch
C
D
Q+
Q+
0
x
Q
Q
No change
1
0
0
1
Reset
1
1
1
0
Set
Table 1.10. Truth table of the gated D latch
1.5. Basic JK Ô¨Çip-Ô¨Çop
The JK Ô¨Çip-Ô¨Çop (J as a set input, and K as a reset input) is the most versatile of the
basic Ô¨Çip-Ô¨Çops. When it is activated, it permits the storage of a binary data based on the
combination of states taken by the inputs J and K. A JK Ô¨Çip-Ô¨Çop can be implemented

Latch and Flip-Flop
17
by using the logic circuit given in Figure 1.17(a). It is symbolically represented as
shown in Figure 1.17(b). From the logic circuit of the JK Ô¨Çip-Ô¨Çop, we can obtain:
S = J ¬∑ C ¬∑ Q
and
R = K ¬∑ C ¬∑ Q
[1.39]
D
C
Q
Figure 1.16. Timing diagram for the gated D latch
J
Q
R
Q
S
J
K
C
(a)
(b)
C
Q
K
Q
Figure 1.17. Basic JK Ô¨Çip-Ô¨Çop: a) logic circuit; b) symbol
By inserting these last expressions in the characteristic equation of the gated SR
latch:
Q+ = R ¬∑ (S + Q)
[1.40]
we get
Q+ = (K ¬∑ C ¬∑ Q) ¬∑ (J ¬∑ C ¬∑ Q + Q)
= (K + C + Q) ¬∑ (J ¬∑ C + Q)
= J ¬∑ K ¬∑ C + J ¬∑ Q ¬∑ C + K ¬∑ Q + Q ¬∑ C
= (1 + J ¬∑ C) ¬∑ K ¬∑ Q + (1 + K) ¬∑ J ¬∑ Q ¬∑ C + Q ¬∑ C
= J ¬∑ Q ¬∑ C + (K + C) ¬∑ Q
[1.41]
‚Äì if C = 1, the characteristic equation takes the form Q+ = J ¬∑ Q + K ¬∑ Q;

18
Digital Electronics 2
‚Äì if C = 0, we have Q+ = Q.
The state table of the basic JK Ô¨Çip-Ô¨Çop can be constructed as shown in Table 1.11.
The forbidden state, inherent to the SR latch, is eliminated by adding two feedback
pathways in order to ensure that the output will be set to 1 only if Q = 0 and reset to
0 only if Q = 1. Table 1.12 presents the truth table of the basic JK Ô¨Çip-Ô¨Çop, where the
outputs Q+ and Q+ are complementary.
C
J
K
Q
Q+
0
x
x
x
Q
1
0
0
0
0
1
0
0
1
1
1
0
1
0
0
1
0
1
1
0
1
1
0
0
1
1
1
0
1
1
1
1
1
0
1
1
1
1
1
0
Table 1.11. State table for the JK Ô¨Çip-Ô¨Çop
C
J
K
Q+
Q+
0
x
x
Q
Q
No change
1
0
0
Q
Q
1
0
1
0
1
Reset
1
1
0
1
0
Set
1
1
1
Q
Q
Toggle
Table 1.12. Truth table of the basic JK Ô¨Çip-Ô¨Çop
It must be noted that this JK Ô¨Çip-Ô¨Çop structure may be affected by undesirable
oscillations. In fact, when the two inputs J and K are set at 1 and the clock signal
changes to 1, the feedback of the values Q and Q taken by the outputs forces the
Ô¨Çip-Ô¨Çop to toggle (or to switch from one state to its logical complement). And if the
clock signal is still at the logic state 1, the process recommences and the Ô¨Çip-Ô¨Çop again
changes state. To ensure smooth operation, the pulse width of the clock signal must
be smaller than the propagation delay of the Ô¨Çip-Ô¨Çop.
1.6. T Ô¨Çip-Ô¨Çop
A JK Ô¨Çip-Ô¨Çop can be transformed into a T Ô¨Çip-Ô¨Çop (T stands for toggle), as shown
in Figure 1.18. When the T Ô¨Çip-Ô¨Çop is activated, its outputs change state every time a

Latch and Flip-Flop
19
pulse is applied to the input T. The characteristic equation of the JK Ô¨Çip-Ô¨Çop is given
by:
Q+ = J ¬∑ Q ¬∑ C + (K + C) ¬∑ Q
[1.42]
Q
C
Q
K
Q
J
T
C
(b)
(a)
Q
T
C
Figure 1.18. T Ô¨Çip-Ô¨Çop: a) logic circuit; b) symbol
Assuming that J = K = T, we obtain the characteristic equation of the T Ô¨Çip-
Ô¨Çop:
Q+ = T ¬∑ Q ¬∑ C + (T + C) ¬∑ Q
[1.43]
‚Äì if C = 1, the characteristic equation is reduced to Q+ = T ¬∑Q+T ¬∑Q = T ‚äïQ;
‚Äì if C = 0, we have Q+ = Q.
Table 1.13 shows the state table of the T Ô¨Çip-Ô¨Çop. As the outputs Q+ and Q+
are complementary, the truth table for the T Ô¨Çip-Ô¨Çop can be constructed as shown in
Table 1.14.
C
T
Q
Q+
0
x
x
Q
1
0
0
0
1
0
1
1
1
1
0
1
1
1
1
0
Table 1.13. State table of the T Ô¨Çip-Ô¨Çop
C
T
Q+
Q+
0
x
Q
Q
No change
1
0
Q
Q
1
1
Q
Q
Toggle
Table 1.14. Truth table of the T Ô¨Çip-Ô¨Çop

20
Digital Electronics 2
1.7. Master-slave and edge-triggered Ô¨Çip-Ô¨Çop
The operation of circuits implemented by coupling level-triggered Ô¨Çip-Ô¨Çops may
become unpredictable, as the signal state can propagate from the output of one Ô¨Çip-
Ô¨Çop to another as long as the clock signal is activated, thus preventing data storage.
One solution to this problem consists of using master-slave or edge-triggered Ô¨Çip-
Ô¨Çops. This is implemented by memorizing only those state changes that occur on
receiving one of the edges of the clock signal as illustrated in Figure 1.19.
edge

T
edge
Rising
Falling
Figure 1.19. Clock signal (œÑ: pulse width; T: signal period)
1.7.1. Master-slave Ô¨Çip-Ô¨Çop
A Master-slave type Ô¨Çip-Ô¨Çop is implemented by connecting two Ô¨Çip-Ô¨Çops, called
master and slave, whose clock signals are complementary.
1.7.1.1. Master-slave D Ô¨Çip-Ô¨Çop
An edge-triggered D Ô¨Çip-Ô¨Çop can be implemented using a master-slave structure
that is composed of two gated D latches (see Figures 1.20 and 1.22).
Slave
Q
Q
D
Q
Q
D
C
C
Qx
CK
D
Master
Q
Q
D
(a)
(b)
Figure 1.20. Master-slave D Ô¨Çip-Ô¨Çop triggered by the clock signal rising
edge: a) logic circuit; b) symbol

Latch and Flip-Flop
21
Q
Qx
D
CK
Figure 1.21. Timing diagram of a master-slave D Ô¨Çip-Ô¨Çop
triggered by the clock signal rising edge
Slave
Q
Q
D
(b)
Q
Q
D
Q
Q
D
C
C
D
Master
CK
(a)
Figure 1.22. Master-slave D Ô¨Çip-Ô¨Çop triggered by the
clock signal falling edge: a) logic circuit; b) symbol
The master latch (or Ô¨Årst latch) remains sensitive to changes in the input logic
state as long as it is activated by the clock signal, but the output of the slave latch
(or the second latch) only changes at the edges of the clock signal, when the master
latch becomes deactivated and its state can no longer change. Thus, the output of the
master-slave Ô¨Çip-Ô¨Çop only reÔ¨Çects the input logic state when the clock signal goes
from high to low or vice versa.
Figures 1.20(a) and 1.20(b) show the logic circuit and symbol, respectively, for a
D Ô¨Çip-Ô¨Çop triggered by the rising edge of the clock signal (or positive-edge-triggered
D Ô¨Çip-Ô¨Çop). Table 1.15 gives the truth table. Figure 1.21 shows the timing diagram
for a D Ô¨Çip-Ô¨Çop triggered by the rising edge of the clock signal.
In the case of the D Ô¨Çip-Ô¨Çop triggered by the falling edge of the clock signal (or
negative-edge-triggered D Ô¨Çip-Ô¨Çop), the logic circuit and symbol are as represented in
Figures 1.22(a) and 1.22(b), respectively. The truth table is given in Table 1.16.

22
Digital Electronics 2
0
x
x
1
0
CK
1
0
0
1
Q+
Q
Q
Q
Q
Q+
1
D
Table 1.15. Truth table
0
D
CK
x
1
x
0
1
0
0
1
Q+
Q
Q
Q
Q
Q+
1
Table 1.16. Truth table
1.7.1.2. JK master-slave Ô¨Çip-Ô¨Çop
A JK master-slave Ô¨Çip-Ô¨Çop can be described using the logic circuit and symbol
represented in Figures 1.23(a) and 1.23(b), respectively, while its operation is
characterized by the truth table given in Table 1.17.
0
Q
Q
Q
Q+
CK
0
Q
0
J
x
1
0
K
x
0
1
1
1
1
Q
0
0
+
Q
Q
1
Table 1.17. Truth table

Latch and Flip-Flop
23
Master
Q
R
Q
S
Q
R
Q
S
Qy
Qx
CK
K
J
(a)
Q
K
Q
J
CK
(b)
Slave
Figure 1.23. JK master-slave Ô¨Çip-Ô¨Çop: a) logic circuit; b) symbol
When the master Ô¨Çip-Ô¨Çop is activated, its output logic state is determined not only
by the inputs J and K, but also by the outputs, Q and Q, of the slave Ô¨Çip-Ô¨Çop. The
master Ô¨Çip-Ô¨Çop state is then transferred to the slave Ô¨Çip-Ô¨Çop only when the clock signal
transitions from high to low (falling edge).
Thus, to ensure the normal operation of the JK master-slave Ô¨Çip-Ô¨Çop, the logic state
taken by each input, J and K, must not change when the master Ô¨Çip-Ô¨Çop is activated
(or the clock signal CK is set to 1). If this condition is not satisÔ¨Åed, the outputs of the
JK master-slave Ô¨Çip-Ô¨Çop may be affected by the undesirable catching of a logic state
1 or 0 by the master Ô¨Çip-Ô¨Çop:
‚Äì when the output Q of the slave Ô¨Çip-Ô¨Çop is at 0, the transition from 0 to 1 of the
input J when CK = 1 results in the master Ô¨Çip-Ô¨Çop output being set at 1, and the
slave Ô¨Çip-Ô¨Çop output can then be set to 1 when CK goes from 1 to 0. Once the master
Ô¨Çip-Ô¨Çop is set to 1 following a change to 1 in the input J, a subsequent assignment
of 1 to the input K when CK = 1 cannot bring the master Ô¨Çip-Ô¨Çop output back to 0.
This is because the slave Ô¨Çip-Ô¨Çop remains in the same state until the clock signal, CK,
again changes to 0 and the feedback signal Q = 0 keeps the input K deactivated. This
behavior is known as 1s catching;
‚Äì in the case where the slave Ô¨Çip-Ô¨Çop output is at 1 and a transient disturbance
forces the input K to change to 1 while CK = 1, the master Ô¨Çip-Ô¨Çop acquires this
reset condition, which is then transferred to the slave Ô¨Çip-Ô¨Çop when the clock signal
CK goes from 1 to 0. It must be noted that K subsequently changing to 1 while
CK = 1 has no effect on the master Ô¨Çip-Ô¨Çop that can only be set to 1 by a high-going
pulse at the input J, which is actually deactivated by the feedback signal Q = 0. This
phenomenon is called 0s catching.

24
Digital Electronics 2
The JK master-slave Ô¨Çip-Ô¨Çop can be considered to be level triggered. The symbol
‚åâis used in Figure 1.23(b) to indicate that the outputs of the JK master-slave Ô¨Çip-Ô¨Çop
only reÔ¨Çect the state of the J and K inputs at the end of the pulse of the clock signal
CK.
The truth table (see Table 1.17) is constructed assuming that the input signals J
and K remain constant while the clock signal is set to 1 and, thus, does not take into
account the 1s catching and 0s catching problem.
Figure 1.24 shows a timing diagram showing a 1s catching and 0s catching in a JK
master-slave Ô¨Çip-Ô¨Çop.
0¬¥s Catching
K
J
CK
Qy
Qx
Q
Q
1
0
1
0
0
1
0
1
1
‚àí
‚àí
0
1
‚àí
0
‚àí
Normal operation
1¬¥s Catching
Figure 1.24. Timing diagram for the JK master-slave Ô¨Çip-Ô¨Çop
(illustration of 1s and 0s catching). For a color version of this Ô¨Ågure, see
www.iste.co.uk/ndjountche/electronics2.zip
1.7.2. Edge-triggered Ô¨Çip-Ô¨Çop
An edge-triggered Ô¨Çip-Ô¨Çop is designed so as to ensure that the output can only
change at the rising or falling edge of the clock signal and remains constant between
two consecutive edges.
1.7.2.1. Principle of edge detection
Even though the circuits shown in Figure 1.25 are not exactly the same as those
found in integrated Ô¨Çip-Ô¨Çops, they clearly demonstrate the detection principle of the
edge of a signal.
The propagation delay caused by an inverter is exploited to generate a signal with
a very small width during any transition of the clock signal.

Latch and Flip-Flop
25
edge
CK
Rising
(a)
FA
FD
CK
CK
CK
FA
(b)
CK
FD
CK
CK
edge
Falling
Figure 1.25. Principle for detecting a) the rising edge
and b) falling edge
1.7.2.2. Edge-triggered D Ô¨Çip-Ô¨Çop
In an edge-triggered D Ô¨Çip-Ô¨Çop, the detection of the clock signal transition in a
given direction can be carried out by making use of the fact that the change in state
(set, reset) of an SR or S R latch occurs only when the logic states of both inputs
change. Thus, the state acquired by a latch after a clock signal transition occurs at
one of the inputs while the other input is set to 1 or reset to 0; it cannot change only
because of subsequent changes in the logic state of the clock signal.
Flip-Ô¨Çops can be triggered by the rising edge or the falling edge of the clock signal.
D Ô¨Çip-Ô¨Çop triggered by the clock signal rising edge
A D Ô¨Çip-Ô¨Çop triggered by the rising edge of the clock signal can be implemented
using S R latches, as illustrated in Figure 1.26(a). The input signal D and the clock
signal CK are applied to the input stage that generates the signal required by the
output stage to determine the outputs Q and Q. When the clock signal goes from 0 to
1, the state (0 or 1) of the input D is converted by the input stage in a (S R) = (10)
or (01) combination that results in the output stage being reset to 0 or set to 1. For
other states that can be taken by the clock signal, the combination (S R) = (11) is
generated by the input stage regardless of the value on the D input. This forces the
output stage to maintain its logic level unchanged.
A triangle is placed at the clock signal input, as shown by the symbol in
Figure 1.26(b), to indicate that the Ô¨Çip-Ô¨Çop is active on the rising edge of the clock
signal. Table 1.18 gives the truth table.
Flip-Ô¨Çop triggered by the clock signal falling edge
Similarly, a D Ô¨Çip-Ô¨Çop triggered by the falling edge of the clock signal can be
implemented using SR latches, as shown in Figure 1.27(a). Depending on whether the
D input state is 0 or 1 the input stage generates, in response to a falling edge of the
clock signal CK, the combination (SR) = (01) or (10) that sets the output stage to
1 or resets the output stage to 0. For the other states that can be taken by the clock

26
Digital Electronics 2
signal, the input stage produces the combination (SR) = (00) and the output stage
holds its previous state.
(b)
D
CK
(a)
Q
Q
S
R
Q
Q
D
Figure 1.26. D Ô¨Çip-Ô¨Çop triggered by the clock signal rising edge:
a) logic circuit; b) symbol
0
D
CK
x
1
x
0
1
0
Q+
Q
Q
Q
Q
Q+
0
1
1
Table 1.18. Truth table of the Ô¨Çip-Ô¨Çop
Referring to the symbol shown in Figure 1.27(b), a circle is placed before the
triangle at the clock signal input to indicate that the Ô¨Çip-Ô¨Çop is activated by the clock
signal falling edge. The truth table is represented in Table 1.19.
APPLICATION.‚Äì Implementation of a JK and T Ô¨Çip-Ô¨Çops using a D Ô¨Çip-Ô¨Çop

Latch and Flip-Flop
27
(b)
D
CK
S
R
(a)
Q
Q
Q
Q
D
Figure 1.27. D Ô¨Çip-Ô¨Çop triggered by the clock signal falling edge:
a) logic circuit; b) symbol
+
D
CK
x
1
x
0
1
0
Q
Q
Q
Q
Q
Q+
0
1
1
0
Table 1.19. Truth table of the Ô¨Çip-Ô¨Çop
A JK Ô¨Çip-Ô¨Çop triggered by the rising edge of the clock signal (or positive-edge-
triggered JK Ô¨Çip-Ô¨Çop), as shown in Figure 1.28, can be implemented by adding a
combinational circuit to a D Ô¨Çip-Ô¨Çop. The characteristic equation takes the following
form:
Q+ = D = J ¬∑ Q + K ¬∑ Q
[1.44]

28
Digital Electronics 2
where Q is the present state and Q+ represents the next state. Table 1.20 shows the
truth table. The timing diagram of the JK Ô¨Çip-Ô¨Çop triggered by rising edge is given in
Figure 1.29.
(a)
Q
Q
K
J
Q
Q
D
(b)
J
K
CK
Figure 1.28. JK Ô¨Çip-Ô¨Çop triggered by the clock signal rising edge:
a) logic circuit; b) symbol
Q
J
K
CK
x
x
1
x
x
0
0
1
1
0
1
1
0
0
Q+
Q
Q
Q+
0
1
1
0
Q
Q
Q
Q
Q
Table 1.20. Truth table
We can also implement a T Ô¨Çip-Ô¨Çop by connecting a combinational circuit to a D
Ô¨Çip-Ô¨Çop as illustrated in Figure 1.30. If Q is the present state and Q+ denotes the next
state, the characteristic equation for the edge-triggered Ô¨Çip-Ô¨Çop is given by:
Q+ = D = T ‚äïQ
[1.45]

Latch and Flip-Flop
29
J
K
CK
Q
Figure 1.29. Timing diagram of the JK Ô¨Çip-Ô¨Çop triggered
by the clock signal rising edge
(b)
Q
Q
T
CK
Q
Q
D
T
(a)
Figure 1.30. T Ô¨Çip-Ô¨Çop triggered by the clock signal rising edge:
a) logic circuit; b) symbol
Q
Q
T
CK
x
1
x
0
1
0
Q+
Q
Q
Q+
Q
Q
Q
Q
Table 1.21. Truth table
Table 1.21 gives the corresponding truth table. The timing diagram of the T Ô¨Çip-
Ô¨Çop triggered by the clock signal rising edge is represented in Figure 1.29.

30
Digital Electronics 2
CK
T
Q
Figure 1.31. Timing diagram for the T Ô¨Çip-Ô¨Çop triggered
by the clock signal rising edge
1.8. Flip-Ô¨Çops with asynchronous inputs
Just after power-up, for instance, asynchronous inputs can be used to deÔ¨Åne initial
conditions of a Ô¨Çip-Ô¨Çop, regardless of the states of synchronous inputs and the clock
signal in order to prevent any possible hazards. They are generally low active.
‚Äì The D Ô¨Çip-Ô¨Çop shown in Figure 1.32(a) has two asynchronous inputs, PR and
CLR, that can be used to determine the output state, regardless of the clock signal.
Its symbol is given in Figure 1.32(b). Based on the truth table, shown in Table 1.22,
the input PR sets the output to 1 (asynchronous preset), and CLR resets the output
to 0 (asynchronous clear). For operation in the synchronous mode, the inputs PR and
CLR must be kept in the high logic state.
(a)
CK
CLR
D
PR
Q
Q
(b)
PR
CLR
Q
D
Q
Figure 1.32. Structure of a D Ô¨Çip-Ô¨Çop with asynchronous inputs
(integrated circuit 74LS74): a) logic circuit; b) symbol
‚Äì A JK Ô¨Çip-Ô¨Çop triggered by the clock signal falling edge (or negative edge
triggered JK Ô¨Çip-Ô¨Çop), as depicted in Figure 1.34(a), consists of a synchronous SR

Latch and Flip-Flop
31
latch connected to NAND gates. It can be set to 1 or reset to 0 using the
asynchronous inputs PR and CLR,
respectively. Its symbol is shown in
Figure 1.34(b).
Normal operation
Asynchronous clear
Asynchronous preset
x
1
0
D
x
x
x
x
CLR
1
1
1
1
1
1
PR
1
0
0
1
0
0
1
1
x
x
x
0
1
CK
Q
Q+
1
0
0
1
1
0
Q
Q
Q
Q
0
1
1
1
+
Forbidden state
Table 1.22. Truth table of the D Ô¨Çip-Ô¨Çop with asynchronous inputs
Q
CLR
CK
PR
D
Figure 1.33. Timing diagram of the D Ô¨Çip-Ô¨Çop with asynchronous inputs
During a normal (or synchronous) operation of the Ô¨Çip-Ô¨Çop, the asynchronous
inputs are set to 1. When the clock signal changes from 1 to 0, the 0 logic state is
directly transferred to the output gated latch of the type SR, which is then activated
so that the state of the inputs J and K can be taken into account. Because the NAND
gates are sized to have a propagation delay in the order of the time required by the
Ô¨Çip-Ô¨Çop outputs to change states, just enough time passed before the clock signal
propagating through the NAND gates can affect the Ô¨Çip-Ô¨Çop, thereby preventing any
other change in logic state. When the clock signal CK takes the 0 logic state, each
NAND gate is then set to 1 and the state of the AND gate connected to the output is
now only dependent on the feedback signal. This allows the Ô¨Çip-Ô¨Çop to preserve its
earlier state. When the clock signal CK changes from 0 to 1, or takes the logic state 1,

32
Digital Electronics 2
the output of each AND gate directly connected to the clock signal is dependent only
on the feedback signal. This prevents the Ô¨Çip-Ô¨Çop from changing state.
Gated latch of the type SR
Q
PR
J
CLR
CK
K
PR
Q
(a)
PR
CLR
Q
CK
J
J
K
CLR
K
(b)
Q
Figure 1.34. Logic circuit and symbol of the JK Ô¨Çip-Ô¨Çop with
asynchronous inputs
Edge triggering is implemented by exploiting the difference in propagation delays
associated with the clock signal CK, that is applied directly and via the NAND gates
to the SR latch.
Table 1.23 shows the truth table of a JK Ô¨Çip-Ô¨Çop with asynchronous inputs.
pHL
R
Q
S


m
t
Metastability
pLH
m
t
Figure 1.35. Operational characteristics of an SR latch
NOTE.‚Äì By simultaneously applying a data D to the input J and its complement, D,
to the input K, the JK Ô¨Çip-Ô¨Çop operates as a D Ô¨Çip-Ô¨Çop.

Latch and Flip-Flop
33
operation
PR
Q+
Forbidden state
Asynchronous preset
Asynchronous clear
No change
Reset
Set
CK
J
K
1
0
1
1
1
0
0
1
1
x
x
x
0
0
x
x
x
1
1
0
0
x
x
x
0
Toggle
1
1
No change
1
1
x
x
1
1
1
1
1
0
1
0
Q
1
1
Q
Q
CLR
Normal 
Table 1.23. Truth table of the JK Ô¨Çip-Ô¨Çop with asynchronous inputs
1.9. Operational characteristics of Ô¨Çip-Ô¨Çops
A Ô¨Çip-Ô¨Çop only acquires a signal whose level can remain stable for a certain time.
Thus, it can operate normally only when the setup time requirements are met.
The timing diagram shown in Figure 1.35 illustrates the effect of the following
characteristics on the state of the Q output of an SR latch:
‚Äì propagation delay tp: this is the interval of time between the application of an
input signal and the appearance of the resulting signal at the output. The delay tpLH
is measured on the rising edge of the output, while tpHL is measured on the falling
edge;
‚Äì minimum pulse width œÑm: in order for the Ô¨Çip-Ô¨Çop to operate reliably, the width
of each pulse must be greater than œÑm, otherwise the state of the output may become
metastable.
Flip-Ô¨Çops available in the form of integrated circuits have propagation delays of
the order of a few nanoseconds.
In addition, with reference to waveforms of a synchronous D Ô¨Çip-Ô¨Çop shown in
Figure 1.36, we can deÔ¨Åne:
‚Äì the setup time as the minimum time during which the input logic levels must
be kept constant before the transition of the clock signal in order to ensure a reliable
triggering;

34
Digital Electronics 2
pHL
Q
CK
th
tsu
th
tpLH
tsu
t
D
Figure 1.36. Operational characteristics of an edge-triggered D Ô¨Çip-Ô¨Çop
‚Äì the hold time, which is the minimum time interval during which the logic levels
of the input must be kept constant after the transition of the clock signal in order to
guarantee a reliable triggering.
The set-up time and hold time for integrated-circuit Ô¨Çip-Ô¨Çops are of the order of
a few nanoseconds. When the set-up and hold conditions are not satisÔ¨Åed, the output
state of the Ô¨Çip-Ô¨Çop may become unpredictable (either 0 or 1). In some cases, we can
observe an oscillation of the output signal or a metastable state situated between the
high and low logic levels.
1.10. Exercises
EXERCISE 1.1.‚Äì Propose an equivalent switch-based circuit for each of the circuits in
Figure 1.37.
What is the function of these circuits?
EXERCISE 1.2.‚Äì Consider the T latch whose logic circuit and symbol are given in
Figure 1.38.
Determine the characteristic equations of this latch.
EXERCISE 1.3.‚Äì Analyze and construct the truth table for the Ô¨Çip-Ô¨Çop shown in
Figure 1.39.
EXERCISE
1.4.‚Äì Consider the positive edge-triggered D Ô¨Çip-Ô¨Çop shown in
Figure 1.40(a). Complete the timing-diagram in Figure 1.40(b).
EXERCISE 1.5.‚Äì Figure 1.41(a) shows a positive edge-triggered JK Ô¨Çip-Ô¨Çop.
Complete the timing diagram in Figure 1.41(b).

Latch and Flip-Flop
35
P
VCC
RP
VCC
RP
RP
(a)
S
R
(b)
S
R
Q
Q
Q
Q
R
Figure 1.37. Logic circuits
T
C
Q
R
Q
S
T
(a)
(b)
Q
Q
Figure 1.38. T latch: a) logic circuit; b) symbol
CK
Q
Q
D
EN
D
Figure 1.39. Logic circuit for the Ô¨Çip-Ô¨Çop
EXERCISE 1.6.‚Äì Consider the master-slave JK Ô¨Çip-Ô¨Çop in Figure 1.42(a). Complete
the timing diagram shown in Figure 1.42(b).
EXERCISE 1.7.‚Äì Figure 1.43(a) shows a JK Ô¨Çip-Ô¨Çop with asynchronous inputs.
Complete the timing diagram in Figure 1.43(b).

36
Digital Electronics 2
CK
Q
Q
D
CK
(b)
(a)
Q
D
D
Figure 1.40. a) D Ô¨Çip-Ô¨Çop; b) timing diagram
CK
(a)
Q
Q
K
J
(b)
CK
K
J
Q
K
J
Figure 1.41. a) JK Ô¨Çip-Ô¨Çop; b) timing diagram
CK
(a)
Q
Q
K
J
(b)
CK
K
J
Q
CK
K
J
Figure 1.42. a) Master-slave JK Ô¨Çip-Ô¨Çop; b) timing diagram
EXERCISE 1.8.‚Äì The logic circuit for a D Ô¨Çip-Ô¨Çop with asynchronous inputs is
represented in Figure 1.44(a). Complete the timing diagram in Figure 1.44(b).
EXERCISE 1.9.‚Äì For each circuit using two D Ô¨Çip-Ô¨Çops,
as represented in
Figures 1.45‚Äì1.47, complete the corresponding timing diagram.
EXERCISE 1.10.‚Äì Complete the timing diagram corresponding to each of the circuits
using two JK Ô¨Çip-Ô¨Çops, as represented in Figures 1.48 and 1.49.
EXERCISE 1.11.‚Äì Consider the logic circuit shown in Figure 1.50(a), which is made
up of two D Ô¨Çips-Ô¨Çops and a combinational logic circuit section F to be determined.

Latch and Flip-Flop
37
PR
PR
CLR
Q
Q
K
J
CK
K
J
CLR
PR
(a)
CK
K
J
Q
(b)
CLR
Figure 1.43. a) JK Ô¨Çip-Ô¨Çop; b) timing diagram
D
(b)
(a)
PR
CLR
Q
Q
D
PR
CK
D
Q
CK
CLR
PR
CLR
Figure 1.44. a) D Ô¨Çip-Ô¨Çop; b) timing diagram
Q1
CK
(a)
Q
Q
D
Q
Q
D
(b)
1
2
CK
Q2
Figure 1.45. a) Logic circuit 1; b) timing diagram
Complete the timing diagram (signals Q1 and Q2) in Figure 1.50(b).
Determine the logic function F and suggest how it can be implemented.

38
Digital Electronics 2
CK
CK
Q2
Q1
D
(a)
(b)
Q
Q
D
Q
Q
D
1
2
Q1
D
Q2
Figure 1.46. a) Logic circuit 2; b) timing diagram
(a)
CK
Q2
Q1
D
(b)
Q
Q
D
Q
Q
D
Q1
Q2
CK
D
1
2
Figure 1.47. a) Logic circuit 3; b) timing diagram
Q2
(a)
(b)
Q
Q
K
J
Q
Q
K
J
CK
1
1
2
CK
Q1
Figure 1.48. a) Logic circuit 1; b) timing diagram
EXERCISE 1.12.‚Äì Determine the characteristic equation for each of the synchronous
D Ô¨Çip-Ô¨Çops in Figure 1.51. To compare these two D Ô¨Çip-Ô¨Çops, we use the set-up shown
in Figure 1.52(a) and assume that the propagation delay of the inverter is not equal to
zero.
Complete the timing diagram in Figure 1.52(b).
Which of the two Ô¨Çip-Ô¨Çops operates correctly? Why? Justify your response using
Karnaugh maps.

Latch and Flip-Flop
39
2
(a)
(b)
CK
1
CK
Q1
Q2
Q
Q
K
J
1
Q
Q
K
J
Figure 1.49. a) Logic circuit 2; b) timing diagram
Logic
(a)
(b)
CK
D
X
Q2
Q1
Q
Q
D
Q
Q
D
CK
C
X
section
F
2
1
Q2
Q1
D
Figure 1.50. a) Logic circuit; b) timing diagram
EXERCISE 1.13.‚Äì Converting between different types of Ô¨Çip-Ô¨Çops. Verify the
equivalence between the Ô¨Çip-Ô¨Çops represented on each of the lines a, b, c and d in
Figure 1.53.
1.11. Solutions
SOLUTION 1.1.‚Äì The equivalent circuit for each of the proposed circuits is represented
in Figure 1.54.
It is a switch debouncer.
SOLUTION 1.2.‚Äì T latch.
An SR latch is characterized by:
Q+ = S ¬∑ C + (R + C) ¬∑ Q
[1.46]

40
Digital Electronics 2
L1
Q
D
C
Q
D
C
(b)
(a)
Q
D
C
L2
Q
D
C
Figure 1.51. Logic circuits and symbols for the synchronous D Ô¨Çip-Ô¨Çops
Q1
C
Q
D
C
L1
Q
D
C
L2
D
C
C
(b)
Q1
Q2
(a)
 Q2
D
Figure 1.52. a) Logic circuit; b) timing diagram
or
Q+ = R ¬∑ S ¬∑ C + (R + C) ¬∑ Q
[1.47]
Assuming that for the T latch, S = Q, R = Q and C = T, we obtain the same
characteristic equation in both cases, which can be written as follows:
Q+ = Q ¬∑ T + T ¬∑ Q = T ‚äïQ
[1.48]

Latch and Flip-Flop
41
(d)
K
EN
D
d
(a)
(b)
(c)
CK
Q
Q
D
T
T
CK
Q
Q
K
J
Q
Q
T
J
K
CK
CK
EN
D
2:1 Multiplexer
Q
Q
D
EN
Q
Q
D
Q
Q
Q
Q
D
Q
Q
K
J
D
CK
Q
Q
D
CK
Q
Q
K
J
J
Figure 1.53. Flip-Ô¨Çops
(b)
VCC
(a)
Figure 1.54. Equivalent circuits

42
Digital Electronics 2
SOLUTION 1.3.‚Äì D Ô¨Çip-Ô¨Çop with enable input.
The characteristic equation for the D Ô¨Çip-Ô¨Çop with enable input is given by:
Q+ = D ¬∑ EN + EN ¬∑ Q
[1.49]
Figure 1.55 shows the logic circuit and the truth table for the D Ô¨Çip-Ô¨Çop with
enable input is represented in Table 1.24.
d
CK
2:1 Multiplexer
Q
Q
D
D
EN
Figure 1.55. Logic circuit for D Ô¨Çip-Ô¨Çop with enable input
+
EN
D
CK
x
x
0
1
x
x
1
1
1
0
0
x
Q
Q
Q
Q+
Q
Q
Q
Q
0
1
1
0
Table 1.24. Truth table of the Ô¨Çip-Ô¨Çop
SOLUTION 1.4.‚Äì Positive edge-triggered DD Ô¨Çip-Ô¨Çop.
For the positive edge-triggered D Ô¨Çip-Ô¨Çop, Figure 1.56 shows the logic circuit and
the timing diagram that can be obtained from the truth table.
Figure 1.57 shows the logic circuit and the timing diagram for the level-triggered
D Ô¨Çip-Ô¨Çop.

Latch and Flip-Flop
43
D
Q
Q
D
CK
CK
(b)
(a)
D
Q
Figure 1.56. a) Positive edge-triggered D Ô¨Çip-Ô¨Çop; b) timing diagram
C
Q
Q
D
(b)
(a)
D
Q
D
C
C
Figure 1.57. a) Level-triggered D Ô¨Çip-Ô¨Çop; b) timing diagram
Figure 1.58 shows the logic circuit and the timing diagram that can be used to
compare these two types of D Ô¨Çip-Ô¨Çops.
(b)
Q
Q
D
C
Q
Q
D
1
2
D
CK
D
Q1
Q2
CK
(a)
Q1
Q2
Figure 1.58. Comparison of two D Ô¨Çip-Ô¨Çops:
a) logic circuit; b) timing diagram
SOLUTION 1.5.‚Äì Positive edge-triggered JK Ô¨Çip-Ô¨Çop.
Figure 1.59 shows the logic circuit and timing diagram for the positive
edge-triggered JK Ô¨Çip-Ô¨Çop.

44
Digital Electronics 2
Q
(a)
Q
Q
K
J
CK
K
J
(b)
CK
K
J
Figure 1.59. a) JK Ô¨Çip-Ô¨Çop; b) timing diagram
SOLUTION 1.6.‚Äì Master-slave JK Ô¨Çip-Ô¨Çop.
Figure 1.60 shows the logic circuit and timing diagram for the master-slave JK
Ô¨Çip-Ô¨Çop.
J
(a)
Q
Q
K
J
(b)
CK
K
J
Q
CK
K
Figure 1.60. a) Master-slave JK Ô¨Çip-Ô¨Çop; b) timing diagram
SOLUTION 1.7.‚Äì JK Ô¨Çip-Ô¨Çop with asynchronous inputs.
Figure 1.61 shows the logic circuit and the timing diagram for the JK Ô¨Çip-Ô¨Çop with
asynchronous inputs.
SOLUTION 1.8.‚Äì D Ô¨Çip-Ô¨Çop with asynchronous inputs.
Figure 1.62 shows the logic circuit and timing diagram for the D Ô¨Çip-Ô¨Çop with
asynchronous inputs.
SOLUTION 1.9.‚Äì Connection of two D Ô¨Çip-Ô¨Çops.
Figure 1.63 shows logic circuit 1 and the corresponding timing diagram.
Logic circuit 2 and its timing diagram are represented in Figure 1.64.
Figure 1.65 shows logic circuit 3 and the corresponding timing diagram that can
be obtained based on the truth table.

Latch and Flip-Flop
45
(b)
PR
PR
CLR
Q
Q
K
J
K
J
CK
CLR
PR
(a)
CK
K
J
Q
CLR
Figure 1.61. a) JK Ô¨Çip-Ô¨Çop; b) timing diagram
(a)
D
Q
CK
CLR
PR
(b)
PR
CLR
Q
Q
D
PR
CK
CLR
D
Figure 1.62. a) D Ô¨Çip-Ô¨Çop; b) timing diagram
(b)
CK
Q
Q
D
Q
Q
D
1
2
(a)
CK
Q2
Q1
Figure 1.63. a) Logic circuit 1; b) timing diagram
SOLUTION 1.10.‚Äì Connection of two JK Ô¨Çip-Ô¨Çops.
Figure 1.66 shows logic circuit 1 and the timing diagram that can be obtained
based on the truth table.

46
Digital Electronics 2
(b)
Q
Q
D
Q
Q
D
1
2
Q1
D
Q2
CK
(a)
CK
Q2
Q1
D
Figure 1.64. a) Logic circuit 2; b) timing diagram
(a)
CK
Q2
Q1
D
(b)
Q
Q
D
Q
Q
D
Q1
Q2
CK
D
1
2
Figure 1.65. a) Logic circuit 3; b) timing diagram
(b)
Q
Q
K
J
Q
Q
K
J
CK
1
1
2
CK
Q1
Q2
(a)
Figure 1.66. a) Logic circuit 1; b) timing diagram
Figure 1.67 shows logic circuit 2 and the corresponding timing diagram.
SOLUTION 1.11.‚Äì Circuit using D Ô¨Çip-Ô¨Çops.
The truth table for the level-triggered D Ô¨Çip-Ô¨Çop and the truth table for the positive
edge-triggered D Ô¨Çip-Ô¨Çop can be used to complete the timing diagram (for the outputs
Q1 and Q2) for the circuit shown in Figure 1.68(a), as illustrated in Figure 1.68(b).

Latch and Flip-Flop
47
(b)
CK
1
CK
Q1
Q2
Q
Q
K
J
1
Q
Q
K
J
2
(a)
Figure 1.67. a) Logic circuit 2; b) timing diagram
(a)
CK
D
X
Q2
Q1
(b)
Q
Q
D
Q
Q
D
CK
C
X
logique
Section
F
2
1
Q2
Q1
D
Figure 1.68. a) Logic circuit; b) timing diagram
Considering Q1 and Q2 as the inputs and X as the output, the truth table (see
Table 1.25) obtained based on the timing diagram helps deÔ¨Åne the logic relationship
that exists between Q1, Q2 and X.
Because the resulting logic equation is of the form, X = Q1 + Q2, the function F
can be implemented by an OR gate (see Table 1.25).
POR Gate
1
0
1
X
Q1
Q2
Q1 Q2 
X
1
1
1
0
0
0
1
1
0
Table 1.25. Truth table (OR gate)

48
Digital Electronics 2
SOLUTION 1.12.‚Äì Gated D latches.
By analyzing each latch, we obtain a characteristic equation of the following form:
‚Äì latch L1:
Q+ = D ¬∑ C + Q ¬∑ C
[1.50]
‚Äì latch L2:
Q+ = D ¬∑ C + Q ¬∑ C + D ¬∑ Q
[1.51]
(a)
C
Q
D
C
L1
Q
D
C
L2
Q1
 Q2
D
C
C
(b)
Q1
Q2
D
Figure 1.69. a) Logic circuit; b) timing diagram
Figure 1.69 shows the timing diagram that can be used to compare the latches L1
and L2.
The operation of the latch L1 is affected by the propagation delay of the inverter
used to generate the signal C. Hence, if D = 1 and Q = 1, we have:
‚Äì latch L1:
Q+ = C + C
[1.52]
‚Äì latch L2:
Q+ = 1 + C + C = 1
[1.53]
Adding the redundant term D ¬∑ Q corresponding to cells 5 and 7 of the Karnaugh
map (see Figure 1.70) is useful for the elimination of the aforementioned functional
hazard in the case of the latch L2.

Latch and Flip-Flop
49
Q
(a)
(b)
DC
00
01
11
10
D
0
C
1
1
6
7
1
0
1
1
0
0
0
0
1
2
3
4
5
Q
Q
DC
00
01
11
10
D
0
C
1
1
6
7
1
0
1
1
0
0
0
0
1
2
3
4
5
Q
Figure 1.70. Karnaugh maps: a) latch L1; b) latch L2. For a color
version of this Ô¨Ågure, see www.iste.co.uk/ndjountche/electronics2.zip
SOLUTION 1.13.‚Äì Conversion of one type of Ô¨Çip-Ô¨Çop to another.
‚Äì T Ô¨Çip-Ô¨Çop
For the circuit based on the D Ô¨Çip-Ô¨Çop, we get:
Q+ = D = T ‚äïQ
[1.54]
Considering the circuit based on the JK Ô¨Çip-Ô¨Çop, we have:
Q+ = D = J ¬∑ Q + K ¬∑ Q = T ¬∑ Q + T ¬∑ Q = T ‚äïQ
[1.55]
In both cases, we have the characteristic equation for the T Ô¨Çip-Ô¨Çop.
‚Äì JK Ô¨Çip-Ô¨Çop
By analyzing the circuit based on the D Ô¨Çip-Ô¨Çop, we can write:
Q+ = D = J ¬∑ Q + K ¬∑ Q
[1.56]
this is the characteristic equation of the JK Ô¨Çip-Ô¨Çop.
‚Äì D Ô¨Çip-Ô¨Çop
For the circuit based on the JK Ô¨Çip-Ô¨Çop, we have:
J = D,
K = D,
and
Q+ = J ¬∑ Q + K ¬∑ Q = D
[1.57]
this is the characteristic equation of the D Ô¨Çip-Ô¨Çop.

50
Digital Electronics 2
The logic expression obtained for the circuit based on the D Ô¨Çip-Ô¨Çop is of the form:
Q+ = d = D ¬∑ EN + Q ¬∑ EN
[1.58]
The equation associated with the circuit based on the JK Ô¨Çip-Ô¨Çop is given by:
Q+ = J ¬∑ Q + K ¬∑ Q
[1.59]
where J = D ¬∑ EN and K = D ¬∑ EN. By applying Boolean algebra theorems, we
can successively Ô¨Ånd that:
Q+ = D ¬∑ EN ¬∑ Q + D ¬∑ EN ¬∑ Q
[1.60]
= D ¬∑ EN ¬∑ Q + (D + EN)Q
= D(EN + Q) + Q ¬∑ EN
= D ¬∑ EN + D ¬∑ Q(EN + EN) + Q ¬∑ EN
= D ¬∑ EN(1 + Q) + Q ¬∑ EN(1 + D)
= D ¬∑ EN + Q ¬∑ EN
[1.61]
In both cases, the characteristic equation obtained is that of a D Ô¨Çip-Ô¨Çop with
enable input.

2
Binary Counters
2.1. Introduction
Binary counters are circuits that generate binary sequences that can be associated
with the number of clock signal pulses applied to the input. They are used in
applications such as event synchronization and frequency measurement, estimation
of angular position and the duration of an event.
An asynchronous counter is often called a ripple counter. The clock signal is only
directly applied to the Ô¨Årst Ô¨Çip-Ô¨Çop and it is subsequently transmitted, with a
propagation delay, from one Ô¨Çip-Ô¨Çop to another.
In a synchronous counter, all the Ô¨Çip-Ô¨Çops are triggered by the same clock signal.
Thus, the outputs of the counter change state at the same time and there is no time lag
between the different outputs.
The state of a counter is deÔ¨Åned by a speciÔ¨Åc combination formed by all the outputs
together.
A state diagram, which shows the states and possible transitions, is most often used
to illustrate the counter operation. It is made up of circles with labels representing the
states and with arrows symbolizing the transitions.
The following parameters can be used to characterize a counter:
‚Äì the number of different states (also called modulo);
‚Äì the direction of counting (up or down);
‚Äì the operating mode (asynchronous or synchronous).
Digital Electronics 2: Sequential and Arithmetic Logic Circuits, First Edition. Tertulien Ndjountche. 
¬© ISTE Ltd 2016. Published by ISTE Ltd and John Wiley & Sons, Inc. 

52
Digital Electronics 2
To analyze counters it is always supposed, unless indicated otherwise, that the
initial state is 0.
2.2. Modulo 4 counter
A modulo 4 (or two-bit) counter has four different states (22 = 4). The output Q0
represents the least signiÔ¨Åcant bit (LSB) and Q1 corresponds to the most signiÔ¨Åcant
bit (MSB). Initially, we have: Q0 = 0 and Q1 = 0. The counting is cyclic and once
the state Q0 = 1 and Q1 = 1 is achieved, the next pulse of the clock signal allows the
counter to reset to its initial state.
The implementation of a modulo 4 counter requires at least two Ô¨Çip-Ô¨Çops that can
be conÔ¨Ågured for synchronous or asynchronous operation.
Figures 2.1(a) and 2.1(b) show the logic circuit and the timing diagram for an
asynchronous modulo 4 counter.
1
CLR
CLR
Q1
Q1
Q0
Q0
Q0
Q
Q
K
J
CK
1
CK
1
2
3
4
Q
Q
K
J
(a)
(b)
0
 0
1
0
0
 1
1
Figure 2.1. Asynchronous modulo 4 binary counter:
a) logic circuit; b) timing diagram
1
CLR
CLR
Q0
Q1
Q0
Q1
Q
Q
K
J
Q
Q
K
J
(b)
1
CK
1
2
3
4
(a)
CK
0
0
1
1
1
0
0
Figure 2.2. Synchronous modulo 4 binary counter:
a) logic circuit; b) timing diagram
The logic circuit and the timing diagram for a synchronous modulo 4 counter are
illustrated in Figures 2.2(a) and 2.2(b).

Binary Counters
53
Table 2.1 describes the count sequence and Figure 2.3 gives the state diagram,
where the initial state is Q1Q0 = 00.
Clock signal
Outputs
pulse
Q1
Q0
Initial state
0
0
1
0
1
2
1
0
3
1
1
4
0
0
Table 2.1. Table describing the count sequence
state :
00
11
01
10
initial state
1Q0
Q
Figure 2.3. State diagram for the modulo 4 counter
2.3. Modulo 8 counter
A modulo 8 (or three-bit) counter has eight different states and is made up of at
least three Ô¨Çip-Ô¨Çops. The output Q0 represents the LSB and Q2 is the MSB.
Initially, we have Q0 = 0, Q1 = 0 and Q2 = 0. The counter follows an ascending
sequence from 0 to 7. At the eighth pulse of the clock signal, the counter is reset to its
initial state.
Figures 2.1(a) and 2.1(b) show the logic circuit and the timing diagram for an
asynchronous modulo 8 counter.
The logic circuit and the timing diagram for a synchronous 8 modulo counter are
illustrated in Figures 2.2(a) and 2.2(b). The logic equations for the inputs of each
Ô¨Çip-Ô¨Çop are given by:
‚Äì Ô¨Çip-Ô¨Çop 0: J0 = K0 = 1;

54
Digital Electronics 2
‚Äì Ô¨Çip-Ô¨Çop 1: J1 = K1 = Q0;
‚Äì Ô¨Çip-Ô¨Çop 2: J2 = K2 = Q1 ¬∑ Q0.
1
CLR
CLR
CLR
Q0
Q1
Q2
Q0
Q1
Q2
Q
Q
K
J
CK
1
(b)
(a)
Q
Q
K
J
Q
Q
K
J
CK
2
4
5
6
7
8
1
3
0
0
0
1
0
0
0
1
0
1
0
0
0
1
1
0
1
0
1
1
1
1
1
0
0
0
Figure 2.4. Asynchronous modulo 8 binary counter:
a) logic circuit; b) timing diagram
CK
CLR
CLR
CLR
Q0
Q1
Q2
Q0
Q1
Q2
Q
Q
K
J
Q
Q
K
J
1
CK
2
4
5
6
7
8
1
3
0
0
0
1
0
0
0
1
0
1
0
0
0
1
1
0
1
0
1
1
1
1
1
0
0
0
1
(a)
(b)
Q
Q
K
J
Figure 2.5. Synchronous modulo 8 binary counter:
a) logic circuit; b) timing diagram

Binary Counters
55
Table 2.2 gives the count sequence, assuming that the initial state of the
synchronous and asynchronous counters is 0. The state diagram is represented in
Figure 2.6.
Clock signal
Outputs
pulse
Q2
Q1
Q0
Initial state
0
0
0
1
0
0
1
2
0
1
0
3
0
1
1
4
1
0
0
5
1
0
1
6
1
1
0
7
1
1
1
8
0
0
0
Table 2.2. Table describing the count sequence
state :
100
111
001
010
011
101
110
000
initial state
2
Q0
Q1
Q
Figure 2.6. State diagram of the modulo 8 counter
2.4. Modulo 16 counter
A modulo 16 (or four-bit) counter has 16 ((24 = 16)) states and at least four
Ô¨Çip-Ô¨Çops are required for its implementation. It can generate binary sequences
corresponding to the numbers from 1 to 15.
At each clock signal pulse, the counter moves from one number to the next. The
counter is reset to 0 upon reaching the sequence 1111, that is the number 15.

56
Digital Electronics 2
The logic circuit for an asynchronous modulo 16 counter is given in Figure 2.7(a).
Asynchronous counters present the advantage of being easy to implement. However,
as the timing diagram of Figure 2.7b shows, the output signals are affected by different
propagation delays that can become too high as the Ô¨Çip-Ô¨Çop number increases. This
limits the maximum operating frequency of the counter.
0
CLR
CLR
CLR
CLR
Q0
Q1
Q2
Q3
Q3
Q2
Q1
Q0
0
0
0
0
Q
Q
K
J
Q
Q
K
J
(a)
CK
1
Q
Q
K
J
Q
Q
K
J
(b)
2
4
5
6
7
8
1
3
9
10
11
12
13
14
16
15
0
0
0
1
1
1
1
0
0
0
1
1
1
1
0
0
CK
17
1
1
1
1
1
1
1
0
0
0
0
0
0
0
1
0
0
1
1
0
0
1
1
0
0
1
1
0
0
1
1
0
1
0
0
1
0
1
1
1
0
0
1
0
1
0
1
Figure 2.7. Asynchronous modulo 16 binary counter:
a) logic circuit; b) timing diagram
Synchronous counters can be implemented, with all outputs having identical
propagation delays. Figures 2.8(a) and 2.8(b) show the logic circuit and the timing
diagram of the synchronous modulo 16 counter when EN = 1. For each Ô¨Çip-Ô¨Çop, the
logic equations of the inputs are written as follows:
‚Äì Ô¨Çip-Ô¨Çop 0: J0 = K0 = EN;
‚Äì Ô¨Çip-Ô¨Çop 1: J1 = K1 = Q0 ¬∑ EN;
‚Äì Ô¨Çip-Ô¨Çop 2: J2 = K2 = Q1 ¬∑ Q0 ¬∑ EN;
‚Äì Ô¨Çip-Ô¨Çop 3: J3 = K3 = Q2 ¬∑ Q1 ¬∑ Q0 ¬∑ EN.
The counter is activated when the signal EN is set to 1, and when the signal EN
assumes the logic state 0 the counter remains in its previous state. Furthermore, we
have:
RCO = Q3 ¬∑ Q2 ¬∑ Q1 ¬∑ Q0 ¬∑ EN

Binary Counters
57
RCO
0
Q1
Q2
Q3
Q3 Q2 Q1 Q0
CLR
CLR
Q2
Q3
CLR
Q1
CLR
Q0
(a)
(b)
CK
2
4
5
6
7
8
1
3
9
10
11
12
13
14
16
15
1
0
0
1
0
1
1
1
0
0
1
0
1
0
1
0
1
1
0
0
1
1
0
0
1
1
0
0
1
1
1
1
1
1
1
1
1
0
0
0
0
0
0
0
1
0
0
0
1
1
1
1
0
0
0
1
1
1
1
0
0
0
0
0
0
0
0
0
EN
RCO
CLR
Counter
Q
Q
K
J
Q
Q
K
J
Q
Q
K
J
Q
Q
K
J
EN
CK
Q
Figure 2.8. Synchronous modulo 16 binary counter:
a) logic circuit; b) timing diagram
The ripple-carry output, RCO, is set to 1 at the end of the counting cycle. To
increase the count range, two counters can be cascaded by connecting the output,
RCO, of the Ô¨Årst to the input, EN, of the second.
The output of one Ô¨Çip-Ô¨Çop only changes states if the outputs of all the Ô¨Çip-Ô¨Çops of
lower numbers are set to 1. The Ô¨Çip-Ô¨Çops used by the counter have identical J and K
inputs and can thus only function in hold or toggle modes such as T Ô¨Çip-Ô¨Çops.
The operation of asynchronous and synchronous modulo 16 counters is described
by the state diagram given in Figure 2.9, where the initial state is 0.
Figure 2.10 shows the logic circuit of a modulo 256 counter implemented by
cascading two modulo 16 counters.
2.4.1. Modulo 10 counter
In general, a counter using N Ô¨Çip-Ô¨Çops has a maximum number of states equal
to 2N. It is thus said to have completed a cycle if it can generate binary sequences
corresponding to the numbers from 0 to 2N ‚àí1.

58
Digital Electronics 2
state :
1100
1111
1110
1101
1011
1010
1001
1000
0011
0000
0001
0010
0100
0101
0110
0111
Q1Q0
initial state
3 Q2
Q
Figure 2.9. State diagram of the modulo 16 counter
RCO
EN
Q3 Q2 Q1 Q0
Q3 Q2 Q1 Q0
EN
1
CK
RCO
Figure 2.10. Modulo 256 counter
The decade counter or the modulo 10 counter is used in applications where a digital
display is required.
The asynchronous modulo 10 counter in Figure 2.11(a) is implemented by
reducing the number of states of a four-bit asynchronous counter. It produces an
ascending sequence going from (0000) to 9 (1001), corresponding to BCD codes.
The counter must be reset at the 10th pulse of the clock signal. A NAND gate is used
to detect the state Q1 = 1 and Q3 = 1 corresponding to the count of 10 (1010) in
order to reset the counter. This can result in unwanted transients during the state
transition, as shown in the timing diagram in Figure 2.11(b).
The logic circuit and the timing diagram of a synchronous modulo 10 counter are
given in Figures 2.12(a) and 2.12(b). The logic equations for the inputs J and K are
written as follows:
‚Äì Ô¨Çip-Ô¨Çop 0: J0 = K0 = 1;
‚Äì Ô¨Çip-Ô¨Çop 1: J1 = K1 = Q0 ¬∑ Q3;
‚Äì Ô¨Çip-Ô¨Çop 2: J2 = K2 = Q0 ¬∑ Q1;
‚Äì Ô¨Çip-Ô¨Çop 3: J3 = K3 = Q0 ¬∑ Q1 ¬∑ Q2 + Q0 ¬∑ Q3.
NOTE.‚Äì Three Ô¨Çip-Ô¨Çops are not enough to implement a modulo 10 counter.

Binary Counters
59
signal
0
Q1
Q2
Q0
Q1
Q2
Q3
J
CLR
1
CLR
Transient
Q
Q
Q
K
J
CLR
(a)
CK
2
4
5
6
7
8
1
3
9
10
Q3
1
1
0
0
1
0
1
0
1
0
1
1
0
0
1
1
0
0
1
0
0
0
0
0
0
0
1
0
0
0
0
1
1
1
1
0
0
0
0
0
CLR
(b)
0
0
0
0
Q
Q
K
J
CLR
CK
Q
Q
K
J
CLR
Q
Q
K
Figure 2.11. Asynchronous modulo 10 binary counter:
a) logic circuit; b) timing diagram
Considering that the counter assumes one of the states corresponding to the
numbers from 10 to 15 (or unused states) after it is powered on, the input equations
for the Ô¨Çip-Ô¨Çops can be used to determine the next states. Table 2.3 shows the
transition table for unused states. The state diagram of the modulo 10 counter is
represented in Figure 2.13. If the counter takes one of the unused states, it can reenter
the main counting cycle after, at most, two clock pluses.
PS
Inputs
NS
Q3Q2Q1Q0
J3K3
J2K2
J1K1
J0K0
Q+
3 Q+
2 Q+
1 Q+
0
1 0 1 0
0 0
0 0
0 0
1 1
1
0
1
1
1 0 1 1
1 1
1 1
0 0
1 1
0
1
1
0
1 1 0 0
0 0
0 0
0 0
1 1
1
1
0
1
1 1 0 1
1 1
0 0
0 0
1 1
0
1
0
0
1 1 1 0
0 0
0 0
0 0
1 1
1
1
1
1
1 1 1 1
1 1
1 1
0 0
1 1
0
0
1
0
Table 2.3. Transition table for unused states
(PS, present state; NS, next state)

60
Digital Electronics 2
(b)
CLR
CLR
CLR
CK
CLR
Q0
Q0
Q1
Q2
Q3
Q1
Q2
Q3
Q
Q
K
J
1
(a)
CK
2
4
5
6
7
8
1
3
9
10
Q
Q
K
J
Q
Q
K
J
Q
Q
K
J
1
1
0
0
1
0
1
0
1
0
1
1
0
0
1
1
0
0
1
0
0
0
0
0
0
0
1
0
0
0
0
1
1
1
1
0
0
0
0
0
0
0
0
0
Figure 2.12. Synchronous modulo 10 binary counter:
a) logic circuit; b) timing diagram
Q
0001
0101
0110
0000
1000
0011
0111
0100
0010
1001
1011
1100
1111
1110
1100
1010
initial state
state :
3 Q2Q1Q0
Figure 2.13. State diagram for the synchronous
modulo 10 binary counter
2.5. Counter with parallel load
A counter with parallel load offers more Ô¨Çexibility in the selection of the count
sequence.

Binary Counters
61
Figure 2.14 depicts a four-bit counter with parallel load. It consists of logic gates
(AND, XOR), 2-to-1 multiplexers and D Ô¨Çip-Ô¨Çops whose input logic equations can be
written as follows:
D0 = P0 ¬∑ Load + (Q0 ‚äïEn)Load
[2.1]
D1 = P1 ¬∑ Load + [Q1 ‚äï(Q0 ¬∑ En)]Load
[2.2]
D2 = P2 ¬∑ Load + [Q2 ‚äï(Q1 ¬∑ Q0 ¬∑ En)]Load
[2.3]
D3 = P3 ¬∑ Load + [Q3 ‚äï(Q2 ¬∑ Q1 ¬∑ Q0 ¬∑ En)]Load
[2.4]
and:
RCO = Q3 ¬∑ Q2 ¬∑ Q1 ¬∑ Q0 ¬∑ En
[2.5]
Reset
1
0
3
3
2
1
CK
Reset
RCO
En
P0 P1 P2 P3
Load
0
Q0 Q1 Q2 Q3
0
1
Q
Q
D
CLR
RCO
0
1
Q
Q
D
CLR
0
1
Q
Q
D
CLR
0
1
Q
Q
D
CLR
Load
En
2
P
Q
P
P
Q
P
Q
Q
Figure 2.14. Logic circuit of a four-bit counter with parallel load
The counter can be reset synchronously and initialized using parallel loads.
Table 2.4 presents the function table.

62
Digital Electronics 2
Inputs
Reset
En
Load
Function
0
x
x
Reset
1
0
0
Hold
1
x
1
Load
1
1
0
Count
Table 2.4. Function table
For applications requiring a modulo 7 or modulo 10 counter, the four-bit counter
with parallel load can be conÔ¨Ågured as shown in Figure 2.15. The AND gate detects
the state 0110 (6) (modulo 7 counter) or 1001 (9) (modulo 10 counter) to initiate the
counter reset through the parallel load.
CK
0 Q1 Q2 Q3
Q0 Q1 Q2 Q3
RCO
En
P0 P1 P2 P3
Load
Reset
0
0
0
0
1
(a)
(b)
RCO
En
P0 P1 P2 P3
Load
Reset
0
0
0
0
1
CK
1
1
Q
Figure 2.15. a) Modulo 7 counter; b) modulo 10 counter
Using two counter stages, the count range can be expanded by connecting the
output, RCO, of the Ô¨Årst stage to the input, EN, of the second stage.
2.6. Down counter
A down counter generates, from a given initial state, a sequence of numbers in
decreasing order.
The logic circuit of an asynchronous modulo 16 down counter is given in
Figure 2.16. It consists of JK Ô¨Çip-Ô¨Çops whose inputs are connected to an enable
signal EN. The down counter is activated or deactivated by setting the signal EN to
1 or to 0.
Figure 2.17 shows the logic circuit and the symbol for a synchronous modulo 16
down counter. The logic equations for the inputs J and K are given by:
‚Äì Ô¨Çip-Ô¨Çop 0: J0 = K0 = EN;

Binary Counters
63
‚Äì Ô¨Çip-Ô¨Çop 1: J1 = K1 = Q0 ¬∑ EN;
‚Äì Ô¨Çip-Ô¨Çop 2: J2 = K2 = Q1 ¬∑ Q0 ¬∑ EN;
‚Äì Ô¨Çip-Ô¨Çop 3: J3 = K3 = Q2 ¬∑ Q1 ¬∑ Q0 ¬∑ EN.
J
CLR
Q0
PR
CLR
Q1
PR
CLR
PR
Q2
CLR
Q3
PR
Q
Q
K
J
Q
Q
K
J
Q
Q
K
J
CK
EN
Q
Q
K
Figure 2.16. Logic circuit for an asynchronous modulo 16 down counter
Down counter
CLR
Q3
CLR
CLR
Q1
CLR
Q0
PR
PR
PR
PR
Q2
EN
CLR
Q3 Q2 Q1 Q0
Q
Q
K
J
Q
Q
K
J
Q
Q
K
J
Q
Q
K
J
CK
EN
RCO
PR
RCO
Figure 2.17. Logic circuit and symbol for a synchronous
modulo 16 down counter
During the normal operation, the enable signal EN must be set to 1.
The state diagram given in Figure 2.18 can be used to describe the operation of
an asynchronous down counter, as well as a synchronous down counter. However,
the maximum frequency of the asynchronous down counter is limited by the different
propagation delays that can affect the clock signal.

64
Digital Electronics 2
state :
1100
1111
1110
1101
1011
1010
1001
1000
0011
0000
0001
0010
0100
0101
0110
0111
Q1Q0
3 Q2
initial state
Q
Figure 2.18. State diagram for a modulo 16 down counter
2.7. Synchronous reversible counter
A reversible counter is also called a bidirectional counter or an up/down counter.
It can generate a sequence of numbers in increasing or decreasing order. In general, it
is possible to change the count direction from any state.
Figures 2.19(a) and 2.19(b) show the logic circuit and the timing diagram of a
reversible synchronous modulo 8 counter.
J
CLR
CLR
CLR
Q0
Q1
Q2
Q0
Q1
Q2
Q
Q
K
J
CK
1
(a)
CK
2
4
5
6
7
8
1
3
0
0
0
1
0
0
0
1
0
1
0
0
0
1
0
0
1
1
1
(b)
1
0
1
0
1
0
0
0
0
1
1
0
0
0
9
10
Dir
Dir
Q
Q
K
J
Q
Q
K
Figure 2.19. Reversible synchronous modulo 8 counter:
a) logic circuit; b) timing diagram
For each Ô¨Çip-Ô¨Çop, the input logic equations are given by:
‚Äì Ô¨Çip-Ô¨Çop 0: J0 = K0 = 1 ;

Binary Counters
65
‚Äì Ô¨Çip-Ô¨Çop 1: J1 = K1 = Q0 ¬∑ Dir + Q0 ¬∑ Dir ;
‚Äì Ô¨Çip-Ô¨Çop 2: J2 = K2 = Q0 ¬∑ Q1 ¬∑ Dir + Q0 ¬∑ Q1 ¬∑ Dir.
The Dir signal is used to choose the type of counting:
‚Äì Dir = 0 for counting in decreasing order;
‚Äì Dir = 1 for counting in increasing order.
Table 2.5 describes the count sequence.
Clock signal pulse
Q2
Q1
Q0
Number
Initial state
0
0
0
0
1
0
0
1
1
2
0
1
0
2
3
0
1
1
3
4
1
0
0
4
5
1
0
1
5
6
1
0
0
4
7
0
1
1
3
8
0
1
0
2
9
0
0
1
1
10
0
0
0
0
Table 2.5. Table describing the counter sequence
2.8. Decoding a down counter
To control the sequence of operation or the display of the numbers represented by
Ô¨Çip-Ô¨Çop states, a decoder must be associated with the counter.
An asynchronous three-bit counter with a decoder is depicted in Figure 2.20. Each
decoder output Yi (i = 0, 1, 2, 3, 4, 5, 6, 7) is only in the high state when the count
result is equal to i. We thus have:
Y0 = Q2 ¬∑ Q1 ¬∑ Q0
[2.6]
Y1 = Q2 ¬∑ Q1 ¬∑ Q0
[2.7]
Y2 = Q2 ¬∑ Q1 ¬∑ Q0
[2.8]
Y3 = Q2 ¬∑ Q1 ¬∑ Q0
[2.9]
Y4 = Q2 ¬∑ Q1 ¬∑ Q0
[2.10]

66
Digital Electronics 2
Y5 = Q2 ¬∑ Q1 ¬∑ Q0
[2.11]
Y6 = Q2 ¬∑ Q1 ¬∑ Q0
[2.12]
and:
Y7 = Q2 ¬∑ Q1 ¬∑ Q0
[2.13]
J
CLR
CLR
CLR
Y0
Y1
Y2
Y3
Y4
Y5
Y6
Y7
Q2
Q1
Q0
Q
Q
K
J
Q
Q
K
J
CK
1
Q
Q
K
Figure 2.20. Asynchronous three-bit counter with a decoder
In general, for binary counters the number of inputs for the AND gates that make
up the decoder increases with the modulo.
2.9. Exercises
EXERCISE 2.1.‚Äì Design an asynchronous modulo 6 counter.

Binary Counters
67
EXERCISE 2.2.‚Äì Asynchronous counter using D Ô¨Çip-Ô¨Çop:
a) verify that the logic circuits shown in Figures 2.21(a) and 2.21(b), where the
clock signal input, CK, is used as the T input, are equivalent to a T Ô¨Çip-Ô¨Çop;
b) complete the timing diagram shown in Figure 2.21(c);
c) for the asynchronous counter shown in Figure 2.22(a), complete the timing
diagram in Figure 2.22(b) and deduce the modulo. We will assume that the counter
is initially set to 0.
(b)
Q
Q
K
J
CK
1
Q
Q
Q
D
CK
Q
CK
Q
(c)
(a)
Figure 2.21. a) and b) Logic circuit; c) timing diagram
D
0
Q1
Q2
CLR
CLR
CLR
Q2
Q1
Q0
(a)
(b)
CK
2
4
5
6
7
8
1
3
Q
Q
D
CK
Q
Q
D
Q
Q
Q
Figure 2.22. a) Logic circuit of the counter; b) timing diagram
EXERCISE 2.3.‚Äì The counter shown in Figure 2.23 is initially set to 1 (thus, Q1Q0 =
11).
Q
Q
K
J
1
1
Q
Q
K
J
0
1
CK
Figure 2.23. Counter using two JK Ô¨Çip-Ô¨Çops
Neglecting the propagation delays, determine the count sequence after Ô¨Åve pulses
of the clock signal.
Represent the state diagram of the counter.

68
Digital Electronics 2
EXERCISE 2.4.‚Äì Asynchronous circuit using two Ô¨Çip-Ô¨Çops.
The asynchronous circuit shown in Figure 2.24(a) consists of two D Ô¨Çip-Ô¨Çops and
a NAND gate.
Dn
B
Up
PR
CLR
Q
D
Q
PR
CLR
Q
D
Q
Up
Dn
1
1
A
(a)
(b)
B
A
Figure 2.24. a) Asynchronous circuit using two Ô¨Çip-Ô¨Çops;
b) timing diagram
Complete the timing diagram as shown in Figure 2.24(b).
What function does this circuit serve?
EXERCISE 2.5.‚Äì Counter using three Ô¨Çip-Ô¨Çops.
CK
CLR
CLR
CLR
Q0
Q1
Q2
Q0
Q1
Q2
Q
Q
K
J
Q
Q
K
J
Q
Q
K
J
1
1
(a)
CK
(b)
Figure 2.25. a) Counter using three Ô¨Çip-Ô¨Çops; b) timing diagram
Consider the counter shown in Figure 2.25(a), whose Ô¨Çip-Ô¨Çops are initially set to 0:
‚Äì determine the logic equations for the J and K inputs of each Ô¨Çip-Ô¨Çop;
‚Äì complete the timing diagram in Figure 2.25(b);
‚Äì construct the state diagram of the counter;
‚Äì deduce the counter modulo.

Binary Counters
69
EXERCISE 2.6.‚Äì Counter using four Ô¨Çip-Ô¨Çops.
Give the timing diagram for the counter shown in Figure 2.26, assuming that all
the Ô¨Çip-Ô¨Çops are initially set to 0.
Modify the counter shown in Figure 2.26 by adding a set input (PR) and a reset
input (CLR), which, when activated, determine the state: Q3Q2Q1Q0 = 1010.
CK
3
Q2
Q1
Q0
Q
Q
K
J
Q
Q
K
J
1
Q
Q
K
J
Q
Q
K
J
PR
CLR
PR
CLR
PR
CLR
PR
CLR
Q
Figure 2.26. Logic circuit for a four-bit counter
EXERCISE 2.7.‚Äì Counter using three JK Ô¨Çip-Ô¨Çops.
CK
CLR
CLR
CLR
Q0
Q1
Q2
Q
Q
K
J
1
Q
Q
K
J
Q
Q
K
J
Figure 2.27. Logic circuit for a counter using three JK Ô¨Çip-Ô¨Çops
Consider the logic circuit of the counter shown in Figure 2.27:
‚Äì determine the logic equations for the inputs of each Ô¨Çip-Ô¨Çop;
‚Äì give the timing diagram for the counter assuming that all the Ô¨Çip-fops are initially
reset to 0;
‚Äì give the state diagram for the counter;
‚Äì deduce the counter modulo.

70
Digital Electronics 2
EXERCISE 2.8.‚Äì Synchronous D Ô¨Çip-Ô¨Çop counter.
For the counter shown in Figure 2.28, determine the logic equation of the input for
each Ô¨Çip-Ô¨Çop and construct the transition table. We will assume that the initial state of
each counter is 0.
CLR
0
Q1
Q2
CLR
Q
Q
D
CLR
CK
Q
Q
D
Q
Q
Q
D
Figure 2.28. Logic circuit for the synchronous D Ô¨Çip-Ô¨Çop counter
Deduce the counter modulo.
EXERCISE 2.9.‚Äì The counter shown in Figure 2.29 is initially set to 0 (that is
Q2Q1Q0 = 000).
a) Determine the logic expressions for the inputs J0, K0, J1, K1, J2 and K2.
b) Derive the state diagram for this counter.
CK
Q
Q
K
J
PR
CLR
0
Q
Q
K
J
PR
CLR
1
Q
Q
K
J
PR
CLR
2
Figure 2.29. Logic circuit for the counter using JK Ô¨Çip-Ô¨Çops
EXERCISE 2.10.‚Äì The counter shown in Figure 2.30(a) is initially set to 0 (in other
words Q2Q1Q0 = 001):
‚Äì determine the logic expressions for the inputs J0, K0, J1, K1, J2 and K2;
‚Äì complete the timing diagram shown in Figure 2.30(b);
‚Äì determiner Q2 Q1 Q0 when the diode D7 is switched on;

Binary Counters
71
‚Äì can the counter simultaneously switch on both the diodes, D2 and D7?
D7
+Vcc
Q
Q
K
J
PR
CLR
0
Q
Q
K
J
PR
CLR
1
Q
Q
K
J
PR
CLR
2
1
R
R
X
Y
CK
Q0
Q1
Q2
X
Y
(a)
CK
D
(b)
2
Figure 2.30. a) Counter connected to D1 and D2
diodes; b) timing diagram
EXERCISE 2.11.‚Äì Synchronous counter.
The synchronous counter shown in Figure 2.31 consists of a debouncing switch
(S), a D Ô¨Çip-Ô¨Çop for data synchronization on the falling edge of the clock signal and a
counter circuit with a reset push button.
Determine the logic equations for the inputs, D1 and D0, and the outputs, Y1 and
Y0, as functions of X, Q1 and Q0.
Complete the timing diagram given in Figure 2.32 and 2.33.
What is the function of the switch S?
Complete the output decoding table given in Table 2.6.
EXERCISE 2.12.‚Äì Temporization circuit for a quartz clock.
An m modulo counter can be implemented, as shown in Figure 2.34, with a reset
input, CLR, an enable input, EN, and a ripple-carry output, RCO.

72
Digital Electronics 2
CLR
R
VCC
VCC
VCC
Y3
Y0
Y1
Y2
BP
Q
X
S
R
R
PR
CLR
Q
D
Q
1
0
PR
CLR
Q
D
Q
PR
CLR
Q
D
Q
0
1
CK
R
S
Q
R
Figure 2.31. Synchronous circuit
CK
Q
R
S
X
Figure 2.32. Timing diagram 1
X
Q1
Q0
Y3
Y2
Y1
Y0
0
x
x
1
0
0
1
0
1
1
1
0
1
1
1
Table 2.6. Output decoding table

Binary Counters
73
CK
CLR
D1
D0
Q1
Q0
X
Figure 2.33. Timing diagram 2
Mod m
RCO
Q1 Q0
EN
CLR
Qn
counter
Figure 2.34. Modulo m counter
Determine the relationship that exists between the modulo, m, and the number of
bits, n.
Using a quartz oscillator, which yields a clock signal, CK, whose frequency is
65, 536 Hz and using modulo 16, 10, 6 and 4 counters, implement a temporization
circuit that can generate a signal for each day (D), each hour (H), each minute (M)
and each second (S).
2.10. Solutions
SOLUTION 2.1.‚Äì Asynchronous modulo 6 counter.
Figure 2.35 shows the logic circuit for an asynchronous modulo 6 counter. The
NAND gate detects the combinations Q2Q1Q0 taking the form 110 (6) or 111 (7) to
initiate the Ô¨Çip-Ô¨Çops reset.
SOLUTION 2.2.‚Äì Asynchronous D Ô¨Çip-Ô¨Çop.
For the logic circuit shown in Figure 2.36(a), we have:
J = K = 1
and
Q+ = J ¬∑ Q + K ¬∑ Q = Q

74
Digital Electronics 2
and for the logic circuit shown in Figure 2.36(b), we have:
D = Q
and
Q+ = D = Q
CLR
0
Q1
Q2
Q
Q
K
J
CLR
Q
Q
Q
K
J
1
CK
Q
Q
K
J
CLR
CLR
Figure 2.35. Asynchronous modulo 6 counter
They then operate in toggle mode or like a T Ô¨Çip-Ô¨Çop, as illustrated by the timing
diagram shown in Figure 2.36(c).
(b)
CK
Q
(c)
Q
Q
K
J
CK
1
Q
Q
Q
D
CK
Q
(a)
Figure 2.36. a) and b) Logic circuit; c) timing diagram
The timing diagram for the counter in Figure 2.37(a) is represented in
Figure 2.37(b). As the count cycle has eight distinct states, the counter modulo is
equal to 8.
1
CLR
CLR
CLR
Q2
Q1
Q0
Q0
Q1
Q2
(a)
(b)
Q
Q
D
CK
Q
Q
D
Q
Q
D
CK
2
4
5
6
7
8
1
3
0
0
0
1
0
0
0
1
0
1
0
0
0
1
1
0
1
0
1
1
1
1
1
0
0
0
Figure 2.37. a) Logic circuit of the counter;
b) timing diagram

Binary Counters
75
SOLUTION 2.3.‚Äì Counter using two Ô¨Çip-Ô¨Çops.
For each of the counter‚Äôs Ô¨Çip-Ô¨Çops, the input equations are given by:
‚Äì Ô¨Çip-Ô¨Çop 0: J0 = Q1
and
K0 = 1;
‚Äì Ô¨Çip-Ô¨Çop 1: J1 = Q0
and
K1 = 1.
Table 2.7 shows the transition table. The state diagram is given in Figure 2.38.
Q1
Q0
J1K1
J0K0
Q+
1
Q+
0
1
1
1 1
0 1
0
0
0
0
0 1
1 1
0
1
0
1
1 1
1 1
1
0
1
0
0 1
0 1
0
0
Table 2.7. Transition table for the counter
state :
00
01
11
Q Q0
1
10
Figure 2.38. State diagram for the counter
SOLUTION 2.4.‚Äì Asynchronous circuit using two Ô¨Çip-Ô¨Çops.
Figure 2.39 depicts an asynchronous circuit using two Ô¨Çip-Ô¨Çops and the
corresponding timing diagram.
By analyzing the timing diagram, we can determine which of the two signals, A
or B, is in advance or delayed. This is, thus, a phase detector.
SOLUTION 2.5.‚Äì Counter using three Ô¨Çip-Ô¨Çops.
By referring to the counter‚Äôs logic circuit, we obtain the following logic equations:
‚Äì Ô¨Çip-Ô¨Çop 0: J0 = Q2 and K0 = 1;
‚Äì Ô¨Çip-Ô¨Çop 1: J1 = Q0 and K1 = Q0;
‚Äì Ô¨Çip-Ô¨Çop 2: J2 = Q1 ¬∑ Q0 and K2 = 1.

76
Digital Electronics 2
B
(a)
(b)
A
B
Up
Dn
PR
CLR
Q
D
Q
PR
CLR
Q
D
Q
Up
Dn
1
1
A
Figure 2.39. a) Asynchronous circuit using two Ô¨Çip-Ô¨Çops;
b) timing diagram
Figure 2.40(a) depicts a timing diagram, where Ô¨Åve different states can be
differentiated. As the counter uses three Ô¨Çip-Ô¨Çops, the next states corresponding to
the three unused states (101, 110, and 111) must be determined.
state :
111
110
101
Q0
Q2
Q1
Q2Q1Q0
CK
(b)
(a)
0
0
0
0
0
0
0
0
1
1
0
0
1
0
1
0
1
0
001
010
011
100
000
Figure 2.40. a) Timing diagram; b) state diagram
Table 2.8 depicts the transition table for the unused states.
PS
Inputs
NS
Q2Q1Q0
J2K2
J1K1
J0K0
Q+
2 Q+
1 Q+
0
1 0 1
0 1
1 1
0 1
0
1
0
1 1 0
0 1
0 0
0 1
0
1
0
1 1 1
1 1
1 1
0 1
0
0
0
Table 2.8. Transition table for the unused states
(PS, present state; NS, next state)

Binary Counters
77
The state diagram for the counter is given in Figure 2.40(b).
This is a 5 modulo counter.
SOLUTION 2.6.‚Äì Counter using four Ô¨Çip-Ô¨Çops.
The logic equations for the inputs of the Ô¨Çip-Ô¨Çops are given by:
‚Äì Ô¨Çip-Ô¨Çop 0: J0 = K0 = 1;
‚Äì Ô¨Çip-Ô¨Çop 1: J1 = K1 = Q0;
‚Äì Ô¨Çip-Ô¨Çop 2: J2 = K2 = Q1 ¬∑ Q0;
‚Äì Ô¨Çip-Ô¨Çop 3: J2 = K2 = Q2 ¬∑ Q1 ¬∑ Q0.
Based on the timing diagram in Figure 2.41, it is possible to deduce that this is a
16 modulo counter.
15
0
Q1
Q2
Q3
CK
1
0
0
1
0
1
1
1
0
0
1
0
1
0
1
0
1
1
0
0
1
1
0
0
1
1
0
0
1
1
1
1
1
1
1
1
1
0
0
0
0
0
0
0
1
0
0
0
1
1
1
1
0
0
0
1
1
1
1
0
0
0
0
0
0
0
0
0
2
4
5
6
7
8
1
3
9
10
11
12
13
14
16
Q
Figure 2.41. Timing diagram
Figure 2.42 depicts the logic circuit for the modiÔ¨Åed counter as well as a
representation of the PR and CLR signals.
CLR
0
Q1
Q2
Q3
PR
PR
Q
Q
K
J
Q
Q
K
J
Q
Q
K
J
Q
Q
K
J
PR
CLR
PR
CLR
PR
CLR
PR
CLR
CK
1
CLR
Q
Figure 2.42. Logic circuit for the modiÔ¨Åed counter. For a color version
of this Ô¨Ågure, see www.iste.co.uk/ndjountche/electronics2.zip

78
Digital Electronics 2
SOLUTION 2.7.‚Äì Counter using three Ô¨Çip-Ô¨Çops.
By analyzing the logic circuit for the counter, we obtain the following logic
equations:
‚Äì Ô¨Çip-Ô¨Çop 0: J0 = K0 = 1;
‚Äì Ô¨Çip-Ô¨Çop 1: J1 = Q2 ¬∑ Q0 and K1 = Q0;
‚Äì Ô¨Çip-Ô¨Çop 2: J2 = Q1 ¬∑ Q0 and K2 = Q0.
Figure 2.43(a) depicts the timing diagram of the counter. The states 110 and 111
are unused. The transition table for the unused states is given in Table 2.9.
Figure 2.43(b) shows the state diagram of the counter. Because the count cycle
consists of six different states, it is a modulo 6 counter.
6
0
Q1
Q2
CK
0
0
0
0
1
0
0
0
1
0
1
1
1
0
0
1
1
0
0
0
0
 1
 2
  3
4
5
Q
Figure 2.43. Timing diagram of the counter
state :
110
111
000
101
100
011
010
001
2
Q0
Q1
Q
Figure 2.44. State diagram of the counter
SOLUTION 2.8.‚Äì Synchronous D Ô¨Çip-Ô¨Çop counter.
The analysis of the logic circuit of the counter yields the following equations:

Binary Counters
79
‚Äì Ô¨Çip-Ô¨Çop 0: D0 = Q0;
‚Äì Ô¨Çip-Ô¨Çop 1: D1 = Q1 ¬∑ Q0 + Q1 ¬∑ Q0;
‚Äì Ô¨Çip-Ô¨Çop 2: .
PS
Inputs
NS
Q2Q1Q0
J2K2
J1K1
J0K0
Q+
2 Q+
1 Q+
0
1 1 0
0 0
0 0
1 1
1
1
1
1 1 1
1 1
0 1
1 1
0
0
0
Table 2.9. Transition table for the unused states
Because we have Q+ = D for a D Ô¨Çip-Ô¨Çop, we can construct the transition table
given in Table 2.10.
PS
Inputs
NS
Q2Q1Q0
D2
D1
D0
Q+
2 Q+
1 Q+
0
0 0 0
0
0
1
0 0 1
0 0 1
0
1
0
0 1 0
0 1 0
0
1
1
0 1 1
0 1 1
1
0
0
1 0 0
1 0 0
1
0
1
1 0 1
1 0 1
1
1
0
1 1 0
1 1 0
1
1
1
1 1 1
1 1 1
0
0
0
0 0 0
Table 2.10. Transition table (PS, present state; NS: next state)
The count cycle is composed of eight different states, corresponding to the
numbers from 0 to 7. The modulo for the counter is, thus, equal to 8.
SOLUTION 2.9.‚Äì The input equations for the Ô¨Çip-Ô¨Çops are written as follows:
‚Äì Ô¨Çip-Ô¨Çop 0: J0 = Q2 ‚äïQ1
and
K0 = Q2 ‚äïQ1 ;
‚Äì Ô¨Çip-Ô¨Çop 1: J1 = Q2 ¬∑ Q0
and
K1 = Q2 ¬∑ Q0 ;
‚Äì Ô¨Çip-Ô¨Çop 2: J2 = Q1 ¬∑ Q0
and
K2 = Q1 ¬∑ Q0.
The transition table of the counter is represented in Table 2.11. Figure 2.45
depicts the state diagram. The count cycle consists of eight different states.

80
Digital Electronics 2
Furthermore, because the successive states differ by only one bit, this is a modulo 8
Gray counter.
SOLUTION 2.10.‚Äì The logic equations for the inputs of the Ô¨Çip-Ô¨Çops are given by:
‚Äì Ô¨Çip-Ô¨Çop 0: J0 = K0 = 1;
‚Äì Ô¨Çip-Ô¨Çop 1: J1 = K1 = Q0;
‚Äì Ô¨Çip-Ô¨Çop 2.
PS
Inputs
NS
Q2 Q1 Q0
J2K2
J1K1
J0K0
Q+
2 Q+
1 Q+
0
0
0
0
0 1
0 0
1 0
0
0
1
0
0
1
0 0
1 0
1 0
0
1
1
0
1
1
0 0
1 0
0 1
0
1
0
0
1
0
1 0
0 0
0 1
1
1
0
1
1
0
1 0
0 0
1 0
1
1
1
1
1
1
0 0
0 1
1 0
1
0
1
1
0
1
0 0
0 1
0 1
1
0
0
1
0
0
0 1
0 0
0 1
0
0
0
Table 2.11. Transition table (PS, present state; NS, next state)
state :
010
110
011
111
101
100
000
001
initial state
2
Q0
1
Q
Q
Figure 2.45. State diagram
For the outputs connected to the diodes, we have:
X = Q2 ¬∑ Q1 ¬∑ Q0
[2.14]
Y = Q2 ¬∑ Q1 ¬∑ Q0
[2.15]

Binary Counters
81
0
CK
Q0
Q1
Q2
X
Y
1
2
3
4
5
6
7
8
0
1
0
1
0
0
1
1
0
0
0
1
1
0
1
0
1
1
1
1
1
0
0
Figure 2.46. Timing diagram
Figure 2.46 depicts the timing diagram of the counter.
D7 is switched on when Q2Q1Q0 = 111.
Based on the timing diagram, the counter cannot simultaneously switch on both
diodes.
SOLUTION 2.11.‚Äì Synchronous counter.
By analyzing the logic circuit of the counter, we obtain the following equations:
D0 = X ¬∑ Q0 + X ¬∑ Q0
[2.16]
D1 = X ¬∑ Q1 ¬∑ Q0 + Q1 ¬∑ Q0 + X ¬∑ Q1
[2.17]
Y3 = X ¬∑ Q1 ¬∑ Q0
[2.18]
Y2 = X ¬∑ Q1 ¬∑ Q0
[2.19]
Y1 = X ¬∑ Q1 ¬∑ Q0
[2.20]
Y0 = X ¬∑ Q1 ¬∑ Q0
[2.21]
Figure 2.47 depicts timing diagram 1. Bounces of the switch S are eliminated by
the Ô¨Çip-Ô¨Çop S R, while the signal X is synchronized to the falling edge of the clock
signal by the D Ô¨Çip-Ô¨Çop.
Figure 2.48 depicts timing diagram 2. The counting commences when the signal
X takes the logic state 1 and stops when the signal X is reset.

82
Digital Electronics 2
CK
Q
R
S
X
Figure 2.47. Timing diagram 1
CK
CLR
D1
D0
Q1
Q0
X
Figure 2.48. Timing diagram 2
The switch S is, thus, used to turn on and off the counter.
The table for output decoding is given in Table 2.12.
X
Q1
Q0
Y3
Y2
Y1
Y0
0
x
x
0
0
0
0
1
0
0
0
0
0
1
1
0
1
0
0
1
0
1
1
0
0
1
0
0
1
1
1
1
0
0
0
Table 2.12. Table for output decoding

Binary Counters
83
SOLUTION 2.12.‚Äì Temporization of a quartz clock.
It is possible to establish the following relationship between the modulo, m, and
the number of bits, n:
n = ‚åàlog(m)/ log(2)‚åâ
[2.22]
where ‚åàx‚åârepresents the smallest integer greater than or equal to x.
Figure 2.49 depicts the temporization circuit for the quartz clock.
Mod 4
Q3 Q2 Q1 Q0
Q3 Q2 Q1 Q0
Q3 Q2 Q1 Q0
Q3 Q2 Q1 Q0
Q2 Q1 Q0
Q2 Q1 Q0
Q2 Q1 Q0
Q1 Q0
Q3 Q2 Q1 Q0
Q3 Q2 Q1 Q0
EN
RCO
CLR
EN
RCO
CLR
EN
RCO
CLR
EN
RCO
CLR
EN
RCO
CLR
counter
counter
counter
counter
counter
counter
counter
counter
counter
EN
RCO
CLR
EN
RCO
CLR
EN
RCO
CLR
M
CK
1
S
H
J
EN
RCO
CLR
EN
RCO
CLR
Mod 16
Mod 16
Mod 16
Mod 10
counter
Mod 16
Mod 6
Mod 10
Mod 6
Mod 6
Figure 2.49. Temporization circuit


3
Shift Register
3.1. Introduction
Shift registers are used to shift bit positions of data words either to the left or to the
right. They are used in data storage and transfer applications. Unlike binary counters,
shift registers do not have a speciÔ¨Åc sequence of states.
A register composed of n Ô¨Çip-Ô¨Çops possesses the storage capacity for a binary
word of n bits. There are different types of registers depending on the mode of access
(series or parallel) to the register (for read and write operations).
3.2. Serial-in shift register
A shift register is implemented by serially connecting D Ô¨Çip-Ô¨Çops activated by the
same clock signal. Figure 3.1 depicts a 5-bit shift register. Data bits applied to the
serial input (SI) are transferred from one Ô¨Çip-Ô¨Çop to another at the edge of each clock
pulse. Signals that appear at the parallel outputs or at the outputs of different Ô¨Çip-Ô¨Çops
are identical but delayed with respect to each other, while data are available as a serial
sequence at the output of the last Ô¨Çip-Ô¨Çop. The timing diagram shown in Figure 3.2
illustrates the temporization function carried out by a shift register.
3.3. Parallel-in shift register
A shift register can be implemented with synchronous inputs, which, if necessary,
can be used to modify its content as shown in Figure 3.3. In this case, the operating
mode of the shift register depends on the state of the enable signal En:
‚Äì when En is low, the gates 1, 2 and 3 are activated and the gates 4, 5 and 6 are
deactivated. Each Di (i = 1, 2, 3) bit can thus be applied to the data input of the
corresponding Ô¨Çip-Ô¨Çop;
Digital Electronics 2: Sequential and Arithmetic Logic Circuits, First Edition. Tertulien Ndjountche. 
¬© ISTE Ltd 2016. Published by ISTE Ltd and John Wiley & Sons, Inc. 

86
Digital Electronics 2
‚Äì when En is high, gates 1, 2 and 3 are deactivated and gates 4, 5 and 6 are
activated, thereby enabling the shift-right operation. D0 can be considered as a SI and
Q3 can be regarded as a serial output (SO).
2
CK
CLR
CLR
CLR
CLR
Q0
Q1
Q2
Q3
D0
Q3
Q3
Q
Q
D
Q
Q
D
Q
Q
D
Q
Q
D
Parallel outputs :
Serial output :
and
Q0 ,
1
Q , Q
Figure 3.1. Shift register
CK
0
Q3
Q2
Q1
D0
Q
Figure 3.2. Timing diagram
En
CLR
CLR
CLR
CLR
Q0
Q1
Q2
Q3
D0
D1
D2
D3
Q
Q
D
Q
Q
D
Q
Q
D
Q
Q
D
4
1
5
2
6
3
CK
Figure 3.3. Parallel-in serial-out shift register

Shift Register
87
Table 3.1 depicts the functional truth table of the parallel-in serial-out shift register.
A timing diagram is given in Figure 3.4 assuming that the Ô¨Çip-Ô¨Çops are initially set
to 0.
Inputs
Q3
Q3
+
D3
Q2
Q3
Q1
Q2
+
Q2
D2
Q2
Q0
Q1
D1
Q1
Q1
+
Q0
D0
D0
Q0
0
Q+
CK
1
0
1
x
x
0
En
Load
Right shift
Hold
NS
Table 3.1. Functional truth table (NS, next state)
En
2
D1
D0
D3
Q0
Q1
Q2
Q3
CK
D
Figure 3.4. Timing diagram
Some applications require shift registers that can be enabled or disabled. Figure 3.5
depicts the logic circuit of a parallel-in serial-out shift register with an enable signal.
To allow the realization of additional functions, the shift register is implemented by
combining 2 : 1 multiplexers with D Ô¨Çip-Ô¨Çops.

88
Digital Electronics 2
Load
0
1
1
0
Q
Q
D
CLR
2
0
1
1
0
Q
Q
D
CLR
3
0
1
1
1
2
2
3
3
1
0
Q
Q
D
CLR
0
CLR
CK
0
1
1
0
0
L
En
Q
Q
D
CLR
1
0
X
Q
X
X
Q
X
Q
X
Q
Figure 3.5. Parallel-in serial-out shift register with enable signal
The functional truth table is given in Table 3.2. The transfer of the input data takes
place when the clock signal transitions from low to high. It must be noted that the
input XL can be considered as a SI and the output Q3 as a SO.
Reset
Q3
+
0
Q+
Q1
+
Q2
+
x
0
0
1
1
x
Inputs
Left shift
NS
Hold
Load
3
0
1
2
0
1
2
3
0
1
2
L
CK
CLR
0
x
1
En
x
0
0
0
0
0
1
1
Load
Q
Q
X
Q
X
Q
X
X
Q
Q
Q
X
Table 3.2. Functional truth table of the parallel-in serial-out
shift register with an enable signal (NS, next state)
3.4. Bidirectional shift register
A bidirectional shift register can be used to shift data bits toward the left or the
right based on the logic state of a control signal.
A four-bit bidirectional shift register is illustrated in Figure 3.6. Its operation can
be described as follows:
‚Äì when the control input Sh is at the high logic state, the gates 1, 2, 3 and 4
are activated, enabling the application of the input signal to the Ô¨Årst Ô¨Çip-Ô¨Çop and the

Shift Register
89
connection of the output Q of each Ô¨Çip-Ô¨Çop to the D input of the next Ô¨Çip-Ô¨Çop. Data
bits are shifted by one position to the right at the rising edge of the clock signal;
‚Äì when the control input Sh is at the low logic state, the gates 5, 6, 7 and 8 are
activated, enabling the connection of the output Q of each Ô¨Çip-Ô¨Çop to the D input of
the preceding Ô¨Çip-Ô¨Çop. Data bits are shifted by one position to the left at the rising
edge of the clock signal.
CK
CLR
CLR
CLR
CLR
Q0
Q1
Q2
Q3
D0
Q
Q
Q
Q
D
Q
Q
D
Q
Q
D
D
D
1
5
2
6
3
7
4
8
Sh
Figure 3.6. Bidirectional shift register
Table 3.1 depicts the functional truth table of the bidirectional shift register.
Assuming that the Ô¨Çip-Ô¨Çops are initially set to 0, the timing diagram can be
represented as shown in Figure 3.7.
NS
D0
Q1
Q0
Q0
0
Q+
Q2
Q3
+
D0
Q3
Q3
Q1
Q2
+
Q3
Q2
Q2
Q0
Q2
Q1
Q1
Q1
+
CK
Sh
1
Inputs
0
0
x
1
x
Right shift
Left shift
Hold
Table 3.3. Functional truth table (NS, next state)

90
Digital Electronics 2
Sh
0
Q1
Q2
Q3
D0
CK
Q
Figure 3.7. Timing diagram
3.5. Register Ô¨Åle
A register Ô¨Åle is composed of Ô¨Çip-Ô¨Çops organized into a two-dimensional array. It
has the advantage of having a regular structure and can be used by the central unit of
a processor to temporarily store data.
In general, a register Ô¨Åle has 2n lines of m Ô¨Çip-Ô¨Çops and each of these lines can be
considered as a register that can contain a binary word.
The structure of a register Ô¨Åle with a write input and two read outputs is shown in
Figure 3.8. It uses Ô¨Çip-Ô¨Çops and 2 : 4 decoders with active-low enable signal (WE,
REA and REB). The input data are words with four bits, D3, D2, D1 and D0, just
like the output data, A3, A2, A1 and A0 for port A, or B3, B2, B1 and B0 for port B.
Write address bits, WA1 and WA0, are decoded in order to identify which Ô¨Çip-Ô¨Çops
to select for storage, while the decoding of the read address bits, RAA1 and RAA0
for port A, or RAB1 and RAB0 for port B, is useful for the selection of the Ô¨Çip-Ô¨Çops
that supply the data to be read. The addressing table for data words can be represented
as shown in Table 3.4.
Write
Reading
Read
operation
operation for port A
operation for port B
WA1
WA0
RAA1
RAA0
RAB1
RAB0
Word 0
0
0
0
0
0
0
Word 1
0
1
0
1
0
1
Word 2
1
0
1
0
1
0
Word 3
1
1
1
1
1
1
Table 3.4. Data word addressing table

Shift Register
91
2:4 Decoder
1
0
2
3
D3
D2
D1
D0
WA1
WA 0
B3
B0
B1
B2
Di
Di
WSi
WSi
i
RAB0
RAB1
1
2:4 Decoder
3
2
0
1
2:4 Decoder
0
2
3
WE
REB
REA
RAA 1
A3
A2
A1
A0
RAA 0
CK
PBi
PAi
PBi
A i
Bi
A i
Bi
PA
Q
D
Q
Figure 3.8. Register Ô¨Åle
The input WE must be set to 0 to allow the write operation of a word whose
address is speciÔ¨Åed. When this condition is not satisÔ¨Åed, the state of the Ô¨Çip-Ô¨Çops
remains unchanged. At least one of the inputs, REA and REB, must be set to 0 in
conjunction with a valid address to allow a word to be read. When one of the inputs,
REA or REB, is set to 1, the corresponding output takes a high impedance state.
3.6. Shift register based counter
A counter can be implemented by connecting the input and output of a shift register
to generate a given bit sequence.

92
Digital Electronics 2
3.6.1. Ring counter
A ring counter, which is depicted in Figure 3.9, uses a Ô¨Çip-Ô¨Çop for each state in its
count sequence. The output of the right-most Ô¨Çip-Ô¨Çop is connected to the input of the
left-most Ô¨Çip-Ô¨Çop, thus forming a ring or loop.
Q
0
Q1
Q2
Q3
PR
PR
PR
PR
Q
Q
D
CLR
Q
D
CLR
CK
0
1
Q
Q
D
CLR
2
Q
Q
D
CLR
3
Q
Figure 3.9. Four-bit ring counter
Assuming Q3Q2Q1Q0 = 0001 is the initial state of the counter, we can draw the
timing diagram shown in Figure 3.10. The logic state 1 is circularly shifted from one
Ô¨Çip-Ô¨Çop to another at the rising edge of each clock pulse. The four outputs of the Ô¨Çip-
Ô¨Çops indicate the clock pulse number. Thus, Q0 = 1 corresponds to 0, Q1 = 1 to 1,
Q2 = 1 to 2 and Q3 = 1 to 3.
Initial state
0
Q2
Q3
Q1
CK
1
2
3
1
2
3
0
Q
Figure 3.10. Timing diagram illustrating two cycles of the counter
Starting with the initial state, Q3Q2Q1Q0 = 0011 or Q3Q2Q1Q0 = 0111, we
also obtain a count sequence with four states as shown in the timing diagram in
Figure 3.11.
The maximum modulo is equal to the number of different states of the ring counter.
For example, from the initial state Q3Q2Q1Q0 = 0001, four different states, 0001,
0010, 0100 and 1000, can be generated, while the initial state Q3Q2Q1Q0 = 0101 is
associated with only two different states: 0101 and 1010.

Shift Register
93
8
0011
3
0110
1100
1001
6
12
9
0001
1
0010
0100
4
2
1111
15
0000
0
0111
7
1110
1101
14
13
1011
1000
0101
5
10
1010
11
Figure 3.11. State diagram of the four-bit ring counter
However, the ring counter remains indeÔ¨Ånitely in the state Q3Q2Q1Q0 = 0000 or
Q3Q2Q1Q0 = 1111.
In general, a ring counter made up of n Ô¨Çip-Ô¨Çops has a maximum modulo equal
to n.
3.6.2. Johnson counter
To implement a Johnson counter, the logical complement of the output of the last
Ô¨Çip-Ô¨Çop is applied to the input of the Ô¨Årst Ô¨Çip-Ô¨Çop. This feedback connection helps
produce a characteristic count sequence.
A four-bit Johnson counter is represented in Figure 3.12. Assuming that all the
Ô¨Çip-Ô¨Çops are initially reset, the count sequence is composed of eight distinct states, as
shown in the timing diagram in Figure 3.13. Unlike the ring counter, a decoder must
be connected to the Johnson counter in order to identify the numbers represented by
the different logic states of the Ô¨Çip-Ô¨Çops. Table 3.5 represents the count sequence and
the decoding equations for a four-bit Johnson counter (from the zero initial condition).
For each number, there are always two Ô¨Çip-Ô¨Çops that form a unique combination in the
sequence of states of the Johnson counter. For example, the combination Q3Q0 = 00
is obtained only when the count result is 0.
Based on the state diagram shown in Figure 3.14, the four-bit Johnson counter can
operate following two possible count sequences depending on its initial state.
In general, a Johnson counter has a modulo of 2n, where n is the number of Ô¨Çip-
Ô¨Çops in the counter. The decoder has 2n two-input AND gates for a Johnson counter
that uses n Ô¨Çip-Ô¨Çops. Additionally, the number of inputs for each gate of the decoder
remains the same whatever the modulo of the counter.

94
Digital Electronics 2
Decoder
3
Q2
Q1
Q0
Y7
Y6
Y5
Y4
Y3
Y2
Y1
Y0
PR
PR
PR
PR
Q
D
CLR
1
Q
Q
D
CLR
2
Q
Q
D
CLR
3
Q
Q
D
CLR
0
Q
CK
Counter
Q
Figure 3.12. Four-bit Johnson counter with a decoder
Pulse
Q3
Q2
Q1
Q0
Output Yi
0
0
0
0
Y7 = Q3 ¬∑ Q0
1
0
0
0
1
Y6 = Q1 ¬∑ Q0
2
0
0
1
1
Y5 = Q2 ¬∑ Q1
3
0
1
1
1
Y4 = Q3 ¬∑ Q2
4
1
1
1
1
Y3 = Q3 ¬∑ Q0
5
1
1
1
0
Y2 = Q1 ¬∑ Q0
6
1
1
0
0
Y1 = Q2 ¬∑ Q1
7
1
0
0
0
Y0 = Q3 ¬∑ Q2
Table 3.5. Count sequence and decoding equations
for the four-bit Johnson counter
3.6.3. Linear feedback counter
A linear feedback shift register (LFSR) counter, also known as a pseudo-random
sequence generator, is generally used to generate signals for digital circuit testing and

Shift Register
95
cryptography. The input for this counter is a linear function (for example the XOR
function) of certain previous states.
CK
0
Q1
Q2
Q3
Y7
Y6
Y5
Y4
Y3
Y2
Y1
Y0
Q
Figure 3.13. Timing diagram of the four-bit
Johnson counter with a decoder
1100
0001
1
1000
8
0000
0
1111
15
0011
3
12
0111
7
1110
14
0101
5
1001
9
0010
2
1101
13
1011
11
0100
4
0110
6
1010
10
Figure 3.14. State diagram for the four-bit Johnson counter
3.6.3.1. Four-bit counters
Let us consider the four-bit LFSR counter shown in Figure 3.15. Beginning from
the state 1000, the counter cycles through 14 states before returning to the initial state.
Based on the state diagram shown in Figure 3.16, this counter has 24 ‚àí1 states, each
state being speciÔ¨Åed by a combination Q3Q2Q1Q0.

96
Digital Electronics 2
Init
Q3
Q0
Q2
Q1
Q
Q
D
Q
Q
D
Q
Q
D
Q
Q
D
PR
CLR
CLR
CLR
CK
Figure 3.15. Four-bit LFSR counter (external XOR) (initially, PR = 0 for
Ô¨Çip-Ô¨Çop 3 and CLR = 0 for the other Ô¨Çip-Ô¨Çops)
state
0001
1000
0100
0010
1001
1100
0110
1011
0101
1010
1101
1110
1111
0111
0011
0000
0
3
14
13
15
10
7
5
1
4
2
9
12
6
11
8
Initial
Figure 3.16. State diagram of the four-bit LFSR counter (external XOR)
Another version of the four-bit LFSR counter is represented in Figure 3.17. The
operation of this counter is described by the state diagram shown in Figure 3.18, where
each combination Q3Q2Q1Q0 designates a state.
CLR
0
Q3
Q1
Q2
Q
Q
D
PR
CK
Init
Q
Q
D
Q
Q
D
Q
Q
D
CLR
CLR
Q
Figure 3.17. Four-bit LFSR counter (initially, PR = 0 for Ô¨Çip-Ô¨Çop 0, and
CLR = 0 for the other Ô¨Çip-Ô¨Çops)
In general, an n-bit LFSR counter has 2n ‚àí1 states and a pseudo-random count
order that is, thus, different from that for a conventional binary counter.

Shift Register
97
state
1001
0001
0010
0100
1000
0011
0110
1011
0101
0111
1111
1101
0000
10
14
9
2
8
6
12
3
1100
1010
1110
13
15
7
0
5
11
1
4
Initial
Figure 3.18. State diagram of the four-bit LFSR counter (internal XOR)
3.6.3.2. Application: built-in self-test circuit
With the increase in the number of transistors on a chip, using built-in self-test
(BIST) circuits has become necessary in order to ensure quality and reliability and to
reduce production costs.
In general, the signal delivered by the circuit being tested is assumed to carry
some information corresponding to an n-bit sequence that can be represented as a
polynomial:
I(x). It is applied at the input of a signature register, which is
implemented using k Ô¨Çip-Ô¨Çops and which can be represented by the characteristic
polynomial G(x), with xk as the monomial of the highest degree. After n shifts, the
output bit sequence forms the quotient Q(x), with a length of n ‚àík, and the output
bits from the Ô¨Çip-Ô¨Çops constitute the remainder, R(x), with a length of k, which is
then called the signature. Hence:
I(x) = Q(x)G(x) + R(x)
[3.1]
where the degree of R(x) is inferior to that of G(x). When the circuit under test
exhibits an error, a corresponding polynomial error, E(x), will be added to I(x). In
this case, we have:
I(x) + E(x) = Q‚àó(x)G(x) + R‚àó(x)
[3.2]
This error can only be detected if the remainder R‚àó(x) differs from R(x). It must
be noted that the polynomials I(x) and I(x) + E(x) have the same remainder if the
error E(x) is a multiple of G(x). The higher the degree of the polynomial G(x), the
less probable it is that the error E(x) is a multiple of G(x).
The characteristic polynomial, G(x), associated with an LFSR counter or
register, can be used to describe the behavior of the output signal from the last
Ô¨Çip-Ô¨Çop. The coefÔ¨Åcients of the monomials xk and x0 always take the value 1, while

98
Digital Electronics 2
each of the other non-zero coefÔ¨Åcients is linked to the presence of an XOR gate on
the corresponding feedback path.
NOTE.‚Äì There are four different ways of representing an LFSR counter or register
with a given characteristic polynomial because the variables and coefÔ¨Åcients can be
assigned from left to right or from right to left.
In principle, the BIST consists of applying a sequence of bits to the input of the
circuit under test in order to analyze the output response. The sequence of input bits is
generated by an LFSR counter. A signature register followed by a signature analyzer
can be used to detect the presence of certain anomalies in the sequence of output bits.
Figure 3.19 depicts the implementation of a BIST for a combinational circuit
consisting of four logic gates. The initialization signal is represented by Init, the T/T
signal is used to select the circuit‚Äôs operating mode (BIST or normal), and the OK
signal is set to 1 when no error is detected. The state diagram of the signal generator
(three-bit LFSR counter) is illustrated in Figure 3.20.
Signature register
0
x1
x2
x3
x0
C
X
1
0
EC
SX
DMUX
1
0
MUX
EB
Q
Q
D
Q
Q
D
CLR
PR
CK
Signal generator
2
1
Init
Circuit under test
x
1
0
MUX
1
0
MUX
EA
T / T
x 3
x1
x 2
Q
Q
D
CLR
0
Q
Q
D
Q
Q
D
CLR
CLR
Q
Q
D
CLR
0
1
2
OK
A
B
Figure 3.19. Example of a BIST for a combinational circuit
APPLICATION.‚Äì The characteristic polynomial for the signature register is written
as:
G(x) = x3 + x + 1

Shift Register
99
state
001
100
010
101
110
111
011
0
3
6
7
1
Initial
2
4
000
5
Figure 3.20. State diagram for the three-bit LFSR counter
The bit sequence successively applied to the input X is 0110010 and corresponds
to the polynomial:
I(x) = 0 ¬∑ x0 + x + x2 + 0 ¬∑ x3 + 0 ¬∑ x4 + x5 + 0 ¬∑ x6
= x5 + x2 + x
Dividing I(x) by G(x), we can obtain the quotient, Q(x), and the remainder R(x).
x5 +
x2 + x
x3 + x + 1
x5 + x3 + x2
x2 + 1
‚ÜêQuotient
x3 +
x
x3 +
x + 1
1
‚ÜêRemainder
Thus, Q(x) = x2 + 1 and R(x) = 1. The remainder corresponds to the signature
in polynomial form.
If, on the other hand, a short-circuit always sets the output of the inverter to 1
regardless of the input bit, A, the bit sequence at the input X becomes 0111010. The
corresponding polynomial then takes the following form:
I(x) + E(x) = 0 ¬∑ x0 + x + x2 + x3 + 0 ¬∑ x4 + x5 + 0 ¬∑ x6
= x5 + x3 + x2 + x
Dividing I(x) + E(x) by G(x) is carried out in the following manner:
x5 + x3 + x2 + x
x3 + x + 1
x5 + x3 + x2
x2
‚ÜêQuotient
x
‚ÜêRemainder

100
Digital Electronics 2
The quotient can be put into the form, Q‚àó(x) = x2, and the resulting remainder,
R‚àó(x) = x, is different from R(x).
It can be observed that the division is carried out by using the addition modulo 2
for the coefÔ¨Åcients of the polynomials (0 + 0 = 0, 1 + 0 = 1, 1 + 1 = 0).
Starting from the initial state Q2Q1Q0 = 100 for the generator and Q2Q1Q0 =
000 for the signature register, the bit sequence after each clock signal pulse is entered
in Table 3.6. After six pulses, the signature register has the sequence 001, which is the
signature for a circuit without error. And when the circuit under test is affected by a
short circuit that always sets the output of the inverter to 1, whatever the state of the
input A, another sequence is obtained, that is: 010.
Without error
With error
Generator
Register
Register
Pulse
Q2
Q1
Q0
X
Q2
Q1
Q0
X
Q2
Q1
Q0
1
0
0
0
0
0
0
0
0
0
0
1
0
1
0
1
0
0
1
1
0
0
1
2
1
0
1
0
0
1
0
0
0
1
0
3
1
1
0
0
1
0
0
1
1
0
1
4
1
1
1
1
0
1
0
1
0
0
0
5
0
1
1
1
1
0
1
1
0
0
1
6
0
0
1
0
0
0
1
0
0
1
0
Table 3.6. Bit sequence for the generator and the signature register
Thus, a fault that causes a modiÔ¨Åcation in the input bit sequence of the signature
register can, at the last clock signal pulse, result in a response with the Ô¨Çip-Ô¨Çop output
bits differing from those of the signature.
3.6.3.3. Built-in logic block observer register
The built-in logic block observer (BILBO) register is often used to reduce the
hardware cost of BIST circuits. It can be conÔ¨Ågured to operate in test mode or normal
mode.
The logic circuit for a three-bit BILBO register is represented in Figure 3.21. It
has an SI, an SO, parallel inputs, Di (i = 0, 1, 2), parallel outputs, Qi (i = 0, 1, 2),
and control inputs, C1 and C0. The function table for the BILBO register is given in
Table 3.7.

Shift Register
101
C
CLR
D2
0
1
MUX
CLR
D1
Q2
D0
Q1
Q0
CLR
CK
Q
Q
D
SI
Q
Q
D
SO
PR
PR
PR
Q
Q
D
0
1
C
Figure 3.21. Logic circuit of a BILBO register
C1
C0
Operating mode
0
0
Shift register, serial input, serial output
0
1
LFSR generator
1
0
D Ô¨Çip-Ô¨Çops
1
1
Signature register
Table 3.7. Function table of the BILBO register
In a circuit, the same BILBO register can generate signals that are stored in the
memory and can then be conÔ¨Ågured as a signature register. And if no error is detected
during the BIST phase, the control circuit will conÔ¨Ågure the BILBO register to operate
in normal mode.
3.7. Exercises
EXERCISE 3.1.‚Äì Implement a Ô¨Åve-bit serial-in serial out shift register.
Represent the timing diagram illustrating the operation of this register, assuming
that the Ô¨Çip-Ô¨Çops are initially set to 0.
EXERCISE 3.2.‚Äì Complete the timing diagram for the modulo 6 Johnson counter
shown in Figure 3.22(a).
Construct and compare the state diagrams for the counters shown in Figure 3.22(a)
and 3.23.

102
Digital Electronics 2
Q
2
Q1
Q0
Q0
Q2
Q1
(a)
(b)
CK
Q
Q
D
CLR
Q
D
CLR
Q
D
CLR
CK
0
1
2
Q
Q
Figure 3.22. a) Modulo 6 Johnson counter (circuit 1); b) timing diagram
Q
Q2
Q1
Q0
Q
Q
D
CLR
Q
D
CLR
CK
0
1
Q
Q
D
CLR
2
Figure 3.23. Modulo 6 Johnson counter (circuit 2)
EXERCISE 3.3.‚Äì Using a shift register, a counter and logic gates, implement a logic
circuit of a detector for the sequence 1101, assuming that the bits can or cannot overlap
between consecutive four-bit words.
EXERCISE 3.4.‚Äì Consider the shift register shown in Figure 3.24, which is
implemented using D Ô¨Çip-Ô¨Çops and 2 : 1 multiplexers.
3
0
CLR
1
0
Q
Q
D
CLR
0
0
1
0
1
0
1
0
1
CLR
CK
Load
1
2
3
L
Q
Q
D
CLR
3
2
Q
Q
D
CLR
2
1
Q
Q
D
X
Q
X
X
Q
X
Q
Q
X
Figure 3.24. Four-bit shift register
Complete the functional truth table shown in Table 3.8.

Shift Register
103
NS
3
+
0
Q+
Q1
+
Q2
+
CK
CLR
Inputs
Load
1
0
1
1
0
x
x
Q
Table 3.8. Functional truth table (NS, next state)
Complete (Q0, Q1, Q2 and Q3) the timing diagram in Figure 3.25 assuming that
X3X2X1X0 = 0101.
CLR
0
CK
1
2
3
Load
L
X
Q
Q
Q
Q
Figure 3.25. Timing diagram (X3X2X1X0 = 0101)
Figure 3.26 depicts the logic circuit for another type of shift register that is also
based on D Ô¨Çip-Ô¨Çops and 2 : 1 multiplexers.
Complete the functional truth table represented in Table 3.9.
EXERCISE 3.5.‚Äì The universal shift register shown in Figure 3.27 is composed of D
Ô¨Çip-Ô¨Çops and 4 : 1 multiplexers. During a normal operation, the synchronous reset
input is set to 1 and does not affect the outputs.
Complete the functional truth table given in Table 3.10.
Complete the timing diagram shown in Figure 3.28.

104
Digital Electronics 2
0
1
CLR
2
Q
Q
D
CLR
3
L
En
0
1
0
1
0
1
0
1
2
3
Q
Q
D
CLR
0
CLR
CK
Q
Q
D
CLR
1
Q
Q
D
Q
Q
Q
Q
X
Figure 3.26. Shift register with enable signal
NS
3
+
0
Q+
Q1
+
Q2
+
CK
CLR
En
1
0
1
1
0
x
x
Inputs
Q
Table 3.9. Functional truth table (NS, next state)
NS
1
1
0
0
Q3
+
0
Q+
Q1
+
Q2
+
CK
Reset
Inputs
1
0
0
1
0
1
1
1
1
0
x
x
x
x
1
C
C
Table 3.10. Functional truth table
EXERCISE 3.6.‚Äì Determine the count sequence for the logic circuit shown in
Figure 3.29 assuming that the initial state is Q2Q1Q0 = 111, and the count sequence
of the circuit shown in Figure 3.30 for a case where the initial state is
Q2Q1Q0 = 000.

Shift Register
105
0
0
3
2
1
0
3
2
1
0
Q
Q
D
Q
Q
D
CLR
CLR
Q
Q
D
CLR
Q
Q
D
CLR
Reset
1
0
R
L
3
2
1
L
0
1
R
3
2
3
2
1
0
1
0
1
2
3
3
2
1
0
CK
Reset
3
2
1
0
C
X
X
X
X
X
X
X
X
Q
X
Q
Q
X
C
C
X
Q
C
Q
Q
Q
Q
X
Figure 3.27. Logic circuit and symbol for the
four-bit universal shift register
CK
Reset
X R
X L
X 0
X 1
X 2
X 3
Q0
Q1
Q2
Q3
C1
C0
Figure 3.28. Timing diagram for a universal register
EXERCISE 3.7.‚Äì Modulo m or m ‚àí1 counter.
Consider the counter using two Ô¨Çip-Ô¨Çops shown in Figure 3.31(a).

106
Digital Electronics 2
D
CK
Q0
PR
PR
PR
Q2
Q1
Q
Q
D
Q
Q
D
Q
Q
Figure 3.29. Three-bit LFSR counter with Ô¨Çip-Ô¨Çops initially set to 1
D
CK
Q0
Q2
Q1
CLR
CLR
CLR
Q
Q
D
Q
Q
D
Q
Q
Figure 3.30. Three-bit LFSR counter with Ô¨Çip-Ô¨Çops initially set to 0
CK
1
2
3
4
1
2
3
4
MC = 0
CK
0
1
1
0
1
0
Q
Q
D
CLR
1
Q
Q
D
CLR
0
CLR
CK
MC
(a)
MC = 1
(b)
Q
Q
Q
Q
Q
Q
Figure 3.31. Modulo m or m ‚àí1 counter with two Ô¨Çip-Ô¨Çops:
a) logic circuit; b) timing diagram
Complete the timing diagrams of Figure 3.31(b) when MC = 0 and MC = 1. We
will assume that the initial state is 0.
Determine the value of the modulo when MC = 0 and MC = 1.

Shift Register
107
Answer the same questions for the counter using three Ô¨Çip-Ô¨Çops and the timing
diagram shown in Figure 3.32.
MC = 0
Q
D
CLR
0
CLR
CK
1
(b)
1
2
CK
MC = 1
1
2
CK
2
1
0
0
2
1
3
4
5
6
0
2
1
3
4
5
6
(a)
Q
Q
D
CLR
2
MC
Q
Q
D
CLR
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Figure 3.32. Modulo m or m ‚àí1 counter with three Ô¨Çip-Ô¨Çops:
a) logic circuit; b) timing diagram
3.8. Solutions
SOLUTION 3.1.‚Äì Five-bit shift register.
Figure 3.33 depicts the logic circuit of a Ô¨Åve-bit shift register. The timing diagram
shown in Figure 3.34 is constructed assuming that the initial state is 0.
CLR
Q
Q
D
CLR
Q
Q
D
CLR
Q
Q
D
CLR
Q
Q
D
CLR
Q
Q
D
1
2
3
4
CK
0
0
Q
Q
D
Q
Q
Q
Figure 3.33. Five-bit shift register

108
Digital Electronics 2
1
0
CK
4
3
0
2
D
Q
Q
Q
Q
Q
Figure 3.34. Timing diagram
SOLUTION 3.2.‚Äì Modulo 6 Johnson counter.
The analysis of the counter shown in Figure 3.35(a) yields the following equations:
D0 = Q2,
D1 = Q0
and
D2 = Q1
state :
0
Q1
Q2
000
100
110
101
111
Q2Q1Q0
010
Q0
Q2
Q1
Q
Q
D
CLR
Q
D
CLR
Q
D
CLR
CK
0
1
2
Q
Q
(c)
011
001
CK
1
1
0
1
0
1
1
0
0
1
1
1
0
1
0
0
0
0
0
0
0
(a)
(b)
Q
Figure 3.35. Modulo 6 Johnson counter: a) circuit 1; b) timing diagram;
c) state diagram
Assuming that the counter is initially set to 0, the timing diagram can be
represented as shown in Figure 3.35(b). The count cycle is made up of six different
states. However, starting from the state 010, the counter goes to the state 101, and
vice versa. The state diagram of the counter is given in Figure 3.35(c).

Shift Register
109
state :
2
Q1
Q0
000
100
110
111
010
101
Q2Q1Q0
(a)
011
001
(b)
Q
Q
D
CLR
Q
D
CLR
CK
0
1
Q
Q
D
CLR
2
Q
Q
Figure 3.36. Modulo 6 Johnson counter:
a) circuit 2; b) state diagram
For the counter shown in Figure 3.36(a), we have:
D0 = Q2,
D1 = Q0
and
D2 = (Q2 + Q0) ¬∑ Q1
Starting from the initial state Q2Q1Q0 = 000, the counter successively takes the
states 001, 011, 111, 110, 100, and returns to 000. When the counter is set to the state
101, it successively goes to 010 and 001. Figure 3.36(b) depicts the state diagram of
the counter. In this case, the counter returns to the same count cycle regardless of the
initial state.
SOLUTION 3.3.‚Äì Detector of the sequence 1101.
The logic circuit for the 1101 sequence detector with overlap is represented in
Figure 3.37. The input data bits, X, being applied to the register with X3 Ô¨Årst, the
sequence 1101 is detected after three clock pulses. Assuming X = X3X2X1X0, the
output logic equation can take the form:
Y = Q2 ¬∑ Q1 ¬∑ Q0 ¬∑ X0
where Q2 = X3, Q1 = X2 and Q0 = X1.
2
CLR
Q
Q
D
CLR
Q
Q
D
CLR
Q
Q
D
0
X
CK
1
Y
Q
Q
Q
Figure 3.37. Logic circuit for the 1101 sequence detector with overlap

110
Digital Electronics 2
The logic circuit for the 1101 sequence detector without overlap is illustrated in
Figure 3.38. The counter is initially reset to 0 and the output Z can take the logic state
1 only if QB = QA = 1. Each four-bit word is processed independently.
2‚àíbit counter
CLR
CLR
CLR
Q
Q
D
CLR
Q
Q
D
CLR
Q
Q
D
J
Q
Q
K
J
0
X
CK
1
2
Z
QA
Y
QB
1
CK
Q
Q
K
Q
Q
Q
Figure 3.38. Logic circuit of the 1101 sequence
detector without overlap
SOLUTION 3.4.‚Äì Shift register.
The analysis of the shift register logic circuit provides the following logic
equations:
Q+
0 = D0 = XL ¬∑ Load + X0 ¬∑ Load
[3.3]
and:
Q+
i = Di = Qi‚àí1 ¬∑ Load + Xi ¬∑ Load,
i = 1, 2, 3
[3.4]
Table 3.11 gives the functional truth table for the shift register.
The timing diagram of the shift register is represented in Figure 3.39, for a case
where X3X2X1X0 = 0101.
In this case, the logic equations for the shift register are written as follows:
Q+
0 = D0 = XL ¬∑ En + Q0 ¬∑ En
[3.5]
and:
Q+
i = Di = Qi‚àí1 ¬∑ En + Qi ¬∑ En,
i = 1, 2, 3
[3.6]

Shift Register
111
Inputs
3
+
0
Q+
Q1
+
Q2
+
0
1
1
Reset
Left shift
Load
NS
Q
0
1
2
L
3
0
1
2
CK
CLR
Load
0
x
x
0
0
0
0
1
X
X
Q
X
Q
X
X
Q
Table 3.11. Functional truth table (NS: next state)
Load
L
CK
CLR
0
1
2
3
Q
Q
X
Q
Q
Figure 3.39. Timing diagram of the shift register
The functional truth table can, thus, be represented as shown in Table 3.12.
SOLUTION 3.5.‚Äì Four-bit universal shift register.
By analyzing the logic circuit of the shift register, we can obtain the following
logic equations:
Q+
0 = D0 = C1 ¬∑ C0 ¬∑ X0 + C1 ¬∑ C0 ¬∑ Q1 + C1 ¬∑ C0 ¬∑ XL + C1 ¬∑ C0 ¬∑ Q0
[3.7]

112
Digital Electronics 2
Q+
i = Di = C1 ¬∑ C0 ¬∑ Xi + C1 ¬∑ C0 ¬∑ Qi+1 + C1 ¬∑ C0 ¬∑ Qi‚àí1 + C1 ¬∑ C0 ¬∑ Qi
[3.8]
Q+
3 = D3 = C1 ¬∑ C0 ¬∑ X3 + C1 ¬∑ C0 ¬∑ XR + C1 ¬∑ C0 ¬∑ Q2 + C1 ¬∑ C0 ¬∑ Q3
[3.9]
where i = 1, 2.
Reset
Q3
+
0
Q+
Q1
+
Q2
+
Q2
Q1
0
Q
Q2
Q1
0
Q
L
CK
CLR
En
1
0
1
1
0
x
x
0
0
0
0
Q3
Left shift
Hold
NS
Inputs
X
Table 3.12. Functional truth table (NS, next state)
Table 3.13 gives the functional truth table of the universal register.
Hold
1
1
1
0
x
x
x
x
0
0
0
0
Right shift
Reset
Left shift
Load
NS
0
Q3
+
0
Q+
Q1
+
Q2
+
3
0
1
2
0
1
2
L
Q1
Q2
3
R
3
0
1
2
1
1
0
CK
Reset
Inputs
1
0
0
1
0
1
1
X
X
X
Q
X
Q
X
Q
C
Q
X
Q
Q
Q
Q
C
Table 3.13. Functional truth table (NS, next state)
The functional truth table helps complete the timing diagram of the universal
register, as shown in Figure 3.40.

Shift Register
113
CK
Reset
X R
X L
X 0
X 1
X 2
X 3
Q0
Q1
Q2
Q3
C1
C0
Figure 3.40. Timing diagram of the universal register
SOLUTION 3.6.‚Äì Three-bit linear-feedback shift register.
The Ô¨Çip-Ô¨Çops of the Ô¨Årst counter operate according to the following characteristic
equations:
Q+
0 = D0 = Q1
[3.10]
Q+
1 = D1 = Q2
[3.11]
Q+
2 = D2 = Q2 ‚äïQ0
[3.12]
Table 3.14 gives the transition table of the counter. When the counter is reset (or
Q2Q1Q0 = 000), it remains in the same state. Hence, the state Q2Q1Q0 = 000 is
not part of the following count cycle: 111 ‚Üí011 ‚Üí101 ‚Üí010 ‚Üí001 ‚Üí100 ‚Üí
110 ‚Üí111.
The count cycle is composed of seven different states and the counter modulo is,
thus, equal to 7.
The characteristic equations for the Ô¨Çip-Ô¨Çops of the second counter are given as
follows:
Q+
0 = D0 = Q1
[3.13]
Q+
1 = D1 = Q2
[3.14]
Q+
2 = D2 = (Q2 + Q1) ‚äïQ1 ‚äïQ0 = (Q2 + Q1) ‚äïQ0
[3.15]

114
Digital Electronics 2
EA
Inputs
ES
Q2
Q1
Q0
D2
D1
D0
Q+
2
Q+
1
Q+
0
1
1
1
0
1
1
0
1
1
0
1
1
1
0
1
1
0
1
1
0
1
0
1
0
0
1
0
0
1
0
0
0
1
0
0
1
0
0
1
1
0
0
1
0
0
1
0
0
1
1
0
1
1
0
1
1
0
1
1
1
1
1
1
0
0
0
0
0
0
0
0
0
Table 3.14. Transition table (PS, present state, NS, next state)
PS
Inputs
NS
Q2
Q1
Q0
D2
D1
D0
Q+
2
Q+
1
Q+
0
0
0
0
1
0
0
1
0
0
1
0
0
0
1
0
0
1
0
0
1
0
1
0
1
1
0
1
1
0
1
1
1
0
1
1
0
1
1
0
1
1
1
1
1
1
1
1
1
0
1
1
0
1
1
0
1
1
0
0
1
0
0
1
0
0
1
0
0
0
0
0
0
Table 3.15. Transition table (PS, present state; NS, next state)
The transition table of the counter is given in Table 3.15.
Beginning with the initial state Q2Q1Q0 = 000, the count sequence is as follows:
000 ‚Üí100 ‚Üí010 ‚Üí101 ‚Üí110 ‚Üí111 ‚Üí011 ‚Üí001 ‚Üí000.
The count cycle is made up of eight different states and the counter modulo is,
thus, equal to 8.
SOLUTION 3.7.‚Äì Modulo m or m ‚àí1 counter.
Based on the logic circuit shown in Figure 3.41(a), we can obtain the following
logic equations:
D0 = Q1 ¬∑ Q0 ¬∑ MC = Q1 + Q0 ¬∑ MC
[3.16]
D1 = Q0
[3.17]
Figure 3.41(b) shows the timing diagrams of the counter. The counter modulo is
equal to either 4, when MC = 0, or 3, when MC = 1.

Shift Register
115
(a)
1
D
CLR
1
Q
Q
D
CLR
0
CLR
CK
MC
0
1
0
0
1
MC = 0
MC = 1
1
0
1
1
0
1
0
1
(b)
1
0
1
1
0
1
0
0
1
2
3
4
1
2
3
4
CK
CK
Q
Q
Q
Q
Q
Q
Q
Q
Figure 3.41. Modulo m or m ‚àí1 counter using two Ô¨Çip-Ô¨Çops:
a) logic circuit; b) timing diagram
For the logic circuit shown in Figure 3.42(a), the inputs of the Ô¨Çip-Ô¨Çops are
characterized by the following logic equations:
D0 = Q2 ¬∑ Q1 ¬∑ MC = Q2 + Q1 ¬∑ MC
[3.18]
D1 = Q0
[3.19]
D2 = Q1
[3.20]
Figure 3.42(b) presents the timing diagram for the counter. The counter modulo is
equal to either 6, when MC = 0, or 5, when MC = 1.
0
0
1
1
1
1
0
1
1
1
1
0
0
1
1
0
2
1
0
0
2
1
3
4
5
6
0
2
1
3
4
5
6
0
0
0
1
1
1
1
0
1
1
1
1
0
0
1
0
0
0
(a)
Q
Q
D
CLR
2
MC
Q
Q
D
CLR
Q
Q
D
CLR
0
CLR
CK
1
(b)
1
2
CK
MC=1
1
2
CK
MC=0
0
0
Q
Q
Q
Q
Q
Q
Q
Q
Q
Figure 3.42. Modulo m or m ‚àí1 counter using three Ô¨Çip-Ô¨Çops:
a) logic circuit; b) timing diagram


4
Arithmetic and Logic Circuits
4.1. Introduction
Arithmetic circuits are essential in the implementation of microprocessors and
circuits for digital signal processing.
As the complexity of the direct approach (construct a truth table and then derive
and simplify the output logic equations) increases with an increase in the size of data,
the modular approach is often chosen to implement arithmetic circuits. A given digital
circuit is thus implemented by assembling modules that are designed for numbers with
small word lengths.
Despite the increasing number of arithmetic operations that are becoming routine,
most microprocessors only contain circuits for basic operations, such as an adder (or
summer), comparator, multiplier and divider. In addition to arithmetic circuits, there
is also a need for circuits that can perform bitwise logic and shift operations. One of
the main components of a microprocessor, therefore, is the arithmetic and logic unit
(ALU), which encases all the circuits required for carrying out operations on digital
data.
4.2. Adder
Adders are used to perform a large number of digital operations. In spite of the
apparent simplicity of an addition operation, there are several approaches to designing
adders.
4.2.1. Half adder
A half adder (HA) is a circuit that generates the sum, S, and the carry, C, resulting
from the addition of two 1-bit numbers, A and B.
Digital Electronics 2: Sequential and Arithmetic Logic Circuits, First Edition. Tertulien Ndjountche. 
¬© ISTE Ltd 2016. Published by ISTE Ltd and John Wiley & Sons, Inc. 

118
Digital Electronics 2
An example of a simple addition, A + B, is given in Figure 4.1. The truth table
shown in Table 4.1 is constructed by considering bits C and S to be the MSB and
LSB in the 2-bit representation of the addition result. The logic equations for the two
outputs are given by:
S = A ¬∑ B + A ¬∑ B = A ‚äïB
[4.1]
C = A ¬∑ B
[4.2]
Carry
C  S
+
B
A
Sum
Figure 4.1. Example of a simple addition. For a color version of the
Ô¨Ågure, see www.iste.co.uk/ndjountche/electronics2.zip
A
B
S
C
0
0
0
0
0
1
1
0
1
0
1
0
1
1
0
1
Table 4.1. Truth table for a half adder
The circuit and the symbol of an HA are given in Figures 4.2(a) and 4.2(b),
respectively.
A
C
B
A
S
HA
(a)
B
S
C
(b)
Figure 4.2. Half adder: a) logic circuit; b) symbol

Arithmetic and Logic Circuits
119
4.2.2. Full adder
A full adder (FA) is a circuit that generates the sum, S, and the carry-out C0
resulting from the addition of two 1-bit numbers, A and B, and a 1-bit carry-in Ci.
+
S
Ci+1
A
Ci
Carryin
Sum
Carryout
B
Figure 4.3. Example of an addition. For a color version of the Ô¨Ågure,
see www.iste.co.uk/ndjountche/electronics2.zip
The working of an FA is based on the arithmetic operation given in Figure 4.3. The
truth table is constructed as shown in Table 4.2. The output logic equations cannot be
simpliÔ¨Åed and are therefore written as follows:
S = A ¬∑ B ¬∑ Ci + A ¬∑ B ¬∑ Ci + A ¬∑ B ¬∑ Ci + A ¬∑ B ¬∑ Ci
[4.3]
= (A ¬∑ B + A ¬∑ B) ¬∑ Ci + (A ¬∑ B + A ¬∑ B) ¬∑ Ci
[4.4]
= (A ‚äïB) ‚äïCi
Ci+1 = A ¬∑ B ¬∑ Ci + A ¬∑ B ¬∑ Ci + A ¬∑ B ¬∑ Ci + A ¬∑ B ¬∑ Ci
[4.5]
= A ¬∑ B + (A ¬∑ B + A ¬∑ B) ¬∑ Ci
= A ¬∑ B + (A ‚äïB) ¬∑ Ci
[4.6]
A
B
Ci
S
Ci+1
0
0
0
0
0
0
0
1
1
0
0
1
0
1
0
0
1
1
0
1
1
0
0
1
0
1
0
1
0
1
1
1
0
0
1
1
1
1
1
1
Table 4.2. Truth table of a full adder

120
Digital Electronics 2
i
A
B
S
C
Ci+1
(b)
(a)
FA
A
B
S
Ci+1
i
C
Figure 4.4. Full adder: a) logic circuit; b) symbol
An FA can be implemented using two HAs and an OR gate, as shown in
Figure 4.4(a). The symbol of an FA is represented in Figure 4.4(b).
4bit adder
i
A
B
A
B
A
B
A
B
S
4
4
4
A
B
C2
(c)
1   1   1   1  
0   0   0   1   
+
1   1   1 
A
B
1 0   0   0   0
0
4
C
i
C
S
FA
S
S3
3
3
A
B
(a)
FA
S
S2
2
2
A
B
C
C4
FA
S
S1
1
1
A
B
C
C1
FA
S
S0
0
0
A
B
Ci+1
Ci
0
(b)
Ci+4
C
C3
Ci
i+1
Ci
i+1
Ci
i+1
C
Figure 4.5. Four-bit ripple-carry adder: a) logic circuit; b) symbol;
c) example of addition with ripple-carry. For a color version of the Ô¨Ågure,
see www.iste.co.uk/ndjountche/electronics2.zip
4.2.3. Ripple-carry adder
A ripple-carry adder is implemented by using an FA stage for each bit and
connecting the carry-out of a given stage to the carry-in of the next stage, as shown in
Figure 4.5(a) for 4-bit numbers. The FA that provides the LSB of the sum and whose
carry-in is set to 0 may be replaced by an HA. Figure 4.5(b) shows the symbol of a
ripple-carry adder. An example of addition with ripple-carry is illustrated in
Figure 4.5(c).

Arithmetic and Logic Circuits
121
Subtraction can be performed by expressing the subtrahend (or number to be
subtracted) with a negative sign in the two‚Äôs complement representation and then
performing an addition operation without taking into account the last carry-out. The
logic circuit and the symbol of an adder conÔ¨Ågured for subtraction are given in
Figures 4.6(a) and 4.6(b). An example of a subtraction operation is illustrated in
Figure 4.6(c).
4bit
i+4
C4
S
4
4
4
A
B
The last carryout
9
1 2

1  1  0  0 
0  1  1  1
+
1   
3
0  0  1  1
1
(c)
A
B
is not taken into account.
i
C
S0
0
0
A
B
1
S1
1
1
A
B
S3
3
3
A
B
(a)
2
2
A
B
FA
S
Ci+1
Ci
C4
FA
S
Ci+1
Ci
FA
S
Ci+1
Ci
S2
Ci
(b)
FA
S
Ci+1
Ci
A
B
A
B
A
B
A
B
subtractor
C
Figure 4.6. Four-bit ripple-carry adder conÔ¨Ågured for subtraction:
a) logic circuit; b) symbol; c) example
Figure 4.7 depicts a 4-bit ripple-carry adder/subtractor. Each XOR gate operates
as a programmable inverter whose output can take either the state or the logic
complement of the input variable.
i+1
1
2
3
0
1
2
3
0
1
2
3
Ci
Ci
Ci
Ci
S
A
B
C
S
B
A
S
B
A
S
B
A
C4
A
B
FA
S
Ci+1
A
B
FA
S
Ci+1
A
B
FA
S
Ci+1
A
B
FA
S
C
0
Figure 4.7. Four-bit ripple-carry adder/subtractor
(C = 0: adder; C = 1: subtractor)

122
Digital Electronics 2
A 4-bit ripple-carry adder is made up of four FAs that can singly exhibit the timing
parameters deÔ¨Åned as follows:
‚Äì œÑi, propagation delay A, B ‚ÜíCi+1;
‚Äì œÑc, propagation delay Ci ‚ÜíCi+1;
‚Äì œÑs, propagation delay Ci ‚ÜíS.
The critical path for a ripple-carry adder corresponds to the propagation path of
the carry. The Ô¨Årst carry is generated with a propagation delay œÑi. The carry is then
propagated from one FA to another with a propagation delay œÑc, and the last FA can,
depending on the input data, either produce a carry-out or not. The propagation delay
is thus given by:
œÑ = œÑi + 2œÑc + max(œÑc, œÑs)
[4.7]
Assuming that the delay introduced by the XOR gate, œÑXOR, is superior to the
propagation delay of the AND gates, œÑAND, and OR gates, œÑOR, we have 1:
œÑ = œÑXOR + 3(œÑAND + œÑOR) + max(œÑXOR, œÑAND + œÑOR)
[4.8]
The propagation delay for a ripple-carry adder increases with an increase in the
number of input data bits and can put a limitation on the operating speed. One solution
that can be used to reduce the propagation delay is to use a carry-lookahead adder.
4.2.4. Carry-lookahead adder
In a carry-lookahead adder, the carry-out of each stage is computed independently.
An analysis of the 4-bit carry-lookahead adder shown in Figure 4.8 provides the
following logic equations:
gi = Ai ¬∑ Bi
[4.9]
pi = Ai ‚äïBi
[4.10]
and:
Ci+1 = gi + pi ¬∑ Ci
[4.11]
1 For an n-bit ripple-carry adder the propagation delay is of the form:
œÑ = œÑXOR + (n ‚àí1)(œÑAND + œÑOR) + max(œÑXOR, œÑAND + œÑOR)

Arithmetic and Logic Circuits
123
CLG
C
S3
p
g
C2
S2
p2
g2
C1
S1
p1
g1
S0
p0
g0
2
A
2
B
3
A
3
B
1
A
1
B
0
A
0
B
gi
pi
Ci
Si
i
B
i
A
C0
C4
P
G
C0
C3
C2
C1
C4
G
P
p0
p1
g0
g1
p2
g
g2
p3
3
3
3
3
Figure 4.8. Four-bit carry-lookahead adder
Upon successive substitutions, we can obtain:
C1 = g0 + p0 ¬∑ C0
[4.12]
C2 = g1 + p1 ¬∑ C1
= g1 + g0 ¬∑ p1 + p0 ¬∑ p1 ¬∑ C0
[4.13]
C3 = g2 + p2 ¬∑ C2
= g2 + g1 ¬∑ p2 + g0 ¬∑ p1 ¬∑ p2 + p0 ¬∑ p1 ¬∑ p2 ¬∑ C0
[4.14]
C4 = g3 + p3 ¬∑ C3
= g3 + g2 ¬∑ p3 + g1 ¬∑ p2 ¬∑ p3 + g0 ¬∑ p1 ¬∑ p2 ¬∑ p3 + p0 ¬∑ p1 ¬∑ p2 ¬∑ p3 ¬∑ C0
[4.15]
The outputs G and P, produced by the carry-lookahead generator, are used to
determine whether a given bit pair will generate a carry or propagate a carry:
P = p0 ¬∑ p1 ¬∑ p2 ¬∑ p3
[4.16]
G = g3 + g2 ¬∑ p3 + g1 ¬∑ p3 ¬∑ p2 + g0p3 ¬∑ p2 ¬∑ p1
[4.17]

124
Digital Electronics 2
The propagation delay (path A0 ‚àíS3) in a 4-bit carry-lookahead adder is:
œÑ = 2œÑXOR + œÑAND + œÑOR
[4.18]
To facilitate the design of an n-bit adder, the carry-lookahead adder has two outputs
P and G:
‚àíP indicates the propagation of the value of the carry-in by a module (Ci);
‚àíG indicates the generation of a carry-out (Ci+1 = 1) by a module, regardless
of the value of the carry-in.
Hence:
Ci+1 = G + P ¬∑ Ci
[4.19]
P =

1
if
X + Y = 2n ‚àí1
0
otherwise
[4.20]
G =

1
if
X + Y ‚â•2n
0
otherwise
[4.21]
P =
n‚àí1

i=0
pi
[4.22]
G = gn‚àí1 + gn‚àí2pn‚àí1 + gn‚àí3pn‚àí1pn‚àí2 + ¬∑ ¬∑ ¬∑ + g0pn‚àí1pn‚àí2 . . . p1
[4.23]
As the number of input data bits increases, the structure of the carry-lookahead
adder becomes more complex. In this case, a better trade-off between the hardware
cost and the operating speed can be achieved by using other approaches such as the
carry-select adder or the carry-skip adder.
4.2.5. Carry-select adder
The working principle of a carry-select adder is to perform the same calculation
in parallel: one with the carry-in set to 0 and the other with the carry-in set to 1. The
correct result is then chosen when the exact value of the carry-in becomes available.
A carry select adder is thus composed of several sections of identical or different sizes

Arithmetic and Logic Circuits
125
and each section, with the exception of the one related to the least signiÔ¨Åcant bits,
carries two additions in parallel.
Figure 4.9 depicts the logic circuit of a 4-bit carry-select adder. Two circuits are
used to perform the addition involving the two most signiÔ¨Åcant bits and the selection
of the result depends on the logic state of the carry, which is generated by the adder
of the two least signiÔ¨Åcant bits and is applied to the multiplexers. The circuit that
determines the carry, C4, which is composed of an OR gate and an AND gate, can be
replaced by a 2 : 1 multiplexer whose selection signal is the carry C2.
S
A
2
A
3
A
3
B
2
B
C4
S2
3
B
2
A
2
B
Ci
1
C2
A 1
A0
0
B
1
B
S1
S0
Ci+1
A
FA
Ci+1
FA
Ci
Ci+1
Ci
A
B
A
B
S
S
0
0
1
0
1
S3
Ci
B
FA
Ci+1
A
B
S
FA
S
FA
Ci+1
FA
Ci
Ci+1
Ci
A
B
A
B
S
3
Figure 4.9. Four-bit carry-select adder
4.2.6. Carry-skip adder
Another approach that can be used to accelerate the propagation of the carry
consists of using a carry-skip adder. It can be implemented using consecutive adder
groups of identical or variable size. The addition of a propagation path enables the
carry to skip a group of k ‚àíl FAs whose propagation signal, Pk:l, is at the logic state
1. An FA with a propagation signal, P, is represented in Figure 4.10. Figure 4.11
depicts a carry-skip adder cell. The expressions for the propagation signals for cells
having between two to four bits are given in Table 4.3, where Pi = Xi ‚äïYi
(i = 0, 1, 2, 3), and the input data are represented by Xi and Yi.
The logic circuit for an 8-bit carry-skip adder is represented in Figure 4.12. It
is composed of four identical groups, each of which performs a two-bit addition. In
general, the optimal size of each group is determined based on the number of input
data bits.

126
Digital Electronics 2
i+1
A
B
S
C
(a)
P
Ci
A
B
FA
P
S
Ci+1
Ci
(b)
Figure 4.10. Full adder
(kl)bit CSAC
Pk:l
Ci
i+(kl)
C
A
B
A
B
A
B
A
B
A
B
k
k
k+1
k+1
k+2
k+2
l
l
A
B
FA
P
S
Ci+1
Ci
k
k
Pk
Sk
Ci+(kl)
Sk
Sk+1
Sk+2
Sl
Ci
A
B
k+1
k+1
Pk+1
Sk+1
A
B
FA
P
S
Ci+1
Ci
A
B
A
B
FA
P
S
Ci+1
Ci
k+2
k+2
Pk+2
Sk+2
l
A
l
B
A
B
FA
P
S
Ci+1
Ci
Pl
Sl
Figure 4.11. Carry-skip adder cell
2-bit cell
P1:0 = P1 ¬∑ P0
3 -bit cell
P2:0 = P2 ¬∑ P1 ¬∑ P0
4-bit cell
P3:0 = P3 ¬∑ P2 ¬∑ P1 ¬∑ P0
Table 4.3. Expressions of the propagation signal for cells
having from two to four bits

Arithmetic and Logic Circuits
127
2bit CSAC
S2
S3
S4
S5
S0
S1
S0
S1
S0
S1
S0
S1
S6
S7
S0
S1
C8
Ci+2
Ci
Ci
Ci
Ci
Ci+2
Ci
Ci+2
Ci
8
8
B
A
8
C8
A
B
A
B
A
A
1
A
1
B
0
A
0
B
B
B
A
B
A
B
3
3
2
2
5
4
4
5
1
1
0
0
1
A
1
B
0
A
0
B
1
A
1
B
0
A
0
B
A
B
A
B
1
A
1
B
0
A
0
B
7
7
6
6
Ci+2
S
8bit adder
2bit CSAC
2bit CSAC
2bit CSAC
Figure 4.12. Eight-bit carry-skip adder
4.3. Comparator
A digital comparator is a logic circuit that compares two binary numbers. The
comparator can be used to determine whether a given number is smaller than, equal to
or larger than another number.
A 1-bit comparator has two inputs (A, B) and three outputs (OA<B, OA=B,
OA>B). Table 4.4 gives the truth table describing the comparator operation. The
output logic equations can be written as:
OA>B = A ¬∑ B
[4.24]
OA=B = A ¬∑ B + A ¬∑ B = (A ‚äïB) = A ‚äôB
[4.25]
OA<B = A ¬∑ B
[4.26]
A
B
OA>B
OA=B
OA<B
0
0
0
1
0
0
1
0
0
1
1
0
1
0
0
1
1
0
1
0
Table 4.4. Truth table for a 1-bit comparator
The logic circuit and symbol of a 1-bit comparator are represented in Figure 4.13.

128
Digital Electronics 2
A<B
OA=B
OA>B
B
A
B
A
OA=B
OA>B
OA<B
comparator
1bit
O
(a)
(b)
Figure 4.13. One-bit comparator: a) logic circuit; b) symbol
More inputs (IA<B, IA=B, IA>B) can be added to a 1-bit comparator to enable
the cascade connection of several circuits of the same type. The truth table of the
cascadable 1-bit comparator is given in Table 4.14. The Karnaugh maps associated
with each output are represented in Figure 4.15. The output logic expressions are
factorized instead of being simpliÔ¨Åed, so that the XOR logic gate performing the
A ‚äïB function can be shared by the outputs. Thus:
OA>B = (A + B) ¬∑ IA>B + A ¬∑ B
[4.27]
= (A ‚äïB) ¬∑ IA>B + A ¬∑ B
[4.28]
OA=B = (A ‚äïB) ¬∑ IA=B
[4.29]
OA<B = (A + B) ¬∑ IA<B + A ¬∑ B
[4.30]
= (A ‚äïB) ¬∑ IA<B + A ¬∑ B
[4.31]
A
B
OA>B
OA=B
OA<B
0
0
IA>B
IA=B
IA<B
0
1
0
0
1
1
0
1
0
0
1
1
IA>B
IA=B
IA<B
Figure 4.14. Truth table of a cascadable 1-bit comparator
The n-bit comparator shown in Figure 4.17 is implemented by cascading 1-bit
comparators. The comparison is carried out in an iterative manner beginning with the
most signiÔ¨Åcant bits of the input data. The logic state 1 for the outputs, OA>B or
OA<B, generated by a given stage is propagated to the following stages while if the
output OA=B of a given stage is set to 1, the same comparison operation is repeated
in the next stage.

Arithmetic and Logic Circuits
129
(c)
I
I A=B
I A<B
I A<B
I A=B
A>B
I
0
0
0
0
1
0
1
0
1
0
0
0
1
1
1
0
0
0
1
0
1
0
1
1
AB
00
01
11
10
A
0
B
1
AB
00
01
11
10
A
0
B
1
AB
00
01
11
10
A
0
B
1
(b)
(a)
A>B
Figure 4.15. Karnaugh maps: a) OA>B; b) OA=B; c) OA<B. For a color
version of the Ô¨Ågure, see www.iste.co.uk/ndjountche/electronics2.zip
The logic circuit and symbol for the cascadable 1-bit comparator are given in
Figures 4.16(a) and 4.16(b), respectively.
1bit
A=B
I A=B
OA>B
A>B
I
OA<B
I A<B
A>B
I
I A=B
I A<B
OA>B
OA=B
OA<B
(b)
(a)
B
A
B
A
comparator
O
Figure 4.16. One-bit cascadable comparator:
a) logic circuit; b) symbol
1bit
n1
A>B
I
I A=B
I A<B
OA=B
OA<B
0
1
0
Bn2
A>B
I
I A=B
I A<B
OA>B
OA=B
OA<B
A>B
I
I A=B
I A<B
OA>B
OA=B
OA<B
OA>B
A n1
B
A
A=B
A<B
A>B
A n2
A 0
B0
B
A
B
A
comparator
1bit
comparator
1bit
comparator
B
Figure 4.17. Structure of the n-bit comparator
4.4. Arithmetic and logic unit
The ALU is the microprocessor component that carries out the arithmetic, logic
and comparison operations. In addition to the data inputs and an output for the result,
it has inputs that are used to select the desired operation.

130
Digital Electronics 2
The ALU can be designed in a hierarchical manner, as illustrated in Figure 4.18,
where A = A3 A2 A1 A0, B = B3 B2 B1 B0 and F = F3 F2 F1 F0. The ALU
is implemented by connecting the appropriate logic circuits (AND and OR function
generators) to the inputs of an adder whose operation is governed by a control signal.
Input data are thus coded depending on the operation to be executed before being
applied to the adder. AND and OR function generators can be implemented as shown
in Figure 4.19. Their outputs, for input bits with the same index, Ak and Bk (k =
0, 1, 2, 3), are characterized by the following equations:
FAND = Ak + Bk ¬∑ S1 + Bk ¬∑ S0
= Ak ¬∑ Bk ¬∑ S1 + Ak ¬∑ Bk ¬∑ S0 + Ak ¬∑ S1 ¬∑ S0
[4.32]
and
FOR = Ak ¬∑ Bk ¬∑ S3 + Ak ¬∑ Bk ¬∑ S2
= Ak + Bk ¬∑ S2 + Bk ¬∑ S3 + S2 ¬∑ S3
[4.33]
where the selection inputs are represented by S0, S1, S2 and S3. Tables 4.5 and 4.6
give the function tables of the AND and OR function generators, respectively.
Generator
M
4
Ci
P
G
4
4
2
S
0
S
1
S
3
S
F
B
A
i+4
C
4bit adder
OR function
Generator
AND function
Figure 4.18. Diagram illustrating the operation principle of a 4-bit
arithmetic and logic unit
The ALU (74HC181 integrated circuit) shown in Figure 4.20 is designed for 4-bit
data. It has select inputs, S0, S1, S2 and S3, and a control input M. It can carry out

Arithmetic and Logic Circuits
131
all sixteen logic operations possible with two variables or sixteen different arithmetic
operations on high-active or low-active input data, as shown in Figures 4.7 and 4.8.
Generator
S
0
S
k
A
AND function
1
FAND
0
S
1
S
FOR
2
S
3
S
3
S
k
A
2
S
k
A
k
B
k
B
k
B
k
A
k
B
FAND
(a)
(b)
FOR
OR function
Generator
Figure 4.19. a) OR function generator; b) AND function generator
S1
S0
FAND
0
0
Ak
0
1
Ak ¬∑ Bk
1
0
Ak ¬∑ Bk
1
1
0
Table 4.5. Function table of the FAND generator
S3
S2
FOR
0
0
1
0
1
Ak + Bk
1
0
Ak + Bk
1
1
Ak
Table 4.6. Function table of the FOR generator
Functions can be generated using either one of the logic operators NOT, AND,
NAND, OR, NOR, XOR and XNOR or using an operation like addition, subtraction,
incrementing, decrementing, multiplication by two, data transfer and comparison of
two numbers. To carry out the logic operations, all the internal carries must be
deactivated by setting the control input, M, to 1, while for arithmetic operations, the
carries are activated by resetting the control input, M, to 0.
As the ALU is based on a carry-lookahead adder, it can supply a carry-out Ci+4
or signals for the propagation (P) and the generation (G) of the carry, which are not

132
Digital Electronics 2
affected by the carry-in, Ci. To process data larger than four bits it is necessary to
cascade several ALUs by connecting the carry-out and carry-in or by using P and G
signals in conjunction with a carry-lookahead generator when high-speed operation is
desired.
C
B
3
A
3
B
G
1
S
0
S
2
S
3
S
A=B
i+4
P
F3
F2
F0
F1
i
C
M
0
A
0
B
1
A
1
B
2
A
2
Figure 4.20. Four-bit arithmetic and logic units
Two‚Äôs complement representation is used to perform arithmetic operations. The
function table lists the arithmetic operations that are executed with or without the
carry-in Ci. The carry-in is taken into account by adding 1 to a result. In this manner,
for the select code S3S2S1S0 = 0110, the operation carried out is either A ‚àíB, if
there is a carry-in, otherwise it is A ‚àíB ‚àí1. Subtraction is executed like addition
with the 1‚Äôs complement of the number to be subtracted, to which 1 is added, and the
carry-out, if any, must be ignored.
The output A = B takes the logic state 1 when all outputs from F3 to F0 are at the
state 1 and is used to indicate the logic equivalence of the four output bits when the
ALU operates as a subtractor with Ci = 1. It is supplied by an open drain gate whose
output can be cabled with other outputs from the same type of gates in order to allow a
comparison of data larger than four bits. It requires an external polarization resistance
to take the high logic level.

Arithmetic and Logic Circuits
133
Select
Active-low data
inputs
M = 1
M = 0 : Arithmetic operations
Logic
Ci = 0
Ci = 1
S3 S2 S1 S0
functions
(without carry)
(with carry)
0
0
0
0
F = A
F = A ‚àí1
F = A
0
0
0
1
F = A ¬∑ B
F = A ¬∑ B ‚àí1
F = A ¬∑ B
0
0
1
0
F = A + B
F = A ¬∑ B ‚àí1
F = A ¬∑ B
0
0
1
1
F = 1
F = ‚àí1
F = 0
0
1
0
0
F = A + B
F = A plus (A + B)
F = A plus (A + B) plus 1
0
1
0
1
F = B
F = A ¬∑ B plus (A + B) F = A ¬∑ B plus (A + B) plus 1
0
1
1
0
F = A ‚äïB
F = A ‚àíB ‚àí1
F = A ‚àíB
0
1
1
1
F = A + B
F = A + B
F = (A + B) plus 1
1
0
0
0
F = A ¬∑ B
F = A plus (A + B)
F = A plus (A + B) plus 1
1
0
0
1
F = A ‚äïB
F = A plus B
F = A plus B plus 1
1
0
1
0
F = B
F = A ¬∑ B plus (A + B) F = A ¬∑ B plus (A + B) plus 1
1
0
1
1
F = A + B
F = A + B
F = (A + B) plus 1
1
1
0
0
F = 0
F = A plus A
F = A plus A plus 1
1
1
0
1
F = A ¬∑ B
F = A ¬∑ B plus A
F = A ¬∑ B plus A plus 1
1
1
1
0
F = A ¬∑ B
F = A ¬∑ B plus A
F = A ¬∑ B plus A plus 1
1
1
1
1
F = A
F = A
F = A plus 1
Table 4.7. Function table for the 4-bit arithmetic and logic unit
When the ALU operates as a subtractor (or with the select code S3S2S1S0 =
0110), the logic level of the carry-out, Ci+4, can also be used to establish a comparison
between the input data. The possible results are given in Table 4.9.
Status Ô¨Çag bits, which are associated with an ALU, supply information on the
nature of the results related to the manipulation of data with a limited word-length.
Figure 4.21 depicts a 4-bit ALUs with status Ô¨Çag bits. The inputs and outputs can
be deÔ¨Åned as follows:
‚Äì inputs:
A and B are two 4-bit numbers (A = A3A2A1A0 and B = B3B2B1B0),
S is a 4-bit select code (S = S3S2S1S0),
M is a control bit,
Ci ‚àà{0, 1};

134
Digital Electronics 2
‚Äì outputs:
F is a 4-bit number (F = F3F2F1F0),
Bit N =

1
if
F < 0
0
otherwise
Bit Z =

1
if
F = 0
0
otherwise
Bit V =

1
if there is overÔ¨Çow (‚àí8 ‚â§R ‚â§7)
0
otherwise.
Select
Active-high data
inputs
M = 1
M = 0 : Arithmetic operation
Logic
Ci = 1
Ci = 0
S3 S2 S1 S0
functions
(without carry)
(with carry)
0
0
0
0
F = A
F = A
F = A plus 1
0
0
0
1
F = A + B
F = A + B
F = (A + B) plus 1
0
0
1
0
F = A ¬∑ B
F = A + B
F = (A + B) plus 1
0
0
1
1
F = 0
F = ‚àí1
F = 0
0
1
0
0
F = A ¬∑ B
F = A plus (A ¬∑ B)
F = A plus (A ¬∑ B) plus 1
0
1
0
1
F = B
F = (A + B) plus A ¬∑ B
F = (A + B) plus A ¬∑ B plus 1
0
1
1
0
F = A ‚äïB
F = A ‚àíB ‚àí1
F = A ‚àíB
0
1
1
1
F = A ¬∑ B
F = A ¬∑ B ‚àí1
F = A ¬∑ B
1
0
0
0
F = A + B
F = A plus (A ¬∑ B)
F = A plus A ¬∑ B plus 1
1
0
0
1
F = A ‚äïB
F = A plus B
F = A plus B plus 1
1
0
1
0
F = B
F = (A + B) plus A ¬∑ B
F = (A + B) plus A ¬∑ B plus 1
1
0
1
1
F = A ¬∑ B
F = A ¬∑ B ‚àí1
F = A ¬∑ B
1
1
0
0
F = 1
F = A plus A
F = A plus A plus 1
1
1
0
1
F = A + B
F = (A + B) plus A
F = (A + B) plus A plus 1
1
1
1
0
F = A + B
F = (A + B) plus A
F = (A + B) plus A plus 1
1
1
1
1
F = A
F = A ‚àí1
F = A
Table 4.8. Function table of the 4-bit arithmetic and logic unit
The ALU uses two‚Äôs representation:
‚Äì the sign bit is determined based on the most signiÔ¨Åcant bit in the result F:
F ‚â•0 if F3 = 0
F < 0 if F3 = 1
‚Äì the overÔ¨Çow bit V is obtained using the relationship:
V = C4 ‚äïC3

Arithmetic and Logic Circuits
135
Active-low
Active-high
Ci
Ci+4
data
data
0
0
A ‚â§B
A ‚â•B
0
1
A > B
A < B
1
0
A < B
A > B
1
1
A ‚â•B
A ‚â§B
Table 4.9. Comparison results
4bit arithmetic 
4
4
A
4
B
F3
C
V
Z
N
F
S
4
Ci
C
C4
and logic unit
M
3
C0
Figure 4.21. Arithmetic unit: status Ô¨Çag bits
In practice, we can also compare two unsigned numbers, A and B, by carrying out
a subtraction followed by a comparison of the difference A ‚àíB with respect to 0. We
thus have:
‚Äì for A ‚àíB = 0, C = 1 and Z = 1, it follows that A = B;
‚Äì for A ‚àíB > 0, C = 1 and Z = 0, it follows that A > B;
‚Äì for A ‚àíB < 0, C = 0 and Z = 0, it follows that A < B.
An ALU can be designed to carry out any operation. The more complex the
operation, the greater the unit‚Äôs required size and power consumption. In practice, a
tradeoff is made to implement an ALU whose size remains moderate so as not to
critically affect the power consumption and operating speed. As a consequence, more
complex operations may be carried out in an iterative manner or using a specialized
unit.

136
Digital Electronics 2
4.5. Multiplier
A cellular digital multiplier is a combinational circuit that calculates and sums the
partial products that make up the product of two numbers, X and Y . The product of
two n-bit numbers, X and Y , is a number of 2n bits, P = X √ó Y .
4.5.1. Multiplier of 2-bit unsigned numbers
Considering X = X1X0 and Y = Y1Y0 as two 2-bit unsigned binary numbers, the
multiplication is carried out as shown in Figure 4.22. The logic circuit of a 2 √ó 2-bit
multiplier is given in Figure 4.23, where the partial products are generated by the four
AND logic gates and the product bits, with the exception of the least signiÔ¨Åcant bit,
are supplied by two HAs whose role is to combine the partial products.
X1
X0
√ó
Y1
Y0
Y0X1
Y0X0
+
Y1X1
Y1X0
P3
P2
P1
P0
Figure 4.22. Multiplication of two 2-bit numbers
0
3
HA
B
A
C
S
HA
B
A
C
S
P1
P0
Y1
X1
P2
Y0
Y1
Y0
X
P
Figure 4.23. Logic circuit of a 2 √ó 2-bit multiplier

Arithmetic and Logic Circuits
137
4.5.2. Multiplier of 4-bit unsigned numbers
A simple cellular multiplier is based on shift and add algorithm. The multiplication
of two 4-bit unsigned binary numbers, X = X3X2X1X0 and Y = Y3Y2Y1Y0, is
carried out as illustrated in Figure 4.24.
X3
X2
X1
X0
√ó
Y3
Y2
Y1
Y0
Y0X3
Y0X2
Y0X1
Y0X0
Y1X3
Y1X2
Y1X1
Y1X0
Y2X3
Y2X2
Y2X1
Y2X0
+
Y3X3
Y3X2
Y3X1
Y3X0
P7
P6
P5
P4
P3
P2
P1
P0
Figure 4.24. Multiplication of two 4-bit numbers
The logic circuit for a 4√ó4-bit cellular multiplier is given in Figure 4.25. The AND
logic gates are used to compute the partial products YiXj, where i, j ‚àà{0, 1, 2, 3}.
i
P0
Y1
Y2
Y3
Ci+1
MC
MC
MC
MC
MC
P5
P4
P7
P6
X1
X2
MC
MC
MC
P1
P2
P3
X3
X0
Y0
Yi
Xi
B
Ci
x
A
FA
S
MC
HA
A
B
C
S
y
Yi
X
Figure 4.25. 4 √ó 4-bit cellular multiplier
In general, an n√ón cellular multiplier requires n2 AND gates, n HAs and n2 ‚àí2n
FAs. The propagation delay of the multiplier is caused by the propagation of carries
between the adders. There are several critical pathways of identical length that pass
through an AND gate and 3n ‚àí4 adders; this is because of the matrix structure of
the multiplier. Assuming that œÑsum ‚â•œÑcarry, where œÑcarry and œÑsum represent the

138
Digital Electronics 2
propagation delays between the adder inputs and each output Ci+1 and S, respectively,
and that œÑAND designates the AND gate propagation delay, the propagation delay of
the multiplier can be expressed as follows:
œÑ = (2n ‚àí3)œÑcarry + (n ‚àí1)œÑsum + œÑAND
[4.34]
Using other adder architecture that is faster will, thus, reduce the propagation delay
and increase the operating speed of the multiplier.
Another approach used to implement a multiplier is given in Figure 4.26, where
all multiplier cells are identical. It is based on the use of a systolic network that offers
the advantage of modularity and is suitable for integrated-circuit implementation.
MC
0
Ci+1
MC
MC
MC
MC
MC
MC
MC
P1
P2
P5
P4
P3
P7
P6
Y3
Y2
MC
MC
MC
MC
Y1
MC
P0
MC
MC
MC
MC
X1
X2
X0
3
0
0
0
0
0
0
0
0
X
Yi
Xi
B
Ci
x
A
FA
S
Y
Figure 4.26. 4 √ó 4-bit cellular multiplier based on a systolic network
4.5.3. Multiplier for signed numbers
The multiplication of signed numbers is quite simple in a sign-magnitude
representation. It is carried out as shown earlier for bits representing the magnitudes,
while the sign bits are applied to the inputs of a XOR logic gate to determine the
product sign. However, in two‚Äôs complement representation, multiplication is carried
out using other algorithms.

Arithmetic and Logic Circuits
139
Consider the signed numbers X and Y , which can be expressed in n-bit two‚Äôs
complement representation, as follows:
X = ‚àíXn‚àí12n‚àí1 +
n‚àí2

i=0
Xi2i
[4.35]
and:
Y = ‚àíYn‚àí12n‚àí1 +
n‚àí2

j=0
Yj2j
[4.36]
where the sign-bits are represented by Xn‚àí1 and Yn‚àí1. The product P is given by the
following equations:
P = X ¬∑ Y
[4.37]
=

‚àíXn‚àí12n‚àí1 +
n‚àí2

i=0
Xi2i

‚àíYn‚àí12n‚àí1 +
n‚àí2

j=0
Yj2j

[4.38]
= Xn‚àí1Yn‚àí122n‚àí2 +
n‚àí2

i=0
n‚àí2

j=0
XiYj2i+j‚àí
Yn‚àí12n‚àí1
n‚àí2

i=0
Xi2i ‚àíXn‚àí12n‚àí1
n‚àí2

j=0
Yj2j
[4.39]
The multiplication of two 4-bit signed numbers can be executed as illustrated in
Figure 4.27. It can be seen that it is necessary to add a sign extension to each line of
partial products. In addition, to obtain the right value of the product, the addition of
the Ô¨Årst lines of partial products must be followed by the subtraction of the last line
of partial products. In this case, the direct approach to implementing the multiplier
results in an increase of the hardware cost.
The sum of a number, A, and it‚Äôs one‚Äôs complement, A, is a number whose n bits
are all set at 1, or 2n ‚àí1. In other words, we have:
A + A = 2n ‚àí1
[4.40]

140
Digital Electronics 2
X3
X2
X1
X0
√ó
Y3
Y2
Y1
Y0
X3Y0
X3Y0
X3Y0
X3Y0
X3Y0
X2Y0
X1Y0
X0Y0
+
X3Y1
X3Y1
X3Y1
X3Y1
X2Y1
X1Y1
X0Y1
+
X3Y2
X3Y2
X3Y2
X2Y2
X1Y2
X0Y2
‚àí
X3Y3
X3Y3
X2Y3
X1Y3
X0Y3
P7
P6
P5
P4
P3
P2
P1
P0
Figure 4.27. Multiplication of two 4-bit signed numbers
This leads to:
‚àíYn‚àí12n‚àí1
n‚àí2

i=0
Xi2i = 2n‚àí1

‚àí2n‚àí1 +
n‚àí2

i=0
XiYn‚àí12i + 1

[4.41]
‚àíXn‚àí12n‚àí1
n‚àí2

j=0
Yj2j = 2n‚àí1

‚àí2n‚àí1 +
n‚àí2

j=0
Xn‚àí1Yj2j + 1

[4.42]
The product, P, then takes the following form:
P = Xn‚àí1Yn‚àí122n‚àí2 +
n‚àí2

i=0
n‚àí2

j=0
XiYj2i+j
+ 2n‚àí1
n‚àí2

i=0
XiYn‚àí12i + 2n‚àí1
n‚àí2

j=0
Xn‚àí1Yj2j ‚àí22n‚àí1 + 2n
[4.43]
The multiplication of two 4-bit signed numbers is illustrated in Figure 4.28. The
partial products are transformed and reorganized so that the multiplier implementation
can now require only one arithmetic operation (addition).
X3
X2
X1
X0
√ó
Y3
Y2
Y1
Y0
1
Y0X3
Y0X2
Y0X1
Y0X0
Y1X3
Y1X2
Y1X1
Y1X0
Y2X3
Y2X2
Y2X1
Y2X0
+
1
Y3X3
Y3X2
Y3X1
Y3X0
P7
P6
P5
P4
P3
P2
P1
P0
Figure 4.28. Multiplication of two 4-bit signed numbers

Arithmetic and Logic Circuits
141
The logic circuit for the corresponding multiplier (Baugh‚ÄìWooley) is represented
in Figure 4.29, where the MC and MC‚àócells are based on an AND gate and a NAND
gate, respectively.
C
MC*
MC*
MC*
3
X
X2
X1
X0
Y0
Y3
Y2
Y1
Ci+1
MC*
Yi
Xi
x
B
Ci
A
FA
S
MC
P7
MC
MC
MC
P1
P2
P5
P4
P3
P6
MC
MC
MC
P0
0
0
0
MC*
MC*
1
HA
1
A
B
S
Figure 4.29. 4 √ó 4-bit (Baugh‚ÄìWooley) multiplier for signed numbers
In a multiplication, the product is obtained as the sum of the partial products, which
increase in number as the word-lengths of the multiplicand and the multiplier become
large. It is possible to reduce the number of partial products using Booth‚Äôs algorithm
to encode the multiplicand bits. This encoding has the advantages of resulting in a
multiplier implementation with a reduced hardware cost and operating at a high speed.
In the two‚Äôs complement representation, the multiplicand can be expressed as
follows:
Y = ‚àíYn‚àí12n‚àí1 +
n‚àí2

j=0
Yj2j
[4.44]
By separating terms of odd and even ranks we have:
Y = ‚àíYn‚àí12n‚àí1 +
n/2‚àí1

j=0
Y2j‚àí122j‚àí1 +
n/2‚àí1

j=0
Y2j22j
[4.45]

142
Digital Electronics 2
With the application of the following identity:
Yk2k =

2Yk ‚àí1
22Yk

2k = Yk2k+1 ‚àí2Yk2k‚àí1
[4.46]
to an odd term, we arrive at:
Y = ‚àíYn‚àí12n‚àí1+
n/2‚àí1

j=0
Y2j‚àí122j +
n/2‚àí1

j=0
Y2j22j ‚àí2
n/2‚àí1

j=0
Y2j‚àí122j‚àí2[4.47]
The transformation j ‚Üík + 1 can be used to combine the Ô¨Årst term and the last
term in the above-mentioned expression for Y as follows:
‚àíYn‚àí12n‚àí1 ‚àí2
n/2‚àí1

j=0
Y2j‚àí122j‚àí2 = ‚àíYn‚àí12n‚àí1 ‚àí2
n/2‚àí2

k=‚àí1
Y2k+122k
[4.48]
= ‚àí2
n/2‚àí1

k=‚àí1
Y2k+122k
[4.49]
Assuming that Y‚àí1 = 0, we Ô¨Ånally obtain:
Y =
n/2‚àí1

j=0
(Y2j‚àí1 + Y2j ‚àí2Y2j+1)22j
[4.50]
The product of the numbers X and Y can thus take the following form:
P = X ¬∑ Y =
n/2‚àí1

j=0
X(Y2j‚àí1 + Y2j ‚àí2Y2j+1)22j
[4.51]
Hence, three bits are simultaneously involved in the encoding used to obtain each
partial product, PPj, which may be added or deducted from the result. The value of
the expression in parentheses is either 0, or ¬±1, or ¬±2. The partial products generated
are multiples of the multiplicand, that is ‚àí2X, ‚àíX, 0, X and 2X, and their number,
when compared with an ordinary multiplication, is practically halved. The encoding
of the multiplicand bits based on Booth‚Äôs algorithm is presented in Table 4.10. It must
be noted that a left shift operation can be used to obtain a partial product of the form,

Arithmetic and Logic Circuits
143
2X, or to implement the multiplication by a factor of 2, and the negative form of a
partial product is obtained by Ô¨Årst forming the one‚Äôs complement and then adding 1 to
the result.
Multiplier
Selection
Y2j+1 Y2j Y2j‚àí1
PPj
0
0
0
0
0
0
1
+X
0
1
0
+X
0
1
1
+2X
1
0
0
‚àí2X
1
0
1
‚àíX
1
1
0
‚àíX
1
1
1
0
Table 4.10. Encoding of the multiplicand bits
based on Booth‚Äôs algorithm
The application of Booth‚Äôs encoding helps reduce the number of the partial
product lines, as illustrated in the examples of signed-number multiplication
presented in Figure 4.30. A Y‚àí1 bit, which is always equal to 0, is added to the
binary sequence of the multiplicand. In addition, a partial product line is completed
by the sign extension each time the value of the left-most bit is equal to 1.
1
0
Y
1
2
3
Y Y Y
1
Y
0
Y
1
2
3
Y Y Y
1
Y
0   1   0   1
+X
+X
(0)
+
1   1   0   1   1   0   0
1
Multiplier (Y)
1   1   0   0
Multiplicand (X)
1
1   1   0   0
1
1   1   0   0
1
Product
(a)
1   0   1   0 (0)
2X
X
1   1   0   1
Multiplicand (X)
Multiplier (Y)
Product
 3
x
18
 6
(b)
 20
 4
x
5
0   0   1   0
+
0   1   0   1
0   1   0   0   1   0
1
Figure 4.30. Examples of multiplication based on Booth‚Äôs algorithm.
For a color version of the Ô¨Ågure, see www.iste.co.uk/
ndjountche/electronics2.zip
4.6. Divider
The division of an m-bit number or dividend, A, by an n-bit (n ‚â§m) number, or
the divisor D, generally yields a quotient Q and a remainder R. Thus, A = Q√óD+R,
where D Ã∏= 0, R < D, and R has the same sign as A.

144
Digital Electronics 2
With a dividend A of 2n bits and a divisor D of n bits, the division with restoration
may be executed according to the algorithm 4.1.
Algorithm 4.1. Division with restoration
Result: quotient Q = Qn‚àí1 ¬∑ ¬∑ ¬∑ Q2Q1Q0 and remainder R(0)
[1] Initially, assign the value of the dividend to the partial remainder, R(0) = A, and set
the most signiÔ¨Åcant bit of the quotient to 1 (Qn‚àí1 = 1);
[2] For i = 0, 1, 2, ¬∑ ¬∑ ¬∑ , n ‚àí1:
calculate the partial remainder:
R(i + 1) = 2R(i) ‚àíQn‚àí(i+1) √ó D
where 0 ‚â§R(i) < D and D is the divisor;
if R(i + 1) ‚â•0, then
Qn‚àí(i+1) = 1;
else
Qn‚àí(i+1) = 0, and the previous value of the remainder must be restored
partial;
After the last iteration, the quotient Q = Qn‚àí1 ¬∑ ¬∑ ¬∑ Q2Q1Q0 and R(0) represent
the Ô¨Ånal remainder.
The logic circuit of a cellular divider based on the algorithm for division with
restoration is illustrated in Figure 4.31, in the case where n = 4. It consists of
controlled-subtract (CS) cells, comprising a full subtractor and a 2 : 1 multiplexer,
OR logic gates and inverters.
Initially, the partial remainder is assumed to be identical to the dividend. The
multiplication by 2 is carried out by shifting the most signiÔ¨Åcant bit of the partial
remainder one position to the left with respect to that of the divisor. After each of the
four subtractions, the partial remainder takes the value of the difference obtained if
the output borrow of a row of S cells is set to 0, otherwise the previous value of the
partial remainder is restored. The corresponding bit in the quotient is obtained as the
OR logic function of the output borrow complement and the most signiÔ¨Åcant bit of
the partial remainder.
In general, performing a division with a dividend of 2n bits and a divisor of n bits
requires n2 CS cells and n OR gates and inverters.
Figure 4.32 gives two examples of the division operation executions. Each time
that the result of the subtraction is negative, the partial remainder is restored to its
previous value.
Another approach that can be adopted to carry out cellular division is based on
the algorithm for division without restoration. Compared to the division with

Arithmetic and Logic Circuits
145
restoration method, this offers the advantage of reducing the number of operation
(addition/subtraction) required, especially in cases where the quotient contains
several zeros. However, it has the disadvantage of requiring an additional stage for
the correction of the Ô¨Ånal remainder.
Sel
i
Bi
Bi
Bi
Bi
Bi
Bi
Bi
Bi
Bi
Bi
Bi
Bi
Bi
Bi
Bi
3
D
2
D
1
D
0
D
7
A
6
A
5
A
4
A
3
A
3
Q
2
Q
1
Q
0
Q
0
A
2
A
1
A
Bi+1
Bi
3
R
0
R
1
R
2
R
R
CS
X
Y
Bi+1
Sel
R
CS
X
Y
Bi+1
Sel
R
CS
X
Y
Bi+1
Sel
R
CS
X
Y
Bi+1
Sel
R
CS
X
Y
Bi+1
Sel
R
CS
X
Y
Bi+1
Sel
R
CS
X
Y
Bi+1
Sel
R
CS
X
Y
Bi+1
Sel
R
CS
X
Y
Bi+1
Sel
R
CS
X
Y
Bi+1
Sel
R
CS
X
Y
Bi+1
Sel
R
CS
X
Y
Bi+1
Sel
0
0
R
CS
X
Y
Bi+1
Sel
R
CS
X
Y
Bi+1
Sel
R
CS
X
Y
Bi+1
Sel
R
CS
X
Y
Bi+1
Sel
0
0
CS
X
Y
D
FS
R 0
1
B
Figure 4.31. Cellular divider based on the algorithm for
division with restoration of the dividend
1 0 1
0 1 1 1
1 1 1 0
0
0
1
Q2
1 0 1
0 0 1
9
10 = 01100100
10 =  1001
(b)
1 0 0 1
1 1 0 0
0
0
1
Q3
100
0
14
17310 = 10101101
10 =  1110
(a)
1 0 0
0 1 1
0 0
1 0 0 1
0
Q2
1
1 0 0
1 1 0
0
 1 1
0 0
1 1 1 0
1
Q1
0
0 1
1 0 0
0
0 1
1 0 0 1
Q1
1
0
1 1 1 0 0
0 1 0 1
0
0 1 1 1
1
Q0 =  Quotient
0
1 1 1 0
0 1 0 1
0
1 0 1
0 0 0 1
0
Q0 =  Quotient
1
1 0 0 1
0
0
Remainder = 0101
Remainder = 0001
1 1 1 0
0
0 1 0 1
1
1
1
Q3
1 1 1
Figure 4.32. Examples of division with restoration: a) 173 √∑ 14 (Q = 12,
R = 5); b) 100 √∑ 9 (Q = 11, R = 1). For a color version of the Ô¨Ågure,
see www.iste.co.uk/ndjountche/electronics2.zip

146
Digital Electronics 2
M
D
3
D
2
D
8
A
7
A
6
A
U
Y
Ci
Ci+1
M
M
Ci
Ci
Ci+1
Ci
Ci+1
Ci
Ci+1
Ci
Ci+1
4
Q
3
Q
1
D
5
A
M
Ci
Ci+1
Ci+1
4
A
M
Ci
Ci
2
A
Ci+1
Ci
X
Y
R
FA
CAS
Ci
Ci
Ci+1
Ci
Ci+1
Ci
1
Q
Ci+1
Ci
Ci
Ci
Ci+1
Ci
Ci+1
Ci
Ci+1
Ci+1
Ci
Ci+1
Ci
Ci+1
Ci
0
Q
3
R
4
R
Ci+1
Ci
Ci+1
Ci
0
R
1
R
2
R
Ci+1
Ci
1
A
0
A
Ci+1
3
A
Ci
0
D
Ci
Ci
Ci+1
Ci
Ci+1
Ci
2
Q
Ci+1
Ci
R
CAS
U
Y
R
CAS
R
CAS
V
Y
R
CAS
U
Y
R
CAS
U
Y
R
CAS
U
Y
M
Ci+1
1
M
Ci+1
M
M
R
CAS
U
Y
R
CAS
U
Y
R
CAS
U
Y
M
R
CAS
U
Y
R
CAS
U
Y
R
CAS
Y
R
CAS
U
M
M
Ci+1
U
Y
M
M
Ci+1
R
CAS
U
Y
M
R
CAS
U
Y
R
CAS
U
Y
R
CAS
U
Y
R
CAS
U
Y
M
M
M
M
Ci+1
X
Y
S
FA
X
Y
S
FA
X
Y
S
FA
Correction
X
Y
S
FA
X
Y
S
FA
0
R
CAS
U
Y
M
R
CAS
U
Y
M
R
CAS
U
Y
R
CAS
U
Y
R
CAS
Y
R
CAS
U
M
M
Ci+1
U
Y
M
M
Ci+1
R
CAS
U
Y
4
Figure 4.33. Cellular division based on the algorithm for division
without restoration of the dividend
Initially, the partial remainder is supposed to take the value of the dividend.
Assuming that D > 0 and |R(i + 1)| < D, the partial remainders R(i + 1)
(i = 0, 1, 2, ¬∑ ¬∑ ¬∑ , n ‚àí1) can be positive or negative.
The operation to be carried out at each iteration can be a subtraction or an addition,
depending on the value of the partial remainder whose expression is given by:
R(i + 1) =

2R(i) ‚àíD
if
2R(i) > 0
2R(i) + D
if
2R(i) < 0
[4.52]
The corresponding quotient bits are determined as follows:
Qn‚àí(i+1) =

1
if
0 < 2R(i) < D
‚àí1
if
‚àíD < 2R(i) < 0
[4.53]

Arithmetic and Logic Circuits
147
The quotient is represented by a sequence of signed digits2, whose value may be
either 1 or ‚àí1 but not 0, and must then be converted to two‚Äôs complement.
For division without restoration the partial remainder is negative when 2R(i) < D,
but, instead of being restored to its previous value (that is, 2R(i), in order to then be
transformed according to the relationship 2[2R(i)] ‚àíD = 4R(i) ‚àíD, as in the case
of division with restoration) it is kept unchanged and is only corrected in the next
iteration. It thus becomes 2[2R(i) ‚àíD] + D = 4R(i) ‚àíD. The result of both types
of division are, therefore, identical. However, a correction of the Ô¨Ånal remainder value
is required in the case of division without restoration when the last partial remainder
is negative. This corresponds to the addition of the divisor to the remainder, whose
correct value can then be obtained as follows:
R = Rn + D = 2Rn‚àí1
[4.54]
The algorithm for division without restoration can be transformed into a version
that can directly generate a quotient and a remainder of n + 1 bits, both represented
in two‚Äôs complement, from a dividend of 2n bits and a divisor of n bits. Its different
steps are deÔ¨Åned by algorithm 4.2.
Algorithm 4.2. Division without restoration
[1] When the dividend and divisor are positive, the Ô¨Årst step consists of subtracting the
divisor from the dividend with both most signiÔ¨Åcant bits aligned. If the obtained partial
remainder is thus positive, one bit of the quotient is set to 1 and the next operation is
a subtraction; if, on the other hand, the obtained partial remainder is negative, one bit
of the quotient is set to 0 and the next operation is an addition.
[2] For each of the following steps, the execution of the previously-determined operation
is carried out after the most signiÔ¨Åcant bit of the partial remainder is shifted to the
left with respect to that of the divisor. If the obtained partial remainder is positive, the
corresponding bit in the quotient is set to 1 and the next operation is a subtraction;
otherwise, the corresponding bit of the quotient is set to 1 and the next operation is an
addition.
The previously mentioned version of the algorithm for division without restoration
is most suitable for cellular divider implementation. The logic circuit for a 8 √ó 4
2 The following steps can be used to convert a binary sequence of n signed digits (1 or ‚àí1) to
two‚Äôs complement:
‚Äì transform each ‚àí1 to 0 to form a code P = pn‚àí1pn‚àí2 ¬∑ ¬∑ ¬∑ p2p1p0, where the value of
each bit, pk (k = 0, 1, 2, ¬∑ ¬∑ ¬∑ , n ‚àí1), is either 0 or 1;
‚Äì obtain the two‚Äôs complement representation by shifting the bits one position to the left
and by inserting 1 in the position of the least signiÔ¨Åcant bit, that is Q = pn‚àí2 ¬∑ ¬∑ ¬∑ p2p1p01.

148
Digital Electronics 2
cellular divider is represented in Figure 4.33. The regular section, comprising CAS
(controlled adder/subtract) cells, is used to generate the partial remainders and the
stage composed of FAs and AND logic gates is used for the correction of the Ô¨Ånal
remainder.
Remainder = 0001
= 001100100
100
910 =  01001
Q0
0
1
Q3
0
Q4
Q2
1
Q1
1
10 =  001010111
87
610 =  00110
(a)
(b)
0 0 0 1 1
1 1 0 0 1
+
1
0 0 1 1 1
1 1 0 0 1
1
+
1
0 0 0 1
0
1 1
1
0
1 1 0 0 1
0 1 0 0 1
0 0 1 1
+
0 0 1 1 0
1 1 1
 
1 1 1 0
+
0
0 1 0 0
1
1
1 1 0 0 1
0
0 1 1 1
+
1
0 0 1 0 1
1
1
1 1 1
0 
1
1
0
+
0 0 0 1 1
1 1 0 1
0 0 1 1 0
1
=  Quotient
Remainder = 00011
=  Quotient
0 1 0 1 0
1 0 1 1 0
+
1
0 0 0 1
0
1 1 1 0 0
0 1 0 0 1
0
+
0
0 1 0 1
0
0 0
1
1
1 0 1 1 0
0 0 1 1 1
1 1 1 0
+
0 1 0 0 1
1 0 0
 
1 0 1 0
+
0
0 0 1 1
1
1
Q3
1
1 0 1 1 0
0
0 1 0 0
+
1
0 0 1 1 0
1
1
1 0 1
0
Q4
0 
Q2
0
0
1
Q1
1
1
Q0
1
10
Figure 4.34. Examples of division without restoration: a) 100 √∑ 9
(Q = 11,R = 1); b) 87 √∑ 6 (Q = 14, R = 3). For a color version of the
Ô¨Ågure, see www.iste.co.uk/ndjountche/electronics2.zip
Each line of CAS cells, each of which comprises an FA and an XOR logic gate,
carries out either a subtraction or an addition based on the state, 1 or 0, applied to one
of the two inputs of the XOR logic gates. Subtraction is performed in two‚Äôs
complement
representation
by
adding
each
partial
remainder
to
the
one‚Äôs
complement of the divisor and by setting the input carry of the right-most CAS cell
to 1. Each bit of the quotient corresponds to the carry-out generated by the left-most
CAS cell, and which represents the complement of the sign-bit of the corresponding
partial remainder.
When the last bit of the quotient is 0, the last partial remainder is negative and a
correction based on a conditional addition is necessary to obtain the correct value of
the Ô¨Ånal remainder.
To divide a 2-bit number, A, by an n-bit number, D, and to obtain a quotient Q
and a remainder R of n-bits, (n + 1)2 CAS cells and n + 1 FAs and AND logic gates

Arithmetic and Logic Circuits
149
are required. This is due to the fact that subtractions are carried out on n + 1 bits in a
cellular divider based on the algorithm for division without restoration of the dividend.
Two examples for the execution of division operations are illustrated in
Figure 4.34. The division is carried out as a succession of left-shift operations by one
bit followed by either a subtraction or an addition.
4.7. Exercises
EXERCISE 4.1.‚Äì Design a half subtractor and a full subtractor.
EXERCISE 4.2.‚Äì Two‚Äôs complement generator.
A two‚Äôs complement generator,
that can provide the two‚Äôs complement
representation of a four-bit binary number after having changed its sign, is to be
designed. This circuit has the inputs B3, B2, B1 and B0, and the outputs T3, T2, T1
and T0. Its operation is described by the truth table given in Table 4.11.
Inputs
Outputs
B3
B2
B1
B0
T3
T2
T1
T0
0
0
0
0
0
0
0
0
0
0
0
1
1
1
1
1
0
0
1
0
1
1
1
0
0
0
1
1
1
1
0
1
0
1
0
0
1
1
0
0
0
1
0
1
1
0
1
1
0
1
1
0
1
0
1
0
0
1
1
1
1
0
0
1
1
0
0
0
1
0
0
0
1
0
0
1
0
1
1
1
1
0
1
0
0
1
1
0
1
0
1
1
0
1
0
1
1
1
0
0
0
1
0
0
1
1
0
1
0
0
1
1
1
1
1
0
0
0
1
0
1
1
1
1
0
0
0
1
Table 4.11. Truth table
a) simplify the functions T0, T1, T2 and T3 using the Karnaugh map;

150
Digital Electronics 2
b) for each of the functions T1, T2 and T3, determine Xi‚àí1 so that the next logic
expression is veriÔ¨Åed:
Ti = Xi‚àí1 ‚äïBi,
i = 1, 2, 3.
c) implement this circuit using only 2-input OR and XOR gates.
EXERCISE 4.3.‚Äì Let P and Q be two 2-bit binary numbers; X, Y and Z are three
1-bit binary numbers. Propose a logic circuit using a comparator and multiplexer to
implement the following loop:
If
P = Q
then
Z = Y ;
else
Z = X;
End
EXERCISE 4.4.‚Äì Express the logic functions E and F as functions of X, Y and Ci.
Show that the logic circuit depicted in Figure 4.35 is an FA.
F
Y
X
Ci
E
Figure 4.35. Logic circuit
EXERCISE 4.5.‚Äì Implement an FA using 4 : 1 multiplexers.
EXERCISE 4.6.‚Äì Propose a circuit to add Ô¨Åve 1-bit numbers, D, E, F, G and H, using
an HA and two FAs.
EXERCISE 4.7.‚Äì Logic unit.
Consider a logic unit implemented from a 4 : 1 multiplexer, as shown in
Figure 4.36. The select inputs are represented by S0, S1, S2 and S3, and A and B
designate the input variables.

Arithmetic and Logic Circuits
151
4:1
B
A
10
01
00
11
S1
S2
S0
S3
F
MUX
Figure 4.36. Multiplexer logic circuit
How many logic functions of a maximum of two variables can be implemented
with this logic unit?
EXERCISE 4.8.‚Äì Arithmetic unit.
Using an FA (input carry bit Ci), AND and OR logic gates and inverter, and two
select inputs, S0 and S1, design a logic circuit that can perform the operations given
in Table 4.12.
S1S0
Ci = 0
Ci = 1
00
F = A + B (addition)
F = A + B + 1
01
F = A (transfer)
F = A + 1
10
F = B (inversion)
F = B + 1 (negation)
11
F = A + B
F = A + B + 1 (subtraction)
Table 4.12. Arithmetic operations
EXERCISE 4.9.‚Äì BCD adder.
Consider the BCD adder shown in Figure 4.37, some of which can be connected in
cascade to carry out an n-bit operation. BCD digits vary from 0000 to 1001 (or 0 to 9).
Two BCD digits are required for the representation of numbers larger than 1001 (or 9).
The output, F, of the correction circuit permits the detection of a sum, C4S3S2S1S0,
larger than 01001 (or 9) and smaller than 10011 (or 19), and the second adder adds
0110 (or 6) to this sum depending on F‚Äôs state.
Propose an implementation of the correction circuit using logic gates.
Verify the operation of the BCD adder using the following numbers:
‚Äì X = 9 and Y = 7;
‚Äì X = 34 and Y = 19.

152
Digital Electronics 2
BCD sum
S0
S1
S2
S3
0
0
C0
Ci
0
1
2
3
n+1
C0
X
Y
F
X1
X2
X3
X0
X1
X2
X3
X0
Y0
Y1
Y2
Y3
Y0
Y1
Y
Y3
n1
Ci
C0
A1
A2
A3
A0
B0
B1
B2
B3
C4
Correction
2
Ci
circuit
Adder 1
Adder 2
Figure 4.37. BCD adder
EXERCISE 4.10.‚Äì Analysis of a logic circuit.
The logic circuit shown in Figure 4.38 is implemented using 2 : 1 multiplexers and
logic gates (inverter, NOR and XOR). Two unsigned 2-bit numbers, X = X1X0 and
Y = Y1Y0, are applied to the inputs, and A, B and C designate the outputs.
0
0
1
0
1
A
B
C
Y1
Y0
X1
X
Figure 4.38. Logic circuit
Determine the logic equation for each of the outputs.
Deduce the function implemented by this circuit.

Arithmetic and Logic Circuits
153
EXERCISE 4.11.‚Äì Cascadable comparator cell.
Implement a 1-bit cascadable comparator using only NAND gates.
EXERCISE 4.12.‚Äì Cascadable comparator.
section
n2
Bn1
A n1
A n2
A 0
B0
0
0
x i
i
y
x i
i
y
x i
i
y
x i
i
y
comparator
cell
1bit
comparator
cell
1bit
comparator
cell
1bit
B
A
B
A
B
A
i+1
y
x i+1
i+1
y
x i+1
i+1
y
x i+1
A<B
OA=B
A>B
O
O
Output
B
Figure 4.39. n-bit cascadable comparator
xi
yi
OA>B
OA=B
OA<B
0
0
0
1
0
0
1
1
0
0
1
0
0
0
1
1
1
0
0
0
Table 4.13. Function table of the comparator
Another approach used to implement a cascadable comparator for two numbers
(An‚àí1 and Bn‚àí1 are the most signiÔ¨Åcant bits):
A = An‚àí1An‚àí2 ¬∑ ¬∑ ¬∑ A0
and
B = Bn‚àí1Bn‚àí2 ¬∑ ¬∑ ¬∑ B0
consists of encoding the three possible outputs using two variables. In this case, as
shown in Figure 4.39, each comparator cell only supplies two output signals and one
output section is used to generate the comparison result in terms of equality, larger,
or smaller. Table 4.13 gives the function table where the combination of variables
xiyi take the values 00, 01 and 10, respectively, for the outputs OA=B, OA>B and
OA<B. The code xiyi = 11 is not associated with any comparison result and is, thus,
considered as a don‚Äôt-care code for the outputs xi+1 and yi+1.
Draw up the truth table of the comparator, considering xi, yi, A and B, as inputs
and xi+1, yi+1, OA=B, OA>B and OA<B, as outputs.
Determine the output logic equations.
Represent the logic circuits for a comparator cell and the output section.

154
Digital Electronics 2
EXERCISE 4.13.‚Äì Consider the logic circuit shown in Figure 4.40, that is implemented
using two FAs and logic gates and where A = A1A0 and B = B1B0 are two numbers.
E
2
1
S0
S1
C1
0
B
Z
C
FA
S
Ci+1
Ci
A
B
FA
S
Ci+1
Ci
A
B
V
N
G
L
1
A
1
B
0
A
Figure 4.40. Logic circuit
Determine the logic expressions for G, E and L as functions of N, V and Z.
Construct a truth table where A1, A0, B1 and B0 are considered as inputs and N,
V and Z, as outputs.
Establish a logic relationship between E, G and L.
What is the role of this circuit?
Modify the proposed logic circuit to implement a comparator for 4-bit signed
numbers.
EXERCISE 4.14.‚Äì Arithmetic and logic unit.
A 4-bit ALU can be implemented by cascading four 1-bit stages, as shown in
Figure 4.41. It can be used to carry out addition and subtraction operations and NOT,
AND, OR and XOR logic functions.
Determine the logic equations for the outputs F and Ci+1.
Complete the function table given in Table 4.14.

Arithmetic and Logic Circuits
155
i+1
A
B
S
F
ALU
Ci+1
Ci
A
B
S
F
ALU
Ci+1
Ci
A
B
S
F
ALU
Ci+1
Ci
A
B
S
F
ALU
Ci+1
Ci
A
B
S
F
ALU
Ci+1
Ci
1
F0
3
A2
B2
A1
B1
A0
B0
A3
B3
S
0
C4
C
C
3
B
F
A
S0
B
S
S2
S2
S1
S1
2
Ci
(b)
(a)
F3
F2
F
Figure 4.41. a) Four-bit arithmetic and logic unit; b) 1-bit arithmetic and
logic unit
S2S1S0
F
Ci+1
Operation
Transfer (Ci = 0) or
0 0 0
Incrementing (Ci = 1) of A
1‚Äôs complement (Ci = 0) or
0 0 1
2‚Äôs complement (Ci = 1) of A
A plus B if Ci = 0 or
0 1 0
A ‚äïB ‚äïCi
A plus B plus 1 if Ci = 1
A plus B if Ci = 0 or
0 1 1
Ci ¬∑ (A ‚äïB) + A ¬∑ B
B minus A if Ci = 1
1 0 0
Transfer of A
1 0 1
Complement of A
1 1 0
A OR B
1 1 1
Complement of A OR B
Table 4.14. Operations implemented by the arithmetic and logic unit

156
Digital Electronics 2
EXERCISE 4.15.‚Äì Programmable logic circuit.
The programmable logic circuit shown in Figure 4.42 can be used to carry out
different arithmetic operations. It comprises an adder, two multiplexers, AND, OR,
XOR logic gates and inverters.
Sign bit
0
Ci
0
S
S1
S2
S
X
Y
FA
F(A,B)
0
1
0
1
A
B
C
Figure 4.42. Programmable logic circuit
Complete the function table given in Table 4.15, by determining the arithmetic
operations carried out depending on the select code S2S1S0.
S2
S1
S0
Operation
F(A, B)
0
0
1
1
0
0
1
0
1
1
1
0
1
1
1
Table 4.15. Function table
EXERCISE 4.16.‚Äì Bidirectional counter.
A bidirectional counter as shown in Figure 4.43 is made up of D Ô¨Çip-Ô¨Çops, 2 : 1
multiplexers and a half adder/subtractor (HAS). Figure 4.44 depicts the HAS circuit
and an application for the counter.
During the normal operation, the asynchronous Reset input is set to 1 and does not
affect the outputs; determine the logic equation of the next state, Q+ = D, for each
Ô¨Çip-Ô¨Çop and the logic equation for the RCO.

Arithmetic and Logic Circuits
157
Q
Q
D
CLR
Q
Q
D
CLR
Q
Q
D
CLR
Reset
P3 P2 P1 P0
Load
Reset
Dir
RCO
3
Cnt
Q3 Q2 Q1 Q0
0
1
2
3
3
0
1
Load
Dir
2
0
1
HAS
1
0
1
HAS
0
0
1
Cnt
HAS
HAS
CK
2
1
0
Q
Q
D
CLR
C
P
C
RCO
Q
P
P
Q
P
Q
C
C
Q
Figure 4.43. Logic circuit of the bidirectional counter
CK
i
(a)
0
0
0
0
i
i
i
Cnt
C0
Q3 Q2 Q1 Q0
i+1
= Cnt
HAS
Dir Dir
P3 P2 P1 P0
Load
Reset
Dir
0
(b)
C
Q
Q
C
D
Figure 4.44. a) Logic circuit of the half
adder/subtractor (HAS); b) application
Complete the function table given in Table 4.16.
Specify the type of counter implemented by the circuit of Figure 4.44(b).

158
Digital Electronics 2
Operations
CK
Reset
1
1
1
0
x
x
1
Load
Cnt
Dir
x
1
x
0
1
x
0
1
0
0
x
1
x
x
0
Inputs
Table 4.16. Function table
4.8. Solutions
SOLUTION 4.1.‚Äì Subtractor.
A full subtractor can be implemented using half subtractors and logic gates.
‚Äì Half subtractor:
Figure 4.45 illustrates the execution of a simple subtraction operation. Referring
to the truth table given in Table 4.17, we can deduce the logic equations of the half
subtractor as follows:
D = X ¬∑ Y + X ¬∑ Y = X ‚äïY
[4.55]
B = X ¬∑ Y
[4.56]
‚àí
Y
B  D
Difference
Borrow
X
Figure 4.45. Example of a subtraction operation. For a color version of
the Ô¨Ågure, see www.iste.co.uk/ndjountche/electronics2.zip
Figure 4.46 depicts the logic circuit and symbol for a half subtractor.

Arithmetic and Logic Circuits
159
X
Y
D
B
0
0
0
0
0
1
1
1
1
0
1
0
1
1
0
0
Table 4.17. Truth table of a half subtractor
Subtractor
B
B
Y
X
D
Half
X
Y
D
(a)
(b)
Figure 4.46. Half subtractor (HS): a) logic circuit; b) symbol
‚Äì Full subtractor:
A subtraction with a borrow-in and a borrow-out is represented in Figure 4.47.
The truth table given in Table 4.18 can be used to derive the logic equations of the full
subtractor, as follows:
D = X ¬∑ Y ¬∑ Bi + X ¬∑ Y ¬∑ Bi + X ¬∑ Y ¬∑ Bi + X ¬∑ Y ¬∑ Bi
= (X ¬∑ Y + X ¬∑ Y ) ¬∑ Bi + (X ¬∑ Y + X ¬∑ Y ) ¬∑ Bi
= (X ‚äïY ) ‚äïBi
[4.57]
B0 = X ¬∑ Y ¬∑ Bi + X ¬∑ Y ¬∑ Bi + X ¬∑ Y ¬∑ Bi + X ¬∑ Y ¬∑ Bi
= X ¬∑ Y + (X ¬∑ Y + X ¬∑ Y ) ¬∑ Bi
= X ¬∑ Y + (X ‚äïY ) ¬∑ Bi
[4.58]
Figure 4.48 depicts the logic circuit and symbol of a full subtractor.
‚àí
B0 D
i
Borrow‚àíin
Difference
Borrow‚àíout
Y
B
X
Figure 4.47. Example of a subtraction operation. For a color version of
the Ô¨Ågure, see www.iste.co.uk/ndjountche/electronics2.zip

160
Digital Electronics 2
X
Y
Bi
D
B0
0
0
0
0
0
0
0
1
1
1
0
1
0
1
1
0
1
1
0
1
1
0
0
1
0
1
0
1
0
0
1
1
0
0
0
1
1
1
1
1
Table 4.18. Truth table of a full subtractor
Full
X
Y
(a)
(b)
Bi
D
B0
X
Y
S
B0
Bi
subtractor
Figure 4.48. Full subtractor (FS): a) logic circuit; b) symbol
SOLUTION 4.2.‚Äì Two‚Äôs complement generator.
Based on the truth table of the circuit that can generate two‚Äôs complement, we
construct the corresponding Karnaugh map for each output, as shown in Figure 4.49.
The logic equations required for the circuit implementation can be written as follows:
‚Äì output T0:
T0 = B0
[4.59]
‚Äì output T1:
T1 = B0 ¬∑ B1 + B0 ¬∑ B1
= B0 ‚äïB1
[4.60]

Arithmetic and Logic Circuits
161
1
B
0
B
2
B
0
B
3
B
0
B
2
B
0
B
1
B
2
B
1
B
2
B
1
1
1
1
3
B
0
B
2
B
0
B
3
B
0
B
2
B
0
B
1
B
2
B
1
B
2
B
1
1
(c)
1
1
1
1
1
(a)
00
01
00
01
11
10
B1
3
B
00
01
00
01
11
10
B1
3
B
11
10
11
10
1
1
1
1
1
1
(b)
00
01
00
01
11
10
B1
3
B
1
(d)
1
1
1
00
01
00
01
11
10
B1
3
B
1
1
1
11
10
1
1
1
1
11
1
1
1
10
3
Figure 4.49. Karnaugh maps: (a) T0; (b) T1; (c) T2; (d) T3. For a color
version of the Ô¨Ågure, see www.iste.co.uk/ndjountche/electronics2.zip
‚Äì output T2:
T2 = B0 ¬∑ B2 + B1 ¬∑ B2 + B0 ¬∑ B1 ¬∑ B2
= (B0 + B1) ¬∑ B2 + (B0 + B1) ¬∑ B2
= (B0 + B1) ‚äïB2
[4.61]
‚Äì output T3:
T3 = B0 ¬∑ B3 + B1 ¬∑ B3 + B2 ¬∑ B3 + B0 ¬∑ B1 ¬∑ B2 ¬∑ B3
= (B0 + B1 + B2) ¬∑ B3 + (B0 + B1 + B2) ¬∑ B3
= (B0 + B1 + B2) ‚äïB3
[4.62]
The logic circuit of the two‚Äôs complement generator is represented in Figure 4.50.
SOLUTION 4.3.‚Äì Implementation of an If-then-else loop.
An If-then-else loop can be implemented by using a multiplexer and logic gates
(XNOR and AND).

162
Digital Electronics 2
T0
T1
T 2
T  3
B  1
B  2
B  0
B  3
Figure 4.50. Logic circuit
1
P1
Q
0
1
X
Y
Z
P0
Q0
Figure 4.51. Implementation of the If-then-else loop
The corresponding logic circuit is represented in Figure 4.51, where the
comparison section is composed of XNOR and AND logic gates.
SOLUTION 4.4.‚Äì Full adder.
Analyzing the proposed logic circuit we can obtain:
E = X ¬∑ Y + (X + Y ) ¬∑ Ci = X ¬∑ Y + (X + Y ) ¬∑ Ci
(= C0)
[4.63]
F = X ¬∑ Y ¬∑ Ci + (X + Y + Ci) ¬∑ E = X ¬∑ Y ¬∑ Ci + (X + Y + Ci) ¬∑ E
= X ¬∑ Y ¬∑ Ci + (X + Y + Ci) ¬∑ [X ¬∑ Y + (X + Y ) ¬∑ Ci]
= X ¬∑ Y ¬∑ Ci + (X + Y + Ci) ¬∑ (X ¬∑ Y + X ¬∑ Ci + Y ¬∑ Ci)
= X ¬∑ Y ¬∑ Ci + X ¬∑ Y ¬∑ Ci + X ¬∑ Y ¬∑ Ci + X ¬∑ Y ¬∑ Ci
(= S)
[4.64]
because E = C0 and F = S, it is an FA.

Arithmetic and Logic Circuits
163
SOLUTION 4.5.‚Äì Implementation of an FA using 4 : 1 multiplexers.
The logic equations of an FA are given by:
S = (A ¬∑ B + A ¬∑ B) ¬∑ Ci + (A ¬∑ B + A ¬∑ B) ¬∑ Ci
Ci+1 = A ¬∑ B + (A ¬∑ B + A ¬∑ B) ¬∑ Ci
[4.65]
They can be implemented using 4 : 1 multiplexers if they are decomposed as
follows:
S = (A ¬∑ B) ¬∑ Ci + (A ¬∑ B) ¬∑ Ci + (A ¬∑ B) ¬∑ Ci + (A ¬∑ B) ¬∑ Ci
C0 = (A ¬∑ B) ¬∑ 0 + (A ¬∑ B) ¬∑ Ci + (A ¬∑ B) ¬∑ Ci + (A ¬∑ B) ¬∑ 1
[4.66]
Figure 4.52 depicts the logic circuit of an FA based on 4 : 1 multiplexers.
4:1
0
E = 1
10
01
00
11
S
E = 1
0
1
A
B
10
01
00
11
Ci
MUX
4:1
MUX
C
Figure 4.52. Logic circuit of a full adder
SOLUTION 4.6.‚Äì Adder for Ô¨Åve 1-bit number.
To add Ô¨Åve 1-bit numbers, as shown in Figure 4.53(a), we can use the logic circuit
of Figure 4.53(b), which consists of two FAs and one HA.
(a)
1
S2
S0
S0
S1
S2
G
H
FA
S
Ci+1
Ci
A
B
D
E
C
HA
S
A
B
FA
S
Ci+1
Ci
A
B
F
(b)
D
E
F
G
H
+
S
Figure 4.53. a) Addition operation; b) logic circuit of the adder

164
Digital Electronics 2
SOLUTION 4.7.‚Äì Logic unit.
The analysis of the logic unit circuit can yield the following equation:
F = S0 ¬∑ A ¬∑ B + S1 ¬∑ A ¬∑ B + S2 ¬∑ A ¬∑ B + S3 ¬∑ A ¬∑ B
[4.67]
Table 4.19 shows the function table of the logic unit. By judiciously choosing the
select signals S0, S1, S2 and S3, we can implement all two-variable logic functions.
That is:
222 = 16
functions
S3
S2
S1
S0
F(A, B)
0
0
0
0
0
0
0
0
1
A ¬∑ B
0
0
1
0
A ¬∑ B
0
0
1
1
A
0
1
0
0
A ¬∑ B
0
1
0
1
B
0
1
1
0
A ‚äïB
0
1
1
1
A + B
1
0
0
0
A ¬∑ B
1
0
0
1
A ‚äôB
1
0
1
0
B
1
0
1
1
A + B
1
1
0
0
A
1
1
0
1
A + B
1
1
1
0
A + B
1
1
1
1
1
Table 4.19. Function table of the logic unit
SOLUTION 4.8.‚Äì Arithmetic unit.
The arithmetic unit is implemented using an FA whose logic equations take the
form:
S = F = (X ¬∑ Y + X ¬∑ Y ) ¬∑ Ci + (X ¬∑ Y + X ¬∑ Y ) ¬∑ Ci
C0 = X ¬∑ Y + (X ¬∑ Y + X ¬∑ Y ) ¬∑ Ci
[4.68]

Arithmetic and Logic Circuits
165
where:
X = A ¬∑ S1 + A ¬∑ S0
Y = B ¬∑ S1 ¬∑ S0 + B ¬∑ S1
The logic circuit of the arithmetic unit is depicted in Figure 4.54.
4:1
i
S1
S0
10
01
00
11
0
B
B
B
Y
C0
F
X
FA
A
S1
S0
MUX
C
Figure 4.54. Arithmetic circuit
SOLUTION 4.9.‚Äì BCD adder.
The sum of two BCD numbers varies from 010 = 000002 (0000+0000) to 1910 =
100112 (1001 + 1001 + 1), as shown in the function table of Table 4.20.
A BCD number only varies from 010 = 00002 to 910 = 10012, and a correction is
necessary for numbers greater than 9.
The correction consists of adding 610 = 01102 to the erroneous sums from 10 to
19.
Sums greater than 15 may be identiÔ¨Åed by C4 = 1, while for sums that vary from
10 to 15, we have S3 = 1, either S2 = 1 or S1 = 1, or both.
The logic expression for the output carry, Cn+1
0
, which permits the detection of
sums greater than 9, is thus given by:
Cn+1
0
= C4 + S3 ¬∑ (S2 + S1)

166
Digital Electronics 2
For a given sum S3S2S1S0, we have:
Œ£3Œ£2Œ£1Œ£0 =

S3S2S1S0 + 0000
if
Cn+1
0
= 0
S3S2S1S0 + 0110
if
Cn+1
0
= 1
Decimal
Binary
BCD
C4S3S2S1S0
C0 + Œ£3Œ£2Œ£1Œ£0
0
00000
0 + 0000
1
00001
0 + 0001
2
00010
0 + 0010
3
00011
0 + 0011
4
00100
0 + 0100
5
00101
0 + 0101
6
00110
0 + 0110
7
00111
0 + 0111
8
01000
0 + 1000
9
01001
0 + 1001
10
01010
1 + 0000
11
01011
1 + 0001
12
01100
1 + 0010
13
01101
1 + 0011
14
01110
1 + 0100
15
01111
1 + 0101
16
10000
1 + 0110
17
10001
1 + 0111
18
10010
1 + 1000
19
10011
1 + 1001
Table 4.20. Function table of the BCD adder
The correction circuit is represented in Figure 4.55.
n+
S1
S2
3
S
C4
1
C0
Figure 4.55. Correction circuit

Arithmetic and Logic Circuits
167
SOLUTION 4.10.‚Äì Analysis of a logic circuit.
The analysis of the logic circuit (see Figure 4.56) can yield the following logic
equations:
A = (X0 ‚äïY0) + (X1 ‚äïY1)
[4.69]
B = X0 ¬∑ Y0(X1 ‚äïY1) + X1(X1 ‚äïY1)
[4.70]
C = X0 ¬∑ Y0(X1 ‚äïY1) + X1(X1 ‚äïY1)
[4.71]
0
0
1
0
1
A (X=Y)
B (X<Y)
C (X>Y)
Y1
Y0
X1
X
Figure 4.56. Two-bit comparator
This is a two-bit comparator. We can verify that C = A + B (or that two of the
outputs are always the logic complement of the other output).
SOLUTION 4.11.‚Äì Cascadable comparator cell.
The outputs of the comparator are deÔ¨Åned in the following manner:
OA>B = 1 if A > B or (A = B and IA>B = 1)
OA=B = 1 if A = B and IA=B = 1
OA<B = 1 if A < B or (A = B and IA<B = 1)
Table 4.21 gives the truth table of a 1-bit cascadable comparator.

168
Digital Electronics 2
A
B
OA>B
OA=B
OA<B
0
0
IA>B
IA=B
IA<B
0
1
0
0
1
1
0
1
0
0
1
1
IA>B
IA=B
IA<B
Table 4.21. Truth table of a 1-bit cascadable comparator
The logic expressions of the outputs obtained from the Karnaugh maps of
Figure 4.57 can be written as follows:
OA>B = A ¬∑ IA>B + B ¬∑ IA>B + A ¬∑ B
= (A + B) ¬∑ IA>B + A ¬∑ B
OA=B = (A ¬∑ B + A ¬∑ B) ¬∑ IA=B
= (A + B) ¬∑ (A + B) ¬∑ IA=B
OA<B = A ¬∑ IA<B + B ¬∑ IA<B + A ¬∑ B
= (A + B) ¬∑ IA<B + A ¬∑ B
(c)
A=B
I A=B
A>B
I
A>B
I
I A<B
I A<B
AB
00
01
11
10
A
0
B
1
AB
00
01
11
10
A
0
B
1
AB
00
01
11
10
A
0
B
1
0
0
1
0
1
0
1
1
0
0
0
0
1
0
1
0
1
0
0
0
1
1
1
0
(a)
(b)
I
Figure 4.57. Karnaugh map: a) OA>B; b) OA=B; c) OA<B. For a color
version of the Ô¨Ågure, see www.iste.co.uk/ndjountche/electronics2.zip
The different logic circuits of the cascadable comparator are shown in Figure 4.58.
SOLUTION 4.12.‚Äì Cascadable comparator.
An n-bit comparator is implemented by connecting 1-bit comparator cells and an
output network in series.
When the bits are equal to the left of the cell i, xiyi = 00, and if A is equal to
B, we then have xi+1yi+1 = 00. However, when xiyi = 00, if AB = 10, it follows
that xi+1yi+1 = 01 and A > B, and if, on the other hand, AB = 01, we then have
xi+1yi+1 = 10 and A < B.

Arithmetic and Logic Circuits
169
B
A=B
OA<B
OA>B
A>B
I
I A<B
I A=B
OA=B
OA>B
OA<B
I A=B
I A<B
A>B
I
(b)
A B
(a)
A
O
Figure 4.58. Cascadable comparator
When the superiority relationship, xiyi = 01, is established at the left of the cell
i, for any value of A and B, we have xi+1yi+1 = 01 and A > B.
Similarly, when the inferiority relationship xiyi = 10, is established at the left of
the cell i, whatever be the values of A and B, we have xi+1yi+1 = 10 and A < B.
Table 4.22 gives the truth table of the comparator. The logic equations for the
signals xi+1 and yi+1 obtained from the Karnaugh maps of Figure 4.59 are given by:
xi+1 = xi + A ¬∑ B ¬∑ yi
[4.72]
yi+1 = yi + A ¬∑ B ¬∑ xi
[4.73]
For the comparator outputs, the following logic equations can be derived from the
Karnaugh maps shown in Figure 4.60:
OA>B = xi+1 ¬∑ yi+1
[4.74]
OA=B = xi+1 ¬∑ yi+1
[4.75]
OA<B = xi+1 ¬∑ yi+1
[4.76]
Figure 4.61 depicts the logic circuit obtained from the logic equations of the
comparator cell and output section.
When both numbers A and B are coded with n bits, a comparison operation begins
with the most signiÔ¨Åcation bits: An‚àí1 and Bn‚àí1.

170
Digital Electronics 2
xi
yi
A
B
xi+1
yi+1
OA>B
OA=B
OA<B
0
0
0
0
0
0
0
1
0
0
0
0
1
1
0
0
1
0
0
0
1
0
0
1
0
1
0
0
0
1
1
0
0
0
1
0
0
1
0
0
0
1
1
0
0
0
1
0
1
0
1
1
0
0
0
1
1
0
0
1
1
0
0
0
1
1
1
0
1
1
0
0
1
0
0
0
1
0
0
0
1
1
0
0
1
1
0
0
0
1
1
0
1
0
1
0
0
0
1
1
0
1
1
1
0
0
0
1
1
1
0
0
x
x
0
0
0
1
1
0
1
x
x
0
0
0
1
1
1
0
x
x
0
0
0
1
1
1
1
x
x
0
0
0
Table 4.22. Truth table for the comparator
AB
i
yi
1
0
0
0
x
x
x
x
1
1
1
1
0
0
0
0
00
01
11
10
00
01
11
10
yi
xi
xi
(a)
0
0
0
x
x
x
x
0
0
0
0
1
1
1
00
01
11
10
00
01
11
10
(b)
1
1
yi
xi
xi
A
AB
B
B
A
y
Figure 4.59. Karnaugh maps: a) xi+1 = xi + A ¬∑ B ¬∑ yi;
b) yi+1 = yi + A ¬∑ B ¬∑ xi. For a color version of the Ô¨Ågure, see
www.iste.co.uk/ndjountche/electronics2.zip
SOLUTION 4.13.‚Äì Analysis of a logic circuit.
By analyzing the proposed logic circuit, we can obtain the following logic
equations:
G = N ¬∑ V + N ¬∑ V ¬∑ Z
[4.77]
E = Z
[4.78]

Arithmetic and Logic Circuits
171
and:
L = N ‚äïV
[4.79]
Table 4.23 represents the truth table of this circuit, where A = A1A0 and B =
B1B0.
i+1
i+1
yi+1
yi+1
yi+1
yi+1
yi+1
1
0
0
1
0
1
(a)
0
0
0
0
0
1
0
1
(b)
1
0
0
0
0
1
0
1
(c)
0
1
xi+1
xi+1
xi+1
xi+1
xi+1
x
y
Figure 4.60. Karnaugh maps: a) OA>B = xi+1 ¬∑ yi+1;
b) OA=B = xi+1 ¬∑ yi+1, (c) OA<B = xi+1 ¬∑ yi+1. For a color version
of the Ô¨Ågure, see www.iste.co.uk/ndjountche/electronics2.zip
B
x i+1
y i+1
A<B
O
x i+1
yi+1
A>B
O
OA=B
yi
(a)
x i
(b)
A
Figure 4.61. Logic circuits: a) comparator cell; b) output section
Noting that G = OA>B, E = OA=B and L = OA<B, we have:
G = E + L
[4.80]
Figure 4.62 shows the logic circuit of a comparator for 4-bit signed numbers.
SOLUTION 4.14.‚Äì Arithmetic and logic unit.
The analysis of a stage in the ALU yields the following logic equations:
F = (S2 ¬∑ Ci) ‚äï(A ‚äïS0) ‚äï(S1 ¬∑ B) + S2 ¬∑ S1 ¬∑ B
[4.81]
and:
Ci+1 = (S2 ¬∑ Ci) ¬∑ [(A ‚äïS0) ‚äï(S1 ¬∑ B)] + S2 ¬∑ (S1 ¬∑ B) ¬∑ (A ‚äïS0)
[4.82]

172
Digital Electronics 2
A1
A0
B1
B0
C2S1S0
Z
N
V
G
E
L
0
0
0
0
1 0 0
1
0
0
0
1
0
A = B
0
0
0
1
0 1 1
0
1
0
0
0
1
A < B
0
0
1
0
0 1 0
0
1
1
1
0
0
A > B
0
0
1
1
0 0 1
0
0
0
1
0
0
A > B
0
1
0
0
1 0 1
0
0
0
1
0
0
A > B
0
1
0
1
1 0 0
1
0
0
0
1
0
A = B
0
1
1
0
0 1 1
0
1
1
1
0
0
A > B
0
1
1
1
0 1 0
0
1
1
1
0
0
A > B
1
0
0
0
1 1 0
0
1
0
0
0
1
A < B
1
0
0
1
1 0 1
0
0
1
0
0
1
A < B
1
0
1
0
1 0 0
1
0
0
0
1
0
A = B
1
0
1
1
0 1 1
0
1
0
0
0
1
A < B
1
1
0
0
1 1 1
0
1
0
0
0
1
A < B
1
1
0
1
1 1 0
0
1
0
0
0
1
A < B
1
1
1
0
1 0 1
0
0
0
1
0
0
A > B
1
1
1
1
1 0 0
1
0
0
0
1
0
A = B
Table 4.23. Truth table of the comparator
L
B
S0
S1
S2
V
N
Z
E
G
C4
S3
3
A
FA
S
Ci+1
Ci
A
B
3
B
0
A
1
1
A
2
A
FA
S
Ci+1
Ci
FA
S
Ci+1
Ci
FA
S
Ci+1
Ci
A
B
A
B
A
B
2
B
1
B
0
Figure 4.62. Logic circuit of the 4-bit comparator
The expressions for F and Ci+1 have common terms. This helps reduce the
number of logic gates in the resulting implementation.
Table 4.24 gives the function table of the ALU.

Arithmetic and Logic Circuits
173
S2S1S0
F
Ci+1
Operation
Transfer (Ci = 0) or
0 0 0
A ‚äïCi
A ¬∑ Ci
Incrementing (Ci = 1) of A
1‚Äôs complement (Ci = 0) or
0 0 1
A ‚äïCi
A ¬∑ Ci
2‚Äôs complement (Ci = 1) of A
A plus B if Ci = 0 or
0 1 0
A ‚äïB ‚äïCi
Ci ¬∑ (A ‚äïB) + A ¬∑ B
A plus B plus 1 if Ci = 1
A plus B if Ci = 0 or
0 1 1
A ‚äïB ‚äïCi
Ci ¬∑ (A ‚äïB) + A ¬∑ B
B minus A if Ci = 1
1 0 0
A
0
Transfer of A
1 0 1
A
0
Complement of A
1 1 0
A + B
0
A OR B
1 1 1
A + B
0
Complement of A OR B
Table 4.24. Function table of the arithmetic and logic unit
SOLUTION 4.15.‚Äì Programmable logic circuit.
The analysis of the programmable logic circuit can help to extract the different
equivalent circuits for carrying out arithmetic functions (addition/subtraction, absolute
value, minimum and maximum) as shown in Figure 4.63.
The function table of this logic circuit is given in Table 4.25.
S2
S1
S0
Operation
F(A, B)
0
0
1
Addition
A + B
1
0
0
Absolute value
|B|
1
0
1
Subtraction
A ‚àíB
1
1
0
Minimum
min(A, B)
1
1
1
Maximum
max(A, B)
Table 4.25. Function table

174
Digital Electronics 2
B
0
Ci
S2
C0
Ci
C0
Ci
C0
Ci
A + B
S
X
Y
AC
S
X
Y
AC
0
1
S
X
Y
AC
0
1
(d)
min(A,B)
max(A,B)
S
X
Y
AC
0
1
A
B
(b)
|B|
A ‚àí B if S2 = 1
if S2 = 0
(a)
(c)
0
B
1
A
B
A
C
1
Figure 4.63. Programmable logic circuit: a) adder/subtractor;
b) absolute value; c) minimum; d) maximum
SOLUTION 4.16.‚Äì Bidirectional counter.
The analysis of the counter can yield the following logic equations:
Q+
0 = (Q0 ‚äïDir) ¬∑ Load + P0 ¬∑ Load
[4.83]
Q+
1 = (Q1 ‚äïC0) ¬∑ Load + P1 ¬∑ Load
[4.84]
Q+
2 = (Q2 ‚äïC1) ¬∑ Load + P2 ¬∑ Load
[4.85]
Q+
3 = (Q3 ‚äïC2) ¬∑ Load + P3 ¬∑ Load
[4.86]
RCO = Dir ¬∑ Q3 ¬∑ C2 + Dir ¬∑ Q1 ¬∑ C2
[4.87]
where:
C0 = Dir ¬∑ Q0 ¬∑ Cnt + Dir ¬∑ Q0 ¬∑ Cnt
[4.88]
C1 = Dir ¬∑ Q1 ¬∑ C0 + Dir ¬∑ Q1 ¬∑ C0
[4.89]
C2 = Dir ¬∑ Q2 ¬∑ C1 + Dir ¬∑ Q2 ¬∑ C1
[4.90]

Arithmetic and Logic Circuits
175
Table 4.26 presents the function table of the counter. Counting is enabled by the
Cnt signal depending on the direction speciÔ¨Åed by the Dir signal. Setting the Load
signal to 1 ensures the loading of data and the deactivation of counting, while resetting
the Load signal to 0 enables the counter to operate normally.
It is a modulo 10 up counter.
Count down
CK
Reset
1
1
1
0
x
x
1
Load
Cnt
Dir
x
1
x
0
1
x
0
1
0
0
x
1
x
x
0
Load
Count up
Inputs
Operations
Hold
Reset
Table 4.26. Function table


5
Digital Integrated Circuit Technology
5.1. Introduction
Several families of technology have been developed for manufacturing integrated
circuits, the most popular being transistor‚Äìtransistor logic (TTL) and complementary
metal oxide semiconductor (CMOS). TTL technology uses bipolar transistors,
whereas CMOS technology is based on MOS Ô¨Åeld-effect transistors.
The technology chosen has an impact on the physical and electrical characteristics
of the circuit (speed, integration density, power consumption, fan-in, fan-out, etc.).
Logic gates, therefore, are not ideal components. In practice, their characteristics limit
their performance.
5.2. Characteristics of the technologies
With
the
widespread
diffusion
of
small-scale
integration,
medium-scale
integration and large-scale integration chips, it is essential to understand the electric
characteristics of most of the major families (TTL and CMOS) of integrated circuits.
5.2.1. Supply voltage
The nominal value of the supply voltage for TTL components is 5 V, and for
CMOS components it is presently 3.3 V and continuing to decrease with the
diminishing size of the transistor.
Digital Electronics 2: Sequential and Arithmetic Logic Circuits, First Edition. Tertulien Ndjountche. 
¬© ISTE Ltd 2016. Published by ISTE Ltd and John Wiley & Sons, Inc. 

178
Digital Electronics 2
5.2.2. Logic levels
The voltage levels associated with each logic state vary depending on the
technology. Figure 5.1 gives a representation of the logic levels of the TTL and
CMOS components.
Input
2
0.8
Logic 0
0
2.4
Logic 0
0.4
5
Output
5
Logic 1
2
0.8
Logic 0
0
3.3
Output
2.4
Logic 1
Logic 0
0.4
Logic 1
Input
TTL
CMOS
0
0
3.3
Undefined
Logic 1
Figure 5.1. Logic levels of TTL and CMOS components
5.2.3. Immunity to noise
Undesirable signals (electromagnetic disturbances, supply voltage Ô¨Çuctuations,
variations due to parasitic coupling or caused by the thermal agitation of charge
carriers) arising in electric circuits are called ‚Äúnoise‚Äù and by modifying the
propagation delay or the signal logic level, these may be an impediment to the proper
operation of a logic circuit.
In order for its performance to remain unaffected by noise, a logic circuit must
manifest a certain immunity to noise. Two values are used to indicate the noise margin
in a logic circuit: high-level noise margin and low-level noise margin.
Based on input and output logic levels represented in Figure 5.2, the different noise
margins can be deÔ¨Åned as follows:
‚Äì high-level noise margin:
VNH = VOH ‚àíVIH
[5.1]
where the minimum voltage required for a high level at the input and output are
designated by VIH and VOH, respectively;
‚Äì low-level noise margin:
VNL = VIL ‚àíVOL
[5.2]

Digital Integrated Circuit Technology
179
where VIL and VOL designate, respectively, the maximum voltage for the input and
the output.
OL
Undefined
Logic 0
Logic 1
VIL
VIH
Input
Logic 0
Output
Logic 1
VOH
V
Figure 5.2. Input and output logic levels
5.2.4. Propagation delay
A logic signal that passes through a logic circuit is subject to a propagation delay.
Hence, there is a difference between the instant the input changes state and the
instant the output changes state. Depending on the edge of the signal, two types of
propagation delays can be deÔ¨Åned:
‚Äì tP LH: propagation delay corresponding to the transition from low to high;
‚Äì tP HL: propagation delay corresponding to the transition from high to low.
5.2.5. Electric power consumption
Electric power is deÔ¨Åned as the product of voltage and electric current. It is
constant across the range of operational frequencies for TTL technology and varies
with frequency for CMOS technology, as shown in Figure 5.3.
5.2.6. Fan-out or load factor
When the output signal of a logic gate is connected to the inputs of other gates,
a load develops on the driving gate. There is a limit to the number of inputs that an
output can safely drive. This limit is called the fan-out of the gate.
In TTL technology, the increase in the output load can lead to an increase in the
power consumption and a reduction in the low-level noise margin.

180
Digital Electronics 2
Power
CMOS
TTL
Frequency
00
Figure 5.3. Electric power consumption of TTL and CMOS components
In CMOS technology, the load factor depends on the maximum operation
frequency. The fewer logic gates connected to the output, the higher its maximum
frequency.
5.3. TTL logic family
5.3.1. Bipolar junction transistor
The bipolar junction transistor (BJT) is the active component present in all TTL
circuits. Figure 5.4 depicts a BJT. A bipolar transistor has three terminals: base,
emitter and collector. It consists of two junctions: the base‚Äìemitter junction and the
base‚Äìcollector junction.
(a)
Collector (C)
Base (B)
Emitter (E)
Collector (C)
Base (B)
Emitter (E)
(b)
Figure 5.4. a) npn and b) pnp bipolar junction transistors
In general, the transistors used in logic circuits operate in commutation mode, as
shown in Figure 5.5.
When the voltage applied at the base is higher than the base‚Äìemitter voltage, which
is of the order of 0.7 V, and when the current intensity at the base is sufÔ¨Åcient, the

Digital Integrated Circuit Technology
181
transistor begins to conduct current and then reaches saturation state. In this state, the
transistor acts as closed switch between the collector and the emitter.
When the input voltage at the base is lower than 0.7 V, the transistor is in the
cut-off region and then acts as an open switch between the collector and emitter.
The BJT transistor can also operate as an ampliÔ¨Åer. In this case, it is equivalent to
a non-ideal current source controlled by a current.
It must be noted that the pnp transistor operates with the polarization voltages
inverted with respect to an npn transistor.
+V
I
On
VCC
VCC
(b)
0
Off
R
R
(a)
VCC
R
VCC
R
Figure 5.5. Operation of a bipolar transistor
5.3.2. TTL NAND gate
A NAND gate in the TTL logic family is represented in Figure 5.6. The transistor,
Q1, has two emitters; as a result, there are two emitter‚Äìbase junctions that can set Q1
to the conduction state. Transistor Q2 plays the role of a phase splitter and the section,
Q3 ‚àíD1 ‚àíQ4, that constitutes the output stage is called the totem-pole stage.
4.0 k
1.0 k
1.6 k
DP1
DP2
R3
130 
VCC
Q1
R
R2
Q3
D1
Q4
R4
Q2
1
Input B
Input A
Output
Figure 5.6. TTL NAND gate (DP1 and DP2 are protection diodes)

182
Digital Electronics 2
The equivalent circuits shown in Figure 5.7 are obtained by replacing the transistor
Q1 with its equivalent diode circuit. Diodes D2 and D3 correspond to the base‚Äìemitter
junctions and D4 corresponds to the base‚Äìcollector junction.
4.0 k
1.0 k
4.0 k
1.0 k
1.6 k
1.6 k
R3
130 
V
B = 0 V
A = 5 V
R3
130 
VCC
Output (Low)
B = 5 V
A = 5 V
On
On
On
Off
Off
Off
On
Off
(a)
(b)
D2
D3
D4
R1
R2
Q3
D1
Q4
R4
Q2
D3
D2
D4
R1
R2
Q3
D1
Q4
R4
Q2
CC
Off
Off
Off
On
Output (High)
Figure 5.7. Equivalent circuits of a TTL NAND gate. For a color version
of this Ô¨Ågure, see www.iste.co.uk/ndjountche/electronics2.zip
For Figure 5.7(a), both inputs are at the high level. The input currents are very
weak. Transistor Q3 is turned-off and Q4 conducts so that the output voltage is lower
than 0.4 V.
The output signal provided by the equivalent circuit of Figure 5.7(b) is at the high
level. In this case, the input A or B can be set to low level, or both inputs (A and B)
can also be set to low level at the same time. The transistor, Q3, conducts while Q4 is
turned-off. The output voltage is, thus, greater than 2.4 V.
NOTE 5.1.‚Äì There is another type of output in TTL integrated circuits: the open
collector output. In this case, an external polarization linked to the supply voltage
source, VCC, must be connected to the collector of the output transistor to obtain the
correct low and high logic levels.
NOTE 5.2.‚Äì In TTL technology, an unused or Ô¨Çoating input acts as a high logic level
because it corresponds to an inversely polarized base‚Äìemitter junction.
5.3.3. Integrated TTL circuit
Different versions of TTL circuits have been developed to meet the requirements
of increasingly diversiÔ¨Åed applications:
‚Äì 74-Standard TTL;
‚Äì 74S-Schottky TTL;

Digital Integrated Circuit Technology
183
‚Äì 74F-Fast TTL.
5.4. CMOS logic family
5.4.1. MOSFET transistor
Metal-oxide semiconductor Ô¨Åeld-effect transistors (MOSFET) can play the role of
active switches in CMOS digital circuits.
The symbols for the n-channel and p-channel MOSFET transistors are given in
Figure 5.8. A MOSFET transistor has the following terminals: gate, drain, source and
substrate (or body). In general, the body is connected to the source.
Gate (G)
Source (S)
Drain (D)
(a)
Source (S)
Drain (D)
(b)
Substrate
Substrate
Gate (G)
Figure 5.8. n-channel a) and p-channel b) MOSFET transistor
When the gate voltage of an n-channel MOSFET transistor is higher than a certain
threshold voltage, the transistor conducts and ideally acts as a closed switch between
the drain and source. When the gate voltage becomes equal to zero, the transistor is
turned-off and acts as an open switch. In this case, the channel resistance is of the
order of 1010 Œ©. This operation is illustrated in Figure 5.9.
DD
On
VDD
S
D
(a)
3.3 V G
VDD
VDD
Off
D
S
(b)
0 V G
V
Figure 5.9. Operation of an n-channel MOSFET transistor
In dynamic operation, a MOSFET transistor is equivalent to a current source
controlled by voltage and whose operation is perticularly affected by parasitic
capacitances.
The p-channel MOSFET transistor operates with voltage polarities that are
opposite to those of the n-channel MOSFET transistor, as illustrated in Figure 5.10.

184
Digital Electronics 2
DD
On
VDD
D
S
0 V
G
(a)
VDD
Off
S
D
3.3 V
G
(b)
VDD
V
Figure 5.10. Working of a p-channel MOSFET transistor
5.4.2. CMOS logic gates
CMOS technology is characterized by high integration density and low-power
consumption.
An inverter can be implemented as shown in Figure 5.11(a). It consists of two
complementary (n-channel and p-channel) transistors. When the input signal assumes
the high level, the transistor M1 conducts while M2 is turned off, and the output takes
the low level. When the logic level of the input signal is low, the transistor M1 is
turned off while M2 conducts, and the output assumes the high level. The truth table
of the inverter is illustrated in Table 5.1.
A
Y
B
A
Y
B
A
Y
Y
Y
A
Y
B
A
A
B
(a)
(b)
(c)
DD
M2
M2
M3
VDD
M4
M2
M1
M3
M4
VDD
V
M1
M1
Figure 5.11. CMOS logic gates: a) inverter; b) NAND gate;
c) NOR gate
A NAND gate can be implemented as shown in Figure 5.11(b). It consists of four
transistors: the two n-channel transistors are connected in series while the two
p-channel transistors are connected in parallel. The truth table given in Table 5.2
summarizes the operation of the NAND gate.

Digital Integrated Circuit Technology
185
A
M1
M2
Y
Low
Off
On
High
High
On
Off
Low
Table 5.1. Truth table of the inverter
A
B
M1
M2
M3
M4
Y
Low
Low
Off
Off
On
On
High
Low
High
On
Off
On
Off
High
High
Low
Off
On
Off
On
High
High
High
On
On
Off
Off
Low
Table 5.2. Truth table of the NAND gate
The circuit that can used to implement a NOR gate is represented in Figure 5.11(c).
It is composed of four transistors: the two n-channel transistors are connected in
parallel, while the two p-channel transistors are connected in series. It is, therefore,
the dual circuit of the NAND gate circuit. Table 5.3 describes the operation of the
NOR gate.
A
B
M1
M2
M3
M4
Y
Low
Low
Off
Off
On
On
High
Low
High
On
Off
Off
On
Low
High
Low
Off
On
On
Off
Low
High
High
On
On
Off
Off
Low
Table 5.3. Truth table of the NOR gate
NOTE 5.3.‚Äì The CMOS components may be damaged by electrostatic discharge. It is,
therefore, essential to take precautions when handling them (conductive foam, special
bracelet connected to a high-value series resistance).
5.5. Open drain logic gates
In microprocessor systems, it is common to connect the outputs of several different
logic gates to a single interconnection wire. As the use of a conventional logic gate
is not possible in this case, one possible solution consists of using open drain logic
gates. The expression open drain signiÔ¨Åes that the output transistor drain is Ô¨Çoating
and must be connected through an external resistor to the supply voltage.

186
Digital Electronics 2
In CMOS technology, a NAND gate is composed of two n-channel transistors
forming a network that is loaded by two p-channel transistors. The open drain NAND
gate is implemented, as shown in Figure 5.12(a), by suppressing the load (p-channel
transistors) to leave the output transistor drain Ô¨Çoating. In practice, to implement the
NAND logic function, a pull-up resistor is often connected to the output, as illustrated
in Figure 5.12(b).
(b)
B
A
Y
A
B
Y
(a)
R
B
A
Y
1
VDD
M
M2
Figure 5.12. a) Circuit and symbol of an open drain NAND gate;
b) implementation of a NAND gate
The truth table of the open drain NAND gate is given in Table 5.4, while Table 5.5
shows the truth table of the corresponding NAND gate.
A
B
M1
M2
Y
Low
Low
Off
Off
Open
Low
High
On
Off
Open
High
Low
Off
On
Open
High
High
On
On
High
Table 5.4. Truth table of the open drain NAND gate
A
B
M1
M2
Y
Low
Low
Off
Off
High
Low
High
On
Off
High
High
Low
Off
On
High
High
High
On
On
Low
Table 5.5. Truth table of the NAND gate

Digital Integrated Circuit Technology
187
Several open drain gates can be connected to a pull-up resistor, as shown in
Figure 5.13(a). A wired AND connection is thus established, characterized by one of
the following logic equations:
Y = A ¬∑ B ¬∑ C ¬∑ D ¬∑ E ¬∑ F
[5.3]
= A ¬∑ B + C ¬∑ D + E ¬∑ F
[5.4]
L 2
L 3
RD
RD
RD
R
L 1
(a)
B
A
Y
D
C
F
E
EN
(b)
V
VDD
DD
Figure 5.13. Applications: a) wired AND connection; b) LED driver
The open drain gate can also be used to implement a light-emitting diode (LED)
driver. In the case shown in Figure 5.13(b), the enable signal is represented by EN,
and each LED is switched on depending on the logic level of the corresponding signal
Lk (k = 1, 2, 3).
In general, the use of open drain gates offers more Ô¨Çexibility by allowing for the
adjustment of each output signal and the advantage of reducing the number of
components. However, the sizing of the pull-up resistor may affect the circuit‚Äôs
precision.
NOTE 5.4.‚Äì In the case of technology based on bipolar transistors, we talk about open
collectors.
5.5.1. Three-state buffer
In general, a three-state buffer circuit is used to connect different components to a
bus. In addition to the logic levels 0 and 1, it can take the high impedance state, z, that
is used to disconnect a component.
Figure 5.14 shows the symbol and logic circuit, respectively, of a three-state buffer.
When the enable signal E assumes the high state, one of the transistors, Mp or Mn,

188
Digital Electronics 2
conducts while the other is turned off, and the output signal takes the same logic state
as the input signal. When the logic level of the enable signal is low, the two transistors
are turned off, thus enabling the output to take the high impedance state. The truth
table shown in Table 5.6 gives a summary of the operation of the three-state buffer.
g
E
X
g
E
X
h
(b)
(a)
Y
h
X
Y
E
Y
S n
S p
DD
M
DD
n
p
V
M
V
Figure 5.14. Three-state buffer: a) symbol; b) logic circuit
E
X
g
h
Sp
Sn
Y
Low
Low
High
Low
Open
Open
z
Low
High
High
Low
Open
Open
z
High
Low
High
High
Open
Closed
Low
High
High
Low
Low
Closed
Open
High
Table 5.6. Truth table of the three-state buffer
A bidirectional input/output (I/O) pin can be implemented as shown in Figure 5.15.
It consists of two three-state buffers and logic gates. When the enable signal, EN, is
set to 0, the data can be transmitted from pin X to pin Y , and vice versa, depending
on the logic state of the signal DIR.
5.5.2. CMOS integrated circuit
Several versions of CMOS circuits are available:
‚Äì the 74HC-CMOS fast series (74HCT-CMOS compatible with the TTL family);
‚Äì the advanced 74AC-CMOS series (74ACT-CMOS compatible with the TTL
family);
‚Äì the low-voltage 74LV-CMOS series.

Digital Integrated Circuit Technology
189
DIR
X
EN
Y
Figure 5.15. Bidirectional input/output pin
Among CMOS circuits offered by manufacturers, some are compatible with TTL
circuits while others are not.
5.6. Other logic families
To satisfy other constraints,
such as speed or reprogrammability,
other
technologies have been developed in addition to TTL and CMOS technologies.
‚Äì The emitter-coupled logic (ECL) family: The coupled logic family is a bipolar
family just like the TTL family. ECL logic circuits use an input stage with differential
ampliÔ¨Åer, a polarization circuit, and an output stage with emitter-follower. The ECL
family is much faster than the TTL family because the transistors do not operate in the
saturation region.
‚Äì The electrically erasable CMOS (EECMOS) logic family: EECMOS logic is
based on a combination of CMOS and NMOS technology. It is mainly used in
reprogrammable modules, which are built around a Ô¨Çoating gate MOS transistor that
is loaded or unloaded by an external current.
5.7. Interfacing circuits of different technologies
The input and output levels of a logic circuit can vary depending on the component
technology and the supply voltage used. The interfacing of logic gates may be further
divided into two categories: interfacing circuits that can operate at the same voltage
levels and interfacing of circuits that operate at different voltage levels. In the Ô¨Årst
case, the circuits are compatible and may be directly connected, while in the second
case, it is necessary to convert the voltage level.
In order to interface two logic circuits, some conditions must be met:
1) the VOH voltage of the driving circuit must be higher than the VIH voltage of
the loading circuit;

190
Digital Electronics 2
2) the VOL voltage of the driving circuit must be lower than the VIL voltage of the
loading circuit;
3) the output voltage of the driving circuit must not exceed the input/output voltage
tolerances of the loading circuit.
The interfacing of a TTL circuit to a CMOS circuit using a resistor is illustrated, as
an example, in Figure 5.16(a), while Figure 5.16(b) shows a CMOS circuit connected
to a TTL circuit through a three-state buffer that can shift the logic level.
DD
TTL
Circuit 
R
VCC
V
VCC
VDD
Circuit 
Circuit 
CMOS
TTL
(a)
(b)
Circuit 
CMOS
Figure 5.16. Examples of interfacing: a) TTL-CMOS; b) CMOS-TTL
5.8. Exercises
EXERCISE 5.1.‚Äì Answer the following questions:
a) There are four different voltage thresholds for the TTL logic family and CMOS
logic family:
Œ±‚àítrue
Œ≤‚àífalse
b) The input signal frequency of a component whose critical path introduces a
propagation delay, tp, must be lower than 1/tp:
Œ±‚àítrue
Œ≤‚àífalse
c) For applications where a higher switching speed is required and a relatively high
current is required for the output load, CMOS logic gates are preferred over TTL logic
gates:
Œ±‚àítrue
Œ≤‚àífalse
d) The ECL logic family is faster than the TTL family but consumes more energy:
Œ±‚àítrue
Œ≤‚àífalse
e) Unused inputs for a logic circuit must be connected either to the supply voltage,
or to the ground, or to an used input:
Œ±‚àítrue
Œ≤‚àífalse
f) In general, the Ô¨Åeld-effect transistor is faster than a bipolar transistor:
Œ±‚àítrue
Œ≤‚àífalse

Digital Integrated Circuit Technology
191
g) Careful handing of a CMOS gate is required because of:
Œ±‚àíits fragile construction
Œ≤‚àíits immunity to high-level noise
Œ≥‚àíits sensitivity to electrostatic charge
Œ¥‚àíits low energy consumption.
h) When the frequency of an input signal for a CMOS gate increases, the average
energy consumption:
Œ±‚àídiminishes
Œ≤‚àíincreases
Œ≥‚àídoes not change.
i) The operation of a CMOS gate is more reliable than a TTL gate in a noisy
environment due to:
Œ±‚àíthe narrower noise margin
Œ≤‚àíthe input capacitance
Œ≥‚àíthe larger noise margin
Œ¥‚àílow energy consumption.
j) The highest currents associated with high and low input level being IIH and
IIL, and high and low output levels being IOH and IOL, respectively; and with ‚åäx‚åã
denoting the greatest integer that is less than or equal to x, the maximum number of
loading gates that the output of a logic gate can drive, as given by the formula:
min(‚åäIOH/IIH‚åã, ‚åäIOL/IIL‚åã)
is not applicable, in practice, to the CMOS family, which are only affected by
increased propagation delays caused by an increase in the load capacitance:
Œ±‚àítrue
Œ≤‚àífalse
EXERCISE 5.2.‚Äì Which logic gate is implemented by each circuit shown in
Figure 5.17.
(a)
A
B
(b)
Y
B
A
Y
3
M3
M5
M2
M6
VDD
M4
M
VDD
5
M6
M2
M1
M4
M1
M
Figure 5.17. CMOS logic gate: a) AND gate; b) OR gate
EXERCISE 5.3.‚Äì Show that the logic circuits shown in Figures 5.18(a) and 5.18(b)
implement the function of AND and OR gates, respectively.
EXERCISE 5.4.‚Äì Power dissipation.

192
Digital Electronics 2
R
A
C
A
B
E
(a)
(c)
R
G
C
B
R
C
D
A
B
F
(b)
V
V
DD
DD
DD
V
Figure 5.18. CMOS logic circuits: a) AND gate, b) OR gate
The electric power dissipated by a TTL component is given by:
PD = VCCICC
[5.5]
where VCC is the supply voltage and ICC is the current Ô¨Çowing through the circuit.
For a CMOS component, the electric power dissipated is the sum of dynamic and
static contributions and can be written as follows:
PD = Pdynamique + Pstatique
[5.6]
= (CL + CP D)V 2
DDf + VDDIDD
[5.7]
where CL is the output load capacitance, CP D is the equivalent capacitance for the
gate, f is the output signal frequency, VDD is the supply voltage and IDD is the
leakage current.
Determine the power, PD, of this circuit, assuming that the outputs of the circuit
commutate with a cyclic relationship, Œ∑, of 50%, the current, ICC is of the form:
ICC = Œ∑ICCH + (1 ‚àíŒ∑)ICCL = (ICCH + ICCL)/2
where ICCH and ICCL represent the current when all the outputs are at the high and
low logic levels, respectively.
What is the highest possible frequency (f) if the maximum value of the power,
PD, of the CMOS circuit is 15 mW and the output load capacitance, CL, is 10 pF?
From the datasheet, we have:
‚Äì TTL circuit: VCC = 5 V, ICCH = 1.5 mA, and ICCL = 4.5 mA;
‚Äì CMOS circuit: CP D = 22 pF, VDD = 3 V, and IDD = 20 ŒºA.

Digital Integrated Circuit Technology
193
5.9. Solutions
SOLUTION 5.1.‚Äì Answers to the questions
a) Œ±
b) Œ±
c) Œ≤
d) Œ±
e) Œ±
f) Œ≤
g) Œ≥
h) Œ≤
i) Œ≥
j) Œ±
SOLUTION 5.2.‚Äì The logic gate shown in Figure 5.17(a) is implemented by
connecting a NAND gate and an inverter in series. The truth table of this gate is given
in Table 5.7. It is an AND logic function.
A
B
M1
M2
M3
M4
M5
M6
Y
Low
Low
Off
Off
On
On
On
Off
Low
Low
High
On
Off
On
Off
On
Off
Low
High
Low
Off
On
Off
On
On
Off
Low
High
High
On
On
Off
Off
Off
On
High
Table 5.7. Truth table of the AND gate
The logic gate shown in Figure 5.17(b) is composed of a NOR gate and an inverter.
It can be characterized by the truth table shown in Table 5.8 and, thus, implements the
OR logic function.
A
B
M1
M2
M3
M4
M5
M6
Y
Low
Low
Off
Off
On
On
On
Off
Low
Low
High
On
Off
Off
On
Off
On
High
High
Low
Off
On
On
Off
Off
On
High
High
High
On
On
Off
Off
Off
On
High
Table 5.8. Truth table of the OR gate
SOLUTION 5.3.‚Äì For each circuit, the logic equations obtained can be written as
follows:
‚Äì circuit as shown in Figure 5.18(a):
E = A ¬∑ B ¬∑ C
[5.8]
‚Äì circuit as shown in Figure 5.18(b):
F = A ¬∑ B ¬∑ C ¬∑ D
[5.9]
= (A + B)(C + D)
[5.10]

194
Digital Electronics 2
‚Äì circuit as shown in Figure 5.18(c):
G = A ¬∑ B ¬∑ D
[5.11]
= A + B + C
[5.12]
SOLUTION 5.4.‚Äì Power dissipation.
The power of the TTL circuit is given by:
PD = 5(1.5 + 4.5)10‚àí3/2 = 15 √ó 10‚àí3 W = 15 mW
The maximum frequency of the CMOS circuit is given by:
f = fmax =
PD ‚àíVDDIDD
(CL + CP D)V 2
DD
[5.13]
= 10 √ó 10‚àí3 ‚àí3(20 √ó 10‚àí6)
(10 + 20)10‚àí12 √ó 32
= 36.8 √ó 106 Hz = 36.8 MHz

6
Semiconductor Memory
6.1. Introduction
Semiconductor memories are digital information storage devices. They are used
in all appliances including microprocessors and also in implementing programmable
logic circuits.
Semiconductor memories have very low access time compared to other memories,
such as hard disks and optical storage discs (Blu-ray discs, DVD, etc.). Semiconductor
memory can be classiÔ¨Åed into two types:
‚Äì volatile memory: these are memories where the integrity of information is not
guaranteed unless they are electrically powered. They are readable and writable;
‚Äì non-volatile memories:
these memories preserve information even in the
absence of an electric power supply.
The operation of storing information in a memory corresponds to writing or
programming.
6.2. Memory organization
The elementary cell of a semiconductor memory is used to store one bit of data.
For non-volatile memory, this can be assimilated to one of the nodes in a network that
is connected, through a switch, to either electric voltage (corresponding to the high
logic level) or to the ground (or the voltage deÔ¨Åning the low logic level); in the case
of volatile memory, the elementary cell is based on a Ô¨Çip-Ô¨Çop, usually a D Ô¨Çip-Ô¨Çop.
A memory word is a set of juxtaposed n bits. In practice, n is equal to 4, 8, 16,
32, or 64. When n is equal to 8, the memory word is called an octet. Each row of cells
represents a memory location, which is typically equal to the word size.
Digital Electronics 2: Sequential and Arithmetic Logic Circuits, First Edition. Tertulien Ndjountche. 
¬© ISTE Ltd 2016. Published by ISTE Ltd and John Wiley & Sons, Inc. 

196
Digital Electronics 2
Each word is selected by providing a binary address. A set of wires used to identify
speciÔ¨Åc memory locations constitutes the address bus.
Using a decoder, n wires are required to address 2n memory locations. The
memory capacity when expressed as the number of memory locations or words is,
therefore, 2n. It can also be expressed as the number of bits. In this case, it is
multiplied by the number of bits per word.
EXAMPLE 6.1.‚Äì Determine the number of address lines for a memory with a capacity
of 64K √ó 8.
A 64K √ó 8 memory is organized into words of eight bits, or octets, and has a
capacity of 64 K octets.
As each word requires an address line and 1K equals 210 or corresponds to 1, 024
bits, implementing this memory requires a total number, n, of address lines, where
n = log(64 √ó 1 024)/ log(2) = 16.
The set of wires through which the information to be stored or read is transmitted
is called the data bus.
(b)
AL1
AK+1
AK
Decoder
N=2K
Cell
Inputs/Outputs
(a)
M bits
Decoder
Cell
BL
WL
M. 2 LK
2K
Decoder
A
A1
A 0
K1
A
A1
A 0
K1
Inputs/Outputs
Word 0
Word 1
Word 2
Word N2
Word N1
Figure 6.1. a) Column structure for a memory;
b) matrix structure for a memory
A memory can be organized in a column structure, as shown in Figure 6.1(a).
The decoder is used to select, from k-bit addresses, an address of 2K lines, or an
M-bit word. When the number of bits, K, becomes very high, a regular structure
is only obtained by adopting a matrix conÔ¨Åguration, as illustrated in Figure 6.1(b).

Semiconductor Memory
197
The address of a word is divided into a line address (A0, ¬∑ ¬∑ ¬∑ , AK‚àí1) and a column
address (AK, ¬∑ ¬∑ ¬∑ , AL‚àí1). Thus, in order to select a word, a horizontal line or a word
line (WL) and a vertical line, or bit line (BL), must be activated.
6.3. Operation of a memory
Memories are designed such that they can be connected to the same data bus. Each
memory chip then possess a selected input, CS (chip select) or CE (chip enable), that
can be used to avoid conÔ¨Çicts when the bus is in use for other purposes. Each of these
control inputs can serve to connect or disconnect a memory from the bus.
‚Äì if CS takes the logic state 0, the memory is selected and connected to the data
bus;
‚Äì if CS assumes the logic state 1, the data buffer is set to the high impedance state
in order to disconnect the memory.
(c)
S
CS
CS
CS
E/S
Memory
Memory
E/S
Memory
R/ W
OE
 AN1
A 0
 AN1
A 0
 AN1
A 0
WE
(a)
(b)
Figure 6.2. a) Read only memory; b) and c) read/write memory
A memory has an output enable input that, often symbolized as OE, can be used to
enable or disable the output, and a write enable input (or read/write R/W input) that
can be used to select which operation is to take place, read or write. The conditions
for a read operation are:
‚Äì if OE takes the logic state 0, it is possible to read data;
‚Äì if OE takes the logic state 1, the data bus is in a high-impedance state and
reading data are not possible.
The necessary conditions for a write operation are as follows:
‚Äì if WE takes the logic state 0, it is possible to write data;
‚Äì if WE takes the logic state 1, it is not possible to write data.
A signal may take the low level, high level or an intermediate level that corresponds
to the high impedance state (see equation [6.3]).

198
Digital Electronics 2
level
High
High
impedance
Low
High
High
impedance
(a)
(b)
level
level
Low
level
Figure 6.3. Representation of a signal: a) ideal case; b) taking into
account the rise and fall times
Data representation on a bus is illustrated in Figure 6.4. Two states can be
observed:
‚Äì a low-impedance state for which the logic level of each wire may be 0 or 1 (two
horizontal lines; the hexadecimal value of the binary conÔ¨Åguration of the wires is
written between these lines);
‚Äì a high impedance state for which the logic level is not deÔ¨Åned (a median line).
In this case, the bus is disconnected.
Data 3
High
Bus i
impedance
Data 1
Data 2
Figure 6.4. Data representation on a bus
Memory timing diagrams for a read cycle and a write cycle are shown in
Figures 6.5 and 6.6, respectively. In general, a transient state is seen on the bus before
the data level stabilizes. The timing characteristics of a read operation can be deÔ¨Åned
as follows:
‚Äì tRC: duration of read cycle;
‚Äì tAC: access time with respect to select input;
‚Äì tAA: access time with respect to the address bus;
‚Äì tOE: data appearance delay with respect to read initialization.
The following are the timing characteristics associated with a write operation:
‚Äì tW C: duration of the write cycle;
‚Äì tSA: address setup time;
‚Äì tW D: WE-hold duration at the low level after data have been applied;
‚Äì tHD: data hold time.

Semiconductor Memory
199
S (Data)
OE
CS
tAC
tRC
A 0AN1
tOE
tAA
Data
Address
Figure 6.5. Memory timing diagram for a read cycle
Data
CS
A 0AN1
tWC
tWD
tHD
tSA
WE
Address
E (Data)
Figure 6.6. Memory timing diagram for a write cycle
6.4. Types of memory
Volatile and non-volatile memory can be differentiated based on the data-retention
feature (or the ability to return correct stored data over a period time).
6.4.1. Non-volatile memory
Non-volatile memory or read-only memory (ROM) is used to permanently store
data. The information contained in a ROM is recorded at the time of production, based
on an exposure technique for photosensitive material, through a mask that reÔ¨Çects the
desired binary conÔ¨Åguration.
We can distinguish between many types of non-volatile memories that differ in
internal structure, the number of times they can be reprogrammed and the methods for
erasure:

200
Digital Electronics 2
‚Äì PROM or programmable ROM is a non-volatile memory that can only be
programmed once. It is composed of a set of fuses that is destroyed during
programming;
‚Äì EPROM or erasable PROM is a kind of PROM that can be programmed, erased
and reprogrammed. Erasure is carried out by exposing the active part of the EPROM
to ultraviolet light. After this operation, all memory cells store a logic 1. The bulk
erase operation for an EPROM is non-selective (that is: it affects all the cells);
‚Äì EEPROM or electrically erasable PROM is functionally identical to EPROM.
The erase operation consists of applying a predetermined electric pulse to the memory.
The main difference between EEPROM and EPROM is that EEPROM can be erased
and reprogrammed without being displaced from its support and in a selective manner.
To erase an EPROM, it must be removed from its support to be handed with special
equipment. EEPROM is almost 10 times slower than random-access memory (RAM)
and its storage capacity is about 100 times lower than that of a RAM. They are mainly
used in applications where non-volatility is a requirement;
‚Äì Flash EEPROM can be erased partially or completely with an electric pulse.
Contrary to what happens with the EEPROM, where the minimum erasure concerns
an octet, the partial erasure of a Ô¨Çash EEPROM is performed on a block of data. A
Ô¨Çash EEPROM can be programmed or erased without being removed from its support.
The Ô¨Çash EEPROM offers a higher storage density than EEPROM.
A ROM can be manufactured using a variety of technology: bipolar, metal-oxide
semiconductor (MOS) or complimentary MOS (CMOS).
The structure of a mask ROM is illustrated in Figure 6.7. It comprises a decoder,
n-channel MOS transistors, pull-up resistors and three-state buffers. The vertical line
(BL) is connected to the supply voltage, VDD. The mask used during the manufacture
does not permit transistors to be inserted anywhere except those positions where the
logic 1 must be stored. For each read operation, a single horizontal line (WL) is
activated by the decoder. This enables the transistors to function as closed switches
between the corresponding nodes on the vertical lines and the ground. As the outputs
for the buffer are logically complemented, the transistor‚Äôs presence results in the
storage of logic 1. The absence of a transistor results in the storage of the logic state
0. A 2n √ó m ROM can be used to store m different logic functions of n variables.
As Figure 6.8 illustrates, the structure of an EPROM is similar to that of a ROM,
but using Ô¨Çoating-gate transistors.
A memory cell is programmed by applying voltage that is higher than the normal
operational voltage to the transistor gate. This results in the capture by the Ô¨Çoating gate
of a portion of channel electrons that have passed through the thin oxide layer. The
charge thus acquired by the gate is maintained even after the programming voltage
is disconnected, and the transistor is biased in the cut-off region and then behaves as

Semiconductor Memory
201
an open switch. Because the vertical line is connected to the supply voltage, VDD,
and the output of the three-state buffer is complemented, the programming operation
corresponds to the storage of the logic state 0.
0
A 1
A 2
2n
Network equivalent to an OR gate bank
A
EN
0
2
1
1
An1
Dm1
D2
D1
D0
VDD
Address
Decoder
Figure 6.7. Structure of a read-only memory (in MOS technology)
Under normal operation, the selection of a horizontal line by the decoder results
in the application of the voltage corresponding to the high logic level to the transistor
gates. The transistors, which have been connected to the programming voltage
beforehand, are not affected and continue to operate as open switches (or cells set to
the logic state 0), while the others become equivalent to closed switches (or cells set
to the logic state 1).
The erase operation consists of applying an ionizing ray (e.g. ultraviolet light),
which has enough energy to free the captured electrons from the Ô¨Çoating gate. An
EPROM is encapsulated in a plastic-molded package having a window that is
translucent to ultraviolet light.
In general, an EPROM cannot be erased electrically because once a sufÔ¨Åcient
number of electrons have been captured by the gate, the transistor conduction can no
longer be reestablished just by reversing the voltage used during programming.

202
Digital Electronics 2
0
A 1
A 2
2n
Dm1
D2
D1
D0
VDD
n1
A
decoder
Address
EN
0
2
1
1
A
Network equivalent to an OR gate bank
Figure 6.8. Structure of an EPROM
However, electrically erasable ROMs can be implemented by using cells with two
transistors in series, a MOS transistor for the selection and a Ô¨Çoating-gate tunneling
oxide transistor for the storage. This approach is characterized by a lower integration
density as compared to a ROM.
Non-volatile programmable memories present the disadvantage of getting
damaged after some time (retention time of about 10 years) and having a capped
number of write/erase cycles (102‚Äì105).
6.4.2. Volatile memories
A volatile memory, or RAM gives access to each of its cells for a read or write
operation, with the same access time and in any order.
There are two types of volatile memory:
‚Äì static RAM or SRAM can operate at high speeds, but present the disadvantage
of requiring high power consumption as its elementary cells are based on D Ô¨Çip-Ô¨Çops;

Semiconductor Memory
203
‚Äì dynamic RAM or DRAM is characterized by a large storage capacity. The basic
cell is implemented by associating a transistor and a capacitor (see Figure 6.11) that
can store or restore electric charge. The memorization of a bit is materialized by the
presence (logic 1) or absence (logic 0) of a charge on the capacitor.
Charge stored on a capacitor tends to gradually decrease over time. This is why
DRAM must be periodically refreshed to maintain memorization. As the external
logic circuits must take into account these priority actions linked to refreshing,
DRAM requires more complex interfacing techniques than SRAM.
The structure of a 4 √ó 4 memory with cells based on D Ô¨Çip-Ô¨Çops is represented in
Figure 6.9. It can be useful for the illustration of the SRAM operation principle. The
truth table is given in Table 6.1, where the memory is activated by the chip-enable
signal, CE, and the logic state of the write signal WR is used to choose between the
write and read operations. For each combination of address bits, the decoder activates
a horizontal line (or WL) thereby enabling the writing or reading of a 4-bit word
through the bidirectional I/O pins.
Address decoder
1
A 0
CM
CM
CM
CM
CM
CM
CM
CM
CM
CM
CM
CM
C
D
Q
CM
CM
CM
CM
3
DQ
2
DQ
1
DQ
0
DQ
0
1
2
3
WR
CE
A
Figure 6.9. Structure of a 4 √ó 4 memory with cells based on D Ô¨Çip-Ô¨Çops
In general, an SRAM may be implemented as shown in Figure 6.10. The matrix
structure, with a line decoder and a column decoder, offers the advantage of being
more regular. Table 6.2 shows the truth table of the memory, where the control inputs
are designated by CE (chip enable), OE (output enable) and WE (write enable).

204
Digital Electronics 2
CE
WR
DQi
Remarks
1
x
Z
Deactivate
0
0
1
Write 1
0
0
0
Write 0
0
1
Data
Read
Table 6.1. Truth table for the 4 √ó 4 (i = 0, 1, 2, 3) memory
Row decoder
WE
OE
CE
A k1 A k+1
A n1
BL
0
DQ
A 0
A 1
A k1
WL
BL
m1
DQ
1
DQ
1bit cell
Network of storage
cells
Column decoder
Input buffer
Sense amplifiers
Figure 6.10. Structure of an SRAM
CE
OE
WE
DQi
Remarks
1
x
x
Z
Memory disabled
0
1
1
Z
Outputs disabled
0
0
1
Data
Read
0
x
0
Data
Write
Table 6.2. Truth table of the (i = 0, 1, ¬∑ ¬∑ ¬∑ , m ‚àí1) SRAM
The elementary cell, which can store 1-bit data, consists of two inverters that form
a closed loop, each of whose outputs are connected to a transistor. Access to the cell
is controlled by the logic state of the WL, while the BL and its complement (BL)

Semiconductor Memory
205
are used to transfer data during read and write operations. The elementary cell of an
SRAM is sized so as to minimize its surface. Consequently, it operates with very low
electric currents, resulting in a small voltage difference between the lines BL and BL.
Access to memory is accelerated by using sense ampliÔ¨Åers to capture and to increase
this small voltage difference so that this latter can reach recognizable logic levels.
A memory with higher density, like the DRAM, can be implemented by reducing
the size of the elementary cell. Figure 6.11 depicts the structure of a DRAM, which is
based on an elementary cell that is composed of a MOS transistor and a capacitor, C.
buffer flipflops
k1 A k+1
A n1
OE
Refresh control
Address &
refresh counter
Row address
buffer flipflops
& Input/Output gates
Column decoder
Column address
A
CBL
0
DQ :
m1
DQ
A 0
A 1
A k1
WE
RAS
CAS
Sense amplifiers
C
WL
1bit cell
BL
Network of storage
buffers
Input
buffers
Output
cells
Control & temporisation
circuit
Row decoder
Figure 6.11. Structure of a DRAM
During a write operation, a data bit is placed on the line BL, and the signal applied
to the line WL assumes the high logic level. Depending on the logic state (1 or 0) of
the data bit, the capacitor is either charged or discharged. Before a read operation, the
BL line is connected to a precharge voltage that is equal to half of the sum of high-
level and low-level voltages; this enables the charging of the parasite capacitor, CBL,
of the BL line. As soon as the signal in the WL line takes the high level, a charge
redistribution occurs between the capacitor CBL and the capacitor C. This results in
an increase or decrease of the voltage on the BL line, depending on whether the logic
state of the initially stored data is 1 or 0. As the parasitic capacities are of the order
of ten or hundred times the value of C, this variation in voltage is low and must be
converted to logic levels using a sense ampliÔ¨Åer.

206
Digital Electronics 2
The charge stored on the capacitor C is reduced by the presence of parasitic
capacitances as well as by each read operation. Thus, refresh operations, which
consist of rewriting the cell contents, must be periodically carried out so that the data
stored in the memory is not altered. The frequency of these operations is reduced by
adopting a two-dimensional architecture, where an entire line can be refreshed at a
time.
To reduce the number of pins, the line and column addresses are multiplexed in
most DRAMs. The decrease in access time is obtained by assigning the selection
function to two control signals, RAS (row address strobe) and CAS (column address
strobe). The RAS signal is used to initiate the capture of line addresses and to mark
the beginning of each operation. It also triggers refresh cycles. The CAS signal is used
to latch the column addresses and to start the read or write operation. Its activation is
also necessary to trigger some types of refresh cycle.
The timing diagrams for a write cycle and for a read cycle in a DRAM are
represented in Figure 6.12. When the RAS signal takes the logic state 0, the line
address is stored on Ô¨Çip-Ô¨Çops and then replaced by the column address. When the
logic state of the CAS signal becomes 0, the Ô¨Çip-Ô¨Çops are used to store the column
address. Each access to the memory, therefore, requires the activation of the RAS
signal, followed by that of the CAS signal. The write and read operations are also
dependent on the WE and OE signals, respectively. Addresses and data are valid
only when each control signal remains active for at least for a predetermined minimal
time.
Data
DQ
RAS
CAS
k
DQ
WE
RAS
CAS
(b)
row
column
Address
OE
row
(a)
Address
Data
column
k
Figure 6.12. a) Write cycle and b) read cycle of a DRAM
In a DRAM, each write or read operation is followed by a refresh cycle of the line
that was accessed. However, these operations are not frequent enough to guarantee
the refreshing of the whole memory within the time limitations. Therefore, in addition
to hidden refresh cycles, which are characterized by the execution of a write or read
operation and a refresh cycle during a single active period of the CAS signal, it is
necessary to consider other refresh options:

Semiconductor Memory
207
‚Äì the RAS-only refresh cycle is executed when the address for the line to be
refreshed is placed on the bus after activating the RAS signal;
‚Äì the CAS-before-RAS refresh cycle is initiated by activating the CAS signal
before the RAS signal. When this sequence is detected by the control circuit, the line
whose address is speciÔ¨Åed by an internal counter is refreshed;
‚Äì the autorefresh cycle is also known as sleep mode or self refresh cycle. An on-
chip oscillator is used to determine the refresh frequency and a counter helps monitor
the address each time.
A conventional DRAM is controlled asynchronously and, thus, requires wait
states to ensure the data synchronization, while a synchronous DRAM (SDRAM) is
basically a DRAM with a synchronous interface. An SDRAM can preserve the same
data transfer speed over a larger bandwidth because the inputs/outputs and control
signals are synchronized with an external clock signal.
Other DRAM structures have been proposed for applications that require faster
access to data:
‚Äì Extended data out DRAM begins the output data generation on the falling edge
of the CAS signal and continues in this way until the RAS signal is deactivated or
until the next falling edge of the CAS signal.
‚Äì Rambus DRAM is characterized by a higher bandwidth. It uses an interface to
connect one or more memories to the same bus.
‚Äì Double data rate SDRAM (DDR SDRAM) enables data transfer on both the
rising and falling edges of the clock signal, thus doubling the data transfer rate. It
uses a prefetch buffer with a depth of two words to facilitate access to several words
sharing the same line address. The increase in the input/output Ô¨Çow rate is obtained
for later versions of the SDRAM, DDR2 and DD3, by using prefetch buffers with
depths of four and eight to increase the number of words accessed by four and eight,
respectively.
6.4.3. Characteristics of the different memory types
A semi-conductor memory uses the same technology as an integrated circuit. It is
characterized by high-speed operation and low manufacturing costs. Table 6.3
summarizes the characteristics of different types of semiconductor memory.
6.5. Applications
Logic function implementations using a memory consist of storing the values for
this function at well-deÔ¨Åned addresses. These addresses are determined by properly
connecting the input variables of the logic function to the address bus.

208
Digital Electronics 2
Erase
Type
Category
Erase
an octet
Volatile
Use
SRAM
Read/write
Electrical
Yes
Yes
Cache
Main
DRAM
Read/write
Electrical
Yes
Yes
memory
Various
ROM
Read only
Impossible
No
No
applications
Few
PROM
Read only
Impossible
No
No
applications
Read mostly
EPROM
Write once
Ultraviolet
No
No
Prototyping
Read mostly
EEPROM
Write several times
Electrical
Yes
No
Prototyping
Flash
Various
EEPROM
Read/write
Electrical
‚àí
No
applications
Table 6.3. Characteristics of different types of semiconductor memory
When the value of certain bits of the address bus is Ô¨Åxed, the memory is divided
into two parts:
‚Äì an accessible part;
‚Äì an inaccessible part.
EXAMPLE 6.2.‚Äì Consider a memory with an address bus of three bits A2A1A0, where
A0 is the least signiÔ¨Åcant bit.
Table 6.4 depicts the accessible and inaccessible parts (four cell zone) if the bit A2
is Ô¨Åxed to 0.
Table 6.5 shows the accessible and inaccessible part (four cell zone) if the bit A0
is set to 1.
In general, the total capacity of the accessible part is equal to the total capacity
divided by 2x, where x is the number of Ô¨Åxed bits.
6.5.1. Memory organization
We can implement a high-capacity memory using elementary memory chips. The
memory to be designed contains:

Semiconductor Memory
209
‚Äì one address bus;
‚Äì one data bus;
‚Äì control signals.
1
A
A2
A0
1
1
cell 6
cell 7
0
1
cell 4
cell 5
0
0
1
1
1
cell 2
cell 3
0
1
cell 0
cell 1
0
0
0
Accessible part
Inaccessible part
Table 6.4. A2 = 0. For a color version of this table, see
www.iste.co.uk/ndjountche/electronics2.zip
Accessible part
A1
A2
A0
1
1
cell 6
cell 7
0
1
cell 4
cell 5
0
0
1
1
1
cell 2
cell 3
0
1
cell 0
cell 1
0
0
0
Inaccessible part
Table 6.5. A0 = 1. For a color version of this table, see
www.iste.co.uk/ndjountche/electronics2.zip
The increase in capacity corresponds to either the increase in the number of the
data bus bits (see Figure 6.13), or the increase in the number of the address bus bits
(see Figure 6.14).
NOTE 6.1.‚Äì In the case where the address bus is expanded, it is often necessary to
determine a logic function for the selection of elementary memories.
6.5.2. Applications
To meet the requirements of certain applications, elementary memories can be
combined in order to obtain larger storage capacity.

210
Digital Electronics 2
bus
bus
A3 A2 A1 A0
D3 D2 D1 D0
Memory
A3 A2 A1
0
D3 D2 D1 D0
Memory
A
CE
OE
CE
OE
CE
OE
Address
Data
Figure 6.13. Combining memories to expand the word length
bus
OE
A3 A2 A1 A0
D3 D2 D1 D0
Memory
A3 A2 A1
0
D3 D2 D1 D0
Memory
A
CE
OE
CE
OE
Address
bus
Data
Figure 6.14. Combining memories to expand the capacity
6.5.2.1. Example 1
We wish to connect several 2 K √ó8 PROMs to produce a total capacity of 8 K √ó8.
Indicate how many PROM chips are required.
Determine the number of wires of the address bus.
Four PROM chips, each of 2 K words, are required to obtain 8 K words.
Because 8 K = 8 √ó 1 024 = 8 192 = 213, the address bus must have 13 wires.

Semiconductor Memory
211
6.5.2.2. Example 2
We desire to implement a 4 K √ó 4 memory, beginning with the address 0000h and
using an elementary 2 K √ó 4 memory and two elementary 1 K √ó 4 memories.
Suggest the possible organization for this memory.
For the 4 K √ó 4 memory, the data bus has four bits and the lowest address is 0, or:
0 0000 0000 0000 = 0000 h
the highest address is 0 + 4 K ‚àí1 = 4 095, or:
0 1111 1111 1111 = 0FFFh
The number of bits, n, required for the address bus is given by:
2n‚àí1 < 4 K ‚àí1 ‚â§2n
[6.1]
That is:
2n‚àí1 < 4 √ó 210 ‚àí1 ‚â§2n
[6.2]
and Ô¨Ånally:
n = 12
[6.3]
The address bits, therefore, are of the form: A11A10A9 ¬∑ ¬∑ ¬∑ A0.
The select logic equations will be even simpler provided that the address where
each elementary memory begins is:
‚Äì either divisible by 2;
‚Äì or divisible by the capacity of the memory.
The two possible ways of organizing the 4 K √ó4 memory are given in Figure 6.15.
For each elementary memory, the address bits that are used only for decoding must
be identiÔ¨Åed.
Starting from the bit A0 to the least signiÔ¨Åcant bits for an elementary memory,
it is not necessary to take into account those bits that change from 0, in the starting
address, to 1, in the Ô¨Ånal address.

212
Digital Electronics 2
(b)
1 K
0C00h
0FFFh
07FFh
2 K
0000h
1 K
0C00h
0FFFh
1 K
0800h
0BFFh
0BFFh
2 K
0400h
1 K
0400h
03FFh
M12
M13
(a)
M11
M23
M21
M22
Figure 6.15. a) Organization 1; b) organization 2
‚Äì Organization 1 Using Table 6.6 to establish the select functions, the useful
address bits are:
- A11 for the 2K memory (M11);
- A11 and A10 for the Ô¨Årst 1K memory (M12);
- A11 and A10 for the second 1K memory (M13).
1
CS
A11
A10
A9
A8
A7
A6
A4
A5
A3
A2
A1
A0
0
1
1
1
1
1
1
1
1
1
1
1
0
1
1
0
0
0
0
0
0
0
0
0
0FFFh
0C00h
0
1
0
1
1
1
1
1
1
1
1
1
0
1
0
0
0
0
0
0
0
0
0
0
0BFFh
0800h
0
1
0
1
1
1
1
1
1
1
1
1
1
0
0
0
0
0
0
0
0
0
0
0
0
07FFh
0000h
1
Table 6.6. Address table for organization 1For a color version of this
table, see www.iste.co.uk/ndjountche/electronics2.zip
The select equations are given by:
CS11 = CS ¬∑ A11
[6.4]
CS12 = CS ¬∑ A11 ¬∑ A10
[6.5]
and:
CS13 = CS ¬∑ A11 ¬∑ A10
[6.6]

Semiconductor Memory
213
‚Äì Organization 2 Based on Table 6.7, the select functions depend on the following
address bits:
- A11 and A10 for the Ô¨Årst 1K memory (M21);
- A11 and A10 for the 2K memory(M22);
- A11 and A10 for the second 1K memory (M23).
1
CS
A11
A10
A9
A8
A7
A6
A4
A5
A3
A2
A1
A0
0
1
1
1
1
1
1
1
1
1
1
1
0
1
1
0
0
0
0
0
0
0
0
0
0FFFh
0C00h
0
1
0
1
1
1
1
1
1
1
1
1
0
0
1
0
0
0
0
0
0
0
0
0
0BFFh
0400h
0
1
0
0
1
1
1
1
1
1
1
1
1
0
0
0
0
0
0
0
0
0
0
0
0
03FFh
0000h
1
Table 6.7. Address table for organization 2For a color version of this
table, see www.iste.co.uk/ndjountche/electronics2.zip
The select logic equations can be written as follows:
CS21 = CS ¬∑ A11 ¬∑ A10
[6.7]
CS22 = CS ¬∑ (A11 ¬∑ A10 + A11 ¬∑ A10)
[6.8]
and:
CS23 = CS ¬∑ A11 ¬∑ A10
[6.9]
The expression CS22 is more complex than the expression for CS12 because the
starting address (0400 h) is not divisible by the capacity of the elementary memory
(2 K = 2 √ó 210 = 0800 h).
Figure 6.16 depicts the logic circuit of the 4 K √ó 4 memory corresponding to each
organization (1 and 2).
NOTE 6.2.‚Äì To obtain the useful address bits for the determination of the select
function of each elementary memory, it is necessary to go through the address table,
beginning with the least signiÔ¨Åcant bit and moving toward the most signiÔ¨Åcant bits,

214
Digital Electronics 2
frame the bits that go from 0, in the starting address, to 1, in the Ô¨Ånal address and
stop as soon as the value of the encountered bit is either 1 for the starting address or 0
for the Ô¨Ånal address. The unmarked bits will be used for the selection of each
elementary memory.
A[10:0]
10
A11
CS
WE
A10
A11
CS
WE
A[10:0]
A[10:0]
A
(a)
A[9:0]
A[9:0]
WE
CS
WE
CS
WE
CS
DQ[3:0]
DQ[3:0]
DQ[3:0]
DQ[3:0]
(b)
A[9:0]
WE
CS
A[9:0]
WE
CS
WE
CS
DQ[3:0]
DQ[3:0]
DQ[3:0]
DQ[3:0]
A[10:0]
Figure 6.16. Logic circuit of the 4K √ó 4 memory:
a) organization 1; b) organization 2
The logic expression for the select function may be obtained directly or may be
simpliÔ¨Åed further by using a Karnaugh map.
A select function may be implemented using a decoder or logic gates.
6.5.2.3. Binary-to-BCD converter
Binary and binary-coded decimal (BCD) numbers are very frequently used in
digital systems. The simplest conversion method consists of using an algorithm that
allows modular synthesis based on expandable building blocks.
The conversion of a binary code to BCD is carried out based on algorithm 6.1.
Algorithm 6.1. Conversion of a binary code to BCD
[1] Shift the binary number to the left by one bit.
[2] Add 0011 each time to the bits that are found in the position of a BCD digit
if the decimal value of these bits is greater than 4, before shifting them to the
left by one bit.
[3] Repeat step [2] until the least signiÔ¨Åcant bit of the binary code is located in the
position of the least signiÔ¨Åcant BCD digit. The bits thus obtained constitute
the BCD code.
Convert, as an example, the 7-bit binary code, 11110112, to BCD.

Semiconductor Memory
215
Table 6.9 lists the different steps to carry out for the conversion. We thus have:
11110112 = 123BCD
[6.10]
The truth table shown in Table 6.8 establishes the equivalence between a 5-bit
binary code and BCD number based on the conversion algorithm that recommends
the addition of 3 each time there is a BCD digit greater than 4. It must be noted that
the enable signal, G, is an active-high signal. The logic circuit of a 5-bit binary-to-
BCD (B2BCD) converter is illustrated in Figure 6.17. It is implemented using a ROM
and may be considered as an expandable module.
Figures 6.18(a) and 6.18(b) show, respectively, the logic circuits for the 6-bit
binary-to-BCD
and
8-bit
binary-to-BCD
converters,
obtained
by
cascading
expandable modules so as to satisfy the shift-left requirement of the conversion
algorithm.
6.5.2.4. BCD-to-binary converter
The steps for converting BCD to binary code are given in algorithm 6.2.
Algorithm 6.2. Conversion of BCD to binary code
[1] Shift the BCD number to the right by one bit.
[2] Subtract 0011 from a new consecutive 4-bit word each time its decimal value
is greater than 7 (0111).
[2] Repeat steps [1] and [2] until the last bit is transferred out of the BCD number.
The binary code then consists of the obtained bits.
In the case of the conversion of the BCD code 16BCD or 1 0110BCD to binary,
the different conversion steps are described in Table 6.11.
And Ô¨Ånally, we obtain:
16BCD = 100002
[6.11]
To construct the truth table of the BCD-to-5-bit binary converter, as shown in
Table 6.10, where the enable signal is represented by G, the BCD-to-binary conversion
algorithm can be interpreted as being the inverse of the binary-to-BCD conversion
algorithm. Because this truth table must be implemented by a ROM with output three-
state inverting buffers, the unused (or don‚Äôt-care) states are set to high logic.
Figure 6.19 depicts the logic circuit of the BCD-to-5-bit binary (BCD2B)
converter.

216
Digital Electronics 2
E
D
C
B
A
G
Y6
Y5
Y4
Y3
Y2
Y1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
1
0
0
0
1
0
0
0
0
0
0
1
0
0
0
0
1
1
0
0
0
0
0
1
1
0
0
1
0
0
0
0
0
0
1
0
0
0
0
1
0
1
0
0
0
1
0
0
0
0
0
1
1
0
0
0
0
1
0
0
1
0
0
1
1
1
0
0
0
1
0
1
0
0
1
0
0
0
0
0
0
1
0
1
1
0
1
0
0
1
0
0
0
1
1
0
0
0
1
0
1
0
0
0
1
0
0
0
0
0
1
0
1
1
0
0
1
0
0
0
1
0
1
1
0
0
0
0
1
0
0
1
0
0
1
1
0
1
0
0
1
0
0
1
1
0
1
1
1
0
0
0
1
0
1
0
0
0
1
1
1
1
0
0
1
1
0
0
0
1
0
0
0
0
0
0
1
1
0
0
1
1
0
0
0
1
0
0
1
1
0
1
0
1
0
0
1
0
0
0
1
1
0
1
1
1
0
0
1
1
0
0
1
1
1
0
0
1
0
1
0
0
0
1
0
0
0
0
0
1
0
1
0
1
0
1
0
0
0
0
1
1
0
1
1
0
0
1
0
0
0
1
0
1
0
1
1
1
0
1
0
0
0
1
1
1
1
0
0
0
0
1
0
0
1
0
0
1
1
0
0
1
0
1
0
1
0
0
0
1
1
0
1
0
0
1
0
1
0
0
1
1
1
0
1
1
0
1
0
1
0
1
0
1
1
1
0
0
0
1
0
1
0
1
1
1
1
1
0
1
0
1
0
1
1
0
0
1
1
1
1
0
0
1
1
0
0
0
0
1
1
1
1
1
0
1
1
0
0
0
1
x
x
x
x
x
1
1
1
1
1
1
1
Table 6.8. Truth table for a 5-bit binary-to-BCD conversion
The logic circuits of the BCD-to-6-bit binary and BCD-to-7-bit binary converters
are represented in Figures 6.20(a) and 6.20(b), respectively, taking into account the
shift-right operations.

Semiconductor Memory
217
Address decoder
6
Y3
Y2
Y1
Y4
Y5
B
E
A
G
1;
0.
20
21
22
19
18
17
16
23
28
29
30
27
26
25
24
31
12
13
14
11
10
15
C
D
4
5
6
3
2
1
0
7
9
8
Storage of
Storage of
Y
Figure 6.17. Logic circuit of a 5-bit binary-to-BCD converter

218
Digital Electronics 2
B2BCD
6
B7
B2
B1
B0
Y5
Y4
Y3
Y2
Y1
Y6
Y5
Y4
Y3
Y2
Y1
Y6
LSB
Y5
Y4
Y3
Y2
Y1
Y6
B2
B1
B0
B3
B5
B4
B3
B5
B4
Y5
Y4
Y3
Y2
Y1
Y6
0
MSB
BCD code
A
B
E
D
C
G
A
B
E
D
C
G
0
Binary code
(b)
A
B
E
D
C
G
0
LSB
BCD code
MSB
(a)
Binary code
A
B
E
D
C
G
B2BCD
B2BCD
B2BCD
B
Figure 6.18. Logic circuits: a) 6-bit binary-to-BCD and b) 8-bit
binary-to-BCD converters
Hundreds
Tens
Unit
Operation
1111011
Store the binary code
1
111011
Shift left
11
11011
Shift left
111
1011
Shift left
1010
1011
Add 111
1
0101
011
Shift left
1
1000
011
Add 011 to 0101
11
0000
11
Shift left
110
0001
1
Shift left
1001
0001
1
Add 011 to 110
1
0010
0011
Shift left
1
2
3
Table 6.9. Conversion of the code 11110112 to BCD
6.6. Other types of memory
Several other types of memory are used to meet the requirements of increasingly
different applications.

Semiconductor Memory
219
E
D
C
B
A
G
Y5
Y4
Y3
Y2
Y1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
1
0
0
0
1
0
0
0
0
0
1
0
0
0
0
1
1
0
0
0
0
1
1
0
0
1
0
0
0
0
0
1
0
0
0
1
0
0
0
0
0
0
1
0
1
0
1
0
0
1
0
0
0
1
1
0
0
1
0
1
0
0
0
0
1
1
1
0
1
0
1
1
0
0
1
0
0
0
0
1
1
0
0
0
0
1
0
0
1
1
0
0
0
0
0
0
1
0
1
0
1
0
0
0
1
0
0
1
0
1
1
1
0
0
1
0
0
0
1
1
0
0
1
0
0
1
1
0
0
1
1
0
1
1
0
1
0
0
0
0
1
1
1
0
1
1
0
0
0
0
0
1
1
1
1
1
1
0
0
1
0
1
0
0
0
0
1
1
0
1
0
0
1
0
0
0
1
1
1
0
1
1
0
1
0
0
1
0
1
1
1
0
0
0
1
0
0
1
1
x
x
x
x
x
1
1
1
1
1
1
Table 6.10. Truth table for a BCD-to-5-bit binary conversion
Tens
Units
Operation
1
0110
Store the BCD code
1011
0
Shift to right
101
10
Shift to right
10
110
Shift to right
1
0110
Shift to right
10110
Shift to right
10000
Subtract 011 from 1011
10000
Table 6.11. Conversion of 16BCD to binary

220
Digital Electronics 2
Address decoder
3
Y2
Y1
Y4
Y5
20
21
22
19
18
17
16
23
28
29
30
27
26
25
24
31
12
13
14
11
10
15
C
D
4
5
6
3
2
1
0
7
9
8
Y
G
B
E
A
Figure 6.19. Logic circuit of a BCD-to-5-bit binary converter
6.6.1. Ferromagnetic RAM
A ferromagnetic RAM (FRAM) is based on a cell that is similar to that of a
DRAM, but uses a capacitor with a dielectric layer made up of a ferroelectric
material (perovskite crystal) to obtain non-volatility.

Semiconductor Memory
221
BCD2B
5
Y4
Y3
Y2
Y1
Y5
Y4
Y3
Y2
Y1
B3
B2
B5
B4
B1
B0
B1
B0
Y5
Y4
Y3
Y2
Y1
B6
B3
B2
B5
B4
A
B
E
D
C
G
MSB
LSB
0
A
B
E
D
C
G
0
LSB
MSB
BCD code
BCD code
Binary code
(a)
(b)
A
B
E
D
C
G
Binary code
BCD2B
BCD2B
Y
Figure 6.20. Logic circuits for a) BCD-to-6-bit binary and
b) BCD-to-7-bit binary converters
A FRAM cell is illustrated in Figure 6.21(a). Figure 6.21(b) shows the polarization,
P, that characterizes the ability of the dipole moments of the ferroelectric material
to move in the direction of the electric Ô¨Åeld associated with the voltage, V , at the
capacitor terminals. It presents a hysteresis cycle.
PL
r
VCC
VCC
Pr
(b)
V
P

C
WL
BL
(a)

P
Figure 6.21. a) FRAM cell; b) polarization characteristic
During a write operation, the application of the voltage VCC to the capacitor
terminals enables the storage of the logic state 1, while the logic state 0 is stored
upon the application of the voltage ‚àíVCC.
To carry out a read operation, the BL line is precharged to zero voltage and the WL
line is activated. When the plate line is connected to the voltage VCC, a sense ampliÔ¨Åer
is used to restore and identify the corresponding logic level depending on whether the
variation in the voltage applied to the BL line is increasing or decreasing. Because a

222
Digital Electronics 2
read operation may cause an inversion of the polarization, it must be followed by a
non-periodic refresh operation, unlike the case of the DRAM whose data retention is
continually undermined by current leakage so that a periodic refresh is required.
While being characterized by low power consumption, endurance for read/write
operations up to 100 trillion cycles and signiÔ¨Åcantly reduced space requirement,
FRAM provides access speeds up to a hundred times more faster than a conventional
Ô¨Çash memory.
6.6.2. Content-addressable memory
A content-addressable memory (CAM), also known as associative memory,
compares input data to data that is already stored, to generate a correspondence
indicator and then return the address of matching data.
It is used in applications that require operations related to pattern matching on
data, such as cache controllers, communication networks, image coding and data
compression. The operation principle of RAM and CAM are illustrated in
Figure 6.22, where the data/command select input, CM, is used to choose between
the data cycle and the command cycle.
Data
R/ W
RAM
Data
CAM
Address
CM
(a)
(b)
Address
Figure 6.22. Operation principle of a) a RAM and b) a CAM
The structure of a CAM, as shown in Figure 6.23, generally comprises a network
of storage cells with validity bits, a decoder for line addresses, a comparison register,
a mask register, sense ampliÔ¨Åers for reading, output data register, a correspondence
detector, a priority encoder, an address encoder and a control unit connected to write-
enable (W), chip enable (E) and data/command select (CM) signals. The comparison
registers may be used as a buffer for data to be stored in memory. After the address
decoder selects a WL line, data are written in the corresponding cells through the BL
and BL lines. The validity bits are used to indicate the characteristic (valid, empty,
skip or RAM) of the word stored in cells associated with the corresponding WL line.
For data to be read, the signal in the BL line of the selected cell is converted to a logic
level by the sense ampliÔ¨Åer before being transferred to the output register.
The content of the memory is accessible in a random manner or through
association by comparison. A correspondence search may be carried out when all the

Semiconductor Memory
223
WL lines are deactivated. Data are placed in the comparison registers and are
compared simultaneously to the valid inputs of the memory. Any bit of the
comparison register may be excluded or not from the comparison operation,
depending on the logic level (0 or 1) stored in the mask register. The correspondence
detector generates the status (no correspondence, single correspondence, multiple
correspondences) based on the result of the comparison operation. In the case of the
single correspondence or multiple correspondence, the address with the highest
priority is identiÔ¨Åed by the priority encoder and can then be generated by the address
encoder.
0
A 1
A k1
BL
BL
0
Q :
m1
Q
BL
cells
& Address encoder
Sense amplifier
Network of storage
A
W
CM
WL
ML
BL
BL
Validity bits
Priority encoder
Status
Output register
m1
D
0
D :
BL
1bit cell
XOR
ML
WL
E
Comparison register
Mask register
Address decoder
Control
unit
 Address
Correspondence detector
Figure 6.23. SimpliÔ¨Åed structure of a CAM
6.6.3. Sequential access memory
Sequential access memories are used as a synchronization buffer between
components operating at different speeds or operating irregularly. Otherwise, the
slowest component would determine the operating speeds of all other components
involved in the data transfer.

224
Digital Electronics 2
First in Ô¨Årst out (FIFO) and last in Ô¨Årst out (LIFO) memories are classes of
sequential access memories. The choice between these two structures depends on the
application.
6.6.3.1. FIFO memory
A FIFO memory is organized such that data are read in the same order in which
they were written. This memory can be implemented using shift registers or a RAM.
A 4 √ó 5 register-based FIFO memory is represented in Figure 6.24, where data Di
(i = 0, 1, 2, 3, 4) are applied to the identical sections composed of storage Ô¨Çip-Ô¨Çops.
Each new 5-bit word is transferred from one Ô¨Çip-Ô¨Çop stage to another to be stored
in the last available position. Reading a word causes a shift by one position toward
the output of the remaining words. The clock signal generator successively produces
pulses at the nodes C1, C2, C3 and C4, when a word is written. It also provides
information on the status of each word, specifying whether a Ô¨Çip-Ô¨Çop already contains
valid data (FULL) or whether it is empty (EMPTY ).
4
FULL
C1
C2
C3
C4
D0
D4
Q
D
CLR
WCK
CLEAR
RCK
EMPTY
Q 0
Q
Figure 6.24. Structure of a 4 √ó 5 register-based FIFO memory
The time required for a word to be moved from the input to the output is called the
fall-through time.
NOTE 6.3.‚Äì Comparing the operation of a conventional register and a FIFO register.
Tables 6.12 and 6.13 are drawn up to illustrate the difference between the operation

Semiconductor Memory
225
of a conventional shift register and the operation of a FIFO shift register (or register-
based FIFO memory). The sequence 0110 is applied, one bit at a time, to the serial
input, Di, of each four-bit capacity register (B1, B2, B3 and B4) to be transferred
toward the output Qi.
Input
B1
B2
B3
B4
Output
Di
x
x
x
x
Qi
0
0
x
x
x
‚Üí
1
1
0
x
x
‚Üí
1
1
1
0
x
‚Üí
0
0
1
1
0
‚Üí
Table 6.12. Shift register (x represents a don‚Äôt-care state)
Input
B1
B2
B3
B4
Output
Di
‚àí
‚àí
‚àí
‚àí
Qi
0
0
0
0
0
‚Üí
1
1
1
1
0
‚Üí
1
1
1
1
0
‚Üí
0
0
1
1
0
‚Üí
Table 6.13. FIFO shift register (‚àíindicates an empty position)
In contrast to a register-based FIFO memory, the fall-through time for a RAM-
based FIFO memory is not dependent on the number of words that can be stored.
Figure 6.25 depicts the structure of a RAM-based FIFO memory where the reset signal
is designated by RS and the output enable signal is represented by OE. Write and read
operations are controlled by the clock signals WCLK and RCLK and the enable
signals WEN and REN, respectively. Write addresses are generally produced by the
write pointer and read addresses by the read pointer. Pointers can be implemented like
binary counters. The status signals EF, FF, PAE and PAF (empty, full, almost
empty, almost full) are produced by the Ô¨Çag logic circuit. The statuses EF and FF
cannot be redeÔ¨Åned while the statuses PAE and PAF are programmable using the
offset register, initialized by the load signal LD.
6.6.3.2. LIFO memory
A LIFO memory is based on the following operation principle: the last bit to be
written is the Ô¨Årst bit to be read. The LIFO memory can be used for the storage of data
that are to be retrieved in reverse order.
A LIFO memory is often called a stack. Most microprocessors use a stack to save
status Ô¨Çag bits and the contents of certain registers, in case of interruptions.

226
Digital Electronics 2
Offset register
Q :
m1
Q
REN
RCLK
LD
RS
m1
D
0
D :
WEN
WCLK
OE
 FF
 EF
 PAE
 PAF
Twoport RAM
Input register
Read pointer
output buffer
Reset circuit
Write pointer
Register &
Read control
Write control
Flag logic circuit 
0
Figure 6.25. Structure of a RAM-based FIFO memory
The structure of a LIFO memory is similar to that of a FIFO memory and it may
be based on shift registers or RAM. In principle, data stored in a register-based LIFO
memory can be moved from one position to the other at each clock pulse. However,
for a RAM-based LIFO memory, it is not the data but the access positions that move,
controlled by counters that are called write or read pointers.
6.7. Exercises
EXERCISE 6.1.‚Äì A 64 K √ó 8 memory comprises an EPROM located from the
address 0000 h, and three RAMs located from the addresses 4000 h, 8000 h and
C000 h, respectively. The capacity of each of the elementary memories is 16 K √ó 8.
Draw up an address decoding table for this memory.
Propose a functional block diagram for this memory.
EXERCISE 6.2.‚Äì Implementing a 4 K √ó 8 RAM requires the use of four elementary
1 K √ó 8 memories, as shown in Figure 6.26, where the number of bits used for the
addressing is 16.

Semiconductor Memory
227
(a)
WE
WE
A11
A10
S 1
S 0
A11
A10
S 1
S 0
A12
A13
A14
A15
CS
A15
CS
A[9:0]
WE
CS
DQ[7:0]
A[9:0]
WE
CS
DQ[7:0]
1
2
3
0
RAM 2
RAM 3
A[9:0]
WE
CS
DQ[7:0]
RAM 0
A[9:0]
WE
CS
DQ[7:0]
RAM 1
A[9:0]
2:4 Decoder
A[9:0]
WE
CS
DQ[7:0]
A[9:0]
WE
CS
DQ[7:0]
1
2
3
0
RAM 2
RAM 3
A[9:0]
WE
CS
DQ[7:0]
RAM 0
A[9:0]
WE
CS
DQ[7:0]
RAM 1
A[9:0]
2:4 Decoder
EN
(b)
EN
Figure 6.26. Functional block diagram of the memory with
a) full decoding and b) partial decoding
Determine the range of addresses for each of the elementary memories shown in
Figure 6.26(a).
To reduce the complexity of the address decoding in some applications, a memory
with partial decoding instead of one with full decoding can be adopted.
What is the disadvantage of the partial decoding used for the memory shown in
Figure 6.26(b)?
Can A15 be replaced by A14 in this memory if the range of addresses from 8C00h
to 8CFFh is assigned to input/output devices?
EXERCISE 6.3.‚Äì Consider the implementation of a RAM composed of two elementary
16 K √ó 8 memories and which is based on the map depicted in Figure 6.27, where the
address space is 64 K:
‚Äì Determine the different address decoding functions.
‚Äì Propose a functional block diagram for this memory.
EXERCISE 6.4.‚Äì An EPROM has a capacity of 32 K octets and can store 8-bit words.
a) Determine the number of bits of the address bus and the data bus for this
memory;
b) Give the symbol of this memory;
c) Determine the number of accessible zones, their starting addresses and Ô¨Ånal
addresses for the following cases:

228
Digital Electronics 2
‚Äì A14 = 0;
‚Äì A13 = 1.
16K
4000h
FFFFh
C000h
16K
8000h
0000h
M2
M1
Figure 6.27. Memory map
EXERCISE 6.5.‚Äì A 10 K√ó8 memory is realized using elementary 4 K√ó8 and 2 K√ó8
memories.
Determine the address decoding equations for the different elementary memories
when the memory system to be constituted begins at:
a) 0000 h;
b) 0800 h.
EXERCISE 6.6.‚Äì A microcontroller system with a 16-bit address bus ((A15 ‚àíA0)),
an 8-bit data bus ((D7 ‚àíD0)), a WR signal for writing and a RD signal for reading
should be connected to the following read-only memories:
‚Äì a 16 K √ó 8 memory located from 2000 h;
‚Äì an 8 K √ó 8 memory located from 8000 h;
‚Äì a 16 K √ó 8 memory located just after the 8 K √ó 8 memory.
Determine the address decoding equations for these memories.
EXERCISE 6.7.‚Äì A microcontroller system has a 16-bit address bus (A15A14 ¬∑ ¬∑ ¬∑ A0),
an 8-bit data bus (D7D6 ¬∑ ¬∑ ¬∑ D0), and control signals RD (active-low) for reading and
WR (active on rising edge) for writing.

Semiconductor Memory
229
Implement the address decoding functions for the following read-only memories:
‚Äì M1 is a 8 K √ó 8 memory located in the address space that covers the addresses
0000h ‚Äì 1FFFh;
‚Äì M2 is a 4 K √ó 8 memory located in the address space covering the addresses
2000h ‚Äì 2FFFh;
‚Äì M3 is a 16 K √ó 8 memory located in the address space covering the addresses
3000h ‚Äì 6FFFh.
EXERCISE 6.8.‚Äì A programmable circuit for the control of a play of lights (or
chaser), can be realized as shown in Figure 6.28, using logic gates (XOR, inverter),
two parallel-in parallel-out shift registers, a modulo 16 binary counter, and a 256 √ó 8
EPROM. The four LEDs to be controlled are L0, L1, L2, and L3. CK represents the
clock signal.
EPROM
INIT
A3
A2
A1
A0
CE
OE
A6
A5
A4
0
L3
L2
L1
L0
Q7
Q6
Q5
Q4
Register 2
D5
D4
D3
D2
D1
D0
CLR
Q1
Q0
Q1
Q0
Q7
Q6
Q5
Q4
Q2
Q3
A7
D0
D1
D2
Register 1
CK
LD CLR
Q2 
Q1
Q0
CLR
Q3 Q2 Q1 Q0
Counter
code
Animation
Figure 6.28. Block diagram of a chaser
An animated sequence can have up to sixteen steps and is selected based on a 3-bit
code applied to the inputs of register 1. Each step in the sequence is stored as a word
in the memory. An animation sequence is initiated by an INIT signal pulse and begins
with a reset of register 2 and the counter, followed by the loading of register 1. It ends
after the diode switching-on operations by the reset of the counter:
a) What is the maximum number of animation sequences possible?
b) Representing the EPROM memory addresses as hexadecimal numbers,
determine the content of the memory for the sequence 0 whose animation code is

230
Digital Electronics 2
0 and which is characterized by the successive switching on of diodes from left to
right, right to left and, Ô¨Ånally, the switching on of all diodes;
c) Same question for sequence 1 which switches on the even-numbered diodes and
then odd-numbered diodes, alternately;
d) Same question for sequence 2 that switches on the diodes based on the binary
representation of the numbers from 1 to 15, diode L3 being considered as the most
signiÔ¨Åcant bit and diode L0 as the least signiÔ¨Åcant bit.
6.8. Solutions
SOLUTION 6.1.‚Äì Organization of a 64K √ó 8 memory.
The address space allocated to each elementary memory ranges from 0 to 214 ‚àí1.
We thus have:
‚Äì EPROM:
Starting address:
0000 0000 0000 0000 = 0000h
Final address:
0011 1111 1111 1111 = 3FFFh
‚Äì RAM 1:
Starting address:
0100 0000 0000 0000 = 4000h
Final address:
0111 1111 1111 1111 = 7FFFh
‚Äì RAM 2:
Starting address:
1000 0000 0000 0000 = 8000h
Final address:
1011 1111 1111 1111 = BFFFh
‚Äì RAM 3:
Starting address:
1100 0000 0000 0000 = C000h
Final address:
1111 1111 1111 1111 = FFFFh
Table 6.14 depicts the address decoding table for the memory system. Only the
logic states of the signals CS, A15 and A14 are useful in the determination of the
address decoding functions for each of the elementary functions.
In addition to the condition, CS = 0, the address decoding function takes the form
A15A14 = 00 for the EPROM, A15A14 = 01 for RAM 1, A15A14 = 10 for RAM
2 and A15A14 = 11, for RAM 3. The address decoding function can, therefore, be
implemented using a 2 : 4 decoder with an enable signal.
The functional block diagram for the 64K √ó 8 memory system is shown in
Figure 6.29.

Semiconductor Memory
231
1
A7
A6
A4
A5
A3
A2
A1
A0
1
1
1
1
1
1
1
1
0
0
0
0
0
0
0
0
7FFFh
4000h
1
1
1
1
1
1
1
1
0
0
0
0
0
0
0
0
3FFFh
0000h
A11
A10
A9
A8
1
1
1
0
0
0
0
1
1
1
1
0
0
0
0
1
A12
1
0
1
0
CS
A15
A14
A13
0
1
1
0
1
0
0
0
0
1
0
0
0
0
1
1
1
1
1
1
1
1
0
0
0
0
0
0
0
0
FFFFh
C000h
1
1
1
0
0
0
0
1
1
0
0
1
1
1
1
0
1
1
1
1
1
1
1
1
1
0
0
0
0
0
0
0
0
BFFFh
8000h
1
1
1
0
0
0
0
1
1
0
0
0
1
1
0
0
Table 6.14. Address decoding table. For a color version of this table,
see www.iste.co.uk/ndjountche/electronics2.zip
EPROM
15
CS
A14
WE
S 1
S 0
A[13:0]
OE
CS
WE
CS
DQ[7:0]
DQ[7:0]
DQ[7:0]
A[13:0]
A[13:0]
WE
CS
DQ[7:0]
A[13:0]
WE
CS
DQ[7:0]
1
2
3
0
EN
A[13:0]
2:4 Decoder
OE
RAM
RAM
RAM
A
Figure 6.29. Functional block diagram of the memory
SOLUTION 6.2.‚Äì The analysis of the memory system based on the full decoding
yields, for the elementary memories, the following addresses:
‚Äì RAM 0
A15A14A13A12A11A10A9A8A7A6A5A4A3A2A1A0
0
0
0
0
0
0
x x x x x x x x x x

232
Digital Electronics 2
‚Äì RAM 1
A15A14A13A12A11A10A9A8A7A6A5A4A3A2A1A0
0
0
0
0
0
1
x x x x x x x x x x
‚Äì RAM 2
A15A14A13A12A11A10A9A8A7A6A5A4A3A2A1A0
0
0
0
0
1
0
x x x x x x x x x x
‚Äì RAM 3
A15A14A13A12A11A10A9A8A7A6A5A4A3A2A1A0
0
0
0
0
1
1
x x x x x x x x x x
where the don‚Äôt-care state, x, is assigned to the address bits that are not used for
decoding.
Each elementary memory has a capacity of 1K = 210 and thus requires ten address
lines. For all elementary memories, the address space occupies 4K = 22 √ó210 = 212,
corresponding to 12 address lines.
0
A7
A6
A4
A5
A3
A2
A1
A0
1
1
1
1
1
1
1
1
0
0
0
0
0
0
0
0
07FFh
0400h
1
1
1
1
1
1
1
1
0
0
0
0
0
0
0
0
03FFh
0000h
A11
A10
A9
A8
1
1
1
0
1
0
0
0
0
1
1
0
0
0
0
0
A12
0
0
0
0
CS
A15
A14
A13
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
1
1
1
1
1
1
1
0
0
0
0
0
0
0
0
0FFFh
0C00h
1
1
1
1
1
0
0
1
0
0
0
0
0
0
0
0
1
1
1
1
1
1
1
1
0
0
0
0
0
0
0
0
0BFFh
0800h
0
1
1
1
0
0
0
1
0
0
0
0
0
1
0
0
1
Table 6.15. Address table. For a color version of this table, see
www.iste.co.uk/ndjountche/electronics2.zip
The combination of logic states for the bits A10 and A11 differs from one
elementary memory to another, while the logic state for each of the bits A15, A14,
A13, and A12 is unchanged. The address decoding table for the memory system can
be drawn up as shown in Table 6.15. We thus have:
‚Äì RAM 0:
Starting address:
0000h
Final address:
03FFh

Semiconductor Memory
233
‚Äì RAM 1:
Starting address:
0400h
Final address:
07FFh
‚Äì RAM 2:
Starting address:
0800h
Final address:
0BFFh
‚Äì RAM 3:
Starting address:
0C00h
Final address:
0FFFh
In the case of the memory system based on partial decoding, the addresses take the
following forms:
‚Äì RAM 0
A15A14A13A12A11A10A9A8A7A6A5A4A3A2A1A0
0
x
x
x
0
0
x x x x x x x x x x
‚Äì RAM 1
A15A14A13A12A11A10A9A8A7A6A5A4A3A2A1A0
0
x
x
x
0
1
x x x x x x x x x x
‚Äì RAM 2
A15A14A13A12A11A10A9A8A7A6A5A4A3A2A1A0
0
x
x
x
1
0
x x x x x x x x x x
‚Äì RAM 3
A15A14A13A12A11A10A9A8A7A6A5A4A3A2A1A0
0
x
x
x
1
1
x x x x x x x x x x
where the don‚Äôt-care state, x, is assigned to the address bits that are not used for
decoding.
Allowing only the change in logic state of each of the bits A14, A13 and A12, there
are 23 = 8 possible combinations that can be generated to access the same elementary
memory.
The partial decoding helps reduce the complexity of the address decoding
functions, but more than one range of addresses can access the same elementary
memory. This is not acceptable unless these ranges do not include address already
assigned to other memories or other input/output devices.

234
Digital Electronics 2
No, because RAM 3 can be selected using the address that belongs to the range
from 8C00h to 8CFFh.
SOLUTION 6.3.‚Äì The characteristics of an elementary memory and the address space
translate into:
16 K = 16 √ó 210 = 24 √ó 210 = 214
and
64 K = 64 √ó 210 = 26 √ó 210 = 216
A 16K memory system requires fourteen address lines and for a 64K address
space, 16 address lines are required.
The address decoding table is given in Table 6.16. The condition to select one of
the elementary memories is CS ¬∑ A15 ¬∑ A14, and for the other it is CS ¬∑ A15 ¬∑ A14.
Figure 6.30 depicts the functional block diagram of the memory system.
1
A7
A6
A4
A5
A3
A2
A1
A0
1
1
1
1
1
1
1
1
0
0
0
0
0
0
0
0
BFFFh
8000h
1
1
1
1
1
1
1
1
0
0
0
0
0
0
0
0
3FFFh
0000h
A11
A10
A9
A8
1
1
1
0
0
0
0
1
1
1
1
0
0
0
0
1
A12
1
0
1
0
CS
A15
A14
A13
0
0
1
1
0
0
0
0
0
1
0
0
0
Table 6.16. Address decoding table. For a color version of this table,
see www.iste.co.uk/ndjountche/electronics2.zip
DQ[7:0]
WE
A14
A15
CS
A[13:0]
A[13:0]
WE
CS
WE
CS
A[13:0]
DQ[7:0]
DQ[7:0]
Figure 6.30. Functional block diagram for the memory system
SOLUTION 6.4.‚Äì The EPROM has a capacity of 32K √ó 8.
a) The number of wires of the address bus is 15, because:
32 K = 32 √ó 210 = 25 √ó 210 = 215

Semiconductor Memory
235
b) The symbol for this EPROM is given in Figure 6.31.
Read
CE
OE
A[14:0]
D[7:0]
Selection
Data bus
bus
Address
Figure 6.31. Symbol for the EPROM
c) Number of accessible zones.
‚Äì When A14 = 0
According to the address decoding table shown in Table 6.17, 0000h to 3FFFh
constitutes an accessible zone.
End
A14
A13
A12
1
1
0
0
0
A11
1
0
A10
1
0
A9
A7
A8
A6
A0
. . .
1
1
1
1
1
0
0
0
0
0
. . .
. . .
03FFh
0000h
Start
Table 6.17. Address decoding table (A14 = 0)
‚Äì When A13 = 1
As given in the address table shown in Table 6.18, the split bit is A13 and there is
a single unÔ¨Åxed bit, A14.
. . .
A14
A13
A12
1
0
Zone 0
Zone 1
1
1
1
0
1
1
1
0
A11
1
0
1
0
A10
1
0
1
0
A9
A7
A8
A6
A0
. . .
2000h
3FFFh
6000h
7FFFh
1
1
1
1
1
0
0
0
0
0
. . .
. . .
1
1
1
1
1
0
0
0
0
0
. . .
Table 6.18. Address decoding table (A13 = 1)
The number of zones, therefore, is 21 = 2.
The accessible zones depend on the logic state of A14:

236
Digital Electronics 2
A14 = 0, zone 0:
2000h ‚Äì 3FFFh
A14 = 1, zone 1:
6000h ‚Äì 7FFFh.
SOLUTION 6.5.‚Äì Organization of a 10 K √ó 8 memory system.
The capacity of the memory system is 10 K √ó 8, and we have:
10 K = 10 √ó 210 = 5 √ó 211
a) Starting address 0000h.
The Ô¨Ånal address is 0000h + 5 √ó 211 ‚àí1.
The number, n, of address bits required, may be determined using the equation:
2n‚àí1 < 5 √ó 211 ‚àí1 < 2n
Thus:
n = 14
The address bits are: A13A12 ¬∑ ¬∑ ¬∑ A0.
Two 4K elementary memories and one 2K elementary memory are required:
‚Äì M11 4 K memory: 0000h‚Äì0FFFh;
‚Äì M12 4 K memory: 1000h‚Äì1FFFh;
‚Äì M13 2 K memory: 2000h‚Äì27FFh.
To obtain simple address decoding functions in each case, the starting address is
a power of 2 and is divisible by the capacity of the elementary memory (especially,
4, 096 and 2, 048).
0000h
. . .
. . .
. . .
. . .
. . .
. . .
CS
A13
A12
A11
0
0
0
1
0
0
0
1
1
0
1
0
0
0
0
1
0
0
0
1
0
A10
1
0
1
0
1
0
M11
M12
M13
A9
A8
A6
A7
A5
A0
1
1
1
1
1
1
0
0
0
0
0
0
27FFh
2000h
1
1
1
1
1
1
0
0
0
0
0
0
1FFFh
1000h
1
1
1
1
1
1
0
0
0
0
0
0
0FFFh
. . .
Table 6.19. Address decoding table. For a color version of this table,
see www.iste.co.uk/ndjountche/electronics2.zip

Semiconductor Memory
237
Table 6.19 gives the address decoding table that can be used to obtain the following
logic equations:
CS11 = CS ¬∑ A13 ¬∑ A12
[6.12]
CS12 = CS ¬∑ A13 ¬∑ A12
[6.13]
and:
CS23 = CS ¬∑ A13 ¬∑ A12 ¬∑ A11
[6.14]
b) Starting address 0800h.
The Ô¨Ånal address is given by:
0800h + 5 √ó 211 ‚àí1 = 211 + 5 √ó 211 ‚àí1 = 6 √ó 211 ‚àí1
The required number, n, of address bits, must verify the relationship:
2n‚àí1 < 6 √ó 211 ‚àí1 < 2n
Thus:
n = 14
The address bits are A13A12 ¬∑ ¬∑ ¬∑ A0.
Two elementary 4K memories and one elementary 2K memory are needed:
‚Äì M21 2K memory: 0800h‚Äì0FFFh ;
‚Äì M22 4K memory: 1000h‚Äì1FFFh ;
‚Äì M23 4K memory: 2000h‚Äì2FFFh.
Table 6.20 gives the address decoding table. It can be used to obtain the following
address decoding equations:
CS21 = CS ¬∑ A13 ¬∑ A12 ¬∑ A11
[6.15]
CS22 = CS ¬∑ A13 ¬∑ A12
[6.16]

238
Digital Electronics 2
0
. . .
. . .
. . .
. . .
. . .
. . .
A9
A8
A6
A7
A5
A0
1
1
1
1
1
1
0
0
0
0
0
0
2FFFh
2000h
1
1
1
1
1
1
0
0
0
0
0
0
1FFFh
1000h
1
1
1
1
1
1
0
0
0
0
0
0
0FFFh
0800h
CS
A13
A12
A11
0
0
1
1
0
0
0
1
1
0
1
0
0
0
0
1
0
0
1
1
0
M21
M22
M23
A10
1
0
1
0
1
. . .
Table 6.20. Address decoding table. For a color version of this table,
see www.iste.co.uk/ndjountche/electronics2.zip
and:
CS23 = CS ¬∑ A13 ¬∑ A12
[6.17]
SOLUTION 6.6.‚Äì For the different elementary memories, we have:
16 K = 16 √ó 210 = 24 √ó 210 = 214, or 4000h (in hexadecimal)
8 K = 8 √ó 210 = 23 √ó 210 = 213, or 2000h (in hexadecimal)
4 K = 4 √ó 210 = 22 √ó 210 = 212, or 1000h (in hexadecimal)
Because the last address of a memory is equal to its word capacity minus one, we
arrive at:
‚Äì M1 16 K memory: 2000h + 4000h ‚àí1 = 5FFFh;
‚Äì M2 8 K memory: 8000h + 2000h ‚àí1 = 9FFFh;
‚Äì M3 4 K memory: it is implanted just after the 8K memory. The starting address
is, therefore, A000h and the last address is A000h + 1000h ‚àí1 = AFFFh.
We assume that RD is connected to the OE inputs of the memories M1, M2 and
M3.
The RD and WR signals are mutually exclusive. We do not need to consider them
in the address decoding equations.

Semiconductor Memory
239
0
. . .
. . .
. . .
. . .
. . .
. . .
M1
M2
M3
A9
A8
A0
1
1
1
0
0
0
AFFFh
A000h
1
1
1
0
0
0
9FFFh
8000h
1
1
1
5FFFh
2000h
0
0
0
A10
1
0
1
0
1
0
A11
1
0
1
0
1
0
A12
0
0
1
0
1
0
13
A
1
1
0
0
0
1
A15
A14
1
0
1
0
1
0
1
0
0
1
0
. . .
Table 6.21. Address decoding table. For a color version of this table,
see www.iste.co.uk/ndjountche/electronics2.zip
The equations for memory selection can be determined using the address decoding
table constructed as shown in Table 6.21. They are given by:
CSM1 = A15 ¬∑ A14 ¬∑ A13 + A15 ¬∑ A14 ¬∑ A13
[6.18]
CSM2 = A15 ¬∑ A14 ¬∑ A13
[6.19]
and:
CSM3 = A15 ¬∑ A14 ¬∑ A13 ¬∑ A12
[6.20]
For the memory M1, the logic combination of the starting address and that of the
Ô¨Ånal address must be taken into account in the address decoding equation as they are
different.
SOLUTION 6.7.‚Äì Organization of 28K √ó 8 ROM.
Once programmed during manufacture, a non-volatile memory can only be read.
The microcontroller has an address bus of sixteen bits (A15A14 ¬∑ ¬∑ ¬∑ A0, and the
RD signal of the microcontroller is assumed to be connected to the OE1, OE2, and
OE3 inputs of the different elementary memories.
The number, n, of bits that are required to address a memory block or the space
containing a memory block, is given by the following equation:
2n‚àí1 < address-space capacity ‚â§2n
[6.21]

240
Digital Electronics 2
‚Äì For the memory M1, there is an address space of 8K and:
n = log(8 √ó 210)/ log(2) = 13
The highest address is 8 √ó 210 ‚àí1 = 8 191 or 1FFFh (in hexadecimal).
‚Äì For the memory M2, the address space is 12 K (or 8 K + 4 K) and:
n = log(12 √ó 210)/ log(2) = 13, 58 ‚âÉ14
The highest address is 12 √ó 210 ‚àí1 = 12 287 or 2FFFh (in hexadecimal).
‚Äì For the memory M2, the address space is 28 K (or 8 K + 4 K + 16 K) and:
n = log(28 √ó 210)/ log(2) = 14, 80 ‚âÉ15
the highest address is 28 √ó 210 ‚àí1 = 28 671 or 6FFFh (in hexadecimal).
To determine the logic equations for memory selection, the address decoding table
can be drawn up as shown in Table 6.22. The logic combinations for the address bits,
on which the address decoding functions are dependent, are identical for the memories
M1 and M2 but are different for M3. The selection of M3 is also determined by the
intermediate combinations that exists between the logic combinations associated with
the starting address and the Ô¨Ånal address. The address decoding equations are, thus,
written as follows:
CSM1 = A15 ¬∑ A14 ¬∑ A13
[6.22]
CSM2 = A15 ¬∑ A14 ¬∑ A13 ¬∑ A12
[6.23]
and:
CSM3 = A15 ¬∑

A14 ¬∑ A13 ¬∑ A12 + A14

A13 ¬∑ A12 + A13 ¬∑ A12 + ¬∑A13 ¬∑ A12
	
[6.24]
The diagram showing the wiring of the memories to the microprocessor is given in
Figure 6.32. The RD signal of the microcontroller is applied to the OE input of each
elementary memory.
SOLUTION 6.8.‚Äì Light set (chaser).
An INIT signal pulse resets the registers and counter, and the content of the
memory at the address 00h determines the initial conditions. The start of the count
cycle brings about the loading of the animation sequence code. For each animation
sequence, the bits from A6 to A4 remain unchanged while only the bits from A3 to

Semiconductor Memory
241
A0 can be modiÔ¨Åed on each rising edge of the clock signal. The counter is reset at the
end of one animation sequence and the logic state for the bits A3, A2 and A0
becomes 0:
0
. . .
. . .
. . .
. . .
. . .
. . .
M1
M2
M3
1    0    0
1    0    1
1    1    0
0    1    1
0
0
0
0
A9
A8
A0
1
1
1
0
0
0
6FFFh
3000h
1
1
1
0
0
0
2FFFh
2000h
1
1
1
1FFFh
0000h
0
0
0
A10
1
0
1
0
1
0
A11
1
0
1
0
1
0
A12
0
1
0
0
1
0
A13
1
1
1
1
0
0
A15
A14
0
1
0
0
0
0
0
0
0
0
0
. . .
Table 6.22. Address decoding table. For a color version of this table,
see www.iste.co.uk/ndjountche/electronics2.zip
3:8 Decoder
OE
CE
RD
Microcontroller
M3
A14:A0
D7:D0
A12:A0
OE
CE
OE
CE
M1
D7:D0
Y0
A15:A0
D7:D0
A15
A14
A13
A12
Y1
Y2
Y3
Y4
Y5
Y6
Y7
EN
X2
X1
X0
1
M2
A13:A0
D7:D0
Figure 6.32. Block diagram showing the wiring of the
memories to the microcontroller
a) The selection of the animation code is done based on a 3-bit code. There are,
therefore, 23 = 8 possible animation sequences.
The address for the EPROM changes at each rising edge of the clock signal.
b) The memory content for the sequence code 0 is given in Table 6.23.

242
Digital Electronics 2
c) Table 6.24 gives the memory content for the sequence code 1.
d) The memory content for the sequence code 2 is given in Table 6.25.
Address
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
1
0
0
0
0
Load code
L0 On
L1 On
L2 On
L3 On
L2 On
L1 On
1
0
0
0
0
1
L0, L1, L2, and L3 On
0
0
1
0
0
0
Counter reset
0
0
0
0
0
0
L0 On
0
1
0
0
0
0
1
0
1
0
0
0
0
0
0
1
0
1
0
1
00h
01h
05h
06h
02h
03h
04h
08h
09h
07h
Q5
Q4
Q3
Q2
Q0
Q1
Q6
Q7
Table 6.23. Memory content (sequence code 0)
17h
16h
12h
13h
14h
11h
0
1
0
0
0
0
0
0
0
0
0
1
1
0
0
0
0
0
1
1
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
0
1
0
0
0
L0 and L2 On
L1 and L3 On
L0 and L2 On
L1 and L3 On
L0 and L2 On
L1 and L3 On
Counter reset
Load code
0
1
0
1
0
0
1
0
0
1
1
0
1
0
0
0
Q5
Q4
Q3
Q2
Q0
Q1
Q6
Address
Q7
00h
15h
Table 6.24. Memory content (sequence code 1)

Semiconductor Memory
243
0
28h
29h
2Ah
21h
25h
26h
22h
24h
2Bh
2Fh
2Dh
2Eh
2Ch
23h
1
0
0
0
0
0
Load code
1
0
0
0
0
1
1
0
0
0
00h
Q5
Q4
Q3
Q2
Q0
Q1
Q6
Q7
Address
L2, L1, and L0 On
0
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
L3 On
L3 and L1 On
0
0
0
1
1
1
1
L3 and L0 On
0
1
0
0
0
0
0
0
0
0
0
0
1
0
1
0
0
0
0
0
0
0
0
0
0
0
0
0
1
L0 On
L2 On
L2 and L0 On
L2 and L1 On
1
1
0
0
1
0
0
0
0
0
0
L1 On
0
1
0
0
0
1
L3, L1, and L0 On
0
1
L0, L1, L2, and L3 On
1
0
0
0
0
1
0
0
1
0
0
0
Counter reset
1
0
1
0
20h
0
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
L3 and L2 On
L3, L2, and L0 On
L3, L2, and L1 On
1
1
1
1
1
1
0
1
0
0
0
1
L1 and L0 On
0
27h
Table 6.25. Memory content (sequence code 2)


7
Programmable Logic Circuits
7.1. General overview
Given
the
increasing
density
and
size
of
logical
and
digital
circuits,
implementation based on programmable logic circuits seems the most appropriate
and economical way of meeting the needs of different applications with a low
production volume, rather than an approach that uses discrete components.
A read-only memory (ROM) is composed of an address decoder and a network of
components connected through switches for the storage of binary words. Once data is
stored in a ROM, it can be read whenever but can no longer be modiÔ¨Åed under normal
operating conditions.
One solution to implement logic functions is using a ROM where the output logic
states given in the truth table can be stored. Thus, whenever the input bits are applied
to the address lines, the logic state of the corresponding line is transferred to the output
of the ROM. A programmable read-only memory (PROM) is implemented by adding
fuses or antifuses in series with the switches of a ROM. It can be programmed once
after manufacture, in an irreversible manner, using a burner.
In addition to the PROM circuit, there are other architectures for programmable
circuits:
programmable array logic (PAL), programmable logic array (PLA),
complex programmable logic device (CPLD) and Ô¨Åeld programmable gate array
(FPGA). However, the generic denomination, programmable logic device (PLD), is
generally only used for architectures introduced to implement two-level circuits such
as PAL, PLA or other versions of similar circuits.
Digital Electronics 2: Sequential and Arithmetic Logic Circuits, First Edition. Tertulien Ndjountche. 
¬© ISTE Ltd 2016. Published by ISTE Ltd and John Wiley & Sons, Inc. 

246
Digital Electronics 2
7.2. Programmable logic device
In general, a n √ó m programmable circuit has n inputs and m outputs. To
implement a sum of p products, p AND gates with 2n inputs and m OR gates with p
inputs are required.
A programmable circuit may be represented completely, as shown in Figure 7.1,
or in a simpliÔ¨Åed form, which is more appropriate when a large number of logic gates
are involved, as shown in Figure 7.2.
2
E 1
E
S 3
S 2
S 1
Figure 7.1. Complete representation of a 2 √ó 3 programmable circuit
2
S 2
S 1
E 1
E
S 3
Figure 7.2. SimpliÔ¨Åed representation of a 2 √ó 3 programmable circuit

Programmable Logic Circuits
247
A PROM consists of a bank of prewired AND gates, which carry out the role of
the decoder, and a bank of programmable OR gates.
A PAL comprises a bank of programmable AND gates and a bank of prewired OR
gates.
A PLA
is made up of a bank of programmable AND gates and a bank of
programmable OR gates.
The following functions are to be implemented using a PROM, PAL or PLA:
X = A + B ¬∑ C + B ¬∑ C
[7.1]
Y = A + B + C
[7.2]
The logic equations for X and Y , respectively, can be expressed in the following
forms:
X = A + B ¬∑ C + B ¬∑ C
= A ¬∑ B ¬∑ C + A ¬∑ B ¬∑ C + A ¬∑ B ¬∑ C + A ¬∑ B ¬∑ C + A ¬∑ B ¬∑ C + A ¬∑ B ¬∑ C
[7.3]
and:
Y = A + B + C
= A ¬∑ B ¬∑ C + A ¬∑ B ¬∑ C + A ¬∑ B ¬∑ C + A ¬∑ B ¬∑ C
+ A ¬∑ B ¬∑ C + +A ¬∑ B ¬∑ C + A ¬∑ B ¬∑ C
[7.4]
‚Äì PROM-based implementation:
The initial PROM is represented in Figure 7.3. To implement the logic functions
X and Y , the circuit must be conÔ¨Ågured as shown in Figure 7.4.
NOTE 7.1.‚Äì The size of a ROM with n inputs and m outputs is given by 2n √ó m.
EXAMPLE 7.1.‚Äì A memory with three inputs and two outputs has a capacity of
23 √ó 2 = 16 bits, or two octets.
A memory with eight inputs and four outputs has a capacity of 28 √ó 4 = 1 024
bits or 1 kbit (kilobit).
‚Äì PAL-based implementation:
Figure 7.5 depicts the initial PAL while the circuit for a PAL programmed to
implement the functions X and Y is given in Figure 7.6.

248
Digital Electronics 2
Y
B
C
A
X
Figure 7.3. Initial PROM (√ó represents a programmable
connection and ‚Ä¢ symbolizes a Ô¨Åxed connection)
‚Äì PLA-based implementation:
By blowing some of the fuses in the initial PLA, shown in Figure 7.7, we can
obtain the programmed circuit of Figure 7.8.
Even though they offer less Ô¨Çexibility, PALs are adopted in practice because
they are faster and less expensive. The different versions of the PAL supplied by
manufacturers differ in the conÔ¨Åguration of output pins:
‚Äì PAL with programmable output polarity (high or low). An example is given in
Figure 7.9. The outputs can function as inputs or intermediate variables and can be fed
back to the inputs;
‚Äì PAL with outputs stored on D Ô¨Çip-Ô¨Çops. Figure 7.10 shows the structure for this
type of PAL, where the Ô¨Çip-Ô¨Çops are synchronized with the clock signal CK and the
OE (output enable) signal can be used to deactivate the output. D Ô¨Çip-Ô¨Çops may be
combined to implement state registers in synchronous Ô¨Ånite-state machines;
‚Äì PAL with versatile outputs. This type of PAL consists of cells similar to the one
shown in Figure 7.11. The inputs are connected to a programmable bank of AND
gates that are connected to an OR gate. A D Ô¨Çip-Ô¨Çop is used for the storage and

Programmable Logic Circuits
249
synchronization of data and the output conÔ¨Åguration is determined by the multiplexer
selection bits. Each cell can be conÔ¨Ågured such that the output is determined by the
AND/OR bank (combinational logic) or by the Ô¨Çip-Ô¨Çop (sequential logic), with either
active-high or active-low signal. Based on a cell conÔ¨Åguration, the feedback signal
can be determined by the Ô¨Çip-Ô¨Çop or any signal applied to the output pin (which
is considered as an input/output node) and it may be active-high or active low. The
different conÔ¨Ågurations for the feedback and output signals are given in Table 7.1.
Y
B
C
A
X
Figure 7.4. Programmed PROM (√ó represents a programmable
connection and ‚Ä¢ symbolizes a Ô¨Åxed connection)
Fuses
ConÔ¨Åguration
S1
S0
Feedback
Output
Polarity
0
0
Flip-Ô¨Çop
Flip-Ô¨Çop
Active-low
0
1
Flip-Ô¨Çop
Flip-Ô¨Çop
Active-high
1
0
Input/output
AND/OR bank
Active-low
1
1
Input/output
AND/OR bank
Active-high
Table 7.1. ConÔ¨Ågurations for the feedback and output signals
(0: fuse intact; 1: fuse blown)

250
Digital Electronics 2
Y
B
C
A
X
Figure 7.5. Initial PAL
Y
B
C
A
X
Figure 7.6. Programmed PAL

Programmable Logic Circuits
251
Y
B
C
A
X
Figure 7.7. Initial PLA
Y
B
C
A
X
Figure 7.8. Programmed PLA

252
Digital Electronics 2
1920
0
4
8
12
16
20
24
28
32
36
39
0
320
2520
2240
Figure 7.9. Structure of an integrated PAL (PAL20P8)
Generally speaking, the number of inputs of a PLD varies between 16 and 32 and
the number of outputs between 8 and 16. A PLD can have a bank of programmable
AND gates, a bank of prewired OR gates, D Ô¨Çip-Ô¨Çops triggered by a single clock and
a fuse to protect against read operations.

Programmable Logic Circuits
253
1536
0
4
8
12
16
20
24
28
31
Q
Q
D
Q
Q
D
Q
Q
D
Q
Q
D
CK
OE
0
256
2016
1792
Figure 7.10. Structure of an integrated PAL (PAL16R8)
PLDs have fused-based interconnects (bipolar technology) or antifuse-based
interconnects (complementary metal-oxide semiconductor [CMOS] technology) as
shown in Figure 7.12. A fuse-based interconnect, implemented by combining a metal
or polysilicon with a diode, is initially closed, while an antifuse-based interconnect,
built around a MOS capacitor, is initially open. PLD circuits can only be
programmed once, through an irreversible blowing of fuses or antifuses. This can
prove a hindrance if we wish to correct any errors that could have occurred during the
programming. Other structures, such as erasable PLD (EPLD) and electrically

254
Digital Electronics 2
erasable PLD (EEPLD), have been proposed to offset this concern. EPLDs can be
erased upon exposure to UV rays while EEPLD circuits can be erased electrically. It
must be noted that the name generic array logic (GAL) has been trademarked by the
company Lattice Semiconductor and is given to PALs which can be electrically
erased. EPLDs and EEPLDs are based on erasable and reprogrammable memory
technology and make use of the advantages of CMOS technology.
SS
S 1
D
10
11
00
01
0
1
S 0
PR
CLR
AR
CK
PR
CLR
Q
Q
Figure 7.11. Structure of a PLD cell (PAL22V10)
(b)
(a)
Figure 7.12. Programmable a) fuse-based and
b) antifuse-based interconnects
The major problem with PLDs is related to the difÔ¨Åculty of sharing the logic
product terms between different cells.

Programmable Logic Circuits
255
7.3. Applications
When a memory circuit (or a programmable circuit) is used to implement
combinational logic functions:
‚Äì the inputs and outputs of the functions to be implemented must be identiÔ¨Åed;
‚Äì the inputs must be connected to the address bus bits;
‚Äì the memory outputs must be considered as the outputs of the function;
‚Äì the content of the memory must be deÔ¨Åned and programmed.
7.3.1. Implementation of logic functions
Implement the following functions using a PAL:
F(A, B, C, D) =

m(0, 1, 5, 6, 9, 12, 14)
[7.5]
G(A, B, C, D) =

m(0, 1, 5, 9, 10, 14, 15)
[7.6]
H(A, B, C, D) =

m(0, 1, 2, 5, 6, 9, 10)
[7.7]
Figures 7.13‚Äì7.15 depict the Karnaugh maps that can be used to obtain the minimal
forms of the logic equations for the functions F, G and H as follows:
F(A, B, C, D) = A ¬∑ B ¬∑ C + A ¬∑ C ¬∑ D + B ¬∑ C ¬∑ D + A ¬∑ B ¬∑ D + B ¬∑ C ¬∑ D
[7.8]
G(A, B, C, D) = A ¬∑ B ¬∑ C + A ¬∑ C ¬∑ D + B ¬∑ C ¬∑ D + A ¬∑ B ¬∑ C + A ¬∑ C ¬∑ D
[7.9]
and:
G(A, B, C, D) = A ¬∑ B ¬∑ C + A ¬∑ C ¬∑ D + B ¬∑ C ¬∑ D + A ¬∑ C ¬∑ D + B ¬∑ C ¬∑ D
[7.10]
For the implementation of the functions F, G and H using a PAL with six inputs
and four outputs, we assume that:
T = A ¬∑ B ¬∑ C + A ¬∑ C ¬∑ D + B ¬∑ C ¬∑ D
[7.11]

256
Digital Electronics 2
D
01
11
10
0
0
1
1
0
0
0
0
0
1
1
0
1
1
0
1
AB
CD
C
00
01
11
10
B
A
00
Figure 7.13. Output F. For a color version of this Ô¨Ågure, see
www.iste.co.uk/ndjountche/electronics2.zip
D
01
11
10
0
0
1
0
0
0
1
0
0
0
1
1
1
1
0
1
AB
CD
C
00
01
11
10
B
A
00
Figure 7.14. Output G. For a color version of this Ô¨Ågure, see
www.iste.co.uk/ndjountche/electronics2.zip
This can then lead to:
F(A, B, C, D) = T + A ¬∑ B ¬∑ D + B ¬∑ C ¬∑ D
[7.12]
G(A, B, C, D) = T + A ¬∑ B ¬∑ C + A ¬∑ C ¬∑ D
[7.13]

Programmable Logic Circuits
257
10
0
0
1
0
0
0
0
0
1
1
1
1
1
1
0
1
AB
CD
C
00
01
11
10
B
A
D
00
01
11
Figure 7.15. Output H . For a color version of this Ô¨Ågure, see
www.iste.co.uk/ndjountche/electronics2.zip
and:
G(A, B, C, D) = T + A ¬∑ C ¬∑ D + B ¬∑ C ¬∑ D
[7.14]
The PAL thus obtained is represented in Figure 7.16.
7.3.2. Two-bit adder
Use a PLA circuit to implement an adder for two 2-bit numbers, A = A1A0 and
B = B1B0, that performs the following operation:
A1
A0
+
B1
B0
C
S1
S0
where the sum is represented by S = S1S0 and C designates the carry.

258
Digital Electronics 2
T
B
A
C
D
F
G
H
Figure 7.16. Programmed PAL
The truth table of the 2-bit adder may be drawn up as shown in Table 7.2. The
Karnaugh maps shown in Figures 7.17‚Äì7.19 help in obtaining the minimal forms for
the output logic expressions. We thus have:
C = A1 ¬∑ B1 + A1 ¬∑ A0 ¬∑ B0 + A0 ¬∑ B1 ¬∑ B0
[7.15]
S1 = A1 ¬∑ B1 ¬∑ B0 + A1 ¬∑ A0 ¬∑ B1 + A1 ¬∑ A0 ¬∑ B1+
A1 ¬∑ B1 ¬∑ B0 + A1 ¬∑ A0 ¬∑ B1 ¬∑ B0 + A1 ¬∑ A0 ¬∑ B1 ¬∑ B0
[7.16]

Programmable Logic Circuits
259
and:
S0 = A0 ¬∑ B0 + A0 ¬∑ B0
[7.17]
Inputs
Outputs
A1
A0
B1
B0
C
S1
S0
0
0
0
0
0
0
0
0
0
0
1
0
0
1
0
0
1
0
0
1
0
0
0
1
1
0
1
1
0
1
0
0
0
0
1
0
1
0
1
0
1
0
0
1
1
0
0
1
1
0
1
1
1
1
0
0
1
0
0
0
0
1
0
1
0
0
1
0
1
1
1
0
1
0
1
0
0
1
0
1
1
1
0
1
1
1
0
0
0
1
1
1
1
0
1
1
0
0
1
1
1
0
1
0
1
1
1
1
1
1
1
0
Table 7.2. Truth table
The implementation of the 2-bit adder based on the PLA is illustrated in
Figure 7.21. It is characterized by a number of products terms that is equal to 11.
One approach that can be used to reduce the number of different product terms and,
consequently, reduce the size (or number of columns) of the PLA, consists of using
decoders. In this case, the output logic expressions must be decomposed as follows:
C = (A1 + B1)(A1 + B1)(A1 + B1)+
(A1 + B1)(A0 + B0)(A0 + B0)(A0 + B0)
[7.18]
S1 = (A1 + B1)(A1 + B1)(A0 + B0)(A0 + B0)(A0 + B0)+
(A1 + B1)(A1 + B1)(A0 + B0) [7.19]
and:
S0 = (A0 + B0)(A0 + B0)
[7.20]

260
Digital Electronics 2
Using a 2 : 4 decoder, as shown in Figure 7.20 ,which can generate maxterms, the
2-bit adder can be implemented as shown in Figure 7.22(a). The number of columns
in the PLA has been reduced to 5.
1
01
11
10
A 1
A 1
A 0
A 0
B1
B0
B0
B1
0
0
0
0
0
1
0
0
1
1
0
1
0
0
00
01
11
10
1
00
Figure 7.17. Output C. For a color version of this Ô¨Ågure, see
www.iste.co.uk/ndjountche/electronics2.zip
0
01
11
10
A 1
A 1
A 0
A 0
B1
B0
B0
B1
0
1
0
1
1
1
1
1
0
0
0
0
1
1
00
01
11
10
0
00
Figure 7.18. Output S1. For a color version of this Ô¨Ågure, see
www.iste.co.uk/ndjountche/electronics2.zip
Another conÔ¨Åguration used to implement the 2-bit adder can be obtained by
decomposing the logical complement of the carry, C, instead of the carry, C, itself.

Programmable Logic Circuits
261
This is useful in cases where the PLA output has programmable inverters, or in
applications where the complement of the carry, C, is of interest. The logic
expression for C is given by:
C = A1 ¬∑ B1 + A1 ¬∑ A0 ¬∑ B0 + A0 ¬∑ B1 ¬∑ B0
[7.21]
= A1 ¬∑ A0 + A0 ¬∑ B1 + A1 ¬∑ B0 + B1 ¬∑ B0 + A1 ¬∑ B1
[7.22]
1
01
11
10
A 1
A 1
A 0
A 0
B1
B0
B0
B1
1
0
0
1
1
0
0
1
1
0
0
0
00
01
11
10
0
1
1
00
Figure 7.19. Output S0. For a color version of this Ô¨Ågure, see
www.iste.co.uk/ndjountche/electronics2.zip
Decoder
Y2
Y1
Y3
0
Y
X 0
Y3
Y2
Y1
0
Y
X 0
X1
X1
Figure 7.20. Logic circuit of the 2 : 4 decoder

262
Digital Electronics 2
1
A1
A0
B1
B0
C
S 0
S
Figure 7.21. Implementation of the 2-bit adder with a PLA
Decoder
A1
B1
B0
A1
B1
B0
(a)
C
S 0
S1
A 0
(b)
C
S 0
S1
A 0
Decoder
Decoder
Decoder
Figure 7.22. Implementation of the two-bit adder
with a PLA and 2 : 4 decoders
Because:
A1 ¬∑ A0 = A1 ¬∑ A0 ¬∑ B1 + A1 ¬∑ A0 ¬∑ B1
[7.23]
A0 ¬∑ B1 = A1 ¬∑ A0 ¬∑ B1 + A1 ¬∑ A0 ¬∑ B1
[7.24]
A1 ¬∑ B0 = A1 ¬∑ B1 ¬∑ B0 + A1 ¬∑ B1 ¬∑ B0
[7.25]
B1 ¬∑ B0 = A1 ¬∑ B1 ¬∑ B0 + A1 ¬∑ B1 ¬∑ B0
[7.26]

Programmable Logic Circuits
263
it follows that:
C = (A1 ¬∑ B1 + A1 ¬∑ B1)(A0 + B0) + A1 ¬∑ B1(1 + A0 + B0)
[7.27]
= (A1 + B1)(A1 + B1)(A0 + B0) + (A1 + B1)(A1 + B1)(A1 + B1)
[7.28]
Figure 7.22(b) shows the resulting logic circuit. The PLA does not require more
than four columns.
By allowing for the sharing of the product terms, the PLA is more Ô¨Çexible but
slower than the PAL, which is characterized by a large number of Ô¨Åxed interconnects
with simpler structures.
7.3.3. Binary-to-BCD and BCD-to-binary converters
Binary-to-BCD and BCD-to-binary converters can be implemented using a ROM.
The conversion algorithm is based on shift, addition and subtraction operations and
is executed assuming that the number to be converted is initially stored in a register.
It can be used to deduce the truth table that establishes the correspondence between
the codes and that is stored in a memory of suitable size for the implementation of
the converter. By cascading converters for smaller word-length codes, it is possible to
increase the size of the codes that can be converted.
7.4. Programmable logic circuits (CPLD and FPGA)
A CPLD has some programmable functional blocks (AND/OR network and
macrocells) whose inputs and outputs can be connected by a reconÔ¨Ågurable
interconnect network, as well as input/output blocks for interfacing with external
components.
A FPGA is based on a matrix network comprising several programmable
functional blocks (conÔ¨Ågurable logic blocks) which are interconnected using
reconÔ¨Ågurable interconnects. This network is surrounded by input/output blocks.
The number of logic blocks (or macrocells), which is only of the order of a few
hundreds for a CPLD, can generally go up to 1, 000, 000 for an FPGA. A macrocell
may be based on an AND/OR bank (CPLD) or on a look-up table (LUT) (CPLD and
FPGA). The ratio of Ô¨Çip-Ô¨Çops to logic resources is higher in an FPGA than in a CPLD.
A CPLD is conÔ¨Ågured from an EEPROM and is, thus, considered non-volatile. On
the other hand, the FPGA conÔ¨Åguration, determined by a RAM, is considered volatile
and must be updated every time it is powered on.

264
Digital Electronics 2
A CPLD is ideal for control applications as it offers very predictable timing
characteristics, while an FPGA circuit, having a large number of functionalities and
registers, would generally seem appropriate for datapath implementations.
7.4.1. Principle and technology
The architecture of a CPLD or FPGA is based on a certain number of logic blocks
that are connected by a network of programmable interconnects.
For some CPLDs, each logic block is made up of an AND bank that generates
product terms, a product term allocator and macrocells. But for other CPLDs and
FPGAs, each logic block comprises a look-up table, a carry propagation and checking
chain and macrocells, as shown in Figure 7.23. In the latter case, the RAM-based logic
block is conÔ¨Ågurable.
Carry
Q
D
Combinational
output
output
Sequential
Carryout
Carryin
LUT
Configuration
Clock
signal
bits
Inputs
circuit
and control
propagation
Figure 7.23. Diagram showing the operation principle
of a conÔ¨Ågurable logic block
Consider the logic function, F, that can be written as follows:
F(A, B, C) = A ¬∑ B ¬∑ C + A ¬∑ B + A ¬∑ C + B ¬∑ C
[7.29]
= A ‚äïB ¬∑ C + B ¬∑ C
[7.30]
The implementation of this function using a 3-input LUT is illustrated in
Figure 7.24. The LUT has eight storage cells, each of which corresponds to the
output value found in each row of the truth table for the function F. Its output F
takes the logic state of one of the storage cells depending on the combination of the
three variables A, B and C, applied to the select inputs.
Figure 7.25 depicts the logic circuit of a 3-input LUT. ReconÔ¨Ågurable circuits, in
general, are implemented using LUTs with three to eight inputs and one output. A

Programmable Logic Circuits
265
LUT allows for the implementation of any logic function which has a number of input
variables that is less than or equal to the number of its inputs.
= F(1,1,1)
(b)
C
B
A
F(A,B,C)
1
1
1
0
1
0
0
1
= F(0,0,0)
= F(0,0,1)
= F(0,1,0)
= F(0,1,1)
= F(1,0,0)
= F(1,0,1)
(c)
0
1
0
1
0
1
0
1
0
1
0
1
0
1
C
B
A
F
1
1
1
0
1
0
0
1
(a)
F
A
B
C
1
0 0
0
0 1
1
0 1
0
1 0
1
1 0
1
1
1 1
0
0
0
1
= F(1,1,0)
0
Figure 7.24. Implementation of a function F based on a 3-input LUT.
For a color version of this Ô¨Ågure, see www.iste.co.uk/
ndjountche/electronics2.zip
RAM
Di
A 2
A 0
A 1
3Input
LUT
0
1
0
1
0
1
0
1
0
1
0
1
0
1
C
A
F
0
0
1
1
0
1
0
1
EN
Decoder
Selection circuit
B
A
C
F
B
Figure 7.25. Three-input LUT. For a color version of this Ô¨Ågure, see
www.iste.co.uk/ndjountche/electronics2.zip

266
Digital Electronics 2
Any Boolean function can be represented in the form of a Shannon decomposition.
In the speciÔ¨Åc case of the logic function F(A, B, C), Shannon decomposition can be
used to successively obtain the following expressions:
F(A, B, C) = A ¬∑ F(0, B, C) + A ¬∑ F(1, B, C)
[7.31]
= A ¬∑ B ¬∑ F(0, 0, C) + A ¬∑ B ¬∑ F(0, 1, C)
+ A ¬∑ B ¬∑ F(1, 0, C) + A ¬∑ B ¬∑ F(1, 1, C)
[7.32]
= A ¬∑ B ¬∑ C ¬∑ F(0, 0, 0) + A ¬∑ B ¬∑ C ¬∑ F(0, 0, 1)
+ A ¬∑ B ¬∑ C ¬∑ F(0, 1, 0) + A ¬∑ B ¬∑ C ¬∑ F(0, 1, 1)
+ A ¬∑ B ¬∑ C ¬∑ F(1, 0, 0) + A ¬∑ B ¬∑ C ¬∑ F(1, 0, 1)
+ A ¬∑ B ¬∑ C ¬∑ F(1, 1, 0) + A ¬∑ B ¬∑ C ¬∑ F(1, 1, 1)
[7.33]
Thus, to implement this 3-variable function based on a 3-input LUT, the inputs
must be used as selection addresses for the 8 √ó 1 bit memory in which the output
column of the truth table is stored.
To implement Boolean functions with more than three variables, two 3-input LUTs
must be combined.
A 3-input LUT can also be implemented by associating two 2-input LUTs, as
shown in Figure 7.26.
F
3Input
LUT
F
B
A
C
C
B
A
2Input
LUT
2Input
LUT
0
1
Figure 7.26. Implementation of a 3-input LUT based on a 2-input LUT
A K-input LUT usually allows for the implementation of any boolean function of
K variables, especially 22K different functions.
NOTE 7.2.‚Äì The implementation of the Boolean functions can be carried out using
approaches other than those using LUT based circuits. The circuit shown in
Figure 7.29(a), which comprises a 2-bit decoder, a network of programmable

Programmable Logic Circuits
267
interconnects, OR gates and a 2 : 1 multiplexer can be used to implement the logic
function F(A, B, C) based on the decomposition as per Shannon‚Äôs expansion
theorem, as given by:
F(A, B, C) = C ¬∑ F(A, B, 0) + C ¬∑ F(A, B, 1)
[7.34]
On the other hand, if the function F(A, B, C) is decomposed in the following
manner:
F(A, B, C) = A ¬∑ B ¬∑ F(0, 0, C) + A ¬∑ B ¬∑ F(0, 1, C)+
A ¬∑ B ¬∑ F(1, 0, C) + A ¬∑ B ¬∑ F(1, 1, C)
[7.35]
it can be implemented by the circuit represented in Figure 7.29(b), which is based on
a 4 : 1 multiplexer.
Connections can be established using a network of programmable interconnects
between the input/output pins and the inputs and outputs of the different logic blocks
of a reconÔ¨Ågurable circuit. Figure 7.27 shows the different types of interconnects used
in the reconÔ¨Ågurable circuits. Each point of interconnection between two conductors
can be implemented using a switch whose state (open or closed) is programmable
based on a conÔ¨Åguration bit saved in a memory.
(a)
(c)
(d)
(b)
Figure 7.27. Types of interconnects used in programable logic circuits
A reprogrammable interconnect may be based on an EEPROM, Flash or SRAM,
as shown in Figure 7.28.
Following the principle of an EEPROM, a reprogrammable interconnect uses a
Ô¨Çoating-gate avalanche-injection MOS (FAMOS) transistor. A charge induced onto
the Ô¨Çoating gate by the positive programming voltage remains there after the voltage
has been disconnected. However, the charge stored on the Ô¨Çoating gate can be removed
by applying a negative voltage.
In the case of a Flash-based reprogrammable interconnect, the Ô¨Çoating gate
transistor, TC, plays the role of a switch, while the Ô¨Çoating-gate tunneling oxide

268
Digital Electronics 2
(FLOTOX) transistor, TF , enables the write and erase operations. It must be noted
that the FLOTOX transistor is a version of the FAMOS transistor, where the thickness
of one portion of the dielectric layer is reduced to facilitate electrical erasure.
DD
T C
T F
S1
V
S2
V
VP
cell
(a)
(c)
(b)
V
SRAM
Figure 7.28. Reprogrammable interconnects:
a) EEPROM; b) Flash; c) SRAM
2:4 Decoder
B
A.
B
A
1
0
B
A.
B
A.
B
A.
(a)
MUX
C
F(A,B,C)
(b)
C
A
B
C
C
0
1
2
3
MUX
F(A,B,C)
Figure 7.29. Programmable circuits that are appropriate
for the implementation of 3-variable functions
Another implementation approach used for reprogrammable interconnects consists
of using an SRAM to store the conÔ¨Åguration bit that is required to control a MOS
transistor operating as a switch.
7.4.2. CPLD
A CPLD contains at least two PLDs. It is made up of:
‚Äì a block of dedicated inputs;
‚Äì input/output blocks;
‚Äì macrocell blocks;

Programmable Logic Circuits
269
‚Äì a programmable interconnect network.
A macrocell can consist of a D Ô¨Çip-Ô¨Çop, multiplexers and three-state gates.
The programmable interconnect network is implemented either using a matrix of
switches or using multiplexers. The switch matrix can help connect a given node to
any output node, while the use of multiplexers is limited by the size and operating
speed of the circuit, and it can generally be used only to connect a given node to a
speciÔ¨Åc output node.
The structure of a CPLD, as illustrated in Figure 7.30, helps to better optimize
the use of resources (bank of AND gates, bank of OR gates, macrocell, input/output
blocks) than that of a PLD. The Ô¨Çip-Ô¨Çops of a CPLD can be conÔ¨Ågured as D, JK, T or
RS Ô¨Çip-Ô¨Çops. The clock signal for each Ô¨Çip-Ô¨Çop can be individual or global (or can be
used to control any component of the chip).
block
MC x
MC 1
MC 0
block
I/O
I/O
MC x
MC 1
MC 0
I/O
MC x
MC 1
MC 0
I/O
MC x
MC 1
MC 0
Logic
block
Logic
Interconnect
network
Logic
block
Logic
Figure 7.30. Architecture of a CPLD
The Xilinx XC9500 CPLD is made up of several functional blocks and input/output
blocks which are completely interconnected by a switch matrix. Each functional block
comprises 18 macrocells. The structure of a macrocell is represented in Figure 7.31.
It is associated with a product term allocator, a detailed diagram of which is given in
Figure 7.32.
Each functional block is implemented using a sum-of-products representation. The
AND gates network generates 90 product terms from 36 inputs, which correspond to
72 signals and their complements. Any number out of these 90 product terms can be
assigned to each macrocell by the product term allocator.
Each macrocell may be conÔ¨Ågured to implement combinational functions or shift-
register type functions. Five logic product terms from the AND bank can be used as the

270
Digital Electronics 2
inputs for the OR and XOR gates to implement combinational functions, or as control
inputs (clock signal, set, reset, output enable). The product term allocator offers the
possibility to choose how the Ô¨Åve product terms reserved for a macrocell are used.
Macrocell
PR
To switch network
CLR
3
CK1
CK2
CK3
CLR
Q
CE
0
1
PR
Q
D
Set/reset
1
6
c
d
54
a
b
(from other
macrocells)
product terms
(from other
product terms
Extra
Extra
To I/O blocks
macrocells)
allocator
Logic product term
Figure 7.31. Structure of a CPLD macrocell (Xilinx XC9500)
In a functional block, the product terms that are not used by the macrocells can be
reassigned to other macrocells in order to increase their capacity. All 90 product terms
can be made available for each macrocell, but with an additional delay.
7.4.3. FPGA
An FGPA is based on a regular network and thus helps achieves a higher
integration level than a CPLD. It has a large number of macrocells and offers great
interconnect Ô¨Çexibility (see Figure 7.33).
The architecture of a CPLD is based on elementary logic blocks, called
macrocells. These have a mainly combinational structure and realize a logic OR of
the product terms from the AND gates. A Ô¨Çip-Ô¨Çop at the output can be used to
implement sequential functions. This structure is characterized by a minimal
input-output latency period. It can serve for the implementation of an AND gate with
a high number of inputs (of the order of 136 inputs for the Lattice ispXPLD) and is,

Programmable Logic Circuits
271
therefore, useful in the synthesis of address decoders for a memory or logic
operations on a data bus.
c
1
6
a
b
d
Figure 7.32. Logic product term allocator
FPGAs are implemented from a large number of more compact LUT-based logic
blocks. But the routing of these logic blocks is more complex in FPGAs, which offer
fewer input/output logic resources than CPLDs.
Each connection node can be implemented using two techniques, thus deÔ¨Åning
two classes of FPGAs:
‚Äì antifuse-based FPGA. The connection node is of ROM type. In this case, the
modiÔ¨Åcation of a connection node is irreversible. The advantage of an antifuse-based
FPGA is the large number of connection nodes due to the reduced fuse surface;

272
Digital Electronics 2
‚Äì SRAM-based FPGA (reprogrammable FPGA). The connection node is made
up of a set of transistors whose switching is controlled by a conÔ¨Åguration register.
An SRAM-based FPGA has a logic mechanism for autocharging the conÔ¨Åguration
registers from the EEPROM after powering on, or on demand.
Interconnect
Macrocell
Input/output
blocks
Switch
matrix
wires
Figure 7.33. Architecture of an FPGA
The structure of a conÔ¨Ågurable logic block in an Altera Stratix V FPGA is given
in Figure 7.34. It contains a combinational logic section including LUTs, two adders,
Ô¨Çip-Ô¨Çops and different control circuits. A logic block can be used to implement any
function with more than six inputs, some seven-inputs functions and certain
combinations of two independent functions.
In general, the choice of the complexity degree for the logic block is dictated by
the tradeoffs between conÔ¨Çicting factors. The less complex a logic block, the greater
the number of resources needed for its routing; but as the complexity of the logic block
increases it can result in reduced efÔ¨Åciency in the capacity utilization of the available
logic circuits.
During normal operation, the different conÔ¨Åguration bits of an FPGA are stored on
an SRAM, which is volatile. They must, therefore, be saved on a non-volatile on-chip
memory, especially a Flash or EEPROM, in order to be used during the conÔ¨Åguration
period which follows every power-on.
The architecture of the logic block varies depending on the manufacturer. The
Virtex-5 FPGA from Xilinx, for example, uses two different types of logic blocks.
One to implement logic, arithmetic and ROM functions, the other to store data on
distributed RAM and to shift data using registers.

Programmable Logic Circuits
273
To interconnect wires (rows and columns) or adjacent cells
C0
Shared arithmetic
term input
term output
Shared arithmetic
Data
Df0
De0
Daa
Dab
Dc0
Dc1
De1
Df1
Ci
aclr[1:0]


CLR
Q
D
CLR
Q
D
CLR
Q
D
CLR
Q
D
1
0
Carry
dk[2:0]
syncload
sclr
Carry
LUT
4Input
3Input
LUT
3Input
LUT
4Input
LUT
3Input
3Input
LUT
LUT
Figure 7.34. Structure of a conÔ¨Ågurable logic block (or macrocell)
in an FPGA (Altera Stratix V)
Density
PLD
CPLD
FPGA
Speed
Figure 7.35. Comparison of programmable logic circuits
Input/output blocks of an FPGA play the role of a communication interface with
external components. To ensure Ô¨Çexibility and versatility, they are conÔ¨Ågurable via

274
Digital Electronics 2
the control bits, thus allowing for the connection of different types of components
and unidirectional (input or output) or bidirectional (input/output) data transfer.
Additionally, in order to meet electrical speciÔ¨Åcations, a polarization circuit, made up
of resistors and transistors, is associated with each input/output pin.
The structure of a conÔ¨Ågurable input/output block is represented in Figure 7.36. It
is made up of three-state buffer circuits, multiplexers and Ô¨Çip-Ô¨Çops that can be used as
such or combined with internal Ô¨Çip-Ô¨Çops to form input/output registers.
CE
Q
Q
0
1
I/O
PR
CLR
Q
D
Q
PR
CLR
D
CE
Figure 7.36. ConÔ¨Ågurable input/output blocks
The necessity of implementing high-speed data transfer translates to an increase
in the complexity of the input/output blocks. As a result, the input/output boxes have
registers instead of Ô¨Çip-Ô¨Çops, alignment and synchronization circuits, parallel-to-serial
and serial-to-parallel converters, encoders and decoders.
7.5. References
‚Äì Xilinx website: www.xilinx.com;
‚Äì Altera website: www.altera.com;
‚Äì Microsemi website: www.microsemi.com;
‚Äì Lattice semiconductor website: www.latticesemi.com

Programmable Logic Circuits
275
7.6. Exercises
EXERCISE 7.1.‚Äì Consider the following logic functions:
F(A, B, C, D) = A ¬∑ C + B ¬∑ C ¬∑ D
[7.36]
G(A, B, C, D) = A ¬∑ B ¬∑ C + B ¬∑ D + A ¬∑ C ¬∑ D
[7.37]
‚Äì Implement these functions using three 2 : 4 decoders (see Figure 7.37 and
Table 7.3) and two OR gates that can take up to eight inputs. The decoder is enabled
when EN1 = 0 and EN2 = 1.
‚Äì Implement these functions using:
a) a programmable 4-input PROM circuit;
b) a programmable 4-input PAL circuit.
EN2
0
1
2
3
X0
X1
EN1
Figure 7.37. Decoder
EN1
EN2
X1
X0
0
1
2
3
x
0
x
x
0
0
0
0
1
x
x
x
0
0
0
0
0
1
0
0
1
0
0
0
0
1
0
1
0
1
0
0
0
1
1
0
0
0
1
0
0
1
1
1
0
0
0
1
Table 7.3. Truth table

276
Digital Electronics 2
EXERCISE 7.2.‚Äì BCD-to-7-segment decoder.
A number with four bits A, B, C, D (where is the least signiÔ¨Åcant bit) is applied
to the decoder inputs, yielding the signals a, b, c, d, e, f and g, which can be used to
control a seven-segment display (see Figure 7.38) generating numbers from 0 to 9.
f
b
c
g
f
(b)
b
c
a
b
c
d
e
f
a
b
c
g
d
f
a
b
c
g
d
e
f
a
b
c
c
g
d
e
f
a
a
c
g
d
f
a
b
g
d
e
a
b
c
g
d
a
b
g
d
e
A
B
C
D
BCDto7segment
decoder
(a)
a
b
c
d
e
g
f
a
b
c
g
d
e
Figure 7.38. a) BCD-to-7-segment decoder;
b) display of numbers from 0 to 9
Implement the BCD-to-7-segment decoder using a PLA circuit.
We will assume that the input combinations 1010, 1011, 1100, 1101 and 1111 are
unused.
EXERCISE 7.3.‚Äì Full adder.
A full adder can be implemented as shown in Figure 7.39, where the bits to be
added are Ai and Bi, Ci denotes the carry-in, the sum corresponds to Si and the
carry-out is given by Ci+1.
By appropriately decomposing the logic equations for a full adder, implement the
logic circuit i using logic gates.
EXERCISE 7.4.‚Äì Implementation of a 9-dot display decoder.
A 9-dot display can be used to implement a circuit for lighting animation. The
decoder inputs for the 9-dot display consist of 4-bit numbers, A, B, C and D, that
determine the state of the display (see Figure 7.40). Each of the decoder‚Äôs nine outputs
(a, b, c, d, e, f, g, h and i) is active-low and is connected to a corresponding dot of the
display.
The different states of the display associated with the inputs ABCD are illustrated
in Figure 7.41. No dot of the display is enabled for inputs associated with 0, while
inputs related to 9 are used to activate all dots of the display:

Programmable Logic Circuits
277
‚Äì Draw up the truth table of the 9-dot display decoder.
‚Äì Simplify the logic expressions a, b, c, d, e, f, g, h and i (consider, if necessary,
the cases where the functions are independent and dependent).
‚Äì Implement the decoder using a PLA.
i+1
i
Ci
S i
Bi
Logic
circuit i
C
A
0
Y
Y3
Y2
Y1
Figure 7.39. Logic circuit of a full adder
b
a
d
g
f
c
i
h
e
Figure 7.40. Representation of the 9-dot display
EXERCISE 7.5.‚Äì Multiplexer circuit.
The multiplexer circuit shown in Figure 7.42 has two data inputs (A and B), two
outputs (F and G) and two control inputs (S1 and S0).
‚Äì Draw up its truth table based on A and B.
‚Äì Determine the role of this circuit.

278
Digital Electronics 2
1100 and 1111
0110
6
0111
7
1000
8
1001
9
0101
5
1011

1100
.
1101
0000
=
+
0001
1
0010
2
0011
3
0100
4
0000
0
Unused
combinations
Figure 7.41. Operation of the 9-dot display
0
1
00
01
10
11
00
01
10
11
A
B
G
F
S
S
Figure 7.42. Circuit using two 4 : 1 multiplexers
EXERCISE 7.6.‚Äì Circuit for a logic element.
The circuit shown in Figure 7.43 is a logic element that can be used to implement
any 3-variable boolean function.
Complete the column F of the function table that is shown in Table 7.44.
Determine the combination of the variables A, B, S2, S1 and S0, that are required
for the implementation of the function F = X ¬∑ Y ‚äïY ¬∑ Z ‚äïY ¬∑ Z.

Programmable Logic Circuits
279
B
2
S1
S0
01
10
00
00
01
10
11
1
0
F
Ci+1
11
A
S
Figure 7.43. Logic circuit of a logic element
A
B
S2
S1
S0
F
Ci+1
X
Y
X
Z
Z
‚Äì
0
X
Y
Z
1
‚Äì
0
X
Y
Y
Z
‚Äì
0
X
Y
Z
Y
‚Äì
0
0
X
Y
Z
‚Äì
0
Y
0
X
Z
‚Äì
X
1
Y
Z
1
‚Äì
X
Y
1
1
Z
‚Äì
Z
Z
1
X
Y
‚Äì
X
1
Y
Z
0
X ‚äïY ‚äïZ
X ¬∑ Y + X ¬∑ Z + Y ¬∑ Z
Figure 7.44. Function table (F)
Specify the choice of variables A, B, S2, S1 and that can be used to implement a
full adder, whose inputs are X and Y and whose carry-in is Ci.
EXERCISE 7.7.‚Äì Implementation of a 5-variable function based on 4-input LUTs.

280
Digital Electronics 2
Consider the 5-variable Boolean function that can be written as follows:
F(A, B, C, D, E) = [A¬∑B¬∑D¬∑E+(A+E)D+(A‚äïB)E]‚äô[B+(A‚äïC)][7.38]
Implement this function using two or three LUTs.
EXERCISE 7.8.‚Äì Implementation of an adder and a comparator using 4-input LUTs.
A 4-input LUT can be implemented by combining two 3-input LUTs and a 2 : 1
multiplexer, as shown in Figure 7.45.
F
C
A
D
B
LUT
4Input
3Input
LUT
3Input
LUT
0
1
F
G
A
B
C
D
G
Figure 7.45. Four-input LUT
Determine the logic expressions for G1, F1, G0 and F0, considering that the circuit
of Figure 7.46 plays the role of an adder whose inputs are the numbers A = A1A0
and B = B1B0, and the carry-in Ci, and whose outputs are the sum S = S1S0 and
the carry-out C2.
Determine the logic expressions for F01 and F23 so that the circuit of Figure 7.47
may operate as a comparator setting the SA=B to 1 when the two binary numbers,
A = A3A2A1A0 and B = B3B2B1B0, are equal.
EXERCISE 7.9.‚Äì Logic element circuit.
Consider a programmable circuit based on a logic element that is composed of an
XOR gate, a D Ô¨Çip-Ô¨Çop and a 2 : 1 multiplexer, as shown in Figure 7.48:
‚Äì complete the truth table given in Table 7.4 for all the possible values of the
control signals S1 and S0. The input signal of the Ô¨Çip-Ô¨Çop is represented by D and the
output of the multiplexer is denoted by F;
‚Äì using three-state buffers, modify the circuit shown in Figure 7.48 so that the pin
X can be used as an input or output depending on the state of the control signal S2;
‚Äì modify the resulting circuit by using an AND gate to allow for the synchronous
reset of the D Ô¨Çip-Ô¨Çop via the control signal S3.

Programmable Logic Circuits
281
4Input
i
LUT
C
0
1
MUX
G
0
1
MUX
G
S 0
S 1
0
1
C1
C2
1
A0
B0
1
A1
B1
F 1
F 0
LUT
4Input
Figure 7.46. Adder
4Input
1
B 0
A 0
A 3
B 2
A 2
A=B
S
0
1
MUX
F
0
23
0
1
MUX
1
0
F01
1
B
3
B
LUT
4Input
LUT
A
Figure 7.47. Comparator

282
Digital Electronics 2
X
 0
S 1
S
Q
D
1
0
F
CK
Figure 7.48. Logic element circuit
S1
S0
D
F
Table 7.4. Truth table to be completed
EXERCISE 7.10.‚Äì Timing diagram of a logic element for a programmable circuit.
Consider a programmable circuit based on the logic element of Figure 7.49a that
consists of logic gates (AND, OR, XOR), a 2 : 1 multiplexer and a D Ô¨Çip-Ô¨Çop.
Complete the timing diagram shown in Figure 7.49(b).
DI
D
G
Y
F
CK
M
X
(a)
CK
DI
Q
G
F
X
M
Y
(b)
1
0
Q
Figure 7.49. a) Logic circuit; b) timing diagram

Programmable Logic Circuits
283
EXERCISE 7.11.‚Äì Logic function implementations using an LUT.
The circuit shown in Figure 7.50 constitutes a logic element in an FPGA, whose
functional resource usage is to be optimized. It is composed of two 2-input LUTs, two
2 : 1 multiplexers and logic gates (inverter and OR).
LUT
Y
X
Z
1
0
F
1
0
G
2Input
LUT
2Input
Figure 7.50. Logic circuit
Show that this circuit can be used to implement each of the following functions
(see the truth tables shown in Tables 7.5 and 7.6):
‚Äì a full adder (S and C0);
‚Äì a comparator with an output indicating equality, E0.
Ci
A
B
S
C0
0
0
0
0
0
0
0
1
1
0
0
1
0
1
0
0
1
0
0
1
1
0
0
1
0
1
0
1
0
1
1
1
0
0
1
1
1
0
1
1
Table 7.5. Truth table

284
Digital Electronics 2
Ei
A
B
E0
0
0
0
0
0
0
1
0
0
1
0
0
0
1
0
0
1
0
0
1
1
0
1
0
1
1
0
0
1
1
0
1
Table 7.6. Truth table
7.7. Solutions
SOLUTION 7.1.‚Äì Implementation of the logic functions F and G.
The logic functions F and G can be written as follows:
F(A, B, C, D) = A ¬∑ C + B ¬∑ C ¬∑ D
=

m(5, 8, 9, 12, 13)
[7.39]
G(A, B, C, D) = A ¬∑ B ¬∑ C + B ¬∑ D + A ¬∑ C ¬∑ D
=

m(1, 3, 5, 8, 9, 11)
[7.40]
Figure 7.51(a) depicts a possible implementation of the functions F and G based
on decoders and OR gates. When the variables C and D are chosen to activate the
decoders, the combination C ¬∑ D is not required.
Using a PROM, the functions F and G can be implemented as shown in
Figure 7.51(b).
To implement the functions F and G using a PLA, it is useful to simplify these two
functions while bringing out their common terms. Thus, the Karnaugh maps shown in
Figure 7.52 can be used to obtain expressions of the form:
F(A, B, C, D) = A ¬∑ C + A ¬∑ B ¬∑ C ¬∑ D
[7.41]
G(A, B, C, D) = A ¬∑ B ¬∑ C + B ¬∑ D + A ¬∑ B ¬∑ C ¬∑ D
[7.42]
The PLA that can be used to realize the functions F and G is shown in Figure 7.53.

Programmable Logic Circuits
285
(b)
D
F
G
C
G
F
B
A
C
D
15
14
13
12
11
10
9
8
7
6
5
4
3
2
1
0
0
1
2
3
X0
X1
C
A
D
0
1
2
3
X0
X1
A
D
0
1
2
3
X0
X1
C
A
B
B
11
3
13
9
5
1
12
8
B
(a)
Figure 7.51. Implementation of F and G using
a) decoders and b) a PROM
(b)
0
1
0
0
1
0
0
1
0
0
0
0
1
1
0
1
AB
CD
C
00
01
11
10
B
A
D
00
01
11
10
0
1
0
1
0
0
0
0
0
0
0
0
0
1
1
1
AB
CD
C
00
01
11
10
B
A
D
00
01
11
10
(a)
Figure 7.52. Karnaugh maps: a) F; b) G. For a color version of this
Ô¨Ågure, see www.iste.co.uk/ndjountche/electronics2.zip

286
Digital Electronics 2
G
B
A
D
C
F
Figure 7.53. PLA for the implementation of F and G
SOLUTION 7.2.‚Äì BCD-to-7-segment decoder.
The truth table and Karnaugh maps for each of the outputs can be used to obtain
the following logic equations:
a =

m(0, 2, 3, 5, 6, 7, 8, 9)
= A + C + B ¬∑ D + B ¬∑ D
[7.43]
b =

m(0, 1, 2, 3, 4, 7, 8, 9)
= B + C ¬∑ D + C ¬∑ D
[7.44]
c =

m(0, 1, 3, 4, 5, 6, 7, 8, 9)
= B + C + D
[7.45]
d =

m(0, 2, 3, 5, 6, 8, 9)
= A + B ¬∑ C + B ¬∑ D + C ¬∑ D + B ¬∑ C ¬∑ D
[7.46]
e =

m(0, 2, 6, 8)
= B ¬∑ D + C ¬∑ D
[7.47]
f =

m(0, 4, 5, 6, 8, 9)

Programmable Logic Circuits
287
= A + B ¬∑ C + B ¬∑ D + C ¬∑ D
[7.48]
and
g =

m(2, 3, 4, 5, 6, 8, 9)
= A + B ¬∑ C + B ¬∑ C + C ¬∑ D
[7.49]
Because the size (or number of horizontal lines) of the PLA that can be used to
implement logic functions depends on the number of different product terms, the
above equations must be written in other forms to highlight the common terms. This
is shown in Figures 7.54‚Äì7.60.
D
01
11
10
0
1
1
x
1
1
x
x
1
1
x
x
0
x
1
1
AB
CD
C
00
01
11
10
B
A
00
Figure 7.54. Signal a:
a = A + B ¬∑ D + C ¬∑ D + B ¬∑ C ¬∑ D + B ¬∑ C ¬∑ D. For a color version of this
Ô¨Ågure, see www.iste.co.uk/ndjountche/electronics2.zip
Comparing these two solutions we can see that the number of different product
terms has been reduced from 15 to 9.
In the case of the PLA, the best implementation is based on Boolean equations
obtained by using a multiple-output logic minimization approach. This consists of
minimizing a set of logic functions while maximizing the sharing of the product terms.

288
Digital Electronics 2
D
01
11
10
1
1
1
x
1
1
x
x
1
0
x
x
1
x
1
0
AB
CD
C
00
01
11
10
B
A
00
Figure 7.55. Signal b:
b = B ¬∑ D + B ¬∑ D + C ¬∑ D + C ¬∑ D. For a color version of this Ô¨Ågure, see
www.iste.co.uk/ndjountche/electronics2.zip
D
01
11
10
1
1
1
x
1
1
x
x
0
1
x
x
1
x
1
1
AB
CD
C
00
01
11
10
B
A
00
Figure 7.56. Signal c:
c = B ¬∑ D + C ¬∑ D + C ¬∑ D + B ¬∑ C ¬∑ D + B ¬∑ C ¬∑ D. For a color version of
this Ô¨Ågure, see www.iste.co.uk/ndjountche/electronics2.zip

Programmable Logic Circuits
289
D
01
11
10
0
1
1
x
1
0
x
x
1
1
x
x
0
x
1
1
AB
CD
C
00
01
11
10
B
A
00
Figure 7.57. Signal d:
d = A + B ¬∑ C + B ¬∑ D + B ¬∑ C ¬∑ D + B ¬∑ C ¬∑ D. For a color version of this
Ô¨Ågure, see www.iste.co.uk/ndjountche/electronics2.zip
D
01
11
10
0
1
1
x
0
0
x
x
1
1
x
x
0
x
0
0
AB
CD
C
00
01
11
10
B
A
00
Figure 7.58. Signal e:
e = B ¬∑ D + B ¬∑ C ¬∑ D. For a color version of this Ô¨Ågure, see
www.iste.co.uk/ndjountche/electronics2.zip

290
Digital Electronics 2
D
01
11
10
1
1
1
x
0
0
x
x
0
1
x
x
0
x
1
1
AB
CD
C
00
01
11
10
B
A
00
Figure 7.59. Signal f:
f = A + C ¬∑ D + B ¬∑ C ¬∑ D + B ¬∑ C ¬∑ D. For a color version of this Ô¨Ågure,
see www.iste.co.uk/ndjountche/electronics2.zip
1
01
11
10
AB
CD
C
00
01
11
10
B
A
D
1
1
0
x
1
0
x
x
1
1
x
x
0
x
1
00
Figure 7.60. Signal g:
g = A + B ¬∑ C + B ¬∑ C + B ¬∑ C ¬∑ D. For a color version of this Ô¨Ågure, see
www.iste.co.uk/ndjountche/electronics2.zip

Programmable Logic Circuits
291
Figure 7.61 depicts the logic circuit for the BCD-to-7-segment decoder.
e
a
b
c
d
B
A
D
C
f
g
Figure 7.61. Implementation of the BCD-to-7-segment
decoder using a PLA
SOLUTION 7.3.‚Äì Full adder.
A full adder is a circuit with three inputs: the Ô¨Årst number being Ai, the second Bi
and a carry-in Ci. It provides the sum Si and the carry-out, Ci+1, that can be expressed
as follows:
Si = (Ai ¬∑ Bi + Ai ¬∑ Bi)Ci + (Ai ¬∑ Bi + Ai ¬∑ Bi)Ci
[7.50]
and:
Ci+1 = Ai ¬∑ Bi + (Ai + Bi)Ci = Ai ¬∑ Bi + (Ai ¬∑ Bi + Ai ¬∑ Bi)Ci
[7.51]
The sum Si can be put into the form:
Si = (Ai + Bi)(Ai + Bi)Ci + (Ai + Bi)(Ai + Bi)Ci
[7.52]

292
Digital Electronics 2
The complement of the carry-out, Ci+1, is given by:
Ci+1 = Ai ¬∑ Bi + (Ai + Bi)Ci
[7.53]
= (Ai + Bi)(Ai + Ci)(Bi + Ci)
[7.54]
= Ai ¬∑ Bi + (Ai + Bi)Ci
[7.55]
But it can also be decomposed as follows:
Ci+1 = Ai ¬∑ Bi + (Ai ¬∑ Bi + Ai ¬∑ Bi)Ci
[7.56]
= (Ai + Bi)(Ai + Bi)(Ai + Bi)
+ (Ai + Bi)(1 + Ai + Ai + Bi + Bi)Ci
[7.57]
= (Ai + Bi)(Ai + Bi)(Ai + Bi)
+ (Ai + Bi + Ai ¬∑ Bi + Ai ¬∑ Bi + Ai ¬∑ Bi)Ci
[7.58]
Because:
Ai ¬∑ Bi = (Ai + Bi)(Ai + Bi)(Ai + Bi)
[7.59]
Ai = Ai(Bi + Bi) = Ai ¬∑ Bi + Ai ¬∑ Bi
[7.60]
and:
Bi = (Ai + Ai)Bi = Ai ¬∑ Bi + Ai ¬∑ Bi
[7.61]
we obtain:
Ci+1 = (Ai + Bi)(Ai + Bi)(Ai + Bi) + (Ai ¬∑ Bi + Ai ¬∑ Bi + Ai ¬∑ Bi)Ci
[7.62]
= (Ai + Bi)(Ai + Bi)(Ai + Bi)(1 + Ci) + (Ai ¬∑ Bi + Ai ¬∑ Bi)Ci
[7.63]
= (Ai + Bi)(Ai + Bi)(Ai + Bi) + (Ai + Bi)(Ai + Bi)Ci
[7.64]
Figure 7.62 depicts the logic circuit of the decoder, which can generate maxterms
that appear in the decomposition of Si and Ci+1.
SOLUTION 7.4.‚Äì Decoder of a 9-dot display for a lighting animation circuit.
The truth table of the 9-dot display decoder can be drawn up as shown in Table 7.7.
The simpliÔ¨Åcation of the equation for each of the outputs using Karnaugh maps is
shown in Figures 7.63‚Äì7.70.
It must be noted that the expression for h presents the advantage of comprising
only preexisting terms but it is different from the minimal form that contains the term
B ¬∑ D instead of the term A ¬∑ B ¬∑ D.

Programmable Logic Circuits
293
Logic
i
Y3
Y2
Y1
0
Y
0
Y
Y3
Y2
Y1
Bi
Bi
A i
circuit
A
Figure 7.62. Logic circuit of the decoder
Symbol
A
B
C
D
a
b
c
d
e
f
g
h
i
0
0
0
0
1
1
1
1
1
1
1
1
1
1
1
0
0
0
1
1
1
1
1
0
1
1
1
1
2
0
0
1
0
0
1
1
1
1
1
1
1
0
3
0
0
1
1
0
1
1
1
0
1
1
1
0
4
0
1
0
0
0
1
0
1
1
1
0
1
0
5
0
1
0
1
0
1
0
1
0
1
0
1
0
6
0
1
1
0
0
1
0
0
1
0
0
1
0
7
0
1
1
1
0
1
0
0
0
0
0
1
0
8
1
0
0
0
0
0
0
0
1
0
0
0
0
9
1
0
0
1
0
0
0
0
0
0
0
0
0
+
1
0
1
0
1
0
1
0
0
0
1
0
1
‚àí
1
0
1
1
1
1
1
0
0
0
1
1
1
.
1
1
0
0
1
1
1
1
1
1
1
1
0
=
1
1
0
1
1
1
1
0
0
0
0
0
0
1
1
1
0
x
x
x
x
x
x
x
x
x
1
1
1
1
x
x
x
x
x
x
x
x
x
Table 7.7. Truth table of the 9-dot display decoder

294
Digital Electronics 2
1
01
11
10
0
0
1
1
0
0
x
1
0
0
x
1
1
0
0
AB
CD
C
00
01
11
10
B
A
D
00
Figure 7.63. Signal a:
a = A ¬∑ B + A ¬∑ C + A ¬∑ B ¬∑ C. For a color version of this Ô¨Ågure, see
www.iste.co.uk/ndjountche/electronics2.zip
0
01
11
10
1
0
1
1
1
1
x
1
1
1
x
1
1
0
1
AB
CD
C
00
01
11
10
B
A
D
00
Figure 7.64. Signal b:
b = A + B + C ¬∑ D. For a color version of this Ô¨Ågure, see
www.iste.co.uk/ndjountche/electronics2.zip

Programmable Logic Circuits
295
1
01
11
10
0
0
1
1
1
0
x
1
1
0
x
1
1
0
0
AB
CD
C
00
01
11
10
B
A
D
00
Figure 7.65. Signal c:
c = A ¬∑ B + A ¬∑ C + A ¬∑ B. For a color version of this Ô¨Ågure, see
www.iste.co.uk/ndjountche/electronics2.zip
0
01
11
10
1
0
1
1
1
0
x
0
1
0
x
1
0
0
1
AB
CD
C
00
01
11
10
B
A
D
00
Figure 7.66. Signals d and f:
d = f = A ¬∑ B + A ¬∑ C + A ¬∑ B ¬∑ D. For a color version of this Ô¨Ågure, see
www.iste.co.uk/ndjountche/electronics2.zip

296
Digital Electronics 2
0
01
11
10
1
1
1
1
0
0
x
0
1
1
x
0
0
0
0
AB
CD
C
00
01
11
10
B
A
D
00
Figure 7.67. Signal e:
e = A ¬∑ D + C ¬∑ D. For a color version of this Ô¨Ågure, see
www.iste.co.uk/ndjountche/electronics2.zip
1
01
11
10
0
0
1
1
1
0
x
1
1
0
x
1
0
0
0
AB
CD
C
00
01
11
10
B
A
D
00
Figure 7.68. Signal g:
g = A ¬∑ B + A ¬∑ C + A ¬∑ B ¬∑ D. For a color version of this Ô¨Ågure, see
www.iste.co.uk/ndjountche/electronics2.zip

Programmable Logic Circuits
297
0
01
11
10
1
0
1
1
1
1
x
1
1
1
x
1
0
0
1
AB
CD
C
00
01
11
10
B
A
D
00
Figure 7.69. Signal h:
h = A + C ¬∑ D + A ¬∑ B ¬∑ D. For a color version of this Ô¨Ågure, see
www.iste.co.uk/ndjountche/electronics2.zip
1
01
11
10
0
0
1
0
0
0
x
1
0
0
x
1
0
0
0
AB
CD
C
00
01
11
10
B
A
D
00
Figure 7.70. Signal i:
i = A ¬∑ C + A ¬∑ B ¬∑ C. For a color version of this Ô¨Ågure, see
www.iste.co.uk/ndjountche/electronics2.zip

298
Digital Electronics 2
g
a
b
c
d
f
B
A
D
C
e
h
i
Figure 7.71. Logic circuit of the 9-dot display decoder
Figure 7.71 shows the 9-dot display decoder implemented using a PLA.
SOLUTION 7.5.‚Äì Multiplexer circuit.
Analyzing the proposed logic circuit, we obtain the following equations:
F = A ¬∑ S1 ¬∑ S0 + B ¬∑ S1 ¬∑ S0 + A ¬∑ S1 ¬∑ S0 + B ¬∑ S1 ¬∑ S0
[7.65]
and
G = B ¬∑ S1 ¬∑ S0 + A ¬∑ S1 ¬∑ S0 + A ¬∑ S1 ¬∑ S0 + B ¬∑ S1 ¬∑ S0
[7.66]
The truth table can then be drawn up as shown in Table 7.8.
This is a cross-bar switch, the symbol for which is given in Figure 7.72.
SOLUTION 7.6.‚Äì Logic element circuit.
The analysis of the logic element provides the following equation:
F = [A ¬∑ S2 ¬∑ S1 + A(S2 ¬∑ S1 + S2 ¬∑ S1) + A ¬∑ S2 ¬∑ S1]S0
+ [B ¬∑ S2 ¬∑ S1 + A(S2 ¬∑ S1 + S2 ¬∑ S1) + B ¬∑ S2 ¬∑ S1]S0
[7.67]

Programmable Logic Circuits
299
S1
S0
F
G
0
0
A
B
0
1
B
A
1
0
A
A
1
1
B
B
Table 7.8. Truth table of the cross-bar switch
B
1
S0
G
F
A
S
Figure 7.72. Symbol of the cross-bar switch
A B S2 S1 S0 F
Ci+1
X Y X Z
Z X ¬∑ Y ¬∑ Z
‚Äì
0 X Y Z
1 X ¬∑ Y ¬∑ Z + X ¬∑ Y ¬∑ Z
‚Äì
0 X Y
Y
Z (X ‚äïY )Z
‚Äì
0 X Y
Z Y
(X + Y )Z
‚Äì
0 0 X Y Z X ¬∑ Y ¬∑ Z + X ¬∑ Y ¬∑ Z + X ¬∑ Y ¬∑ Z ‚Äì
0 Y 0
X Z X ¬∑ Z + X ¬∑ Y ¬∑ Z
‚Äì
X 1 Y Z
1 X ¬∑ Y + Y ¬∑ Z + X ¬∑ Z
‚Äì
X Y 1
1
Z X ¬∑ Z + Y ¬∑ Z
‚Äì
Z Z 1 X Y
(X ¬∑ Y ) ‚äïZ
‚Äì
X 1 Y Z
0 X ‚äïY ‚äïZ
X ¬∑ Y + Y ¬∑ Z + X ¬∑ Z
Table 7.9. Function table (F)
Table 7.9 shows the function table of the logic element.
For the combination of the variables A = X, B = 1, S2 = Y , S1 = Z and
S0 = 1, we have:
F = X ¬∑ Y + Y ¬∑ Z + X ¬∑ Z = X ¬∑ Y ‚äïY ¬∑ Z ‚äïX ¬∑ Z
[7.68]

300
Digital Electronics 2
The choice of variables that can be used to implement a full adder is given below:
A = X, B = 1, S2 = Y, S1 = Ci and S0 = 0.
That is:
F = S = X ‚äïY ‚äïCi
and
Ci+1 = X ¬∑ Y + X ¬∑ Ci + Y ¬∑ Ci
[7.69]
SOLUTION 7.7.‚Äì Implementation of a 5-variable function using a 4-input LUT.
The Boolean function to be implemented is given by:
F(A, B, C, D, E) = [A¬∑B¬∑D¬∑E+(A+E)D+(A‚äïB)E]‚äô[B+(A‚äïC)][7.70]
In this form, it can be implemented using two LUTs, as shown in Figure 7.73(a).
The LUT 1 implements the function X = [A ¬∑ B ¬∑ D ¬∑ E + (A + E)D + (A ‚äïB)E],
and the LUT 2 implements the function X ‚äô[B + (A ‚äïC)].
The function F can also be decomposed according to Shannon‚Äôs expansion
theorem. Thus:
F(A, B, C, D, E) = A ¬∑ F(0, B, C, D, E) + A ¬∑ F(1, B, C, D, E)
[7.71]
where:
F(0, B, C, D, E) = (D + B ¬∑ E) ‚äô(B + C)
[7.72]
and:
F(1, B, C, D, E) = (B ¬∑ D ¬∑ E + D ¬∑ E + B ¬∑ E) ‚äô(B + C)
[7.73]
The circuit obtained in this case is illustrated in Figure 7.73(b). The functions
F(0, B, C, D, E) and F(1, B, C, D, E) are implemented by LUT 1 and LUT 2, while
the LUT 3 is conÔ¨Ågured as a 2 : 1 multiplexer whose select signal is A.
SOLUTION 7.8.‚Äì Implementation of an adder and comparator using 4-input LUTs.
A full adder is characterized by the following Boolean equations:
Si = (Ai ‚äïBi) ‚äïCi
[7.74]
Ci+1 = (Ai ‚äïBi)Ci + Ai ¬∑ Bi
[7.75]

Programmable Logic Circuits
301
LUT 3
(a)
E
A
B
D
F
C
F
A
(b)
E
B
C
D
LUT 1
LUT 2
LUT 2
LUT 1
Figure 7.73. Circuits for the implementation of F
We have:
S1 = G1 ‚äïC1
[7.76]
S0 = G0 ‚äïCi
[7.77]
C2 = C1 ¬∑ G1 + F1 ¬∑ G1
and:
C1 = Ci ¬∑ G0 + F0 ¬∑ G0
[7.78]
By comparison, we can deduce the following logic expressions:
G1 = A1 ‚äïB1
[7.79]
F1 = A1 ¬∑ B1
[7.80]
G0 = A0 ‚äïB0
[7.81]
and:
F0 = A0 ¬∑ B0
[7.82]
For a 4-bit comparator, the logic equation for the output SA=B is written as:
SA=B = (A3 ‚äïB3) (A2 ‚äïB2) (A1 ‚äïB1) (A0 ‚äïB0)
[7.83]
Because:
SA=B = F23 ¬∑ F01
[7.84]

302
Digital Electronics 2
it follows that:
F01 = (A1 ‚äïB1) (A0 ‚äïB0)
[7.85]
and:
F23 = (A3 ‚äïB3) (A2 ‚äïB2)
[7.86]
SOLUTION 7.9.‚Äì Logic element circuit.
By analyzing the circuit for the logic element in Figure 7.74, we have:
F = D ¬∑ S0 + Q ¬∑ S0
[7.87]
and
Q+ = D = X ‚äïS1
[7.88]
where Q+ denotes the next state of the Ô¨Çip-Ô¨Çop output. Table 7.10 shows the truth
table of the logic element.
X
 0
S 1
S
Q
D
1
0
F
CK
Figure 7.74. Logic element circuit
S1
S0
D
F
0
0
X
Q
0
1
X
D
1
0
X
Q
1
1
X
D
Table 7.10. Truth table
The logic element circuit with an I/O pin is shown in Figure 7.75.

Programmable Logic Circuits
303
D
 0
S 2 S 1
S
Q
1
0
F
X
CK
D0
Figure 7.75. Circuit of a logic element with an I/O pin
The logic element circuit with a synchronous reset input for the Ô¨Çip-Ô¨Çop is shown
in Figure 7.76.
1
Q
0
X
CK
S 2
S 3
S 0
D0
S
D
1
F
Figure 7.76. Circuit of a logic element with a synchronous reset input
SOLUTION 7.10.‚Äì Timing diagram of the logic element for a programmable circuit.
An analysis of the logic element circuit yields the following equations:
F = G ¬∑ Y + Q ¬∑ Y
[7.89]
where
G = M ¬∑ DI + M ¬∑ DI ¬∑ CK = M ¬∑ DI(1 + CK) = M ¬∑ DI
[7.90]
and the next state of the Ô¨Çip-Ô¨Çop is deÔ¨Åned by:
Q+ = D = X ‚äïDI
[7.91]
The timing diagram of the logic element shown in Figure 7.77(a) is represented in
Figure 7.77(b).

Programmable Logic Circuits
305
For the carry-out, C0, we have:
C0 = Ci ¬∑ C0(0, A, B) + Ci ¬∑ C0(1, A, B)
[7.94]
The truth table gives the representation 0001 for C0(0, A, B), 0111 for
C0(1, A, B)
and
0110
for
S(0, A, B).
This
can
be
exploited
to
write
C0(1, A, B) = S(0, A, B) + C0(0, A, B), and Ô¨Ånally:
C0 = Ci ¬∑ C0(0, A, B) + Ci[S(0, A, B) + C0(0, A, B)]
[7.95]
The logic equation for the output E0 of the comparator can take the form:
E0 = Ci ¬∑ E0(0, A, B) + Ci ¬∑ E0(1, A, B)
[7.96]
Because, according to the truth table shown in Table 7.12, E0(0, A, B) and
E0(1, A, B) take the values 0000 and 1001, respectively, it can be established that
E0(1, A, B) = E0(0, A, B) + E0(1, A, B). Hence:
E0 = Ci ¬∑ E0(0, A, B) + Ci[E0(0, A, B) + E0(1, A, B)]
[7.97]
Ei
A
B
E0
0
0
0
0
0
0
1
0
0
1
0
0
0
1
0
0
1
0
0
1
1
0
1
0
1
1
0
0
1
1
0
1
Table 7.12. Truth table of the comparator
The input and output speciÔ¨Åcations of the logic element are given in Table 7.13 for
each of the functions to be implemented.

306
Digital Electronics 2
Z
Y
X
F
G
Function
A
B
Ci
S
C0
Adder
A
B
Ci
-
E0
Comparator
Table 7.13. Input and output speciÔ¨Åcations of the logic element

Appendix
Digital Integrated Circuits and Software
A1.1. Combinational circuit
‚Äì 74HC00 Quad 2-Input NAND Gate
‚Äì 74HC02 Quad 2-Input Nor Gate
‚Äì 74HC04 Hex Inverter
‚Äì 74HC86 Quad 2-input XOR Gate
‚Äì 74HC138 3 of 8 Decoder
‚Äì 74HC139 Dual 2 of 4 Decoder
‚Äì 74HC157 Quad 2 to 1 Multiplexer non-inverting
‚Äì 74HC153 Dual 4 to 1 Data Selector/Multiplexer
‚Äì 74HC151 8 to 1 Data Selector/Multiplexer
‚Äì 74HC139 Dual 2 of 4 Decoder
‚Äì 74HC147 10-Decimal to 4-BCD Priority Encoder
‚Äì 74HC148 8 to 3 Octal Priority Encoder
‚Äì 74HC154 4 of 16 Line Decoder/Demultiplexer
‚Äì 74LS47 BCD-7 Segment Decoder/Driver
‚Äì 74HC42 BCD/Decimal Decoder
‚Äì 74HC283 4 Bit Binary Full Adder with Fast Carry
‚Äì 74HC583 4 Bit BCD Full Adder with Fast Carry
‚Äì 74HC182 4 Bit Lookahead Carry Generator
Digital Electronics 2: Sequential and Arithmetic Logic Circuits, First Edition. Tertulien Ndjountche. 
¬© ISTE Ltd 2016. Published by ISTE Ltd and John Wiley & Sons, Inc. 

308
Digital Electronics 2
‚Äì 74HC181 4 Bit ALU/Function Generator
‚Äì 74HC384 8 by 1 Bit Twos-Complement Multiplier
‚Äì 74HC85 4 Bit Magnitude Comparator
‚Äì 74HC365 Hex Buffer W/Common Enable
A1.2. Sequential circuit
‚Äì 74LS279 RS Latch
‚Äì 74HC75 Quad Bistable Transparent Latch
‚Äì 74HC74 Dual D-Flip-Flop with Preset and Clear
‚Äì 74HC109 Dual JK Flip-Flop with Preset and Clear
‚Äì 74HC194 Four Bit Bidirectional Universal Shift Register
‚Äì 74HC670 Four by Four Register File
‚Äì 74HC93 Four Bit Binary Ripple Counter
‚Äì 74HC161 Four Bit Synchronous Counter
‚Äì 74HC699 Binary Up/Down Counter, Synchronous Clear Latch
A1.3. Memory and programmable circuit
‚Äì 74HC189 64 (16 √ó 4) Bit RAM Inverting
‚Äì CY6264 8 K √ó 8 Static RAM
‚Äì Altera: Stratix-10 FPGA; Cyclone V FPGA; Max V CPLD
‚Äì Xilinx: Virtex-7 FPGA; Spartan-6 FPGA; CoolRunner-II CPLD
A1.4. Computer-aided design software
‚Äì Quartus Prime Design Software: www.altera.com
‚Äì ISE Design Suite; Vivado Design Suite: www.xilinx.com

Bibliography
[BRO 08] BROWN S., VRANESIC Z., Fundamentals of digital logic with VHDL design, 3rd
ed., McGraw-Hill Education, New York City, NY, 2008.
[CLE 00] CLEMENTS A., The principles of computer hardware, 3rd ed., Oxford University
Press, Oxford, UK, 2000.
[COM 95] COMER D.J., Digital logic and state machine design, 3rd ed., Oxford University
Press, New York City, NY, 1995.
[DUE 01] DUECK R.K., Digital design with CPLD applications and VHDL, Delmar Thomson
Learning, Albany, NY, 2001.
[GIV 03] GIVONE D., Digital principles and design, McGraw-Hill, New York City, NY, 2003.
[HAY 93] HAYES J.P., Introduction to digital logic design, Addison-Wesley Publishing
Company, Boston, MA, 1993.
[HAY 98] HAYES J.P., Computer architecture and organization, McGraw-Hill, New York
City, NY, 1998.
[KAT 05] KATZ R.H., BORRIELO G., Contemporary logic design, 2nd ed., Prentice Hall,
Upper Saddle River, NJ, 2005.
[MAN 01] MANO M.M., Digital design, 3rd ed., Prentice Hall, Upper Saddle River, NJ, 2001.
[MAR 10] MARCOVITZ A.B., Introduction to logic design, 3rd ed., McGraw-Hill Education,
New York City, NY, 2010.
[NDJ 11] NDJOUNTCHE T., CMOS analog integrated circuits: high-speed and power-efÔ¨Åcient
design, CRC Press, Boca Raton, FL, 2011.
[ROT 04] ROTH JR. C.H., Fundamental of logic design, 5th ed., Brooks/Cole ‚Äì Thomson
Learning, Belmont, CA, 2004.
[SAN 02] SANDIGE R.S., Digital design essentials, Prentice Hall, Upper Saddle River, NJ,
2002.
[TIN 00] TINDER R.F., Engineering digital design, Academic Press, San Diego, CA, 2000.
Digital Electronics 2: Sequential and Arithmetic Logic Circuits, First Edition. Tertulien Ndjountche. 
¬© ISTE Ltd 2016. Published by ISTE Ltd and John Wiley & Sons, Inc. 

310
Digital Electronics 2
[TOC 03] TOCCI R.J., AMBROSIO F.J., Microprocessors and microcomputers, 6th ed.,
Prentice Hall, Upper Saddle River, NJ, 2003.
[WAK 00] WAKERLY J.F., Digital design principles and practices, 3rd ed., Prentice Hall,
Upper Saddle River, NJ, 2000.
[WIL 98] WILKINSON B., The essence of digital design, Prentice Hall Europe, Hemel
Hempstead, UK, 1998.
[YAR 97] YARBROUGH J.M., Digital logic ‚Äì Applications and design, West Publishing
Company, St. Paul, MN, 1997.

Index
A
adder, 117, 257
carry-lookahead, 122
carry-select, 124
carry-skip, 125
ripple-carry, 120
addition, 120, 149
address bus, 196
algorithm, 138, 141, 144, 147, 214, 215,
263
antifuse, 245, 253
arithmetic unit, 164
associative memory, 222
B
Baugh‚ÄìWooley, 141
BCD adder, 165
Booth, 141
built-in self test, 97
bus, 197
C
carry, 125
cascadable, 129, 153
circuit
programmable logic, 245
CPLD, 263
FPGA, 263
PAL, 247, 248
PLA, 247, 248, 257
PROM, 247
CMOS, 178, 179, 183, 186, 188, 190, 200,
253
code
BCD, 214‚Äì216, 263
binary, 214‚Äì216, 263
comparator, 127, 168
comparison, 127, 129
content-addressable memory (CAM), 222
counter, 51, 91, 175
asynchronous, 51
LFSR, 98
linear feedback shift-register, 94
modulo 4, 52
modulo 8, 53
modulo 10, 58
modulo 16, 55
reversible, 64
synchronous, 51
up/down, 64
CPLD, 245, 263, 268, 270
AND bank, 264
macrocell, 264, 270
product term allocator, 264
D, E
data bus, 196
debouncing, 11
decoder, 66, 214, 245, 247, 259, 267, 271,
274, 276, 278, 284, 291, 292
divider, 143, 149
Digital Electronics 2: Sequential and Arithmetic Logic Circuits, First Edition. Tertulien Ndjountche. 
¬© ISTE Ltd 2016. Published by ISTE Ltd and John Wiley & Sons, Inc. 

312
Digital Electronics 2
division
with restoration, 144
without restoration, 144
down counter, 62
DRAM, 203
edge-triggered, 1
EEPLD, 254
EEPROM, 200
electric power, 179
encoder, 274
EPLD, 253
EPROM, 200
F
fan-out, 179
FIFO memory, 224
RAM-based, 225
register-based, 224
Ô¨Çash EEPROM, 200
Ô¨Çip-Ô¨Çop, 1
characteristic, 33
edge-triggered, 24, 29
hold time, 34
JK, 16, 18
level-triggered, 24
master-slave, 20, 22, 24
setup time, 33
T, 18
with asynchronous inputs, 30
FPGA, 245, 263, 270
antifuse based, 271
input/output block, 273
interconnect, 270
look-up table, 264
SRAM based, 272
FRAM, 220
full adder, 119, 163
full subtractor, 149, 158
fundamental mode, 3
fuse, 245, 248, 253
H, I, J
half adder, 117
half subtractor, 149, 158
interconnect, 253
antifuse-based, 253
EEPROM-based, 267
Ô¨Çash-based, 267
fuse-based, 253
network, 269
reprogrammable, 267
SRAM-based, 268
interfacing, 189
inverter, 184
Johnson counter, 93
K, L
Karnaugh, 7, 128, 214, 255
map, 128, 214, 255, 258, 284, 286, 292
L
latch, 1, 33
gated D, 15
gated SR, 11, 14
level sensitive, 16
NAND-gate based, 5
NOR-gate based, 1
race condition, 3
SR, 6
S R, 9
level-triggered, 1
LFSR counter, 98
LIFO, see LIFO memory
LIFO Memory, 225
load factor, 179
logic block, 272
logic equation, 2, 53, 109, 117, 187, 211,
247
logic gate
NAND, 181, 184, 186
NOR, 185
open collector, 182
open drain, 185
logic level, 178
logic unit, 164
look-up table, 263, 264, 266
LUT, see look-up table
M
macrocell, 263, 270
master-slave, 20, 22, 24
master-slave JK Ô¨Çip-Ô¨Çop

Index
313
0‚Äôs catching, 23
1‚Äôs catching, 23
maxterms, 260, 292
memory, 195
access time, 195
CAM, 222
DRAM, 203
EEPROM, 200
EPROM, 200, 201
FIFO, 224
Ô¨Çash EEPROM, 200
FRAM, 220
LIFO, 225
non-volatile, 195, 199
organization, 208
PROM, 200
read cycle, 198
ROM, 199
select fonction, 213
SRAM, 202
timing diagram, 198
volatile, 195, 202
word, 195
write cycle, 198
microcontroller, 228
microprocessor, 117
modulo, 51
MOSFET, 183
multiplicand, 142
multiplier, 136, 141
signed number, 138
unsigned number, 137
N, O, P
noise, 178
number
signed, 138‚Äì140, 143
unsigned, 135, 137
open collector, 182
open drain, 185, 187
PAL, 245, 247
PLA, 245, 247
PLD, 245
PROM, 200, 245, 247
propagation delay, 179
R
race condition, 3
critical, 10
non-critical, 9
RAM, 202
read cycle, 198
register, 85
bidirectional, 88
parallel inputs, 85
serial input, 85
register Ô¨Åle, 90
ring counter, 92
ROM, 199, 245
S
semiconductor memory, see memory
sequential access memory, 223
Shannon, 266
shift register, see register
short-circuit, 100
signature register, 98
SRAM, 202
stack, 225
state diagram, 51, 63
status Ô¨Çag bits, 133
subtraction, 121, 149, 158
supply voltage, 177
switch debouncing, 11
systolic, 138
T, W
technology, 178, 253
three-state buffer, 187
transistor
bipolar, 180
MOS, 177
truth table, 245, 258, 263, 264, 278, 286
TTL, 177‚Äì181, 189, 190
two‚Äôs complement, 138, 160
word, 195
write cycle, 198


Nanoelectromechanical Systems 

Uncertainty Theories and Multisensor Data Fusion 

Wide Band Gap Semiconductor Nanowires 1: Low-Dimensionality Effects 
and Growth 
Wide Band Gap Semiconductor Nanowires 2: Heterostructures and 
Optoelectronic Devices 
Design of Microwave Active Devices 
Non-volatile Memories 
Other titles from 
in
Electronics Engineering 
2015
DURAFFOURG Laurent, ARCAMONE  Julien 
APPRIOU Alain 
 
 
CONSONNI  Vincent, FEUILLET Guy 
LACAZE Pierre Camille, LACROIX Jean-Christophe 
GAUTIER Jean-Luc 

OLED Microdisplays: Technology and Applications 
New Sensors and Processing Chain 

Electromagnetic Compatibility in Power Electronics 
Embedded Systems: Analysis and Modeling with SysML, UML and AADL 
/(7,(&<DQQLFN
Chemistry in Microelectronics

Electromagnetism: Maxwell Equations, Wave Propagation and Emission 
Chemical Sensors and Biosensors 
Instrumentation and Metrology in Oceanography 
Numerical Analysis in Electromagnetics: The TLM Method

Microwaves Photonic Links: Components and Circuits
Silicon Technologies: Ion Implantation and Thermal Treatment 
Electromagnetic Reverberation Chambers 
TEMPLIER Fran√ßois 
THOMAS Jean-Hugh, YAAKOUBI Nourdin 
COSTA Fran√ßois, GAUTIER Cyrille, LABOURE Eric, REVOL Bertrand 
KORDON Fabrice, HUGUES J√©r√¥me, CANALS Agusti, DOHET Alain 
BECHERRAWY Tamer 
LALAUZE Ren√© 
 
 
SAGUET Pierre 
ALGANI Catherine, RUMELHARD Christian, BILLABERT Anne-Laure 
BAUDRANT Annie 
BESNIER Philippe, D√âMOULIN Bernard 
LE MENN Marc 

Integration of Ferroelectric and Piezoelectric Thin Films: Concepts ans 
Applications for Microsystems 
Ferroelectric Dielectrics Integrated on Silicon 
Nano-lithography 

Lithography 
VHF / UHF Filters and Multicouplers

Silicon Non-volatile Memories / Paths of Innovation
Optoelectronic Sensors
Chemical and Biological Microsensors / Applications in Fluid Media 
Physics and Operation of Silicon Devices in Integrated Circuits 
Solid-State Physics for Electronics 
Power Electronics Semiconductor Devices 
Passive RF Integrated Circuits
DEFAY Emmanuel 
DEFAY Emmanuel 
LANDIS Stefan 
LANDIS Stefan 
PIETTE Bernard 
DE SALVO Barbara 
DECOSTER Didier, HARARI Joseph 
FABRY Pierre, FOULETIER Jacques 
GAUTIER Jacques 
MOLITON Andr√© 
PERRET Robert 
SAGUET Pierre 


Electromagnetism and Interconnections 

Modern Sensors Handbook

CHARRUAU St√©phane 
RIPKA Pavel, TIPEK Alois 

WILEY END USER LICENSE AGREEMENT
Go to www.wiley.com/go/eula to access Wiley‚Äôs ebook EULA.






