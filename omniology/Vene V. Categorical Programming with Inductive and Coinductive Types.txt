DISSERTATIONES MATHEMATICAE UNIVERSITATIS TARTUENSIS
23
CATEGORICAL PROGRAMMING
WITH
INDUCTIVE AND COINDUCTIVE
TYPES
VARMO VENE
TARTU 2000


DISSERTATIONES MATHEMATICAE UNIVERSITATIS TARTUENSIS
23


DISSERTATIONES MATHEMATICAE UNIVERSITATIS TARTUENSIS
23
CATEGORICAL PROGRAMMING
WITH
INDUCTIVE AND COINDUCTIVE
TYPES
VARMO VENE
TARTU 2000

Faculty of Mathematics, University of Tartu, Estonia
Dissertation accepted for public defense of the degree of Doctor of Philosophy
(PhD) on May 26, 2000 by the Council of the Faculty of Mathematics, University
of Tartu.
Opponent:
PhD, University Lecturer
Jeremy Gibbons
Oxford University Computing Laboratory
Oxford, England
The public defense will take place on Sept. 3, 2000.
The publication of this dissertation was ï¬nanced by Institute of Computer Science,
University of Tartu.
câƒVarmo Vene, 2000
Tartu Â¨Ulikooli Kirjastuse trÂ¨ukikoda
Tiigi 78, 50410 Tartu
Tellimus nr. 365

CONTENTS
1
Introduction
9
1.1
Motivation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9
1.2
Overview of the thesis
. . . . . . . . . . . . . . . . . . . . . . .
12
1.3
Notation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
14
2
Inductive and coinductive types
15
2.1
Initial algebras and catamorphisms . . . . . . . . . . . . . . . . .
15
2.2
Terminal coalgebras and anamorphisms
. . . . . . . . . . . . . .
22
2.3
Implementation in Haskell . . . . . . . . . . . . . . . . . . . . .
26
2.4
Related work
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
31
3
Primitive (co)recursion
33
3.1
Primitive recursion via tupling . . . . . . . . . . . . . . . . . . .
33
3.2
Paramorphisms . . . . . . . . . . . . . . . . . . . . . . . . . . .
35
3.3
Apomorphisms . . . . . . . . . . . . . . . . . . . . . . . . . . .
40
3.4
Para- and apomorphisms in Haskell
. . . . . . . . . . . . . . . .
43
3.5
Related work
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
45
4
Course-of-value (co)iteration
47
4.1
Course-of-value iteration via memoization . . . . . . . . . . . . .
47
4.2
Histomorphisms . . . . . . . . . . . . . . . . . . . . . . . . . . .
50
4.3
Futumorphisms . . . . . . . . . . . . . . . . . . . . . . . . . . .
55
4.4
Histo- and futumorphisms in Haskell . . . . . . . . . . . . . . . .
58
4.5
Related work
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
61
5
Mendler-style inductive types
63
5.1
Mendler-style inductive types: covariant case
. . . . . . . . . . .
63
5.2
Conventional inductive types reduced to Mendler-style inductive
types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
66
5.3
Mendler-style inductive types: mixed variant case . . . . . . . . .
69
5.4
Restricted existential types . . . . . . . . . . . . . . . . . . . . .
72
5

5.5
Mendler-styles inductive types reduced to conventional inductive
types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
75
5.6
Mendler-style inductive types in Haskell . . . . . . . . . . . . . .
78
5.7
Related work
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
82
6
Mendler-style recursion schemes
83
6.1
Simple iteration . . . . . . . . . . . . . . . . . . . . . . . . . . .
84
6.2
Primitive recursion . . . . . . . . . . . . . . . . . . . . . . . . .
85
6.3
Course-of-value iteration . . . . . . . . . . . . . . . . . . . . . .
89
6.4
Mendler-style recursion operators in Haskell . . . . . . . . . . . .
94
6.5
Related work
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
97
7
Conclusions
99
7.1
Summary
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
99
7.2
Future work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100
References
102
KokkuvËœote
109
Acknowledgements
111
6

LIST OF ORIGINAL PUBLICATIONS
1. Varmo Vene and Tarmo Uustalu. Functional programming with apomor-
phisms (corecursion). Proceedings Estonian Academy of Sciences: Phys.,
Maths., 47(3):147â€“161. Sept. 1998.
2. Tarmo Uustalu and Varmo Vene. Primitive (co)recursion and course-of-
value (co)iteration, categorically. INFORMATICA, 10(1):5â€“26, March 1999.
3. Tarmo Uustalu and Varmo Vene. Mendler-style inductive types, categori-
cally. Nordic Journal of Computing, 6(3):343â€“361. Autumn 1999.
4. Tarmo Uustalu and Varmo Vene. Coding recursion a la Mendler (extended
abstract). In J. Jeuring, ed., Proceedings 2nd Workshop on Generic Pro-
gramming, WGPâ€™2000, Ponte de Lima, Portugal, 6 July 2000, Tech. Report
UU-CS-2000-19, Dept. of Computer Science, Utrecht Univ., pp. 69â€“85.
June 2000.
7

8

CHAPTER 1
INTRODUCTION
1.1
Motivation
Data types are one of the key components of every program. They allow to or-
ganize values according to their purpose and properties. Already the very ï¬rst
programming languages had some concept of data types, containing at least a
ï¬xed collection of base types, like integers, reals, characters, but also means to
form compound data types like records, arrays or lists. Soon it was realized (e.g.
by Hoare [Hoa72]) that the structure of a program is intimately related with to the
data structures it uses. Hence the ability to express and manipulate complex data
structures in a ï¬‚exible and intuitive way is an important measure of the usability
and expressiveness of a programming language. Especially notable in this respect
are modern functional languages like Haskell [PJH99] and ML [MTHM97] which
possess rich type systems supporting algebraic data types, polymorphism, static
type checking, etc.
In this thesis we explore two particular kinds of data types, inductive and
coinductive types, and several programming constructs related to them. The char-
acteristic property of inductive types (like natural numbers or lists) is that they
provide very simple means for construction of data structures, but in order to use
these values one often needs recursion. Coinductive types (like streams, possibly
inï¬nite lists) are dual to inductive ones. They come together with basic operations
to destruct the values, however, their construction often involves recursion. Gen-
eral recursion can be quite difï¬cult to reason about, and it is sometimes called the
goto of functional programming.
In this thesis we use a categorical theory of initial algebras and terminal coal-
gebras as the abstract framework for inductive and coinductive types. This ap-
proach is attractive, as it equips (co)inductive types with generic (co)iteration op-
erations. As these operations capture a very simple form of recursion, namely
the structural (co)recursion, they are very easy to reason about. While the class
9

of functions expressible easily in terms of (co)iteration is quite large, not all
useful functions fall under it. The main objective of this thesis is to ï¬nd new
(co)recursive operations which capture some useful programming constructs, but
still possess nice reasoning properties.
Algebraic data types in Haskell
Algebraic data types as provided by Haskell are intuitive yet powerful way to de-
scribe data structures. Essentially, new data types are deï¬ned by listing all possi-
ble canonical ways to construct its values. For instance, the following declaration
in Haskell deï¬nes a new data type Shape together with two data constructors:
data Shape = Circle Float | Rectangle Float Float
Functions can manipulate such data types using pattern matching to â€œdestructâ€
the data structure into its components:
perimeter :: Shape -> Float
perimeter (Circle r)
= 2 * pi * r
perimeter (Rectangle h w) = 2 * (h + w)
Data deï¬nitions can be recursive allowing to describe data structures of varying
size. For instance, below are deï¬ned natural numbers and (polymorphic) lists as
recursive data types:
data Nat
= Zero | Succ Nat
data List a = Nil
| Cons a (List a)
Functions which operate on recursive data types are often recursive too. For in-
stance, below is deï¬ned a function which ï¬nds the sum of the elements in the
argument list (here we use the standard notation for lists in Haskell, where []
denotes the empty list, i.e. the Nil constructor above, and (:) corresponds to
the Cons constructor):
sum
:: [Int] -> Int
sum []
= 0
sum (x:xs) = x + sum xs
The deï¬nition can be read as follows: the sum of the empty list is 0; in the case of
non-empty list, the sum of the whole list is obtained by adding the head of the list
to the sum of the tail of the list.
10

Folds
The same recursion pattern, occurs so often when deï¬ning list processing func-
tions, that Haskell provides a standard higher-order function which captures its
essence:
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr f b []
= b
foldr f b (x:xs) = f x (foldr f b xs)
For instance, the sum function can be deï¬ned using foldr as follows:
sum = foldr (+) 0
Below are some other useful functions deï¬ned as instances of foldr:
length
= foldr (\x n -> 1+n) 0
xs ++ ys = foldr (:) ys xs
map f
= foldr (\x xs -> f x : xs) []
The ï¬rst function computes the the length of the argument list, the second concate-
nates two lists, and ï¬nally, the third maps the given function to the every element
of the argument list.
The function foldr has a very nice algebraic reading: it â€œreplacesâ€ the binary
list constructor (:) by a binary function f, and the empty list [] by a constant
b; i.e. foldr f b is a homomorphism between the algebras formed by list con-
structors and by f and b. This observation leads naturally to the generalization
of foldr to other algebraic data types, and forms the basis of the categorical
treatment of the inductive data types. For instance, the function which â€œreplacesâ€
constructors of natural numbers can be deï¬ned as follows:
foldNat :: (a -> a) -> a -> Nat -> a
foldNat f b Zero
= b
foldNat f b (Succ n) = f (foldNat f b n)
Calculating with folds
The function foldr satisï¬es two important laws. The ï¬rst law, known as identity
law, is rather obvious. It states that â€œreplacingâ€ the constructor functions with
themselves gives the identity function:
foldr (:) [ ] = id
The second law, known as fusion law, gives conditions under which intermediate
values produced by folding can be eliminated:
h (f a b) = g a (h b)
â‡’
h â—¦foldr f b = foldr g (h b)
11

To illustrate the use of these laws (and also the structured calculational proof
style [Gru96] we use throughout the thesis) we give a proof of the fact, that map
is a functor. First, the proof that map preserves identities:
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
map id
=
â€“ deï¬nition of map â€“
foldr(Î»x xs â†’id x : xs) [ ]
=
â€“ deï¬nition of id â€“
foldr(:) [ ]
=
â€“ identity law â€“
id
Next, we use fusion to show that map preserves compositions:
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
map f â—¦map g
=
â€“ deï¬nition of map â€“
map f â—¦foldr(Î»x xs â†’g x : xs) [ ]
=
â€“ fusion law â€“
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
map f (g a : [ ])
=
â€“ deï¬nition of map â€“
foldr(Î»x xs â†’f x : xs) [ ] (g a : [ ])
=
â€“ deï¬nition of foldr â€“
f(g a) : foldr(Î»x xs â†’f x : xs) [ ] [ ]
=
â€“ deï¬nition of map â€“
f(g a) : map f [ ]
foldr(Î»x xs â†’f(g x) : xs) [ ]
=
â€“ deï¬nition of map â€“
map (f â—¦g)
The identity and fusion law for foldr can be proved by induction over lists.
However, in categorical treatment of the inductive data types as initial algebras,
these laws are simple corollaries of the initiality. Hence they are not speciï¬c to
foldr and folds for any inductive data type satisfy similar laws.
1.2
Overview of the thesis
In this thesis we develop new recursion combinators that capture more complex
recursion patterns than simple (co)iteration but still possess nice reasoning prop-
erties. In particular, we consider combinators for primitive (co)recursion and
course-of-value (co)iteration.
It is well known that the primitive recursion can be simulated by a simple it-
eration which computes a value paired together with the argument, and that this
12

construction leads to the notion of paramorphism which captures the primitive re-
cursion directly. We will show, that the obvious dualization of this construction
leads to notion of apomorphism which captures the recursion pattern known as
primitive corecursion. More importantly, we will also show that a more involved
generic simulation of memoization by iteration leads to the notion of histomor-
phism, a direct formalization of course-of-value iteration, and describe the dual
notion of futumorphism, a formalization of course-of-value coiteration.
Inspired by type-theoretic work by N. P. Mendler [Men87, Men91], we will
introduce the concepts of Mendler-style algebra and homomorphism and treat in-
ductive types as initial Mendler-style algebras. From that basis, we will introduce
Mendler-style analogs for the cata, para and histo combinators. From the theory
developed, it appears that Mender-style recursion combinators are just as well-
suited for program calculation as the conventional ones, but support a program-
ming style more close to customary (general-)recursive programming.
The remainder of the thesis is organized as follows: Chapter 2 reviews the
conventional treatment of inductive and coinductive types as initial algebras and
terminal coalgebras of a functor. The calculational properties of basic iteration
and coiteration are studied.
Chapter 3 studies the properties of operators corresponding to primitive recur-
sion and corecursion. This is the ï¬rst chapter which contains our original contri-
bution. Namely, we formalize primitive corecursive functions as apomorphisms,
and show their utility on several simple examples (the â€œstandardâ€ example being
the concatenation of two colists).
The next three chapters contain our main contribution to the theory of cate-
gorical data types.
Chapter 4 is devoted to course-of-value iteration and coiteration. They are
formalized respectively as histo- and futumorphisms, the latter being functions
which generate several elements of codata type at once.
Chapter 5 presents an alternative treatment of inductive types as initial Mend-
ler-style algebras. It shows that, in the case of covariant functor, the conventional
treatment coincides with the Mendler-style one. However, Mendler-style induc-
tive types can be deï¬ned also for mixed variant base functor. In this case, it is
shown, that if certain restricted existential types are available, then Mendler-style
inductive types are equivalent with the conventional ones, but for a different (co-
variant) functor.
Chapter 6 uses Mendler-style algebras to deï¬ne recursion operators which
operate on conventional inductive types. Mendler-style versions of cata-, para-
and histomorphisms are formalized and their properties are studied.
The concluding chapter 7 outlines possible future work.
13

1.3
Notation
Throughout the thesis C is the default category, in which we shall assume the
existence of ï¬nite products (Ã—, 1) and coproducts (+, 0), as well as the distribu-
tivity of products over coproducts (i.e. C is distributive). The typical example of a
distributive category is Set â€” the category of sets and total functions.
We make use of the following quite standard notation. Given two objects A,
B, we write fst : A Ã— B â†’A and snd : A Ã— B â†’B to denote the left and
right projections for the product A Ã— B. For f : C â†’A and g : C â†’B,
pairing (we also use name fork) is the unique arrow âŸ¨f, g âŸ©: C â†’A Ã— B, such
that fst â—¦âŸ¨f, g âŸ©= f and snd â—¦âŸ¨f, g âŸ©= g. The left and right injections for the
coproduct A + B are inl : A â†’A + B and inr : B â†’A + B. For f : A â†’C
and g : B â†’C, case analysis (we also use name join) is the unique morphism
[ f, g ] : A + B â†’C, such that [ f, g ] â—¦inl = f and [ f, g ] â—¦inr = g. Besides,
given an object C, we have the unique morphism !C : C â†’1. The inverse of the
canonical map [ inl Ã— id, inr Ã— id ] : (AÃ—C)+(BÃ—C) â†’(A+B)Ã—C is denoted
by distr : (A+B)Ã—C â†’(AÃ—C)+(B Ã—C). Finally, given a predicate p : A â†’
1 + 1, the guard p? : A â†’A + A is deï¬ned as (snd + snd) â—¦distr â—¦âŸ¨p, idA âŸ©.
14

CHAPTER 2
INDUCTIVE AND COINDUCTIVE
TYPES
In this chapter we review the traditional treatment of inductive and coinductive
types as initial algebras and terminal coalgebras of a functor.
2.1
Initial algebras and catamorphisms
Deï¬nition 2.1 (algebra)
Let F : C â†’C be an endofunctor on category C. An F-algebra is a pair (C, Ï•),
where C is an object and Ï• : FC â†’C an arrow in the category C. The object C
is the carrier and the functor F is the signature of the algebra.
Deï¬nition 2.2 (algebra homomorphism)
Let (C, Ï•) and (D, Ïˆ) be two F-algebras.
A homomorphism from (C, Ï•) to
(D, Ïˆ) is an arrow f : C â†’D in the category C, such that
f â—¦Ï• = Ïˆ â—¦F f
i.e. makes the following diagram to commute:
F C
Ï•
/
F f

C
f

F D
Ïˆ
/ D
15

For any F-algebra, the identity arrow on its carrier is a homomorphism from
it to itself and also the composition of two homomorphisms is always a homo-
morphism, so we can deï¬ne a category where objects are F-algebras and arrows
are homomorphisms between them. However we have to be a little careful, as the
same arrow from the base category can be homomorphism between more than one
pair of F-algebras. For instance, the identity arrow idC is a homomorphism from
any F-algebra with carrier C to itself.
Deï¬nition 2.3 (category of algebras)
The category of F-algebras over C â€” Alg(F) â€” is deï¬ned by:
â€¢ Objects: F-algebras; i.e. arrows Ï• of C such that dom Ï• = F(cod Ï•).
â€¢ Arrows: triples (f, Ï•, Ïˆ) : Ï• â†’Ïˆ where Ï• and Ïˆ are F-algebras and
f : cod Ï• â†’cod Ïˆ is a homomorphism from Ï• to Ïˆ.
â€¢ Identity: idÏ• = (idcod Ï•, Ï•, Ï•).
â€¢ Composition: (f, Ï•2, Ï•3) â—¦(g, Ï•1, Ï•2) = (f â—¦g, Ï•1, Ï•3).
Deï¬nition 2.4 (initial algebra)
A F-algebra (ÂµF, in) is the initial F-algebra if for any F-algebra (C, Ï•) there exists
a unique arrow L Ï• M : ÂµF â†’C making the following diagram commute:
F ÂµF
in
/
F L Ï• M

ÂµF
L Ï• M

F C
Ï•
/ C
i.e. satisfying the universal property:
f â—¦in = Ï• â—¦F f
â‰¡
f = L Ï• M
cata-CHARN
The arrows in form L Ï• M are called catamorphisms (derived from the Greek prepo-
sition ÎºÎ±Ï„Î± meaning â€˜downwardsâ€™).
In other words, the initial algebra (ÂµF, in) is an initial object in the category
Alg(F), and the catamorphism L Ï• M is the mediating arrow out of it.
The initial F-algebra may or may not exist. It is guaranteed to exist if F is
Ï‰-cocontinuous (i.e. it preserves the colimits of Ï‰-chains). All polynomial func-
tors (i.e. functors built up from products, sums, the identity functor, and constant
functors) are Ï‰-cocontinuous and, hence, the initial algebras for them exist.
16

Corollary 2.1 Let (ÂµF, in) be an initial F-algebra.
â€¢ Cancellation: For any F-algebra Ï• : FC â†’C
L Ï• M â—¦in = Ï• â—¦F L Ï• M
cata-SELF
â€¢ Reï¬‚ection:
id = L in M
cata-REFL
â€¢ Fusion: For any F-algebras Ï• : FC â†’C, Ïˆ : FD â†’D and an arrow
f : C â†’D
f â—¦Ï• = Ïˆ â—¦F f
â‡’
f â—¦L Ï• M = L Ïˆ M
cata-FUSION
Intuitively, the initial algebra in : FÂµF â†’ÂµF denotes the collection of con-
structor functions for inductive data type ÂµF, and the catamorphism is a simple
iteration. When read from left to right, the cancellation law can be viewed as the
reduction rule for terms where catamorphism is applied to a data constructor. The
reduction proceeds recursively by systematically replacing data constructors with
some algebra with same signature. If constructors are replaced by themselves
nothing is changed. This is exactly what the reï¬‚ection law claims.
The formal justiï¬cation on the identiï¬cation of inductive types with initial al-
gebras is given by the following fundamental theorem, known as Lambek lemma.
Its proof, albeit simple, provides a nice example of using above mentioned laws
in action.
Theorem 2.2 (Lambek [Lam68]) The initial algebra inF : FÂµF â†’ÂµF is an
isomorphism with the inverse deï¬ned as
inâˆ’1 = L F in M
in-inv-DEF
Proof. Note that inâˆ’1 has indeed the right typing; i.e. inâˆ’1 : ÂµF â†’FÂµF. We
have to show that it is the pre- and post-inverse of the in. For the ï¬rst we argue:
ï£®
ï£¯ï£¯ï£¯ï£¯ï£°
in â—¦L F in M
=
â€“ cata-FUSION â€“
L in M
=
â€“ cata-REFL â€“
id
17

To show that it is also the post-inverse, we make use of the just shown fact (in the
step marked â€œsee aboveâ€):
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
L F in M â—¦in
=
â€“ cata-SELF â€“
F in â—¦F L F in M)
=
â€“ F functor â€“
F (in â—¦L F in M)
=
â€“ see above â€“
F id
=
â€“ F functor â€“
id
The theorem shows that the carrier of the initial algebra is (up to isomorphism)
a ï¬xed point of the functor. In fact, initial algebras generalize the notion of the
least ï¬xed point from lattice theory in the sense that if the base category is a
preorder and thus an endofunctor is a monotonic function then the carrier of the
initial algebra is the least ï¬xed point of the given function.
Example 2.1 (empty type)
In the category Set of sets and functions, the pair (âˆ…, idâˆ…) is the initial algebra of
the identity functor with the unique arrow out of âˆ…as the required unique homo-
morphism. More generally, in any category with initial object, the pair (0, id0) is
the initial Id-algebra.
Example 2.2 (naturals)
Consider the set Nat = {0, 1, 2, . . . } of natural numbers with its zero and succes-
sor function zero : 1 â†’Nat and succ : Nat â†’Nat deï¬ned by:
zero ()
=
0
succ n
=
n + 1.
Using join, these functions combine into a single function [ zero, succ ] : 1 +
Nat â†’Nat, forming an algebra of the functor N(X) = 1 + X. In fact, the pair
(Nat, [ zero, succ ]) is the initial N-algebra; i.e. ÂµN = Nat and in = [ zero, succ ].
To show this, assume an arbitrary N-algebra (C, Ï•). We have to ï¬nd a function
f : Nat â†’C which is homomorphism and it should be unique. Because of every
arrow out of sum is join, Ï• = [ c, h ] for some constant c : 1 â†’C and arrow
h : C â†’C. So, the homomorphism condition for N-algebras states that f should
18

make the following diagram commute
1
zero
/
c
'O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
O
Nat
f

Nat
succ
o
f

C
C
h
o
i.e. satisï¬es two equations
f â—¦zero
=
c
f â—¦succ
=
h â—¦f.
But this equation system has exactly one solution, namely the function deï¬ned by
n 7â†’hn(c()), which gives to us the required unique homomorphism.
For instance, the sum and product of two naturals can be deï¬ned as follows:
add(n, m)
=
L [ Î»x.m, succ ] M(n)
mul(n, m)
=
L [ Î»x.m, Î»x.add(m, x) ] M(n).
The predecessor function pred : Nat â†’1 + Nat which maps 0 7â†’inl() and
n + 1 7â†’inr n can be deï¬ned by
pred = L id +[ zero, succ ] M
i.e. it is the inverse of the initial N-algebra.
Parametric data types can be easily modeled by initial algebras using bifunc-
tors as their signatures. Let F : C Ã— C â†’C be a bifunctor, then for any object A
we have an endofunctor FA : C â†’C deï¬ned as FA(X) = F(A, X).
Example 2.3 (lists)
The data type of lists over a given set A can be represented as the initial algebra
(ÂµLA, in) of the functor LA deï¬ned by LA(X) = 1 + (A Ã— X). Denote ÂµLA by
List(A). The constructor functions nil : 1 â†’List(A) and cons : AÃ—List(A) â†’
List(A) are deï¬ned by
nil
=
in â—¦inl
cons
=
in â—¦inr,
so in = [ nil, cons ]. Given any two functions c : 1 â†’C and h : A Ã— C â†’C,
the catamorphism f = L [ c, h ] M : List(A) â†’C is the unique solution of the
equation system
f â—¦nil
=
c
f â—¦cons
=
h â—¦(id Ã—f),
19

i.e., foldr(c, h) from functional programming. For instance, the function length :
List(A) â†’Nat which ï¬nds the length of the list, can be deï¬ned as catamorphism
length = L [ zero, Î»(a, n).succ(n) ] M.
As another example, the function concat : List(A)Ã—List(A) â†’List(A), which
concatenates two lists, can be deï¬ned as catamorphism
concat(xs, ys) = L [ Î»x.ys, cons ] M(xs).
Finally, the function map(f) : List(A) â†’ListB, which applies the function
f : A â†’B to every element of the argument list, can be deï¬ned as follows
map(f) = L [ nil, cons â—¦(f Ã— id) ] M.
Lots of other examples about list catamorphisms (i.e. function foldr) can be found
in any functional programming textbook (e.g. [Bir98]).
Example 2.4 (binary trees)
Consider the bifunctor B(A, X) = A + X Ã— X. The initial BA-algebra deï¬nes
the data type of binary (leaf) trees Btree(A) = ÂµBA with a constructor functions
leaf
= in â—¦inl
: A â†’Btree(A)
branch = in â—¦inr
: Btree(A) Ã— Btree(A) â†’Btree(A)
For instance, a binary tree of naturals with three leafs can be constructed as
branch(branch(leaf (1), leaf (2)), leaf (3)).
Given any functions l : A â†’C and b : C Ã— C â†’C, the catamorphism f =
L [ l, b ] M : Btree(A) â†’C is the unique solution of the equation system
f â—¦leaf
=
l
f â—¦branch
=
b â—¦(f Ã— f).
For instance, the function ï¬‚atten : Btree(A) â†’List(A), which collects ele-
ments in leaves into list in left-to-right order, can be deï¬ned as
ï¬‚atten = L [ unit, concat ] M,
where unit(x) = cons(x, nil) : A â†’List(A) is a function which converts
an element into singleton list, and concat the list concatenation function from
Example 2.3.
20

It is well known from functional programming that the type constructor List
together with the function map form a functor. The next theorem shows that lists
are not exceptional in this respect and every similarly deï¬ned parametric data type
can be extended to a functor.
Theorem 2.3 Let F : C Ã— C â†’C be a bifunctor, such that and for any object A
there exists initial FA-algebra (ÂµFA, in). Then, the mapping T(A) = ÂµFA can
extended to the endofunctor on C by deï¬ning
T(f) = L in â—¦F(f, id) M
data-map-DEF
The functor T : C â†’C is called a data functor of F.
Proof. Note that deï¬nition above has the right typing. We have to show that T
preserves identities and composition. First, identities:
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
T id
=
â€“ data-map-DEF â€“
L in â—¦F(id, id) M
=
â€“ F bifunctor â€“
L in M
=
â€“ cata-REFL â€“
id
For the composition, we show that T(f) is a homomorphism from in â—¦F(g, id) to
in â—¦F(f â—¦g, id) and then use cata-FUSION:
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
Tf â—¦Tg
=
â€“ data-map-DEF â€“
Tf â—¦L in â—¦F(g, id) M
=
â€“ cata-FUSION â€“
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
Tf â—¦in â—¦F(g, id)
=
â€“ data-map-DEF â€“
L in â—¦F(f, id) M â—¦in â—¦F(g, id)
=
â€“ cata-SELF â€“
in â—¦F(f, id) â—¦F(id, L in â—¦F(f, id) M) â—¦F(g, id)
=
â€“ F bifunctor â€“
in â—¦F(f â—¦g, id) â—¦F(id, L in â—¦F(f, id) M)
=
â€“ data-map-DEF â€“
in â—¦F(f â—¦g, id) â—¦F(id, Tf)
L in â—¦F(f â—¦g, id) M
=
â€“ data-map-DEF â€“
T(f â—¦g)
21

Example 2.5 (bushes)
Consider the bifunctor B(A, X) = A Ã— List(B(A, X)). The initial BA-algebra
deï¬nes the data type of bushes (ï¬nitely branching trees) Bush(A) = ÂµBA with a
constructor function node = in : A Ã— List(Bush(A)) â†’Bush(A). Given any
function h : A Ã— List(C) â†’C, the catamorphism f = L h M : Bush(A) â†’C is
the unique solution of the equation
f â—¦node = h â—¦(id Ã—map(f)),
where map(f) : List(Bush(A)) â†’List(C) is the map function on lists deï¬ned
in Example 2.3.
2.2
Terminal coalgebras and anamorphisms
We now dualize the material about initial algebras and catamorphisms.
Deï¬nition 2.5 (coalgebra)
Let F : C â†’C be an endofunctor on category C. A F-coalgebra is a pair (C, Ï•),
where C is an object and Ï• : C â†’FC an arrow in the category C. The object C
is the carrier and the functor F is the signature of the coalgebra.
Deï¬nition 2.6 (coalgebra homomorphism)
Let (C, Ï•) and (D, Ïˆ) be two F-coalgebras. A homomorphism from (C, Ï•) to
(D, Ïˆ) is an arrow f : C â†’D in the category C, such that
Ïˆ â—¦f = F f â—¦Ï•
i.e. makes the following diagram to commute:
C
Ï•
/
f

F C
F f

D
Ïˆ
/ F D
Similarly to homomorphisms between algebras, homomorphisms between co-
algebras compose with identity arrow as the identity homomorphism.
Deï¬nition 2.7 (category of coalgebras)
The category of F-coalgebras over C â€” CoAlg(F) â€” is deï¬ned by:
â€¢ Objects: F-coalgebras; i.e. arrows Ï• of C such that cod Ï• = F(dom Ï•).
22

â€¢ Arrows: triples (f, Ï•, Ïˆ) : Ï• â†’Ïˆ where Ï• and Ïˆ are F-coalgebras and
f : dom Ï• â†’dom Ïˆ is a homomorphism from Ï• to Ïˆ.
â€¢ Identity: idÏ• = (iddom Ï•, Ï•, Ï•).
â€¢ Composition: (f, Ï•2, Ï•3) â—¦(g, Ï•1, Ï•2) = (f â—¦g, Ï•1, Ï•3).
Deï¬nition 2.8 (terminal coalgebra)
A F-coalgebra (Î½F, out) is the terminal F-coalgebra if for any F-coalgebra (C, Ï•)
there exists unique arrow [( Ï• )] : C â†’Î½F making the following diagram com-
mute:
C
Ï•
/
[( Ï• )]

F C
F [( Ï• )]

Î½F
out
/ F Î½F
i.e. satisfying the universal property:
out â—¦f = F f â—¦Ï•
â‰¡
f = [( Ï• )]
ana-CHARN
The arrows in form [( Ï• )] are called anamorphisms (derived from the Greek prepo-
sition Î±Î½Î± meaning â€˜upwardsâ€™; the name is due to Meijer).
In other words, the terminal coalgebra (Î½F, out) is the terminal object in the
category CoAlg(F), and the anamorphism [( Ï• )] is the mediating arrow out of it.
Corollary 2.4 Let (Î½F, out) be a terminal F-coalgebra.
â€¢ Cancellation: For any F-coalgebra Ï• : C â†’FC
out â—¦[( Ï• )] = F [( Ï• )] â—¦Ï•
ana-SELF
â€¢ Reï¬‚ection:
id = [( out )]
ana-REFL
â€¢ Fusion: For any F-coalgebras Ï• : C â†’FC, Ïˆ : D â†’FD and an arrow
f : C â†’D
Ïˆ â—¦f = F f â—¦Ï•
â‡’
[( Ïˆ )] â—¦f = [( Ï• )]
ana-FUSION
23

Terminal coalgebras satisfy the dual version of the Lambek lemma stating that
their carriers are ï¬xed points of F.
Corollary 2.5 The terminal coalgebra out : Î½F â†’F Î½F is an isomorphism with
the inverse outâˆ’1 : FÎ½F â†’Î½F deï¬ned as follows
outâˆ’1 = [( F out )]
out-inv-DEF
Dually to initial algebras, terminal coalgebras generalize the notion of the
greatest ï¬xed point, as the carrier of the terminal coalgebra for a monotonic end-
ofunction over preorder is the the greatest ï¬xed point of the given function.
Example 2.6 (unit type)
In the category Set, the pair ({â‹†}, id{â‹†}) is the terminal coalgebra of the identity
functor, where {â‹†} is a one element set. The unique arrow into {â‹†} is the required
unique homomorphism. More generally, in any category with terminal object, the
pair (1, id1) is the terminal Id-coalgebra.
Example 2.7 (conaturals)
Consider the endofunctor N(X) = 1 + X from Example 2.2. Recall that its
initial algebra is given by the set Nat = {0, 1, 2, . . . } of natural numbers together
with the join of zero and successor function as algebra structure [ zero, succ ] :
1 + Nat â†’Nat. The inverse of the initial algebra pred : Nat â†’1 + Nat is a
N-coalgebra, but it is not terminal.
The terminal N-coalgebra is given by the pair (CoNat, pred), where CoNat =
{0, 1, 2, . . . }âˆª{âˆ} is the set of natural numbers augmented with an extra element
âˆ, and pred : CoNat â†’1 + CoNat is the predecessor function
pred 0
=
inl ()
pred (n + 1)
=
inr n
pred âˆ
=
inr âˆ.
Given an arbitrary N-coalgebra (C, f), there exists a unique function g = [( f )] :
C â†’CoNat satisfying
pred(g(x)) =
 inl ()
if f(x) = inl ()
inr(g(y))
if f(x) = inr y
For instance, consider the function f : CoNat Ã—CoNat â†’1+(CoNat Ã—CoNat)
deï¬ned by
f(x, y) =
ï£±
ï£²
ï£³
inl ()
if pred(x) = pred(y) = inl ()
inr(xâ€², y)
if pred(x) = inr xâ€²
inr(x, yâ€²)
if pred(x) = inl (), pred(y) = inr yâ€²,
24

i.e. an N-coalgebra with carrier CoNat Ã—CoNat. The anamorphism add = [( f )] :
CoNat Ã— CoNat â†’CoNat deï¬nes the addition function on conaturals.
Because the sum appears in the target, we cannot decompose an N-coalgebra
into simpler components in general. Often, however, the N-coalgebra is in the
form f = (!C +h)â—¦p? for some predicate p : C â†’Bool and function h : C â†’C.
In this case, the homomorphism condition translates to
pred(g(x)) =
 inl ()
if p(x)
inr(g(h(x)))
otherwise.
Parametric coinductive types can be modeled by terminal coalgebras using
bifunctors as their signatures. Also, the resulting type constructor can be extended
to a functor.
Corollary 2.6 Let F : C Ã— C â†’C be a bifunctor, such that and for any object A
there exists terminal FA-coalgebra (Î½FA, out). Then, the mapping T(A) = Î½FA
can extended to the endofunctor on C by deï¬ning
T(f) = [( F(f, id) â—¦out )]
codata-map-DEF
The functor T : C â†’C is called a codata functor of F.
Example 2.8 (streams)
The codata type of streams over a given set A is nicely represented by the terminal
coalgebra (Î½SA, out) of the bifunctor S(A, X) = A Ã— X. Write Stream(A)
for Î½SA. The functions head : Stream(A) â†’A and tail : Stream(A) â†’
Stream(A) equal fst â—¦out and snd â—¦out, respectively. Given any two functions
c : C â†’A and h : C â†’C, the anamorphism [( âŸ¨c, h âŸ©)] is the unique solution
f : C â†’StreamA of the equation system
head â—¦f
=
c
tail â—¦f
=
f â—¦h.
The function nats : Nat â†’Stream(Nat), which returns the stream of all natural
numbers starting with the natural number given as the argument, is the unique
solution of the equation system
head â—¦nats
=
id
tail â—¦nats
=
nats â—¦succ,
and is thus deï¬nable as the anamorphism [( âŸ¨id, succ âŸ©)].
25

The function zip : Stream(A) Ã— Stream(B) â†’Stream(A Ã— B) that zips the
argument streams together is characterized as follows:
head â—¦zip
=
(fst Ã— fst) â—¦(out Ã— out)
tail â—¦zip
=
zip â—¦(snd Ã— snd) â—¦(out Ã— out)
This function can, therefore, be deï¬ned as [( âŸ¨fst Ã— fst, snd Ã— snd âŸ©â—¦(out Ã— out) )].
The function iterate(f) : A â†’Stream(A) builds the stream of all repeated
applications of function f : A â†’A to the argument
iterate(f) = [( âŸ¨id, f âŸ©)]
Example 2.9 (colists)
The codata type of colists over a given set A can be represented as the termi-
nal coalgebra (Î½LA, out) of the functor LA. Write Listâ€²
A for Î½LA. Given any
function g : C â†’1 + (A Ã— C), the anamorphism [( g )] is the unique solution
f : C â†’Listâ€²
A of the equation out â—¦f = (id +(id Ã—f)) â—¦g, i.e. the function
unfold(g) from functional programming.
2.3
Implementation in Haskell
In Haskell, like in type theory, functors arise from the association of a morphism
mapping to an object mapping. A functor in Haskell is a type constructor from
the class Functor deï¬ned in the Haskell Prelude as follows:
class
Functor f
where
fmap :: (a -> b) -> f a -> f b
The type constructor f, in itself, is the object mapping part of a functor. The
morphism mapping is the function fmap. The class deï¬nition forces fmap to
have the correct typing, but cannot force it to preserve identities and composition,
so at each time the programmer deï¬nes the fmap function for a particular type
constructor f, it is his responsibility to ensure that these conditions are met.
Given some type constructor, it can be declared to be a functor by deï¬ning the
fmap function for it using instance declaration. For example, the fmap function
for the list type constructor is deï¬ned in the Haskell Prelude as follows:
instance Functor [] where
fmap = map
26

The deï¬nition tells, that the fmap for lists is â€œordinaryâ€ map function.
Inductive types, being carriers of initial algebras, are least ï¬xed points of the
corresponding functors. In Haskell, this can be modeled by the following decla-
ration:
> newtype Mu f = In (f (Mu f))
Given a type constructor f, this deï¬nes a new type Mu f which has the same
representation as the type f(Mu f); i.e. it deï¬nes Mu f as the least ï¬xed point of
f. In addition, it deï¬nes a data constructor In :: f (Mu f) -> Mu f for the
explicit one-way coercion between the types. The coercion in the other way (i.e.
the inverse of In) can be deï¬ned by pattern matching:
> unIn :: Mu f -> f (Mu f)
> unIn (In x) = x
Coinductive types are carriers of terminal coalgebras, thus greatest ï¬xed points
of the corresponding functors. Because Haskell allows to use a general recursion,
coinductive types are necessarily isomorphic to the inductive types with the same
base functor. Hence we could use Mu f also for coinductive types. However,
in order to make intended meaning of different usages explicit, we deï¬ne them
separately:
> newtype Nu f = Wrap (f (Nu f))
> out :: Nu f -> f (Nu f)
> out (Wrap x) = x
In order to implement cata- and anamorphisms, we make use the correspond-
ing cancellation laws, but in a slightly modiï¬ed form1. Namely, we eliminate the
occurrences of the initial algebra in or terminal coalgebra out from the left-hand
side of the equation, by pre- or postcomposing both sides with the corresponding
inverse.
> cata :: Functor f => (f c -> c) -> Mu f -> c
> cata phi = phi
. fmap (cata phi) . unIn
> ana
:: Functor f => (c -> f c) -> c -> Nu f
> ana phi
= Wrap . fmap (ana phi)
. phi
1In fact, this is not necessary for catamorphisms, as we could use pattern matching to implement
the cancellation law directly. However, this does not work in the case of anamorphisms, as Haskell
requires that the name of the deï¬ned function has to be the outermost in the left-hand side of the
deï¬ning equation.
27

The combinator cata takes a function of type f c -> c (i.e. algebra) into func-
tion of type Mu f -> c. Dually, ana takes a function of type c -> f c (i.e.
coalgebra) into function of type c -> Nu f. In both cases, the type constructor
f has to belong into class Functor. The restriction on f is necessary, as the
right-hand sides of the deï¬ning equations makes use of the function fmap. Note
that there was no such restriction in the deï¬nitions of Mu or Nu.
Example 2.10 (naturals)
The data type of natural numbers, as given in example 2.2, is an initial algebra for
the functor N(X) = 1 + X. In Haskell, this can be implemented as follows:
> data N x = Z | S x
> instance Functor N where
>
fmap f Z
= Z
>
fmap f (S x) = S (f x)
> type Nat = Mu N
The ï¬rst line deï¬nes a new type constructor N, which corresponds to the object
mapping part of the functor N. Then, the instance declaration deï¬nes the function
fmap for it; i.e. makes it a functor. Finally, the last line deï¬nes data type Nat as
the least ï¬xed point of N.
The constructor functions for naturals (the constant zero and successor func-
tion) can be deï¬ned as follows:
> zeroN :: Nat
> zeroN
= In Z
> succN
:: Nat -> Nat
> succN n = In (S n)
Below are listed some illustrative values of type Nat (naturals 1, 2 and 4):
In (S (In Z))
In (S (In (S (In Z))))
In (S (In (S (In (S (In (S (In Z))))))))
The sum of two naturals can be implemented as following catamorphism:
> addN :: Nat -> Nat -> Nat
> addN x y = cata phi x
>
where phi Z
= y
>
phi (S n) = succN n
28

Note that the algebra phi is deï¬ned by the case analysis over the structure of type
constructor N, specifying the result separately depending whether the inductive
argument (i.e. x) is zero or not. In the case of non-zero inductive argument, the
result is speciï¬ed in terms of the value on its predecessor.
Analogously, the product of two naturals can be implemented by a catamor-
phism:
> mulN :: Nat -> Nat -> Nat
> mulN x y = cata phi x
>
where phi Z
= y
>
phi (S n) = addN y n
Example 2.11 (lists)
The data type of lists can be implemented as follows:
> data L a x = N | C a x
> instance Functor (L a) where
>
fmap f N
= N
>
fmap f (C x xs) = C x (f xs)
> type List a
= Mu (L a)
> nilL :: List a
> nilL
= In N
> consL
:: a -> List a -> List a
> consL x xs = In (C x xs)
The functions nilL and consL are constructor functions for lists. The ï¬rst cor-
responds to an empty list, and the second to the â€œordinaryâ€ list constructor.
The functions length, concat and map from the example 2.3 can be imple-
mented as follows:
> lengthL :: List a -> Nat
> lengthL = cata phi
>
where phi N
= zeroN
>
phi (C _ n) = succN n
29

> concatL :: List a -> List a -> List a
> concatL xs ys = cata phi xs
>
where phi N
= ys
>
phi (C x xsâ€™) = consL x xsâ€™
> mapList :: (a -> b) -> List a -> List b
> mapList f = cata phi
>
where phi N
= nilL
>
phi (C a bs) = consL (f a) bs
Example 2.12 (streams)
The codata type of streams can be implemented as follows:
> data S a x =
St a x
> instance Functor (S a) where
>
fmap f (St x xs) = St x (f xs)
> type Stream a = Nu (S a)
> headS :: Stream a -> a
> headS xs = case out xs of
>
St x _ -> x
> tailS :: Stream a -> Stream a
> tailS xs = case out xs of
>
St _ xsâ€™ -> xsâ€™
Functions headS and tailS are stream destructors, returning the head and the
tail of the given stream respectively.
> zipS :: (Stream a, Stream a) -> Stream (a,a)
> zipS = ana phi
>
where phi (xs, ys) = St (headS xs, headS ys)
>
(tailS xs, tailS ys)
30

> iterateS :: (a -> a) -> a -> Stream a
> iterateS f = ana phi
>
where phi x = St x (f x)
Example 2.13 (colists)
Colists have the same base functor as lists, hence we can implement them as
follows:
> type CoList a = Nu (L a)
The destructor function for conaturals, can not be decomposed in general. How-
ever, as Haskell allows to use partial functions, we deï¬ne more intuitive â€œdestruc-
torsâ€ as follows:
> nullCL :: CoList a -> Bool
> nullCL xs = case out xs of
>
N
-> True
>
C _ _ -> False
> headCL :: CoList a -> a
> headCL xs = case out xs of
>
C x _ -> x
> tailCL :: CoList a -> CoList a
> tailCL xs = case out xs of
>
C _ xsâ€™ -> xsâ€™
The function nullCL tests whether the colist is empty or not. Partial functions
headCL and tailCL extract respectively the head and the tail of the given non-
empty colist.
2.4
Related work
The categorical treatment of inductive and coinductive types as initial algebras
and terminal coalgebras for covariant functors comes from Hagino [Hag87], who
designed a typed functional language CPL based on distributive categories and
initial algebras and terminal coalgebras for strong covariant functors. The Charity
language by Cockett et al. [CF92] is a similar programming language.
The program calculation community is rooted in the Bird-Meertens formalism
or Squiggol [Bir87], which, originally, was an equational theory of programming
31

with the parametric data type of lists. Malcolm [Mal90b, Mal90a] made the com-
munity aware of Haginoâ€™s work and much of the subsequent development fol-
lowed the path he set. A classic reference in the area of theory is Fokkingaâ€™s
[Fok92].
The excellent introduction into program calculation is the textbook
[BdM97].
32

CHAPTER 3
PRIMITIVE (CO)RECURSION
This chapter, based on [VU98], is devoted to primitive recursion and primitive
corecursion. Primitive recursion is a well known recursion scheme, where the
value on the current argument is constructed using the value on the previous ar-
gument together with the previous argument itself. Its dualization, primitive core-
cursion, is not so well known, but provides an equally useful corecursive deï¬ni-
tion mechanism where a codata structure is generated either step by step (like in
the case of coiteration) or in one big step. Both schemes are generalizations of
the simple (co)iteration and can be embedded in a nice way into the categorical
framework presented in the previous chapter.
3.1
Primitive recursion via tupling
Not every function with inductive type as source can be represented by a single
catamorphism alone. For instance, the factorial function fact : Nat â†’Nat is
neatly characterized as the unique solution of the equation system
fact(0)
=
1
fact(n + 1)
=
(n + 1) âˆ—fact(n)
However, the recursion pattern of the equations above does not follow that of cata-
morphisms but primitive recursion, i.e. the factorial of a given natural, depends not
only on the factorial of its predecessor, but also on the predecessor itself. So, the
catamorphic deï¬nition of factorial has to compute both in parallel as a pair and
then project the factorial component out:
fact
=
fst â—¦L [ Î»x.(1, 0), Î»(f, n).((n + 1) âˆ—f, n + 1) ] M.
Meertens [Mee92] showed that the same trick of tupling can be also used for other
inductive types. The relevant result is the following:
33

Lemma 3.1 For any two arrows f : ÂµF â†’C and Ï• : F (C Ã— ÂµF) â†’C, we have
f â—¦in = Ï• â—¦F âŸ¨f, id âŸ©
â‰¡
f = fst â—¦L âŸ¨Ï•, in â—¦F(snd) âŸ©M
Proof. The left-hand equation essentially says that f follows the primitive re-
cursion pattern for ÂµF, while the right one gives its deï¬nition in terms of the
composition of the left projection and a catamorphism.
The equivalence is proved by the following two calculations. First, from left
to right:
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
â–·
f â—¦in = Ï• â—¦F âŸ¨f, id âŸ©
f
=
â€“ pairing â€“
fst â—¦âŸ¨f, id âŸ©
=
â€“ cata-CHARN â€“
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
âŸ¨f, id âŸ©â—¦in
=
â€“ pairing â€“
âŸ¨f â—¦in, in âŸ©
=
â€“ F functor â€“
âŸ¨f â—¦in, in â—¦F id âŸ©
=
â€“ pairing â€“
âŸ¨f â—¦in, in â—¦F (snd â—¦âŸ¨f, id âŸ©) âŸ©
=
â€“ â—, F functor â€“
âŸ¨Ï• â—¦F âŸ¨f, id âŸ©, in â—¦F snd â—¦F âŸ¨f, id âŸ©âŸ©
=
â€“ pairing â€“
âŸ¨Ï•, in â—¦F snd âŸ©â—¦F âŸ¨f, id âŸ©
fst â—¦L âŸ¨Ï•, in â—¦F snd âŸ©M
Second, from right to left:
34

ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
â–·
f = fst â—¦L âŸ¨Ï•, in â—¦F snd âŸ©M
f â—¦in
=
â€“ â—â€“
fst â—¦L âŸ¨Ï•, in â—¦F snd âŸ©M â—¦in
=
â€“ cata-CHARN â€“
fst â—¦âŸ¨Ï•, in â—¦F snd âŸ©â—¦F L âŸ¨Ï•, in â—¦F snd âŸ©M
=
â€“ pairing, 2x â€“
Ï• â—¦F âŸ¨fst â—¦L âŸ¨Ï•, in â—¦F snd âŸ©M, snd â—¦L âŸ¨Ï•, in â—¦F snd âŸ©M âŸ©
=
â€“ â—, cata-FUSION â€“
ï£®
ï£°
snd â—¦âŸ¨Ï•, in â—¦F snd âŸ©
=
â€“ pairing â€“
in â—¦F snd
Ï• â—¦F âŸ¨f, L in M âŸ©
=
â€“ cata-REFL â€“
Ï• â—¦F âŸ¨f, id âŸ©
From the lemma above, it follows that at least every primitive recursive func-
tion can be represented using catamorphism as the only recursive construction.
In the presence of exponentials, one can even deï¬ne Ackermannâ€™s function as a
(higher-order) catamorphism, so the expressive power of the â€œlanguage of cata-
morphismsâ€ is bigger than the class of primitively recursive functions. In fact,
Howard [How96] has shown that the functions expressible in simply typed Î»-
calculus extended with inductive and coinductive types are precisely those prov-
ably total in the logic ID<Ï‰ (the ï¬rst order arithmetic augmented by ï¬nitely-
iterated inductive deï¬nitions).
However, from the practical point of view, the situation is not very satisfac-
tory. First, using tupling is clearly not the most natural way to program primitive
recursive functions. Second, algorithms corresponding to the deï¬nitions obtained
by the lemma above have additional penalty in terms of complexity, as they have
to reconstruct the argument which is already there.
3.2
Paramorphisms
To make programming and program reasoning easier, let us introduce a new con-
struction and study its properties.
35

Deï¬nition 3.1 (paramorphism)
Let (ÂµF, in) be an initial F-algebra. For any arrow Ï• : F (C Ã—ÂµF) â†’C, the arrow
âŸ¨| Ï• |âŸ©: ÂµF â†’C is deï¬ned by
âŸ¨| Ï• |âŸ©= fst â—¦L âŸ¨Ï•, in â—¦F(snd) âŸ©M
para-DEF
The arrows in form âŸ¨| Ï• |âŸ©are called paramorphisms (derived from the Greek
preposition Ï€Î±ÏÎ± meaning â€˜near toâ€™, â€˜at the side ofâ€™, â€˜towardsâ€™; the name is due
to Meertens [Mee92]).
The deï¬nition made use of the right-hand side of the equivalence in Lemma 3.1.
Exploiting the left-hand side, we get the characterization of paramorphisms in
terms of universal property.
Corollary 3.2 For any arrow Ï• : F (C Ã— ÂµF) â†’C, the paramorphism f =
âŸ¨| Ï• |âŸ©: ÂµF â†’C is the unique arrow making the following diagram commute:
F ÂµF
in
/
F âŸ¨f,id âŸ©

ÂµF
f

F (C Ã— ÂµF)
Ï•
/ C
i.e. satisfying the universal property:
f â—¦in = Ï• â—¦F âŸ¨f, id âŸ©
â‰¡
f = âŸ¨| Ï• |âŸ©
para-CHARN
Example 3.1 (primitive recursion for naturals)
Consider the data type of natural numbers. Given any two functions c : 1 â†’C
and h : C Ã—Nat â†’C, the paramorphism f = âŸ¨| [ c, h ] |âŸ©: Nat â†’C is the unique
solution of the equation system
f â—¦zero
=
c
f â—¦succ
=
h â—¦âŸ¨f, id âŸ©,
i.e. it captures the classical primitive recursion scheme. For instance, the factorial
function fact : Nat â†’Nat can be deï¬ned as paramorphism
fact = âŸ¨| [ one, Î»(f, n).mul(succ(n), f) ] |âŸ©,
where one = succ â—¦zero : 1 â†’Nat and mul : Nat Ã— Nat â†’Nat is the
multiplication of naturals deï¬ned in Example 2.2.
36

Example 3.2 (primitive recursion for lists)
Consider the data type of lists List(A). Given any two functions c : 1 â†’C and
h : A Ã— C Ã— List(A) â†’C, the paramorphism f = âŸ¨| [ c, h ] |âŸ©: List(A) â†’C is
the unique solution of the equation system
f(nil)
=
c()
f(cons(x, xs))
=
h(x, f(xs), xs).
For instance, the function tails : List(A) â†’List(List(A)), which returns the
list of all tail segments of argument list, can be deï¬ned as paramorphism
tails = âŸ¨| [ cons(nil, nil), Î»(x, r, xs).cons(cons(x, xs), ys) ] |âŸ©.
Another example of list paramorphism is the function dropWhile(p) : List(A) â†’
List(A), which for given predicate p : A â†’Bool drops the longest initial seg-
ment of the argument list such that all elements in this segment satisfy p
dropWhile(p) = âŸ¨| [ nil, Î»(x, r, xs).if p(x) then r else cons(x, xs) ] |âŸ©.
The calculational properties of paramorphisms are similar to those of catamor-
phisms. In particular, we have â€œparamorphicâ€ versions of cancellation, reï¬‚ection
and fusion laws.
Proposition 3.3 Let (ÂµF, in) be an initial F-algebra.
â€¢ Cancellation: For any arrow Ï• : F (C Ã— ÂµF) â†’C
âŸ¨| Ï• |âŸ©â—¦in = Ï• â—¦F âŸ¨âŸ¨| Ï• |âŸ©, id âŸ©
para-SELF
â€¢ Reï¬‚ection:
id = âŸ¨| in â—¦F(fst) |âŸ©
para-REFL
â€¢ Fusion: For any arrows Ï• : F (C Ã— ÂµF) â†’C, Ïˆ : F (D Ã— ÂµF) â†’D and
f : C â†’D
f â—¦Ï• = Ïˆ â—¦F(f Ã— id)
â‡’
f â—¦âŸ¨| Ï• |âŸ©= âŸ¨| Ïˆ |âŸ©
para-FUSION
Proof. The cancellation law is directly obtained form the universal property of
paramorphisms by substituting f := âŸ¨| Ï• |âŸ©thus making the right-hand equation in
37

para-CHARN trivially true. For the reï¬‚ection law we argue:
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
id
=
â€“ para-CHARN â€“
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
id â—¦in
=
â€“ identity, F functor â€“
in â—¦F(id)
=
â€“ pairing â€“
in â—¦F(fst â—¦âŸ¨id, id âŸ©)
=
â€“ F functor â€“
in â—¦F(fst) â—¦FâŸ¨id, id âŸ©
âŸ¨| in â—¦F(fst) |âŸ©
Finally, the fusion law is proved as follows:
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
â–·
f â—¦Ï• = Ïˆ â—¦F(f Ã— id)
f â—¦âŸ¨| Ï• |âŸ©
=
â€“ para-CHARN â€“
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
f â—¦âŸ¨| Ï• |âŸ©â—¦in
=
â€“ para-SELF â€“
f â—¦Ï• â—¦FâŸ¨âŸ¨| Ï• |âŸ©, id âŸ©
=
â€“ â—â€“
Ïˆ â—¦F(f Ã— id) â—¦FâŸ¨âŸ¨| Ï• |âŸ©, id âŸ©
=
â€“ F functor â€“
Ïˆ â—¦F((f Ã— id) â—¦âŸ¨âŸ¨| Ï• |âŸ©, id âŸ©)
=
â€“ pairing â€“
Ïˆ â—¦FâŸ¨f â—¦âŸ¨| Ï• |âŸ©, id âŸ©
âŸ¨| Ïˆ |âŸ©
In addition to the laws above, paramorphisms satisfy several other useful prop-
erties some of which are listed below.
Proposition 3.4
1. Every catamorphism L Ï• M can be deï¬ned as a paramorphism which does
not use the preceding value of the argument directly:
L Ï• M = âŸ¨| Ï• â—¦F(fst) |âŸ©
para-CATA
2. Every arrow whose source is the carrier of an initial algebra is a paramor-
phism:
f = âŸ¨| f â—¦in â—¦F(snd) |âŸ©
para-FROM-INIT
38

3. The inverse of an initial algebra is a paramorphism:
inâˆ’1 = âŸ¨| F(snd) |âŸ©
para-IN-INV
Proof. The ï¬rst equality is proven as follows:
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
L Ï• M
=
â€“ para-CHARN â€“
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
L Ï• M â—¦in
=
â€“ cata-SELF â€“
Ï• â—¦FL Ï• M
=
â€“ pairing â€“
Ï• â—¦F(fst â—¦âŸ¨L Ï• M, id âŸ©)
=
â€“ F functor â€“
Ï• â—¦F(fst) â—¦FâŸ¨L Ï• M, id âŸ©
âŸ¨| Ï• â—¦F(fst) |âŸ©
Similarly, the validity of para-FROM-INIT is shown by:
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
f
=
â€“ para-CHARN â€“
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
f â—¦in
=
â€“ F functor â€“
f â—¦in â—¦F(id)
=
â€“ pairing â€“
f â—¦in â—¦F(snd â—¦âŸ¨f, id âŸ©)
=
â€“ F functor â€“
f â—¦in â—¦F(snd) â—¦FâŸ¨f, id âŸ©
âŸ¨| f â—¦in â—¦F(snd) |âŸ©
Finally, para-IN-INV comes directly from the previous law:
ï£®
ï£¯ï£¯ï£¯ï£¯ï£°
inâˆ’1
=
â€“ para-FROM-INIT â€“
âŸ¨| inâˆ’1 â—¦in â—¦F(snd) |âŸ©
=
â€“ in-inv-CHARN â€“
âŸ¨| F(snd) |âŸ©
39

3.3
Apomorphisms
Let us now dualize everything we know about paramorphisms.
Deï¬nition 3.2 (apomorphism)
Let (Î½F, out) be a terminal F-coalgebra. For any arrow Ï• : C â†’F(C + Î½F),
deï¬ne the arrow [âŸ¨Ï• âŸ©] : C â†’Î½F as a composition of a certain anamorphism with
the left injection:
[âŸ¨Ï• âŸ©] = [( [ Ï•, F(inr) â—¦out ] )] â—¦inl
apo-DEF
The arrows in form [âŸ¨Ï• âŸ©] are called apomorphisms (derived from the Greek prepo-
sition Î±Ï€o meaning â€˜apart fromâ€™, â€˜far fromâ€™, â€˜away fromâ€™; the name was ï¬rst used
by Vos [Vos95]1).
Corollary 3.5 For any arrow Ï• : C â†’F(C + Î½F), the apomorphism f = [âŸ¨Ï• âŸ©] :
C â†’Î½F is the unique arrow making the following diagram commute:
C
Ï•
/
f

F (C + Î½F)
F [ f,id ]

Î½F
out
/ F Î½F
i.e. satisfying the universal property:
out â—¦f = F [ f, id ] â—¦Ï•
â‰¡
f = [âŸ¨Ï• âŸ©]
apo-CHARN
The laws for apomorphisms are just dual to those for paramorphisms.
Corollary 3.6 Let (Î½F, out) be a terminal F-coalgebra.
â€¢ Cancellation: For any arrow Ï• : C â†’F(C + Î½F)
out â—¦[âŸ¨Ï• âŸ©] = F[ [âŸ¨Ï• âŸ©], id ] â—¦Ï•
apo-SELF
â€¢ Reï¬‚ection:
id = [âŸ¨F(inl) â—¦out âŸ©]
apo-REFL
1It is interesting to note that Vene and Uustalu [VU98] unaware of the work by Vos happened to
come up with exactly the same new name.
40

â€¢ Fusion: For any arrows Ï• : C â†’F(C + Î½F), Ïˆ : D â†’F(D + Î½F) and
f : C â†’D
Ïˆ â—¦f = F(f + id) â—¦Ï•
â‡’
[âŸ¨Ïˆ âŸ©] â—¦f = [âŸ¨Ï• âŸ©]
apo-FUSION
Corollary 3.7
1. Every anamorphism [( Ï• )] is an apomorphism:
[( Ï• )] = [âŸ¨F(inl) â—¦Ï• âŸ©]
apo-ANA
2. Every arrow whose target is the carrier of a terminal coalgebra is an apo-
morphism:
f = [âŸ¨F(inr) â—¦out â—¦f âŸ©]
apo-TO-TERM
3. The inverse of a terminal coalgebra is an apomorphism:
outâˆ’1 = [âŸ¨F(inr) âŸ©]
apo-OUT-INV
Example 3.3 (primitive corecursion for streams)
Consider the codata type of streams Stream(A). Given any two functions h :
C â†’A and t : C â†’C + Stream(A), the apomorphism f = [âŸ¨âŸ¨h, t âŸ©âŸ©] : C â†’
Stream(A) is the unique solution of the equation system
head â—¦f
=
h
tail â—¦f
=
[ f, id ] â—¦t.
Like in the case of anamorphisms, the head of the stream is computed from the
current seed value using the function h. However, the tail of the stream can be
generated two different ways depending whether the function t computes the
new seed value (in which case the generation process proceeds recursively) or
the rest of stream as whole. For instance, the function maphd(h) : Stream(A) â†’
Stream(A), which modiï¬es any input stream by applying a function h : A â†’A
to its head while leaving the tail unchanged, can be deï¬ned as following apomor-
phism:
maphd(h) = [âŸ¨âŸ¨h â—¦head, inr â—¦tail âŸ©âŸ©].
41

The role of the function t is more explicit when it is in the form t = [ n, r ] â—¦p?,
where p â†’Bool is a predicate and n : C â†’C and r : C â†’Stream(A) are
functions for computing next seed or rest of the stream respectively. Then the
apomorphism f = [âŸ¨âŸ¨h, [ n, r ] â—¦p? âŸ©âŸ©] is characterized by equations:
head(f(x))
=
h(x)
tail(f(x))
=
f(n(x))
if p(x)
=
r(x)
otherwise.
For an example, assume that a given set A is ordered. The function insert(a) :
Stream(A) â†’Stream(A) inserts the element a : 1 â†’A into a given stream
immediately before the ï¬rst element that is greater than or equal to a (so that the
returned stream will be a sorted, if the argument was). It can be deï¬ned as an
apomorphism:
insert(a) = [âŸ¨âŸ¨h, [ tail, id ] â—¦p? âŸ©âŸ©],
where
p(xs)
=
head(xs) â‰¤a()
h(xs)
=
head(xs)
if p(xs)
=
a()
otherwise.
Example 3.4 (primitive corecursion for conaturals)
Given a function h : C â†’1 + (C + CoNat), the apomorphism f = [âŸ¨h âŸ©] : C â†’
CoNat is the unique solution of the equation system
pred(f(x)) =
ï£±
ï£²
ï£³
inl ()
if h(x) = inl ()
inr(f(xâ€²))
if h(x) = inr(inl(xâ€²))
inr(y)
if h(x) = inr(inr(y)).
For instance, the addition function on conaturals add = CoNat Ã— CoNat â†’
CoNat, which was deï¬ned as an anamorphism in the Example 2.7, can be more
succinctly deï¬ned as add = [âŸ¨f âŸ©], where
f(x, y) =
ï£±
ï£²
ï£³
inl ()
if pred(x) = pred(y) = inl ()
inr(inl(xâ€², y))
if pred(x) = inr xâ€²
inr(inr(yâ€²))
if pred(x) = inl (), pred(y) = inr yâ€².
The â€œstructuredâ€ corecursion operator can be deï¬ned if the function h is in the
form h = [ !C, [ n, r ] â—¦p2? ] â—¦p1?, where p1 : C â†’Bool and p2 : C â†’Bool are
42

predicates, n : C â†’C gives the next seed and r : C â†’CoNat gives the remain-
der of the conatural under construction. Then f = [âŸ¨[ !C, [ n, r ] â—¦p2? ] â—¦p1? âŸ©] :
C â†’CoNat is characterized by the equations:
pred(f(x)) =
ï£±
ï£²
ï£³
inl ()
if p1(x)
inr(f(n(x)))
if Â¬p1(x) âˆ§p2(x)
inr(r(y))
otherwise.
Example 3.5 (primitive corecursion for colists)
For instance, the function the function append : CoList(A) Ã— CoList(A) â†’
CoList(A), which appends two colists is naturally deï¬nable as an apomorphism
append = [âŸ¨f âŸ©], where
f(x, y)
=
inl()
if null(x) âˆ§null(y)
=
inr(head(y), inr(tail(y)))
if null(x) âˆ§Â¬(null(y))
=
inr(head(x), inl(tail(x), y))
otherwise.
Here, null : CoList(A) â†’Bool is a predicate which tests whether the colist is
empty or not, i.e. null = [ id, !A ] â—¦out.
3.4
Para- and apomorphisms in Haskell
Paramorphisms map arrows of type F (C Ã— ÂµF) â†’C to the arrows of type ÂµF â†’
C. Thus, the type of paramorphism combinator can be expressed in Haskell as
follows:
> para :: Functor f => (f (c, Mu f) -> c) -> Mu f -> c
For the deï¬ning equation of paramorphism combinator we have two possibilities.
First, we can use the deï¬nition of paramorphism in terms of catamorphism:
para phi = fst . cata (fork phi (In . fmap snd))
where fork is pair forming function deï¬ned as follows:
> fork :: (a -> b) -> (a -> c) -> a -> (b,c)
> fork f g x = (f x, g x)
However, this deï¬nition is inefï¬cent, as it recursively reconstructs the argument.
The second possibility is to use the cancellation law to obtain the directly recursive
deï¬nition:
> para phi = phi . fmap (fork (para phi) id) . unIn
43

This deï¬nition is more efï¬cent, as the (previous) argument is used directly by
phi.
Example 3.6 (factorial)
The factorial function can be implemented as paramorphism:
> fact :: Nat -> Nat
> fact = para phi
>
where phi Z
= succN zeroN
>
phi (S (r,x)) = mulN (succN x) r
In the second equation of phi, the result (i.e. factorial) on the previous argument
is denoted by r, and the argument itself by x.
Example 3.7 (dropwhile)
The function dropWhile from the example 3.2 can be implemented as follows:
> dropWhileL :: (a -> Bool) -> List a -> List a
> dropWhileL p = para phi
>
where phi N
= nilL
>
phi (C x (r,xs)) | p x
= r
>
| otherwise = consL x xs
Here, again, r denotes the value on the previous argument (i.e. value on the tail
of the list), while x and xs denote the head and tail of the original list.
Dually to paramorphisms, apomorphisms map arrows of type C â†’F(C +
Î½F) to arrows of type C â†’Î½F. As Haskell does not provide a primitive type
constructor for sums, we have to deï¬ne it ï¬rst:
> data Sum a b = InL a | InR b
We also deï¬ne a combinator which does the case analysis on the sum:
> join :: (a -> c) -> (b -> c) -> Sum a b -> c
> join f g (InL x) = f x
> join f g (InR y) = g y
Now, the type of the apomorphism combinator can be expressed as follows:
> apo :: Functor f => (c -> f (Sum c (Nu f)))
>
->
c -> Nu f
Like in the case of paramorphisms, we have a choise between two possibilities
to deï¬ne the apomorphism combinator. First, the deï¬nition in terms of anamor-
phism:
44

apo phi = ana (join phi (fmap InR . out)) . InL
This deï¬nition is not very efï¬cent, as it constructs the codata structure in a step-
wise fashion even if the whole remaining structure is available (i.e. phi returns
the right summand). The second possibility is to use directly recursive deï¬nition
obtained from the cancellation law:
> apo phi = Wrap . fmap (join (apo phi) id) . phi
In the case of phi returns the right summand, this deï¬nition is more efï¬cient, as
the rest of the structure is returned by one step.
Example 3.8 (insert)
The function insert from the example 3.3 is deï¬ned as follows:
> insertS :: Ord a => a -> Stream a -> Stream a
> insertS a = apo phi
>
where phi xs | x < a
= St x (InL (tailS xs))
>
| otherwise = St a (InR xs)
>
where x = headS xs
Example 3.9 (append)
The concatenation of two colists can be implemented as apomorphism:
> appendCL :: (CoList a, CoList a) -> CoList a
> appendCL = apo phi
>
where phi (xs, ys)
>
| nullCL xs && nullCL ys = N
>
| nullCL xs
= C (headCL ys)
>
(InR (tailCL ys))
>
| otherwise
= C (headCL xs)
>
(InL (tailCL xs, ys))
3.5
Related work
Primitive recursion is universally recognized as an important generalization of it-
eration. Paramorphisms were introduced by Meertens [Mee92]. Geuvers [Geu92]
contains a thorough category-theoretic analysis of primitive recursion versus it-
eration and a demonstration that this readily dualizes into an analysis of primi-
tive corecursion versus coiteration. In general, however, it appears that primitive
45

corecursion has largely been overlooked in the theoretical literature, e.g. [Fok92]
ignores it. The sole discussion of primitive corecursion in a programming con-
text that we knew about when writing [VU98] was the laconic report in [Ves97]
on a not very clean extension to the categorical functional language Charity in
which it is possible to deï¬ne functions by primitive recursion and primitive core-
cursion. Soon after we got to know of [Vos95]. Citations of [VU98] appear in
[GH99, BBA00].
46

CHAPTER 4
COURSE-OF-VALUE
(CO)ITERATION
In this chapter, which is based on [UV99b], we introduce categorical combina-
tors for course-of-value iteration and coiteration. Course-of-value iteration is a
recursion scheme, where the value on the current argument is constructed using
the values for the subparts of the argument on arbitrary (but ï¬xed) depth. Du-
ally, course-of-value coiteration allows to generate several â€œlevelsâ€ of a resulting
codata structure in one step.
4.1
Course-of-value iteration via memoization
The famous Fibonacci function ï¬bo : Nat â†’Nat is most smoothly characterized
as the unique solution of the equation system
ï¬bo(0)
=
1
ï¬bo(1)
=
1
ï¬bo(n + 2)
=
ï¬bo(n + 1) + ï¬bo(n).
This very nice characterization does not give us any deï¬nition of ï¬bo in terms
of catamorphisms. The problem is that the value of ï¬bo for a given argument is
deï¬ned not via the values for the immediate subparts of the argument, but via the
values for its subparts of depth 2. But the characterization of ï¬bo together with
the function ï¬boâ€² : Nat â†’Nat Ã— Nat (which, for any argument n, returns the
pair formed of the value of ï¬bo for n and either zero or the value of ï¬bo for the
predecessor of n) by a much trickier equation system, viz.,
ï¬bo
=
fst â—¦ï¬boâ€²
ï¬boâ€²(0)
=
(1, 0)
ï¬boâ€²(n + 1)
=
âŸ¨add, fst âŸ©(ï¬boâ€²(n)),
47

leads to a deï¬nition of ï¬bo as the composition of the left projection and a cata-
morphism:
ï¬bo = fst â—¦L âŸ¨[ Î»x.1, add ], [ Î»x.0, fst ] âŸ©M.
Now, we could introduce a new construction that would capture the natural
deï¬nition scheme of the Fibonacci function and closely similar functions, and
start studying its properties. But this would only provide us with a partial so-
lution to the problem manifested by the Fibonacci example, as one can imagine
functions whose value for a given argument is naturally deï¬ned via the values for
its subparts of depth three, four, etc. Instead of this, we introduce a construction
that captures a general course-of-value iteration by collecting the values on all
subparts into a certain codata structure.
Deï¬nition 4.1 (cv-algebra)
Let F : C â†’C be an endofunctor for which there exists an initial algebra (ÂµF, in).
Deï¬ne a bifunctor FÃ— : C Ã— C â†’C as follows:
FÃ—(A, X) = A Ã— F(X).
Assume that for any object A there exists a terminal FÃ—
A-coalgebra (Î½FÃ—
A, out),
i.e. FÃ— induces a codata functor FÎ½(X) = Î½FÃ—
X. A F-cv-algebra is a pair (C, Ï•),
where C is an object and Ï• : F(FÎ½(C)) â†’C is an arrow.
Deï¬nition 4.2 (cv-algebra homomorphism)
Let (C, Ï•) and (D, Ïˆ) be two F-cv-algebras. A homomorphism from (C, Ï•) to
(D, Ïˆ) is an arrow f : C â†’D in the category C, such that
f â—¦Ï• = Ïˆ â—¦F[( (f Ã— id) â—¦out )]
i.e. makes the following diagram to commute:
F(FÎ½(C))
Ï•
/
F[( (fÃ—id)â—¦out )]

C
f

F(FÎ½(D))
Ïˆ
/ D
Note that any F-cv-algebra is an ordinary algebra for a functor G(X) =
F(FÎ½(X)), and homomorphisms between F-cv-algebras are ordinary homomor-
phisms between G-algebras.
48

The next result, analogous to Lemma 3.1 for primitive recursion, states that
every function which can be speciï¬ed using course-of-value iteration, can be de-
ï¬ned in terms of catamorphism which builds a codata structure of values of the
function on the all substructures of its argument (essentially, the catamorphism
builds a memo-table [Mic68] for the function).
Lemma 4.1 For any arrow f : ÂµF â†’C and F-cv-algebra Ï• : F(FÎ½(C)) â†’C,
we have
f â—¦in = Ï• â—¦F [( âŸ¨f, inâˆ’1 âŸ©)]
â‰¡
f = fst â—¦out â—¦L outâˆ’1 â—¦âŸ¨Ï•, id âŸ©M
Proof. Proving it is quite tricky. From left to right we calculate:
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
â–·
f â—¦in = Ï• â—¦F [( âŸ¨f, inâˆ’1 âŸ©)]
f
=
â€“ pairing â€“
fst â—¦âŸ¨f, inâˆ’1 âŸ©
=
â€“ pairing â€“
fst â—¦(id Ã—F [( âŸ¨f, inâˆ’1 âŸ©)]) â—¦âŸ¨f, inâˆ’1 âŸ©
=
â€“ ana-SELF â€“
fst â—¦out â—¦[( âŸ¨f, inâˆ’1 âŸ©)]
=
â€“ cata-CHARN â€“
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
[( âŸ¨f, inâˆ’1 âŸ©)] â—¦in
=
â€“ out-inv-CHARN â€“
outâˆ’1â—¦out â—¦[( âŸ¨f, inâˆ’1 âŸ©)] â—¦in
=
â€“ ana-SELF â€“
outâˆ’1â—¦(id Ã—F [( âŸ¨f, inâˆ’1 âŸ©)]) â—¦âŸ¨f, inâˆ’1 âŸ©â—¦in
=
â€“ pairing â€“
outâˆ’1â—¦âŸ¨f, F [( âŸ¨f, inâˆ’1 âŸ©)] â—¦inâˆ’1 âŸ©â—¦in
=
â€“ pairing â€“
outâˆ’1â—¦âŸ¨f â—¦in, F [( âŸ¨f, inâˆ’1 âŸ©)] â—¦inâˆ’1 â—¦in âŸ©
=
â€“ â—, in-inv-CHARN â€“
outâˆ’1â—¦âŸ¨Ï• â—¦F [( âŸ¨f, inâˆ’1 âŸ©)], F [( âŸ¨f, inâˆ’1 âŸ©)] âŸ©
=
â€“ pairing â€“
outâˆ’1â—¦âŸ¨Ï•, id âŸ©â—¦F [( âŸ¨f, inâˆ’1 âŸ©)]
fst â—¦out â—¦L outâˆ’1 â—¦âŸ¨Ï•, id âŸ©M
49

From right to left we argue:
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
â–·
f = fst â—¦out â—¦L outâˆ’1 â—¦âŸ¨Ï•, id âŸ©M
f â—¦in
=
â€“ â—â€“
fst â—¦out â—¦L outâˆ’1 â—¦âŸ¨Ï•, id âŸ©M â—¦in
=
â€“ cata-SELF â€“
fst â—¦out â—¦outâˆ’1 â—¦âŸ¨Ï•, id âŸ©â—¦F L outâˆ’1 â—¦âŸ¨Ï•, id âŸ©M
=
â€“ out-inv-CHARN â€“
fst â—¦âŸ¨Ï•, id âŸ©â—¦F L outâˆ’1 â—¦âŸ¨Ï•, id âŸ©M
=
â€“ pairing â€“
Ï• â—¦F L outâˆ’1 â—¦âŸ¨Ï•, id âŸ©M
=
â€“ ana-CHARN â€“
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
out â—¦L outâˆ’1 â—¦âŸ¨Ï•, id âŸ©M
=
â€“ pairing â€“
âŸ¨fst â—¦out â—¦L outâˆ’1â—¦âŸ¨Ï•, id âŸ©M, snd â—¦out â—¦L outâˆ’1â—¦âŸ¨Ï•, id âŸ©M âŸ©
=
â€“ â—, in-inv-CHARN â€“
âŸ¨f, snd â—¦out â—¦L outâˆ’1 â—¦âŸ¨Ï•, id âŸ©M â—¦in â—¦inâˆ’1 âŸ©
=
â€“ cata-SELF â€“
âŸ¨f, snd â—¦out â—¦outâˆ’1â—¦âŸ¨Ï•, id âŸ©â—¦F L outâˆ’1â—¦âŸ¨Ï•, id âŸ©M â—¦inâˆ’1 âŸ©
=
â€“ out-inv-CHARN â€“
âŸ¨f, snd â—¦âŸ¨Ï•, id âŸ©â—¦F L outâˆ’1 â—¦âŸ¨Ï•, id âŸ©M â—¦inâˆ’1 âŸ©
=
â€“ pairing â€“
âŸ¨f, F L outâˆ’1 â—¦âŸ¨Ï•, id âŸ©M â—¦inâˆ’1 âŸ©
=
â€“ pairing â€“
(id Ã—F L outâˆ’1 â—¦âŸ¨Ï•, id âŸ©M) â—¦âŸ¨f, inâˆ’1 âŸ©
Ï• â—¦F [( âŸ¨f, inâˆ’1 âŸ©)]
4.2
Histomorphisms
To make programming and program reasoning easier, let us introduce a new con-
struction and study its properties.
Deï¬nition 4.3 (histomorphism)
Let (ÂµF, in) be an initial F-algebra. For any F-cv-algebra Ï• : F(FÎ½(C)) â†’C, the
arrow {| Ï• |} : ÂµF â†’C is deï¬ned by
{| Ï• |} = fst â—¦out â—¦L outâˆ’1 â—¦âŸ¨Ï•, id âŸ©M
histo-DEF
The arrows in form {| Ï• |} are called histomorphisms.
50

By Lemma 4.1, we get the characterization of histomorphisms in terms of
universal property.
Corollary 4.2 For any F-cv-algebra Ï• : F(FÎ½(C)) â†’C, the histomorphism f =
{| Ï• |} : ÂµF â†’C is the unique arrow making the following diagram commute:
F(ÂµF)
in
/
F [( âŸ¨f,inâˆ’1 âŸ©)]

ÂµF
f

F(FÎ½(C))
Ï•
/ C
i.e. satisfying the universal property:
f â—¦in = Ï• â—¦F [( âŸ¨f, inâˆ’1 âŸ©)]
â‰¡
f = {| Ï• |}
histo-CHARN
From the universal property, we also get the cancellation, reï¬‚ection and fusion
laws for histomorphisms:
Proposition 4.3 Let (ÂµF, in) be an initial F-algebra.
â€¢ Cancellation: For any F-cv-algebra Ï• : F(FÎ½(C)) â†’C
{| Ï• |} â—¦in = Ï• â—¦F [( âŸ¨{| Ï• |}, inâˆ’1 âŸ©)]
histo-SELF
â€¢ Reï¬‚ection:
id = {| in â—¦F (fst â—¦out) |}
histo-REFL
â€¢ Fusion: For any F-cv-algebra Ï• : F(FÎ½(C)) â†’C, Ïˆ : F(FÎ½(D)) â†’D
and an arrow f : C â†’D
f â—¦Ï• = Ïˆ â—¦F [( (f Ã— id) â—¦out )]
â‡’
f â—¦{| Ï• |} = {| Ïˆ |}
histo-FUSION
Proof. The cancellation law is directly obtained from the universal property of
histomorphisms by substituting f := {| Ï• |} thus making the right-hand equation
51

in histo-CHARN trivially true. For the reï¬‚ection law we argue:
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
id
=
â€“ histo-CHARN â€“
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
id â—¦in
=
â€“ identity, F functor â€“
in â—¦F(id)
=
â€“ pairing â€“
in â—¦F (fst â—¦âŸ¨id, inâˆ’1 âŸ©)
=
â€“ pairing â€“
in â—¦F (fst â—¦(id Ã—F [( âŸ¨id, inâˆ’1 âŸ©)]) â—¦âŸ¨id, inâˆ’1 âŸ©)
=
â€“ ana-SELF â€“
in â—¦F (fst â—¦out â—¦[( âŸ¨id, inâˆ’1 âŸ©)])
=
â€“ F functor â€“
in â—¦F (fst â—¦out) â—¦F [( âŸ¨id, inâˆ’1 âŸ©)]
{| in â—¦F(fst â—¦out) |}
Finally, the fusion law is proved as follows:
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
â–·
f â—¦Ï• = Ïˆ â—¦F [( (f Ã— id) â—¦out )]
f â—¦{| Ï• |}
=
â€“ histo-CHARN â€“
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
f â—¦{| Ï• |} â—¦in
=
â€“ histo-SELF â€“
f â—¦Ï• â—¦F [( âŸ¨{| Ï• |}, inâˆ’1 âŸ©)]
=
â€“ â—â€“
Ïˆ â—¦F [( (f Ã— id) â—¦out )] â—¦F [( âŸ¨{| Ï• |}, inâˆ’1 âŸ©)]
=
â€“ F functor â€“
Ïˆ â—¦F ([( (f Ã— id) â—¦out )] â—¦[( âŸ¨{| Ï• |}, inâˆ’1 âŸ©)])
=
â€“ ana-FUSION â€“
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
(f Ã— id) â—¦out â—¦[( âŸ¨{| Ï• |}, inâˆ’1 âŸ©)]
=
â€“ ana-SELF â€“
(f Ã— id) â—¦(id Ã—F [( âŸ¨{| Ï• |}, inâˆ’1 âŸ©)]) â—¦âŸ¨{| Ï• |}, inâˆ’1 âŸ©
=
â€“ pairing â€“
(f Ã— F [( âŸ¨{| Ï• |}, inâˆ’1 âŸ©)]) â—¦âŸ¨{| Ï• |}, inâˆ’1 âŸ©
=
â€“ pairing â€“
âŸ¨f â—¦{| Ï• |}, F [( âŸ¨{| Ï• |}, inâˆ’1 âŸ©)] â—¦inâˆ’1 âŸ©
=
â€“ pairing â€“
(id Ã—F [( âŸ¨{| Ï• |}, inâˆ’1 âŸ©)]) â—¦âŸ¨f â—¦{| Ï• |}, inâˆ’1 âŸ©
Ïˆ â—¦F [( âŸ¨f â—¦{| Ï† |}, inâˆ’1 âŸ©)]
{| Ïˆ |}
52

Read from left to right, the cancellation law can be treated as the reduction
rule for histomorphisms. Informally it tells that, the value of the histomorphism
on the given argument is computed by ï¬rst building a certain â€œcolistâ€ and then
using a cv-algebra to give the ï¬nal result. The â€œcolistâ€ is generated using an
anamorphism which gets the previous argument as the initial seed. On every step,
the anamorphism computes (recursively) the value of the histomorphism on the
current seed, and also a new seed by taking a â€œpredecessorâ€ of the current one.
The left-hand side of the fusion law states that f is a homomorphism between
cv-algebras Ï• and Ïˆ. Hence every cv-algebra homomorphism can be fused with
a histomorphism.
Similarly to paramorphisms, histomorphisms can be viewed as a generaliza-
tion of catamorphisms. Namely, every catamorphism is a histomorphism which
uses only the value on the â€œpredecessorâ€ of the current argument (i.e. the â€œheadâ€
of the â€œcolistâ€).
Proposition 4.4 For any F-algebra Ï• : F(C) â†’C,
L Ï• M = {| Ï• â—¦F (fst â—¦out) |}
histo-CATA
Proof. It is veriï¬ed by the following calculation:
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
L Ï• M
=
â€“ histo-CHARN â€“
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
L Ï• M â—¦in
=
â€“ cata-SELF â€“
Ï• â—¦F L Ï• M
=
â€“ pairing â€“
Ï• â—¦F (fst â—¦âŸ¨L Ï• M, inâˆ’1 âŸ©)
=
â€“ pairing â€“
Ï• â—¦F (fst â—¦(id Ã—F [( âŸ¨L Ï• M, inâˆ’1 âŸ©)]) â—¦âŸ¨L Ï• M, inâˆ’1 âŸ©)
=
â€“ ana-SELF â€“
Ï• â—¦F (fst â—¦out â—¦[( âŸ¨L Ï• M, inâˆ’1 âŸ©)])
=
â€“ F functor â€“
Ï• â—¦F (fst â—¦out) â—¦F [( âŸ¨L Ï• M, inâˆ’1 âŸ©)]
{| Ï• â—¦F (fst â—¦out) |}
Example 4.1 (course-of-value iteration for naturals)
Consider the data type of natural numbers;
i.e. the initial N-algebra
(Nat, [ zero, succ ]). The codata type NÎ½(C) consists of nonempty colists over
C, and the terminal coalgebra structure is provided by out = âŸ¨cur, prev âŸ©:
53

NÎ½(C) â†’C Ã— (1 + NÎ½(C)), where cur : NÎ½(C) â†’C gives the head and
prev : NÎ½(C) â†’1 + NÎ½(C) the (possible) tail of a colist.
Any N-cv-algebra Ï• : 1 + NÎ½(C) â†’C can be decomposed using join Ï• =
[ z0, s0 ], where z0 : 1 â†’C and s0 : NÎ½(C) â†’C. The histomorphism f =
{| [ z0, s0 ] |} : Nat â†’C is the unique solution of the equation system:
f(zero())
=
z0()
f(succ(x))
=
s0([( âŸ¨f, pred âŸ©)](x)),
where pred : Nat â†’1 + Nat is the predecessor function from the Example 2.2.
In order to get more illuminating version of the course-of-value iteration oper-
ator, assume that the function s0 is in form s0 = [ z1â—¦!, s1 ] â—¦distr â—¦out for some
constant1 z1 : 1 â†’C and function s1 : C Ã— NÎ½(C) â†’C. Then the correspond-
ing histomorphism f = {| [ z0, [ z1â—¦!, s1 ] â—¦distr â—¦out ] |} is characterized by the
equations:
f(zero())
=
z0()
f(succ(zero()))
=
z1()
f(succ(x))
=
s1(f(x), [( âŸ¨f, pred âŸ©)](x)).
Now, the use of the value on the previous argument is explicit. Particularly, by
taking z0 = one, z1 = one and s1(x, y) = add(x, cur(y)), we get the deï¬nition
of the Fibonacci function; i.e.
ï¬bo = {| [ one, [ oneâ—¦!, add â—¦(id Ã—cur) ] â—¦distr â—¦out ] |}.
The general form of course-of-value iteration operator involves n+1 constants
z0, . . . , zn : 1 â†’C and a function sn : C Ã— (. . . (C Ã— NÎ½(C)) . . . ) â†’C (here
the product has n + 1 components). The corresponding histomorphism is
f = {| [ z0, [ z1â—¦!, [ z2â—¦!, . . . [ znâ—¦!, sn ] â—¦dout . . . ] â—¦dout ] â—¦dout ] |},
where dout = distr â—¦out. It is characterized by the system of n + 2 equations:
f(zero())
=
z0()
f(succ(zero()))
=
z1()
. . .
f(succn(zero()))
=
zn()
f(succn(x))
=
sn(fn(x), . . . , f(x), [( âŸ¨f, pred âŸ©)](x)).
1Instead of the constant, the left branch of the join could be a function h : C â†’C which makes
use of the value on the previous argument. However, the previous argument is known to be zero
and the value on it is z0, thus result on the argument succ â—¦zero is already known to be z1 = h(z0).
54

Note that in such way we can characterize functions which make use of arbitrary
but ï¬xed number of preceding values. Of course, we can imagine functions which
make use of all preceding values (such recursion scheme is called course-of-value
recursion). The classical example of such function is f(n) = 2n, which can be
characterized as:
f(n) = 1 + f(n âˆ’1) + Â· Â· Â· + f(1) + f(0).
If we rewrite the equation in a more explicit form
f(n) = 1 +
nâˆ’1
X
i=0
f(i),
we see that the use of all preceding values can be achieved by using primitive
recursion and course-of-value iteration at the same time.
4.3
Futumorphisms
We now introduce a construction dual to cv-algebras and histomorphisms.
Deï¬nition 4.4 (cv-coalgebra)
Let F : C â†’C be an endofunctor for which there exists a terminal coalgebra
(Î½F, out). Deï¬ne a bifunctor F+ : C Ã— C â†’C as follows:
F+(A, X) = A + F(X).
Assume that for any object A there exists an initial F+
A-algebra (ÂµF+
A, in), i.e. F+
induces a data functor FÂµ(X) = ÂµF+
X. A F-cv-coalgebra is a pair (C, Ï•), where
C is an object and Ï• : C â†’F(F+(C)) is an arrow.
Deï¬nition 4.5 (cv-coalgebra homomorphism)
Let (C, Ï•) and (D, Ïˆ) be two F-cv-algebras. A homomorphism from (C, Ï•) to
(D, Ïˆ) is an arrow f : C â†’D in the category C, such that
Ïˆ â—¦f = F L in â—¦(f + id) M â—¦Ï•
i.e. makes the following diagram to commute:
C
Ï•
/
f

F(FÂµ(C))
F L in â—¦(f+id) M

D
Ïˆ
/ F(FÂµ(D))
55

Note that any F-cv-coalgebra is an ordinary coalgebra for a functor G(X) =
F(FÂµ(X)), and homomorphisms between F-cv-coalgebras are ordinary homomor-
phisms between G-coalgebras.
Deï¬nition 4.6 (futumorphism)
Let (Î½F, out) be a terminal F-coalgebra.
For any F-cv-coalgebra Ï• : C â†’
F(FÂµ(C)), the arrow [{ Ï• }] : C â†’Î½F is deï¬ned by
[{ Ï• }] = [( [ Ï•, id ] â—¦inâˆ’1 )] â—¦in â—¦inl
futu-DEF
The arrows in form [{ Ï• }] are called futumorphisms.
Corollary 4.5 For any F-cv-coalgebra Ï• : C â†’F(F+(C)), the futumorphism
f = [{ Ï• }] : C â†’Î½F is the unique arrow making the following diagram commute:
C
Ï•
/
f

F(FÂµ(C))
F L [ f,outâˆ’1 ] M

Î½F
out
/ F(Î½F)
i.e. satisfying the universal property:
out â—¦f = F L [ f, outâˆ’1 ] M â—¦Ï•
â‰¡
f = [{ Ï• }]
futu-CHARN
By a straightforward dualization of the laws for histomorphisms, we get the
corresponding laws for futumorphisms.
Corollary 4.6 Let (ÂµF, in) be an initial F-algebra.
â€¢ Cancellation: For any F-cv-coalgebra Ï• : C â†’F(F+(C))
out â—¦[{ Ï• }] = F L [ [{ Ï• }], outâˆ’1 ] M â—¦Ï•
futu-SELF
â€¢ Reï¬‚ection:
id = [{ F (in â—¦inl) â—¦out }]
futu-REFL
â€¢ Fusion: For any F-cv-coalgebra Ï• : C â†’F(F+(C)), Ïˆ : D â†’F(F+(D))
and an arrow f : C â†’D
Ïˆ â—¦f = F L in â—¦(f + id) M â—¦Ï•
â‡’
[{ Ïˆ }] â—¦f = [{ Ï• }]
futu-FUSION
56

â€¢ Ana from futu: For any F-coalgebra Ï• : C â†’F(C)
[( Ï• )] = [{ F (in â—¦inl) â—¦Ï• }]
futu-ANA
Example 4.2 (course-of-value coiteration for streams)
Recall, that the terminal coalgebra for a bifunctor S(A, X) = A Ã— X was given
by Stream(A), the codata type of streams over A, with the coalgebra structure
âŸ¨head, tail âŸ©: Stream(A) â†’A Ã— Stream(A). The inductive data type manifest-
ing in stream futumorphisms is given by the induced data bifunctor SÂµ(C, A) =
ÂµS+
C,A, where S+(C, A, X) = C + A Ã— X; i.e. data type of nonempty lists where
all elements except the last one are from type A, and the last element is of type C.
The initial algebra structure is given by [ l, c ] : C + A Ã— SÂµ(C, A) â†’SÂµ(C, A),
where l : C â†’SÂµ(C, A) constructs the singleton list and c : A Ã— SÂµ(C, A) â†’
SÂµ(C, A) inserts the new element of type A into ï¬rst position.
Every SA-cv-coalgebra Ï• : C â†’A Ã— SÂµ(C, A) can be decomposed using
fork Ï• = âŸ¨h0, t âŸ©, where h0 : C â†’A and t : C â†’SÂµ(C, A). The futumorphism
f = [{ âŸ¨h0, t âŸ©}] : C â†’Stream(A) is the unique solution of the equation system:
head(f(x))
=
h0(x)
tail(f(x))
=
L [ f, cons ] M(t(x)),
where cons = outâˆ’1 : A Ã— Stream(A) â†’Stream(A). Intuitively, the function
t in produces a list of stream elements going to follow just next after the current
head, and also a new seed as the last element of the list. Then the catamorphism
replaces the list constructors c with the â€œstream constructorâ€ cons, thus forming
an initial preï¬x of the tail stream. Finally, the last constructor l, which contains
the new seed, is replaced by f, which continues recursively to produce the rest of
the stream.
Assume that the function t explicitly constructs the list of n + 1 elements; i.e.
it is in form
t(x) = c(h1(x), (c(h2(x), . . . c(hn(x), l(s(x))) . . . ))),
where h1, . . . , hn : C â†’A and s : C â†’C. Then the futumorphism f =
[{ âŸ¨h0, c â—¦âŸ¨h1, . . . c â—¦âŸ¨hn, l â—¦s âŸ©. . . âŸ©âŸ©}] : C â†’Stream(A) is characterized by a
system of n + 2 equations:
head(f(x))
=
h0(x)
head(tail(f(x)))
=
h1(x)
. . .
head(tailn(f(x)))
=
hn(x)
tail(tailn(f(x)))
=
f(s(x)).
57

For instance, the function exch : Stream(A) â†’Stream(A), which pairwise
exchanges the elements of any given argument, is characterized by the equation
system
head(exch(x))
=
head(tail(x))
head(tail(exch(x)))
=
head(x)
tail(tail(exch(x)))
=
exch(tail(tail(x))).
Thus it is deï¬nable as a futumorphism:
exch = [{ âŸ¨head â—¦tail, c â—¦âŸ¨head, l â—¦tail â—¦tail âŸ©âŸ©}].
4.4
Histo- and futumorphisms in Haskell
Histomorphisms map arrows F(FÎ½(C)) â†’C to arrows ÂµF â†’C. Hence, in order
to implement histomorphisms in Haskell, we ï¬rst have to deï¬ne the base functor
for the â€œcourse-of-valuesâ€ codata structure:
> newtype ProdF f a x = ProdF (a, f x)
> instance Functor f => Functor (ProdF f a) where
>
fmap f (ProdF (a, fx)) = ProdF (a, fmap f fx)
We also deï¬ne the pairing function for ProdF:
> forkF :: (a -> b) -> (a -> f c) -> a
>
-> ProdF f b c
> forkF f g = ProdF . fork f g
In order to ease the navigation on the â€œcourse-of-valuesâ€ codata structure, we
deï¬ne destructor functions out of it:
> hdCV :: Nu (ProdF f c) -> c
> hdCV xs = case out xs of
>
ProdF (c, _)
-> c
> tlCV :: Nu (ProdF f c) -> f (Nu (ProdF f c))
> tlCV xs = case out xs of
>
ProdF (_, fx) -> fx
Now, the type of histomorphism combinator can be expressed in Haskell as fol-
lows:
58

> histo :: Functor f => (f (Nu (ProdF f c)) -> c)
>
->
Mu f
-> c
Like in the case of paramorphisms, we have two possibilities for the deï¬ning
equation of histo combinator. First, we can deï¬ne it in terms of catamorphism:
> histo phi = hdCV . cata (Wrap . forkF phi id)
The second possibility is to use the directly recursive deï¬nition:
histo phi = phi
. fmap (ana (forkF (histo phi) unIn))
. unIn
This time, however, the ï¬rst deï¬nition is more efï¬cient. In the case of directly re-
cursive deï¬nition, â€œcourse-of-valueâ€ codata structure is recomputed in every step
of iteration. On the other hand, the catamorphic deï¬nition computes the â€œcourse-
of-valueâ€ codata structure incrementally in a bottom-up fashion, thus effectively
implementing the memoization of the values on previous arguments.
Example 4.3 (Fibonacci)
The Fibonacci function can be implemented as histomorphism (for greater clarity
we use Haskell integers Int as the result type):
> fibo :: Nat -> Int
> fibo = histo phi
>
where phi Z
= 1
>
phi (S x) = case tlCV x of
>
Z
-> 1
>
S y -> hdCV x + hdCV y
Example 4.4 (evens)
The function evens takes from the given list every second element. It can be
deï¬ned as histomorphism:
> evens :: List a -> List a
> evens = histo phi
>
where phi
N
= nilL
>
phi (C _ x) = case tlCV x of
>
N
-> nilL
>
C a y -> consL a (hdCV y)
59

Futumorphisms map arrows C â†’F(FÂµ(C)) to arrows C â†’Î½F. Hence, in
order to implement futumorphisms in Haskell, we ï¬rst have to deï¬ne the base
functor for the inductive data structure FÂµ(C):
> newtype SumF f a x = SumF (Sum a (f x))
> instance Functor f => Functor (SumF f a) where
>
fmap f (SumF (InL a)) = SumF (InL a)
>
fmap f (SumF (InR x)) = SumF (InR (fmap f x))
> joinF :: (a -> c) -> (f b -> c) -> SumF f a b -> c
> joinF f g (SumF s) = join f g s
We also deï¬ne constructor functions for the inductive data structure:
> lastF :: c -> Mu (SumF f c)
> lastF x = In (SumF (InL x))
> consF :: f (Mu (SumF f c)) -> Mu (SumF f c)
> consF x = In (SumF (InR x))
Now, the type of futumorphism combinator can be expressed in Haskell as fol-
lows:
> futu :: Functor f => (c -> f (Mu (SumF f c)))
>
->
c -> Nu f
Like in the case of histomorphisms, we have two possibilities for the deï¬ning
equation of futumorphisms combinator. First, we can deï¬ne it in terms of anamor-
phism:
futu phi = ana (joinF phi id . unIn) . lastF
The second possibility is to use the directly recursive deï¬nition obtained from the
cancellation law:
> futu phi = Wrap
>
. fmap (cata (joinF (futu phi) Wrap))
>
. phi
There is no difference between two deï¬nitions in terms of efï¬ciency except some
small constant factor.
60

Example 4.5 (exchange)
The function exch from the example 4.2 can be implemented as follows:
> exch :: Stream a -> Stream a
> exch = futu phi
>
where phi xs = St (headS (tailS xs))
>
(consF (St (headS xs)
>
(lastF (tailS xs))))
4.5
Related work
We do not know any other directly comparable work on course-of-value iteration
or coiteration (except our own work in a type-theoretic setting [UV97, UV00b,
Uus98]). The closest is work by Hu, Iwasaki and others [HITT96] about the tu-
pling transformation. They develop calculational rules to eliminate multiple data
traversals on functions deï¬ned by course-of-value iteration (and also by mutual
recursion). Instead of using coinductive data structure to represent the course-
of-values, they are using ï¬nite products which essentially are the unfolded ï¬nite
preï¬xes of the course-of-values the function actually uses. This makes the rules
quite hard to follow, but their aim is to use these rules in some automatic program
transformation system, and not in programming itself.
61

62

CHAPTER 5
MENDLER-STYLE INDUCTIVE
TYPES
This chapter is based on [UV99a] and here we consider a novel alternative ap-
proach to inductive types in the categorical setting, inspired from the work by
N. P. Mendler [Men91] in type theory. The basic motivation for this another for-
malization lies in the difï¬culties of extending the traditional approach to inductive
types (and coinductive types) for non-covariant base functors. Freydâ€™s dialgebras
[Fre90, Fre91] solve the problem for mixed-variant functors, but at the cost that
the distinction between inductive and coinductive types vanishes.
One reason for the difï¬culties in the conventional approach is that the deï¬-
nition of homomorphism between F-algebras explicitly mentions the arrow map-
ping part of the functor. As a result, if F is not a covariant functor, the deï¬nition
of homomorphisms has to be changed accordingly, otherwise the distributivity
equation the homomorphism must satisfy is incorrectly typed.
The basic idea of so called Mendler-style inductive types is to modify the def-
inition of algebra and their homomorphisms in such a way that the arrow mapping
part of the functor does not manifest itself in the distributivity equation. Instead,
there is an additional condition that the algebra itself has to satisfy, and functor
appears only in the typing. Then the concept can be extended to apply to non-
covariant bases by modifying the condition in the deï¬nition of algebra, but leav-
ing the deï¬nition of algebra homomorphism (and so also the calculational laws)
intact.
5.1
Mendler-style inductive types: covariant case
Recall, that for a given object C of the category C, we can form a contravari-
ant homfunctor C(âˆ’, C) : Cop â†’Set which takes an object A to the hom-set
C(A, C), and an arrow g : A â†’B to the function C(g, C) : C(B, C) â†’C(A, C)
63

deï¬ned by Î»Î² : B â†’C. Î² â—¦g. Similarly, if F : C â†’C is an endofunctor,
we can deï¬ne a contravariant functor C(F(âˆ’), C) : Cop â†’Set which takes any
object A to the hom-set C(F(A), C), and any arrow g : A â†’B to the function
C(F(g), C) : C(F(B), C) â†’C(F(A), C) deï¬ned by Î»Î² : B â†’C. Î² â—¦F(g). In
the following we denote the functor C(F(âˆ’), C) by F/C.
Deï¬nition 5.1 (Mendler-style algebra for a functor)
Let F : C â†’C be an endofunctor. A Mendler-style F-algebra or F-malgebra
is a pair (C, Î¦), where C is an object of C and Î¦ : Id/C .â†’F/C is a natural
transformation; i.e. for any arrow g : A â†’B the following diagram commutes:
C(B, C)
Î¦B
/
C(g,C)

C(F(B), C)
C(F(g),C)

C(A, C)
Î¦A
/ C(F(A), C)
In other words, Î¦ is an operation on arrows with target C which â€œliftsâ€ the
source of the arrow under the functor F, by taking any arrow Î± : A â†’C to the
arrow Î¦A(Î±) : F(A) â†’C. If the lifted arrow Î± : C â†’C is an automorphism
(i.e. an arrow with the same source and target object), then Î¦C(Î±) : F(C) â†’C
is a conventional F-algebra. In particular, Î¦ takes the identity arrow on C to a
conventional F-algebra Î¦C(id).
The naturality condition says, that the lifting preserves compositions in the
following sense: if Î± = Î² â—¦g for some object B and arrows Î² : B â†’C,
g : A â†’B, then
Î¦A(Î² â—¦g) = Î¦B(Î²) â—¦F(g)
(5.1)
or diagrammatically
A
Î±
@
@
@
@
@
@
@
g
/ B
Î²
~~~~~~~~
C
â‡’
F(A)
Î¦A(Î±)
!D
D
D
D
D
D
D
D
F(g)
/ F(B)
Î¦B(Î²)
}zzzzzzzz
C
In particular, by taking B = C and Î² = idC, we have that
Î¦A(Î±) = Î¦C(id) â—¦F(Î±)
(5.2)
So, the lifting on the arrows is determined by the composition the functor with
some F-algebra.
64

Deï¬nition 5.2 (malgebra homomorphism)
Let (C, Î¦) and (D, Î¨) be F-malgebras. A homomorphism from (C, Î¦) to (D, Î¨)
is an arrow h : C â†’D such that for any object A the following diagram com-
mutes in Set:
C(A, C)
C(A,h)
/
Î¦A

C(A, D)
Î¨A

C(F(A), C)
C(F(A),h)
/ C(F(A), D)
In terms of base category C, the square above tells that for any object A and
arrow Î³ : A â†’C, the following equation holds:
h â—¦Î¦A(Î³) = Î¨A(h â—¦Î³)
(5.3)
or diagrammatically:
A
Î³
~~~~~~~
Î´
 @
@
@
@
@
@
@
C
h
/ D
â‡’
F(A)
Î¦A(Î³)
}zzzzzzzz
Î¨A(Î´)
!D
D
D
D
D
D
D
D
C
h
/ D
In particular, if we take A = C and Î± = idC, then
h â—¦Î¦C(id) = Î¨C(h).
(5.4)
Now, using the equality 5.2 about malgebras we get
h â—¦Î¦C(id) = Î¨C(id) â—¦F(h).
(5.5)
Thus, homomorphism h is also homomorphism between conventional F-algebras
Î¦C(id) and Î¨C(id).
Obviously, homomorphisms between malgebras compose, and the identity ar-
row on the carrier object gives the identity homomorphism. So, we can form a
category Alg(F)m of Mendler-style F-algebras and their homomorphisms.
Deï¬nition 5.3 (initial malgebra for a functor)
A Mendler-style F-algebra (ÂµmF, inm) is an initial F-malgebra if for any Mend-
ler-style F-algebra (C, Î¦) there exists an arrow L Î¦ Mm : ÂµmF â†’C satisfying the
universal property:
f â—¦inm
ÂµmF(id) = Î¦ÂµmF(f)
â‰¡
f = L Î¦ Mm
cataM-CHARN
65

In other words, the initial malgebra (ÂµmF, inm) is the initial object in the
category Alg(F)m. The cancellation, reï¬‚ection and fusion laws for Mendler-style
catamorphisms specialize as follows:
Corollary 5.1 Let (ÂµmF, inm) be an initial F-malgebra.
â€¢ Cancellation: For any F-malgebra (C, Î¦)
L Î¦ Mm â—¦inm
ÂµmF(id) = Î¦ÂµmF(L Î¦ Mm)
cataM-SELF
â€¢ Reï¬‚ection:
id = L inm Mm
cataM-REFL
â€¢ Fusion: For any F-malgebras (C, Î¦) and (D, Î¨) and an arrow f : C â†’D
f â—¦Î¦C(id) = Î¨C(f)
â‡’
f â—¦L Î¦ Mm = L Î¨ Mm
cataM-FUSION
Note that neither the universal property nor the laws derived from it contain
any direct references to the functor F. The functor only appears implicitly on the
typing, and as the naturality condition for Mendler-style algebras involved.
Example 5.1 (naturals)
Consider the data type of natural numbers Nat. Recall, that it forms the initial
algebra (Nat, [ zero, succ ]) for the functor N(X) = 1 + X. For any object A
and arrow Î³ : A â†’Nat, deï¬ne a mapping inm
A(Î³) = [ zero, succ â—¦Î³ ]. Then
(Nat, inm) forms an initial N-malgebra.
For instance, the sum of two naturals can be deï¬ned in terms of Mendler-style
catamorphism as follows:
add(n, m) = L Î»A, Î³ : A â†’Nat. [ Î»x.m, succ â—¦Î³ ] Mm(n).
5.2
Conventional inductive types reduced to
Mendler-style inductive types
The project of this section is to show that conventional inductive types reduce to
Mendler-style inductive types. To this end, we prove that, for any endofunctor
F : C â†’C, the categories Alg(F)m and Alg(F) are isomorphic. The proof we
present is a proof from scratch. For a reader versed in category theory, the result
is a consequence from the Yoneda lemma.
66

Deï¬nition 5.4 (malgebra to algebra mapping)
For any F-malgebra (C, Î¦), deï¬ne
âŒÎ¦âŒŸ= Î¦C(id)
Deï¬nition 5.5 (algebra to malgebra mapping)
For any conventional F-algebra (C, Ï•), deï¬ne
âŒœÏ•âŒ= Î»A, Î³ : A â†’C. Ï• â—¦F(Î³)
Proposition 5.2 If (C, Î¦) is a F-malgebra, then (C, âŒÎ¦âŒŸ) is a F-algebra.
Proof. Trivial.
Proposition 5.3 If (C, Ï•) is a F-algebra, then (C, âŒœÏ•âŒ) is a F-malgebra.
Proof. We have to check that âŒœÏ•âŒis a natural transformation.
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
â–·
pick A, B, g : A â†’B, Î² : B â†’C
âŒœÏ•âŒA(Î² â—¦g)
=
â€“ âŒœâˆ’âŒ-def â€“
Ï• â—¦F(Î² â—¦g)
=
â€“ F functor â€“
Ï• â—¦F(Î²) â—¦F(g)
=
â€“ âŒœâˆ’âŒ-def â€“
âŒœÏ•âŒB(Î²) â—¦F(g)
Proposition 5.4 If (C, Î¦) is a Mendler-style F-algebra, then
âŒœâŒÎ¦âŒŸâŒ= Î¦.
Proof.
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
â–·
pick A, Î³ : A â†’C
âŒœâŒÎ¦âŒŸâŒA(Î³)
=
â€“ âŒœâˆ’âŒ-def â€“
âŒÎ¦âŒŸâ—¦F(Î³)
=
â€“ âŒâˆ’âŒŸ-def â€“
Î¦C(id) â—¦F(Î³)
=
â€“ Î¦ natural â€“
Î¦A(Î³)
67

Proposition 5.5 If (C, Ï•) is a conventional F-algebra, then
âŒâŒœÏ•âŒâŒŸ= Ï•.
Proof.
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
âŒâŒœÏ•âŒâŒŸ
=
â€“ âŒâˆ’âŒŸ-def â€“
âŒœÏ•âŒC(id)
=
â€“ âŒœâˆ’âŒ-def â€“
Ï• â—¦F(id)
=
â€“ F functorial â€“
Ï•
Proposition 5.6 If h is a Mendler-style F-algebra homomorphism between
(C, Î¦) and (D, Î¨), then h is also a conventional F-algebra homomorphism be-
tween (C, âŒÎ¦âŒŸ) and (D, âŒÎ¨âŒŸ).
Proof. Already shown, see the equation 5.5 and the discussion before it.
Proposition 5.7 If h is a conventional F-algebra homomorphism between (C, Ï•)
and (D, Ïˆ), then h is also a Mendler-style F-algebra homomorphism between
(C, âŒœÏ•âŒ) and (D, âŒœÏˆâŒ).
Proof.
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
â–·
h â—¦Ï• = Ïˆ â—¦F(h)
â–·
pick A, Î³ : A â†’C
h â—¦âŒœÏ•âŒA(Î³)
=
â€“ âŒœâˆ’âŒ-def â€“
h â—¦Ï• â—¦F(Î³)
=
â€“ â—â€“
Ïˆ â—¦F(h) â—¦F(Î³)
=
â€“ F functorial â€“
Ïˆ â—¦F(h â—¦Î³)
=
â€“ âŒœâˆ’âŒ-def â€“
âŒœÏˆâŒA(h â—¦Î³)
These propositions tell us that there exists a functor between the categories
Alg(F)m and Alg(F) and a left-and-right inverse for it.
68

Theorem 5.8 The categories Alg(F)m and Alg(F) are isomorphic.
The following is now immediate:
Corollary 5.9 If (ÂµmF, inm) is an initial Mendler-style F-algebra,
then
(ÂµmF, âŒinmâŒŸ) is an initial (conventional) F-algebra.
For any F-algebra Ï• :
F(C) â†’C, the unique homomorphism into it (i.e. catamorphism) is given by
L âŒœÏ•âŒMm : ÂµmF â†’C.
Corollary 5.10 If (ÂµF, in) is an initial (conventional) F-algebra, then (ÂµF, âŒœinâŒ)
is an initial Mendler-style F-algebra. For any Mendler-style F-algebra (C, Î¦),
the unique homomorphism into it (i.e. Mendler-style catamorphism) is given by
L âŒÎ¦âŒŸM : ÂµF â†’C.
5.3
Mendler-style inductive types: mixed variant case
The idea of Mendler-style inductive types makes sense not only for covariant base
functors F : C â†’C, but also for mixed variant functors G : Cop Ã— C â†’C. The
mixed variant case is, in fact, more general, as covariant functors are a degenerate
case of mixed variant functors: for any F : C â†’C, one can trivially deï¬ne
Fâ‰€: Cop Ã— C â†’C, a padding of Fâ‰€with a â€œdummyâ€ contravariant argument, by
letting Fâ‰€(Y, X) = F(X).
Deï¬nition 5.6 (Mendler-style algebra for a difunctor)
Let G : Cop Ã— C â†’C be an endodifunctor. A Mendler-style G-algebra or G-
malgebra is a pair (C, Î¦), where C is an object of C and Î¦ : Idâ‰€/C ..â†’G/C is
a dinatural transformation; i.e. for any arrow g : A â†’B the following diagram
commutes:
C(B, C)
C(g,C)mmmmm
vmmmmm
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
C(A, C)
Î¦A

C(B, C)
Î¦B

C(G(A, A), C)
C(G(g,idA),C)
Q
Q
Q
Q
Q
(Q
Q
Q
Q
Q
C(G(B, B), C)
C(G(idB,g),C)
mmmmm
vmmmmm
C(G(B, A), C)
69

In terms of the base category, Î¦ is a mapping that takes any arrow Î³ : A â†’C
to the arrow Î¦A(Î±) : G(A, A) â†’C in such a way that if Î± = Î² â—¦g for some
object B and arrows Î² : B â†’C, g : A â†’B, then the following equation holds:
Î¦A(Î² â—¦g) â—¦G(g, idA) = Î¦B(Î²) â—¦G(idB, g)
(5.6)
or diagrammatically:
B
Î²

G(B, A)
G(g,idA)
yrrrrrrrrrr
G(idB,g)
%L
L
L
L
L
L
L
L
L
L
A
g
@
Î±
>>>>>>>>
â‡’
G(A, A)
Î¦A(Î±)
&L
L
L
L
L
L
L
L
L
L
L
G(B, B)
Î¦B(Î²)
xqqqqqqqqqqq
C
C
If the contravariant argument of the difunctor G is â€œdummyâ€ (i.e. G(X, Y ) =
F(Y ) for some covariant functor F : C â†’C) then the dinaturality condition boils
down to the naturality condition in deï¬nition 5.1, and equation 5.6 simpliï¬es to
equation 5.1. So in this case the deï¬nitions 5.1 and 5.6 coincide.
Deï¬nition 5.7 (malgebra homomorphism)
Let (C, Î¦) and (D, Î¨) be G-malgebras for a difunctor G : Cop Ã— C â†’C. A
homomorphism from (C, Î¦) to (D, Î¨) is an arrow h : C â†’D such that for any
object A the following diagram commutes in Set:
C(A, C)
C(A,h)
/
Î¦A

C(A, D)
Î¨A

C(G(A, A), C)
C(G(A,A),h)
/ C(G(A, A), D)
In terms of base category C, the square above tells that for any object A and
arrow Î³ : A â†’C, the following equation holds:
h â—¦Î¦A(Î³) = Î¨A(h â—¦Î³)
(5.7)
or diagrammatically:
A
Î³
~~~~~~~
Î´
 @
@
@
@
@
@
@
C
h
/ D
â‡’
G(A, A)
Î¦A(Î³)
{wwwwwwwww
Î¨A(Î´)
#G
G
G
G
G
G
G
G
G
C
h
/ D
70

Note that the equation 5.7 looks exactly the same as the equation 5.3. The only
difference between two is on the typing of Î¦ and Î¨.
Like in the covariant case, G-malgebras and their homomorphisms (for a di-
functor G) form a category Alg(G)m.
Deï¬nition 5.8 (initial malgebra for a difunctor)
A Mendler-style G-algebra (ÂµmG, inm) is the initial G-malgebra if for any Mend-
ler-style G-algebra (C, Î¦) there exists a unique arrow L Î¦ Mm : ÂµmG â†’C satisfy-
ing the universal property:
f â—¦inm
ÂµmG(id) = Î¦(f)
â‰¡
f = L Î¦ Mm
cataM-CHARN
In other words, the initial malgebra (ÂµmG, inm) is an initial object in the cat-
egory Alg(G)m. The cancellation, reï¬‚ection and fusion laws for Mendler-style
catamorphisms specialize as follows:
Corollary 5.11 Let (ÂµmG, inm) be an initial G-malgebra.
â€¢ Cancellation: For any G-malgebra (C, Î¦)
L Î¦ Mm â—¦inm
ÂµmG(id) = Î¦ÂµmG(L Î¦ Mm)
cataM-SELF
â€¢ Reï¬‚ection:
id = L inm Mm
cataM-REFL
â€¢ Fusion: For any G-malgebras (C, Î¦) and (D, Î¨) and an arrow f : C â†’D
f â—¦Î¦C(id) = Î¨C(f)
â‡’
f â—¦L Î¦ Mm = L Î¨ Mm
cataM-FUSION
Note the fact that the arrow mapping part of the signature difunctor is not
mentioned manifestly in the calculational laws for an initial Mendler-style alge-
bra, it only appears in the dinaturality condition and this would in normal practice
always be a â€œtheorem for freeâ€ `a la Wadler [Wad89].
Example 5.2 (course-of-value naturals)
Let G(Y, X) = [Y â†’N(X)] Ã— N(X) and write Natâ€² for the carrier of the ini-
tial Mendler-style G-algebra (ÂµmG, inm). Assume that there exists a predecessor
function predâ€² : Natâ€² â†’1 + Natâ€² which satisï¬es the following speciï¬cation: for
any object A and morphism Î³ : A â†’Natâ€²
predâ€² â—¦inm(Î³) = N(Î³) â—¦snd .
71

Then the functions zeroâ€² : 1 â†’Natâ€² and succâ€² : Natâ€² â†’Natâ€² can be deï¬ned as
zeroâ€²
=
inm
Natâ€²(id) â—¦âŸ¨Î»x. predâ€², inl âŸ©
succâ€²
=
inm
Natâ€²(id) â—¦âŸ¨Î»x. predâ€², inr âŸ©.
Now, the Fibonacci function can be deï¬ned as a Mendler-style catamorphism
ï¬bo = L Î¦ Mm : Natâ€² â†’Nat, where
Î¦A(Î³ : A â†’Nat)(p, inl())
=
one()
Î¦A(Î³ : A â†’Nat)(p, inr(n))
=
[ one, Î»nâ€². add(Î³(n), Î³(nâ€²)) ](p(n))
5.4
Restricted existential types
The project opposite to that of the Section 5.2 â€” reducing Mendler-style inductive
types to conventional inductive types â€” is unperformable in general. But, as we
will see in Section 5.5, it can be carried out, if certain restricted existential types
are available. Let us explain what these are.
Deï¬nition 5.9 (restricted cowedge)
Let G : Cop Ã— C â†’C be an endodifunctor and H : Cop Ã— C â†’Set a difunctor to
Set. An H-restricted G-cowedge (cowedge from G) is a pair (C, Î¦) formed of an
object C of C and dinatural transformation Î¦ between the difunctors H and G/C,
i.e., a family of functions {Î¦A}AâˆˆC between the sets H(A, A) and C(G(A, A), C)
indexed over objects of C such that, for any arrow g : A â†’B the following
diagram commutes:
H(B, A)
H(g,idA)mmmmm
vmmmmm
H(idB,g)
Q
Q
Q
Q
Q
(Q
Q
Q
Q
Q
H(A, A)
Î¦A

H(B, B)
Î¦B

C(G(A, A), C)
C(G(g,idA),C)
Q
Q
Q
Q
Q
(Q
Q
Q
Q
Q
C(G(B, B), C)
C(G(idB,g),C)
mmmmm
vmmmmm
C(G(B, A), C)
72

In other words, Î¦ is a function that takes objects A of C to functions Î¦A
sending elements a of H(A, A) to morphisms Î¦A(a) : G(A, A) â†’C so that the
following condition is met: for any objects A, B and morphism g : A â†’B of C
and any element c of H(B, A), it holds in C that
Î¦A(H(g, idA)c) â—¦G(g, idA) = Î¦B(H(idB, g)c) â—¦G(idB, g)
or diagrammatically
G(B, A)
G(g,idA)

G(idB,g)
/ G(B, B)
Î¦B (H(idB,g)c)

G(A, A)
Î¦A (H(g,idA)c)
/ C
Deï¬nition 5.10 (restricted cowedge homomorphism)
An H-restricted G-cowedge homomorphism between H-restricted G-cowedges
(C, Î¦) and (D, Î¨) is an arrow h : C â†’D of C with the property that, for
any object A of C, it holds in Set that
C(G(A, A), h) â—¦Î¦A = Î¨A
or diagrammatically
H(A, A)
Î¦A
wooooooooooo
Î¨A
'O
O
O
O
O
O
O
O
O
O
O
C(G(A, A), C)
C(G(A,A),h)
/ C(G(A, A), D)
This condition is equivalent to the following one: for any object A of C and
any element a of H(A, A), it is the case in C that h â—¦Î¦A(a) = Î¨A(a).
G(A, A)
Î¦A(a)
{wwwwwwwww
Î¨A(a)
#G
G
G
G
G
G
G
G
G
C
h
/ D
The H-restricted G-cowedges and homomorphisms between them form a cat-
egory, CowH
G.
73

Deï¬nition 5.11 (restricted coend)
An H-restricted G-cowedge (Î£(H, G), injH
G) is a H-restricted G-coend if it is an
initial object of CowH
G; i.e. for any H-restricted G-cowedge (C, Î¦) there exists an
unique arrow f = [ Î¦ ]H
G : Î£(H, G) â†’C satisfying the universal property:
(âˆ€A, a âˆˆH(A, A). f â—¦(injH
G)A(a) = Î¦A(a))
â‰¡
f = [ Î¦ ]H
G
case-CHARN
The cancellation, reï¬‚ection and fusion laws for restricted coends specialize as
follows:
Corollary 5.12 Let (Î£(H, G), injH
G) be a H-restricted G-coend.
â€¢ Cancellation: For any H-restricted G-cowedge (C, Î¦)
âˆ€A, a âˆˆH(A, A). [ Î¦ ]H
G â—¦(injH
G)A(a) = Î¦A(a)
case-SELF
â€¢ Reï¬‚ection:
idÎ£(H,G) = [ injH
G ]H
G
case-REFL
â€¢ Fusion: For any H-restricted G-cowedges (C, Î¦) and (D, Î¨) and arrow
h : C â†’D
(âˆ€A, a âˆˆH(A, A). h â—¦Î¦A(a) = Î¨A(a))
â‡’
h â—¦[ Î¦ ]H
G = [ Î¨ ]H
G
case-FUSION
Example 5.3 (coends)
Consider the constant functor 1 : Cop Ã— C â†’Set, which sends everything into a
singleton set (i.e. an terminal object of Set). Given an endodifunctor G : Cop Ã—
C â†’C, a pair (C, Î¦) is a 1-restricted G-cowedge if Î¦ is a family of arrows
Î¦A = G(A, A) â†’C which make the diagram
G(B, A)
G(g,idA)

G(idB,g)
/ G(B, B)
Î¦B

G(A, A)
Î¦A
/ C
74

commute for every g : A â†’B. In other words, the pair (C, Î¦) is a cowedge
of G in ordinary sense1 (i.e. Î¦ is a dinatural transformation from G to a constant
functor C). Given two cowedges (C, Î¦) and (D, Î¨), an arrow h : C â†’D is
a homomorphism between them iff h â—¦Î¦A = Î¨A for any object A. Finally,
a 1-restricted G-coend is the coend of G (see e.g. [Mac97], where the notation
R c G(c, c) is used for Î£(1, G)).
5.5
Mendler-styles inductive types reduced to
conventional inductive types
The necessary preparations made in the previous section, we are now in a position
to construct a reduction of Mendler-style inductive types to conventional inductive
types. We will obtain it in the same fashion as we obtained the reduction of
conventional inductive types to Mendler-style inductive types in Section 5.2.
Let G be an endodifunctor on C such that, for any object C of C, there exists a
Idâ‰€/C-restricted G-coend ((Î£(Idâ‰€/C, G), injIdâ‰€/C
G
), [ Â· ]Idâ‰€/C
G
). Then, we can deï¬ne
the following endofunction Ge on C:
GeC
=
Î£(Idâ‰€/C, G)
Ge(h : C â†’D)
=
[ Î»A, Î³ : A â†’C. (injIdâ‰€/D
G
)A(h â—¦Î³) ]Idâ‰€/C
G
.
The function Ge turns out to be functorial (as one might expect), so Ge is an
endofunctor on C.
Deï¬nition 5.12
Given a Mendler-style G-algebra (C, Î¦). Deï¬ne
âŒÎ¦âŒŸ= [ Î¦ ]Idâ‰€/C
G
Deï¬nition 5.13
Given a conventional Ge-algebra (C, Ï•). Deï¬ne
âŒœÏ•âŒ= Î»A, Î³ : A â†’C. Ï• â—¦(injIdâ‰€/C
G
)A(Î³)
Proposition 5.13 If (C, Ï•) is a conventional Ge-algebra, then (C, âŒœÏ•âŒ) is a
Mendler-style G-algebra.
1Mac Lane [Mac97] uses the term wedge for both, the dinatural transformations from and to
constant functor. However, universal wedges are called ends and coends respectively, hence our use
of the term cowedge
75

Proof. It has to be checked that âŒœC, Ï•âŒis dinatural.
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
â–·
pick A, B, g : A â†’B, Î² : B â†’C
âŒœÏ•âŒA(Î² â—¦g) â—¦G(g, idA)
=
â€“ âŒœâˆ’âŒ-def â€“
Ï• â—¦(injIdâ‰€/C
G
)A(Î² â—¦g) â—¦G(g, idA)
=
â€“ injIdâ‰€/C
G
dinatural â€“
Ï• â—¦(injIdâ‰€/C
G
)BÎ² â—¦G(idB, g)
=
â€“ âŒœâˆ’âŒ-def â€“
âŒœÏ•âŒB(Î²) â—¦G(idB, g)
Proposition 5.14 If (C, Î¦) is a Mendler-style G-algebra, then (C, âŒÎ¦âŒŸ) is a con-
ventional Ge-algebra.
Proof. Trivial.
Proposition 5.15 If (C, Ï•) is a conventional Ge-algebra, then
âŒâŒœÏ•âŒâŒŸ= Ï•.
Proof.
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
âŒâŒœÏ•âŒâŒŸ
=
â€“ âŒâˆ’âŒŸ-def â€“
[ âŒœÏ•âŒ]Idâ‰€/C
G
=
â€“ âŒœâˆ’âŒ-def â€“
[ Î»A, Î³ : A â†’C.Ï• â—¦(injIdâ‰€/C
G
)A(Î³) ]Idâ‰€/C
G
=
â€“ case fusion â€“
Ï• â—¦[ injIdâ‰€/C
G
]Idâ‰€/C
G
=
â€“ case reï¬‚ection â€“
Ï•
Proposition 5.16 If (C, Î¦) is a Mendler-style G-algebra, then
âŒœâŒÎ¦âŒŸâŒ= Î¦.
76

Proof.
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
â–·
pick A, Î³ : A â†’C
âŒœâŒÎ¦âŒŸâŒA(Î³)
=
â€“ âŒœâˆ’âŒ-def â€“
âŒÎ¦âŒŸâ—¦(injIdâ‰€/C
G
)A(Î³)
=
â€“ âŒâˆ’âŒŸ-def â€“
[ Î¦ ]Idâ‰€/C
G
â—¦(injIdâ‰€/C
G
)A(Î³)
=
â€“ case cancellation â€“
Î¦A(Î³)
Proposition 5.17 If h is a conventional Ge-algebra homomorphism between
(C, Ï•) and (D, Ïˆ), then h is also a Mendler-style G-algebra homomorphism be-
tween (C, âŒœÏ•âŒ) and (D, âŒœÏˆâŒ).
Proof.
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
â–·
h â—¦Ï• = Ïˆ â—¦Geh
â–·
pick A, Î³ : A â†’C
h â—¦âŒœÏ•âŒA(Î³)
=
â€“ âŒœâˆ’âŒ-def â€“
h â—¦Ï• â—¦(injIdâ‰€/C
G
)A(Î³)
=
â€“ â—â€“
Ïˆ â—¦Geh â—¦(injIdâ‰€/C
G
)A(Î³)
=
â€“ Ge-def â€“
Ïˆ â—¦[ Î»A, Î³ : A â†’C. (injIdâ‰€/D
G
)A(h â—¦Î³) ]Idâ‰€/C
G
â—¦(injIdâ‰€/C
G
)A(Î³)
=
â€“ case cancellation â€“
Ïˆ â—¦(injIdâ‰€/D
G
)A(h â—¦Î³)
=
â€“ âŒœâˆ’âŒ-def â€“
âŒœÏˆâŒA(h â—¦Î³)
Proposition 5.18 If h is a Mendler-style G-algebra homomorphism between
(C, Î¦) and (D, Î¨), then h is also a conventional Ge-algebra homomorphism be-
tween (C, âŒÎ¦âŒŸ) and (D, âŒÎ¨âŒŸ).
77

Proof.
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
â–·
âˆ€A, Î³ : A â†’C. h â—¦Î¦A(Î³) = Î¨A(h â—¦Î³)
h â—¦âŒÎ¦âŒŸ
=
â€“ âŒâˆ’âŒŸ-def â€“
h â—¦[ Î¦ ]Idâ‰€/C
G
=
â€“ case fusion â€“
[ Î»A, Î³ : A â†’C. h â—¦Î¦A(Î³) ]Idâ‰€/C
G
=
â€“ â—, with A := A, Î³ := Î³ â€“
[ Î»A, Î³ : A â†’C. Î¨A(h â—¦Î³) ]Idâ‰€/C
G
=
â€“ case cancellation â€“
[ Î»A, Î³ : A â†’C. [ Î¨ ]Idâ‰€/D
G
â—¦(injIdâ‰€/D
G
)A(h â—¦Î³) ]Idâ‰€/C
G
=
â€“ case fusion â€“
[ Î¨ ]Idâ‰€/D
G
â—¦[ Î»A, Î³ : A â†’C. (injIdâ‰€/D
G
)A(h â—¦Î³) ]Idâ‰€/C
G
=
â€“ Ge-def â€“
[ Î¨ ]Idâ‰€/D
G
â—¦Ge(h)
=
â€“ âŒâˆ’âŒŸ-def â€“
âŒÎ¨âŒŸâ—¦Ge(h)
These propositions tell us that there exists a functor between the categories
Alg(Ge) and Alg(G)m and a left-and-right inverse for it.
Theorem 5.19 The categories Alg(Ge) and Alg(G)m are isomorphic.
From here, the following is obvious already.
Corollary 5.20 If (ÂµGe, in) is an initial Ge-algebra, then (ÂµGe, âŒœinâŒ) is an initial
G-malgebra. For any G-malgebra (C, Î¦), the catamorphism L âŒÎ¦âŒŸM : ÂµGe â†’C
is the unique homomorphism from (ÂµGe, in) to (C, Î¦).
Corollary 5.21 If (ÂµmG, inm) is an initial Mendler-style G-algebra, then
(ÂµmG, âŒinmâŒŸ) is an initial conventional Ge-algebra. For any conventional Ge-
algebra (C, Ï•), the Mendler-style catamorphism L âŒœÏ•âŒMm : ÂµmG â†’C is the
unique conventional homomorphism from (ÂµmG, inm) to (C, Ï•).
5.6
Mendler-style inductive types in Haskell
Mendler-style inductive types can be modeled in Haskell by using existential types
and rank-2 type signatures. While not part of the ofï¬cial Haskell98 language
78

deï¬nition, several Haskell implementations (e.g. Hugs, ghc, hbc) support them as
language extensions.
According to Corollary 5.20, an initial Mendler-style algebra for a difunctor
G is an initial (conventional) Ge-algebra, where functor Ge is constructed from
G by terms of certain restricted coends. Hence, in order to model Mendler-style
inductive types, we ï¬rst have to implement restricted coends.
The Haskell correspondent for a H-restricted G-cowedge (C, Î¦) is a polymor-
phic function phi :: H a -> G a -> C (together with the type C), where H
and G are type constructors. Thus, H-restricted G-coends can be implemented as
follows:
> data RCoEnd h g = forall a . InjRCE (h a) (g a)
Given type constructors h and g, this deï¬nes the type RCoEnd h g as a pair
of values of type h a and g a respectively. The type variable a is existentially
quantiï¬ed2 and does not appear in RCoEnd h g. It also deï¬nes the data construc-
tor InjRCE :: h a -> g a -> RCoEnd g c which corresponds to the re-
stricted coend. The universal cowedge homomorphism out of InjRCE can be
deï¬ned as follows:
> caseRCE :: (forall a . h a -> g a -> c)
-> RCoEnd h g -> c
> caseRCE phi (InjRCE ha ga) = phi ha ga
Note the use of rank 2 type signature to ensure that the ï¬rst argument is a poly-
morphic function (i.e. is a restricted cowedge).
The type constructor corresponding to Ge can be deï¬ned by instantiating the
ï¬rst parameter of RCoEnd with a type constructor represented by (->c). Unfor-
tunately, Haskell does not allow sectioning of inï¬x type constructors (as it does
for â€œordinaryâ€ inï¬x operators). Hence, we have to deï¬ne the corresponding type
constructor explicitly.
> newtype Fun c a = Fun (a -> c)
> newtype Ext g c = Ext (RCoEnd (Fun c) g)
We also â€œliftâ€ the deï¬nitions of restricted coends and universal cowedge homo-
morphisms for Ext g c.
> injExt :: (a -> c) -> g a -> Ext g c
> injExt h x = Ext (InjRCE (Fun h) x)
2The apparently counterintuitive use of forall to capture existentially quantiï¬ed variables is
justiï¬ed by the logical equivalence âˆ€A.P â‡’Q â‰¡(âˆƒA.P) â‡’Q, if A is not free in Q.
79

> caseExt :: (forall a . (a -> c) -> g a -> d)
>
-> Ext g c -> d
> caseExt phi (Ext (InjRCE (Fun h) x)) = phi h x
The arrow mapping part of the functor Ge can be deï¬ned as follows:
> instance Functor (Ext g) where
>
fmap f = caseExt (\ h -> injExt (f . h))
Now, using the Corollary 5.20, we can deï¬ne Mendler-style inductive types, initial
malgebras and Mendler-style catamorphisms as follows:
> type MuM g = Mu (Ext g)
> inM :: (a -> MuM g) -> g a -> MuM g
> inM h x = In (injExt h x)
> cataM :: (forall a . (a -> c) -> g a -> c)
>
-> MuM g -> c
> cataM phi = cata (caseExt phi)
Instead of going through conventional inductive types, we could also imple-
ment Mendler-style inductive types directly as ï¬xed points of certain existential
types.
data MuM g = forall a. InM (a -> MuM g) (g a)
cataM :: (forall a. (a -> c) -> g a -> c)
-> MuM g -> c
cataM phi (InM h x) = phi (cataM phi . h) x
In this case, according to Corollary 5.9, we could deï¬ne conventional inductive
types in terms of Mendler-style inductive types (only for type constructors which
are functors).
type Mu f = MuM f
inMu :: f (Mu f) -> Mu f
inMu = InM id
cata :: Functor f => (f c -> c) -> Mu f -> c
cata phi = cataM (\ f -> phi . fmap f)
80

It may be helpful to think about the existentially quantiï¬ed type variable a as
some (abstract) type of internal representations for the data type. Then, values of
type MuM g are constructed from a function which converts internal representa-
tions to the data type together with the actual value itself, where the â€œouterâ€ struc-
ture (given by type constructor g) is explicit but substructures are in the internal
form. In particular, the deï¬nition of conventional inductive types is obtained by
using the data type itself also for the internal representation.
Example 5.4 (naturals)
The Mendler-style deï¬nition of natural numbers involves the same type construc-
tor N as the conventional deï¬niton (see example 2.10).
> type NatM = MuM N
The constructor functions for naturals can be deï¬ned as follows:
> zeroNM :: NatM
> zeroNM
= inM id Z
> succNM
:: NatM -> NatM
> succNM n = inM id (S n)
The sum of two naturals can be deï¬ned in terms of Mendler-style catamorphism
as follows:
> addNM :: NatM -> NatM -> NatM
> addNM x y = cataM phi x
>
where phi add_y Z
= y
>
phi add_y (S n) = succNM (add_y n)
Example 5.5 (course-of-value naturals)
Course-of-value naturals from example 5.2 can be implemented as follows:
> data Nâ€™ x = Nâ€™ (x -> N x) (N x)
> type NatCM = MuM Nâ€™
In order to deï¬ne â€œstandardâ€ constructor functions, we ï¬rst have to deï¬ne the
predecessor function for course-of-value naturals:
> predC :: NatCM -> N NatCM
> predC = caseExt phi . unIn
>
where phi h (Nâ€™ _
Z)
= Z
>
phi h (Nâ€™ _ (S n)) = S (h n)
81

Now, constructor functions can be deï¬ned as follows:
> zeroC
:: NatCM
> zeroC
= inM id (Nâ€™ predC Z)
> succC
:: NatCM -> NatCM
> succC n = inM id (Nâ€™ predC (S n))
The Fibonacci function from course-of-value naturals to integers can be deï¬ned
as follows:
> fibC :: NatCM -> Int
> fibC
= cataM phi
>
where phi fib (Nâ€™ p Z) = 1
>
phi fib (Nâ€™ p (S n))
>
= case p n of
>
Z
-> fib n
>
S m -> fib n + fib m
5.7
Related work
The concept of Mendler-style inductive type is an abstraction from N. P. Mendlerâ€™s
work [Men91] on an extension of system F (2nd-order simply-typed lambda-
calculus) with inductive and coinductive types. This system supported iteration
and coiteration through unusual operators whose beta-reduction rules did not men-
tion the arrow mapping component of the base functor of the (co)inductive type.
In [UV97, UV00b, Uus98, Mat98, Mat00], an observation was emphasized that
the system does not loose any of its desirable meta-theoretic properties, if the
base functor is permitted to be non-covariant. It was also shown how to interpret
the liberalized system in lattice theory (ÂµF is not necessarily of (pre-)ï¬xed point
of F, if F is non-monotonic). The same lattice theory explanations reappeared
in [SU99]. The category-theoretic account given here is a â€œgloriï¬cationâ€ of the
lattice-theoretic semantics.
82

CHAPTER 6
MENDLER-STYLE RECURSION
SCHEMES
In this chapter we present an alternative formalization of recursion operators (for
conventional inductive types) which is based on Mendler-style algebras. In par-
ticular, we develop Mendler-style operators for basic iteration, primitive recur-
sion and course-of-value iteration. The new operators are equivalent to the cor-
responding conventional ones, but are somewhat more intuitive (at least in our
opinion) against the background of â€œordinaryâ€ (general-)recursive programming.
This chapter is based on [UV00a].
In order to explain the difference between conventional and Mendler-style
approach, consider the function f : ÂµF â†’C deï¬ned by simple iteration. The
recursive deï¬ning equation for it is in the form
f â—¦in = Î¦(f),
where Î¦ is some deï¬nable function from arrows ÂµF â†’C to arrows FÂµF â†’C.
Just in this form, the equation does not necessarily deï¬ne f iteratively. Indeed,
the characterizing equations for primitive recursion and course-of-value iteration
are exactly in the same form. In fact, the equation may have no solution in which
case it does not deï¬ne f at all.
The conventional method to ensure that the equation deï¬nes f by a simple
iteration consists in insisting that Î¦(f) = Ï•â—¦F(f), where Ï• : F(C) â†’C is some
F-algebra. This means imposing a relatively syntactic condition on the right-hand
side of the equation: no expression other than â€˜Ï• â—¦F(f)â€™ is acceptable unless we
are eager and able to prove that it equals Ï• â—¦F(f) (which may require quite a bit
of equational reasoning).
The Mendler-style method to ensure that the equation deï¬nes f by a simple
iteration is leave the form of its right-hand side as it is (i.e. â€˜Î¦(f)â€™) but to require
Î¦ not to use any speciï¬cs about the type ÂµF. This is achievable by insisting that Î¦
83

is an instance of a function parametric in A from arrows of type A â†’C to arrows
of type F(A) â†’C (which is veriï¬able by type-checking). This means adopting
a considerably more semantic approach to controlling the right-hand side of the
equation.
6.1
Simple iteration
Mendler-style coding of the simple iteration follows directly from the properties
of initial Mendler-style algebras for a (covariant) functor presented in Section 5.2.
According to Theorem 5.8 and its corollaries any initial algebra determines an
initial Mendler-style algebra and vice versa. Hence, we can take an initial al-
gebra (ÂµF, in) and characterize Mendler-style homomorphisms out of the initial
malgebra (ÂµF, âŒœinâŒ) directly in terms of it.
Deï¬nition 6.1 (m-catamorphism)
Let (ÂµF, in) be an initial F-algebra. For any F-malgebra (C, Î¦), a m-catamorphism
f = L Î¦ Mm : ÂµF â†’C is a unique arrow satisfying the universal property
f â—¦in = Î¦ÂµF(f)
â‰¡
f = L Î¦ Mm
mcata-CHARN
From this, the cancellation, reï¬‚ection, and fusion laws for m-catamorphism
follow straightforwardly.
Corollary 6.1 Let (ÂµF, in) be an initial F-algebra.
â€¢ Cancellation: For any F-malgebra (C, Î¦)
L Î¦ Mm â—¦in = Î¦ÂµF(L Î¦ Mm)
mcata-SELF
â€¢ Reï¬‚ection:
id = L Î»A, Î³ : A â†’ÂµF. in â—¦F(Î³) Mm
mcata-REFL
â€¢ Fusion: For any F-malgebras (C, Î¦) and (D, Î¨) and an arrow f : C â†’D
(âˆ€A, Î³ : A â†’C. f â—¦Î¦A(Î³) = Î¨A(f â—¦Î³))
â‡’
f â—¦L Î¦ Mm = L Î¨ Mm
mcata-FUSION
84

Note that the left-hand side of the fusion law is equivalent to the simpler
equation f â—¦Î¦ÂµF(id) = Î¨ÂµF(f). However, for calculational purposes the one
in mcata-FUSION is preferable, as it can be directly instantiated in different con-
texts.
From the Corollary 5.10, we get the deï¬nition of m-catamorphism as con-
ventional catamorphism. Similarly, the Corollary 5.9 gives to us the deï¬nition of
conventional catamorphism as m-catamorphism.
Corollary 6.2 Let (C, Î¦) be a F-malgebra, then
L Î¦ Mm = L Î¦ÂµF(id) M
mcata-DEF
Corollary 6.3 Let (C, Ï•) be a F-algebra, then
L Ï• M = L Î»A, Î³ : A â†’C. Ï• â—¦F(Î³) Mm
mcata-CATA
6.2
Primitive recursion
In this section we formalize the primitive recursion operator in the Mendler-style
setting. For this, we ï¬rst introduce the notions of rec-malgebra and their homo-
morphisms.
Deï¬nition 6.2 (rec-malgebra)
Let F : C â†’C be an endofunctor for which there exists an initial algebra (ÂµF, in).
A F-rec-malgebra is a pair (C, Î¦), where C is an object and Î¦ : C(âˆ’, C Ã—
ÂµF) .â†’C(F(âˆ’), C) is a natural transformation; i.e. for any arrow g : A â†’B
the following diagram commutes:
C(B, C Ã— ÂµF)
Î¦B
/
C(g, CÃ—idÂµF)

C(F(B), C)
C(F(g),C)

C(A, C Ã— ÂµF)
Î¦A
/ C(F(A), C)
In other words, Î¦ is a family of functions {Î¦A}AâˆˆC which take arrows Î± :
A â†’C Ã— ÂµF to the arrows Î¦A(Î±) : F(A) â†’C. The naturality condition says,
85

that Î¦ preserves compositions in the following sense: if Î± = Î² â—¦g for some object
B and arrows Î² : B â†’C Ã— ÂµF, g : A â†’B, then
Î¦A(Î² â—¦g) = Î¦B(Î²) â—¦F(g)
(6.1)
or diagrammatically
A
Î±
#G
G
G
G
G
G
G
G
G
g
/ B
Î²
{wwwwwwwww
C Ã— ÂµF
â‡’
F(A)
Î¦A(Î±)
!D
D
D
D
D
D
D
D
F(g)
/ F(B)
Î¦B(Î²)
}zzzzzzzz
C
In particular, by taking B = C Ã— ÂµF and Î² = idCÃ—ÂµF, we get an equivalent
condition:
Î¦A(Î±) = Î¦CÃ—ÂµF(id) â—¦F(Î±)
(6.2)
Deï¬nition 6.3 (rec-malgebra homomorphism)
Let (C, Î¦) and (D, Î¨) be two F-rec-malgebras. A homomorphism from (C, Î¦) to
(D, Î¨) is an arrow h : C â†’D in the category C, such that for any object A the
following diagram commutes in Set:
C(A, C Ã— ÂµF)
C(A,hÃ—idÂµF) /
Î¦A

C(A, D Ã— ÂµF)
Î¨A

C(F(A), C)
C(F(A),h)
/ C(F(A), D)
In terms of the base category, the square above tells that for any object A and
arrow Î³ : A â†’C Ã— ÂµF, the following equation holds:
h â—¦Î¦A(Î³) = Î¨A((h Ã— id) â—¦Î³)
(6.3)
or diagrammatically:
A
Î³
{wwwwwwwww
Î´
#G
G
G
G
G
G
G
G
G
C Ã— ÂµF
hÃ—idÂµF
/ D Ã— ÂµF
â‡’
F(A)
Î¦A(Î³)
}zzzzzzzz
Î¨A(Î´)
!D
D
D
D
D
D
D
D
C
h
/ D
In particular, if we take A = C Ã— ÂµF and Î³ = idCÃ—ÂµF, then
h â—¦Î¦C(id) = Î¨C(h Ã— id).
(6.4)
86

Note that, in a cartesian closed base category, F-rec-malgebras and their ho-
momorphisms are equivalent to ordinary Mendler-style algebras and homomor-
phisms for a difunctor G(Y, X) = [Y â†’ÂµF] Ã— F(X).
Deï¬nition 6.4 (m-paramorphism)
Let (ÂµF, in) be an initial F-algebra. For any F-rec-malgebra (C, Î¦), a m-para-
morphism f = âŸ¨| Î¦ |âŸ©m : ÂµF â†’C is a unique arrow satisfying the universal
property
f â—¦in = Î¦ÂµFâŸ¨f, id âŸ©
â‰¡
f = âŸ¨| Î¦ |âŸ©m
mpara-CHARN
Proposition 6.4 Let (ÂµF, in) be an initial F-algebra.
â€¢ Cancellation: For any F-rec-malgebra (C, Î¦)
âŸ¨| Î¦ |âŸ©m â—¦in = Î¦ÂµFâŸ¨âŸ¨| Î¦ |âŸ©m, id âŸ©
mpara-SELF
â€¢ Reï¬‚ection:
id = âŸ¨| Î»A, Î³ : A â†’ÂµF Ã— ÂµF. in â—¦F(fst â—¦Î±) |âŸ©m
mpara-REFL
â€¢ Fusion: For any F-rec-malgebras (C, Î¦) and (D, Î¨) and an arrow f :
C â†’D
(âˆ€A, Î³ : A â†’C Ã— ÂµF. f â—¦Î¦A(Î³) = Î¨A((f Ã— id) â—¦Î³))
â‡’
f â—¦âŸ¨| Î¦ |âŸ©m = âŸ¨| Î¨ |âŸ©m
mpara-FUSION
Proof. The cancellation law is directly obtained form the universal property of
paramorphisms by substituting f := âŸ¨| Î¦ |âŸ©m thus making the right-hand equation
in mpara-CHARN trivially true. For the reï¬‚ection law we argue:
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
id
=
â€“ mpara-CHARN â€“
ï£®
ï£¯ï£¯ï£¯ï£¯ï£°
id â—¦in
=
â€“ identity, F functor â€“
in â—¦F(id)
=
â€“ pairing â€“
in â—¦F(fst â—¦âŸ¨id, id âŸ©)
âŸ¨| Î»A, Î³ : A â†’ÂµF Ã— ÂµF. in â—¦F(fst â—¦Î³) |âŸ©m
87

Finally, the fusion law is proved as follows:
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
â–·
âˆ€A, Î³ : A â†’C Ã— ÂµF. f â—¦Î¦A(Î³) = Î¨A((f Ã— id) â—¦Î³)
f â—¦âŸ¨| Î¦ |âŸ©m
=
â€“ mpara-CHARN â€“
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
f â—¦âŸ¨| Î¦ |âŸ©m â—¦in
=
â€“ mpara-SELF â€“
f â—¦Î¦ÂµFâŸ¨âŸ¨| Î¦ |âŸ©m, id âŸ©
=
â€“ â—â€“
Î¨ÂµF((f Ã— id) â—¦âŸ¨âŸ¨| Î¦ |âŸ©m, id âŸ©)
=
â€“ pairing â€“
Î¨ÂµFâŸ¨f â—¦âŸ¨| Î¦ |âŸ©m, id âŸ©
âŸ¨| Î¨ |âŸ©m
Proposition 6.5 For any F-rec-malgebras (C, Î¦)
âŸ¨| Î¦ |âŸ©m = âŸ¨| Î¦ÂµFÃ—ÂµF(id) |âŸ©
mpara-DEF
Proof.
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
âŸ¨| Î¦ÂµFÃ—ÂµF(id) |âŸ©
=
â€“ mpara-CHARN â€“
ï£®
ï£¯ï£¯ï£¯ï£¯ï£°
âŸ¨| Î¦ÂµFÃ—ÂµF(id) |âŸ©â—¦in
=
â€“ para-SELF â€“
Î¦ÂµFÃ—ÂµF(id) â—¦F âŸ¨âŸ¨| Î¦ÂµFÃ—ÂµF(id) |âŸ©, id âŸ©
=
â€“ 6.2 â€“
Î¦ÂµFâŸ¨âŸ¨| Î¦ÂµFÃ—ÂµF(id) |âŸ©, id âŸ©
âŸ¨| Î¦ |âŸ©m
Proposition 6.6 For any arrow Ï• : F(C Ã— ÂµF) â†’C
âŸ¨| Ï• |âŸ©= âŸ¨| Î»A, Î³ : A â†’C Ã— ÂµF. Ï• â—¦F(Î³) |âŸ©m
mpara-PARA
Proof.
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
âŸ¨| Î»A, Î³ : A â†’C Ã— ÂµF. Ï• â—¦F(Î³) |âŸ©m
=
â€“ para-CHARN â€“
ï£®
ï£°
âŸ¨| Î»A, Î³ : A â†’C Ã— ÂµF. Ï• â—¦F(Î³) |âŸ©m â—¦in
=
â€“ mpara-SELF â€“
Ï• â—¦FâŸ¨âŸ¨| Î»A, Î³ : A â†’C Ã— ÂµF. Ï• â—¦F(Î³) |âŸ©m, id âŸ©
âŸ¨| Ï• |âŸ©
88

Proposition 6.7 For any F-malgebra (C, Î¦)
L Î¦ Mm = âŸ¨| Î»A, Î³ : A â†’C Ã— ÂµF. Î¦A(fst â—¦Î³) |âŸ©m
mpara-MCATA
Proof.
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
âŸ¨| Î»A, Î³ : A â†’C Ã— ÂµF. Î¦A(fst â—¦Î³) |âŸ©m
=
â€“ mcata-CHARN â€“
ï£®
ï£¯ï£¯ï£¯ï£¯ï£°
âŸ¨| Î»A, Î³ : A â†’C Ã— ÂµF. Î¦A(fst â—¦Î³) |âŸ©m â—¦in
=
â€“ mpara-SELF â€“
Î¦ÂµF(fst â—¦âŸ¨âŸ¨| Î»A, Î³ : A â†’C Ã— ÂµF. Î¦A(fst â—¦Î³) |âŸ©m, id âŸ©)
=
â€“ pairing â€“
Î¦ÂµFâŸ¨| Î»A, Î³ : A â†’C Ã— ÂµF. Î¦A(fst â—¦Î³) |âŸ©m
L Î¦ Mm
6.3
Course-of-value iteration
In this section we formalize the course-of-value iteration operator in the Mendler-
style setting. We do it in the analogous way to the primitive recursion by intro-
ducing the notions of cv-malgebra and their homomorphisms. For this, we need
Mulryâ€™s notion of strong dinaturality [Mul91].
Deï¬nition 6.5 (strong dinaturality)
Let H, G : Cop Ã— C â†’A be difunctors. A strong dinatural transformation Î¦ :
H ..â†’G is a family of maps Î¦A for all A âˆˆC, such that for every arrow g : A â†’B
the following diagram commutes:
W
xrrrrrrrrrrr
&M
M
M
M
M
M
M
M
M
M
M
H(A, A)
Î¦A

H(idA,g)
LLLL
%LLLL
H(B, B)
Î¦B

H(g,idB)
rrrr
yrrrr
H(A, B)
G(A, A)
G(idA,g)
LLLL
%LLLL
G(B, B)
G(g,idB)
rrrr
yrrrr
G(A, B)
where W is the pullback of H(idA, g) and H(g, idB).
89

Proposition 6.8 ([Mul91]) Every strong dinatural transformation Î¦ : H ..â†’G is a
dinatural transformation.
Proof. Since H(idA, g) â—¦H(g, idA) = H(g, idB) â—¦H(idB, g), the pair of arrows
H(g, idA) and H(idB, g) factors through W and thus G(idA, g)â—¦Î¦Aâ—¦H(g, idA) =
G(g, idB) â—¦Î¦B â—¦H(idB, g).
Note that malgebras and rec-malgebras, which by deï¬nition are dinatural
transformations, are also strong dinatural transformations, as the pullback squares
for them are trivial.
Deï¬nition 6.6 (cv-malgebra)
Let F : C â†’C be an endofunctor. A F-cv-malgebra is a pair (C, Î¦), where
C is an object and Î¦ : C(âˆ’, C Ã— F(=)) ..â†’C(F(âˆ’), C) is a strong dinatural
transformation; i.e. for any arrow g : A â†’B the following diagram commutes:
W
ukkkkkkkkkkkkkkkk
)S
S
S
S
S
S
S
S
S
S
S
S
S
S
S
S
C(A, C Ã— F(A))
Î¦A

C(idA,idCÃ—F(g))
R
R
R
R
R
)R
R
R
R
R
C(B, C Ã— F(B))
Î¦B

C(g,idCÃ—F(B))
lllll
ulllll
C(A, C Ã— F(B))
C(F(A), C)
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
C(F(B), C)
C(F(g),C)
lllll
ulllll
C(F(A), C)
where W = {(Î± : A â†’CÃ—F(A), Î² : A â†’CÃ—F(A)) | (idCÃ— F(g))â—¦Î± = Î²â—¦g}
is a pullback of C(idA, idCÃ—F(g)) and C(g, idCÃ—F(B)).
In terms of the base category C, Î¦ is a family of functions {Î¦A}AâˆˆC which
take FÃ—
C-coalgebras (see Deï¬nition 4.1) Î± : A â†’C Ã— F(A) to the arrows
Î¦A(Î±) : F(A) â†’C. The strong dinaturality condition means, that for arbi-
trary FÃ—
C-coalgebras Î± : A â†’C Ã— F(A) and Î² : B â†’C Ã— F(B), and an arrow
g : A â†’B, the following holds:
(idCÃ— F(g)) â—¦Î± = Î² â—¦g
â‡’
Î¦A(Î±) = Î¦B(Î²) â—¦F(g)
(6.5)
90

or diagrammatically
A
g

Î±
/ C Ã— F(A)
idCÃ— F(g)

B
Î²
/ C Ã— F(B)
â‡’
F(A)
Î¦A(Î±)
!D
D
D
D
D
D
D
D
F(g)
/ F(B)
Î¦B(Î²)
}zzzzzzzz
C
Note that the left-hand side of the implication says, that g is a homomorphism
between FÃ—
C-coalgebras Î± and Î².
Assume that there exists a terminal FÃ—
C-coalgebra (Î½FÃ—
C, out). Then, by taking
B = Î½FÃ—
C and Î² = out, the condition 6.5 simpliï¬es to the following equation:
Î¦A(Î±) = Î¦Î½FÃ—
C(out) â—¦F([( Î± )])
(6.6)
As the calculation below shows, the equation is equivalent to the previous impli-
cation. Indeed, if equation 6.6 holds, then
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
â–·
pick A, B, g : A â†’B, Î± : A â†’C Ã— F(A), Î² : B â†’C Ã— F(B)
â–·
(idC Ã—F(g)) â—¦Î± = Î² â—¦g
Î¦A(Î±)
=
â€“ 6.6 â€“
Î¦Î½FÃ—
C(out) â—¦F([( Î± )])
=
â€“ â—, ana-FUSION â€“
Î¦Î½FÃ—
C(out) â—¦F([( Î² )] â—¦g)
=
â€“ F functor â€“
Î¦Î½FÃ—
C(out) â—¦F([( Î² )]) â—¦F(g)
=
â€“ 6.6 â€“
Î¦B(Î²) â—¦F(g)
Deï¬nition 6.7 (cv-malgebra homomorphism)
Let (C, Î¦) and (D, Î¨) be two F-cv-malgebras. A homomorphism from (C, Î¦) to
(D, Î¨) is an arrow h : C â†’D in the category C, such that for any object A the
following diagram commutes in Set:
C(A, C Ã— F(A))
C(idA,hÃ—idF(A))/
Î¦A

C(A, D Ã— F(A))
Î¨A

C(F(A), C)
C(idF(A),h)
/ C(F(A), D)
91

In terms of the base category, the square above tells that for any object A and
FÃ—
C-coalgebra Î³ : A â†’C Ã— F(A), the following equation holds:
h â—¦Î¦A(Î³) = Î¨A((h Ã— id) â—¦Î³)
(6.7)
or diagrammatically:
A
Î³
zuuuuuuuuuu
Î´
$I
I
I
I
I
I
I
I
I
I
C Ã— F(A)
hÃ—idF(A)
/ D Ã— F(A)
â‡’
F(A)
Î¦A(Î³)
}zzzzzzzz
Î¨A(Î´)
!D
D
D
D
D
D
D
D
C
h
/ D
Assuming that there exists a terminal FÃ—
D-coalgebra (Î½FÃ—
D, out), the condition
above simpliï¬es to the equivalent equation:
h â—¦Î¦A(out) = Î¨A((h Ã— id) â—¦out)
(6.8)
Note that, in a cartesian closed base category, F-cv-malgebras and their ho-
momorphisms are equivalent to ordinary Mendler-style algebras and homomor-
phisms for a difunctor G(Y, X) = [Y â†’F(X)] Ã— F(X) (the instance of which
we used in the example 5.2 for course-of-value naturals).
Deï¬nition 6.8 (m-histomorphism)
Let (ÂµF, in) be an initial F-algebra. For any F-cv-malgebra (C, Î¦), a m-histo-
morphism f = {| Î¦ |}m : ÂµF â†’C is a unique arrow satisfying the universal
property
f â—¦in = Î¦ÂµFâŸ¨f, inâˆ’1 âŸ©
â‰¡
f = {| Î¦ |}m
mhisto-CHARN
Proposition 6.9 Let (ÂµF, in) be an initial F-algebra.
â€¢ Cancellation: For any F-cv-malgebra (C, Î¦)
{| Î¦ |}m â—¦in = Î¦ÂµFâŸ¨{| Î¦ |}m, inâˆ’1 âŸ©
mhisto-SELF
â€¢ Reï¬‚ection:
id = {| Î»A, Î³ : A â†’ÂµF Ã— F(A). in â—¦F(fst â—¦Î³) |}m
mhisto-REFL
â€¢ Fusion:
For any F-cv-malgebras (C, Î¦) and (D, Î¨) and an arrow
f : C â†’D
(âˆ€A, Î³ : A â†’C Ã— F(A). f â—¦Î¦A(Î³) = Î¨A((f Ã— id) â—¦Î³))
â‡’
f â—¦{| Î¦ |}m = {| Î¨ |}m
mhisto-FUSION
92

Proof. The cancellation law is directly obtained form the universal property. For
the reï¬‚ection law we argue:
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
id
=
â€“ mhisto-CHARN â€“
ï£®
ï£¯ï£¯ï£¯ï£¯ï£°
id â—¦in
=
â€“ identity, F functor â€“
in â—¦F(id)
=
â€“ pairing â€“
in â—¦F (fst â—¦âŸ¨id, inâˆ’1 âŸ©)
{| Î»A, Î³ : A â†’ÂµF Ã— F(A). in â—¦F(fst â—¦Î³) |}m
Finally, the fusion law is proved as follows:
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
â–·
âˆ€A, Î³ : A â†’C Ã— F(A). f â—¦Î¦A(Î³) = Î¨A((f Ã— id) â—¦Î³)
f â—¦{| Î¦ |}m
=
â€“ mhisto-CHARN â€“
ï£®
ï£¯ï£¯ï£¯ï£¯ï£°
f â—¦{| Î¦ |}m â—¦in
=
â€“ mhisto-SELF â€“
f â—¦Î¦ÂµFâŸ¨{| Î¦ |}m, inâˆ’1 âŸ©
=
â€“ â—â€“
Î¨ÂµFâŸ¨f â—¦{| Î¦ |}m, inâˆ’1 âŸ©
{| Î¨ |}m
If there exists a terminal FÃ—
D-coalgebra (Î½FÃ—
D, out), then any m-histomorphism
can be deï¬ned in terms of a (conventional) histomorphism, and vice versa.
Proposition 6.10 Let (Î½FÃ—
C, out) be a terminal FÃ—
C-coalgebra, then for any F-cv-
malgebra (C, Î¦)
{| Î¦ |}m = {| Î¦Î½FÃ—
C(out) |}
mhisto-DEF
Proof.
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
{| Î¦Î½FÃ—
C(out) |}
=
â€“ mhisto-CHARN â€“
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
{| Î¦Î½FÃ—
C(out) |} â—¦in
=
â€“ histo-SELF â€“
Î¦Î½FÃ—
C(out) â—¦F [( âŸ¨{| Î¦Î½FÃ—
C(out) |}, inâˆ’1 âŸ©)]
=
â€“ 6.6 â€“
Î¦ÂµFâŸ¨{| Î¦Î½FÃ—
C(out) |}, inâˆ’1 âŸ©
{| Î¦ |}m
93

Proposition 6.11 For any F-cv-algebra Ï• : F(FÎ½(C)) â†’C
{| Ï• |} = {| Î»A, Î³ : A â†’C Ã— F(A). Ï• â—¦F[( Î³ )] |}m
mhisto-HISTO
Proof.
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
{| Î»A, Î³ : A â†’C Ã— F(A). Ï• â—¦F[( Î³ )] |}m
=
â€“ histo-CHARN â€“
ï£®
ï£°
{| Î»A, Î³ : A â†’C Ã— F(A). Ï• â—¦F[( Î³ )] |}m â—¦in
=
â€“ mhisto-SELF â€“
Ï• â—¦F[( âŸ¨{| Î»A, Î³ : A â†’C Ã— F(A). Ï• â—¦F[( Î³ )] |}m, inâˆ’1 âŸ©)]
{| Ï• |}
Every m-catamorphism can be deï¬ned as m-histomorphism, which uses only
the value on the â€œpredecessorâ€ of the current argument.
Proposition 6.12 For any F-malgebra (C, Î¦)
L Î¦ Mm = {| Î»A, Î³ : A â†’C Ã— F(A). Î¦(fst â—¦Î³) |}m
mhisto-MCATA
Proof.
ï£®
ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
{| Î»A, Î³ : A â†’C Ã— F(A). Î¦(fst â—¦Î³) |}m
=
â€“ mcata-CHARN â€“
ï£®
ï£¯ï£¯ï£¯ï£¯ï£°
{| Î»A, Î³ : A â†’C Ã— F(A). Î¦(fst â—¦Î³) |}m â—¦in
=
â€“ mhisto-SELF â€“
Î¦(fst â—¦âŸ¨{| Î»A, Î³ : A â†’C Ã— F(A). Î¦(fst â—¦Î³) |}m, inâˆ’1 âŸ©)
=
â€“ pairing â€“
Î¦{| Î»A, Î³ : A â†’C Ã— F(A). Î¦(fst â—¦Î³) |}m
L Î¦ Mm
6.4
Mendler-style recursion operators in Haskell
In Haskell, we can implement m-catamorphisms as follows:
> mcata :: (forall a. (a -> c) -> f a -> c)
>
-> Mu f -> c
> mcata phi (In x) = phi (mcata phi) x
94

The constraint for phi, that it is Mendler-style algebra, is expressed by its typing,
which requires phi to be polymorphic on a. Differently from conventional cata-
morphisms, the type for mcata does not contain the restriction for type construc-
tor f to be an instance of class Functor. This is not required, as the deï¬ning
equation (which expresses the cancellation law), does not use fmap. Note that
there was no such requirement in the deï¬nition of type Mu f either. Hence, if we
use mcata combinator instead of cata, we can deï¬ne inductive types only by
deï¬ning the corresponding type constructor, and no instance declaration for class
Functor is required.
Example 6.1 (naturals to integers)
The function nat2int, which converts naturals to corresponding integers, can be
deï¬ned as m-catamorphism:
> nat2int :: Nat -> Int
> nat2int = mcata phi
>
where phi n2i Z
= 0
>
phi n2i (S n) = 1 + n2i n
Note that n in the second equation of phi corresponds to the original predecessor,
and not to the value of the function on it (as it had been case if we had used cata).
The value on the predecessor is computed by applying to it the function provided
as the ï¬rst argument of phi. Using the suitable naming of this argument, the
deï¬nition of phi becomes very similar to the directly recursive deï¬nition for the
function nat2int.
Example 6.2 (length)
The function, which computes the length of a given list, can be deï¬ned as follows:
> lengthM :: List a -> Nat
> lengthM = mcata phi
>
where phi len N
= zeroN
>
phi len (C _ xs) = succN (len xs)
The Haskell correspondent for a F-rec-malgebra is a polymorphic function of
type (a -> (c, Mu f)) -> (f a -> c) for some ï¬xed type constructor f
and type c. However, for convenience, we use an equivalent version of it; namely,
(a -> c) -> (a -> Mu f) -> (f a -> c). Now, we can implement
m-paramorphisms, by using the accordingly modiï¬ed cancellation law, as follows:
> mpara :: (forall a. (a -> c) -> (a -> Mu f)
>
->
f a -> c)
>
->
Mu f -> c
> mpara phi (In x) = phi (mpara phi) id x
95

Example 6.3 (factorial)
The factorial function can be implemented as Mendler-style paramorphism:
> factM :: Nat -> Nat
> factM = mpara phi
>
where phi fac i Z = oneN
>
phi fac i (S x)
>
= mulN (succN (i x)) (fac x)
The ï¬rst functional argument of phi is used for computing the value on the previ-
ous argument x (like in the case of mcata combinator). However, now phi has
also the second functional argument i, which is applied to the previous argument
in places where the argument itself is needed.
Example 6.4 (dropwhile)
The function dropWhile can be implemented as follows:
> dropWhileM :: (a -> Bool) -> List a -> List a
> dropWhileM p = mpara phi
>
where phi dropW i N
= nilL
>
phi dropW i (C x xs)
>
| p x
= i xs
>
| otherwise = consL x (dropW xs)
The Haskell correspondent for a F-cv-malgebra is a polymorphic function of
type (a -> (c, f a)) -> (f a -> c) for some ï¬xed type constructor f
and type c. Again, for convenience, we use a slightly modiï¬ed, but equivalent,
version of it; namely, (a -> c) -> (a -> f a) -> (f a -> c). Now,
we can implement m-histomorphisms, by using the accordingly modiï¬ed cancel-
lation law, as follows:
> mhisto :: (forall a. (a -> c) -> (a -> f a)
>
->
f a -> c)
>
->
Mu f -> c
> mhisto phi (In x) = phi (mhisto phi) unIn x
Note, that the deï¬nition does not use any intermediate data or codata structure.
Hence, it does not memoize values on previous arguments. (However, it is possi-
ble to arrive to the memoizing version by exploiting mhisto-DEF.)
96

Example 6.5 (Fibonacci)
The Fibonacci function can be implemented as Mendler-style histomorphism:
> fiboM :: Nat -> Int
> fiboM = mhisto phi
>
where phi fib pre Z
=
1
>
phi fib pre (S x)
>
= case pre x of
>
Z
-> 1
>
S y -> fib x + fib y
The ï¬rst functional argument of phi is used for computing the value on the pre-
vious argument x (like in the case of mcata or mpara combinator). However,
now phi has also the second functional argument pre, which is applied to the
previous argument x in places where its predecessor is needed.
Example 6.6 (evens)
The function evens, which takes from the given list every second element, can
be deï¬ned as follows:
> evensM :: List a -> List a
> evensM = mhisto phi
>
where phi eve pre N
=
nilL
>
phi eve pre (C _ x)
>
= case pre x of
>
N
-> nilL
>
C a y -> consL a (eve y)
6.5
Related work
Mendler-style
recursion
combinators
were
invented
in
type
theory
by
N. P. Mendler. In [Men87] (a conference paper), he studied an extension of sys-
tem F with (co)inductive types and primitive (co)recursion; [Men91] (its journal
version) treats a simpliï¬ed calculus that only supported (co)iteration. Some im-
portant works commenting on [Men87]/[Men91] and, in particular, on the em-
beddings between simply typed lambda calculi with conventional- and Mendler-
style iterators and primitive-recursors and system F are [Lei90, Geu92, SpÅ‚93].
Mendler-style course-of-value iteration was studied by us in a type-theoretic set-
ting in [UV97, UV00b, Uus98]. In [UV00a] we also studied a Mendler-style
combinator for simultaneous iteration.
97

98

CHAPTER 7
CONCLUSIONS
In this last chapter we summarize the contribution of this thesis and outline some
possible directions for future work.
7.1
Summary
We have studied the theory of inductive and coinductive types in a categorical
framework. The goal of this thesis was to develop new recursion combinators that
capture more complex recursion patterns than simple (co)iteration but still possess
nice reasoning properties. In particular, we considered combinators for primitive
(co)recursion and course-of-value (co)iteration using two different approaches.
The ï¬rst approach was based on the treatment of inductive and coinductive
types as initial algebras and terminal coalgebras. In this setting, it is well known
that the primitive recursion can be simulated by a simple iteration which com-
putes a value paired together with the argument, and that this construction leads
to the notion of paramorphism which captures the primitive recursion directly.
We showed (in Chapter 3), that the obvious dualization of this construction leads
to notion of apomorphism which captures the recursion pattern known as prim-
itive corecursion. More importantly, we also showed (in Chapter 4) that a more
involved generic simulation of memoization by iteration leads to the notion of his-
tomorphism, a direct formalization of course-of-value iteration, and also described
the dual notion of futumorphism, a formalization of course-of-value coiteration.
The second approach, inspired by type-theoretic work by N. P. Mendler, was
here pursued for inductive types only. To recast Mendlerâ€™s work in category-
theoretic terms, we invented the concepts of malgebra and malgebra homomor-
phism and treated inductive types as initial malgebras (chapter 5). From that basis,
we then introduced Mendler-style analogs for the cata, para and histo combinators
(chapter 6). From the theory developed, it appears that Mender-style recursion
99

combinators are just as well-suited for program calculation as the conventional
ones, but support a programming style more close to customary (general-) recur-
sive programming.
7.2
Future work
Semantics of Mendler-style inductive and coinductive types. While the basic
theory of Mendler-style inductive and coinductive types has been settled, many
questions remain still unresolved. First, the precise conditions of the existence of
initial (terminal) Mendler-style (co)algebras for mixed-variant base functors and
their relationship to Freydâ€™s dialgebras [Fre90, Fre91] need further study. Also,
recently, Bird and others [BM98, BP99] have proposed a new approach for nested
data types. How this work relates to ours is currently unclear and is a very inter-
esting topic to investigate.
Modeling of interactive processes. Coalgebras and coinductive types have re-
ceived much attention recently. They facilitate elegant modeling of interactive
processes and several very important notions of object-oriented programming like
objects, classes and inheritance. Our preliminary investigations on Mendler-style
coinductive types show that at least modeling of simple processes is easily achiev-
able by them. As the next step, we plan to use Mendler-style coinductive types
to model more complex process calculi (like CSP or CCS), and, if we succeed
in this, we start to develop the speciï¬cation methodology of processes based on
these models. We also plan to provide several case studies for specifying pro-
cesses using the methodology.
Computations with side-effects and (co)inductive types. The use of monads to
represent side-effecting computations is nowadays considered standard, and for
instance in lazy functional language Haskell they are the main structuring lan-
guage construction for side-effects including input/output. The popularity of using
monads is caused by the fact that they provide a simple and effective way to handle
computations that interact purely functionally but internally use side-effects. At
the same time, the monadic approach is not without shortcomings, as the model it
provides for input/output assumes that the environment is closed (i.e. the program
is the only one which interacts with environment). Recently Kieburtz [Kie99]
proposed a conjecture that comonads (duals of monads) together with coinductive
types yield a more appropriate formalism for modeling the interaction with outer
environment. We plan to verify this conjecture, and more generally to investi-
gate the possibilities for integration of monads and comonads with Mendler-style
(co)inductive types.
100

Generic programming. Genericity and reusability are two important issues for
simplifying the design and maintenance of programs. The purpose of generic pro-
gramming [BJJM99] is to develop new methods to parameterize algorithms and
programs. For instance, while traditional polymorphism allows parameterization
with respect to types, the so-called polytypism [JJ96] allows also parameterization
also with respect to type constructors. Most of the approaches for generic pro-
gramming are using inductive and coinductive types, as they come equipped with
universal combinators representing different generic recursion schemes. Mendler-
style inductive and coinductive types have the same potential, but their real utility
in generic programming needs further investigation.
Program transformation. The genericity and reusability of programs have a
side-effect that resulting programs can be very resource-consuming. The prob-
lem can be solved by using different program transformation techniques, like
partial evaluation or deforestation. In the context of inductive and coinductive
types, the last is especially interesting, as it allows to eliminate data structures
constructed during intermediate computations, and can be made fully automatic.
Traditional deforestation is based on the unfold-fold method by Burstall and Dar-
lington [BD77], and is quite inefï¬cient as it requires keeping the full computation
history to guarantee the termination. Takano and Meijer [TM95] proposed an
alternative approach based on (co)inductive types, called â€œacid rainâ€, where in-
termediate data structures are removed using pure calculation, and keeping the
computation history is not required. We hope that this method can be generalized
for Mendler-style (co)inductive types. Also, we plan to investigate other program
transformation methods in this setting.
101

REFERENCES
[BBA00]
L. S. Barbosa, J. B. Barros, and J. J. Almeida. Polytypic recursion
patterns. To appear in Proc. SBLPâ€™00, vol. of ENTCS, May 2000.
[BD77]
Rod M. Burstall and John Darlington. A transformation system for
developing recursive programs. Journal of the ACM, 24(1):44â€“67,
January 1977.
[BdM97]
Richard Bird and Oege de Moor. Algebra of Programming, volume
100 of Prentice Hall Int. Series in Computer Science. Prentice Hall,
London, 1997.
[Bir87]
Richard S. Bird. An introduction to the theory of lists. In M. Broy,
editor, Logic of Programming and Calculi of Discrete Design, vol-
ume 36 of NATO ASI Series F, pages 3â€“42. Springer-Verlag, Berlin,
1987.
[Bir98]
Richard S. Bird.
Introduction to Functional Programming using
Haskell.
Prentice Hall Int. Series in Computer Science. Prentice
Hall, London, 2nd edition, 1998.
[BJJM99]
Roland Backhouse, Patrik Jansson, Johan Jeuring, and Lambert
Meertens. Generic programming â€“an introductionâ€“. In S. Doaitse
Swierstra, Pedro R. Henriques, and JosÂ´e N. Oliveira, editors, Re-
vised Lectures 3rd Int. School on Advanced Functional Program-
ming, AFPâ€™98, Braga, Portugal, 12â€“19 Sept. 1998, volume 1608 of
Lecture Notes in Computer Science, pages 28â€“115. Springer-Verlag,
Berlin, 1999.
[BM98]
Richard Bird and Lambert Meertens. Nested datatypes. In J. Jeuring,
editor, Proceedings 4th Int. Conf. on Mathematics of Program Con-
struction, MPCâ€™98, Marstrand, Sweden, 15â€“17 June 1998, volume
1422 of Lecture Notes in Computer Science, pages 52â€“67. Springer-
Verlag, Berlin, 1998.
102

[BP99]
Richard Bird and Ross Paterson.
Generalised folds for nested
datatypes. Formal Aspects of Computing, 11(2):200â€“222, 1999.
[CF92]
Robin Cockett and Tom Fukushima. About Charity. Yellow Se-
ries Report 92/480/18, Dept. of Computer Science, Univ. of Calgary,
June 1992.
[Fok92]
M. M. (Maarten) Fokkinga. Law and Order in Algorithmics. PhD
thesis, Dept. of Informatics, Univ. of Twente, 1992.
[Fre90]
Peter J. Freyd. Recursive types reduced to inductive types. In Pro-
ceedings 5th IEEE Annual Symp. on Logic in Computer Science,
LICSâ€™90, Philadelphia, PA, USA, 4â€“7 June 1990, pages 498â€“507.
IEEE Computer Society Press, Los Alamitos, CA, 1990.
[Fre91]
Peter J. Freyd. Algebraically complete categories. In A. Carboni,
M. C. Pedicchio, and G. Rosolini, editors, Proceedings Int. Conf.
Category Theory â€™90, CTâ€™90, Como, Italy, 22â€“28 July 1990, vol-
ume 1488 of Lecture Notes in Mathematics, pages 95â€“104. Springer-
Verlag, Berlin, 1991.
[Geu92]
Herman Geuvers. Inductive and coinductive types with iteration and
recursion. In B. NordstrÂ¨om, K. Pettersson, and G. Plotkin, editors,
Informal Proceedings Workshop on Types for Proofs and Programs,
BËšastad, Sweden, 8â€“12 June 1992, pages 193â€“217. Dept. of Com-
puting Science, Chalmers Univ. of Technology and GÂ¨oteborg Univ.,
1992. ftp://ftp.cs.chalmers.se/pub/cs-reports/baastad.92/proc.ps.Z.
[GH99]
Jeremy Gibbons and Graham Hutton. Proof methods for structured
corecursive programs. In Proceedings 1st Scottish Functional Pro-
gramming Workshop, Stirling, Scotland, Aug/Sept 1999, page ???
1999.
[Gru96]
Jim
Grundy.
A
browsable
format
for
proof
pre-
sentation.
Mathesis
Universalis,
2,
1996.
URL
http://saxon.pip.com.pl/MathUniversalis/2/.
[Hag87]
Tatsuya Hagino. A Categorical Programming Language. PhD thesis
CST-47-87, Laboratory for Foundations of Computer Science, Dept.
of Computer Science, Univ. of Edinburgh, September 1987.
[HITT96]
Zhenjiang Hu, Hideya Iwasaki, Masato Takeichi, and Akihiko
Takano.
Tupling calculation eliminates multiple data traversals.
103

In Proceedings 2nd ACM SIGPLAN Int. Conf. on Functional Pro-
gramming, ICFPâ€™97, Amsterdam, The Netherlands, 9â€“11 June 1997,
pages 164â€“175. ACM Press, New York, 1996.
[Hoa72]
C. A. R. Hoare. Notes on data structuring. In O.-J. Dahl, E.W. Dijk-
stra, and C.A.R. Hoare, editors, Structured Programming. Academic
Press, 1972.
[How96]
Brian T. Howard. Inductive, coinductive, and pointed types. In Pro-
ceedings 1st ACM SIGPLAN Int. Conf. on Functional Programming,
ICFPâ€™96, Philadelphia, PA, USA, 24â€“26 May 1996, SIGPLAN No-
tices 31(6), pages 102â€“109. ACM Press, New York, 1996.
[JJ96]
Johan Jeuring and Patrik Jansson.
Polytypic programming.
In
J. Launchbury, E. Meijer, and T. Sheard, editors, Tutorial Text 2nd
Int. School on Advanced Functional Programming, Olympia, WA,
USA, 26â€“30 Aug 1996, volume 1129 of Lecture Notes in Computer
Science, pages 68â€“114. Springer-Verlag, Berlin, 1996.
[Kie99]
Richard Kieburtz. Codata and comonads in Haskell. Unpublished
manuscript, July 1999.
[Lam68]
Joachim Lambek. A ï¬xpoint theorem for complete categories. Math-
ematische Zeitschrift, 103:151â€“161, 1968.
[Lei90]
Daniel Leivant. Contracting proofs to programs. In P. Odifreddi,
editor, Logic and Computer Science, volume 31 of APIC Studies in
Data Processing, pages 279â€“327. Academic Press, London, 1990.
[Mac97]
Saunders Mac Lane. Categories for the Working Mathematician,
volume 5 of Graduate Texts in Mathematics.
Springer-Verlag,
Berlin, 2nd edition, 1997. (1st ed., 1971).
[Mal90a]
Grant Malcolm. Data structures and program transformation. Sci-
ence of Computer Programming, 14(2â€“3):255â€“279, 1990.
[Mal90b]
Grant R. Malcolm. Algebraic Data Types and Program Transforma-
tion. PhD thesis, Dept. of Computer Science, Univ. of Groningen,
1990.
[Mat98]
Ralph Matthes. Extensions of System F by Iteration and Primitive
Recursion on Monotone Inductive Types. PhD thesis, Fachbereich
Mathematik, Ludwig-Maximilians-UniversitÂ¨at MÂ¨unchen, 1998.
104

[Mat00]
Ralph Matthes. Tarskiâ€™s ï¬xed-point theorem and lambda calculi with
monotone inductive types. In Benedikt LÂ¨owe and Florian Rudolph,
editors, Refereed Papers of Research Coll. on Foundations of the
Formal Sciences, Berlin, Germany, 7â€“9 May 1999, pages 91â€“112.
Kluwer Academic Publishers, Dordrecht, 2000.
[Mee92]
Lambert Meertens. Paramorphisms. Formal Aspects of Computing,
4(5):413â€“424, 1992.
[Men87]
Nax Paul Mendler. Recursive types and type constraints in second-
order lambda-calculus. In Proceedings 2nd Annual IEEE Symp. on
Logic in Computer Science, LICSâ€™87, Ithaca, NY, USA, 22â€“25 June
1987, pages 30â€“36. IEEE Computer Society Press, Washington, DC,
1987.
[Men91]
Nax Paul Mendler.
Inductive types and type constraints in the
second-order lambda-calculus. Annals of Pure and Applied Logic,
51(1â€“2):159â€“172, 1991.
[Mic68]
Donald Michie. Memo functions and machine learning. Nature,
(218):19â€“22, April 1968.
[MTHM97] Robin Milner, Mads Tofte, Robert Harper, and David MacQueen.
The Deï¬nition of Standard ML (Revised). The MIT Press, 1997.
[Mul91]
Philip S. Mulry. Strong monads, algebras and ï¬xed points. In M. P.
Fourman, P. T. Johnstone, and A. M. Pitts, editors, Applications of
Categories in Computer Science: Proceedings LMS Symp., Durham,
UK, 20â€“30 July 1991, volume 177 of London Math. Society Lec-
ture Note Series, pages 202â€“216. Cambridge University Press, Cam-
bridge, 1991.
[PJH99]
Simon Peyton Jones and John Hughes, editors.
Report on
the Programming Language Haskell98,
A Non-strict Purely
Functional
Language,
February
1999.
Available
from
http://www.haskell.org/definition/.
[SpÅ‚93]
ZdzisÅ‚aw SpÅ‚awski.
Proof-Theoretic Approach to Inductive Deï¬-
nitions in ML-Like Programming Languages versus Second-Order
Lambda Calculus. PhD thesis, WrocÅ‚aw Univ., 1993.
[SU99]
ZdzisÅ‚aw SpÅ‚awski and PaweÅ‚ Urzyczyn.
Type ï¬xpoints: Itera-
tion vs. recursion. In Proceedings 4th ACM SIGPLAN Int. Conf.
on Functional Programming, ICFPâ€™99, Paris, France, 27â€“29 Sept
1999, pages 102â€“113. ACM Press, New York, 1999.
105

[TM95]
Akihiko Takano and Erik Meijer. Shortcut deforestation in calcu-
lational form. In Conf. Record 7th ACM SIGPLAN/SIGARCH Intl.
Conf. on Functional Programming Languages and Computer Archi-
tecture, FPCAâ€™95, La Jolla, San Diego, CA, USA, 25â€“28 June 1995,
pages 306â€“316. ACM Press, New York, 1995.
[Uus98]
Tarmo Uustalu.
Natural Deduction for Intuitionistic Least and
Greatest Fixedpoint Logics, with an Application to Program Con-
struction. PhD thesis (Dissertation TRITA-IT AVH 98:03), Dept. of
Teleinformatics, Royal Inst. of Technology, Stockholm, May 1998.
[UV97]
Tarmo Uustalu and Varmo Vene. A cube of proof systems for the in-
tuitionistic predicate Âµ, Î½-logic. In Magne Haveraaen and Olaf Owe,
editors, Selected Papers 8th Nordic Workshop on Programming The-
ory, NPWTâ€™96, Oslo, Norway, 4â€“6 Dec 1996, Research Report 248,
Dept. of Informatics, Univ. of Oslo, pages 237â€“246. May 1997.
[UV99a]
Tarmo Uustalu and Varmo Vene. Mendler-style inductive types, cat-
egorically. Nordic Journal of Computing, 6(3):343â€“361, 1999.
[UV99b]
Tarmo Uustalu and Varmo Vene. Primitive (co)recursion and course-
of-value (co)iteration, categorically. INFORMATICA, 10(1):5â€“26,
1999.
[UV00a]
Tarmo Uustalu and Varmo Vene. Coding recursion a la Mendler (ex-
tended abstract). In Johan Jeuring, editor, Proceedings 2nd Work-
shop on Generic Programming, WGPâ€™2000, Ponte de Lima, Portu-
gal, 6 July 2000, Tech. Report UU-CS-2000-19, Dept. of Computer
Science, Utrecht Univ., pages 69â€“85. June 2000.
[UV00b]
Tarmo Uustalu and Varmo Vene. Least and greatest ï¬xedpoints in
intuitionistic natural deduction. To appear in Theoretical Computer
Science, March 2000.
[Ves97]
Peter Vesely. Typechecking the Charity term logic. Unpublished
notes, April 1997.
[Vos95]
Tanja Vos.
Program construction and generation based on recur-
sive types. MSc thesis INF/SCR-95-12, Dept. of Computer Science,
Univ. of Utrecht, March 1995.
[VU98]
Varmo Vene and Tarmo Uustalu. Functional programming with apo-
morphisms (corecursion). Proceedings of the Estonian Academy of
Sciences: Physics, Mathematics, 47(3):147â€“161, 1998.
106

[Wad89]
Philip Wadler. Theorems for free!
In Proceedings 4th Int. Conf.
on Funct. Prog. Languages and Computer Arch., FPCAâ€™89, London,
UK, 11â€“13 Sept 1989, pages 347â€“359. ACM Press, New York, 1989.
107

108

KATEGOORNE PROGRAMMEERIMINE
INDUKTIIVSETE JA KOINDUKTIIVSETE
T Â¨U Â¨UPIDEGA
KokkuvËœote
Algoritmika ehk programmide konstrueerimise matemaatika on teoreetilise in-
formaatika haru, mille eesmÂ¨argiks on uute matemaatiliselt pËœohjendatud tarkvara-
tehnika meetodide vÂ¨aljatÂ¨oÂ¨otamine. Seejuures kasutatav matemaatiline aparatuur
baseerub pËœohiliselt universaalalgebral ja loogikal, ning eriti just viimasel ajal
kategooriate teoorial. Algoritmika Â¨uks olulisemaid tunnuseid on, et tulempro-
grammi korrektsus spetsiï¬katsiooni suhtes garanteeritakse konstruktsiooni kÂ¨aigus
ning selle eraldi veriï¬tseerimist ei ole vaja. Eelistatakse deklaratiivseid program-
meerimisparadigmasid, iseÂ¨aranis tÂ¨uÂ¨ubitud funktsionaalseid keeli, kuna nende se-
mantiline baas on vÂ¨aga lÂ¨ahedane kasutatava matemaatilise aparatuuriga. Muuhul-
gas vËœoimaldab see nii spetsiï¬tseerimis- kui ka realiseerimisfaasis jÂ¨aÂ¨ada Â¨uhe para-
digma piiresse.
KÂ¨aesolevas doktoritÂ¨oÂ¨os on kategooriate teooria abil uuritud induktiivseid ja
koinduktiivseid andmetÂ¨uÂ¨upe ja nendega seotud rekursiooniskeeme. TÂ¨oÂ¨o kÂ¨aigus
jËœouti jÂ¨argmiste uute tulemusteni:
â€¢ Uuriti korekursiivsete funktsioonide deï¬neerimise skeemi, mille formali-
satsiooniks terminaalsete koalgebratega distributiivsetes kategooriates on
nn. apomorï¬smid (primitiivne korekursioon); sËœonastati ja tËœoestati apomor-
ï¬smide iseloomulikud omadused, vËœorreldi neid anamorï¬smidega (lihtsa ko-
iteratsiooniga); esitati lihtsaid nÂ¨aiteid koandmetÂ¨uÂ¨upidega funktsionaalpro-
grammeerimisest, kus apomorï¬smid on tululikud.
â€¢ Uuriti rekursiivsete ja korekursiivsete funktsioonide deï¬neerimise erinevaid
skeeme. NÂ¨aidati, et course-of-value-iteratiivsed funktsioonid on formali-
seeritavad initsiaalsete algebratega distributiivsetes kategooriates nn. histo-
morï¬smidena ning course-of-value-koiteratiivsed funktsioonid on duaalselt
formaliseeritavad terminaalsete koalgebratega distributiivsetes kategoori-
ates nn. futumorï¬smidena.
â€¢ Formaliseeriti nn. Mendleri-laadi induktiivsete tÂ¨uÂ¨upide kategoorne seman-
tika, tuues selleks sisse Mendleri-laadi algebrate ning nende vaheliste ho-
momorï¬smide mËœoisteid. NÂ¨aidati, et kovariantse baasfunktori korral on in-
dutseeritud Mendleri-laadi algebrate kategooria ekvivalentne sama funktori
(tavaliste) algebrate kategooriaga. Segavariantse baasfunktori jaoks nÂ¨aidati,
et kui baaskategoorias leiduvad teatud suured summad (tÂ¨apsemalt teatud
109

tensorite kolËœopud), siis saab konstrueerida uue kovariantse funktori, mille
algebrate kategooria on esialgse funktori Mendleri-laadi algebrate kategoo-
riaga ekvivalentne.
Lisaks uuriti Mendleri-laadi induktiivsete tÂ¨uÂ¨upidega
seotud rekursioonioperaatorite omadusi ning nende kasutatavust program-
mide konstrueerimisel.
110

ACKNOWLEDGEMENTS
First and foremost, my greatest thanks go to Tarmo Uustalu who has been not
only a direct partner of the research reported here, but also a good friend. Our
collaboration has been great pleasure and I can only hope that it will continue.
The discussions we had in Spring 1996 during my visit to Stockholm were the
starting point of the work and is still one of the greatest experience I have had in
my academic life.
Special thanks to my supervisor Merik Meriste who is responsible for ignit-
ing my interest in programming language theory and functional languages in par-
ticular. He has always been very supportive and patient, especially at difï¬cult
moments throughout my PhD study.
I want to thank Prof. Enn TËœougu for inviting me to the Royal Institute of
Technology in Stockholm for a two two-month periods during 1996. These visits
were ï¬nanced by the Stockholm-LadugËšardslandet Club of District 2350 of Rotary
International for which I am very grateful.
I would like to thank all my friends, who often wondered whether this thesis
will ever be ï¬nished, for their support.
Last but not least, I am grateful to my mother for the support and encourage-
ment all over the years.
The work reported in this thesis was partially supported by the Estonian Sci-
ence Foundation grant no. 2976.
111

112

CURRICULUM VITAE
VARMO VENE
Citizenship: Estonian Republic.
Born: July 2, 1968, Tartu, Estonia.
Marital status: single.
Address: Anne 90-58, Tartu, EE-50705 Estonia,
phone.: +372 7 482 460,
e-mail: varmo@cs.ut.ee
Education
1986 â€“ 1992 Applied mathematics, Faculty of Mathematics, University of Tartu.
1992 â€“ 1994 MSc studies in Computer Science, Faculty of Mathematics, Univer-
sity of Tartu.
1996 â€“ 2000 PhD studies in Computer Science, Faculty of Mathematics, Univer-
sity of Tartu.
Professional employment
1994 â€“ 2000 Researcher, Institute of Computer Science, University of Tartu.
1998 â€“
Researcher, Institute of Cybernetics, Tallinn Technical University.
2000 â€“
Lecturer, Institute of Computer Science, University of Tartu.
113

CURRICULUM VITAE
VARMO VENE
Kodakondsus: Eesti Vabariik.
SÂ¨unniaeg ja -koht: 2. juuli, 1968, Tartu, Eesti.
Perekonnaseis: vallaline.
Aadress: Anne 90-58, Tartu, EE-50705 Eesti,
tel.: +372 7 482 460,
e-post: varmo@cs.ut.ee
Haridus
1986 â€“ 1992 Tartu Â¨Ulikool, matemaatikateaduskond, rakendusmatemaatika eri-
ala.
1992 â€“ 1994 Tartu Â¨Ulikool, matemaatikateaduskond, informaatika magistratuur.
1996 â€“ 2000 Tartu Â¨Ulikool, matemaatikateaduskond, informaatika doktorantuur.
Erialane teenistuskÂ¨aik
1994 â€“ 2000 Tartu Â¨Ulikool, Arvutiteaduse Instituut, teadur.
1998 â€“
Tallinna TehnikaÂ¨ulikool, KÂ¨uberneetika Instituut, teadur (0.3 kohta).
2000 â€“
Tartu Â¨Ulikool, Arvutiteaduse Instituut, lektor.
114

DISSERTATIONES MATHEMATICAE
UNIVERSITATIS TARTUENSIS
1. Mati Heinloo. The design of nonhomogeneous spherical vessels, cylindri-
cal tubes and circular discs. Tartu, 1991. 23 p.
2. Boris Komrakov. Primitive actions and the Sophus Lie problem. Tartu,
1991. 14 p.
3. Jaak Heinloo. Phenomenological (continuum) theory of turbulence. Tartu,
1992. 47 p.
4. Ants Tauts. Inï¬nite formulae in intuitionistic logic of higher order. Tartu,
1992. 15 p.
5. Tarmo Soomere. Kinetic theory of Rossby waves. Tartu, 1992. 32 p.
6. JÂ¨uri Majak. Optimization of plastic axisymmetric plates and shells in the
case of Von Mises yield condition. Tartu, 1992. 32 p.
7. Ants Aasma. Matrix transformations of summability and absolute summa-
bility ï¬elds of matrix methods. Tartu, 1993. 32 p.
8. Helle Hein. Optimization of plastic axisymmetric plates and shells with
piece-wise constant thickness. Tartu, 1993. 28 p.
9. Toomas Kiho. Study of optimality of iterated Lavrentiev method and its
generalizations. Tartu, 1994. 23 p.
10. Arne Kokk. Joint spectral theory and extension of non-trivial multiplica-
tive linear functionals. Tartu, 1995. 165 p.
11. Toomas Lepikult. Automated calculation of dynamically loaded rigidplas-
tic structures. Tartu, 1995. 93 p. (in russian)
12. Sander Hannus. Parametrical optimization of the plastic cylindrical shells
by taking into account geometrical and physical nonlinearities.
Tartu,
1995. 74 p. (in russian)
13. Sergrei Tupailo. Hilbertâ€™s epsilon-symbol in predicative subsystems of
analysis. Tartu, 1996. 134 p.
14. Enno Saks. Analysis and optimization of elastic-plastic shafts in torsion.
Tartu, 1996. 96 p.
15. Valdis Laan. Pullbacks and ï¬‚atness properties of acts. Tartu, 1999. 90 p.
16. MÂ¨art PËœoldvere. Subspaces of Banach spaces having Phelpsâ€™ uniqueness
property. Tartu, 1999. 74 p.
17. Jelena Ausekle. Compactness of operators in Lorentz and Orlicz sequence
spaces. Tartu, 1999. 72 p.
115

18. Krista Fischer. Structural mean models for analyzing the effects of com-
pliance in clinical trials. Tartu, 1999. 125 p.
19. Helger Lipmaa. Secure and efï¬cent time-stamping systems. Tartu, 1999.
56 p.
20. JÂ¨uri Lember. Consistency of empirical k-centres. Tartu, 1999. 148 p.
21. Ella Puman. Optimization of plastic conical shells. Tartu, 2000. 102 p.
22. Kaili MÂ¨uÂ¨urisep.
Eesti keele arvutigrammatika: sÂ¨untaks.
Tartu, 2000.
109 lk.
116

