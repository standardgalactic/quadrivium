So a couple of years ago I made a video on Julia for medical statistics, quite a successful video.
I think it's cut down about 12,000 views now and because people are interested in that.
Now it's a couple of years down the line, short couple of years and we had version 1.4
and I think that was still done in 0.4 so many things have changed and Julia's really grown up.
It is a phenomenal language for scientific computing, solves so many problems in such an easy way
and there's a big community now and there's also a big package ecosystem.
So it was time to redo this video.
The video is still going to be about showcasing Julia, how to use Julia to do medical statistics.
And what we're going to do this time around though, we're going to base it on a paper.
So an open paper, I'll put the link down below and we're just going to use some of the summary statistics
to simulate some new data and that's the data that we're going to analyze.
So I'll show you how that works out, use distributions just to create and simulate your own data.
Then we're going to go through summary statistics and plotting.
You've got to visualize your data and I'm going to show you a plotting library called GATFLY
and it really produces beautiful plots and then we're going to check for the assumptions
for the use of parametric tests and then do one or two inferential tests.
Lastly, just again to showcase the ease of the use of the language, what it can do,
we're just going to hand code a chi-square test for independence.
Now as I mentioned, Julia has really grown up.
A lot of people are using it, the community is just getting larger and larger.
Currently I'm working on a course and as soon as that one's done, I'll pop that link down below
so maybe by the time you watch this, that link will be up.
An introductory course and just teaching you how to do Julia from the ground up,
whether you've programmed before, maybe a bit of R, maybe a bit of Python
or if you've never coded at all, just to show you how easy it is to learn a programming language
and if you're going to learn how to use one, might as well be Julia, it really is going places
and if you can code in Julia, you can basically code in Python as well and you can code in R
and there's really no use just to code in one language, quite a couple of them.
It really makes life interesting and makes your work a lot more fun.
Start with Julia though, why not?
Now though, let's look at Julia using medical statistics.
And so we start off with the Julia language website, there's julialang.org, lots of information here.
You can learn about Julia, all you like in the documentation.
I am going to tell you that the documentation is on the technical side.
So at least when you start, it is a little bit of a struggle.
Of course to download and install Julia, we can just click on the Downloads button
and we can see when I made this recording, the current stable release was 1.4.1,
that's what we're going to use and that was released on April the 14th.
There's also a long term support release, if that's what you want to stick to.
And you can see we have Windows, Mac OS and all the Linux libraries
and then for some of them 32 bit and 64 bit, you will know what to install.
For Windows go for 64 bit, Mac OS, you're only going to get the 64 bit.
And then with Linux, the 64 bit would just be the norm most computers
and operating systems are 64 bit these days.
When you've installed Julia though, that is only going to be available to you in the REPL.
So that is your terminal, your command prompt.
And so you can just write little lines of code that get executed.
What you do need is a graphical user interface.
And the best one to use at the moment is Atom.
And there we go, Atom.io. When you go on the Atom website,
it will recognize, should recognize your operating system.
It says that I'm on Windows here and we can download and install that.
If Julia was installed properly, once you've downloaded it, just accept all the defaults.
It should be in your environment variables or in your path.
That means your computer knows where to find Julia when you want to start using it.
And when you install Atom, it should pick up where Julia is.
If you install Julia inside of Atom.
So Atom is a general purpose coding environment, an IDE.
And you can code, use a lot of languages inside of Atom.
Let me just open Atom for you there.
There we go. That's Atom.
And you can see right at the top there, it says Juno.
That means Julia was already installed to work inside of Atom.
And I'll show you how to go about that, two ways that you could go about that.
The best way or the easiest way I should say is just to go to Julia Computing.
So not Julialang.org but JuliaComputing.com, commercial arm of Julia.
You can find out all about what they have to offer.
But what you want to do is go down here and look at Julia Pro.
Let's click on Read More.
And there you can download Julia Pro free of charge.
And you can see there they've got 1.0.5.2, the long term release there,
but also the current stable release 1.4.1-1.
And again, you can just download those.
Might ask you to register.
It's all free of charge.
And you can go ahead and download that.
What that is going to do for you, it's going to install Atom, as we can see here.
You're going to see Atom and Julia's already connected to it.
If you do the Julialang separately and Atom separately,
you can always come to the settings page.
And you'll see for me that was control comma or command comma.
And you'll see packages there.
And I'll list all the packages that were installed.
And you can see Julia client was already installed.
Julia language already installed.
What you would have to search for is Uber.
That's U-B-E-R, Juno.
If you search for that package and install that,
that's going to install everything for you.
If everything worked well, you install Julia properly.
You installed Atom as we've done here.
You should have Juno there when you restart.
You can go down to settings and you can set all sorts of things
as far as the Julia client specifically is concerned.
You can see there's some Julia options, the UI options, etc.
Atom itself has built-in themes as well.
So you can go for a light theme or a dark theme.
Let's close this all off.
What I've got you on the left-hand side is just a project pane.
In other words, I went to file and add project folder
because the files that I want to work in, they're all in a specific folder.
And that also allows you to connect your code on a GitHub repository
and you can just continuously upload to GitHub.
What you see down at the bottom is a terminal.
And you can run the Julia in the form of a REPL right here.
So if I click the Enter return there, we can see Julia's launch there.
And when you install just base Julia, just Julia without anything else, without an IDE,
this is what you're going to see.
And I can just type some code there, 2 plus 2, hit Enter, and we're going to see 4.
In the middle here is where we see the coding environment itself.
And you see I've got a file open Julia for medicalstatistics.jl.
And that's what we're going to work with.
On the right-hand side, there's the workspace.
This is going to show me my current workspace,
the computer variables that I've created, and the objects that are assigned to them.
You get full documentation here.
So you can search the documentation.
Of course, you can just go on the website as well.
And we're going to have inline plots.
So what I like to do is I'm just going to grab the REPL here,
and I'm going to move it right up there next to workspace.
So it makes that little blue mark there, drop it there.
Now it's on the right-hand side for me.
I can also just close down this side and we've got a lot more space to work with
because some of the lines of code are quite long.
As with Python, we see that we can use the hashtag symbol or pound symbol
on the left-hand side of every line of code.
And that means that whole line of code will just be ignored by Julia.
It won't ignore that.
And inside of an IDE such as this, you can just use these comments
just to write some comments.
And when you download this file, you can see the comments that I've made.
It'll tell you a little bit about Julia, about its type system,
about multiple dispatch, why it's so fast,
why it is such a lovely language to use.
Basically, it comes down to it is as simple as Python,
but it runs along the sort of speeds that you can expect
of other compiled languages like C,
because that's exactly what Julia is.
It's a compiled language.
So when you enter some code, it gets compiled for your computer,
for your CPU.
In other words, the code is going to execute very fast.
It's just in time compiling, so it goes to a low-level virtual machine
and that is going to compile the code for your system bringing you that speed.
One more thing that I want to say about Julia before we start,
everything in Julia is a function.
Functions, it's a functional language.
In other words, you saw me type 2 plus 2 there,
but what's happening behind the scene is there is a plus function in Julia
and you start by typing the function and in this instance,
it is this plus symbol that is a function.
It's the name of a function.
And as with all functions, you pass it some arguments.
Not all functions need arguments, but most functions would need arguments.
They are separated by commas.
If they are positional arguments, we might talk a little just about keyword arguments,
perhaps not in this video, but those would follow a semi-colon.
Here I'm just passing two arguments to the plus function.
It's 2 and 2.
The plus function knows what to do with it.
Why?
Well, it understands what 2 and 2 are.
2 and the other 2, those are both 64-bit integers by default 64-bit
because this is a 64-bit operating system.
So those are 64-bit integers that I'm passing to this function through multiple dispatch.
The plus function will know what to do with integers
and that will be something very different than doing just that.
That's 2.0.
That's a floating point value.
It's going to call a different method for the plus function
because it knows what to do with floating point values.
Those are decimal point values and that's different from integers.
But Julia understands what to do, how to compile the code
so that it executes as fast as possible, as optimized as possible
for that plus function to execute.
We don't have to tell Julia what type of variable we do have.
So if I say a equals 3, I don't have to instantiate that 3.
That is, I'm instantiating this object which is actually an array,
a vector at least of a single value.
And that is assigned to the computer variable A.
So that's an instance of 64-bit integer here that I'm passing to.
But I didn't have to tell.
I didn't have to specify the type of that 3.
I didn't have to specify.
Julia is going to infer that for me.
Obviously do specify, you can specify the type
and that is going to lead to a better execution.
So all that being said, that's not what you're here for.
Let's have a look at what we can do in Julia.
Now we are going to use, make use of third-party packages.
Most other languages have packages that you can install
to greatly expand the functions that are available to you
and what you can do.
And you see here, I've just typed a single line of code here.
Import data frames.
Let me increase the size.
Just one more tick.
There we go.
That was just holding down control or command and using my mouse wheel
and just to increase the size there.
So import data frames.
Data frames is a package.
That's the name of a package.
And I'm using import there to import, but you can also see down here
I'm importing get fly, but instead of import, I use using.
So there's a difference between those two.
There are a few differences.
One of the main differences are that if I want to use
some of the functions inside of data frames,
I have to use the data frames, the namespace,
the full namespace word there.
So data frames dot and then a function that lives inside of there.
Using for most of them, you don't have to do that.
You just use the function as is.
If you're familiar with Python, that would be importing NumPy as NP.
And then using NP dot random, for instance,
whereas if you imported from NumPy import random,
then you can just use random directly.
The reason why I'm going to do this here is I want to show you,
if I show you a function, I want you to know where it comes from.
Many tutorials, all these packages are just used to the using keyword.
And then functions are used, but you're not really sure where they come from.
So I'm going to restrict myself to import here, which is not the norm.
But just to show you if I use a function from, for instance,
from statspace, that you know that that function comes from statspace.
So where did I get all of these extra packages from?
Let's go back to the REPL.
It's going to delete there.
I'm going to hit the right square bracket.
And that brings me into the package management system.
And all I have to do is say add.
And then I could say data frames.
And if I hit enter now, the data frames package is going to be installed.
That's a permanent installation unless I remove it.
So it's always there.
But the first time that you start up the IDE.
So just to say to get out of that package, I just had to hit backspace and I'm back.
Before I forget, there's also the question mark that brings you into the help system.
If I were to look for the function called sum.
That's all.
Look at that.
I just get all that information.
I could also go to the documentation, of course, and type in sum.
And I'm going to get this information as well.
So the help system is always there for you.
Back to these packages.
You install them there.
But you have to import it every time you start the IDE or start the Julia kernel.
Again, you have to import or use the keyword using with ease.
And then they're going to be pre-compiled and they take some time.
So every time you import these packages, it is going to take time.
There's no way to rush this situation.
It's not like importing numpy as NP and it's almost instantaneous.
This has to be compiled.
So you can see here at the bottom, pre-compiling data frames.
And you see this little gear icon here.
It is doing the pre-compiling and you have to wait for that.
If you want the speed, you've got to wait for the language to compile.
And there we go.
It didn't take that long.
Let's also import distributions.
So the distribution package is going to give me access to a lot of discrete and continuous distributions.
GATFLY is a package for plotting based on the grammar of graphics.
If you use ggplot2 before, it should not be too difficult for you to pick up GATFLY.
So Render is very beautiful plots.
And certainly go to the GATFLY website and have a look around.
It is this phenomenal, the type of plots that you can create.
And of course, we're going to create the plots in this tutorial.
So let's do GATFLY.
It's going to take a little bit longer to pre-compile.
It's a large package and it's going to take a bit of time.
I'll continue talking about the hypothesis tests that's going to give us access
to a lot of statistical tests for inference.
So we're going to get our t tests, f tests, etc.
That is going to be available for us.
Not all inferential statistic tests are available.
Have a look at their website.
For instance, as I mentioned in an introduction, we are going to hand code
or hand write some code to do chi-square tests for independence at the end of this tutorial.
StatsBase is also going to give me access to a bunch of statistical functions
which makes life very easy.
It's a very useful package to have.
So let's just go back to hypothesis tests.
And you can see I'm doing for GATFLY and for hypothesis tests I'm using using.
But for statsBase, I'm using import.
It's just that I want to show you where these, as I mentioned, where these functions come from.
So I'm going to do import, by the way, to execute these lines of code.
I'm just at the end.
I can be anywhere inside that line and I'm holding down shift and I'm hitting enter.
Shift and enter or shift and return.
And that is going to complete that for me.
Let's do statistics.
Now, statistics and random, they come with Julia.
They build into Julia.
But if you want to use the functions inside of those two packages,
you have to import them or use the using statement.
CSV.
Of course, it's a package that's going to help us read CSV files.
If you work with spreadsheet software such as the ubiquitous Microsoft Excel,
never save your files.
If you're going to work with data, don't save your files as Excel spreadsheets.
Save them as CSV files, comma-separated value files.
Makes it much easier to work with those kind of files that have stripped away all the fancy things
that have been added to the rendering of your cells inside of Microsoft Excel
or some other spreadsheet software.
All you want is the actual data, not its representation as a percentage.
If it was captured as a fraction, you want those values as a fraction.
And then lastly, or second from last, we're going to use query.
That's a package to help us query language.
And that is a very powerful, it's not only for the data frames package.
I did mention the data frames package right in the beginning.
That's going to allow us to work with the data that we've imported.
But the query language on top of that is almost like a structured query language.
It allows us to write queries to interrogate the data.
And in the end, if we're going to do a chi-square test for independence,
we've got to have some contingency tables and the frequency tables or FREQ tables.
It's going to allow us just to do those counts along contingency tables.
So let's import that.
So what I'm going to do here next is we're just going to make use of this journal article that you can see here.
The link will be down below.
You can read that link.
The article itself used an organism and tablet form and randomized some participants
and had a look at the effect that would have on the cholesterol and specifically HDL cholesterol.
They've got beautiful tables in that journal paper.
And we're just going to use the summary that they go over in those tables
and just generate some data on our own.
That's one of the beauties of a computer language.
Of course, you can generate your own data.
So this would not refer to real-life data.
This is data that we're going to simulate based on the summary statistics in those tables.
So the first function that we're going to use you see here is random.seed.
Open close parentheses because the seed is a function
and I'm just passing in some integer that I decided on 12.
You see the little exclamation mark there?
That's the bang symbol.
So random.seed bang.
And I'll tell you a little bit more about the bang symbol a bit later.
To seed the pseudo-random number generator means all these random values that we are going to generate
will be exactly the same if I run this code again.
If you run this code, you're going to get exactly the same pseudo-random numbers as well.
If we don't do that, of course, every time you run this,
you're going to get different random numbers.
So the first set of random numbers, let me just execute that.
Shift-Enter, Shift-Return.
And now if I run these in order, of course, if I go back and rerun some of these,
it'll be different numbers.
But if I run these all in order, we should all get the same random values.
So the first random function we're going to deal with is a built-in Julia function, RAND.
And it's going to take some arguments and return one or more random values.
The first argument here is these oppositional, so you've got to put them in order,
is what to choose from.
And this is a unit range, 30 colon 65.
Because I don't put a default step size in the middle, so I could say 30 colon 2 colon 65.
That's going to go up in steps of 2.
If I don't put any step size, it's just going to use 1 as a step size.
So from 30 to 65, that is a unit range.
It's going to select from those values.
How do I know that that's a unit range?
Well, let's go to the REPL here.
There is a type of function.
And if we were to say 30 to 65, it'll tell us what Julia sees that as.
It sees that as a unit range of 64-bit integers, just as we suspected.
Back here to the comma, the next positional argument would be 46.
I want 46 values back from this interval of 30 to 65.
I want 46 values back.
The random is going to give us a uniform distribution with replacement.
So if the age 35 was chosen once, it goes back into the pile and it can be chosen again.
So just a uniform random distribution.
Shift-Enter.
And there we see we have a vector of 64-bit integers with 46 elements.
If I twirl down on it, you can see a list of them there.
46.
So in this paper, they had 46 participants, 23 in each arm, taking either the drug itself,
which as I say, we're just some organisms, or placebo.
And we want 46 of them.
And we're just going to randomize from a uniform random distribution.
Uniform distribution, we're just going to take 46 values.
And we're storing that, assigning that.
Remember, equal sign is an assignment operator.
It assigns what is on the right side of it to whatever is on the left.
And on the left, we've generated a computer variable name age,
creating a space in our memory where this object on the right-hand side is stored.
I'm going to use snake case for my computer variable names.
There you can see snake case.
In other words, it's a word I came up with, computer variable,
but the words have got these underscores in between them.
It's commonly seen in Julia, although you can use, I suppose, whatever convention you want.
Camel case, it's really up to you.
The next one I'm going to generate is gender.
And here I'm going to use the sample function from the stats-based package.
And that's why I used importing, so I have to now write stats-based.sample.
So my first argument is going to be an array.
And it is an array because of the square brackets.
An array is a list of elements.
And the two elements I'm going to give it is female and male as strings.
And in Julia, strings go inside of double quotation marks.
You can also use single quotes, but that's only with a single letter.
And then it's not a string.
It's actually a character type, not a string type.
So there we go.
Now in this paper, there was just the binary allocation of gender.
So there was only female or male.
Then in the paper, 60% of participants were female and only 40% were male.
So I'm going to add some weights to this random sampling.
So stats-based.weights is my next function there, weights.
And again, I'm passing an array of 0.6 and 0.4.
Of course, that's going to sum to 1.
And I want 46 of those.
And it's a very expressive language because that's almost like an English sentence that I've written there.
Sample for me from this sample space containing two elements, female and male.
Sample with weights.
So that's 60% of female and 40% are male.
Or at every turn, that's that likelihood of being selected.
There's a 60% likelihood of choosing female and a 40% likelihood of choosing male.
And I want 46 of them as well.
So shift-inter, shift-return.
And we see my vector here of strings this time, not 64, but integers, but strings.
So let's tool that down.
We say we see male, female, female, female, male.
And with only 46, of course, it's not going to be completely a 60-40 split.
46 is a small number, but it's going to be in that order.
Now, next up, I'm going to create the group, this computer variable called group.
And now I'm going to use the repeat function.
So for the repeat function, I'm going to pass again something to choose from.
In other words, it's got to be an array, but this array only has one element.
And I want it repeated 23 times.
And you can guess at what's going to happen here.
I'm going to have a vector of strings with 23 elements.
And there we go, placebo, placebo, placebo, placebo.
So what I'm trying to simulate here is I'm just going to put the 46 patients or participants in.
They took the placebo, and then I'm going to add 23 of them.
They took the active ingredient.
So how do I add to the end of an already existing vector or array?
So you'll see it's called a vector here in atom, but if you just ran it in the ripple here,
it'll say array, not vector.
But if we just want to add to the end of that 23, another 23,
I'm going to use the append bang function.
So there's append and I'll tell you a little bit about the bang
because you get many functions with and without the bang.
What the bang does, or what it does to this function, it makes the changes permanent.
So I'm going to append to the end of these 23 placebo values,
and I'm going to put that inside of the group, computer variable,
but the changes will be permanent.
Sometimes you don't want those changes permanent.
You only want them to happen with an inside a for loop or inside of a function,
but then you want the original back at the end without the permanent change.
Yeah, I want the permanent change, append to the group variable, this repeater.
So repeat active 23 times.
And if I run this now, now suddenly my vector is 46 elements long.
I've appended to the end of those 23 placebos.
I've added 23 actives.
Great stuff.
So let's close these.
There we go.
The next one that we're going to go for is we're going to actually sample from a continuous distribution.
So in the paper, they looked at a lot of variables.
I'm not going to simulate all of them here, just a couple of them.
So they looked at HDL cholesterol, high density lipoprotein.
That's the good cholesterol before and after the intervention.
So they told us in the paper what the mean and standard deviation was for the sample values for those variables.
Of course, we don't have access to them, but I'm just going to simulate them based on those parameters for the normal distribution.
So I'm going to call my computer variable HDL underscore cholesterol underscore before.
I'm going to use the RAND function, but this time I'm going to not take a unit range.
So I don't want this uniform distribution.
I actually want the normal distribution with a mean of 1.24 and a standard deviation of 0.31.
So that comes straight out the paper.
So I'm saying use this distribution.
So that's distributions.normal.
So if I said using distributions in the end, you could just have said normal.
But because I said import distributions, we have to say distributions.normal.
As I say, I'm doing this so that you can see where this normal function comes from.
It doesn't just come from Julia or some other package.
It comes from the distributions package.
So it's all about just showing you about that fact.
So distributions.normal from a mean, these oppositional arguments.
It's always going to be mean, standard deviation.
As I say, that comes from the paper and I want 23 of those.
So let's do that.
And now we've got these 23 elements.
And then I want to add another 23.
So that was read from the table as far as the placebo group was concerned.
Now I want to add from another distribution according to the summary statistics in their table
for the 23 participants who took the active ingredient.
So what do I do?
I'm going to append with a bang because I want that permanent.
Append to HDL underscore cholesterol underscore before from this distribution with a mean of 1.24.
And so that was exactly the same there and 0.29 as far as the standard deviation is concerned.
So I'm going to add 23 values to that, which means I now have a 46 element vector of those values that we were interested in.
So we've simulated that.
So it's correct for all the two groups of participants.
Then I'm going to do this a couple of more times.
So I'm going to create an HDL cholesterol after.
And again, I'm going to go through the same thing, random from an all distribution with a mean of 1.4 standard deviation of 0.35.
And then I'm going to append to that some more.
So you can have a look at that code.
I'm going to run through it very quickly because it's just a repeat of what we've done before.
So there's a wait before and a wait after, diastolic blood pressure before, diastolic blood pressure before, and diastolic blood pressure after.
So I'm just going to run quickly through all of these, just create them from the distribution as per the parameters in the table.
So let me run through all of those.
Done.
So that would be one way to go about it.
Let's just show you something else.
And the reason why I'm doing this is just to show you how a for loop would work inside of Julia.
So we have BMI underscore before, and I'm passing to that an empty array.
And an empty array is just the two square brackets.
Open, close, square brackets.
It's a vector.
And now you see the type is any.
The type here is any.
Now I just want to stop there a little bit because I want to tell you just about the Julia type hierarchy.
Everything is the type in Julia.
So if I say what is the type of some typing in the repel on the right hand side here, what is the type of just three?
Well, it's a 64 bit integer.
What is the type of three dot zero?
So I'm just saying three dot Julia knows it's a zero.
So if I enter that, we see it's a 64 bit float.
And these are abstract types.
And you can instantiate an abstract type.
What that means is I can get a computer variable and I can assign three to it.
That would be an instance of a 64 bit floating type.
If I asked what the type of, and let's make three comma three, but I'm passing these inside of square brackets.
So that is actually an array.
And if we look at that indeed on the side, it'll say array on the ID, it'll call it a vector.
Same thing.
So it's an array of 64 bit integers and it's a rank one tensor.
In other words, it is a mathematical speak.
It is a real column vector.
And again, the 64 bit integers for us here or the array that we see here, that is a concrete type.
I can create an instance of that type, but I can also look up the hierarchy.
Let's see what the super type is.
Super type is my function.
What is the super type of array?
Well, in this instance, it has a super type of dense array.
Let's go up and say what is the super type of dense array?
Well, that's an abstract array.
Okay, let's go further up.
Let's see what the super type then is of an abstract array.
And that's any.
So any is right at the top of this type hierarchy.
And it's like a branch is going down on all sides.
You get all sorts of types.
So any will have many, many, many, many types.
But I can look at all the subtypes.
For instance, what are the subtypes of?
Let's make it number.
So number is some way up a different branch of the trees.
So let's look at the subtypes of number.
And we see it has two subtypes, complex and real.
So complex is actually a concrete type.
In other words, I can create an instance of complex.
Real, on the other hand, continues to branch out.
So I cannot make...
I can't instantiate real.
I've got to go all the way down to say integer or float 64 down that hierarchy tree.
If you're interested in that, Google it.
It'll give you...
You'll quickly find this whole tree structure.
Anyway, back to our for loop, which is what I wanted to show you.
So for i equals 1 to 46.
Again, remember that would be a unit range.
So I just put in 1 to 46.
And it's going to go from 1, 2, 3, loop through all those values
because I didn't put a step size.
So I could have said something like this.
That would have jumped 1 to 3 to 5, etc.
But if I don't put anything there, it'll be exactly the same as doing this.
I'm just going to go from 1 to 46 and I'm doing steps of 1.
So 1 to 46 to the following.
When you're at the end of the line there and you hit return or enter,
it's going to create this blank space for you.
And that helps us here with seeing what the flow is going to be.
A for loop is always ended with an end.
So you've always got to have the end there.
So what am I going to do here?
I'm going to create two random numbers.
And the first one is going to be stored in placebo underscore BMI underscore before.
And the next one is going to be stored in active underscore BMI underscore before.
And what are these two values?
Well, both of them are the ran function.
Both come from a normal distribution,
but you see there's slight difference in the mean and standard deviation
from which those are going to be selected.
And I haven't said, comma, I want five of them.
No, no, no, I just leave that blank because I just want a single one of them.
So just give me one random value back from that distribution.
Store that in this placebo computer variable.
Give me random value from this normal distribution.
Store that there.
So I've got these two values now while I still won.
And I'm going to use the push bang function.
And I'm going to push to BMI underscore before.
And this BMI underscore before, it's empty at the moment.
But now I'm going to push a single value to it.
What am I going to pass to it?
Well, that comes after the comma.
And what I want to do is to assign based on what is inside of group.
So let's have a look at group again.
I'm just going to show you here on the right-hand side.
So there's group and you can see it's the 23 placebos and then 23 active.
But I can index that.
I can say what is group?
What is in position number four?
Seeing that this is just a column vector.
This is going to go from one to 46.
Of course, that was going to be placebo.
So instead of giving it a number specifically, what is inside number four?
I'm saying what is inside number I, because every time we loop through this,
I was going to be one, then two, then three, then four, then five, then six, etc.
Until 46.
So it's going to iterate through all of them.
And now it says, is this equal equal to placebo?
Double equal sign is a Boolean question.
It's going to return a two or false.
So it's the one I'm looking at at the moment.
So let's just look what group one.
We all know what group one is.
It's going to say placebo.
If this is placebo, then you see a little question mark.
And then give me back the placebo value that was stored there.
Else after the colon, give me the active value back.
And that means I can assign based on what is inside that group value.
And what we see here is called a ternary operator.
Let me do this for you here.
So we can say two is less than five.
And then question mark.
You've got to put these spaces.
So yes.
And it's not a comma, but a colon, no.
And those are strings.
You can put in anything you like.
Of course it is.
If we now say two is greater than or equal to five.
And then yes.
Yes.
And we've got to have those spaces there.
No.
Of course, we're going to get back.
No.
So it's just a very shortened version of an if else statement in case you were wondering.
So that's all we're doing here is saying we read that value.
And then we're going to assign one of those two values based on what we see in the group value.
We're going to push that into this BMI.
So let's do that.
And now if we have BMI, BMI before.
I'm going to get taken from the right distribution for all of those 46 values.
And then we're going to run through the same for loop there.
Now I've just created a bunch of random values, random variables there.
We've got our data point values.
Now we're going to store them inside of a data frame.
So I told you about the data frames package.
That's an excellent package just to work with data.
So if you're going to import a CSV file, comma separated value files, you're going to use CSV.read.
And then it's going to be stored as a data frame.
If you're familiar with R, that would be like R data frames or in Python, that would be like pandas.
So I see an open, there open and close set of parentheses.
So these are all arguments that I'm passing to the data frame function.
And what we can do there is give a name of our variable.
So think about it in a spreadsheet file.
That will be row number one, all the column headers.
And look at them here.
They are just passed as normal words without spaces in between or other illegal characters,
but they're not strings.
I'm not passing them in a strings just like that.
So I'm going to have ID.
Yeah, I'm going to use the range function from one comma stop equals 46.
So it's going to go from one to 46.
That's another way to create this iterator age with an uppercase A.
That's going to be my variable name inside my statistical variable name inside my data frame.
I'm passing that the age computer variable.
And I go all along all these ones that we've created, except here for cholesterol HDL cholesterol delta.
And to that I'm going to assign an operation I'm going to do on two of these variables that we have created.
We've created HDL underscore cholesterol underscore before and we've created HDL underscore cholesterol underscore after.
And I want this column to be the difference between those two, hence the name I've chosen.
And all I'm going to do, I'm going to do element wise subtraction.
Remember, this one has 46 elements in it.
This one has 46 elements in it.
And I want to do element wise subtraction in Julia.
That means the minus sign, but we have to put this dot in front.
So dot minus and that indicates in Julia that we want element wise operation.
So take those pairs of values subtract them from each other.
And then we've see all the others you see I've done a weight delta as well.
So dot minus.
So the difference between those two vectors element wise.
And you see for BMI I didn't create a delta because I'm going to show you how to do that just with code.
So enter shift return.
And now we have a data frame.
You can see a 46 by 15.
So 46 subjects there across 15 variables.
And there's not enough space.
It's going to emit some of them.
But there's my data frame and you can see it is like a spreadsheet file.
There I have my column headers, row, ID, age, gender, group, HDL before, etc.
But just below that Julia tells us what the type is of these elements.
So what is the type of this?
Well, there's 64 bit integers here and another 64 bit integers and then strings, strings, 64 bit floats.
Now sometimes you want to deal with these things not as strings, but as categorical variables.
And there's a data frames dot categorical bang function.
And if I pass it the data frame and then the column header.
And it's going to change that permanently because this is a bang from a string into a categorical type.
And what you have to notice here is this colon in front of group.
Data frames allow us to use the group name, the column names as symbols.
And that is a symbol.
Once there is this colon in front, that's a symbol.
And that is the notation that we're going to use when we want to refer to the columns inside of a data frame.
So remember that we've got to use that symbol notation.
So I'm just changing the group and the gender.
I'm going to change them to, if we have a look at them now, you'll see gender is now a categorical type,
not a string type anymore.
And there are advantages to that.
Next up I'm going to show you how we get access to only certain parts of the data.
Because if you start analyzing data, you don't want to see all the data in the data frame.
You want to narrow it down looking at something specific.
So I'm going to start off with by just looking at the ways to slice a data frame.
So remember when we said group, when we had group, we just looked at the first value in there.
And that was placebo.
But indexing, I used index notation here and that's inside of square brackets.
That's exactly what we're going to do here.
But here with the data frames we have rows and columns.
It is a, you can think of it as a rank two tensor.
We have rows and columns, not only values down a single column.
So we've got to refer to, as you do with the spreadsheet file, give the cells row and column address.
So here we're going to use a unit range, one to three.
So that's going to give me one and two and three.
So rows one, rows two, rows three, comma.
This here, if I just use the colon symbol, that shorthand will give me all of the columns.
So rows one, two and three, all the columns please.
So let's have a look at that.
I get indeed three rows across all 15 of the columns.
So only the first three rows there across all the columns.
Now let's just ask for a single column.
So still rows one, two and three, but only of the age column please.
And look again, I'm using symbol notation.
So there we go, unit, it's a vector of 64 bit integers and there's only three elements in it
because we've only asked for three elements.
If I want to use more than one column, I've got to pass them as an array.
So they're going to go inside of square brackets.
And I want the group column and the age column still only rows one to three.
So let's do that.
Now I have a three by two data frame object and I have the group and the age as I've asked for in that order.
And I see the first three rows for those.
What if I only want rows one and three, not one, two, three?
So I've got to put that inside of square brackets because this becomes an array.
An array of rows, only one to one, only one to three comma an array of all the columns that I want.
And now I'm just going to get this two by two data frame.
Only rows one and rows three and only for those two columns.
Now if I want to see all of the, remember I said up here we use colon as our short hand for give me all.
Just make note of it's becoming more prevalent just to use the exclamation mark when you want to refer to all the rows.
So the data frame object give me all the rows and then just the age column.
And I'm asking a Boolean question there.
Would that be the same as using this notation?
Am I going to get back exactly the same thing?
And the answer is true.
So I could use either of those two notations.
Now we're going to pass a rule.
We only want the data frame back all the columns but, so we're going to see all the columns,
but go down the age column and only return those that have an age of more than 50.
So how do we go about that?
So I want to see the whole data frame with all my variables,
but I only want to see it for participants who are older than 50 years of age.
So this is what we're going to do.
We have this very nice dot notation.
So if I say df.h, let's do the Tien Le Repel, df.h.
And now it's just going to give me back this 46 element array or a vector of these 46 values.
So df.h, it's a shorthand.
Otherwise I could have written df like we've done up here.
And here I would say give me all the rows only of the age, exactly the same thing.
But shorthand I can just refer to it as df.h.
It's just going to give me back this array.
And you can see there the return is not a data frame.
It is an array that we get back.
So go down each of them and see if they're greater than 50.
So the dot greater than again, that means it's going to go element-wise.
So it goes down.
Everyone, is it more than 50?
False.
It's not more than 50.
This first one, that row is now not included.
Next one, 35.
It's not more than 50.
It's not included.
And let's go down now and this would be the first row that gets included
because this participant was older than 50, comma, all the columns.
So that's very nice notation.
And you see we down to 18 participants now.
And if we go down the age column, they're all going to be older than 50.
Simple as that.
Now maybe I want to string more of these together.
Now I only want participants that were older than 50
and they were in the placebo group.
So how are we going to go about this?
Again, it's my data frame.
Rows, columns.
So there's my comma.
I want all the columns there, but let's look at what rows I want.
Well, I'm going to put these inside our parentheses.
So I've got these two rows that I want.
So one df.h and dot greater than, so element wise, 50.
Dot and, and that's the symbol for and.
So both of these have got to be true before we get a true back.
So we just have normal logic here.
So it is dot and and we want the df.group to be dot equals equals placebo.
So row by row.
And all these things have to be true before we, we get that row included.
Now we're down to 10.
And they are all going to be over 50 and they're all going to be in the placebo group.
You can see how easy it is just to manipulate the data to get something very specific back.
That means I can also create new data frames, sub data frames from the full set.
So I'm going to call mine placebo and intervention.
And I want to split the participants up into two very separate data frames.
Very easy to do.
Call the data frame, address the rows by df.group dot equals equals placebo, comma all the columns.
So in this new data frame only has 23 participants in it,
but they're all going to be in the placebo as far as the group is concerned.
And I'm going to do the same and I'm going to call that one intervention.
And of course in the group, it's only going to be the active participants taking the active intervention.
I promised to show you that I had to do this with a data frames code.
I should have said this difference between.
So if you want to create a new column, I have to create it this way.
So there's df, square bracket notation, and then by symbol name.
So if we scroll back up when I created this data frame, I did not use symbol notation here,
when I want to add a new column, I use symbol notation.
So create this new column.
And that is going to be the difference, the element wise difference between these two arrays.
And the first ray is df underscore bmi before dot minus to indicate that it's element wise df dot bmi after.
So that is going to allow me to have this new column in my data frame.
We see that I now have 16 columns.
Now I want to show you a little bit about the query language.
What I want to show you actually is this that it exists because it is phenomenal and it is vast for you to start taking or selecting and changing, manipulating only a part of your data.
So I'm going to show you just a couple of examples here, but that is many, many, many lectures worth of things you can do.
So I'm going to start with my data frame, and then I have this pipe operator.
So that will just be the up-down stroke on your keyboard or my keyboard that's above my enter.
So I hit shift and the key above, it'll be different for your keyboard, I'm sure.
And that's state data frame and pipe it into what comes next.
And here I'm using, I suppose, the generic form of the query package.
So I'm going to start a query and we're using a macro here.
So in Julia, it makes use of macros like this and what the macro would do, a macro actually generates code.
So instead of us writing out the long code, the macros, we can create macros that actually generate code and then that code gets executed.
So it's a very nice way to write the succinct, just the sort of a function there, a macro that will generate code and do something for us.
But this is built at query macro, is built into the query package.
So I'm going to say what query do I want to have.
So I'm going to create this variable called I.
Now it's another thing we haven't spoken about and it's local variables and global variables.
Let's do that.
Here I've created a variable name and I've assigned some object to it.
This placebo exists in a global space, in the global space.
In other words, I can make use of it anytime.
It exists in its value, exists everywhere.
Inside of a for loop, as we did before, we created some computer variables, but those only will have a local scope.
Outside of that for loop, they don't exist and I can't refer to them again.
They're not permanent.
They're not in the global scope.
So here we have query I and then begin.
To every beginning, there's an end here.
And then I'm going to use other macros at where I dot age is greater than 50.
So what's happening here?
This pipe operator piped DF into the query and it was put into the query right there with the I.
So I'm piping DF into I.
So when I say I dot age, I'm actually saying DF dot age.
It's just being piped into this I here.
So where the age is greater than 50, then at select, and I'm passing these inside of a set of curly braces,
I dot HDL cholesterol before and I dot HDL cholesterol after.
So it's going to select only those two columns for only participants older than 40.
And then end my begin, then my end, close my query parentheses there and pipe that into something.
And I want that to be piped into a data frame object.
But because we only used import data frames, I've got to say data frame dot data frames dot data frame.
So if I run all of that, lo and behold, I get this back.
Only those two columns that I asked for.
So DF dot HDL cholesterol before and HDL cholesterol after.
And it's only going to be for people who are older than 50.
So this is just a quick look at what the query language can do for you.
Now I could have done that much simpler before, but this complexity allows me to become very specific.
And there are more macros than just these.
Before I get to the next macro, I just want to show you this.
Many times when we collect data, we try to protect patient confidentiality.
And in a very simple example, what we might do as researchers beforehand, we're going to just subtract in our heads two.
So for instance, it's the value two from everyone's age.
So if someone was really 50, I'm going to capture 48 as the age.
No one outside of the study knows that.
So if someone got hold of that data, it's a little bit more difficult to bring that back to an actual human being.
So that's a very simplified example.
It won't work in the real world.
You'll have to be much more inventive than that.
And there are ways to do this.
But if I want to change something permanently, so DF dot age, I'm now saying assign that to DF dot age dot plus two.
So that's going to add two to everyone's age.
And if you capture data in that way, where you changed it before you analyze the data, of course, you want to change that back.
So that would just be the way to do that.
Here we are back with the query package.
So I'm going to pipe data frame into this at filter macro.
And we've done this one before.
I only want the ages back and whether on the placebo group.
This would be the way to do that.
We saw that before, but this is way to do it with query.
So pipe DF into this.
And instead of I, we have this underscore here.
So DF is going to go in place of those underscore, but I'm using at filter.
So I want ages greater than 50 and group equal to placebo.
Note the differences, though.
There's no at before that.
And I'm using the double ampersand.
And then so you've got to read the notation on the query package and I'm piping that into a data frame.
So what we're going to get back is this data frame of all the columns, but we're only going to have participants older than 50 again and only in the placebo group.
One more way just to use the query.
I just wanted to show you that we're going to pipe DF into the at group.
So I want to group by DF dot group because this DF was piped into this placeholder.
And then the at map query.
And I want two column headers.
My first one is going to be called key.
And my second one is going to be called count.
And to the key, I want the key function inside of query.
And you'll see in a while what that means.
And then in the count column, I want length.
Length is a Julia function.
And that is going to just count how many things they are.
So let's have a look at what happened here.
So I've created a data frame because I piped this all into a data frame.
And I have two columns.
One is called key.
That is my selection there.
And one is called count there.
Key, this key function, what it did to this placeholder because this was all piped.
So let's just look at this piping.
DF was piped into the group by.
So this now becomes DF dot group.
DF dot group, that got piped into all of this.
So this is now DF dot group.
So it's key of DF dot group.
And that's what piped.
We've got beautiful visions of that in our programming language for statistical analysis.
Same sort of thing.
You built this pipeline of execution.
So this DF was piped into this placeholder.
Now the whole lot was piped into this placeholder.
So this becomes DF dot group.
And the key of that is going to return for you the sample space elements.
What are all the unique elements that were found in that column?
So in the group, in the DF dot group column, there was only two sample space elements, placebo and active.
And that's what it's going to give me back.
But in the second one, I want to count how many times it occurred.
So this is a way to count the occurrences of your sample space elements of a variable.
And there we can see we had 23 with placebo and 23 with active exactly as we designed it.
Great.
Let's do some summary statistics.
The describe function is very, very useful.
So it comes from the stats-based package.
So if you just see the scribe, they would know where it comes from.
But I said import stats-based.
I've got to say stats-based dot describe.
And what I want to describe is from the DF data frame.
Take all the rows for me in the age column.
Remember, there are different ways to write this.
You could have just said DF dot age.
Anyway, let's execute this.
And the result is just a tick mark because it's executed in the REPL.
So it says there were 46 values.
There were no missing values.
The mean was 46.93.
The minimum, the first quartile, the median, the third quartile and the maximum value.
They were all there and they were all 64-bit integers.
So a nice descriptive statistics here of that column.
There's also the summary stats function.
That's going to do exactly the same.
But it's going to return it for me here in the REPL.
So I can cool down and see those results here.
And then the statistics package.
That is one of the built-in Julia packages.
You don't have to install that.
Remember how to install, go here, write square bracket, type add,
space and add what you want to add.
And then import it with import or using.
So statistics dot median.
So this is going to give me back the same value as we had before.
The 48, there's the median there.
It was 48 indeed, no problem.
One thing you won't see here is the standard deviation.
But there's a statistics dot STD that gives you back the sample standard deviation.
And if you read the documentation there,
you can also ask for the population standard deviation.
It has a mean and standard deviation, mean underscore and underscore STD.
That's a function inside of stats base.
And that's going to give me back a tuple.
A tuple is different from an array.
Instead of square brackets, we see parentheses.
And by the way, tuples are immutable.
So you can't change their values as you can with arrays.
But that's a story for a different day.
We get back the mean and the standard deviation.
Variants, of course, is just dot var.
Again, there is another argument that you can pass that gives you back the population variance.
This would be the sample variance.
There's a statistics dot quantile function.
And you can ask for what percentiles you actually want.
I want the 25th and the 75th.
That gives me the first and the third quartile values.
And you can see for age, those are the ones we saw there, 40 and 55.
In stats base, not inside of statistics, but inside of stats base.
There's an IQR that is going to give us the interquartile range.
But I can also do that with code.
Let me just go to the front of this.
I can say statistics dot quantile, the 75th minus statistics dot quantile, the 25th.
And if I execute that, I'm also going to get back 15 because that's what the interquartile range is.
The difference between the third and the first quartile.
Span, stats base dot span, that's going to give you the full range.
So the minimum and the maximum value.
And remember, initially we chose it from 30 to 65, but we added two to each.
One of the participants age.
So now we see the youngest was 32.
The oldest was 67.
Now this is a bit of a convoluted one.
I want to show you here in the describe function.
What if you don't want everything back?
So I'm saying here df, all the rows, comma, only these columns.
But this describe function can take back, can take as arguments some things that we want to create.
What do we want to create?
Well, that comes after the next comma.
Create a symbol for me.
That's a column header with a name AVE and attach to that.
And we have to use this arrow notation.
So that's equal greater than stats base dot mean another symbol STD and attached to that.
Stats base dot STD.
So that becomes quite convoluted.
And it takes a while for you to get behind what is exactly how to do that and remember how to do that.
But that gave me the age and the cholesterol delta.
And it gave me the average of each of those and the standard deviation for each of those.
So that would be another way to go about this.
And what you can start to see here, what's developing here is the fact that there's just so many ways to do things in Julia.
There's the unique function in Julia.
And I'm telling it go down the group column.
All the ones just give me back what is unique.
Well, we know it's going to be placebo and active.
So we're going to get back just sample space elements.
I could do it with query language.
Also, I could say pipe DF into the at group by.
So this is going to become DF dot group.
Pipe that into this map at map macro.
And all I want is a key and pipe that into a data frame.
And now I'm going to get exactly what I got back here with the unique.
Instead of getting back just an array, I actually pipe this into a data frame.
So I'm going to get my sample space elements there.
There's a statspace dot count map function.
So not only is it going to give me back the unique values, but it's also going to count how many there are.
And again, I see active and placebo.
But I can also do this just with the query language.
So I'm piping DF into group by.
So DF dot group, that gets piped into the map.
The key, so DF dot group, the key of that.
So that's sample space elements and the length is going to count all of them.
And you know exactly what we're going to get here.
This is what we have before.
We're going to get placebo and active and their counts.
So so many ways.
Whatever pleases you, you choose that way.
One more thing, let's do the median.
And we do only of people who are older than, participants older than 50 in the placebo group.
And then I can use another set of indices here.
And that is only give me back the median of the ages then.
So what we've done here is the median of the age of participants in the placebo group that were older than 40, the older than 50.
So this is a different notation to do this first and then what you actually want.
So hang on to that notation.
It is sometimes easier to use.
Sometimes it's much easier just to use some of these macros inside of the query language.
We can construct our own functions.
And that's one of the beautiful things of Julia.
Construct your own function.
So I see the function keyword there.
Tell Julia I want to create a function.
The name of my function, I decided on that.
And it's going to take a single positional argument X.
And it's going to return for me the following.
Statistics.meanofwhateveripassin, statistics.std ofwhateveripassin.
End.
We always have to have an end.
And now I have a new function, mean and standard deviation.
As you can see here, it is a new function.
And now I'm going to pass an array to it, df.age, into that function.
And so that takes the place of all the X's.
So I'm getting back the mean and the standard deviation of that.
So you can create your own functions too.
Let's do this last one before we visualize data.
I'm going to group by group.
I'm going to map the key.
And then create two column headers, average age and standard deviation age.
And I'm going to perform those two on it.
You can see what is going to be in that placeholder because df is going to be piped into there.
And then this makes a df.group that gets piped into there, which is also piped into there and there.
I think by now you get the meaning of how to write these pipelines.
So I'm going to get placebo and active back.
And that gives me the average age and the standard deviation of the age for those two groups.
Very easy to start learning how to put these together.
Now let's get back, let's get to one of the exciting parts.
We've summarized our data and we've really summarized it a lot.
We've created a lot of other variables.
So please play with them and see what results you can get.
That's the only way to learn is to start playing with these.
So get fly.
There are other plotting libraries as well.
I'm going to show you get fly here.
I like the way the plots look.
And it's a very simple specifically if you know how to use ggplot.
So get fly dot set default plot size.
I'm just going to set it for argument sake here to fit in here to 800 pixels by 600 pixels.
So here's a very simple plot.
Remember I said using get fly.
So I needn't have said get fly dot set or get fly dot plot.
I can just use the plot function directly.
Now get fly.
I like get fly.
It works very well with data frames.
So my first argument is this data frame.
It's the data frame we're passing on the x axis.
I want the group variable on the y axis.
I want the age.
And what geometry do I want?
Well geom dot box plot.
So I actually want Julie here to create a box plot for me.
There's a couple of guides.
One of them is title.
So guide dot title.
Give it a title as a string.
And then you can also do a theme.
So my theme here is going to have a default color midnight blue.
There's a bunch of these already built in.
You can Google that and see all the theme colors that are built in.
And I want to also just make a hundred pixels in between my box plots.
As simple as that.
I'm going to hit shift and enter, shift and return.
And I'm going to go make a cup of coffee.
Because the first time you create a plot,
there's a lot of stuff that have to happen behind the scenes.
It has been recognized that this is a bit too long.
And there's certainly a lot of work going on behind the scenes
and trying to improve this time to first plot in Julia.
It is a known problem.
You do wait quite a long time before that first plot is created.
So I'm going to go often have some coffee.
I don't know what you're going to have.
I'll see you back in a minute or two.
And there we go.
It really wasn't a minute in my case.
It was about 10 seconds.
It was slightly less than 10 seconds.
So it's not that bad.
Anyway, that is from the time I stopped talking, by the way.
And there we go.
I see a beautiful box plot.
I see my age on my y-axis.
I see the two groups.
It found placebo and active all on its own.
And we see the title that we created up there.
And we see these beautifully rendered midnight blue box plots.
Very nicely.
You can assign that to a computer variable
because you do get packages and you do get the draw function,
which can save this plot that you've assigned to P,
save it to your hard drive as a PNG file, SVG file.
Now you might have to import some other libraries.
I think with PNG you'll have to import Cairo, C-A-I-R-O,
uppercase C package to export to PNG.
Otherwise you can just export to SVG.
It's capable of vector graphics.
And those are very nice to use in other programs like Inkscape
or Adobe Illustrator, et cetera,
to add a lot more to your plots.
So here I'm going to use plot again.
Plus the def, I'm going to have on my x-axis the changing
cholesterol, color by the group.
Now this color has nothing to do with color.
Color argument here means split by.
So group by the group column, whatever the sample space
elements you find there, give me a geom.density.
So this is going to be a density plot of the changing cholesterol
before and after the intervention split by the group variable.
And then I've just added a title.
So let's have a look at that.
And there we see a beautiful density estimate
of the placebo and active group as far as the change
in the cholesterol values.
We're concerned if we look at these two distributions
for our data values.
So beautiful density plots there.
You can also just ask for plots that are models.
Look at this data frame.
x-axis is BMI before, y-axis is HDL cholesterol after.
So this is going to be a scatter plot.
And indeed, I'm calling geom.point.
That gives me point marker.
So this is a scatter plot of two continuous random variables,
BMI before and HDL cholesterol after.
So I'm trying to predict HDL cholesterol after
given an input of BMI before.
And I want that done separately
for each of my sample space elements in my group column.
So color equals symbol group, geom.point.
And then in the layer argument,
I'm going to call the stat.smooth function inside of GATFLY.
I want it to be a simple linear model
and I want a 95% confidence interval around my model.
And that's going to be a geom.line
and the ribbon is the confidence intervals around that.
Then outside of that, I've got a title and a theme.
And in my theme, I'm passing a bit of transparency
and I'm making the point size the markers of the scatter plot
quite big with 10 pixels.
Let's have a look at the output of this beautiful plot.
It's going to take a second or two again
because it's now also creating this linear model behind the scenes.
So I'm not even using a package that does linear modeling.
They exist too, GLM being a beautiful example of that.
But just inside of this plotting package,
GATFLY, I can do this.
And then I can see my two models
both for the placebo and the active group.
I see my markers with a bit of transparency
and I see my two linear models
created with a confidence interval around those.
That is absolutely fantastic
and those plots are really beautiful.
Let's do some inferential statistics.
Now, with inferential statistics,
we always start off by describing our data.
Now, we've already done that
and the one that I'm going to concentrate on here
is just to see what's the difference in HDL cholesterol
from the difference mean before and after
but between the two groups.
So we've just got the subtraction
of what the before minus after,
that gives me one variable
and I've got that same variable split
along one of my categorical variables, which is the group.
So I'm just asking a question.
Is there a statistically significant difference
in the change in cholesterol?
So my null hypothesis is that
there is no difference between those two
and my alternate hypothesis is
that there is a change between the two.
So one can be higher than the other
and I'm using an alpha value of 0.05.
So there's my hypotheses.
So let's just describe the placebo group.
Remember, we created these two sub-data frames.
Let's just go back to the REPL to see the results.
I'm describing HDL cholesterol
from my placebo data frame.
So that's another way to go about it.
You need to use the query to select these.
Just create two sub-data frames,
one for each of your groups
and that's what we did in the beginning.
So I have my placebo and my intervention group
and there we can see summary statistics.
The mean of the difference was negative 0.1
for the placebo group
and negative 0.22 there
for the, so there was a bigger decrease
in the HDL cholesterol
in the time period before and after the intervention.
We can also just ask for the following.
So I'm asking for confidence intervals.
So that comes from the hypothesis tests function
package.
There's a confint function
and what I'm going to do is call the one sample
t-test function also from hypothesis tests
on each of my two,
each of my two data sets,
the HDL cholesterol delta for each of my two groups.
So I've got the mean
and I can work out the standard deviation
but here we have the 95% confidence interval
around the means for both of these.
So very simple for us to use hypothesis tests
just for confidence intervals.
I've really plotted these two distributions for you.
So let's just have a look at our assumptions
for the use of parametric tests.
So in hypothesis tests
there is a p-value function
and what I want to do,
it does not have a Shapiro-Wolk test
but it has comograph Smirnov
and I think a few others.
So I'm just going to use ks-test here.
So exact one sample ks-test
and I'm passing my cholesterol delta
for the placebo group
and against a normal distribution.
So that's a ks-test
against a normal distribution.
So let's do that.
It's going to give me back a p-value.
So the null hypothesis, remember,
is that it is from a population
in which this variable is normally distributed
and let's do the same for my second group
and there we have a problem.
We see that a p-value of less than
and chosen alpha value of 0.05
so we're not really there
meeting the assumptions for the use of a parametric test.
I can investigate that visually
by qqplot.
So let's just have a look at this.
I'm creating two plots p1 and p2
and each of these are going to be a qqplot.
So in the x-axis I have the values
and on the y-axis
we have the theoretical distribution there.
So I'm calling distributions.normal
and it's all going to be changed by this
stat.qq.
So it knows what to do,
what to do with the values for a qqplot
and then geom.point
so it's scatterplot
and then a semicolon
because I don't want any output to the screen
I'm going to do that same for the intervention group
and then we're going to call getfly.vstack
so I could also just say vstack
because we said using getfly.
So vstack, plot 1 and plot 2
so make a vertical stack of those two plots
and then the plots I can see a vertical stack
of these two qqplots
I can see here for the second one
that's really off of a straight line there
for normal
so we're not really meeting the assumptions
for the use of parametric tests
and although this data was taken
from the normal distribution when we created this
we only took 23 points from each
so there's always the chance
that we get random values
that are not going to show up to be from a normal distribution.
So in that case
for two groups
the symmetric test will be the Man-Whitney-U test
and of course there is a Man-Whitney-U test there
I'm just passing my two data sets
my placebo's changing cholesterol
and my intervention changing cholesterol
using the dot notation
so it's going to give me two arrays
that's what we like with the Man-Whitney-U test
and I want the p-value back from there
so let's have a look at the Man-Whitney-U test
gives me a p-value of 0.7 there
so that is above my
alpha value of 0.5
so we can't reject another hypothesis there
just to show you that we also have an
equal variance t-test
so if we did meet the assumptions with the use of a parametric test
there we see equal variance t-test
is another function
and we can run that but we're going to see
a p-value
that is also above 0.05
so no problems there
last thing on today's list
I'm going to show you just how to do a chi-square test
for independence
there is no such function in the hypothesis test data
for any of the packages of yet
so we're going to do this by hand
so I hope you know the equation
for working out a chi-square value
we're just going to sum over the square differences
between observed and an expected contingency table
and then divide that by the expected values
and that gives us our chi-square value
and then we're just going to use a chi-square distribution
as far as the degrees of freedom are concerned
so let's create a frequency table
a contingency table of observed values
and what we're going to use is the
freq tables function
package.freq table
frequency table function there
and what I want is the data frames
and I want group against gender
those are two categorical variables remember
we changed them to categorical variables
but what I want back is not a data frame
I want it to be converted to a straight up array
so I'm going to use the convert function
change to array the following thing for me
this frequency table and I'm going to store that
in gg underscore obs
that's my contingency table of observed values
and what we get back is this 2 by 2 array
of my observed values
and that's what you want for your
for your chi-square test for independence
and you can see it's 64 bit integers
but I have two dimensions now
so there's rows and columns
this is a rank 2 tensor or a matrix
and that's exactly what we want
now I want to know from this
the row totals and the columns totals
so this first column will have a total
at the bottom here
16 plus 14 is 30
and 9 and 7 is going to give me 16
but then I want across
the two columns for each row as well
so I want both the row totals
and the column totals
I'm going to use the sum function
for my matrix but I say a long dimension 1
so let's see what that gives us back
that's going to give us back the 30 and the 16
so that's adding 16 and 14
and adding 7 and 9
but if I say dims equals 2
it's going to give me across
the 23 and 23
so 16 and 7 is 23 and 14 and 9 is 23
so I have the row totals and the column totals
I need those and I need the sum total as well
remember there were 46 participants
so no problem there
now I just want to know the size
as another function we haven't seen before
what is the size of this array
and that's going to give me back a tuple
of how many rows, how many columns
and if I have a higher rank tensor
I would have more elements there
but it's a 2 by 2 array
that we're passing to that
so now I'm just going to instantiate
an empty array
of similar shape
so 2 by 2 array
and they're all just going to have 0 values in it
so I want the number of rows
with this ggdim
its first value 2
and gg underscore dim its second value there
so if I had more than
2 sample space elements in each of those
group and gender
it was just male and female
and active and placebo group
so there's always going to be a 2 by 2 contingency table
but if I had more
and these were different 3,4
for instance
I would just still reference these 2
by now I could have just put by hand 2,2
but I want to show you where that comes from
this gives me this
array of all zeros
I'm just instantiating that because I want to overwrite
each of these values
and I'm going to overwrite that with a double 4 loop
I'm saying for i equals 1,2
gg underscore dim 1
so that means 2
so for i equals 1,2,2 and then for j
equals 1,2,2 as well
so I want to
iterate through all these 4 values
row 1 column 1, row 1 column 2, row 2 column 1
row 2 column 2
I want to overwrite all of those
and remember how do I get that first one
well that is this
row total
multiplied by this column total here
divided by the sum total
and that's what we're doing there
so I'm overwriting at the moment
i is 1 and j is 1
so I'm overwriting gg
as expected
which is just this 4 zeros
so I'm now in position 1 what do I do
well I take that columns total
1 times the row total
1 divided by the total 46
and that gives me that first value
now I'm going to iterate over the inner 4 loop
so j becomes 2
so that's the second column
so we now
at that one there I'm still in the first row
so now we're looking at this value up here
divided by the total
and that's going to give me that value
now we through this j loop
so we jump out to the 4 loop
and i goes from 1 to 2
now it's 2
and now we're going to go
again it's back to column 1, row 2
and then column 2, row 2
so that's with a double 4 loop
I'm going to iterate through all those
values
and if we look at the table now we see our
expected table
and that's what we would expect
is our observed values
and we want to know is there a difference
how do we do that, remember
it is
observed minus expected
but I do that element wise
so it's dot minus, dot square
all of those differences individually
so dot and to the power
2, that's to the power
2 and then each of those
I divide by
the expected
the expected value
at the end I sum over all of those
and that's how I get chi squared
and look at the beauty of Julia
you see the chi symbol there
well we can actually use unicode
so I can say backslash
alpha
and hit tab and that gives me an alpha symbol
or backslash of beta
so it is like latic
so I hit tab and I get the beta symbol
and I can assign that to
that's a variable name
so chi2 there, that's a variable name
look at that
backslash
colon
smile so you can
put all of these
little icons you can also use
for
computer variable names
it's just a little whimsy that exists
there inside of Julia
and anyways that's my chi squared value
and there we go it's 0.38
is that
significant so is there dependence between those
two
well I'm going to use from the distributions package
this time the pdf probability density
function
I'm going to use a chi squared distribution
with a
degrees of freedom of 1
remember that is the number of rows
minus 1 times the number of columns minus 1
so it's 2 minus 1 is 1 times 1 is 1
so it's a single degree of freedom
and I pass the x square value to that
and that's going to give me a p value
and oh behold it is more than an alpha
difference between those
people did not land up in one of the two groups
that was totally independent
of the gender that they were
so we have a chi squared test there
done by hand very easy
very quick
very simple to do
are four loops slow? no they're not slow
so you needn't vectorize your code
to get speed in Julia because remember
this is going to be compiled
before it gets executed
and when a for loop is compiled
very quick so no problems there
whatsoever
so that was a brief introduction just to Julia
by way of showcasing some medical statistics
some simple medical
statistics
this has been an update from
the video that I uploaded in 2015
that still used Julia 0.4
and there are certainly lots of breaking changes
when we got to Julia 1, Julia is now mature
we had version 1.4
and it really just is a pleasure to use
right inside here of
Atom
now you needn't use it inside of Atom
you can also
use it inside of Visual Studio Code
that is becoming more prevalent
and of course iJulia comes
with Julia Computing
but you can also install iJulia
let me just show you here
so I would go on this side
and say add iJulia
execute that and then
we could say using iJulia
and once we say that we can just call the notebook
as a function
and that's going to open a Jupyter Notebook for us
so iJulia is going to
install
all its dependencies
well I should actually just put that in uppercase
that's the correct one iJulia
the i in the jr uppercase
and you can use Julia Notebooks
so you can code right inside of
Atom
you can code inside of Visual Studio Code
or you can code right inside
of Jupyter Notebooks whatever your preference is
so Atom
comes with Jupyter Computing
i should say Julia Computing
when you install Julia Computing
you're going to get this as your default
IDE
and it really is a lovely IDE
to code in. I hope you enjoyed that video
like, subscribe and comment
if something wasn't clear let me know
I can perhaps
spend some more time and explain that
otherwise spread the word
it is really easy language to use
it is beautiful, a lot of speed
of course with the size of datasets
that we commonly work with
in inferential statistics when it comes to medicine
we don't really need that speed
but it's just such a lovely language
to use and learn
that I don't see
any reason why you shouldn't
spend a couple of days and weeks
to get yourself familiar with this
lovely language
I hope you enjoyed this video
see you in the next one
bye
