Now we've taken pencil and paper and we understand the imaginary unit, complex numbers and complex
arithmetic. Now in this video we're going to look at how to use Python for complex numbers. And we're
going to do that in three steps. We're going to look at the built-in functionality in Python,
then we're going to have a look at the cmath module, and finally, most importantly, we're
going to look at symbolic Python, the SymPy package. So I've already opened up a brand new notebook,
a colab notebook inside of a folder on my Google Drive. Now I've pre-populated this notebook just
so that you don't have to watch me type. Now we can see the three sections there, the imaginary unit
ij and complex arithmetic in Python, the cmath module and complex arithmetic using SymPy.
Now I'll make this notebook available so that you can see how I did my typesetting. For instance,
there we see a title, if I double click on that, and then you can see a single hashtag and a space,
and that denotes the largest font size, and that's very good for a title. Now I'm going to connect
to the server, so I'll hit the connect button. I get my little green check mark. So an instance of
Python is running on Google servers, and that is served up to me here in my browser. So first up,
we're going to look at the imaginary unit i, and in Python that is a 1 and a j, no space in between.
So this is built-in functionality inside of Python. We don't have to install anything extra,
no extra modules, no extra packages. It's just built inside of Python. And there we
have it. If I want the imaginary unit i, in Python, I would simply type 1j. And now I'm going to hold
down shift, and I'm going to hit return or enter, and that line of code is going to be executed,
and we see the result right there, 1j. Now j is often used in engineering to denote the imaginary
unit, because i is usually used for current in physics and engineering. So don't get confused
between the two, whether it's i or j, it doesn't really matter. Now next up, I want to show that
i squared equals negative 1. And that's how we define the imaginary unit. It is a number
such that when we square it, we get negative 1. And so what I'm going to type is 1j. There we go,
that's code. And then a space, and then the star symbol, which means multiplying Python,
another space, and then 1j. Now you don't need those spaces, but it just looks a little neater.
Now I'm going to hold down shift and hit return. What you can also do is just hit that little play
button. We see the result minus 1 plus 0j. Now 0 times anything is just 0, so we can just ignore
that bit at the end, and we see negative 1. That is the result, minus 1. i squared, or then 1j squared,
well that's just equal to negative 1, just as we would expect. Now please review the videos where I
take pencil and paper to show you how these things fit together. In the Python version of these videos,
let me show you how I constructed this. So you see right there, show that i squared equals negative
1. If I double click on that, this is how I constructed that sentence. First of all,
this is a text cell, and I'm just typing show that. And then inside of these set of dollar symbols,
I use LARTECH. i to the power 2, that 2 goes inside of braces equals negative 1. We can see on the
right hand side what that's going to look like, and I'll just hold down shift and hit return or enter,
and that line of text is executed. So inside of those dollar symbols, as I mentioned, that's LARTECH.
That's a specific kind of mathematical typesetting that you can use inside of a notebook,
but you can also use that in various other places. Very nice for mathematical typesetting.
Now if I hover just between any two cells, right in the middle, I see I can create a new code cell or
a new text cell. And that's what I do. Just as the document grows, I'll just add code cell or a text cell,
code cell or a text cell. And I will remember that I can always come and just in between
anything that exists before, I can just add a new text cell or a new code cell. And so I like to keep
my documents neat and tidy, such that you can see here. If I go back up, you see my largest font size
there. That was a single hashtag. When I come down here, that's my first section. If I double click on
that, of course, that was a text cell. And I've got the two hashtag symbols and a space, and that denotes
the second largest font size. And by the way, do you see these funny tick marks in front of the 1 and J?
If you do that inside of a text cell, that's going to print out a format that looks like code inside of
a text cell. So let's execute that by holding down shift and hitting enter or return. And you can see
I'm using a dark theme. So we see the 1 J here is with a dark background. And that just, you know,
again, it's just a little bit of typesetting just makes it look nice and neat to me. Now that we've
spent some time just going thinking about how to construct a nice notebook with code cells and
text cells, let's carry on with the mathematics. That's what we're here for. So our next question
is to use Python to show the complex number three plus four I. And there you can see code. Remember
what you can do, just hover in between, click on code, and a new code cell will open for you. You
can of course just go to the right and delete that code cell. So I created a new code cell and I typed
three plus four times one J. We already know one J is just I. So that's three plus four times I. Now
mathematics, we can just put four I and we know there's a multiplication symbol between the four
and the I. But in Python, we have to put that multiplication symbol. And as I mentioned, the
multiplication symbol inside of Python is a star symbol that shift and eight on my keyboard. So this
is going to be three plus four times I J. Let's execute this. I'll just click on the little play button.
And then we see the result three plus four J. Now that J, remember, that's just I. So this is
three plus four I exactly as I want. Now there is an alternative way to do this. Much of the
functionality in Python is locked up in functions. Now functions are keywords. They are reserved words
for the language. And so when I type complex, as you can see there, Python knows what to do. It's a
keyword. It can act upon that word and do something. Now with functions, you'll see an
open parenthesis and a closing parenthesis directly after a function name. There's no
spaces between that X and the opening parenthesis. What goes inside of these set of parentheses
are the arguments. That's the information that you give to the function so that it can do its
job. So complex. In this instance, I'm passing two arguments to it. Arguments are always separated
by a comma. So you see three comma four. And that's what we're trying to do here. The complex
function creates a complex number and we are passing the real and the imaginary parts of that
complex number. Hence the three comma four. Now just on top of that, you'll see another little
hashtag symbol, a space and then alternative. Now that hashtag symbol is not the same hashtag symbol
as that we see in a text cell. When you see a hashtag symbol inside of a code cell, that is an
instruction to Python to ignore anything on that line that follows that hashtag symbol. This is what
we call a code comment. This is where you can leave comments to yourself or to others that read
your code. Python is just going to ignore that whole line. Anything that follows the hashtag symbol
on any given line of code is just ignored. So I've written the word alternative there. I just want to remind
myself that there's an alternative way to create a complex number in Python. So let's execute this.
Instead of the play button, I'm going to hold down shift and hit return or enter. And I see the exact
same result as three plus four I or in Python speak, that'd be three plus four J. Show that the real
number four is the complex number four plus zero I. And so zero times anything, even I is the zero.
So this is just four. And here we can see really that the real numbers are a subset of the complex
numbers. All real numbers are actually complex numbers. They just have a complex part or an
imaginary part that is zero. So four plus zero times IJ. If I execute that, shift and enter,
shift and return, I see four plus zero J. And that really is just four. Just to remind you,
I can also use the complex function to create a complex number. I'm just passing the real and
the imaginary part as two arguments. Arguments go inside of the parentheses. Parentheses directly
follow the keyword that is a reserved word in Python. So that's Python language. And it's going to give me
back the complex number four plus zero I. And that's exactly what we see. Now let's do some
arithmetic. We need to add three plus four I and two plus four I. Now what I like to do is just to take
each one of my complex numbers and put them inside of a set of parentheses. So this would almost be like
mathematical parentheses. I just want those parentheses around these so that I know which
parts, because remember I have addition and multiplication going on. I just want to combine them
all into this one object, this one complex number. And then I'm using addition. And then the second
complex number. So that would be three plus four times one J, plus two plus four times one J. And
let's execute that. And we see the two real parts are going to be added. So that's the three and the
two that gives me the five. And the two imaginary parts, the four and the four, four plus four is eight.
And so I see eight I or in Python speak eight J. The alternative again is just to use the complex
function. So complex is three. That's my real part for my imaginary part plus complex to the real part
of my second complex number and for the imaginary part. And if I execute this, I'm going to get
exactly the same result. Now, of course, I can also do subtraction and we can see the three plus four
I minus two plus two I. So I'm going to get three minus two for the real parts. That's just going to
be one and then four minus two. That is for the imaginary part. So that's going to be plus two I let's
execute that and see if that's indeed what we get. Yes, we do. That's one plus two I or in Python speak one
plus two J. Now, of course, we can take a scalar and we can multiply that with a complex number. That's just going
to give us distribution. So three times two is six and three times three is nine. So that's going to
be six plus nine I. And here we have there's our code over there three times. And now I really have
to use that set of parentheses because I want to show that we are going to distribute this scalar three
over what is an essence and expression. I have a two and I have a three I and I'm adding those two terms.
And so let's execute this and we get six plus nine J as we expected. Now we can also distribute a
complex number such as three I. I'm going to distribute that over two plus three I or indeed
this is three I times two I plus three I. And this is what I have. Now, how would I do this? Now this
part here is my three I that's three times one J. And I'm going to multiply that by and again, I put
this all in a set of parentheses two plus three times one J. Let's execute that. And three times
two is six. And that has an I there three I times two that's six I that's what we can see at the end
there six J. Now three times three is nine, but I times I is negative one. And that leaves me with a
negative nine. So we see negative nine plus six I. Now we can also multiply two complex numbers as you
can see there three plus two I times one minus three I I'm sure you are used to the code now let's
execute that and we get nine minus seven J. So you know how to do this with pencil and paper, please
watch those videos. In case you can't remember how to do this multiplication, you don't have to really
do it with pencil and paper. Of course, you just come here in Python and you just do it very, very
simple. Now let's use the c math module. Now that's a module built into Python, but you have to
import it into the active session. Now you can see the URL there if you want to read more on the
documentation for the c math or complex math module. And the way that I'm going to import it here is just
use the full name. So import space c math. Let's run that. And now everything that's inside of c math
has now been imported into this active session. And I can use everything that is inside of c math
in this notebook. So first of all, we asked to calculate the square root of negative one. Now
there is an sqrt function that lives inside of c math. It does not live inside of base Python. So I
can't just use it sqrt like I use the function complex. I have to tell Python where to find this
function. But default, it's going to look in base Python. Now base Python has many, many functions,
but certainly the sqrt function is not inside of base Python. So the way that we do that in Python
is we're going to give the name of our module c math, and then a dot, you see there's no spaces
here, and then sqrt. We know that it's a function because we see a set of opening and closing
parentheses. And again, we're passing a single argument and the argument is negative one. So
this is the square root, the function square root. It knows what to do. You just have to give it
something to do its job with. And what you give it is the argument and the argument is negative one.
So we want the square root of negative one. We just have to remember that this function sqrt lives
inside the cmath module. And it's because I just did a simple import. I just said import space cmath
that I have to use the word cmath dot square root. So let's execute that and we get the result,
which is i. Of course, in Python speak, that would be one j. Here's an alternative way to do it. I'm
going to say cmath dot sqrt. So that's going to do the square root of a complex number for me. And
instead of saying negative one, I'm using the complex function. Now look at that. I'm using a
function as an argument to another function. Please note that cmath dot sqrt is a function. And you see
the yellow open close parentheses. And then everything I've highlighted, that's the argument for the cmath dot
square root function. And that argument is actually another function. So there's the complex function.
It has its own set of opening closing parentheses, negative one for the real part and zero for the
imaginary part. So that is just the number negative one. And so I'm going to pass that to the square
root function in the cmath module. And again, I get the exact same result because negative one and
complex negative one comma zero, that's just negative one. Now I want to print the complex number to the
screen. That's one plus square root of three times I. Now remember, my real part is one, my imaginary part
is square root of three, that's still a real number, the real part and the imaginary part of a complex
number, they are both real numbers and square root of three is a real number. Now one way I can do it
is using sqrt. Now the sqrt function inside of the cmath module can also do proper square roots,
square roots of non negative numbers, so zero and above any non negative real number. So if I say cmath dot
sqrt three, that's just going to calculate the square root of three. So look now how I'm constructing
my complex number, I'm saying one plus and then the square root of three, using the sqrt function from
the cmath module, so that I can calculate the square root of three, that is my imaginary part times one j,
which remember, it's just my imaginary unit, let's execute that. And now you can see there is a
numerical approximation for the square root of three, 1.732058. So that's not an exact value,
the exact value is written right there in LaTeX. Let me just double click on there. See there's
LaTeX notation, mathematical typesetting. This is not code, well it is LaTeX code, but it's inside of
a text cell. So there's no execution happening here, it's just rendered to the screen. So the square
root of three, that's the exact number. This is a numerical approximation for the square root of
three. So that leaves me with one plus 1.73, many decimal places, i. Now as an alternative,
let's use the complex function. Now I actually prefer to use the complex function. So there we
go, complex, there's my first argument, it is one, that's my real part, and then my imaginary part is
cmath dot square root of three. And so if we print that out to the screen, we're going to get exactly the
same result. We see our numerical approximation for the square root of three times i, which in Python
speak is a j. So let's calculate the argument of phase. Now I'm just going to call it phi or phi,
that's up to you, of one plus the square root of three i. So the argument, or this instance,
we're really talking about the principal argument, or the phase then, remember that's the angle on
the argand plane. Remember that's the real axis and the imaginary axis on that argand plane. So we've
got one on the real axis and square root of three in the imaginary axis. If I were to draw that number,
one plus square root of three i as a vector, that's the angle that we get from the positive real axis
towards that vector. And so let's see how to do that. Now, again, in the cmath module, there is a
function called phase. Now it does not live in base Python, so I can't just use it like I use complex,
I have to tell Python, where did I find this function? Well, it's inside of the cmath module.
So cmath dot phase, and I'm passing one single argument to the phase function. I know it's a function
because I see open, close parentheses, no space between that e and the opening parentheses. That's
a function, and I'm passing an argument to it. And what I'm passing as an argument to it is actually
my complex number, one plus the square root of three times i. So let's execute that. And we see
a numerical approximation for this value. That's actually pi over three, and we can see 1.04719,
etc, just a numerical approximation. We can also calculate the norm or the length. So the length of
that vector as a vector representation of a complex number on the argand plane, or then just the norm
of the complex number, we're going to call that lowercase r. And again, it's of one plus square
root of three i. And now there's a function abs for absolute. Now that abs function, as you can see
there, it lives inside of base Python. It is a recognized keyword in Python. So I can just use it
as is abs, open, close parentheses, that is a function in base Python. And what I'm going to pass this
time, instead of the usual way of creating a complex number, I'm just going to use the complex
function. So this is one comma cmath dot square root three. So the real part one, imagine part
square root of three, I'm passing all of this. Once again, I'm passing a function and its arguments
as an argument to a function, the abs function. So let's execute that. And we see the result is two.
So if we think of Pythagoras, that will just be the length of the hypotenuse, thinking of the complex
number on the argand plane. Now there's another function in the cmath module, that's this polar,
P-O-L-A-R, polar. And now look, as argument, I'm passing my complex number, and I represent my complex
number using the complex function. Now what the polar function is going to do, it's going to return
two things to me, it's going to return both the norm and the principal argument. And that's what we
asked to do. So r and phi, and then we see the norm was two. And there we see that's a numerical
approximation of pi over three, that's the argument, the angle between the positive real axis and the
vector representation of my complex number. Now if I have those two values, now here I have r,
that's my norm, and my principal argument, I can get back to that original complex number. And there's
another function called rect, R-E-C-T, and that stands for rectangular. You can see there it lives
inside of cmath. So it's cmath.rect. Now I'm passing the norm, and some numerical approximation for my
argument, my principal argument. If I hit play now, I can see there is very close to what the complex
number is. Now there's going to be some rounding errors. So I see 1.0000, and then there's, you know,
many zeros and a two. Python's really trying to tell you this was one. And then look at this,
1.732, etc. Remember that was my square root of three. So this is really trying to tell me is one
plus the square root of three i, but we are going to get some rounding errors. That's just the way that
your computer language is going to work. That's using the rect function where I pass the norm and
the principal argument as the two arguments to the rect function. Now let's think of complex numbers
in the four different quadrants of the argand plane. So I'm going to use phase, the phase function,
because I want to know the argument of this complex number negative 1 plus 1i. Now remember negative 1
on the real axis, positive on the imaginary axis. So that's going to be in the second quadrant.
If we use the term quadrants in terms of the argand plane, similar to what we would imagine
the Cartesian plane to look like. So cmath.phase, and now I'm using the complex function again to
represent my complex number. And that whole function and its arguments is passed as an argument to the
phase function. So I'm asking, what is the phase of this complex number negative 1 plus i? Let's
execute that. And we get 2.35. Again, a numerical approximation. It is positive though,
because between 0 and pi, so in the first and second quadrants, we are going to get positive
values for our argument. Now let's look at a complex number that'll be in the third quadrant.
So that's negative 1 minus i. Again, I'm going to represent that number using the complex function,
and I'm passing all of that as an argument to the phase function. Let's execute that. And now we're
going to get negative, because we are going to now go clockwise from the positive real axis,
clockwise all the way around to the negative real axis. And that's the angle that we're looking at.
So negative 2.356 radians. And then in the fourth quadrant, let's take a complex number 1 minus i.
And if I execute that, again, I'm going to get that negative angle for the radians. Now the next
question there is, print a numerical approximation of the number pi. And inside of the cmath module,
there's a couple of constants. And one constant is pi. And you can just see it's cmath.pi. Now there's
no open and close parentheses, because pi is not a function, it's just a symbol. So let's execute
that. And we see again, a numerical approximation for the irrational number pi. Now for the last
question in the section, we asked to calculate e to the power i pi. So we're using some Euler notation
there. E, Euler's number to the power i pi. Now how would I do that? Well, there is an exp function
also inside of cmath. So cmath.exp. And I'm passing, there we go, I am passing 1j, that's the i,
then times cmath.pi. I'm passing that as argument to the exp or exponent function. And look at what
we get. Negative 1. Now we do know e to the power i pi should be negative 1. So there's my negative 1.
Now look at the imaginary part. That is 1.22, etc, times 10 to the power negative 16. That's this
mathematical notation there, e minus 16. That means times 10 to the power negative 16. That e there has
nothing to do with Euler's number. It's just notation for times 10 to the power negative 16.
And so what Python is trying to tell you, well, there's some rounding errors and that is actually
just zero. So negative 1 plus 0i, that's just negative 1. And indeed, we know e to the power i
pi should be negative 1. Now that we know how to use Python and the cmath module to do a bit of
complex arithmetic, let's step it up. We're going to do some symbolic mathematics. And that is what we're
here for. So complex arithmetic using SymPy, that's short for symbolic Python. That's the name of a
package. Now lots of people have worked on and continue to work on this package. It just is full
and full and full of all sorts of symbolic mathematics. That's the mathematics that looks
like your textbook. And that's really what we want. Now I'm going to import from SymPy a couple of
the functions. Now remember I said import cmath and then I always had to say cmath dot then the
function. Now here's another way to do an import. So instead of just importing SymPy saying import
SymPy and then I'll have to say SymPy dot symbols, SymPy dot collect, all those functions. I'm just going
to list all these functions inside of this package that I want to use in this notebook. Now there are
many, many, many, many, many functions and other functionalities inside of the SymPy package.
But this is a very neat way to do things. I'm only importing what I need. And by doing so, I also
don't have to say SymPy dot symbols, SymPy dot collect. I can simply use these names, these reserved
keywords. Remember those are the functions. I can just use them as if they are part of BasePython.
It's a very neat way to do your import. So let's import all of that. Now some of these are functions
and some of these are just symbols. There's pi for pi. Look right there. Now this first
one init underscore printing. It is a function. So there we go. It's got open and close parentheses.
Let's execute that in a code cell. Now what that is going to do, it's going to allow this notebook
to print out the results of my code so that it looks like a mathematical textbook. It's going to do
mathematical typesetting in the results. And that is very unique here to Python. It is fantastic that
you can use Python to look like the mathematics in your textbook. And that's what's going to allow this
notebook to print that mathematical typesetting. So the first thing we want to do here is to print
the imaginary unit i using SymPy. Now I don't have to say SymPy dot and it's an uppercase i because I've
already imported it as such. I didn't just say import SymPy. I said from SymPy import all of these. Now I can
just use it directly. And let's execute that. And look at that beautiful mathematical typesetting that
we see. We see i now. The real mathematical imagining unit. Not a j. It's an i. Now we want
to say calculate i squared. And that's how we define the imagining unit. It is a number such that when we
square that number, we get negative one. So I'm going to say i star star. Now remember double star
symbols. That means to the power. i to the power two. Let's execute that. And we get negative one.
Very nicely done. Now here comes the beauty of SymPy. I can take computer variables. That's what we see
on the left hand side. Then we see an equal symbol. Now that's not a mathematical equal symbol. In
computer languages, the equal symbol is an assignment operator. It looks at what is to its right and then
it assigns it to what is to its left. Now let's see what we're doing on the right. We're using the
symbols function. Now let's go up. We imported the symbols function. There we go. It's right here.
Symbols. It's a function that lives inside of SymPy. But the way that we imported it means we don't
have to say SymPy dot symbols. We can just use it directly. So symbols open close parentheses. It is
a function. It lives inside of the SymPy package. And now here comes two arguments. Here's my first
argument. Comma. There's my second argument. Now my first argument, I see open and close single
quotation marks. Now you can use double or single in Python. It really doesn't matter. So there's my
quotation marks and now I'm putting A space B space C space D space K. Now I put spaces in between but I
could also have used commas. It just looks better with the spaces. So A, B, C, D and K. What I'm
trying to create here is mathematical symbols. The symbol A, the symbol B, the symbol C, the symbol D and
the symbol K like you see it in your textbook. And so I have to put that inside of a set of quotation
marks. Now comma, there's our second argument. Now this is a very special kind of argument. All the
arguments that you've seen up till now are just positional arguments. This function, it's going to
expect that you pass certain arguments to it in a certain order. That means positional arguments.
But there's some arguments that have name and you can really put them anywhere. They don't need to be in
a certain order. But you have to use the name of that argument. And so this argument's name is real
and I'm assigning that a value. Remember equals is assignment. I'm assigning that the value true.
So I want these symbols A, B, C, D and K to be real numbers. Now look at that code there. Isn't that
beautiful? You can almost read it like just an English sentence. Now it's going to create these
mathematical symbols for me. They're all going to be real numbers. Now we are assigning that. So remember
what is to its right. And that's all those symbols that we've just created. Now I'm going to assign
that to computer variables. Now a computer variable is just a little space in your computer's memory.
And you put something in that little space. Now I've got these symbols, mathematical symbols
or variables A, B, C, D, K. Those are, let's call them mathematical variables. Now I've got to put them
inside of a little bit of space in my computer memory. Now to do that, we give that little space
a name. That name is under your control. Now that's within reason. There's all sorts of stuff
you cannot use as a name. You can't use any of these keywords that is reserved for the Python
language. No, no, no. You can't do that. So you have to come up with your own. Now this is very
simple. Why don't we just use the same letter for our computer variable name, the name of our little
space in memory, same name as the symbol. So I'm going to say A, B, C, D, K. Now you have to put
commas on the left-hand side. On the right-hand side of the assignment operator, I'm creating
one, two, three, four, five items. So I better have on the left side, five items as well. And
another thing about Python, which is very beautiful, I could do these one by one. I could say A equals
symbols, A real equals true. Next line, B equals symbols, B real equals true. But in Python, I can do
that all in one go. So I can do multiple assignments here on the left-hand side. And after a while, you'll
get very used to this. So let's execute that. Now I have a bunch of mathematical symbols. They are all
real numbers. And they are assigned to these computer variables that have got a similar letter
name. That's a little space in memory. And so the A, little space in memory, it contains the
mathematical symbol A. And this B, the computer variable B, contains inside of memory, that's the
name of that little piece of memory. It contains a mathematical symbol called B that holds a real
number. So let's print this complex number to the screen, A plus B, I. Now that looks
a lot more like your mathematical textbook. So I'm just going to say A plus B times I. Now
if you try to do this in any other computer language, it's going to give you an error, because
it does not know that A is a mathematical symbol. It wants it to be some number or some other
object, such as a whole string, something like that. But here in symbolic Python, it can actually
hold a mathematical symbol. So let's print this to the screen. This is code. And look
at that beautiful mathematical type setting. Now that comes from the init underscore printing
function. Remember, we called that before. And look at that A plus. Now what Simpi is going
to do, it always puts this I, the imaginary unit before the imaginary part B. So A plus IB
instead of A plus BI. Now that multiplication commutes. So that's not really a problem for us.
Let's do another one. C plus DI. There I have C plus D times I. Now again, remember, you
have to in the code use this multiplication symbol. You can't get away from that. You can't
just say C plus DI. That's going to be an error. So let's execute that. And then we see
C plus ID. Now when we imported from Simpi, one of the functions that we imported was the
RE function. And we also imported the IM function. Now the RE function, that's going to calculate
the real part of a complex number. And the IM function, it's going to return the imaginary
part of a complex number. So let's do that. I'm saying RE, I can use it directly because
of the way that I imported this function from the Simpi package. It is a function. So there's
open, close parentheses. And I'm just going to pass A plus B times I, my complex number.
So let's pass that as argument to the RE function. And it returns for us just the A. Look
at that beautiful mathematical type setting for the A. The IM is going to return the imaginary
part. So let's run that code. And I get the B back. That's the imaginary part of that complex
number. Now let's multiply K, this constant K or the scalar K times this complex number
A plus BI. Now that's very easy to do. I'm going to say K times, there's my times, it's the
star symbol. And then I'm going to put inside of a set of parentheses, just to denote it's always
a safe thing to do that this is my whole one object. This is my complex number A plus B times
I. Now I'm going to multiply that and look at what I get. It was actually not performed.
The mathematical operation was not performed. I just see beautiful typesetting K times A
plus IB. Now, how do I get Simpi to actually execute that? And here we go. Now remember,
if I have a code cell and I have a hashtag symbol, that means that's a code comment, everything
in that line after that symbol. Python's just going to know that. So you can use that to leave
a little message to yourself or to someone else who reads your code. Now you're going to see
something special. Let's look at this code and take it apart. Look at this first section that I'm
highlighting. Inside of a set of parentheses, I am passing that scalar times complex number
multiplication. K times. And then in another set of parentheses, A plus B times I. Now I've
enclosed all of that in the set of parentheses. So that becomes one unit. Then follows a dot
and then follows a function. The expand function. How do I know it's a function? Well, it has open
close parentheses. But hang on a minute. Have we not been using Python in a way that we use the
function name first and then inside of the parentheses we pass the argument? Yes, indeed. That's how we use
Python. But a very special thing inside of Python is this ability to use a function after an object has
already been created. Now everything we create in Python, strictly speaking, is an object. So what
we've done here, look at this code cell here, K times A plus B I, that created an object. That object
was printed to the screen. That's what we can see there. Now there's my object. Once I've created an
object, I can actually use this reverse notation. I create the object first, then I put a full stop,
so that dot, and then the function. Now what Python understands here is apply this function to this
object that already exists. It is as if I'm taking this object and passing it as an argument to that
function. But we do this in this reverse order. And that's a very, very useful thing because we just work
on stuff, we create stuff, and then we think what to do with it. Then we want to apply a function to it. And
when we do it this way, we can refer to this function as a method. It is one of the functions
that is very specific to this object. This object, if I create this object, the scalar times a complex
number, that object can be passed to many, many functions. It's restricted though to those functions.
And one of them is the expand function. And what we do is then we use it in the form of a method. So I
create my object first. Now it's got to be in its own whole set of parentheses so that it is one single
unit, one single object, then the dot, then the expand method, which remember it's now just a
function. So let's do this. And now you can see the distribution has taken place. K times a is ak,
we have commutativity, and k times ib is going to be i times bk, again, commutativity. And that is
fantastic. So not only can I use it just to print out to the screen the actual math that I want,
like, you know, like in your textbook, I can actually execute that mathematics. And the way
that we're going to do it in Simpy is we create the object, and then we use a method after creating
that object. And remember that method is simply a function, and this is the expand function. So let's
add two complex numbers, a plus bi, and we add to that the other complex number, c plus di. And what
I like to do once again here is just put each one of them in their own set of parentheses. It's just,
it's just a safe thing to do. So I've got a plus b times i plus, and instead of parentheses,
c plus d times i. Let's look at that. And now we can see a plus ib plus c plus id. Now,
completely correct, no problem there. But we want to neaten things up a bit. Now there is a function
inside of Simpy, it's called collect. Now when I said from Simpy import, one of the functions that
I imported was the collect function. And so I can just use it straight away. And so there in yellow,
that's its open and closing parentheses. Now this first argument that I'm passing,
that's just the addition of these two complex numbers, as you can see there,
as we had in the line of code before, comma, the second argument of this collect function
is what do I want to collect upon? Well, I want to collect upon i, the imaginary unit. So let's
execute this code so you can see what happens. Now look what it's done. I have an ib plus an id.
Well, I can take the i out as a common factor. There's the i as a common factor. And now I have
b plus d, that addition of b and d, that is now as far as my solution is concerned,
that is now the imaginary part and then a plus c there. Well, that's just the real part of my
solution. Now, I want to just go back a little bit just so that we're sure about something. Now
this collect, I did from Simpy import, and then I had a bunch of functions and constants with commas
in between that I imported from the Simpy package. Now this expand, you would not have found
expand when I did that import. Why didn't I have to do that? Because I'm using it in the form of a
method. And once it's a method, Simpy and Python is very clever. It knows what type of object this is.
It knows it's a complex number. And it knows that expand is a function that I can use in terms of this
object. So I did not have to import expand at all. These methods, they come just as a free gift
for all these objects that we create. Collect, though, I'm using this as a function. And so I
had to import that function. Great. Now, as far as this last addition is concerned, our question is,
does calculate the real and imaginary parts of the last addition? Now, there's my re function. And so
open, close parentheses there in yellow, and we can see we're just passing a plus b times i and add to
that c plus d times i. I'm passing all of that as an argument. I'm using a little code comment there for
myself. And we can see a plus c, that was the real part. And let's look at the imaginary part.
That's the im function, exactly the same thing. And there's the b plus d in the solution. That's
going to be our complex part. So let's do calculate a plus bi times c plus di. I'm multiplying now. Once
again, I'm going to put these inside of parentheses, keep things neat. That is one single complex number,
then times multiplication, that's the star symbol, and then my second complex number. So let's do this.
Now, look at that. It's just going to do the typesetting to the screen. It has not executed
that. It has not done the mathematics. So now how do I get it to do the mathematics? I have to do a
times c, then a times id, then ib times c, then ib times id. Remember how to distribute. Now look at
this wonderful way that we can do. We're going to use another method. So there we go. I've got yellow
parentheses to create one single object. Inside of that object, I am multiplying my two complex numbers,
a plus bi, and c plus di. Outside of that set of yellow parentheses, creating that single object,
which is going to be another complex number. If I multiply a complex number by a complex number,
I'm going to get a complex number. Unless I multiply a complex number by its complex conjugate. That's a
different story. And there's my dot, or full stop. And then I'm using the expand method. I know it's a
method because it is a function. I know it's a function, open, close parentheses, but it's then a
method because it's been applied after the object has been created. So let's do that. And now we can
see that multiplication has taken place. Now once again, I can collect everything on that I, I can
take out I as a common factor. And so now admittedly, it becomes a bit long, but let's, let's just take
this apart. There's my collect function. So inside of my set of yellow parentheses, there's my whole
two arguments. I've got one argument, comma, the second argument. Remember, the second argument is this
common factor that I want to take out. That's the I. My first argument is just the multiplication that
we've just done. The part that I'm highlighting now is just taken copy and paste from the previous
line of code. So I want to take that multiplication that's just taken place because of the expand
method. And I want to take out I as a common factor. And now we can see that's beautiful. Now for
the real part, I have AC minus BD. And for the imaginary part, I have AD plus BC, exactly as I would
expect. Now we asked to calculate the complex conjugate of the complex number A plus BI.
That's how we would write it. Remember, pencil and paper, we put this little bar on top A plus BI.
Remember what we do there, the complex conjugate that takes this imaginary part B and it multiplies
it by negative one. And that's where we have negative B. That's just A minus BI. So we have a
function conjugate. Now if you look back up, when I said from Simpi import, conjugate was one of the
functions that I wanted to import. It is a function because I see open close parentheses. I'm passing my
complex number A plus B times I. And let's take the complex conjugate of that. And lo and behold,
I see A minus BI or A minus IB, exactly as I expect. Now I can also calculate the norm. Remember,
if I represent it as a vector, there'll be the length of that vector on the argant plane. But
before I had to use it just with numbers and I saw the numerical approximation for those numbers.
Now I can see the symbolic mathematics happening. The function that I'm going to use is the ABS.
That's an uppercase A, ABS. And again, that was one of those functions that I did the import on.
I said from Simpi import ABS. Now I can use ABS all on its own. It is a function because we see open
and closed parentheses. And again, I'm passing A plus B times I. Let's pass that to the ABS function.
And it's exactly as we expect. And look at that beautiful mathematical type setting because of
the init underscore printing function. I see the square root of the square of the real part plus the
square of the imaginary part. Isn't that fantastic? Next up, we need to show that the square of the norm.
Now remember that gives me a square root. And if I square square root, I'm just getting rid of the square root.
So show that the square root of the norm of the complex number A plus B I is A plus B I times its complex
conjugate. So let's do that. There I have a set of yellow parentheses. So I'm creating one object.
I'm taking A plus B I. I'm multiplying that by its complex conjugate. A minus B I. And then I'm using the
expand method because I want the actual math to take place. So let's look at that.
And indeed, I get back the A squared plus B squared. As I expect, that's the norm squared.
Now let's calculate some arguments. Remember, if I do a vector on the argand plane, that's the angle
between the positive real axis and counterclockwise on this interval from zero to pi radians.
That's counterclockwise. That's a positive angle. But once I get to quadrant number three and four,
I'm going to go clockwise going from positive real axis clockwise. And I'm going to express that as
negative radians. So let's look at one plus one I. I can just write that as one plus I. I want to look
at the principal argument of that. And indeed, look at this. Now this is fantastic. I do not get back
in symbolic Python. I do not get back a numerical approximation. I get back the exact solution. Pi over
four, a quarter pi. Now that's something very, very special. Now if I want the numerical approximation,
look at what I'm doing now. Look at my set of yellow parentheses. I'm creating a single object.
Take the arg function. And then remember, I didn't speak about that. Arg, again, that was imported
directly from Simpy. One of those functions that I imported was arg. So from Simpy import arg,
A-R-G, that's a lowercase a. That's going to calculate the principal argument for me. So I'm
creating all of that. There's arg, open close parentheses, one plus I. I'm putting all of that
in a set of parentheses so that I can use another method. Now this method is the evalF method,
evaluate method. And I'm passing a single argument before. We've never passed an argument to a
method. I'm passing the argument 10 to it. Now what it's going to do, it's going to give me a
numerical approximation. Let's have a look at that. So instead of getting pi over four, I get a numerical
approximation of pi over four. So let's calculate the argument of negative one plus I. So that's going
to be in the second quadrant of the argand plane. If I do that, I get three quarters pi or three pi over
four. Again, that's going counterclockwise from the positive real axis. So let's do a complex number
in the third quadrant, negative one minus I. Let's see what we get. Well, we're going to get
negative three quarters pi, three quarters times pi, three pi over four. Again, that's got to be
negative because it's going clockwise. It's outside of that interval from zero to pi. We're now beyond
pi going all the way around to two pi. There we measure negative angles going clockwise from the
positive real axis. Let's do the fourth quadrant. We're going to get one minus I and we get negative
pi over four. That is absolutely fantastic. Now remember, I can wrap all of that inside of a set
of parentheses and then use dot eval f and I can pass an argument to that method just to show you
in case I want to use actual constants. Yeah, I have I want the principal argument of three plus four I.
So three plus four times I am using the arg function in some pi and look at what I get. I get the
arg tan of four over three. Now that is exactly what I want. That is an exact value. The arg tan of
four over three. The four comes from the, think of Pythagoras, that is going to come from the imaginary
part. That's the four and the three comes from the real part. Think of a triangle, a right triangle.
Now I can do the numerical approximation for this to 10 significant digits. So let's do eval f 10. Let me
just show you. Remember I'm using those yellow parentheses as you can see there. Now the color, it's not me
choosing the color. That's just the way that this notebook is rendered with a dark theme. And I can
see 0.927295218. That's nine decimal places. That's 10 significant digits. Great stuff. The last
thing. Now we've done it before and we've got that numerical approximation. Let's use some pi.
E to the power i pi. That should give me a negative one. Now this exp function, I imported that. I said
from some pi import exp. So I can just use it directly. This is not the same exp function that we have
inside of the cmath module. This is exp inside of the some pi package. I just have to be very
careful there. Let's execute this. And now I get a beautiful value back. There's no numerical
approximation. That is indeed negative one. And that is absolutely fantastic. So I hope you've enjoyed
this introduction to using complex numbers and complex arithmetic inside of Python. What I really
want you to concentrate on is some pi. We're going to use some pi throughout much of this course just to do
our work. But we will also get back to numerical approximation. We cannot always use symbolic math.
Then we're going to introduce another package and that is the numpy or numerical Python package.
