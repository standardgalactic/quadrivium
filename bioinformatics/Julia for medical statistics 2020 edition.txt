So a couple of years ago I made a video on Julia for medical statistics, quite a successful video.
I think it's got around about 12,000 views now and because people are interested in that now,
it's a couple of years down the line, short couple of years, and we had version 1.4 and I think that
was still done in 0.4 so many things have changed and Julia's really grown up. It is a phenomenal
language for scientific computing, solves so many problems in such an easy way and there's a big
community now and there's also a big package ecosystem. So it was time to redo this video.
The video is still going to be about showcasing Julia, how to use Julia to do medical statistics.
What we're going to do this time around though, we're going to base it on a paper,
so an open paper, I'll put the link down below, and we're just going to use some of the summary
statistics to simulate some new data and that's the data that we're going to analyze. So I'll show
you how that works, how to use distributions just to create and simulate your own data.
Then we're going to go through summary statistics and plotting. You've got to visualize your data
and I'm going to show you a plotting library called GatFly and it really produces beautiful plots.
And then we're going to check for the assumptions for the use of parametric tests and then do one
or two inferential tests. Lastly, just again to showcase the ease of the use of the language,
what it can do, we're just going to hand code a chi-squared test for independence. Now as I mentioned,
Julia has really grown up. A lot of people are using it, the community is just getting larger
and larger. Currently, I'm working on a course and as soon as that one's done, I'll pop that link
down below. So maybe by the time you watch this, that link will be up. An introductory course and
just teaching you how to do Julia from the ground up, whether you've programmed before, maybe a bit
of R, maybe a bit of Python, or if you've never coded at all, just to show you how easy it is to learn a
programming language. And if you're going to learn how to use one, it might as well be Julia. It really
is going places. And if you can code in Julia, you can basically code in Python as well and you can
code in R. And there's really no use just to code in one language. You've got to know a couple of them.
It really makes life interesting and makes your work a lot more fun. Start with Julia though, why not?
Now though, let's look at Julia using medical statistics.
And so we start off with the Julia language website. It's julialang.org. Lots of information
here. You can learn about Julia all you like in the documentation. I am going to tell you that the
documentation is on the technical side. So at least when you start, it is a little bit of a struggle.
Of course, to download and install Julia, we can just click on the Downloads button and we can see
when I made this recording, the current stable release was 1.4.1. That's what we're going to use.
And that was released on April the 14th. There's also a long-term support release if that's what you
want to stick to. And you can see we have Windows, Mac OS and all the Linux libraries. And then for some
of them, 32-bit and 64-bit, you will know what to install. For Windows, go for 64-bit. Mac OS,
you're only going to get the 64-bit. And then with Linux, the 64-bit would just be the norm most
computers and operating systems are 64-bit these days. When you've installed Julia though, that is
only going to be available to you in the REPL. So that is your terminal, your command prompt. And so
you can just write little lines of code that get executed. What you do need is a graphical user
interface. And the best one to use at the moment is Atom. And there we go, Atom.io. When you go on
the Atom website, it should recognize your operating system. It says that I'm on Windows here and we can
download and install that. If Julia was installed properly, once you've downloaded it, just accept
all the defaults. It should be in your environment variables or in your path. That means your computer
knows where to find Julia when you want to start using it. And when you install Atom, it should pick
up where Julia is if you install Julia inside of Atom. So Atom is a general purpose coding environment,
an IDE. And you can code or use a lot of languages inside of Atom. Let me just open Atom for you there.
There we go. That's Atom. And you can see right at the top there it says Juno. That means Julia was
already installed to work inside of Atom. And I'll show you how to go about that. Two ways that you
could go about that. The best way or the easiest way I should say is just to go to Julia Computing.
So not julialang.org but juliacomputing.com. Commercial arm of Julia. You can find out all about
what they have to offer. But what you want to do is go down here and look at Julia Pro. Let's click on
Read More. And there you can download Julia Pro free of charge. And you can see there they've got
1.0.5.2 the long term release there but also the current stable release 1.4.1-1. And again you can
just download those. Might ask you to register. It's all free of charge. And you can go ahead and
download that. What that is going to do for you it's going to install Atom as we can see here. You're
going to see Atom and Julia's already connected to it. If you do the julialang separately and Atom
separately you can always come to the settings page. And you'll see for me that was control comma or
command comma. And you'll see packages there. It'll list all the packages that were installed. And you
can see Julia client was already installed. Julia language already installed. What you would have to
search for is Uber. That's U-B-E-R Juno. If you search for that package and install that that's
going to install everything for you. If everything worked well you installed Julia properly. You
installed Atom as we've done here. You should have Juno there when you restart. You can go down to
settings and you can set all sorts of things as far as the Julia client specifically is concerned.
You can see there's some Julia options, the UI options, etc. Atom itself has built in themes as
well. So you can go for a light theme or a dark theme. Let's close this all off. What I've got here
on the left hand side is just a project pane. In other words I went to file and add project folder
because the files that I want to work in they're all in a specific folder. And that also allows you to
connect your code on a GitHub repository. And you can just continuously upload to GitHub.
What you see here down at the bottom is a terminal. And you can run the Julia in the form of a REPL
right here. So if I click enter or return there we can see Julia's launch there. And when you install
just base Julia, just Julia without anything else, without an IDE, this is what you're going to see.
And I can just write in, type some code there, two plus two, hit enter, and we're going to see four.
In the middle here is where we see the coding environment itself. And you see I've got a file
open, julia4medicalstatistics.jl. And that's what we're going to work with. On the right hand side,
there's the workspace. It's going to show me my current workspace, the computer variables that I've
created, and the objects that are assigned to them. You get full documentation here. So you can search
the documentation. Of course, you can just go on the website as well. And we're going to have inline plots.
So what I like to do is I'm just going to grab the REPL here. And I'm going to move it right up
there next to workspace. So it makes that little blue mark there, drop it there. Now it's on the
right hand side for me. I can also just close down this side. And we've got a lot more space
to work with because some of the lines of code are quite, quite long. As with Python, we see that
we can use the hashtag symbol or pound symbol on the left hand side of every line of code. And that
means that whole line of code will just be ignored by Julia. It won't ignore that. And inside of an IDE
such as this, you can just use these comments just to write some comments. And when you download this
file, you can see the comments that I've made. It'll tell you a little bit about Julia, about
its type system, about multiple dispatch, why it's so fast, why it is such a lovely language to use.
Basically, it comes down to it is as simple as Python, but it runs along the sort of speeds that
you can expect of other compiled languages like C, because that's exactly what Julia is. It's a
compiled language. So when you enter some code, it gets compiled for your, for your computer, for your
CPU. In other words, the code is going to execute very fast. It's just in time compiling. So it goes
to a low level virtual machine, and that is going to compile the code for your system, bringing you that
speed. One more thing that I want to say about Julia before we start everything in Julia is a
function functions. It's a functional language. In other words, you saw me type two plus two there.
But what's happening behind the scene is there is a plus function in Julia. And you start by typing
the function. And in this instance, it is this plus symbol that is a function. It's the name of a
function. And as with all functions, you pass it some arguments. Not all functions need arguments,
but most functions would need arguments. They are separated by commas if they're positional arguments.
We might talk a little just about keyword arguments, perhaps not in this video, but those would be
follow a semicolon. Here, I'm just passing two arguments to the plus function. It's two and two.
The plus function knows what to do with it. Why? Well, it understands what two and two are. Two and the
other two. Those are both 64-bit integers. By default, 64-bit because this is a 64-bit operating
system. So those are 64-bit integers that I'm passing to this function through multiple dispatch.
They are the plus function will know what to do with integers. And that will be something very
different than doing just that. That's two dot or two dot o. That's a floating point value. It's going
to call a different method for the plus function because it knows what to do with floating point
values. Those are decimal point values. And that's different from integers. But Julia understands what
to do, how to compile the code so that it executes as fast as possible, as optimized as possible for
that function, that plus function to execute. We don't have to tell Julia what type of
variable we do have. So if I say a equals three, I don't have to instantiate that three. That is,
I'm instantiating this object, which is actually an array, a vector at least of a single value.
And that is assigned to the computer variable a. So that's an instance of a 64-bit integer here that
I am passing to. But I didn't have to tell. I didn't have to specify the type of that three. I didn't have
to specify. Julia is going to infer that for me. You can obviously do specify. You can specify the type
and that is going to lead to a better execution. So all that being said, that's not what you're here
for. Let's have a look at what we can do in Julia. Now we are going to use, make use of third party
packages. Most other languages have packages that you can install to greatly expand the functions
that are available to you and what you can do. And you see here, I've just typed a single line
of code here. Import data frames. Let me increase the size. Just one more tick. There we go. That was just
holding down control or command and using my mouse wheel and just increase the size there.
So import data frames. Data frames is a package. That's the name of a package.
And I'm using import there to import. But you can also see down here, I'm importing get fly. But
instead of import, I use using. So there's a difference between those two. There are a few differences.
One of the main differences are that if I want to use some of the functions inside of data frames,
I have to use the data frames, the namespace, the full namespace word there. So data frames dot,
and then a function that lives inside of there. Using for most of them, you don't have to do that.
You just use the function as is. If you're familiar with Python, that would be importing numpy as np,
and then using np.random, for instance. Whereas if you imported from numpy import random,
then you can just use random directly. The reason why I'm going to do this here is I want to show you,
if I show you a function, I want you to know, you to know where it comes from. In many tutorials,
all these packages are just, it's just used with the using keyword. And then functions are used, but
you're not really sure where they come from. So I'm going to restrict myself, myself to import here,
which is not the norm. But just to show you if I use a function from, for instance, from stats base,
that you know that that function comes from stats base. So where did I get all of these extra packages
from? Let's go back to the REPL. I'm just going to delete there. I'm going to hit the right square
bracket. And that brings me into the package management system. And all I have to do is say,
add, and then I could say data frames. And if I hit enter now, the data frames package is going
to be installed. That's a permanent installation, unless I remove it. So it's always there. But the
first time that you start up the IDE, so just to say to get out of that package, I just had to hit
backspace and I'm back. Before I forget, there's also the question mark that brings you into the help
system. If I were to look for the function called SUM, that's all. Look at that. I just get all that
information. I could also go to the documentation, of course, and type in SUM. And I'm going to get
this information as well. So the help system is always there for you. Back to these packages,
you install them there, but you have to import them every time you start the IDE or start the Julia
kernel. Again, you have to import or use the keyword using with ease. And then they're going to be
pre-compiled and that takes some time. So every time you import these packages, it is going to take
time. There is no way to rush this situation. It's not like importing NumPy as NP and it's almost
instantaneous. This has to be compiled. So you can see here at the bottom, pre-compiling data frames.
And you see this little gear icon here. It is doing the pre-compiling and you have to wait for that.
If you want the speed, you've got to wait for the language to compile. And there we go. It didn't
take that long. Let's also import distributions. So the distribution package is going to give me
access to a lot of discrete and continuous distributions. GetFly is a package for plotting
based on the grammar of graphics. If you've used ggplot2 before, it should not be too difficult for
you to pick up getFly. So renders very beautiful plots and certainly go to the getFly website and
have a look around. It is just phenomenal, the type of plots that you can create. And of course,
we're going to create the plots in this tutorial. So let's do getFly. It's going to take a little bit
longer to pre-compile. It's a large package and it's going to take a bit of time. I'll continue
talking about the hypothesis tests. That's going to give us access to a lot of statistical
tests for inference. So we're going to get our t-tests, f-tests, etc. that is going to be available for us.
Not all inferential statistic tests are available. Have a look at their website. For instance,
as I mentioned in an introduction, we are going to hand code or handwrite some code
to do a chi-square test for independence at the end of this tutorial.
StatsBase is also going to give me access to a bunch of statistical functions
which makes life very easy. It's a very useful package to have. So let's just go back to
hypothesis tests. And you can see I'm doing for getFly and for hypothesis tests, I'm using using.
But for StatsBase, I'm using import. It's just that I want to show you where these,
as I mentioned, where these functions come from. So I'm going to do import, by the way,
to execute these lines of code. I'm just at the end. I can be anywhere inside that line and I'm
holding down shift and I'm hitting enter. Shift and enter or shift and return. And that is going to
going to complete that for me. Let's do statistics. Now statistics and random, they come with Julia.
They built into Julia. But if you want to use the functions inside of those two packages,
you have to import them or use the using statement. CSV, of course, is a package that's
going to help us read CSV files. If you work with spreadsheet software, such as the ubiquitous
Microsoft Excel, never save your files. If you're going to work with data, don't save your files as
Excel spreadsheets. Save them as CSV files, comma separated value files. Makes it much easier to work
with those kinds of files that have stripped away all the fancy things that have been added to the
rendering of your cells inside of Microsoft Excel or some other spreadsheet software. All you want is
the actual data, not its representation as a percentage. If it was captured as a fraction,
you want those values as a fraction. And then lastly, or second from last, we're going to use query.
That's a package to help us query language. And that is very powerful. It's not only for the
dataframes package. I didn't mention the dataframes package right in the beginning. That's going to
allow us to work with the data that we've imported. But the query language on top of that is almost
like a structured query language. It allows us to write queries to interrogate the data. And in the end,
if we're going to do a chi-square test for independence, we've got to have some
contingency tables and the frequency tables or FREQ tables. It's going to allow us just to do those
counts along contingency tables. So let's import that. So what I'm going to do here next is we're
just going to make use of this journal article that you can see here. The link will be down below.
You can read that link. The article itself used an organism in tablet form and randomized some
participants and had a look at the effect that would have on their cholesterol and specifically
HDL cholesterol. They've got beautiful tables in that journal paper. And we're just going to use the
summary that they gave in those tables and just generate some data on our own. That's one of the
beauties of a computer language. Of course, you can generate your own data. So this would not refer
to real life data. This is data that we're going to simulate based on the summary statistics in those
tables. So the first function that we're going to use you see here is random.seed. Open close
parentheses because the seed is the function and I'm just passing in some integer that I decided on 12.
You see the little exclamation mark there. That's the bang symbol. So random.seed bang.
And I'll tell you a little bit more about the bang symbol a bit later.
To seed the seed of random number generator means all these random values that we are going to generate
will be exactly the same if I run this code again. If you run this code, you're going to get exactly
the same seed of random numbers as well. If we don't do that, of course, every time you run this,
you're going to get different random numbers. So the first set of random numbers, let me just execute
that shift enter, shift return. And now if I run these in order, of course, if I go back and rerun
some of these, it'll be different numbers. But if I run these all in order, we should all get the same
random values. So the first random function we're going to deal with is a built in Julia function,
rand. And it's going to take some arguments and return one or more random values.
The first argument here is, these are positional, so you've got to put them in order, is what to
choose from. And this is a unit range, 30 colon 65. Because I don't put a default step size in the
middle, so I could say 30 colon 2 colon 65, that's going to go up in steps of two. If I don't put any
step size, it's just going to use one as a step size. So from 30 to 65, that is a unit range. It's
going to select from those values. How do I know that that's a unit range? Well, let's go to the
REPL here. There is a type of function. And if we were to say 30 to 65, it'll tell us what Julia sees
that as. And it sees that as a unit range of 64-bit integers, just as we suspected. Back here to the
comma. The next positional argument would be 46. I want 46 values back from this interval
of 30 to 65. I want 46 values back. The random is going to give us a uniform distribution
with replacement. So if the age 35 was chosen once, it goes back into the pile
and it can be chosen again. So just a uniform random distribution. Shift enter. And there we see
we have a vector of 64-bit integers with 46 elements. If I twirl down on it, you can see a list of them
there. 46. So in this paper, they had 46 participants, 23 in each arm, taking either the drug itself,
which as I say, which is some organisms or placebo. And we want 46 of them. And we're just going to
randomize from uniform random distribution. Uniform distribution. We're just going to take 46
values. And we're storing that, assigning that. Remember equals sign is an assignment operator
that assigns what is on the right side of it to whatever's on the left. And on the left,
we've generated a computer variable name, age, creating a space in our memory where this object
on the right hand side is stored. I'm going to use snake case for my computer variable names. There
you can see snake case. In other words, it's a word I came up with computer variable, but the words have
got these underscores in between them. It's commonly seen in Julia, although you can use, I suppose,
whatever convention you want. Camel case. It's really up to you. The next one I'm going to generate
is gender. And here I'm going to use the sample function from the stats-based package. And that's
why I used importing. So I have to now write stats-based dot sample. So my first argument is
going to be an array. And it is an array because of the square brackets. An array is a list of elements.
And the two elements I'm going to give it as female and male as strings. And in Julia,
strings go inside of double quotation marks. You can also use single quotes, but that's only
with a single letter. And then it's not a string. It's actually a character type,
not a string type. So there we go. Now in this paper, there was just the binary
allocation of gender. So there was only female or male. Then in the paper, 60% of participants were
female and only 40% were male. So I'm going to add some weights to this random sampling.
So stats-based dot weights is my next function there, weights. And again, I'm passing an array
of 0.6 and 0.4. Of course, that's got a sum to one. And I want 46 of those. And it's a very
expressive language because that's almost like an English sentence that I've written. A sample
for me from this sample space containing two elements, female and male sample with weights.
So that 60% are female and 40% are male. Or at every turn, that's that likelihood of being selected.
There's a 60% likelihood of choosing female and a 40% likelihood of choosing male. And I want 46 of them
as well. So shift enter, shift return. And we see my vector here of strings this time, not 64, but
integers, but strings. So let's tool that down. We say, we see male, female, female, female, male.
And with only 46, of course, it's not going to be completely a 60-40 split. 46 is a small number,
but it's going to be in that order. Now, next up, I'm going to create the group,
this computer variable called group. And now I'm going to use the repeat function.
So for the repeat function, I'm going to pass again something to choose from. In other words,
it's got to be an array, but this array only has one element and I want it repeated 23 times. And
you can guess at what's going to happen here. I'm going to have a vector of strings with 23 elements.
And there we go. Placebo, placebo, placebo, placebo. So what I'm trying to simulate here is I'm just going
to put the 46 patients or participants in that took the placebo. And then I'm going to add 23 of them
that took the active ingredient. So how do I add to the end of an already existing vector or array?
So you'll see it's called a vector here in atom, but if you just ran it in
the REPL here, it'll say array, not vector.
But if we just want to add to the end of that 23, another 23, I'm going to use the append bang
function. So there's append. And now I'll tell you a little bit about the bang,
because you get many functions with and without the bang. What the bang does, or what it does to
this function, it makes the changes permanent. So I'm going to append to the end of these 23 placebo
values. And I'm going to put that inside of the group computer variable, but the changes will be
permanent. Sometimes you don't want those changes permanent. You only want them to happen with the
inside of the for loop or inside of a function, but then you want the original back at the end
without the permanent change. Yeah, I want the permanent change append to the group variable
this repeater. So repeat active 23 times. And if I run this now, now suddenly my vector is 46 elements
long. I've appended to the end of those placebos, those 23 placebos. I've added 23 actives. Great stuff.
So let's close these. There we go. The next one that we're going to go for
is we're going to actually sample from a continuous distribution. So in the paper,
they looked at a lot of variables. I'm not going to simulate all of them here, just a couple of them.
So they looked at HDL cholesterol, high density lipoprotein. That's the good cholesterol before
and after the intervention. So they told us in the paper what the mean and standard deviation was
for the sample values for those variables. Of course, we don't have access to them, but I'm just
going to simulate them based on those parameters for the normal distribution. So I'm going to call
my computer variable HDL underscore cholesterol underscore before. I'm going to use the rand function,
but this time I'm going to not take a unit range. So I don't want this uniform distribution. I actually
want the normal distribution with a mean of 1.24 and a standard deviation of 0.31. So that comes
straight out the paper. So I'm saying use this distribution. So that's distributions dot normal.
So if I said using distributions in the end, you could just have said normal. But because I said import
distributions, we have to say distributions dot normal. As I say, I'm doing this so that you can see
where this normal function comes from. It doesn't just come from Julia or some other package. It comes
from the distributions package. So it's all about just showing you about that fact. So distributions dot
normal from a mean, these oppositional arguments, it's always going to be mean comma standard deviation.
As I said, that comes from the paper and I want 23 of those. So let's do that. And now we've got these 23
elements. And then I want to add another 23. So that was read from the table as far as the placebo group was
concerned. Now I want to add from another distribution according to the summary statistics in their table
for the 23 participants who took the active ingredient. So what do I do? I'm going to append
with a bang because I want that permanent. Append to HDL underscore cholesterol underscore before
from this distribution with a mean of 1.24. And so that was exactly the same there. And 0.29 as far as the
as far as the standard deviation is concerned. So I'm going to add 23 values to that, which means I now have a
46 element vector of those values that we were interested in. So we've simulated that. So it's
correct for all the two groups of participants. Then I'm going to do this a couple of more times.
So I'm going to create an HDL cholesterol after. And again, I'm going to go through the same thing,
random from an all distribution with a mean of 1.4 standard deviation of 0.35. And then I'm going to
append to that some more. So you can have a look at that code. I'm going to run through it very quickly
because it's just a repeat of what we've done before. So there's a wait before and a wait after,
diastolic blood pressure before, diastolic blood pressure before, and diastolic blood pressure after.
So I'm just going to run quickly through all of these, just create them from the distribution as per the
parameters in the table. So let me run through all of those. Done. So that would be one way to go
about it. Let's just show you something else. And the reason why I'm doing that is just to show you
how a for loop would work inside of Julia. So we have BMI underscore before, and I'm passing to that
an empty array and an empty array is just the two square brackets, open, close square brackets. It's a
vector. And now you see the type is any. The type here is any. Now I just want to stop there a little
bit because I want to tell you just about the Julia type hierarchy. Everything is a type in Julia.
So if I say, what is the type of, so I'm typing in the REPL on the right hand side here. What is the type of
just three? Well, it's a 64-bit integer. What is the type of three dot zero? So I'm just say three dot.
Julia knows it's a zero. So if I enter that, we see it's a 64-bit float. And these are abstract
types and you can instantiate an abstract type. What that means is I can create a computer variable
and I can assign three to it. That would be an instance of a 64-bit floating type. If I asked what
the type of and let's make a three comma three, but I'm passing these inside of square brackets.
So that is actually an array. And if we look at that, indeed on this side, it'll say array on
and the IDE, it'll call it a vector. Same thing. So it's an array of 64-bit integers and it's a rank one
tensor. In other words, it is in mathematical speak, it is a real column vector.
And again, the 64-bit integers for us here or the array that we see here, that is a concrete type.
I can create an instance of that type, but I can also look up the hierarchy. So let's see what the
super type is. Super type is my function. What is the super type of array? Well, in this instance,
it has a super type of dense array. Let's go up and say, what is the super type of dense array?
Well, that's an abstract array. Okay. Let's go further up.
Let's see what the super type then is of an abstract array. And that's any. So any is right at the top of
right at the top of this type hierarchy. And it's like a branch is going down on all sides.
You get all sorts of types. So any will have many, many, many, many types. But I can look at all the
subtypes, for instance, what are the subtypes of, let's make it number. So number is some way up a
different branch of the trees. So let's look at the subtypes of number. And we see it has two subtypes,
complex and real. So complex is actually a concrete type. In other words, I can create an instance of
complex real on the other hand, continues to branch out. So I cannot make, I can't instantiate real.
I've got to go all the way down to say integer or float 64 down that hierarchy tree. And if you're
interested in that, Google it, it'll give you, you'll quickly find this whole tree structure.
Anyway, back to our for loop, which is what I wanted to show you. So 4i equals 1 to 46. Again,
remember, that would be a unit range. So I just put in 1 to 46. And it's going to go from 1 to 3,
loop through all those values because I didn't put a step size. So I could have said something like this,
that would, that would have jumped 1 to 3 to 5, etc. But if I don't put anything there,
it'll be exactly the same as doing this. I'm just going to go from 1 to 46. And I'm doing steps of 1.
So 1 to 46, do the following. When you're at the end of the line there and you hit return or enter,
it's going to create this blank space for you. And that helps us here with seeing what the flow
is going to be. A for loop is always ended with an end. So you've always got to have the end there.
So what am I going to do here? I'm going to create two random numbers.
And the first one is going to be stored in placebo underscore BMI underscore before.
And the next one is going to be stored in active underscore BMI underscore before.
And what are these two values? Well, both of them are the RAND function. Both come from a normal
distribution, but you see there's slight difference in the mean and standard deviation from which those
are going to be selected. And I haven't said comma, I want five of them. No, no, no. I just leave that blank
because I just want a single one of them. So just give me one random value back from that distribution.
Store that in this placebo computer variable. Give me a random value from this normal distribution.
Store that there. So I've got these two values now, while I is still one. And I'm going to use
the push bang function. And I'm going to push to BMI underscore before. There's BMI underscore before.
It's empty at the moment. But now I'm going to push a single value to it.
What am I going to pass to it? Well, that comes after the comma.
And what I want to do is to assign based on what is inside of group.
So let's have a look at group again. I'm just going to show you here on the right hand side.
So there's group and you can see it's the 23 placebos and then 23 active.
But I can index that. I can say, what is group? What is in position number four?
Seeing that this is just a column vector. This is going to go from one to 46.
Of course, that was going to be placebo. So instead of giving it a number,
specifically what is inside number four, I'm saying, what is inside number I?
Because every time we loop through this, I was going to be one, then two, then three,
then four, then five, then six, et cetera, until 46. So it's going to iterate through all of them.
And now it says, is this equal equal to placebo? Double equal sign is a Boolean question.
It's going to return a true or false. So it's the one I'm looking at at the moment.
So let's just look at what group one, we all know what group one is. It's going to say placebo.
If this is placebo, then you see a little question mark and then give me back the placebo value that
was stored there. Else after the colon, give me the active value back. And that means I can assign
based on what is inside that group value. And what we see here is called a ternary operator.
Let me do this for you here. So we can say two is less than five. And then question mark,
you've got to put these spaces. So yes. And it's not a comma, but a colon. No. And those are strings.
You can put in anything you like. Of course it is. If we now say two is greater than or equal to five.
And then yes.
Yes. And you've got to have those spaces there. No. Of course, we're going to get back. No.
So it's just a very shortened version of an if else statement in case you were wondering.
So that's all we're doing here. We're saying we read that value. And then we're going to assign
one of those two values based on what we see in the group value. We're going to push that
into this BMI. So let's do that. And now if we have BMI BMI before,
I'm going to get taken from the right distribution for all of those 46 values.
And then we're going to run through the same for loop there. Now I've just created a bunch of random
values, random variables there. We've got our data point values. Now we're going to store them
inside of a data frame. So I told you about the data frames package. That's an excellent package
just to work with data. So if you're going to import a CSV file, comma separated value files,
you're going to use CSV.read. And then it's going to be stored as a data frame. If you're familiar with
R, that would be like R data frames, or in Python, that would be like pandas. So I see an open there,
open and close set of parentheses there. So these are all arguments that I'm passing to the data frame
function. And what we can do there is give a name of our variable. So think about it in a spreadsheet
file. That will be row number one, all the column headers. And look at them here. They are just
passed as normal words without spaces in between or other illegal characters, but they're not strings.
I'm not passing them in a strings just like that. So I'm going to have ID. Here I'm going to use the
range function from one comma stop equals 46. So it's going to go from one to 46. That's another way
to create this iterator. Age with an uppercase A. That's going to be my variable name inside
my statistical variable name inside my data frame. I'm passing that the age computer variable.
And I go all along all these ones that we've created, except here for cholesterol,
HDL cholesterol delta. And to that, I'm going to assign an operation I'm going to do on two of these
variables that we have created. We've created HDL underscore cholesterol underscore before,
and we've created HDL underscore cholesterol underscore after. And I want this column
to be the difference between those two, hence the name I've chosen. And all I'm going to do,
I'm going to do element wise subtraction. Remember, this one has 46 elements in it. This one has 46
elements in it. And I want to do element wise subtraction. In Julia, that means the minus sign,
but we have to put this dot in front. So dot minus, and that indicates in Julia that we want element
wise operation. So take those pairs of values, subtract them from each other. And then we see all
the others, you see, I've done a weight delta as well. So dot minus. So the difference between those
two vectors element wise, and you see for BMI, I didn't create a delta because I'm going to show
you how to do that just with code. So shift enter, shift return. And now we have a data frame. We can
see a 46 by 15. So 46 subjects there across 15 variables, and there's not enough space. So it's
going to emit some of them, but there's my data frame. And you can see it is like a spreadsheet file.
There I have my column headers, row, ID, age, gender, group, HDL before, et cetera. But just below that,
Julia tells us what the type is of these elements. So what is the type of this? Well,
there's 64 bit integers here, another 64 bit integers, and then strings, strings, 64 bit floats.
Now, sometimes you want to deal with these things, not as, not as strings, but as categorical
variables. And there's a data frames dot categorical bang function. And if I pass it, the data frame
and then the column header, and it's going to change that permanently because this is a bang
from a string into a categorical type. And what you have to notice here is this colon in front of
group. Data frames allow us to use the group name, the column names as symbols. And that is a symbol.
Once there is this colon in front, that's a symbol. And that is the notation that we're going to use when
we want to refer to the columns inside of a data frame. So remember that we've got to use that
symbol notation. So I'm just changing the group and the gender. I'm going to change them to, if we have
a look at them now, you'll see gender is now categorical type, not a string type anymore. And
there are advantages to that. Next up, I'm going to show you how we get access to only certain parts
of the data, because if you start analyzing data, you don't want to see all the data in the data frame,
you want to narrow it down looking at something specific. So I'm going to start off with by just
looking at the ways to slice a data frame. So remember when we said group, when we had group,
we just looked at the first value in there. And that was placebo. But indexing, I used index notation
here, and that's inside of square brackets. That's exactly what we're going to do here.
But here with the data frames, we have rows and columns. It is a, you can think of it as a rank
two tensor. We have rows and columns, not only values down a single column. So we've got to refer
to, as you do with a spreadsheet file, give the cells row and column address. So here we're going
to use a unit range, one to three. So that's going to give me one and two and three. So rows one,
rows two, rows three, comma, this here, if I just use the colon symbol, that shorthand will give me
all of the columns. So rows one, two and three, all the columns, please. So let's have a look at that.
I get indeed three rows across all 15 of the columns. So only the first three rows there
across all the columns. Now let's just ask for a single column. So still rows one, two and three,
but only of the age column, please. And look again, I'm using symbol notation. So there we go.
Unit, it's a vector of 64 bit integers, and there's only three elements in it, because we've only asked for
three elements. If I want to use more than one column, I've got to pass them as an array.
So they're going to go inside of square brackets. And I want the group column and the age column
still only rows one to three. So let's do that. Now I have a three by two data frame object,
and I have the group and the age as I've asked for in that order. And I see the first three rows
for those. What if I only want rows one and three, not one, two, three. So I've got to put that inside
of square brackets because this becomes an array, an array of rows, only one row one, only one row three,
comma, an array of all the columns that I want. And now I'm just going to get this two by two data frame,
only rows one and rows three, and only for those two columns. Now, if I want to see all of the,
remember I said up here, we use colon as our shorthand for give me all, just make a note of
it's becoming more prevalent just to use the exclamation mark when you want to refer to all
the rows. So the data frame object, give me all the rows and then just the age column. And I'm asking
a Boolean question there, would that be the same as using this notation? Am I going to get back
exactly the same thing? And the answer is true. So I could use either of those two notations.
Now we're going to pass a rule. We only want the data frame back all the columns,
but, so we're going to see all the columns, but go down the age column and only return those that have
an age of more than 50. So how do we go about that? So I want to see the whole data frame with all my
variables, but I only want to see it for participants who are older than 50 years of age.
So this is what we're going to do. We have this very nice dot notation. So if I say df.age,
let's do that here in the REPL, df.age. And now it's just going to give me back this 46 element array
or a vector of these 46 values. So df.age, it's a shorthand. Otherwise I could have written df
like we've done up here. And here I would say, give me all the rows only of the age,
exactly the same thing, but shorthand, I can just refer to it as df.age. It's just going to give me
back this array. And you can see there, the return is not a data frame. It is an array that we get back.
So go down each of them and see if they're greater than 50. So the dot greater than again,
that means it's going to go element wise. So it goes down every one. Is it more than 50? False.
It's not more than 50. This first one, that row is now not included. Next one, 35. It's not more than
50. It's not included. And let's go down now. And this would be the first row that gets included
because this participant was older than 50, comma, all the columns. So that's very nice notation. And you see
we're down to 18 participants now. And if we go down the age column, they're all going to be
older than 50. Simple as that. Now, maybe I want to string more of these together. Now,
I only want participants that were older than 50 and they were in the placebo group.
So how are we going to go about this? Again, it's my data frame, rows, comma, columns. So there's my
comma. I want all the columns there, but let's look at what rows I want.
Well, I'm going to put these inside our parentheses. So I've got these two rules that I want.
So one df.h dot greater than. So element wise, 50 dot and, and that's the symbol for and. So both of
these have got to be true before we get a true back. So we just have normal logic here. So it is dot
dot and, and we want the df.group to be dot equals equals placebo. So row by row. And all these things
have to be true before we, we get that row included. Now we're down to 10 and they are all going to be
over 50 and they're all going to be in the placebo group. So you can see how easy it is just to manipulate
the data to get something very specific back. That means I can also create new data frames,
sub data frames from the full set. So I'm going to call mine placebo and intervention. And I want to
split the participants up into two very separate data frames. Very easy to do. Call the data frame,
address the rows by df.group dot equals equals placebo comma all the columns. So in this new data frame
only has 23 participants in it, but they're all going to be in the placebo as far as the group is
concerned. And I'm going to do the same. I'm going to call that one intervention. And of course in the
group, it's only going to be the active participants taking the active intervention. I promised to show
you that I had to do this with a data frames code. I should have said this difference between. So if
you want to create a new column, I have to create it this way. So there's df, square bracket notation,
and then by symbol name. So if we scroll back up, when I created this data frame, I did not use symbol
notation here, but when I want to add a new column, I use symbol notation. So create this new column.
And that is going to be the difference, the element wise difference between these two
arrays. And the first array is df underscore BMI before dot minus to indicate that it's element wise
df dot BMI after. So that is going to allow me to have this new column in my data frame.
We see that I now have 16 columns.
Now I want to show you a little bit about the query language. What I want to show you actually is just
that it exists because it is phenomenal and it is vast for you to start taking or selecting and
changing, manipulating only a part of your data. So I'm going to show you just a couple of examples
here, but that is many, many, many lectures worth of things you can do. So I'm going to start with my
data frame and then I have this pipe operator. So that will just be the up down stroke on your keyboard,
or my keyboard that's above my enter. So I hit shift and the key above, it'll be different for
your keyboard, I'm sure. And that says take data frame and pipe it into what comes next.
And here I'm using, I suppose, the generic form of the query package. So I'm going to start a query
and we're using a macro here. So in Julia, it makes use of macros like this. And what a macro would do,
a macro actually generates code. So instead of us writing out the long code,
the macros, we can create macros that actually generate code and then that code gets executed.
So it's a very nice way to write the succinct, just the sort of a function there, a macro that'll
generate code and do something for us. But this is built, this at query macro is built into the query
package. So I'm going to say, what query do I want to want to have? So I'm going to create this
variable called i. Now it's another thing we haven't spoken about and that's local variables and global
variables. Let's do that. Here I've created a variable name and I've assigned some object to it.
This placebo exists in a global space, in the global space. In other words, I can make use of it
any time. It exists and its value exists everywhere. Inside of a for loop, as we did before, we created
some computer variables, but those only will have a local scope. Outside of that for loop, they don't
exist and I can't refer to them again. They're not permanent. They're not in the global scope.
So here we have query i and then begin and to every beginning, there's an end here. And then I'm going
to use other macros. At where i.age is greater than 50. So what's happening here? This pipe operator
piped df into this query and it was put into this query right there with the i. So I'm piping df into i.
So when I say i.age, I'm actually saying df.age. It's just being piped into this i here.
So where the age is greater than 50, then at select, and I'm passing these inside of a set of curly
braces, i.htlcholesterol before and i.htlcholesterol after. So it's going to select only those two columns
for only participants older than 40. And then end my begin, then my end, close my query
parentheses there and pipe that into something. And I want that to be piped into a data frame object.
But because we only used import data frames, I've got to say data frames dot data frame.
So if I run all of that, lo and behold, I get this back. Only those two columns that I asked for,
so df dot htlcholesterol before and htlcholesterol after. And it's only going to be for people who are
older than 50. So this is just a quick look at what the query language can do for you. Now I could have
done that much simpler before, but this complexity allows me to become very specific. And there are
more macros than just these. Before I get to the next macro, I just want to show you this.
Many times when we collect data, we try to protect patient confidentiality. And in a very simple
example, what we might do as researchers beforehand, we're going to just subtract in our heads
two. So for instance, it's the value two from everyone's age. So if someone was really 50,
I'm going to capture 48 as the age. No one outside of the study knows that. So if someone got hold of
that data, it's just a little bit more difficult to bring that back to an actual human being. So that's
a very simplified example. It won't really, it won't work in the real world. You'll have to be much more
inventive than that. And there are ways to do this. But if I want to change something permanently,
so df.age, I'm now saying assign that to df.age dot plus two. So that's going to add two to everyone's
age. And if you capture data in that way, where you changed it before you analyze the data, of course,
you want to change that back. So that would just be the way to do that. Here we are back with the
query package. So I'm going to pipe data frame into this at filter macro. And we've done this one
before. I only want the ages back and whether on the placebo group, this would be the way to do that.
We saw that before, but this is way to do it with queries. So pipe df into this. And instead of i,
we have this underscore here. So df is going to go in place of those underscore,
but I'm using at filter. So I want ages greater than 50 and group equal to placebo. Note the
differences though. There's no at before that. And I'm using the double ampersand.
And then, so you've got to read the notation on the query package, and I'm piping that into a data
frame. So what we're going to get back is this data frame of all the columns, but we're only going to
have participants older than 50 again and only in the placebo group. One more way just to use the
query. I just wanted to show you that. I'm going to pipe df into the at group. So I want to group by
df.group because this df was piped into this placeholder and then the at map query.
And I want two column headers. My first one is going to be called key and my second one is going to be
called count. And to the key, I want the key function inside of query. And you'll see just
in a while what that means. And then in the count column, I want length. Length is a Julia function.
And that is going to just count how many things they are. So let's have a look at what happened here.
So I've created a data frame because I piped this all into a data frame.
And I have two columns. One is called key. That was my selection there. And one is called count there.
Key, this key function, what it did to this placeholder because this was all piped.
So let's just look at this piping. df was piped into the group by. So this now becomes df.group.
df.group. That got piped into all of this. So this is now df.group.
So it's key of df.group. And that's what pipe, we've got beautiful versions of that in our programming
language for statistical analysis. Same sort of thing. You have, you build this pipeline of execution.
So this df was piped into this placeholder. Now the whole lot was piped into this placeholder. So
this becomes df.group. And the key of that is going to return for you the sample space elements. What
are all the unique elements that were found in that column? So in the group, in the df.group column,
there was only two sample space elements, placebo and active. And that's what it's going to give me
back. But in the second one, I want to count how many times it occurred. So this is a way to count
the occurrences of your sample space elements of a variable. And there we can see we had 23 with
placebo and 23 with active exactly as we designed it. Great. Let's do some summary statistics.
The describe function is very, very useful.
So it comes from the stats-based package. So if you just see describe there, you wouldn't know
where it comes from, but I said import stats-based. So I've got to say stats-based.describe.
And what I want to describe is from the df data frame, take all the rows for me in the age column.
Remember there are different ways to write this. I could have just said df.age. Anyway,
let's execute this. And the result is just a tick mark because it's executed here in the REPL.
So it says there were 46 values. There were no missing values. The mean was 46.93. The minimum,
the first quartile, the median, the third quartile, and the maximum value. They were all there,
and they were all 64-bit integers. So a nice descriptive statistics here of that column.
There's also the summary stats, the summary stats function. It's going to do exactly the same,
but it's going to return it for me here in the REPL. So I can pull down and see those results here.
And then the statistics package, that is one of the built-in Julia packages. You don't have to
install that. Remember how to install. Go here, right square bracket, type add space and add what
you want to add, and then import it with import or using. So statistics.median. So this is going to
give me back the same value as we had before the 48. There's the median there. It was 48 indeed. No
problem. One thing you won't see here is the standard deviation, but there's a statistics.std that
gives you back the sample standard deviation. And if you read the documentation there, you can also
ask for the population standard deviation.
It has a mean and standard deviation, mean underscore and underscore std. That's a function
inside of stats base. And that's going to give me back a tuple. A tuple is different from an array.
Instead of square brackets, we see parentheses. And by the way, tuples are immutable. So you can't
change their values as you can with arrays, but that's a story for a different day. We get back the mean
and the standard deviation. Variants, of course, it's just .var. Again, there is another argument
that you can pass that gives you back the population variance. This would be the sample variance.
There's a statistics.quantile function, and you can ask for what percentiles you actually want. I want
the 25th and the 75th. That gives me the first and the third quartile values. And you can see for age,
those are the ones we saw there, 40 and 55. In stats base, not inside of statistics,
but inside of stats base, there's an IQR that is going to give us the interquantile range.
But I can also do that with code. Let me just go to the front of this. I can say statistics.quantile
the 75th minus statistics.quantile the 25th. And if I execute that, I'm also going to get back 15,
because that's what the interquantile range is, the difference between the third and the first
quartile. Span, stats base.span, that's going to give you the full range, so the minimum and the
maximum value. And remember, initially we chose it from 30 to 65, but we added two to each,
one of the participants' age. So now we see the youngest was 32, the oldest was 67.
Now, this is a bit of a convoluted one I want to show you here,
and the describe function. What if you don't want everything back? So I'm saying here,
df, all the rows, comma, only these columns. But this describe function can take back,
can take as arguments some things that we want to create. What do we want to create? Well,
that comes after the next comma. Create a symbol for me, that's a column header with a name,
AVE, and attach to that, and we have to use this arrow notation, so that's equal, greater than,
stats base.mean, another symbol, std, and attach to that, stats base.std. So that becomes quite
convoluted and it takes a while for you to get behind what is exactly how to do that and remember
how to do that. But that gave me the age and the cholesterol delta, and it gave me the average
of each of those and the standard deviation for each of those. So that would be another way to go
about this. And what you can start to see here, what's developing here is the fact that there's just
so many ways to do things in Julia. There's the unique function in Julia, and I'm telling it go
down the group column, all the ones, and just give me back what is unique. Well, we know it's going to
be placebo and active, so we're going to get back just the sample space elements. I could do it with
query language. Also, I could say pipe df into the at group by, so this is going to become df.group,
pipe that into this map at map macro, and all I want is a key, and pipe that into a data frame.
And now I'm going to get exactly this, what I got back here with the unique. Instead of getting back
just an array, I actually pipe this into a data frame. So I'm going to get my sample space elements
there. There's a stats base dot count map function. So not only is it going to give me back the unique
values, but it's also going to count how many there are. And again, I see active and placebo,
but I can also do this just with a query language. So I'm piping df into group by,
so df.group, that gets piped into the map. The key, so df.group, the key of that,
so that's the sample space elements, and the length is going to count all of them. And you know exactly
what we're going to get here. This is what we had before. We're going to get placebo and active,
and their counts. So, so many ways. Whatever pleases you, you choose that way.
One more thing. Let's do the median. And we do only of people who are older than, participants
who are older than 50 in the placebo group. And then I can use another set of indices here. And
that is only give me back the median of the ages then. So what we've done here is the median of the
age of participants in the placebo group that were older than 40, the older than 50. So this is a
different notation to do this first, and then what you actually want.
So hang on to that notation. It is sometimes easier to use. Sometimes it's much easier just to use
some of these macros inside of the query language. We can construct our own functions. And that's one
of the beautiful things of Julia. Construct your own function. So I see the function keyword there.
Tell Julia I want to create a function. The name of my function. I decided on that. And it's going to
take a single positional argument, x. And it's going to return for me the following.
Statistics.mean of whatever I pass in, comma, statistics.std of whatever I pass in.
End. We always have to have an end. And now I have a new function, means and standard deviation. As you
can see here, it is a new function. And now I'm going to pass an array to it, df.age, into that function.
And so that takes the place of all the x's. I'm getting back the mean and the standard deviation
of that. So you can create your own functions too. Let's do this last one before we visualize data.
I'm going to group by group. I'm going to map the key. And then create two column headers, average age,
and standard deviation age. And I'm going to perform those two on it. You can see what is going to be in
that placeholder because df is going to be piped into there. Then that makes a df.group that gets
piped into there, which is also piped into there and there. I think by now you get the meaning of
how to write these pipelines. So I'm going to get placebo and active back. And that gives me the
average age and the standard deviation of the age for those two groups. Very easy to start learning how
start learning how to put these together. Now let's get back. Let's get to one of the exciting
parts. We've summarized our data and we've really summarized it a lot. We've created a lot of other
variables. So please play with them and see what results you can get. That's the only way to learn
is to start playing with these. So get fly. There are other plotting libraries as well. I'm going to
show you get fly here. I like the way the plots look and it's very simple specifically if you know
how to use ggplot. So get fly dot set default plot size. I'm just going to set it for argument's sake
here to fit in here to 800 pixels by 600 pixels. So here's a very simple plot. Remember I said using
get fly so I needn't have said get fly dot set or get fly dot plot. I can just use the plot function
directly. Now get fly. I like get fly. It works very well with data frames. So my first argument is
this data frame. It's the data frame we're passing. On the x-axis I want the group variable. On the y-axis
I want the age. And what geometry do I want? Well geom dot box plot. So I actually want
Julia here to create a box plot for me. There's a couple of guides. One of them is title. So guide
dot title. Give it a title as a string. And then you can also do a theme. So my theme here is going
to be has have a default color midnight blue. There's a bunch of these already built in. You can google
that and see all the theme colors that are built in. And I want to also just make 100 pixels in between
my box plots. As simple as that. I'm going to hit shift and enter. Shift and return. And I'm going to
go make a cup of coffee. Because the first time you create a plot there's a lot of stuff that have
to happen behind the scenes. It has been recognized that this is a bit too long and there's certainly
a lot of work going on behind the scenes and trying to improve this time to first plot in Julia. It is a
known problem. You do wait quite a long time before that first plot is created. So I'm going to go off
and have some coffee. I don't know what you're going to have. I'll see you back in a minute or two.
And there we go. It really wasn't a minute. In my case it was about 10 seconds. It was slightly less
than 10 seconds. So it's not that bad. Anyway that is from the time I stopped talking by the way.
And there we go. I see a beautiful box plot. I see my age on my y-axis. I see the two groups. It
found placebo and active all on its own. And we see the title that we created up there and we see
these beautifully rendered midnight blue box plots. Very nice indeed. You can assign that to a computer
variable because you do get packages and you do get the draw function which can save this
plot that you've assigned to P. Save it to your hard drive as a PNG file, SVG file. Now you might
have to import some other libraries. I think with PNG you'll have to import Cairo C-A-I-R-O uppercase C
package to export to PNG. Otherwise you can just export to SVG. It's scalable vector graphics. And those
are very nice to use in other programs like Inkscape or Adobe Illustrator etc to add a lot more to your plots.
So here I'm going to use plot again. Pass the df. I'm going to have on my x-axis the
changing cholesterol, color by the group. Now this color has nothing to do with color. The color
argument here means split by. So group by the group column, whatever the sample space elements you find
there, give me a geom.density. So this is going to be a density plot of the changing cholesterol before
and after the intervention split by the group variable. And then I've just added a title.
So let's have a look at that. And there we see a beautiful density estimate of the placebo and active
group as far as the change in their cholesterol values were concerned. So if we look at the
these two distributions for our data values. So beautiful density plots there. You can also just
ask for plots that are models. Look at this data frame.
Y-axis is BMI before. Y-axis is HDL cholesterol after. So this is going to be a scatter plot and
indeed I'm calling geom.point. That gives me point markers. So this is a scatter plot of two continuous
random variables. BMI before and HDL cholesterol after. So I'm trying to predict HDL cholesterol after
given an input of BMI before. And I want that done separately for each of my sample space elements in
my group column. So color equals symbol group, geom.point. And then in the layer argument, I'm going to call
the stat.smooth function inside of GATFLY. I want it to be a simple linear model and I want a 95%
confidence interval around my model. And that's going to be a geom.line and the ribbon is the confidence
intervals around that. Then outside of that, I've got a title and a theme. And in my theme, I'm passing
a bit of transparency and I'm making the point size, the markers of the scatter plot quite big with 10
pixels. Let's have a look at the output of this beautiful plot. It's going to take a second or two
again because it's now also creating this linear model behind the scenes. So I'm not even using a
package that does linear modeling. They exist too. GLM being a beautiful example of that. But just inside
of this plotting package, GATFLY, I can do this. And there I can see my two models, both for the placebo
and the active group. I see my markers with a bit of transparency and I see my two linear models
created with a confidence interval around those. That is absolutely fantastic. And those plots are
really beautiful. Let's do some inferential statistics.
Now with inferential statistics, we always start off by describing our data. Now we've already done
that. And the one that I'm going to concentrate on here is just to see what's the difference in HDL
cholesterol before, from that difference mean before and after, but between the two groups.
So I've just, we've just got the subtraction of what the before minus after that gives me one variable.
And I've got that same variable split along one of my categorical variables, which is the group.
So I'm just asking a question. Is there a statistically significant difference
in the change in cholesterol? So my null hypothesis is that there's no difference between those two.
And my alternate hypothesis is that there is a change between the two. So one can be higher than the
other. And I'm using an alpha value of 0.05. So there's my hypothesis. So let's just describe
the placebo group. Remember, we created these two sub dataframes. Let's just go back to the REPL to see
the results. I'm describing HDL cholesterol for my placebo dataframe. So that's another way to go about it.
You needn't use the query to select these. Just create two sub dataframes, one for each of your
groups. And that's what we did in the beginning. So I have my placebo and my intervention group.
And there we can see summary statistics. The mean of the difference was negative 0.1
for the placebo group and negative 0.22 there for the, so there was a bigger decrease in the HDL
cholesterol in the time period before and after the intervention.
We can also just ask for the following. So I'm asking for confidence intervals. So that comes
from the hypothesis tests function package. There's a confint function. And what I'm going to do is call
the one sample t-test function, also from hypothesis tests, on each of my two, each of my two data sets,
the HDL cholesterol delta for each of my two groups. So I've got the mean and I can work out the standard
deviation. But here we have the 95% confidence interval around the means for both of these.
So very simple for us to use hypothesis tests just for confidence intervals.
I've already plotted these two distributions for you. So let's just have a look at our assumptions
for the use of parametric tests. So in hypothesis tests, there is a p-value function. And what I want
to do, it does not have a Shapiro-Wilk test, but it has Kolmogorov Smirnoff and I think a few others.
So I'm just going to use KS test here. So exact one sample KS test and I'm passing my cholesterol
delta for the placebo group and against a normal distribution. So that's a KS test against the
normal distribution. So let's do that. It's going to give me back a p-value. So the null hypothesis,
remember, is that it is from a population in which this variable is normally distributed.
And let's do the same for my second group. And there we have a problem. We see that a p-value of
of less than a chosen alpha value of 0.05. So we're not really there meeting the assumptions
for the use of a parametric test. I can investigate that visually by a q-q plot. So let's just have a
look at this. I'm creating two plots, p1 and p2, and each of these are going to be a q-q plot. So on
the x-axis, I have the values and on the y-axis, we have the theoretical distribution there. So I'm
calling distributions.normal and it's all going to be changed by this stat.qq. So it knows what to do,
what to do with the values for a q-q plot and then geom.point. So it's a scatter plot and then a
semicolon because I don't want any output to the screen. I'm going to do that same for the intervention
group. And then we're going to call getfly.vstack. So I could also just say vstack because we said
using getfly. So vstack, plot one and plot two. So make a vertical stack of those two plots.
And then the plots, I can see a vertical stack of these two q-q plots. And you can see here
for the second one, that's really off of a straight line there for normal. So we're not
really meeting the assumptions for the use of parametric tests. And although this data was
taken from the normal distribution when we created this, we only took 23 points from each. So there's
always the chance that we get random values that are not going to show up to be from a normal
distribution. So in that case, for two groups, a non-parametric test will be the Mann-Whitney-U
test. And of course, there is a Mann-Whitney-U test there. I'm just passing my two datasets,
my placebo's changing cholesterol and my intervention changing cholesterol using the dot notation. So it's
going to give me two arrays. That's what we like with the Mann-Whitney-U test. And I want a p-value back
from there. So let's have a look at the Mann-Whitney-U test. It gives me a p-value of 0.7 there.
So that is above my alpha value of 0.5. So we can't reject the null hypothesis there. Just to show
you that we also have an equal variance t-test. So if we did meet the assumptions for the use of a
parametric test, there we see equal variance t-test as another function. And we can run that, but we're
going to see a p-value that is also above 0.05. So no problems there. The last thing on today's
list, I'm going to show you just how to do a chi-square test for independence. There is no
such function in the hypothesis test data or any of the packages of yet. So we're going to do this by
hand. So I hope you know the equation for working out a chi-square value. We're just going to sum over
the square differences between observed and an expected contingency table, and then divide that
by the expected values. And that gives us our chi-square value. And then we're just going to use a chi-square
distribution as far as the degrees of freedom are concerned. So let's create a frequency table, a
contingency table of observed values. And what we're going to use is the freq tables function
package.freq table, frequency table function there. And what I want is the data frames,
and I want group against gender. Those are two categorical variables. Remember, we changed them
to categorical variables. But what I want back is not a data frame. I want it to be converted to a
straight up array. So I'm going to use the convert function, change to array, the following thing for
me, this frequency table. And I'm going to store that in in gg underscore obs. That's my my contingency
table of observed values. And what we get back is this two by two array of my observed values.
And that's what you want for your for your chi-square test for independence. And you can see
it's 64-bit integers, but I have two dimensions now. In other words, there's rows and columns. This is a
rank two tensor or a matrix. And that's exactly what we want. Now I want to know from this the row
totals and the columns totals. So the this first column will have a total at the bottom here. 16 plus
14 is 30. And 9 and 7 is going to give me 16. But then I want across the two columns for each row as
well. So I want both the row totals and the column totals. I'm going to use the sum function. I pass my
matrix, but I say long dimension one. So let's see what that gives us back. That's going to give
us back the 30 and the 16. So that's adding 16 and 14 and adding seven and nine. But if I say dims
equals two, it's going to give me across the 23 and 23. So 16 and 7 is 23 and 14 and 9 is 23. So I have
the row totals and the column totals. I need those and I need the sum total as well. And remember,
there were 46 participants. So no problem there. Now I just want to know the size is another function
we haven't seen before. What is the size of this array? And that's going to give me back a tuple
of how many rows comma how many columns. And if I had a higher rank tensor, I would have more elements
there. But it's a two by two array that we're passing to there. So now I'm just going to instantiate
an empty array of similar shape. So two by two array, and they're all just going to have zero values in
it. So I want the number of rows with this gg dim its first value two and gg underscore dim its second
value there. So if I had more than two sample space elements in each of those group and gender,
it was just male and female and active and placebo group. So there was always going to be a two by two
contingency table. But if I had more, and these were different three comma four, for instance,
I would just still reference these two. By now I could have just put by hand two comma two. But I
want to show you where that comes from. This gives me this array of all zeros. I'm just instantiating
that because I want to overwrite each of these values. And I'm going to overwrite that with a double
four loop. So I'm saying for i equals one to gg underscore dim one. So that means two.
So for i equals one to two, and then for j equals one to two as well, because I want to
I want to iterate through all these four values. Row one column one, row one column two, row two column
one, row two column two. I want to overwrite all of those. And remember, how do I get that first one?
Well, that is this row total multiplied by this column total here divided by the sum total.
And that's what we're doing there. So I'm overwriting at the moment i is one and j is one. So I'm
overwriting gg expected, which is just this four zeros. So I'm now in position one. What do I do?
Well, I take that columns total one times the row total one divided by the total 46.
And that gives me that first value. Now I'm going to iterate over the inner for loop.
So j becomes two. So that's the second column. So we now at that one there, I'm still in the first
row. So now we're looking at this value up here divided by the total. And that's going to give me
that value. Now we through this j loop. So we jump out to the for loop and i goes from one to two.
Now it's two. And now we're going to go again, it's back to column one, row two, and then column
two, row two. So that's where the double for loop, I'm going to iterate through all those values.
And if we look at the table, now we see our expected table. And that's what we would expect
given our values versus our observed values. And we want to know, is there a difference?
How do we do that? Remember it is observed minus expected, but I do that element wise. So it's dot
minus dot square, all of those differences individually. So dot and to the power two,
that's to the power two. And then each of those I divide by the expected, the respected, expected
value. And in the end, I sum over all of those. And that's how I get Chi squared.
And look at the beauty of Julia. You see the Chi symbol there. Well, we can actually use Unicode.
So I can say backslash alpha and hit tab. And that gives me an alpha symbol or backslash beta. So it is
like Lartec. So I hit tab and I get the beta symbol and I can assign that to that. That's a variable
name. So Chi2 there. That's a variable name. Look at that. Backslash, colon, smile. So you can put all
of these little icons you can also use for computer variable names. It's just a little whimsy that
exists there inside of Julia. And anyways, that's my Chi squared value. And there we go. It's 0.38.
Is that significant? So is there dependence between those two? Well, I'm going to use from
the distributions package this time, the PDF probability density function, I'm going to use
a Chi squared distribution with a degrees of freedom of one. Remember that is the number of
rows minus one times the number of columns minus one. So it's two minus one is one times one is one.
So it's a single degree of freedom. And I pass the X square value to that. And that's going to give me
a p-value. And oh, behold, it is more than an alphabet of 0.05. So there's no dependence between
those. People did not land up in one of the two groups that was totally independent of the gender
that they were. So we have a Chi squared test there done by hand, very easy, very quick,
very simple to do. Are for loops slow? No, they're not slow. So you needn't vectorize your code to get
speed in Julia. Because remember, this is going to be compiled before it gets executed. And when
a for loop is compiled, it's very quick. So no problems there whatsoever. So that was a brief
introduction just to Julia by way of showcasing some medical statistics on this simple medical
statistics. This has been an update from the video that I uploaded in 2015 that still used Julia 0.4.
And there were certainly lots of breaking changes when we got to Julia 1. Julia is now mature.
We had version 1.4. And it really just is a pleasure to use right inside here of Atom.
Now, you needn't use it inside of Atom. You can also use it inside of Visual Studio Code. That is
becoming more prevalent. And of course, iJulia comes with Julia Computing. But you can also install
iJulia. Let me just show you here. So I would go on this side and say add iJulia. Execute that. And
then we could just say using iJulia. And once we say that, we can just call the notebook as a function,
notebook open, close parentheses, and that's going to open a Jupyter notebook for us.
So iJulia is going to install all its dependencies. Well, I should actually just put that in uppercase.
That's the correct one, iJulia, the i in the jr uppercase. And you can use Julia Notebooks.
So you can code right inside of Atom. You can code inside of Visual Studio Code.
Or you can code right inside of Jupyter Notebooks, whatever your preference is.
So Atom comes with Jupyter Computing. I should say Julia Computing. When you install Julia Computing,
you're going to get this as your standard, your default IDE. And it really is a lovely IDE to code in.
I hope you enjoyed that video. Like, subscribe, and comment. If something wasn't clear, let me know.
I can perhaps spend some more time and explain that. Otherwise, spread the word. It is really
easy language to use, beautiful, a lot of speed. Of course, with the size of datasets that we commonly
work with in inferential statistics when it comes to medicine. We don't really need that speed,
but it's just such a lovely language to use and learn that I don't see any reason why you
shouldn't spend a couple of days and weeks to get yourself familiar with this lovely language.
Sure.
Thank you.
It's amazing.
.
.
.
.
