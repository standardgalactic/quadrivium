So this is going to be our first lecture just looking at how to use Python to do our mathematics.
Now you do not need any prior knowledge of Python. You don't even have to install anything.
There is a link in the description down below to a video where I show you how to set up your
Google Drive such that you can use a Google Colab file that looks very much like a Google Doc
into which you're going to type your Python code. So you really need no Python experience
and you don't need to install anything. What I do want you to have watched is the first video
in this lecture series where I take pencil and paper and we talk about this stuff in lecture
number one. Just simple arithmetic and talking about numbers. In this lecture though we're going
to use Python to do all the mathematics that we learned about in lecture number one. So to start
with we have lecture number one. So we might as well go right to the top and you see if I hover in the
middle between these two cells you see code and text. So let's enter some text. Now this is going
to be a title for me. So if I double click here double click or enter to edit if I double click
you see I have a bar that allows me to use boldface italics insert images all sorts of things. I'm going
to use a single hashtag symbol or pound symbol and I'm going to say lecture one. So lecture one and
perhaps I'll have a space and I'll put a little bar there on my keyboard. It's right above the right
shift key. This is a macbook pro. You'll have to find that on your own keyboard. Of course you can
type any kind of title that you want and I'm going to call this one arithmetic.
The single hashtag symbol there with a space behind it indicates to this notebook that this must be the
largest font size that this notebook can render. And if I just hold down shift and hit enter that cell is
executed and now you can see it's quite a large font. I have lecture one and then I have my little
horizontal my little vertical bar I should say and arithmetic. And so the first thing that I like to do
in these notebooks is to import all the extra packages that I'm going to use in this session
of Python. So I'm going to hover in the middle between these two cells. There's a code cell which
was there automatically but just above that so between the stick cell that I've just created and
this code cell if I hover over the middle you'll see code and text and I'm going to add a new text
cell. This time I want the second largest font so I'm going to use two hashtags or pound symbols
and then a space and then I'm going to write imports. And if I hold down shift and hit return or enter
that cell is executed and you can see the font size is slightly smaller from my largest font size
which I use for my title. And then for subtitles or sections I will use the second largest font size
which is indicated by those two hashtag or two pound symbols. Now I want to use a code cell. Now
there's already a code cell for me there so we might as well make use of that. And I'm going to import a
few things. And the keyword in Python to import a new package is just import. It's very much like
English. And I leave a little space and the package that I want to import is the math package. And all I
have to do now is hit that little play button but I can also hold down shift and hit return or enter.
Now what I don't have at the moment is a running Python kernel. Now remember all of this is happening
on Google's servers not on my own computer. So I have to start Python on their computer and one thing I
can do is hit that little connect button that you see right at the top. Or when you execute your
first cell that's going to happen automatically. So let's do that. I'm going to click on this little
run button. You see the marching ants walk around, walk around the play button. Things are happening
behind the scenes. We've started Python on the Google server side and we see a little check mark
there. That code cell has executed. We have now imported the math module. The math module is full of
extra functionality that is not in base Python which has now expanded what I can do with Python. Let's do
that once again. I'm going to go to just below. Hover in the middle just below the cell that we've just
had and I'm going to add a new code cell and import. And this time I'm going to import Sympy.
That's S-Y-M-P-Y short for symbolic Python. I'm going to hold down my shift key and hit my enter key
or my return key. When I do that a new cell will automatically appear below. But look at that.
There's a little check mark there. We have successfully imported NumPy. Now I can always
come back and add more cells in between cells that are already there. The execution will be in temporal
order. Unfortunately that means the order in which we have from top to bottom that is not going to
happen as I execute this current notebook. So we always just have to be aware of that. So let's create
a new text cell. So I'm going to click on the text button. Let's make it another section. And my
sections are the second largest font size. So there'll be two hashtag or two pound symbols. And
let's type in Python types. Now hold down shift and hit return or enter. And now you see my notebook
is starting to look very neat. I've got my title. I do have these two sections. Now everything in Python
or let's say most things in Python are really just objects. And as far as objects are concerned,
objects have a certain type. And one way that we can find out about the type of something is using
a Python function. And functions in Python are keywords. And you can see me type there the word
type. That is a function in Python, a keyword. And all functions are immediately followed by a set of
parentheses, open and close parentheses. So every time you see a word and then open and close
parentheses, that would be a Python function. Inside of those parentheses, we pass an argument.
It tells the function, this function can do something, but what must it use to do its job?
Well, that is the argument that we pass. And this time I'm going to use single quotation marks. And as
soon as I hit the single quotation mark, remember you can also use double quotation symbol. That doesn't
really make a difference. And I'm going to say, I love mathematics. And I've typed that sentence.
And, but it is inside of quotation marks. If I highlight it, can you see that that is inside
of quotation marks? That whole thing inside of the quotation marks together with the quotation marks,
that is an argument. I'm passing that argument to the function type. Type knows what to do. You must
just tell it, what must I act upon? Now it is acting upon this argument. And that is,
I love Python in quotation marks. Now, as soon as we put something in quotation marks,
what we are telling Python is that this is a string type. So let's hit that play button or
shift enter, shift return. And we see the result immediately str. And that's as short for string.
Anything that's inside of a set of quotation marks is a string. And you can think of this as just normal
English. It can be a single letter, a single number. It can be a sentence. It can be a paragraph.
Anything that goes inside of a set of quotation marks is a string object. Now that it is that
data type string, Python can do a lot of stuff with strings. But the stuff that it can do with
strings is very specific to strings. They will mostly only work on strings. And so Python needs
to know what this is. And it knows that this is a string. And I can find out for myself as a human
being, what does Python see this as by using the type function. So let's try the type function again.
I'm going to say type. And this time as argument, I'm going to put just the number one, just simply
the number one. So there's no quotation marks, which means this is not going to be a string.
We already know that. And let's do shift and enter, shift and return. And we see that's
int. That is short for integer, otherwise known as a whole number. And so we can see that object
there. The object is the number one. And all objects have a certain type. We can use the type
function. Pass this one as an argument to the type function. Type knows what to do. Just wants to know
what must I act upon. Well, there's your argument. It's one and it is returned. We can see that it is
an integer. Let's carry on with this. Let's do type. And this time I'm going to put 1.0. So there's a
decimal value there. I've added one single zero decimal point. And as soon as I do that, we see now we
have a float. That is short for floating point number, which just means numbers with decimal
points. And again, Python has a bunch of stuff that it can do to strings. It has a bunch of stuff it can
do to integers. It has a bunch of stuff that it can do with floats. It just needs to know what that
object is. Of course, Python will know what it is, but I'm using the type function to find out for
myself as a human being, you know, what is going on here. I want to show you one exciting one. And we
are going to look at this during this course. And that is just one J. So there's no spaces between
the one and J. And let's have a look at that. That's a complex number. So in engineering, we use
J for the imaginary unit. Mathematics, we usually use I. But here in Python, you can just use the J.
So one J is the imaginary unit I. And that is of type complex. That is part of being a complex number.
Let's have a look at a couple more. And I'm just using different arguments to just show you
some of the data types that Python has. So this time, I'm going to use the keyword true. And you
can see that it's spelled with an uppercase T. And let's have a look at what that is. That is a
bull, which is short for Boolean. Boolean is just true and false. If you have a mathematical statement,
what we do in mathematics is we have statements and they can either be true or false. There's no maybe,
there's no gray area. It's true or false. And in computer science, we also have this idea of true
and false. Let's have a look at the type of false. Now that is uppercase F. And if we look at that,
scroll down, that's also a bull. That's very, very important. A Boolean type. And the only two is true
and false for us here. And behind the scenes, I just want to let you know, very interestingly,
true is actually represented by the number one and false is represented by the number zero. So that I can
actually say, do some mathematics. This is the first mathematics. We're going to see true plus true.
And now that is, you know, space plus space, then true. You don't have to use those spaces. It just
looks a bit neater to my eye. But look at what happens when I execute this. I get the result too,
because behind the scenes, Python is storing true as the number one and false as the number zero. So if
you say one plus one, it is definitely going to be true. Let's look at one more type that I want to
show you in this section. So I'm going to say type and then none. And then the N, the first N is
uppercase as well. And we see that has a very special type and that's called the none type.
Once again, a computer language such as Python needs to know what type an object is because it
can do certain things with certain types of objects, which it cannot do with other types of
objects. That is how the language is designed. Now we've worked on our file a little bit. It's
starting to look very nice, but right at the top, there's something we haven't done yet. We haven't
named our notebook. So you can see if I hover over untitled zero dot IPYNB, I can rename this
notebook. So I can click anywhere in there. Let's go to the right of the zero and let's delete all of
that. And I'm going to call this lecture 01. And I'm just going to hit enter or return. And this
notebook now has a specific name that is saved. And if you go back into your folder, your Google Drive
folder, you'll see this is now called lecture 01.IPYNB. And of course, you can call your notebooks
anything you like. Let's create a new text cell. And I'm just going to put two hashtag symbols.
And so I'm starting a brand new section. By the way, if we go all the way back up, we see we have
these little downward facing arrows. If I click on that, it is going to close up that section. And if I go
that, it closes up that section. And this makes it even neater because now those are collapsed. And I
can just re-expand them as I need them. So let's leave that collapsed. And we can, as I say, always
re-expand them. So let's do a little bit of arithmetic. Now I'm going to start the section
in arithmetic off with looking at a very specific function. And that's called the round function.
So round does what the name implies. It rounds off to a certain number of decimal points. So let's
use just a single number. Let's do 10.4. I'm passing 10.4. That is my argument to the round
function. I'm going to hold down shift, hit return, or enter to execute the cell. And by default,
we see that it is rounded off to the nearest integer. So there we see 0.4 was just rounded down.
Remember at 0.5, 0.6, 0.7, anything 5 or more, it's going to round up. And then less than 5,
it's going to round down. So let's have a look at what happens if we do round. Let's do 10 point,
let's do 4999. Let's see what happens now. Again, that 4 is less than 5. So it's going to round down
and we see, as we expected, we see a 10. But what if we want more decimal places involved? Let's do
round. Let's do 3.141. And now I'm going to put a comma and a space. Now, one thing about Python is
you can pass in for many functions, at least more than one argument. And we separate those arguments
by commas. So here we have our first argument is the number. And our second argument might be
how many decimal places do we want? And so let's say that we want a single decimal place. And for
that, I just type the number one. And now you can see it's been rounded off to one significant digit
to one. 3.1 is one decimal place. And so you can pass other values, two, three, four, depending on
how many decimal values you would like. Now there are two other important functions when it comes
to rounding. And that is the floor function and the seal function for floor and ceiling. Now those are
very important functions. We've discussed them in the pencil and paper lecture. So let's have a look
at them. One thing that we are going to see now is that the floor function and the seal function,
which we're going to see, is not available in base Python. They live inside of one of the packages
that we imported. And to make use of them, we've got to tell Python that this function that we're
interested in is inside of that package. Now this package is going to be the math package. Remember
right at the beginning we imported that. So we type the name of the package and then we say dot
or full stop. And then let's do the floor function. And there we go. We see floor that
floor. I cannot just write, remember with type and here with round, I could just type those names of
the function because those are functions inside of base Python. This floor function is not inside of
base Python. It is inside of the math package. And hence I have to reference that package name. And I
say math dot or full stop. And then the name of the function. Now this active session of Python
will know where to go and look for this function. And let's do 3.999. And what the floor function is
going to do, remember, it's always going to round down to the nearest integer. So if I execute that,
that is going to give me back a three. It falls down to the floor. And no matter how high those
decimal values are, if they are five or more, it's not going to work as normal rounding. It's going to
round down. And we also have math dot seal. And that is short for ceiling. That is the official
name of this function inside of the math package. And let's do 3.001. And let's look at what the
ceiling of that is. Of course, it rounds up to the nearest integer. And so we see that the nearest
integer rounding upwards from 3.001 would be 4. So that's very interesting. I always like to start
arithmetic by just a reminder of rounding and floor and ceiling functions because we do make use of these
in so many of our calculations. More importantly, let's get to some real arithmetic. And the first
thing we're going to do is addition. So we might as well make our notebook look very nice. Let's create
a new text cell. And I'm going to put three hashtag symbols because now I want the third largest font.
And let's start with addition. Let's start with addition. And now you can see that's even smaller
than the font size for arithmetic because I used three hashtag symbols. So let's just do a little
bit of arithmetic. Now I've already shown you true plus true. But let's do something like 3 plus 4. And
it's very simple. That's all you do. 3 plus 4. Now again, I need not have put the spaces there. I can
also type 3 plus 4. That's very acceptable. I like to put the spaces. It just looks a little bit neater.
And Python allows me this freedom to use white space. Python doesn't really care about my spaces.
And I'm going to hold down shift hit return or enter. And I see as I expected, the result would
just be 7. Let's do something more exciting. Let's do 3 plus 4 plus 5. Shift and return 12. 3 plus 4 is
7. 7 plus 5 is indeed 12. And I can just keep on adding, adding, adding as many numbers as I like.
Addition is no problem whatsoever. Let's go and have a look at subtraction. I'm going to hit the little
text button. 1, 2, 3 hashtags. And I'm going to do subtraction. And so let's just do subtraction.
Let's do 3 minus 4. And I'm just using the minus symbol on my keyboard. Shift and enter. And indeed,
3 minus 4 is negative 1. I can do something more complicated. Let's do 23 minus 6 minus 10. And if I do
that, 23 minus 6 minus 10, that's 23 minus 16. Indeed, that is just 7. So very, very simple to do.
And of course, you can just keep on going and add more and more of these. By the way, you can also do
addition and subtraction together. And we'll look at that a little bit later. Let's just carry on with
our simple exploration of arithmetic for now. I'm going to add a text cell. 1, 2, 3 pound symbols. And
let's do multiplication. There we go. Now, there's no multiplication symbol on keyboards. And so we use
another symbol. And that is the star symbol on my keyboard that will be shift and 8. So let's do 3
times 4. So that time symbol there is just the asterisk or the star symbol. And if I say shift
and enter, I get 12. 3 times 4 is indeed 12. Once again, I can do more. Let's do 3 times 4 times
2. And that's going to give me 24. And you can just carry on as long as you like. Let's have a
look at something a bit more exciting. Let's look at division. So I'm creating a new text cell. I'm
doing 1, 2, 3 hashtags. I'm writing division. Division. By the way, let's just go up and let's
start collapsing these. I'm going to collapse addition. I'm going to collapse subtraction,
multiplication, just making my notebook look a little neater. So let's do division. And now let's do
something very simple. Let's say 10 divided by 2. Once again, there's no division symbol on my
keyboard. And what we use is the forward slash key. So 10 forward slash 2 means 10 divided by 2.
And I see 5.0. And we know what type that is. That is a floating point number versus just a 5,
which would have been an integer. So we've learned something here. If we do division in Python,
we are indeed going to get, we are absolutely going to get a floating point value. Now I can just keep on
going. I can say 10 divided by 2 divided by 5. Let's carry on. And that's going to be 1 because 10
divided by 2, reading from the left is going to be 5. And 5 divided by 5 is simply going to be,
is simply going to be 1. Now let's make use of another strength of Python. And that's the
SymPy package. I just want to show you something. Let's do 2 divided by 5. If I take 2 and I divide by 5,
if I get 0.4, 0.4, but what if I did not want that floating point value 0.4? So let's use something
that's inside of the SymPy package. Now, because we imported that package as its full name, I have
to say SymPy dot, and there's something in SymPy called the rational, and that's with an uppercase
R. It's going to create an instance of the rational class. We don't have to be too concerned about that.
And it's got parentheses. So we are going to see this as a function. Let's call it the rational
function. And I'm going to say 2, 5. I'm passing two arguments to this rational function. I'm
separating them by a comma, and it's 2, 5. Let's have a look at what happens now. And just absolutely
look at how beautiful that is. I see it as I would see it in my math textbook. I see a fraction. We did
not execute 2 divided by 5 to get this decimal value 0.4. We've actually got the fraction there.
And we got that fraction 2 divided by 5 by using this SymPy function called rational. And I think
that is very, very beautiful. And now let's go right up back to the top, because I want to expand
this import section again. And I'm going to create a brand new cell here. And that's going to be a code
cell. Now, I was fortunate that I saw that fraction 2 over 5. If you don't see that, you have
to tell this session of Python, this notebook, that you want your SymPy execution or the results of your
SymPy functions to be printed very nicely. And the way that you would go about that is to say
SymPy.init underscore printing. Init printing, it is a function, open close parentheses. And so there's
no argument that we pass to this function. I can just hold down shift and hit return or enter. That
is going to be executed now. And that is telling this notebook right now that if you use SymPy,
please print everything to the screen in nice mathematical notation. Just as we've seen right
down here, we see 2 divided by 5 as a beautiful fraction. And that is a very powerful thing or one
of the first powerful things that we'll see about the symbolic Python package. So let's carry on.
I'm going to use text and I'm going to use 1, 2, 3 hashtag symbols and I'm going to do powers. So
let's look at some powers. How can we do something like 2 to the power 3? Now, once again, there's no
way to do superscripts. You know, we put either if we say 2 or 3 to the power 2, we need that little 2
to be in a superscript. We don't have that. So what we do in Python, if we want to say 3 squared,
we'll do 3 and then 2 star symbols and 2. So that means 3 to the power 2. Now, I don't like to put
spaces here because when I write this in my, you know, with pencil and paper, I put the superscript
2 right up against the 3. And this just is for me a nice way to write it. So let's execute that 3 to
the power 2. That's 3 times 3. And as we can see there, that is equal to 9. And that is how we do
powers. Now I can do a power of a power. So let's take 3 to the power 2, which is going to be 9.
What happens now if I do another to the power 2? And now I get 81. That is where we make use of the
multiplication of those powers. 3 to the power 2 is 9. And 9 to the power 2 is indeed 81. So powers are
quite easy to deal with. Let's go up and just close these. Let's close division. Let's close
power. Because the next one that I want to show you is how to deal with square roots. So let's do
1, 2, 3 hashtag symbols. And I'm going to type square roots. So let's deal with square roots.
So by the way, you could see there when I collapse powers and I opened a new cell,
we got this automatic cell entered. That happens. You can just go, you know, click inside of that cell,
go to the right and click on that little trash can icon. And indeed that cell is gone. So let's
close powers again. And let's talk about square roots. Now one way to write the square root of
something is to raise it to a power half. We looked and we looked at that inside of the pencil and paper
lecture. So maybe I want to take the square root of 9. I would say 9 to the power. Now I'm going to
use parentheses because I want to put a half there. And one way to do a half is just to say 1 divided by
2. 1 divided by 2 is a half. So I'm saying 9 raised to the power a half. And when I look at the results,
it looks fantastic. It says 3.0. Fortunately for us, we don't have to do all of this. Inside of the
math package, there is a function sqrt. So that is not in base Python. It is in the math package.
So I have to tell Python where to find this function sqrt. And that's inside of the math
function. Let's do a set of parentheses again. That sqrt is a function. We have to have open close
parentheses and we're going to pass the argument 9 to this function. And we see the result is again
3. Do note here though that Python is not going to tell you that it's plus or minus 3. It omits
that negative. And it's just going to assume that you know that there should be a negative as well.
Now let's do something like math dot sqrt of 10. Now we know that's not going to be, you know,
an easy integer solution. And indeed, if we look at that, we're going to get this numerical approximation
3.162776. And that is great because usually we want to deal with that number. But I want to show
you the difference between the sqrt function that is in the math package versus the sqrt function
that's inside of SymPy. So if I say SymPy dot, unfortunately, there's also an sqrt function
inside of SymPy. And now if I pass 10 to this, look what happens. I get the exact numerical
representation or the exact representation. I should say I get the square root of 10. So here
I have the numerical approximation and here I have the exact solution. That's what were the terms that
we use in mathematics. Same function, sqrt, sqrt, but they behave very different differently because
the people who designed the square root function inside of the math package, that's a very different
set of work than the people working on the sqrt function inside of the SymPy package. They perform
very differently, although the name is the same. Now, when you develop your own package, you are
free to use function names, whichever ones you want. And just so happens, sqrt short for square root
was the same function name that was chosen by both sets of developers. Now in SymPy, it's also easy to
get the numerical approximation. Let me show you how to do that. SymPy dot sqrt. I'm going to pass 10 to
that. And now I'm going to do a very weird thing. I am going to use another function, but this is a
very special way to do this. I'm going to put another dot and then I'm going to say eval f and
that stands for evaluate this function and just open and close parentheses. There's nothing that
I'm going to pass as an argument there. So what is happening here? Now you don't have to know about
this at this stage, but let me just explain that for your interest. SymPy dot sqrt 10 is going to be
a certain object. And indeed, we saw the object there. It's the square root of 10 in symbolic notation.
But I can now take this object and I can pass it as argument to a function. But I can do it in this
way by appending this object with a dot and then the function name. Instead of saying eval f and inside
of the parentheses pass SymPy dot sqrt 10, I'm doing it in this order. And in this sense, we call this a
method. This function is called a method. That is when we apply a function to an object that already
exists. So that's a brief little introduction to the way that methods work. And we won't go into
the details there, but the result is spectacular. So now I get the numerical approximation of this
exact solution, which is square root of 10. I get the numerical approximation that says, well,
actually evaluate this for me the same as the square root function inside of the math package would
have done for me anyway. So I think that is just a little bit of fun. Now, just to show you,
you know, before we spoke about briefly about the complex numbers. Now we will have a lecture where
we take the roots of quadratic functions and the complex numbers, complex roots will come up. So I
just want to show you for now, not too important, but let's do that. Let's do SymPy dot sqrt of a
negative number. Now we are going to deal with this later on in the course. For now, we know that we
cannot take the square root of a negative number, but I just want to show you what SymPy would do with
this. It actually, actually gives us back this complex solution, three times i, the imaginary
unit i. So SymPy can absolutely deal with this kind of algebra. As I said, we will work with it
a little bit later in the course. Now let's create a new text cell and I'm going to use three hashtag
symbols again, because this is still one of my subsections under my arithmetic and I'm going to do
higher roots. So what if we, by higher roots, I mean, not just the square root, but the cube root
or anything higher than that, to the power one over four, power one over five, et cetera. So if I want
to look, for instance, at the cube root of 27, I would have to do 27 and then two star symbols and
then one divided by three, 27 to the power a third. That would be the cube root of 27. And lo and behold,
I get the right solution. And that is going to be three because three times three times three is indeed
27. Let's take, for instance, 16. And I'm going to raise that to the power one over four, the fourth
root day of 16. And that's two because two times two times two times two is indeed 16. Inside of SymPy,
SymPy dot, there is a root function, SymPy dot root. And now I can simply pass the value that I want to
root of 64. And what root do I want? I want the third root of that. So that would be 64 to the power
one over three or the cube root of 64. And the solution is four because four times four times four
is indeed 64. So you start getting a sense of how these functions work. The root function, and remember
this is just human beings designing it that way, that they say, well, there should be two arguments.
The first argument must be the number. And the second argument must be, you know, this power that I want.
I want to the power one over three when it comes to the root functions, because I want the third
root of 64, the cube root of 64. Let's move on to a new subsection. And I'm going to call this one,
so three hashtags, absolute values. Absolute values. Now, you know what happens to the absolute values,
it turns any number into its positive version. Let's go up. I'm just going to collapse this section
on square roots. There we go. Let's collapse the section on higher roots. And now I'm working
with absolute values. Now there's a function abs. And if I pass negative three to that function abs,
I get positive three. So note, I can just use abs as is. It is inside of base Python. It's a function
that lives inside of base Python. I don't have to use abs if it is in one of the other packages. It is in
root Python. And so I can just use it as is. So it's going to turn any number into its positive
version. And that's actually all I want to show you about absolute values. It's quite easy to do.
So now let's look at logarithms. So I'm going to do one, two, three, and I'm going to do logarithms.
Logarithms. Now we've discussed logarithms in the pencil and paper section. We deal with
logarithms so many times inside of data science. And so let's have a quick look at that. If I do
math.log, there is a log function built in. And you see there's actually log, log 10, log 1p, log 2.
There's a few of these. If we just use log, it is going to be base E. In other words, Euler's number.
That is the natural log. So if I take the log of, say, 10, well, let's make it 100. Just to show you
math, log 100 is going to be 4.6. That is E to the power of 4.6 gives me 100. As I showed you there,
there is a log 10 function as well. And if I now put 100 in there, I should get back 2 because 10 to
the power 2 gives me 100. So you just have to be clear about this. But look at this, the math.log
function. So once again, you can clearly see log. The log function does not live inside of base
Python. Base Python cannot do a log. So I have to use one of the packages that can do logarithms.
I can say I want the log of 100, but I can also say comma. And now I can tell it what I want the
base to be. By default, the base is going to be E. So the natural log. But I can say comma base 10.
And now I'm going to get the two back again. So you see log 10 and log with the second argument of 10.
That's going to do exactly the same thing. Now let's look at some pi dot log. Seems like there is
a log function inside of some pi as well. And let's do 100. And what am I going to get back? I get back
this exact or symbolic representation that is log 100. It has not evaluated that function for me. So
once again, if I wanted the evaluation of that from some pi, I would have to say some pi log. And then
I'm going to say 100. And then remember that is going to give me back an object. And now I'm going
to use the eval f method. Eval f. And let's return that. And now I actually get that same numerical
value, same numerical approximation as I got from the math. So what we've seen now is all these functions
inside of the math package. That's just going to do plain and simple the stuff that your calculator
would do for you. It's going to give you this numerical approximation. But some pi is a bit
special. It can do that for you. But by default, it's going to give you the stuff that you see in
your math textbook. So you're going to see these nice symbols. Now let's look at math dot exp. And
I'm just going to pass the value 1 as an argument. And what I get back is 2.71828. And that is
Euler's number. Anything raised to the power 1 is just that number. And the exp, short for exponent,
is very special. That does refer to Euler's number E. And so I'm saying take E and raise it to the power
1. And that actually gives me back Euler's number. So if you ever wanted to know the first couple of
decimal places of Euler's number, just like pi, you know, we learned 3.14125, etc. Here's Euler's number
2.7182818. It's also an irrational number. So just to show you that we can do that as well. Can we do
the same with some pi? Let's explore some pi. And let's see if there's an exp function in some pi.
And I'm going to pass the number 1 to that. So that says the exponent 1, E to the power 1. And what do
we get? Instead of this numerical approximation, only to a number of decimal places, we actually get
the exact solution, the exact value represented by this symbol E. So once again, I just want to show
you how special some pi is. I absolutely love some pi. It really helps us to do proper mathematics
that it looks like we are working with a textbook. So let's create a brand new section. And we're just
going to talk a little bit about the properties of real numbers. Remember, we did that in the pencil
and paper lecture. So this is going to be a brand new section for me. So I'm only using two hashtag
symbols. And I'm going to say properties of the natural numbers. Shift and enter. So let's go back
up. I'm going to close down logarithms. And I'm going to close down absolute values. And we can
actually go way back up. And we can close up all of the section on arithmetic. Now you don't need to do
this. I'm just trying to keep my notebook nice and neat. So properties of our real numbers. Now,
first thing I want to teach you here is about something called conditionals. Now a conditional
looks at something and something else. So two things and it wants to compare them. And the best way to
compare things or the first way to compare things is to see if they are equal to each other. And the way
that we do that in Python is to write a statement and it's going to return to us a Boolean value.
So is this true or false? So let's look at three. And the way that we test for equality is by two
equals symbols. Three equals equals three. This is what we call a conditional. What I'm asking with
this code is, is three equal to three? So I've got two things there, a three and a three. You can think,
start thinking about this as an equation. So on the left hand side I have a three, on the right hand
side I have a three. And I'm asking, is three equal to three? Now this is a statement that is either true
or false. Now obviously three is equal to three. So let's execute this code and we're going to see
a Boolean data type returned to us. And there's only two possible things that's going to be true
or false. And indeed we see it is true. Now I'm going to use this, this conditional, and I'm going
to look at some of the properties of natural numbers. So let's do that. Let's see if the commutative
property holds. And of course it does. We know it does. But let's check on that. If I say three plus
four, is that equal to four plus three? So does the order in which I add two numbers, does that
differ? Now we know three plus four is seven and four plus three is seven. So we know we're going
to return a two. But we're seeing something deeper here. We see that the commutative property
on addition holds. That if I do, you know, it does not matter what the order is, I get the same
solution. We know that that is not true for subtraction. Because three minus four, let's check if that is
equal to four minus three. And the result is going to be false. Because three minus four is negative
one. And four minus three is positive one. And negative one is not equal to positive one. And
indeed we see there that we get the result is equal, is false. Now there's another conditional. I'm just
having a bit of fun here. Let's have a look at that. Three minus four, not equal to. So exclamation
mark equal is also a conditional operator that's asking, is it not equal to? And let's do four minus
three. So this statement is saying, is three minus four not equal to four minus three? And then they
are not equal to each other. For sure they're not equal to each other. And Python tells me, you're
absolutely right. That is absolutely true. Now the same is going to go for multiplication. If I do
three times four, is that equal to four times three? Yes, it's 12 equal to 12. No problem. But what
what about three divided by four? Is that equal to four divided by three? Well, no, it is not. Three
quarters is not equal to one and a third. And I get false. But if I say three divided by four, is that
not equal to four divided by three? Then I'm going to get back a true response. So I'm using a bit of
simple arithmetic here. And these, you know, using a bit of logic with these comparisons, just to see,
to teach you about how we could go about using a computer language later on, if we want to test
whether something is true or false. Now, what about the associative properties? Let's look at three
times four, and then times five. And I want to know, is this equal to doing three times four times five?
Now I'm using my parentheses and PEMDAS. We know what's inside the parentheses will be executed first. So
on the left hand side, I'm going to do three times four, which is 12. And then 12 times five,
which is 60 versus on the right hand side, I'm doing four plus four times five, that's 20. And
20 times three is 60. Is this the same? Yes, true. And we can see this idea of associativity holds as far
as as far as multiplication is concerned. And I'm going to leave it in your hands to play with this,
use these conditionals and look at the different properties that we discussed on the pencil and paper
section to see whether, whether certain properties hold as far as the natural numbers are concerned.
So let's do a new section. And I'm going to just talk about the uses of division. That's going to
be a new section for me. And I'm going to say the uses of division. Now remember, we did discuss this
in pencil and paper section. Let's close the section on the properties of natural numbers. And I really
want you to explore that on your own. Now in the pencil and paper section, we spoke about this idea of
using fractions, which is just something divided by something else. Usually we would say fractions
that the numerator is smaller than the denominator, but that's not necessarily true. Just dividing two
numbers. Now we've seen the simpi.rational. We've seen the simpi.rational function. And for instance,
I want to have a look at three over eight. And so I would just pass those two arguments, three comma eight,
not three divided by eight. And now I see this nice exact solution, three divided by eight,
three over eight. And for me, that is indeed a fraction. Now let's have a look at another one.
Let's do simpi.rational. And let's do three divided, three divided by five. So that's three comma five.
This function is taking a numerator and denominator as its two arguments and arguments are separated by
commas. And I can see three fifths. Now let's do what we did with a pencil and paper. Let's see if
three eighths is less than three fifths. Now what I'm going to do is something we do quite often. We
cheat a little bit. I'm going to copy. So command or control C and I'm going to control or command V
and I'm going to say less than. Now, have you seen that in mathematics? Of course you have seen.
So let's go back and let's copy this bit of code. Command C, control C. And now I'm going to go
right back there and paste it. And now look at that. Is three eighths less than three fifths? Now we use
the double equal and the exclamation mark equal before. And this is exactly the same thing. I'm
asking is three eighths less than three fifths? And this is a statement and it's going to be true or
false. And let's execute that and see, and we see it as true. If I cut my cake into eight pieces and I
take three of those, or if I cut my cake into five equal pieces, of course, those five pieces are
bigger. So three of those fifths, that is going to be bigger than three of the eighths. So three
eighths is less than three fifths. And if you ever have to do this kind of thing, work with fractions,
very nice to do here. Of course here, I'm just using the rationals or that rational function. Now that
means I can also do a bit of addition here. So I'm going to copy and paste this whole line of code.
Now look at how naughty I'm going to be here and I'm going to paste it right there, but maybe I want
to add those two things to each other. So I'm just going to replace my less than symbol with a plus.
So instead of having to type out everything, I'm just making use of a bit of copying and pasting.
So I'm saying three eighths plus three fifths. And let's execute that and look at that. That is 39
40, 39 over 40. And isn't that a thing of beauty here with some pie? Now let's try and do the same
thing just with normal mathematics. So let me put inside of parentheses because I do want to do three
divided by eight and then add to that. So I'm using PEMDAS. I'm using the parentheses to now instruct
the order of this arithmetical operation. And so I can do this all in base Python. I don't need to use
anything else. So I'm saying three divided by eight plus three divided by five. And if I look at the
solution now, I'm going to get 0.975. That is the decimal representation. But look what some pie can do
for me. It can make it look like a nice little fraction from my textbook. And I absolutely,
absolutely love that. Let's do another bit of cheating. Let's take those exact same two. I'm
going to highlight and copy those. I'm going to come down to the cell and paste them. And I'm just
going to change my addition to multiplication. So I'm putting a little star symbol in between the two.
So three over eight times three over five. And look what I get. I get nine over 40. And again,
for me, that is a thing of beauty. And it's already going to be reduced for me. Now that is
the smallest numerator and denominator. I cannot simplify that any further. So that is absolutely
beautiful. Let me show you this. Let's copy and paste. I love to copy and paste to save so much
time. And let's do something like five over 10. If I use five over 10, if I use that in some pie,
it's five over 10. It's going to reduce that for me to a half instead of doing the five over 10.
So some pie is even going to do that nice little bit of mathematics for me. Now, one of the things
we talked about is the least common multiple. And in some pie, we have some pie dot LCM. Now,
remember, we broke it down into its prime. We took a whole number. We broke it down into its prime
factors. But look at this. If I want the least common multiple of two numbers, look at that.
There's an LCM function. It does not exist in base Python. It exists in the some pie package.
So let's have a look at what is the least common multiple of four and six. And the least common
multiple is 12. Four times three is 12. Six times two is 12. So it's so easy to get the least common
multiple. And you know, if you want to add two fractions, the two denominators must be the same.
And this is just such an easy way to find the least common multiple between two integers. It's
absolutely lovely to do. Now, one thing we spoke about in the pencil and paper section, again,
was a sum was a remainder. I just want to show you if you do some pie dot mod mod, but that M has to
be an uppercase. And I'll do 13 divided by two. Now I know that 13 divided by two is six as a whole
number, but six times two is 12. But I need to get to 13. So there is a remainder of one. So if you
always want to know what the remainder is, use the mod function. So hopefully this has given you a good
start, an enjoyable start to using Python for your mathematics. Everything we've done now is just play
a little bit. It's quite easy to do. And I want you to explore on your own. Do a couple of these on
your own. Once again, using mathematics in terms of a computer language is a participatory sport. You
can't just watch me code and learn to code. You have to code yourself and you're going to get a bunch
of errors. No matter how long we use a computer language, you will always make mistakes. People
with 10, 20, 30 years of experience make mistakes every day. And if you see little errors prop up,
because if you do something and it does not execute for you, you are going to see an error. Try and fix
that. Try and figure out how to fix that. So this is a brief introduction specifically about the Simpi
package, because we're going to use the Simpi package throughout the rest of this course. Hopefully
you could see just how easy it is to start using it.
