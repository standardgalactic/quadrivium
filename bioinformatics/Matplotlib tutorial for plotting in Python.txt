Well, if you know my unit, you know that we use Plotly most of the time for interactive plotting,
but there's always Matplotlib. Matplotlib is the grandparent of all plotting libraries in Python,
and it's really, it's a beast of a piece of software. You can do any kind of plots with
Matplotlib. So what I'm going to do here is 80 minutes, put as much of Matplotlib into 80 minutes
as I humanly possibly can, and show you how to use it. Here we are in JupyterLab, and we've
opened our Matplotlib tutorial.ipynb file. What I do like to do is to keep my table of contents
open on the left-hand side, and I also like to keep this simple setting there, just to save a bit of
screen space. So there, Matplotlib tutorial for scientific plots. Now I want to tell you something
first, and if you've never used Matplotlib before, you've got nothing to hang this information onto,
but I want you to keep it in the back of your mind so when you start using Matplotlib, you know what
to do, and that is the default setting. So you can actually set some parameters and save their values
so that every time that you create a plot, you know, these defaults will be used. We can set that
class rcparams while we code, or you can look at this file here, Matplotlib rc, and you can find out
where this file is by importing Matplotlib and then calling the Matplotlib underscore fname
function. And if you do that, you'll see where this file is, and you can tinker around with that.
Just don't mess things up, I suppose. So as I said, you've never used Matplotlib before. You're not
quite sure what this all is, but sometimes when you do want to generate the same sort of type of plots,
you want all sorts of default settings. You can just play around with Matplotlib rc or the rcparams
class. And I suppose in the beginning of a notebook or some code, if you use VS code or PyCharm or
whatever you use, you can set that with some Python code as well. So you've never used Matplotlib
before, you know, know what the hell I'm talking about. That's fine. Just remember that you can set
a bunch of default values. So let's have a look at the table of contents. These are all clickable links,
and it takes us to the different parts of this notebook. But we can also look down all the way
down here in our table of contents. A bit of introduction. We've already had that table of
contents we're talking about now, and then packages used in this notebook. We'll run through that.
Now there's two basic interfaces. There's more, but the two main ones that we can use is the Pyplot
interface. Of course, back in the day, it was trying to look like Matlab, which I suppose we don't have
to do anymore. But that was it. And you can use the Pyplot module and make your plots or make the
code at least very similar to Matlab. And then there's the object-oriented interface, which you'll
use most of the time once you get used Matplotlib for sure. But we're going to start with the Pyplot
interface. Just do some basic plots there, lines plots, line plots and scatter plots, some frequency
plots, etc. Then we're going to tackle this object-oriented interface that allows us much more control,
and I think you'll love that a bunch more. And then because this is Matplotlib for scientific
plots, we're going to look at some plots for functions and vectors. We're going to look at
contour plots, quiver plots for vector fields, and then stream plots for vector fields as well.
And then I'll just show you very quickly how to save your plots if you want your plot that you've
worked so hard on, ready to be printed in your report or published on the web, etc. You can just
save your plots as PNGs, JPEGs, etc. So let's quickly look at these packages that we can use
in this notebook, OSS, just so that we can interface with the folder structure on our computer.
Symbolic Python, because when we talk about the vector fields, I'll just show you how easy it is
to take partial derivatives just using Symbolic Python. The friend that we have to use all the
time, NumPy. And then the Pyplot module here, Matplotlib. So import Matplotlib.pyplot as
PLT, so using that namespace abbreviation. Well, NP and SYM as well, namespace abbreviations that
you'll see all over the show. And then to take ultimate control over how we put a bunch of plots
in one figure, we'll use the GridSpec module. So import Matplotlib.gridspec as GridSpec. And
because I'm recording this on MacBook Pro, we'll just set the inline backend figure format there to
Retina to have the high DPI plots displayed to the screen. So they look a lot crisper. Now you can
set your themes, if you're into that sort of thing, set your themes. And so plt.style.available,
the available attribute there. And you can see the bunch of styles that we can use now. I just want
to warn you, if you've got to have a tick installation on your machine, and you've got to
have science plots. I've got to have that package installed as well to see all of these. If you
don't have, there'll be a subset of these modules, or actually these styles available to you. And we're
just going to stick with the default here. I just want to show you that you can also tinker with the
backend that Matplotlib uses to do create these actual plots. And you don't have to be too concerned
about that. I'm just showing you here. I've set the backend to Mac OS X. And so you can read up on
all these things, little bits of information as you start getting used to Matplotlib. There might
be a bunch of stuff you want to do. I'm telling you about all of that. Depending on your coding
environment, what you're using, you might have to run this magic command, Matplotlib, inline.
You might not have to. But certainly here, it's just going to allow us to plot, generate the plots
inline with our code. So a quick introduction here to the notebook. Let's get back. And we're
going to just use the PyPlot module to generate some basic plots. Quick plots with the PyPlot
interface. So there we go. Line plots and scatter plots, which are basically the same thing,
depending on how you set up the plot. First of all, it's a plot. It's got two axes, an X-axis and
Y-axis. It's a Cartesian plane. And we've got to have X-coordinates and Y-coordinates. So what we're
doing here is just generating some values for ourselves to plot. And I'm going to use the computer
variable names X-vals and then Y-vals underscore one and Y-vals underscore two. So those will be my
X and Y-coordinates. And I'm having, you know, I've got two different sets of Y-coordinates for the
same set of X-coordinates. And I'm using the lint space function from NumPy there. It has a start
value, stop value, and then how many points you want, how many values you want for that array that
it's going to create. And you can think of the array just as a vector of values for your X-coordinates and
then your Y-coordinates. So we're going to start at zero and end at four pi. So NumPy dot pi for
the irrational number pi there. And we want 50 values in that interval. So zero is going to be
included. And of course, four times pi exactly is not going to be included. And then what we're
going to do is I've got these two arrays and I'm going to add them to each other. So the first one is
the sign of each of these 50 values. And to that I add element wise, this second array that also
contains 50 values. And it is 50 values because I'm passing x valves to the len function. So that's
going to give us this 50. And what I want is 50 values from the NumPy random module and the rand n,
that standard normal distribution, mean of zero standard deviation of one. And all I'm doing is just
multiplying each one by 0.1. So that's going to broadcast to every element in this 50 element array.
And I'm adding this 50 element array to this 50 element array. So that one to that one. So we're
just adding some random noise to the sign value of each. And I'm doing it again for y valves underscore
two. And because I want to draw two plots basically, or two figure two sets of information in this same
figure. So that's basically the plot function in the PyPlot module. So PLT, that namespace abbreviation
we had for matplotlib.pyplot. So dot plot. And all I'm passing is this array of x-coordinate values
and the array of y-coordinate values. And that's all I'm doing. Well, I've added a little bit there.
I've added a semicolon. If you use a notebook like this, there's some other information that
matplotlib generates with these plots. And that's going to be printed to the screen as well.
And you can just suppress that by using the semicolon. And I don't have to put plt.show
because in the Jupyter environment, that's going to be done for you. So if you've seen
plt.show everywhere, you certainly don't need to do that. And here we go. We see the raggedy little
line here. Sort of you can see the sine wave coming out for every x value. And you see we're
going from about zero to about four pi. So that's just over 12 there towards 13. And but I've only got
50 x values in that interval. So you can well imagine what's happening here is there's some
interpolation happening. So there's just these little straight lines drawn in between each of
these 50 xy-coordinate points. So that looks a bit ugly. And we can certainly do a lot more. So we're
imagining that, you know, these are values, perhaps it's over time and some, some independent, some
dependent value depending on what time is. And we've ran the experiment twice. So let's get going. Now,
you can see here, this is the code that we can use for our first plot over there. And you see,
I'm using plt.plot, plt.plot, and then all sorts of other things, legend, xlabel,
and each one of them take a bunch of arguments and keyword arguments. I'm just going to use the
word argument. I won't specify when something is an argument and a keyword argument. But you know,
there's the difference difference between the two. Remember, keyword argument, you actually have to use
the argument's name, that's a keyword argument. And then with a normal argument, you can just pass the
values. Anyway, there's a bunch of these arguments for each of these functions. And for some of them,
I just want to use the same value over and over again. So I'm just defining them as variables here,
assigning them to computer variable names. So I'm going to have one called marker underscore type.
And you see, I'm assigning a string to that. And it's a lowercase o dash dash. And that's going to
be the type of marker. And it's a shorthand notation for making my markers into round little circles,
and my interpolation making those dashed lines. Simple as that. I'm defining two colors. And I'm
using actual color names as strings. One is dodger blue, and the other one's orange red. And I'm
assigning that to color underscore one, color underscore two. I'm assigning the integer one to
this computer variable lw, six to the computer variable ms. And then these two strings to two more
variables, label underscore one, label underscore two. So what I'm going to do in this tutorial,
I'm just going to run this code, plotting the plot, and you'll see what it looks like. And then we'll
go line by line to see, you know, what happens. So there, there we go, beautiful plot, lots of
information there, you can clearly see that we have these 50 values, it's two colors there. And it
clearly shows in the legend that that would be, you know, data from two experiments, experiment one
and experiment two. So we ran this twice. And those were the results that we calculated, you can see
a title at the top position over time, you can imagine that this was a type of experiment that
generated a position at different time points. So on the x axis, I have an x axis label there,
time, and then I have units, then square brackets, microseconds. So you see a little bit of tech code
there, the micro symbol. And then on the y axis, I have a label position and the units cm centimeters.
So how did we generate all of this? Oh, by the way, you can also see the gray grid there,
all sorts of things. So let's see how we generated this. The first thing we did line number one here,
plt dot figure. So a figure in matplotlib, that's the blank canvas onto which you plot things. And we
get to the object oriented interface, we'll see that each one of these things are called axes. So this is
an axis on a figure. So the figure is this blank canvas. And then we have all these axes on different
axes. And then when we use the object oriented interface, we'll see we can do more than one plot,
you know, on the same blank figure canvas. Now I'm only using one of the arguments here. Now remember
always here, it's easy here in JupyterLab, I'm holding shift tab when I'm inside of where inside of the
function there, where I would place my arguments, shift tab, and it's going to give you the help
section. And you can see the num, fixed size, DPI, face color, edge color, frame on, figure class,
clear, and then a bunch of other keyword arguments that you could do. And I'm only using fixed size
here. So it's going to give me the inches, 10 inch by six inch. So depending on the DPI, when you save
this and print it out, you know, your mileage is going to vary regarding how big this figure is actually
going to print out if you if you do go to print. But on the screen here, 10 across and six up. So
it's width and height, you know, sort of nice enough for us to make a video recording of see what's going
on. So it's a tuple that we assign to this keyword argument fixed size. And then plt dot plot plt dot
plots, you can see in the same figure, I'm calling it twice, you know, one is going to be the the blue set
of data and one red, orange, dodger blue and orange, red, I should say. So the plot, as we did with a
bare bones one, it's x valves and y valves, that's all we're going to do. Just the two sets of arrays for x and
y coordinate values. And that's going to be, of course, all be the all the markers that you can see here, not
the interpolated lines, because any of 50 on this little interval. And then marker type, remember marker type was
the string here, and lowercase, oh, and then dash dash, that means the mark itself, the little round
marker, and there's a bunch of them. And then dash dash dash, minus minus, that'll be the stashed line.
And then color, keyword argument column sitting there to color one, remember, that was dodger blue, that was a
word. So it's saved as a string. So there are many colors that are actually named colors. LW, I'm
assigning that keyword argument to this computer variable LW. And to that, I've assigned the integer
one. So line weight is one. MS is the marker size. So that's going to be six there, because we had a six
up there. And label equals label one, label label one is experiment one. So if I put a label value there,
and we see here is legend. If I use the legend function, it's going to draw to create this little
legend here, experiment one and experiment two, it's going to use these values that you assign there.
So I'm doing it again for Y vales two, and the second color, no problem. So the legend function,
then I can place it in certain parts. Now you can, there's lots of granularity here, but
the common ones are upper right as strings, upper right, upper left, bottom right, bottom left,
and center, I think there's as well. So but there's more granularity about exactly where you want to put
it. But we'll get to that. And this one I'm putting in the upper right. And I'm setting a font size. So
once again, let's just go right at the start, hit shift tab. And you can see there's all the things
that you can do there with the legend. All sorts of things there. So at the moment, all I've done is
the location and the font size. And then the x label. So you see, I've got a bit of tech in there.
So there's a subset of tech in Matplotlib that you can use. And the way that we're going to do that is
pass a raw string. So the R there. So that is just going to ignore, you know, escape characters, etc.
But it'll still read all of my LARTECH code here, which goes inside of a set of dollar symbols.
So left, backslash left, and then the left square bracket, you know, that opens the square
bracket, and it'll size it appropriately. Otherwise, you could just use the left square
bracket, but then it won't be sized. Backslash MU, that's new for the micro symbol, and S,
and then the right square bracket. So that gives me time, as you can see at the bottom time,
and then the units microseconds. Y label, as we can see there, I'm just giving that a font size,
and then it's just position and centimeters. And then the title function, I'm giving that a string
value, position over time, and a font size. And with title as well, it's just a shift tab,
there's a bunch of things you can do. And then this font to dict, I mean, I just put font size there,
but you can put a lot of things there. And you can place them all in a dictionary and assign that to
the font tick keyword argument there. So there's various ways you can go about this. If you just
use them separately like this, so just the font size, you can just use them as is. The grid is
going to generate this gray grid in the background, and that's always good to see in these scientific
plots. And then the tick, tick params, so plt.tick underscore params. So you'll see this,
the values on the x and y axis, 0, 2, 4, 6, 8, 10, 12 on the x axis, minus 1, minus a half,
zero, half one on the y axis. But you also see, if you look very closely, and depending on what
resolution on YouTube, you're watching this in, and your screen, you might see these little black
little ticks. Now those are major ticks, you also get minor ticks, smaller ones, and you can set how
long they are, and their color, and all sorts of things you can set. But here, I'm just using the
which argument, I'm setting that to both. So that's both minor, major, minor tick marks. And I'm
setting the direction to in. There's also out and some other ones, and that just means they point
inwards into the axes, instead of pointing outwards towards the numbers. So I like to do that,
sort of like this looks a little bit better. So there you go. It's a bunch of stuff, and that's
what we're going to do in this tutorial. So I'm just going to generate these plots, and they'll have
different keyword arguments, different arguments, different functions from Matplotlib, different ways
of setting up the plot. And that's how you learn. That's how you learn. So you can see there, the
color, we said dodger blue, I think, and red, orange. But there's also these little shortcut colors,
K, W, R, G, B, C, M, Y. And that's for black, white, red, green, black, white, red, green, and blue,
and cyan, magenta, and yellow. You can just specify a value.
So color equals, and 0.5. So on that interval 0 to 1, that's just simply going to give you a shade
of gray. Or you can use hexadecimal colors there. So color equals, and then there's a string,
a pound symbol, or hashtag, and then the sets of, three sets of two values there,
to give you the intensity of your red, green, and blue pixels there. So you can set a color,
any color that you want. Great stuff. And the next one, we're going to add a model.
To our data instead of that interpolation. So I'm just going to generate the plot so you can see
what's happening here. So what's different here? First of all, we don't have the interpolation
between our data points. Instead, we, you know, we think that this is the model for our data. So
it's this little sine curve, obviously, that we just put in there. But now the legend is not,
if we look back up here, you know, experiment one and experiment two, they were written as two rows
in our column. Here we have a single row with three columns. And we print it that way. So that's
one little difference. So first, we just generated these values for our x, y coordinates
and to create this model, the sine curve there. So I'm just lint space again from zero to four pi.
But this time, I'm just ramping it up from 50 points on my x-axis to 200 points. So that gives me
a little finer detail and when the interpolation happens so that you draw a continuous line as you
would do taking a pencil to paper. So just putting more in there just gives me a lot of more to work
with. And my model, we're just saying, well, that's the sine of all my x values. So fixed size, we put
there plot x vales, y vales one. And this time, I'm not using dashes. I'm just saying just a lowercase
0. So that is just going to give me these round markers. Still same color, same size, still same
label. So nothing's changed there. So I'm adding a third plot there. That's x vales underscore model.
These are the ones I've generated up here. And then just a dash, a single dash. That means a straight
line. So interpolate with a nice, you know, with a nice line. And because I've got 200 points on this
interval, it's going to look, you know, quite smooth. And then the label that I give it so that
the legend function knows what to do. So the legend function, again, the location, the font size,
but now I have in call, and I'm seeing that equal to three. Now, so it means, you know, I have three
columns for my legend. So all three of those labels, because I've got one label to label three labels,
each going to go into one column in a single row. So that's how we got that. Our labels are still the
same. And what I've done here is a new one, ylim. So the y axis limits, and I've used the top
argument, then I'm sending that to 1.5. So it's going a bit higher. And the reason why I did that
is just because I have this legend here in the top right, and it can encroach a little bit on the data
itself or your model or whatever you're plotting there. So if you can set that a bit higher, or but
you can also do xlim, of course, and do bottom and left and right, etc, just so that you give
yourself some extra room. So that would be, you know, you've got to think about these plots, not
just use code and, and the same sort of generic code all the time, you've got to look at what the plot
is and sort of change things accordingly. And I'm putting the grid in and I'm doing the same with a,
with a tick parameters. So without these, the interpolation, of course, if we take away the
model, this is just a scatter plot of x, y coordinate values. So let's do a little bit of
that. I'm creating two sets of values again to arrays in depth and depth for independent and
dependent variable values. I'm using a rand in play from the random modules, random integers from
on the interval 100 to 300 and 150 of them. And then each one of them by broadcasting, I divide by two.
And then my dependent is just going to be times 0.8 times a bit of random noise there,
once again. But this time, it just comes from a uniform distribution of
the values in this interval negative 10 to 10. So let's see what this looks like.
This is a scatter plot. And that's just because, you know, again, it's just that O
that I'm doing on the plot. So still the x values, the y values, and then the type of marker. So
there's no dash there. So it's not trying to put a line in there. It's just the actual markers.
I've got a title, an x label, a y label, no problems there. And then the grid, I've changed
up a little bit. So I'm saying grid equals true. So this time, I'm using the true argument there.
And then I'm setting a color. So if I set color 0.5, remember, that's just going to give me scales
of gray. So it's like 50% gray there. And then I'm defining what the dashes look like as a tuple.
So it's, it's line, space, line, space. So I want a line length of five, then a space of length two,
then a line length of one, and then another space of two. And then it'll go to the front again,
line space of five. So you can see these long dashes, short dashes, long dashes, short dashes,
with a sort of two points in between each. So you can really define exactly, you know, what your grid
is going to look like. And there's lots more granularity there if you, if you care to look that up.
So that's great stuff. But there's also the scatter function here in the pie plot module.
So what I'm going to do is create two more independent variables. And they both come
also from uniform distribution and 50 values of each because on a scatter plot, you can actually have
information about four variables. So let's run this code and see, we have a different marker size,
and we have a different color. So we're using plt.scatter here instead of plot, I'm still have
my x and y coordinates, the size now s equals, that's these values up here. So each one of them
will have a different size. And then c for color, they'll each have a different color. And I'm just
setting some transparency there with the alpha argument alpha equals 0.5. So that's four numerical
variables that are represented by this scatter plot. Great stuff. Now, what we've seen up till now is
that both our x and y axes are linear, but we can also use other scales. So what we're going to do
here is just do the log scale. So I'm going to create a computer variable here, VALS for log,
VALS underscore four underscore log. And I'm using some list comprehension there. So I'm saying 10 to the
the power i for i in range 10. So it's 10 to the power 0, 10 to the power 1, 10 to the power 2, up
till 10 to the power 9. And then we're going to plot that. So let's have a look at this.
And what we can see here on the y axis, that's a log base 10 scale, 10 to the power 1, well,
10 to the power 0 is down here. 10 to the power 1, 3, 5, 7, 9. And we have a linear scale on the x axis.
So how do we do that? I've still got my figure there. I've got my plot. And what I'm saying is
VALS for log. So all I have here at the moment is just one set of values. Remember, we had x
coordinates and y coordinates. So if you just put one set there, it is going to do take those as the
as the as the y coordinates. And what it's going to do is just going to do 0, 1, 2, 3, 4, 5, 6,
7 on the x axis. So it's going to say it's point, the first value on that, this y is essentially going
to be the y coordinate values. The first one is at x position 0, the second one is at x position 1,
then 2, then 3, then 4. So that's what's going to happen if you just put those in.
And of course, you can see there, there's a mark and a dashed line, you know how to do that now.
And I'm setting specifically that my y scale is log. So PLT dot y scale, and I'm setting that to log.
So it knows and the default is log base 10. And, and then as per usual, I'm using a bit of latex there,
you've seen how to do that as a raw raw text as well. Just you can do either of those I'm putting
in a grid, nothing else different. So that'll be that log scale. What about if we want to do the
the same for the x axis? So let's have a look at this. There we do. There we go. So I'm now saying
plot the x scale is now log. Plot dot x scale is now log. So it's going to put that log values on the
x axis for me. And you've seen what happened to the y axis now. That is this again, 0, 1, 2, 3, 4.
No problems there.
What about different log scales? So my x coordinates is going to be base 10. And my y
scale is going to be base 2. So I'm just generating x and y values there. Let's have a look at the plot.
And you can see it's still a straight line. Because on the x axis here, I have log base 10. On the y
axis, I have log base 2. So how do I do that? I use the semi log x and semi log y. The default is
base 10. So I don't have to put anything there for the x axis. But for the y axis, I put the base as
2. And that's going to give me the space 2 values. So we do have values, you know, which definitely will
not give us a straight line on the Cartesian plane. But now I have different log scales there,
and I get my straight line. If both of them have the same base, so let's generate some values there,
both base 10, I can just use the plt.loglog. And that'll do both of the axes. And I set a base there,
base 10. So now we have them both as base 10 and still our straight line there. So that's how to deal
with the log scale. So that's it for lines and markers, you know, scatter plots. Let's move on to
frequency plots. Now we can do both the continuous numerical variable and categorical variables.
When it comes to frequency charts, if it's continuous numerical, we'll talk about a
histogram. And if it's categorical variables, we just count the frequency, that's going to be a bar
plot. Although we can also use the sort of mean and errors, error bars when it comes to bar plots.
Let's have a look. So frequency plots, we're going to start with a histogram. So we're just generating
two sets of values here, two arrays, I'm going to generate 1000 elements in this array
from a normal distribution with a mean of 100 and a standard deviation of 10. And the second one
with a mean of 98, a standard deviation of 15. So I'm using numpy to generate those random variables
for me. And then we're going to use the hist function, plt.hist. So let me show you what it
looks like. And I'm not using the semicolon because I actually want to show you everything that gets
generated by this function. So the first thing we have is an array 6, 27, 67, 151. And that's the height of
each of these bars in my histogram. And you can see that it's a continuous numerical variable because
there's no gaps between these, between the bars. So what happens with a continuous numerical variable,
of course, there's binning. So there's a low and upper limit for each bin. And we're just counting
how many of our 1000 values fell into that little interval. And we can see in our first interval,
there were six values and our second interval 27, third one 67. That's what it does. The second array
that you can see there, that's actually the limits, the intervals of these bins. So it went from 68.4496
to 74. So that will be the interval of this first little bar here, and then the second interval. So
you can see what, what matplotlib decided to do by default to generate the intervals for these bins.
So that's, that's sort of quite important. Now that's an ugly histogram. So we certainly do a bit
better. One thing we might want to do and say, well, depending on our data, it might be more natural
to have, you know, bin size, that's a bit, bins sizes that are a bit different. Maybe we want to go
from 70 to 80, 80 to 90, 90 to 100, 100 to 110. So I'm going to do that with a bit of list comprehension
there, create a computer variable called bin underscore intv for bin interval. As I said, using this
comprehension there, so it's 10 times I, and I is the range from 6 to 15. So that's going to be 60,
70, 80, 90, up till 140, if you think about that. And now I'm going to pass that to the, that, that
python list to the bins argument. And there we go. So now we see these bins 60 to 70, 70 to 80,
80 to 90, 90 to 100. Now let's do a little bit more. Let's run the code, see what we get, and we can run
through it. So that looks to me looks like a little bit of a better histogram. Of course,
the text is a bit too big, the title and the access labels are too big, and the legend's too big. But,
you know, I want you to see it on the screen. So first of all, you can see that we now have these
sort of step function to show off our histogram. That looks a little bit better. We can see that we
have for both experiments, basically, we have the histogram for both sets of values. And we have our
legend way off of the figure, it's away from the figure. So how did we go about that? We still have
our fixed size there. We're using hist. And of course, we're using var underscore, underscore group
underscore one, it was our first array. And I'm just setting the number of bins this time. So you
can see there for the for this one group one here, you can see there, it starts just below 70, and then
goes here to about 74 point something there. But if you count them, there'll be 10 bins. And all we
can see with a step is the outside of all my little rectangles, making up the frequency chart, the
histogram. So I'm just stating I want 10. And what happens is matplotlib will look at the minimum,
the maximum value, you know, make 10 intervals, and that's it. And how I get the step is by doing a
hist type and setting that to step the string step there. I'm putting a label so that I have something
for my legend function to do. So for the orange one, though, we're putting this bin underscore intv. So
you can see that goes from 60 to 70 70 to 80. The hist type is still step. And the label is group two.
Now for the legend, we've got font size equals 12, but too big. Now we've got this b box to anchor,
and we see this tuple assigned to that keyword argument. And what we have here is the bottom
left is 00, the top right is 11. So from 00, that's 0% to 100%. So we gain 1.05. So 5% over the maximum
on the x axis. And that's why it's over beyond the plot itself, and then 100%. So right at the top
on the y axis, I'm saying frame on is false. Remember, there's this little frame around it,
and I'm giving it a title groups. And you can change the size of that too, because that looks
a little bit small. And that's how you get sort of this kind of plot, which starting to look a bit
better. Now, bar charts is for counting. So let's create these four classes ABCD, saving them as a
Python list. Two categories, I'm going to do random choice of the classes 500. And that's with
replacement, so it's going to be A, C, B, B, C, A, B, D, D, B, etc. And I'm doing that twice,
assigning that. And now we're going to use the unique function in Python. And that's going to give
us back two things, the array of unique values. And we know where it came from, because we generated
those four, you know, the four classes. And then we've got this returns, return underscore counts
argument set to true. So it's also going to return the counts. So there were 130 A's,
121 B's, 117 C's, and 132 D's here in cat underscore group underscore one.
So what I'm going to do now is just use a bit of indexing, because I've got these,
the tuple of two values, the two arrays there. So I'm just referencing array number one,
that's the second one. So all I'm saving here is those values, 130, 121, 117, and 132.
I've got my classes saved, so now I have these independent of each other.
Now the ABCD and the count of each one of those for both cat one and cat two there.
So let's generate this figure and see, this is what it looks like, a very boring bar chart.
And it's just a frequency chart. And my variable is nominal categorical. I suppose you could say
it's ordinal categorical, but it's categorical nonetheless, ABCD. And for group one and group two,
I'm just showing you the count of each. So how did I do this grouped bar chart?
Well, it's plt.figure and then bar, plot plt.bar. Now you've got to, you know,
just hang on in there, because it's not so easy just to get these correctly aligned here at the
bottom. Because this axis wants to be numerical, it wants to count 01234. And that's exactly what we
give it we say numpy dot a range for. So that's going to be 0123. And that's what we have the ABCD
0123. And I'm subtracting 0.2 from that. So it's going to be minus,
so 0 minus 0.2. So it's minus 0.8. And then the next one also subtracted. So 1 minus 0.2,
2 minus 0.2, and 3 minus 0.2. So this is actually shifted to the left. So this,
these dark gray bars actually just shifted to the left of 01234. Then the counts, remember these,
those were those counts, 130, 121. And that gives us the height of these bars.
Giving it a label group. So for the legend, you know, it has something to grab onto.
And then the color, I'm setting that to gray. Bar two, I'm moving everyone over 0.2 to the right.
And then the counts for the second one. And for both of these, you'll see 0.4, 0.4. That's how wide
things are. And because I've split the centers, negative 0.2 to the one side and 0.2 to the other side,
they're going to basically just line up very nicely with each other. So no problems there.
Other than the fact that I still have 01234 at the bottom, which I have to change. And that's
what I do with the x-tix function. So again, the x-tix are going to be range 4,
or numpy.a range 4. It's going to give you the array or list, doesn't matter. So that's 01234.
And then I replace that with the classes. That's ABCD. So 0 is going to become A,
2 is going to become B, 2 is going to become C, and 3 is going to become D. So that I have ABCD
at the bottom instead of 01234. Clever. I have my legend. And again, I'm setting in call to 2,
so that it's like two columns there, horizontal instead of stacked. And I'm generating a bit more
space at the top so that these bars don't run into my legend there by setting the y-limb. And that's how
you would do that. Of course, you can use bar plots just for statistics as well for different groups
as far as a numerical variable is concerned. So let's, you know, do something a little bit
different. I'm going to say aluminum and copper. And I'm going to take from a normal distribution
100 values of each. And you can see the mean there and the standard deviation there from which these two
sets of values are generated. And I'm just going to save the mean and the standard deviation of each
of those arrays. So numpy dot mean, numpy dot standard deviation. Remember, this is a sample,
not a population. So in our denominator there, we're subtracting 1 when we calculate the standard
deviation or the variance first, at least. So you've got to put DDOF there. The degrees of freedom
there is 1 so that you calculate the sample variance or sample standard deviation and not the population
standard deviation. But anyway, I've saved those two. And now what I'm going to do is the following.
So let's just generate the plot first and you can see what happens. So we have aluminum on the left
hand side, copper on the right hand side. And this would be, say, for instance, like coefficient or
thermal expansion. And you can see the bars go up to the mean. And we're using the standard deviation
as the error bars. So not confidence intervals or anything. We're using standard deviation in this
instance, just to keep things easy. And those were the two error bars. So how do we do that? The
figure again, fixed size, nothing new bar, nothing new. So again, range two. So that's going to give me
on the x axis is zero and a one. And then here with the x sticks, remember, I'm just changing those,
I'm swapping out zero and one with aluminum and copper, or aluminum if you from certain parts of the
world. So the height of the bars, I'm just setting that as a Python list. So the mean of aluminum and
the mean of copper. 0.4 again, the width. And then y error, that is what's going to do the error bars for
us. And I'm passing the standard deviation of each of those as a list. Align these error bars to the
center. Cap size is eight. That's the little horizontal bars there. The color is black. And
that would be black for these, not the error bars themselves, but the actual bars of the bar plot.
But I'm setting an alpha value of only 10%, 0.1. So they're like light gray. Title and x-text we spoke
about and the label. And once again, I've got a bit of latte code there to show the degrees per degree
Celsius, the coefficient of thermal expansion there. And we see four aluminum and copper there.
Of course, I don't like bar charts for that. You can definitely go a bit differently.
First of all, what I did here is just a different kind of error bar by not using error as we did here,
not using it separately or as an argument inside of the bar function. But there is an error bar,
PLT dot error bar function itself. And I'm doing exactly the same as what we had before. But this
time around, I can say that I want a dot in the middle and I want the color. And so you can specify
a little bit more about how these error bars would look. The way that I would do that though, is just
use the error bars on their own. I think this looks better, but might be different for you. So it's just
PLT dot error bar, range of zero and one. So I still have aluminum and copper there, which I replaced
by the X sticks that you know about now over there. I still got a title there, Y label, put a bit more
space on the top because this error bar was getting close to the top. So I've increased Y limb a little
bit there. And then as far as the error bar is concerned, again, I can put a D as diamond before
we had the O there. Now I've put a D for diamond. So you can see the diamond there. And you can do all
sorts of other things to improve the look of these. But that's certainly, you know, one way that
we are sort of sort of abusing a frequency chart to generate these or place these error bars.
One more chart type that you see all over the show, not my favorite type of chart, the box and
whisker plot, it's going to give us the same sort of information that a histogram is going to do for
continuous numerical variable, other than the fact that it's working with a quantile. So you'll have
the quartile values here. And this is what it looks like. So let's see how we generated all of this.
So if you don't know, this bar or this box in the middle, I should say the lower end of that
is the first quartile value, the upper one is the third quartile. You'll see if you look very closely,
there's two lines there in the middle, there's a little orange line that would be the median,
and then there's this dashed line that will be the mean. And then the little notches at the moment
are set to indicate the 95% confidence intervals around the median. And we're using a bit of bootstrapping
there to calculate the values there for those notches. So how do we go about it? PLT dot figure,
nothing new. Box plot is brand new. I want two sets of values. So when we did the histogram,
var underscore group underscore one, var underscore group underscore two, those were just the arrays of
values, continuous numerical variables. I'm putting flyer props out there with a marker D for diamond.
And these statistical outliers, so there were no statistical outliers.
These whiskers would go out to a minimum and maximum value. But if there are outliers,
they'd be values that are more than 1.5 times the interquartile range. The interquartile range
remembers the difference between the value at the first and the third quartiles. Multiply that by 1.5,
add that to the first quartile, subtracted from the first quartile, and any values beyond that would be
be suspected statistical outliers. So that's how that would happen. I've put the mean line to true
and show means to true. So you've got to do both of those to have that tiny little dashed line there,
which you can hardly see. So it's only when you have very skewed data that the mean and the median will
not be close to each other, of course, and it'll make a bit more sense. The notch is true
this time. And what we're doing is we're setting bootstrap equals 5000. So it's 5000 bootstrap
re-samples. And we're using percentiles then, of course, to work out the up and lower limits of
that confidence interval. So title, label, label, x ticks. Remember the x ticks, we had to do exactly the
same thing. So there I'm just doing one and two becomes group one and group two. That's how we did
that. The param, the tick params, the grid. And then something a bit new. I'm saying plt.gca,
get current axis, axis, axes. And there's only one axis on this figure. And when we get to the object
oriented interface, you'll understand what that's all about. So I'm getting that axis, that's this
whole plot on this figure. And I'm setting that to ax. And then I'm saying ax.set underscore frame
underscore on to false. And you can see the frame that goes around, that's now gone. But you can only
do that really in the object oriented interface, or it's easier to do it with object oriented interface.
But to get to that, I had to use plt.get current axes. And there's only one here. In a few minutes,
you'll understand what's happening there. I'm just setting this frame to be off.
Okay, enough of using the pipe plot sort of interface. Let's go to object oriented,
object oriented interface. And that allows us a much more control over what kind of axes we can put on a
blank canvas called a figure. There we go, the object oriented interface. And that, as I mentioned,
now gives us a lot more control, you can click there to read a little bit more about it. So let's
just go back to a simple plot. It's plt.plot. I've got my x valves, y valves, just put the O there,
so it's going to be a scatter plot. And we put a little bit of a title there. There's
sine wave with a bit of a random noise added to that. Now we've seen before that I can do the same
and use this plt.gca to get these axes. And I've assigned that to the computer variable name ax,
ax. And the type of ax, if we use there, we can see it's a matplotlib dot axes dot underscore subplots
dot axes subplot. So the axes is one thing that's on on top of this whole big figure thing.
And the way that we get to all of this, I'm just using ax again there, you'll see we can use
different, you can use anything there, depending on what makes sense. This would be typical fig dot ax,
because this plt dot subplots, it has two things, this outer figure, the big thing,
the blank canvas, and then ax are all the different plots that we put on this blank canvas.
And I'm not specifying anything there. So that's just going to give us this one blank canvas, because
we haven't specified anything to plot on this figure. And so there's, you know, there's one,
sort of one axis on this blank figure canvas, basically. And now x, ax, a plot itself has
nothing in it. So let's put something in there. So just a little bit of stuff we're going to put in
at the moment. So I'm going fig dot ax equals plt dot subplots. And this time, I'm passing two values
there, three comma two, that says, put three rows of axes and two columns of axes. So six plots,
all in all on the same figure, I'm making the fix size quite big 16 by nine. And now,
because I now have six plots in three rows and two columns of them, I've got to use indexing,
you know, to identify each of them. And because I have rows and columns, that's along two dimensions.
So it's a array with along two dimensions. Now I've got to specify first the rows and then the columns.
So I'm saying ax and then zero. So that'll be in the first row and the first column. So that'll be
the top left one. I'm assigning that to the computer variable ax one. And then ax one is now
what plt dot plot would have been before. And this time, I'm just using a set underscore title. And
you'll see when we use this object oriented notation, lots of our functions that used to
just be plt dot title now become set underscore. So there's usually a set underscore between,
so I'm just setting the title. And then I'm going for ax six, my last one. So that will be in row two,
column one. So remember zero index, so that actually the third row, the second column,
that will be the bottom right one. And I'm just setting a title there. And then plt dot
title underscore layout, you'll want to use that many times because what matplotlib will do,
if you've got many axes on the same figure canvas, you know, things might overlap a bit. And it just
decides how to put a bit of padding in between things. So there's no overlap. And there's a bunch of,
obviously a bunch of arguments that you can set there. So that's what it looks like. And that's what I
said, we have three rows and two columns of plots. And each one of them is an axes, because, you know,
each one of them is a Cartesian coordinate system here, two axes. So that whole thing is an axes,
and there's six of them. And as you can see, I referenced 00 to put a, then to put a set title
there on that one. And then this bottom one here, put a title there. And that's as simple as that.
It's just that we use the subplots function. Now, there's many ways to go about this. So
this would be one way, but we'll get to that. So subplots, plt dot subplots,
and we have fig comma ax. So we've got a, you know, it generates two things, the blank canvas,
and then all the plots that go on there. Great stuff. Let's have a look at this one. Let's run the
code and see what it is. It's a plot inside of a plot, because now things become really interesting.
So this would be one other way to go about adding different axes. Before we said fig comma ax and
using the plt dot subplots, this would be another way to go about it. So I'm showing you two things
here. Another way to go about it and how to plot a plot inside another plot. So anyway, I'm generating
this fig underscore one. It's plt dot figure, fig size six by four. And then I'm saying fig underscore
one dot add axes. So instead of using the subplots that already gave me access to the axes,
I'm just adding one by one to the figure now. And that allows me to specify on this blank canvas,
how much of this blank canvas does it take up? Because it takes this Python list argument,
and it goes left bottom width and height. So I'm saying start on this blank canvas 5% from the left
and 5% from the bottom, because it's 00 on the top left and 11 in the bottom left to 11 on the top
right. I'm starting saying starting 0.5% over on the left side 0.5% up from the bottom. And then 0.95
0.95. That's the width and the height. So then I'm using 95% of the width. That's what's sort of
left behind left over for me and 95% of the height. And then I'm just plotting a title on there. So you
can see where it goes. And now I'm adding another axis. So another add axis, I'm saying go 60% up from
the bottom, go 60% up from the left and then 60% up from the bottom. And then use 30% of the width
and 30% of the width of this figure. And I've just added another title there so that you can see the
two different axes here on the same figure canvas. So remember, that's one way to go about it. Just do
a normal PLT.figure and then add individual axes or use the subplots, specify how many they're going
to be. And then just reference each of them. Now we had to use two indices there for row and column.
If I, for instance, if I had 3,1, that's three rows and just one column, I wouldn't have to use two
indices because that'll be an array of just along a single dimension. We'll see that in a little bit.
Great stuff. Let's do this one. And we've seen that actually before.
That's that I now can use set underscore, set underscore frame underscore on and I put that
to false. And this time I'm doing PLT dot subplots one comma one. That's just one. That would be the
same as just having PLT dot plot. But now, you know, I have access to more things now.
One thing I might have access to is these spines. So yeah, we've removed all of them. So these the
frame is actually called spines. So I'm going to use the set underscore visible method here. So I'm
saying fig comma ax equals PLT dot subplots one comma one. So it's just the one I'm saying ax.
That's now this, you know, my plot on my blank canvas, spines the top one set visible to false
and set right to false. And that what that's going to do, of course, is just take away the right and
the top one. And you might want to generate that kind of plot. Next one, I'm going to run these two
lines of code. And that looks more like something, you know, that's getting towards a final product.
So look at all these things happening here. Let's get into how we generated it. First of all,
we've seen the two plots before, but now we're using the object oriented interface
just to put both of them on there. And I've got all sorts of text that I'm putting in here,
we can see this little one with a sigma underscore one sigma underscore two showing the standard deviation.
The mean is sort of implied in the plot by the height of the histogram, you know, where the histogram
sort of is high there, because it's kind of caution, I suppose. And then there, we have the standard deviation
of each of those. And our legend there looks slightly different. And here, we've only got
drids in one direction, all sorts of things. Let's go about all of this. First of all, this text that's
over here, you know, it can be quite a bit to type in. So we've just done it separately there.
So what is it that sigma underscore one equals and then the standard deviations. And then in the
second column, sigma underscore two equals that standard deviation. So how do we go about it?
Well, we're going to use this join. So this is text for new line. So I'm saying join the following two
things, the, that thing there, that whole thing, I can't get straight to the end, that whole thing there,
join that with a new line. So two lines, basically. So the first bit here, now there's this first bit
here, that is just going to be for us, just a bit of, you know, setting up Python to print values
inside of a string. So first of all, so raw string, it contains a bit of latex, I'm saying
sigma backslash sigma, that gives us the sigma symbol, underscore, that's the underscore one,
that gives us a subscript. And then equals, we're using this notation to get hold of what follows
there, which is an actual calculation, puts it inside of there, and only gives us two decimal places.
So dot 2f. And what it's supposed to put in this, in this place of this dot 2f is indicated by this
percent sign. And then we have the percent symbol. And what we want is the standard deviation. Now,
what did I get wrong here? Of course, this is from a sample. So I should have put DDOF equals one,
to give me a sample variance, a sample standard deviation. And anyway, I have the second one there
as well. And that's how we're going to get the text. And how are we going to go about this?
A new way. So fig dot, and instead of ax, and then I index the ax, I'm passing a tuple of ax's,
axes. So and I'm just calling them ax1 and ax2. So that I can, as you can see down here, refer to them
individually. It's going to be a subplot. So plt dot subplots, one comma two, one row, two columns,
and that's what we see, a fig size. And frame on equals false.
As far as the whole thing is concerned. So let's go to ax1 dot hist. So histogram for
var group one and var group two, we've seen that we've seen also that we setting the bin intervals,
we're setting it as a step instead of, you know, full on, we're setting a label for our legend to use.
And this time we're making the lines a bit thicker, we're setting two pixel line width there. So for both
of them there, that gives us the ability to use legend, because we set the label there,
we're putting it on the upper right, making a font size of eight, making it a two column one,
so that we're next to each other. We're making the edge color gray. And we're making the face color
light gray. If you're into that sort of thing, I think it looks ugly. But there you go, show you
that as possible. We're setting a title. So instead of plt dot title, it now becomes ax1 set underscore
title. And the y label and an x label, etc. And then the text, where do we position this text?
Well, there's a way just to do 00 to 11, the whole thing. But what we do here, if we don't,
if we just use what I can say, what I can call the default way, is just to look at the axis values
itself. So 60 on the x axis, there's the 60, and 200 on the y, it's up there. So it's going to put this
box around about there. And you've got to sort of experiment with it. Then put the text, remember,
which was this text that we had up there. And then bbox equals, and we're doing this
Python dictionary there, face color to white and edge color to gray. So a little gray edge color
and a white bounding box. So it's white on top of this grid. So you don't see the grid shining through.
And we can just call grid there. And then the box block we've seen before,
so there's nothing new there. Except for we set the frame to be off there.
The frame to be off. And what else did we change the x sticks labels, we've put them
there, the group one and group two, and you see we're not making use of any kind of overwrite there.
So set x sticks labels, we can just put group one and group two right there.
What else did we change? We have this right at the bottom experiment one.
So that's right at the bottom here. And that is on the canvas, not on the individual axis. So
there'd be fig, fig dot text, 0.5 is 50% across. We can also set that horizontal alignment to be centered.
So the horizontal alignment of the text there to be centered. And by the way, it's 5% below the bottom
margin of the whole figure. And we've got the text itself there and the font size.
And when we get to the grid here, before we just said ax1 dot grid, what we've got here is ax2 dot y
axis dot grid. So you can set them separately. And only that one is set to true so that we don't get
the vertical grid printed for us as well. Now, as I said here, we're using the 6200 and that pertains to
the actual coordinates on our plot. What we can do here, let's run this, is setting it all up a little
bit differently, and using grid spec. So let's have a look at grid spec. So fig is a plt dot figure,
I'm setting tight layout to true, doing that right as an argument, fix size 16 to 9. And now I'm saying
gs equals grid spec dot the grid spec function, uppercase g uppercase s, 2 comma 2. So I have two
rows and two columns. But what we can see here is that the first row is taken up by one single plot,
instead of having four plots in the two by two layout. So how do we go about that? ax1
is a fig dot add subplot. And then I say gs zero comma all. So ax1 is fig, remember, this is how we do
it, we can add a subplot separately before we had add axes, but add subplot. And we use the grid spec
to say row zero over all the columns. So that's going to give us over the whole thing. And we can
see the basic plot there. And then for ax2 is going to be a fig dot add subplot, and then the grid spec
one comma zero, so row one column zero, so that will be the second row, first column. And then over there,
we do the whole thing. And then over here, the second one. And you can see I've done things slightly
differently, the model is in there, and then the interpolated line is there. What I was going to show
what I didn't put in the plot is just this little text that caught my eye over here. Remember here,
I just spoke about the 600, 200. So let's get back to that. You can do the zero zero to one one
across the whole thing by setting this transform equals ax and whatever ax you're dealing with at
the moment, ax1 dot trans axis, low case t, upper case a. When you do that, instead of doing the actual
values, as far as what is on your grid is concerned, your x and y axis coordinates, you can then put
0.05 and 0.2, you know, to go 5% from the left side and 20% up. So you do that just by this extra
little argument that you have to set there. Great stuff. So grid spec is something I think,
in the end, if you generate reports, you'll use most of the time. Right, so the last section,
we're going to do some other type of scientific plots, where we're just going to use some
mathematical functions, we're going to look at vector fields and gradients, etc. And then lastly,
I'll just show you how to save plots. So plots for functions and vectors. First of all,
let's do a contour plot. You get two types of contour plots, one that's filled and one that's
not filled. So you get contour f and just contour. So let's consider this function in two variables,
just f of x and y is x squared plus y squared. Nothing magical going on there. We're going to now
generate a grid. So if you've never seen this numpy.meshgrid before, the first time you see it,
the first couple of times can be a bit slightly confusing. What it does is it creates a grid of
x and y coordinate values as simple as that. And what I'm doing here because my x and y coordinate
looks exactly the same as far as the interval is concerned. I'm just, you know, cheating a little
bit, just putting a single underscore there and numpy.lin space, negative one to one 200 values. So it's an
array of 200 values on that interval negative one to one. And now I'm placing this on the mesh grid,
it's the same set of 200 values in that array and the same array there. So that just gives me this
grid, you know, it starts at negative one, negative one, you know, on the bottom left and goes to one,
go to one, you know, just under one on the top right. So it's just this grid of values,
a comma b x comma y, you know, just creates that grid. And because my x and y looked exactly the
same, you know, I can just do this, otherwise, I would have done x and y separately and passed x
there and y there. And it's typical to assign that to uppercase x and uppercase y. And then my function
is x squared plus y squared. So what that does is because I have this grid of values of x comma y values,
at each one of those little points on this 2d grid, for that little point, it takes a value x squared
comma y squared. So you can well imagine then you can plot that can be your z axis and that's the height
along the z axis of any of those points. That's what mesh grid does, really not that difficult.
But let's create, instead of creating 3d plots, you know, which is kind of a hit or miss thing
most of the time, let's rather create a contour plot. I think that makes a lot more sense. So let's do
plt dot contour f, that's a full contour plot, x comma y, so that's still all my individual x values,
my individual y values, and then f at each one of those values will do, will do an x squared and y
squared. So remember that x and y comes from this grid being formed. So each one of those values will
do have this f value levels is how many contours I'm going to have. And we can using, we can use a
colour map, and I'm using the inferno colour map, there's many colour maps you can use. I'm also
adding a colour bar so that it's sort of a legend that we can read off from. By the colour we'll,
we'll see the different contours. And then putting a label onto that colour bar and then just putting
a title. So taking too long, let me show you what this plot looks like. There we go, it's a contour plot,
and it's x squared plus y squared, so you know what that looks like. And then they add 0, 0 in the
centre, that's way down here, dark, and then it goes as it goes out in all directions, lighter and
lighter, you know, as the z axis value goes up. And that's a filled contour plot. And there's 30 shades
there because we set the levels to 30. If you put less, of course, you're going to have larger gaps in
between. Let's just do that. Let's put 10 just to see what this all looks like. And now you can see
there's only 10. Now that's a filled one, but we can only do the contours themselves. So let's have
a look at the contours themselves. And so that looks very neat. So how did we do this, where we have the
actual values on those contours? So first of all, it's plt.contour, not contour f, exactly the same
stuff, x and y from our grid, f, the value at each of those grid values, I only want 10 levels, and I'm
using the plasma colour map here. But I've got to assign that to some variable, this time I've done c,
so that I can say plt.clabel. And the first argument is the whole contour plot. And then font size equals
eight. And what that's going to do is put these values, you know, one value on each of these little contours,
and it works out sort of where to put them, and then just the title. So very neat kind of plot there.
So let's do quiver plots for vectors. So first of all, I just want to show you how a vector is
generated. I've got a position here 00 and a direction 21. Save them as computer variables. And
let's plot this thing. So what it does is quiver. So this time we're using fig.ax, plt.subplots,
fig size equals three comma three, tiny little plot. And then the quiver function, ax, remember,
it's my axis on my canvas. x pass, y pass, so that's where it starts our little vector. And then
the values in the x and y direction. So there was two across and one up. And you can sort of see the
slope there, it's going to be a half. And then you can scale it, some scaling factor. And then I'm just
showing the axis, the axis, what is the limits for the x axis, comma, the y axis. So all that is
passed us there as a single Python list. And then I'm using the set underscore aspect function to equal,
so that we don't get distortion, because you know, it's rectangular, and you're distorting one of the
two axes. So that's, you know, to put one little vector on a vector field. And of course, that'd be hard
work if you had to do all of them. So we can do better. So let's just look at a little vector
function there. So in two unit vector directions, i hat and j hat, I have x over five minus y over
five. So you see two different notations there for how to write that vector. Of course, what we're
going to do is create a mesh grid again. So because x and y is going to be exactly the same, I can just
set, you know, one of them. So it's going to go from two to 2.2. And this time, it's the a range
function. So we're going up in steps of 0.2. We're setting that as a mesh grid. And because
I want exactly the same values for both x and y, I don't have to do them separately. And then I have
u and v. So how this works, you obviously don't have to use u and v. But this is common notation,
Matplotlib uses it as well. So this is a vector valued function, of course. So x over five is my x,
and negative y over five is my is my second function. And we denote that separately for
u and v. So u is x over five, and v is the minus y over five. And that denotes the direction basically,
or really. So let's look at this plot. There we go, we can see it. And there's our vector field.
And we've also got our little legend there to show our vector valid function.
So how do we go about this? We're using the same standard way of fig comma ax equals plt dot
subplots. We're putting a fig size, we're using quiver there for our ax, ax dot quiver. We're
passing the mesh grid values there. And then these two, the directions and the value for each of the
x direction and the y direction. We're setting the limits of our axes there, we set the axis aspect to
equal. And then we've give it a title. And now about this little text here at the bottom.
So I'm putting it at 00. So we're not using the trans axis thing. It's here at 00 using the grids
specifically. And I'm using a bit of Lartic there, as you can see. And then instead of just saying font
size equals 14, this is another way to go about things, a font dict. So you can use a dictionary
and there's lots of key value pairs, keys you can put inside of this font dictionary. I'm only using
font size there to be 14. And bbox. I'm also using a dictionary there by setting the face color to
white and the edge color to gray. So that I can plot right over some vectors that might be there and
they don't shine through because the box is now is now white. Great stuff. So there's our vector field F.
And by the way, with Lartic, you see my F there. And this time around, it's got a little arrow over
it to show that that is a vector. So instead of using math BB for blackboard, using the VEC Lartic code
there. So let's think about a multivariable function here. F of x and y is x squared minus
y squared. We want to take the gradient of that. Remember, that's how we do that. And that's the
Greek letter nabla. So you can see nabla there. So it is the partial derivative of f over x and the
partial derivative of f with respect to y. Or you can also write it f sub x. There's lots of notation for
that. But you know what the gradient is. Now, the first thing I sort of just want to show off
SymPy a bit because SymPy is one of my favorite packages. So let's make x and y mathematical
symbols. So some dot symbols and x and y. So now they're mathematical symbols. And I can set up this
computer variable x to hold x squared minus y squared. And you can see they are now no longer
computer variables, but mathematical symbols. So they'll print out nicely to the screen x squared minus
y squared. And I can take the first derivative, partial derivative with respect to x, f dot diff.
And I'm doing a first derivative, so only a single x with respect to x. And of course,
that function x squared minus y squared with a partial derivative with respect to x is just 2x.
And the partial derivative with respect to y is just 2y, minus 2y, it's x squared minus 2y.
And now I can evaluate that at certain values by using subs. So I'm saying f dot diff,
x, so it's a partial derivative of f with respect to x, at point 2 comma 2. So let's do 2 comma 2.
So I say dot subs, x comma 2. So x is 2, dot subs, y is 2. So what is that at point 2, 2? Of course,
that's 4. And when we substitute the partial derivative with respect to y at this point,
of course, we get negative 4. So we know at this point,
what that vector should look like. We've done that. So just a sort of sanity check when we
actually do our plot that things are working out. So I'm going to do my mesh grid as well,
going from negative 2 to 2. I'm setting up my two partial derivatives now, because remember what the
partial derivative is, is the slope at that point. So it's 2x, there it was, there we got the 2x there,
and negative 2y there for the two partial derivatives. We're setting that up as u and v.
And now let's see what the plot looks like. There's our gradient plot. So I've got my plot there. And
of course, you can see the saddle point there for x squared minus y squared. And I've got this little
mark at the top to show that the length of that vector is 10 units. So let's see how we put that up.
fx, ax, plt dot subplots. And I've got my quiver again as per normal. But this time,
I'm assigning that to a computer variable because I've got this function quiver key. And the first
argument is the whole vector field there. And then I'm saying 0.85, 85% of the way across,
going from 00 here at the bottom, go to 0.85, then go to 2% above the plot, 1.02,
and make it 10 units long. And because it's 10, I'm putting that as a text there, 10 units,
and the label position is e, you get east, east, north, south and west. So that is going to the east,
to that side of the little arrow. So you can position where you put this text with respect to
your little marker there. So that's how I would go about that. And that's our gradient plot there.
Of course, we don't have to use some pi, we can just use num pi all the way. So I'm going to create
the distance instead of f, f a new one, because f had now had the mathematical symbols in it,
remember. So let's say my underscore f, and I'm using the mesh grid values there x squared minus y
squared. And we just call num pi dot gradient. And we want the gradient there to be
my underscore f, we're taking the gradient of that function. And then the 0.1, we just have
to be careful about that. Because when we set up these, these values, let's just go back up there,
where did we set them up? It was negative two to two over 20. So the gaps in between was two over 20.
So it's the 10th 0.1. And that's where we get that 0.1. So we set up that gradient. Now,
there's one thing that will always catch you out. The gradient does the derivative with respect to y
first, and then the derivative with respect to x. Very funny. But anyway, so switch those around as
the first v, and then u. And then we can do, you know, that plot again, and get exactly the same thing.
So I showed you a bit of some pi, because that's always fun to use. But you can just
stick to num pi, and you get exactly the same thing. And by the way, we looked at
2,2. And you can see that's sort of up there. And it goes, you know, across four to the x direction,
and negative four in the y direction. So kind of makes sense there that that is our, that that is our plot,
you know, that our gradient field there worked out very well for us.
And of course, we can plot that over, over our contour plot, and see if things make sense there.
And of course, it does work out pretty well for us, because remember, the gradient always points uphill.
And so these the yellow, remember, that's up and the dark is down. So it's always pointing uphill.
And we have the saddle point in the in the center. And our vector has vectors have got to be
perpendicular at each point to the contours. And you can see every every place, you know,
they are perpendicular to that contour. Lastly, I want to show you our second of last, I want to
show you stream plots. And so let's just plot that out. First of all, see what it looks like,
and then go through. So I'm using a one comma three subplots there, one row three plots. And I've
got a new thing there, share y equals two, because you can see the y axis is shared by all three of
them. So I'm not printing these values negative two, negative one and a half on each of them,
they share a y value that sort of looks better. So we've got the three stream plots here, the first one,
you know, it's the same vector field that we're looking at here. So it's stream plot, x, y, u and v,
title basic stream plots, you can sort of see the, you know, the saddle point there and how things would
flow if you put a marble on that position, what you know, where, what what sort of what the flow is
going to be like, remember, the vectors go to maximum values, though, so that'd be the opposite.
But anyway, the second one, and by the way, I'm using axes, they're just a different one. So
but because I just have this along the single vector one, zero, one and two, I just have to use,
as I said before, just the one index. So actually, zero will be this first one x is one, the second one
x is two, the third one. And then the second one, I'm adding a magnitude by color. So of course,
as we go off here, it'll, you know, it'll, away from our saddle point, it'll get more and more.
So the colors change, I put magma as my color map there. But I'm working out the magnitude and
magnitude of that vector, of course, we're working in an R2 here. So that's just the square root of x
squared plus y squared Pythagorean theorem there. So I'm setting that to MAGN for magnitude, because
my color is going to be decided by the magnitude. So that's one way. And then instead of the color,
you can also use sort of the thickness of these to indicate as far as the stream plot is concerned.
And we do that by alternating the line width. And what we're doing here is magnitude divided by
the maximum of the magnitude. Simple as that, I'm just multiplying by four, just to thicken them up
a little bit. And then it's still the stream plot. And you get that nice plot there. Last thing,
how to save a plot. Remember, we imported us before, if you want to know where your notebook is saved at
the moment, you can say, I start get current working directory, I've saved it to a variable path
there in case I want to join this path to something. I don't want to at the moment.
The way to do that is to go for the fig. Now that'll be the last one we used.
So that would be this fig here. So these three here. And then this is save fig as simple as that.
And then we're just going to give it a name. And so this is a PNG, you can put JPEG, PDF,
there's, you can look on matplotlib for all the variety of different file types you can use. I've
got an images sub folder inside of this folder where this notebook is. So it'll just, you know,
put it out there. Or this is a Mac. So that's what the folder structure would look like to the desktop.
And forward slash users, the username, and then desktop, and then put the plot there. So you can
just decide where you want to put that plot. And that's it. I mean, that's as much, you know,
as much matplotlib as that I can squish into the short time. Matplotlib is, is a beast. We have
barely, barely and all this time scratched the surface, but I think you've got a good start.
Now go out and use matplotlib.
Matplotlib is, is a beast.
Matplotlib is, is a beast.
Matplotlib is, is a beast.
Matplotlib, is a beast.
Matplotlib is, is a beast.
Matplotlib, is a beast.
Matplotlib, so for for all the destruction,
the beast is the beast.
Will go out punto,
You win,
Thank you.
