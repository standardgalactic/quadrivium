It is time to get to know Python a little bit. Of course, this is a single lecture. I can't show
you everything that there's about the language, but I want to show you the basics so that you're
familiar with at least some way of the structuring of the language so that we can continue with this
course. Here we are in our next notebook, the Python language for data science.
Now there are, as we've mentioned before, many languages for data science, but Python really has
taken the lead. There are many versions of Python. New versions are released every time. In the time
of this specific recording, version 3.10 is getting ready for release. Now there is a lot of version
3s that will work for us. There was an older version 2, 2.7, which until very recently was still being
actively developed because so many companies still have legacy Python software, but that has now
lapse. So certainly there's no further development or support for any version 2 of Python. So
everything is about version 3 and we're already, as I mentioned, going for version 3.10. In the first
video lecture, we've spoken a little bit about Python and where it comes from, some of the other languages,
and then the fact that there's so many packages that we can install and then import to expand what
Python can do for us. We also spoke about some of the tools for Python and we have settled here on
the Google Colab so that we don't have to install anything on our local system. We can all run it in
the Google Cloud and, of course, by the access to the internet, it really doesn't cost us anything.
Now this Google Colab or Jupyter Notebooks then, on which it is based, is by far not the only coding
environments that we can use for Python and there are many others. PyCharm, Spyder, Microsoft Visual
Studio Code, specifically VS Code, has become very popular for the development of Python apps, programs,
and, of course, even data science. What we like about this notebook format, though, is that we have the
ability to have these cells and we can just write normal sentences. In between them, we can format it
very nicely as you can see here with the table of contents on the left being picked up by these cells
that have these hashtag symbols or pound symbols that allow us to determine how large that text is
going to be. I remind you, in your Google Drive, if you don't see Google Colab, just go to this
website colab.research.google.com once you've signed into your Google account and then the Colab will be
available to you alongside Google Doc School Sheets and all the other Google apps. Now, one way to get
familiar with a language is usually to write a little program, usually called Hello World programs, but
of course, we want to do data science, so that's not really going to suffice for us. What I like to do
is just to introduce Python as a very large and complicated calculator, the calculator, or physical
calculator, calculator on your phone. We can also do that right here in Python and I think that gives us a
very good introduction to the language and especially looking forward to the way that we do use Python
in data science. So we're going to start with some simple arithmetic and you can see a little table
there, table one with all our expressions to operate an example and what the results are going to be.
And first of all, this is a Google Colab notebook, so you might wonder how did I render that? So let's
double click on that cell and you can see exactly what code went in there. And it's very easy. I wrote table
one, I put a space and then I use these little dividers. So look for these symbols on your
keyboard. As long as you line everything up like this, it's going to be rendered to the screen as a
nice little table. So we get addition, subtraction, multiplication, division, integer division, remainder,
exponentiation. And those are the little operators for that plus, minus. Of course, we don't have
multiplication on a keyboard, so we use star. That's shift eight on most keyboards. We don't have divide by.
So we are going to just use the forward slash four division into the division. If we divide a number
into another number, we just want the whole that remains. So 10 divided by 3, a whole is 3. 3 times
3 is 9. And then for the remainder, if we just want the remainder returned, which will be 1. In this instance,
we sense a symbol. And then to take a power, 3 to the power 4, that's two star symbols in Python.
So let's just do a little bit of addition right there. I've created a cell there, you know, just
in between, click on code, a code cell will open, and I've typed in two plus two. So let's do a new
brand new one. So I'm going to say code, and I'm saying two plus two. Now here I've put no, oops, two,
there we go, I've put no spaces. But just putting these spaces just makes it easier for us to see what to
do. And that's all I did. Two space plus space two, two plus two. And now what you'll see in this code
here is a little hashtag symbol. Now that hashtag or pound symbol has nothing to do with the one that
we get when we do text cells. In a text cell, that is going to determine how big our text is. When it's
inside of code, in many languages, it is used for a comment. So in every line of code, Python will look
for a hashtag symbol or pound symbol like that. And anything after that on that line, it will ignore.
So why do we put that there? Well, it's very useful to leave little code comments. There's a law that
states that if you read your own code six months later, you won't recognize it as your own code.
And especially when we share our code with others, leave those little comments there to tell others and
yourself, your future self, why you wrote that line of code. So anything after a pound symbol or hashtag
symbol will be ignored by the Python interpreter. So we've had two by two then. And what our code
comment says, hold down the shift key and hit enter on a PC or Linux machine or return on a Mac. So I'm
going to do just that hold down shift hit enter. And I'm going to see the result. Now, of course, what we
haven't done here, remember, they are up there, we have to connect to the Google Cloud, so that it spins
up an instance of Python, and it runs Python, we can see that the compute engine back in Python 3 is
being connected. Now it's connected. Now this code cell will execute and we see two plus two, we see the
result below that is four. Remember, I don't only I can do something other than holding shift and enter
or shift and return, I can hit that little play button there. And we're going to get exactly the
same thing. So that plus symbol for addition, and we can of course, add more things two plus two plus
10, and shift enter, shift return, and that's going to give me 14. And of course, there's the subtraction,
that's just the minus key. So it's seven minus four. And of course, that's going to give us three. Or
indeed, if we have 10 minus three minus four, of course, that's going to give us another three. So
let's move to multiplication. So multiplication, as I said before, that's the star symbol because we
don't have a multiplication key on our keyboard. So three star four, shift and eight on most keyboards,
have a look at where it is on your keyboard. I bet it's at above the eight key and three times four is
12. And as with addition, we can do more than just two numbers. Three times four is 12 times two is 24.
Division once again, that's the forward slash. So I'm going to say 10 divided by 2. So 10 is in the
numerator, 2 is in the denominator. So there we go. 10 divided by 2 is 5. But you see something
different there. You see a 5.0, not just a 5. So there we said 3 times 4 times 2, that's 24. There's a
difference between that whole number, the integer and this decimal value here called a floating point
number. And that is the internal representation of numbers that most computer languages have.
And as soon as Python sees a division, it's going to give you a decimal value.
So let's do 10 divided by 8. We know it does not go into 20 without a remainder. So we're going to see
the 2.5 there. If we were interested just on the 2, the whole number part of this division,
we can use two forward slashes. And that's just going to return for us the 2. And if we're concerned
about what the remainder is, remember 8 times 2 is 16. To get to 20, there's a remainder of 4.
We can just use the percent symbol. So 20% 8 is going to give us the 4. Power is very easy. Remember
2 to the power of 3. That means 2 times 2 times 2, 3 times. And that obviously gives us 8.
And in Python, that's the double asterisk, double star symbol 2. Shift 8, shift 8 and 3. 2 to the power
3. And that gives me 8. One thing I want you just to cast your mind back at school, we had the order
of arithmetical operations. So division and multiplication came before subtraction and addition.
So just remember those things as something very different. Depending on what gets executed first,
if we have 3 times, 3 plus 4 times 2, if we added 3 and 4 together, that's going to give us 7 times
2 is 14. But that's of course not the way that it works. Multiplication comes before addition. So
it's actually the 4 times 2 first, which is 8 plus 3 is 11. So let's have a look at that. If we just type
that into Python and Python is going to obey that order of arithmetical operations. So it's 4 times 2 is
8 plus 3 is 11. Of course, if I wanted to force the fact that I wanted 3 and 4 to be added first,
I put those in a set of parentheses. So I'm not going to put too many exercises in this course,
but just in the beginning, I might put one or two. And what I want you to do there is do 6
plus 4 first times 10 and then divide it by 2. How would you write that in code? And in case you are,
you can just add it there. I've left a little cell for you there to enter the code. But
if you're curious, you just toggle open that solution and you'll see how it's done.
Next up is the comparison operators. And we're going to use them
quite a lot when we tease out certain subsets of our data. We might only be interested in values,
you know, observations where a certain variable has a value more than some set value. Think of age.
And you might want to work with participants that are younger than a certain age or older than a
certain age. And we're certainly going to use the comparison operators quite a bit. And you can see
all of them there. Less than, so 2 minus 4, that'll be true. 2 is less than 4. 4 less than 2, that's going
to return a false. That is certainly not true. You get the greater than, less than equal to, greater than
equal to, so those two also allow for equality, is equal to as a double equal sign. Because the equal
sign in most computer languages is not the equal sign that you think about when you think about
mathematics. It's actually what we call an assignment operator. So if we want to know if the left hand
side equals the right hand side, we put two double equal signs. So we'll see 4 equals equals 4.0.
One is an integer, one is a decimal value, but they're both the same. So that's going to return a true.
But 4 equals equals 2, that's certainly going to return a false there. And then not equal to is
exclamation mark equal. That's not equal to. So 4 not equal to 2, certainly that's true. 4 not equal to 4,
well that's false. So let's have a look at it. Let's see if 2 is less than 4. So I'm going to type 2
less than symbol 4. And what these comparison operators do, they're always going to return
some boolean value and that refers to it being true or false. That's the only thing we can get back.
And the keyword for true in Python is an uppercase t true. And if we say 4 is greater than 2,
yes it is greater than 2. We see that as well. Is 4 less than or equal to 4? So equality is included
there. So that's going to return a true for us. Is 4 greater than equal to 4? Well that better return
true as well because 4 is indeed equal to 4. And here we have that double equal symbol. I'm saying,
I'm asking is the comparison, is the left hand side equal to the right hand side? And it's going to return
true for me as well. Is 4 not equal to 2? Well yes of course it's not equal to 2. And we're going to
return true there. 4 less than 2? That's going to be false. 2 greater than 4? That's going to be false.
4 less than or equal to 2? That's going to be false. And you can just set up these and play around with them
to your heart's content. 4 of course is not equal to 2. And 4 is equal to 4. So that's going to return a false.
So please keep in mind these. We're going to use them as inside of conditional statements quite a bit.
So functions are keywords in Python. They're built into the language or into one of the packages that
we're going to import. And we can just use them. And they take an input that we call an argument. And
that argument always goes inside of a set of parentheses. So there's the print function. It's a
keyword in Python. It exists there. We don't have to create it or anything. Because it's a function
immediately followed by a set of parentheses. And then inside of those parentheses go
an argument. The arguments tell the function. It gives the function something to work on.
And the function is designed so that they'll have an output. And when I say print and then put
this this is easy. And you can see I've put those inside of single quotation marks. Now in Python
we can use double quotes or single quotes. We usually stick to single quotes. Although you'll see double
quotes quite a bit. And the interchangeability of the two means that we can use one set within
another set if we want that to be printed out. What it means though, it signifies that
and those letters words. This is easy full stop as a string. So we get whole numbers which are integers.
We get decimal values that are floats. And then we get these letters or words or paragraphs inside
of quotation marks. Those are called strings. So you can well imagine it's just going to print to the
screen. This is easy. Great data types. So most of what we work with in Python is a certain type.
And we can actually use the type function. There is a type function. So I'm just going to write type.
And then I'm passing an argument. Get used to that vocabulary. Type I'm going to add or I'm going to
pass the argument three to that type. And it's going to tell me what representation Python has,
what data type Python holds for that symbol three. And it says int and it's short for integer.
So three just on its own is an integer. If I pass the value 3.0 as argument to the type function,
and the type function takes that argument. It knows what to do with it. And it's going to output that
this is a float. Floating point number, that means in computer language speak, that means a value with
decimal, a number of decimal values. So here we go. I'm going to put letters inside of quotation marks.
And you'll see that that is going to be returned as a str, which is short for string. So everything
really in Python, or most things in Python, Python has a type. So what if I do eight and I put it inside
of quotation marks? Well, that is still going to be a string, which means I can't do any mathematics
with that eight, because it is not the number eight. It is just a character, a string eight.
One thing we can do with strings is we can concatenate them with a plus symbol. So look at the
string Python and then a space plus is and then a space plus a in a space plus powerful in a space plus
language in a space plus a full stop. So if we concatenate all those together, we're going to get
this whole sentence. Python is a powerful language. As simple as that. That's how we do what of course
what we term string concatenation, which means I won't use this too often, but you could do this,
have a string, this the solution to one plus one. So that's my string. And I'm going to concatenate to
that one plus one, but I'm passing this one plus one to a function called str. And that's going to
take what I passed to it and change it into a string. And then plus the full stop. So I'm using
string concatenation there. But in the middle of all of that, I do a true calculation. One plus one,
the result is two. And I'm going to convert that into a string so that it's part of this concatenation.
And then you can say the solution to one plus one is two, as you would expect.
So the math module, let's have a quick look at that. Now the math module, also called the math package,
fortunately for us, it's not something we have to download and install. And this is part of Python,
but we have to import it into the base, into core Python. And there's a bunch of functions,
new functions inside of the math module that is not available in just basic Python. And the way that we
import any package is we use the import command or keyword. So it's import space and then math.
And once we do that, all the functionality that someone set and designed inside of this package
is now available to us. As simple as that. The only problem though, is we have to refer to the functions
inside of that differently than we would refer to functions that's inside of just Python. I could just
use the print function. I could just use the str or string function. But yeah, I have to refer to the
package that it came from. So there's the, the keyword PI PI. And as you can imagine, that's going to hold
the value for PI to some decimal value, but it's, it's a, it's a, an object inside of the math package.
I have to say math. And then in Python, we use dot notation. So it's method dot PI. It tells us
pi lives inside of the math package. And I have to say math dot PI. And that's purely because how I
imported it. I just imported math. And therefore I have to do this math dot PI. And if we do that,
we'll see the value there to at least some decimal approximation. And then E Euler's number. So math dot E
gives me Euler's number there. Now there's also the exponent. Remember, if we, if we take anything to
the power of one, it just remains that one thing. So exp, the exp function, if I pass the element one
to that, that's also going to give me Euler's number, just, just of a little bit of interest.
Now there's a bunch of trigonometric functions as well in the, in the math module or math package.
So I'm going to say math dot sin for sine, and then I'm passing math dot PI divided by two.
So that's exactly what we have here, the sine of PI over two. So what is PI over two? Remember,
that's 90 degrees. What is the sine of 90 degrees? Well, the sine is opposite divided by hypotenuse.
And the result of that should be one. And we see indeed the result of 1.0.
So what is the cosine of 90 degrees or PI over two? So we'll say math dot cos for cosine,
and we pass the argument math dot PI divided by two. It really is as simple as that.
Other than the result that we see here, because the cosine of 90 degrees is zero. But we see a result
that's not quite zero. Well, this has to do with how correct a computer language can be,
or your computer's CPU can be, as far as decimal places are concerned. Because remember, it can't
have an infinite number of decimal places. And PI has an infinite number of decimal places. So
somewhere along the line is going to be these truncation errors. But if we look at the number,
we see it's 6.123 blah blah blah e minus 17. That means 6.1 times 10 to the power negative 17. So
that's going to be a zero comma and then 16 zeros, six. And something as small as that, what Python's
trying to tell us that this is zero. So something with, you know, so many zeros after the decimal place,
it's just a truncation error. It's the way computer languages work. And you've got to get used to that.
And we see there that this really means zero. So I want you to do the exercise of the tangent of
PI over four. And the tangent is just going to be math dot tan, math dot tan. But if you want to
have a look at the solution, you can see it there. Logarithms and just, you know, if you had log
logarithms at school, remember log has always got a base a and b and that equals c. So if you were to
say a thousand is 10 to the power of three, that's what it means. Log base ten thousand. What that
means is this little bit log base ten of a thousand. It asks 10 to the power of what gives me a thousand?
Well, 10 to the power of three gives me a thousand. So log base ten of a thousand is three.
And the function in the math package is math dot log ten. So if I said math dot log ten a thousand,
I'm going to get back 3.0 because 10 to the power of three is a thousand. We also get that natural
logarithm. That's where the basis oil is number e. So the function for that is just log. So math dot log
and I pass math dot e to that. And of course, that's one. Anything to the power one is that something.
Roots. The square root is probably what we would use most often. And that's also in the math package.
That's math dot sqrt. And I'm passing 256 to that. And as you can see, it's the square root of 256,
which is 16. So if I say math dot square root sqrt past the integer two five sixes argument,
I get the value back 16. Now I want to show you some alternatives. And this is what we call namespace
abbreviation. Because all the functionality that come inside of a package, that's under that package's
namespace inside of Python. I don't want to get too technical about that, but we can give that
namespace an abbreviation. So I can say import math as and give it an abbreviation such as m.
That means I don't have to say math dot sqrt. I can just say m dot sqrt. So I'm using an abbreviation.
And that's used quite commonly in Python. So we don't have to write out the whole
word, the name of that package to get to its functionality. There's one other alternative.
If I really don't want to use that namespace full name or namespace abbreviation,
I can import the functions that are inside of that package quite directly. So instead of saying
import math, I say from math import sine cosine and pi. And I put commas in between those. So
those are the keywords and functions that we've seen. So I can import them directly. This means
I don't have to refer to that namespace anymore. I can just say the sine of pi over two. I don't
have to say m dot or math dot sine and math dot pi. I can import the functions that are inside of that
module. So you've got to be a little bit careful when you do that because sometimes when these
packages are developed, the developers will use a keyword that's a function that already exists
inside of Python. And that's going to override that function and it can lead to a bit of difficulty.
So this is something I don't ever want to use. So from math import star, and that star says import
everything inside of the math module so that I can use it directly. So now I could just say,
once we've run that cell at least, I can just say log 10 of 100. So 10 to the what gives me 100? Well,
it's 2. So that's star. But once again, I try to be more precise. Either just import the namespace with
an abbreviation or name the specific functions that you want to import. So that brings us to this concept
of a computer variable. Now what a computer variable is, it is a name that we give to something.
It is our choice to give that name to something. We call that a computer variable name. Once we have
decided on a name and we type that name, what Python will do is it'll reserve a little space in memory,
call that little space in memory, give it a name, and that's the name we give it, and then it can store
something inside that little piece of memory. Now we, as I said, we come up with that name,
and we've just got to be careful what we name things though. There's a few conventions that we
try to stick to, and you can see the bullet points there. Use a name that starts with a lowercase letter,
make the name very descriptive, and use the most popular form as using these underscores,
and using those underscores turns this name into something that we refer to as snake case.
So I'm going to use a computer variable name, my underscore variable underscore name. It's very
descriptive of what it is, and there's no spaces in there. Spaces are illegal characters. Remember
Python sees a space as something very specific in the language. So that is snake case. An alternative
would be camel case, and that's where we don't do underscores. We concatenate the whole thing
together, and except for the first one, every subsequent word starts with an uppercase. But
that's not so common or popular in Python. In Python, the snake case is much more popular. And then one
thing absolutely not to do is to use a Python function or Python keyword. So what I've done here is
this little line of code that we can see here. And as you can see, I've left you lots of code comment
there. So I have this value 3.0. And this value 3.0, it's what we would refer to as an object.
That object has a type, and we've already seen 3.0 would be a type integer. And I'm going to assign
the value of an object. I'm going to assign this object to a computer variable. That's how it works.
And that's what this equal symbol is in the computer language. It's an assignment operator,
not an equal symbol. So I'm saying take 3.0 and assign it to a little space in memory.
And this 3.0, this object that is of type integer, is stored in this little part of memory that is
called my underscore value. And as I said, my underscore value, that's your own choice, what you call it.
And we do this assignment. Now, once we've named this little part of memory, it now contains an object
of a certain type and value. So our object is going to be a type integer, type float,
and it's going to hold the value 3. I can just recall whatever's inside of that memory by just
referring to the computer variable name. So I can just type my underscore value. And it's going to look
in a piece of memory and bring out what is inside of that 3.0. And if we look at the type of my value,
we'll see it's an object of type float. And 3.0 indeed is a decimal value or floating point value.
What we can do with computer variables is continuously update them. So I'm going to create
this computer variable that I just call i. i is very common if you want to iterate over something.
So I'm going to assign an integer to it. And that integer is an object. And it has the value 0. And
I'm going to assign that to the computer variable i. And then on the next line, I just call that piece
of memory called i. And the result is going to come back as 0. Now look at this next line of code,
which might be a bit confusing. i equals i plus 1. Certainly in mathematics, that's not going to make
sense. That's because that equal symbol is an assignment operator. It says whatever's to my
right, assign that to whatever's to my left. So it's going to look towards its right first. And that's
i plus 1. At the moment, i holds the value 0. So it's going to add 1 to 0, which now gives me 1. And
now it assigns it to that same little piece of memory, which means it has to overwrite what was in there
before. So in that piece of memory before was a 0. I add 1 to that. That's 1. And it's now going to
overwrite that value inside of that same piece of memory called i. And if I call i now, 0 plus 1 is
1. And I'm going to get the 1 back. Now we usually use a shorthand notation. Instead of saying i equals i
plus 1, we use this little shorthand, i plus equals 1. It's just what we call syntactic sugar. It's just a
little shorthand notation. i plus equals 1. That's exactly the same as i equals i plus 1. Can you guess
what the result is going to be? Well, at the moment inside of i is the value 1. To the right of this
assignment operator, we have plus 1. So 1 plus 1 is 2. I pass that to this piece of memory, overwrite
this piece of memory. And the result is now going to be 2. It's a little exercise that you can run
through if you want to. And you can see the solution there. Next up, we're going to talk about collections,
because up till now we've had a single string. Of course, we've concatenated some of them. But all
our values, our integers, our floating point values have been single values. But what if we want to store
more than one value? Well, the most common object in Python is called a list object. And a list object
just goes inside of a set of square brackets. So here, I only have a single value 10. So I might as
well just have written the 10. But it now signifies that this is part of a list. It goes inside of a list.
And how we separate the elements inside of a list is just with a comma. So here, we're passing
five elements to this list object. And now, if I were to execute that code, I see this list object
one, two, three, four, five. Now, it needn't all be the same type. I mean, one is an integer,
two is an integer, up to five is an integer. I can also have a list. And it has different types.
One is an integer. Two, as we've written it out, there's a string. Three dot, or three dot O. We don't
have to put the O in Python, by the way. We can omit that. But that still is very different. That is
a floating point value. But I can pass them all to a list. Now, let's see if we pass this list to
the type function, what it returns. And it's going to return that that object is a list object.
At the moment, it doesn't care what the individual elements are. The object as a whole is a list.
So I've taken this list object, and we're just printing it to the screen. It's still a list object.
But I can assign this list object to a computer variable. And very neatly, I'm going to give it
the computer variable named my list. And I'm going to assign to that this list object. And this list
object has four elements separated by commas, and they're all integers. If I now call my list looks
in the memory, sees there's a list object in there with certain values, and it prints it out to the screen.
And that means we have this little function len for length. And that's going to return for us
how many elements are in my list. So if I pass my list as an argument to the len len function,
it's going to return four, because there are four elements inside of there.
That brings us to something called a method. Now, up till now, we've only seen functions. So I'm just
write the word, the keyword, put a set of parentheses, and off we go. We pass an argument to that function
that does something with that argument and spits out something. But we also have methods and attributes.
Now, there's a little bit of confusion about what is what, and people tend to use the terms
interchangeably. It becomes quite technical, and I don't want to get into that for the sake of this course.
Anything that gets, a function that gets passed after a computer variable, I'm going to call a method.
So this is the count method, but you can see it still has a set of parentheses, and I'm still
passing an argument to it. But it is after a dot and after some object that I've already created,
given a computer variable name. So I'm going to say my list dot count three. So I'm going to call this a
method instead of a function. It's just going to be the convention just to keep things very simple.
And three, I passed three there. Now what this count method does, it counts how many times this
three occurs in my list, and it only occurred once. My elements were one, two, three, four. So it's only
going to occur once, so I'll just put the one there.
Now as far as lists are concerned, we can also have nested lists, or in some languages we refer
to it as a list of lists. So what you can see is the outer set of square brackets, to note this
is a list, but inside of it I have two elements, and both of them are lists. So both of them are
sub-lists of the outside list, and they contain elements one, two, and three, and the second one,
three, four, and five. I'm going to assign that to the computer variable named my underscore nested
underscore list, and you can see that. Now if I pass that to the len function, what do you think
it's going to say? What is going to say two? There are two elements inside of this whole object. My
nested list is a single object, and it contains two elements, and that's what we can see there.
Now we can look at some more methods. The next one is the append method. So I'm saying my list,
remember that was just the elements one, two, three, four, and I want to add a value to that,
and that's going to be the append method. So I'm saying my list first dot append. It is like a
function though, so parentheses and I'm passing five to it. So append meaning add to my list. If I now call
my list, we're going to see that there's five elements now. It's appended the element five to
my list. So now I have elements one, two, three, four, and five. What the pop does, the pop method,
so my list, my underscore list dot pop, it's going to remove the last element and return that element
that it removed. So it's going to look what is last. It's the five. It's going to return that. It's going to
pop it off. And I see the five there. That's what gets returned. Look at my list though. If I look at
my list, I see now one, two, three, four, the five was removed. So let's just look at something called
indexing or an address. So I see three elements of my list, 10, 20, and 30. And what we're going to see
here is they each have an address called an index. So let's call it my other list, 10, 20, and 30.
And I print that out, 10, 20, and 30. Now each of those, as I say, have an index. Now one thing you
must get used to in Python is that Python is what we call zero indexed. Python starts counting at zero.
So my first element 10 there is actually my zero with element carries an index of zero. 20 is my second
element, but it carries an index of one. It's the first element. And 30 is my third element, but it
carries an index of two, which is my second element. So I have a zero with a first and a second element
there. So really it starts counting at zero. Now the way that indexing works, instead of a set of
parentheses, we use a set of square brackets. So I'm saying my other list, we know it's got three
elements in it. And I put inside of square brackets, I want the zero with the first element. So if I do
that, it's going to return the 10 for me. If I put a one in there, it's going to go for the second
element, which is 20. And with the third one, if I put in two there, that's going to be my third element,
my last one, and that gives me the 30. So very important to remember that Python is zero indexed.
And there's good reason for that. Although other languages say, for instance, Julia is one indexed.
There's a little shorthand. If you have a very long list and you don't know how many elements
are in there, you couldn't be bothered to get the length of that, the length, using the length function,
you can just say minus one. The minus one refers to the last, whatever it is. And the last one,
of course, is 30. Now, if we have indexing, we can also do what we call slicing. So instead of just
asking for one element back, I can ask for a couple of elements back. And if I want a range of them,
one after the other, I use the colon symbol notation there. So zero, colon two. So you might
think that means the zero, the one, and the two. That's what you might think. The step size is always
one. So zero, colon two, give me element zero, give me element one, give me element two. So you would
think it's going to give you all three of the elements, but you'd be wrong. Because in Python,
this last value is not included. So that actually only says the zeroth and the first. In other words,
the first and the second element. That's not going to include that two. It says up to two,
but not including two. So let's just go back to my nested list. And so I've got two subsets. So if I
want to get to one of the values in there, I've got to use this notation here. I've got two sets of
square brackets. That first one says one. That means it's actually the second. Remember,
so it's going to be the second sub list, the three, four, and the five. And inside of there,
the zeroth or first one, which is the three. So this should give us back the element three,
just as we said. Now we can overwrite elements inside of a list. So my element and my other list,
I'm going to index the last element, and I'm going to assign to that the value negative 40. Remember,
equal is assignment. So it's going to overwrite that last value, which was 30, and now becomes
negative 40. The last little thing that I want to show you here is just the double colon symbols.
I can say two till the end, two colon colon, or one colon colon, as we have here. And remember,
one would be the second element. So it's going to give me from the second element to the last element,
20 and the negative 40. So indexing a little bit difficult in the beginning, but if you've used it
a couple of times, it really becomes a second nature. And I've left a little exercise for you
there. The second type of collection is called a tuple. Now, instead of going inside of a set of
square brackets, a tuple goes inside of parentheses. So I'm passing three elements to this tuple,
three, five, and then the string two. And there I go assigning that to the computer variable,
my underscore tuple. If we want to do indexing, we can do that. Of course, we can ask for the last
one, which will be the string two. Now, the nice thing about tuples is that they are immutable.
Immutable means I can't overwrite them. I can't say my tuple minus one equals four now. It's just not
going to work. Tuples are immutable. Once you've created them, you cannot change the actual values.
Another nice thing about them is we can name the elements. Not only do they have an index value,
so the three would have an index zero, five, index one, and the two, the index two. I can actually name
them. And here I've given three computer variable names, named one, two, and three equals my tuple.
What I've done there is I've just named each individual one. So if I now call one,
it's just going to give me back that first value, which was three. So from time to time,
we do use tuples and they become useful. The last type of collection inside of Python are dictionaries.
The last type we're going to talk about anyway are dictionaries. And they go inside of a set of curly
braces. And they are key value pairs. So there's always going to be a pair of elements and they
separate it by a colon. The first part is the key and the second part is the value. So I'm going to
assign that to a computer variable called my underscore dict. And then inside of the set of
curly braces, I've got three elements. So you can see the comma there, there's a comma, and there's a
comma. So I've got three elements and they're all key value pairs. So the key is language. In this instance,
it's a string and its value is also a string. The value is Python. A version, also a string,
colon three. So the value is three. The key is version. Environment, colon colab, both of them are
strings. So I have these key value pairs. So I have this method called keys. So I say my underscore
dict dot keys. It's a function. So it has the parentheses. It gives me the three keys, language,
version, and environment. And if I want the three values, I use the values method there.
And if I want both of the things, the keys and their values, I can just use the items method there.
So I see language and Python, version three, environment, and colab. And it's giving me back
those almost as little tuples, as you can see there. So if I want one of the values there,
I can say my underscore dict dot get, and then I'm going to pass the key to it as argument. So
it's going to get me back the value of that key value pair. Version was the key. Its value was three.
So let's just have a look at another one just to show you that, you know, we can do, there's another
way to construct these dictionaries. And instead of curly braces, we can, you know, do this, use the
dict function. And what that is going to take as an argument is a whole long list. And it's going to
be a list of tuples. So I can say language comma Python inside of parentheses, making it a tuple.
Version comma 3.8, making that a tuple. And environment comma, and I've made a list as the
value. So you can, you can see, we can get quite creative as, as far as what we do there.
Now we want to control the flow of how the language is executed. Python is an interpretive language. So
it's just going to go line by line and execute our code. So let's create a little loop so that the,
the code can run over and over again. I just want to show you this little function,
quite useful, the range function. And I'm going to pass a single argument to a 10.
Now what the range function does, it's going to count up to a certain value, not excluding that value,
as usual in Python. And with the range, range function, if I don't tell it anything else,
it's always going to start at zero. And it's always going to increment in steps of one.
So that range 10 is going to give me back this range object, starting at zero, ending in 10.
But 10 is not included. Let me show you this little for loop. I'm going to say for,
so my keyword in Python space, I, my I is just the placeholder counter.
For I in range 10. Now range holds the values zero, one, two, three, four, five, six, six, seven,
eight, nine. So for I in that range. So the I is just going to iterate through all of those 10 values,
zero, one, two, three, and then a colon. And as soon as you put that colon and hit enter return,
Python will put in that little white space for you there. White space is very important. It counts as
code in Python. Print I. And what we're going to do there is see a new line printed zero, one,
two, three, four, five, six, seven, eight, nine. So I think you can see there what a for loop does.
It's very expressive. And you can almost guess at what that code is going to do just by looking at.
So that's a for loop. Now let's just recall my other list, what was inside of the 10, 20 and
negative 40. So that I was just a name I decided on, I, but you can use anything else. So this time,
instead of I, I'm using just a word, any word. It's not a keyword in Python. And so for element in my
other list. So I could also just have said for I in my other list, print I, but it's more expressive
here to say element because it sort of tells you what it's going to do print element. So it's going
to print for us to the screen, the 10, the 20 and the negative 40. We can also do something like this
for key and my other dict dot keys, print the key. So the my underscore other underscore dict dot
using the method keys, it's going to give me the three keys. And in this for loop, I'm just going to
print each of those. Other than a for loop, we also get a while loop. And what we do here is we
start a counter. Again, I've chosen I, you can choose a word that makes sense to you. I'm setting
it at I and I'm saying while I is less than five. So this is a conditional. I'm asking something to
be returned true or false. And it's going to continue looping as long as this conditional is true.
So we're using a comparison. At the moment, it's zero, zero less than five. Yes, it is. It's going to run
through that loop. So what it does in that loop, it prints I to the screen, then it increments I.
Remember, I equals I plus one. So now I is going to be one, goes through the loop again,
is one less than five, it's true, it goes through the next loop. By the time it gets to five, is five
less than five, that returns a false. So the condition now becomes false, and it's not going to
loop anymore. So if we run that, we're going to see zero, one, two, three, four, it's not going to print
five, because it's going to escape that little loop. Very expressive again. So we can just use this,
these conditionals inside of if-else statements. So look at, see how this works. I'm going to say I
equals 23. And now, let's put a little space there just to separate it out. I say if I is less than 20,
colon, print this following text, the following string, smaller than 20. If that was not true,
it was false, if that conditional, that comparison was false, else, colon, print. Now you'll see those
little colons there. Very important to put them, because that's going to give us this white space,
and to Python that white space means something. But again, this reads very much like a normal
English sentence. If I is less than 20, remember I is 23. So 23 minus 20, that's false. That's going to
return that conditional at the moment. It's going to return a false for me. Then this gets ignored,
and it jumps to the else. And what do we do else? Well, we print equal to or greater than 20.
So let's run that.
And it's going to return equal to or greater than 20. 23 is equal to or greater than 20,
and as much as it's greater than 20. So if-else allows us to decide what code gets executed.
And as you can see here, it gets a bit more interesting, because there's an ELIF function
as well. By the way, you see these are printed a little bit differently. Let's open up that code
cell. If you put them inside of these little tick marks, that means it's going to print to the screen
this tick cell looking like code. And that's how you get that. So let's do this one using an ELIF.
That's just short for ELIF. So I can embed if statements inside of other if statements using
ELIF. So I'm going to assign a two to the variable a, one to the variable b. So I'm going to say,
if b is greater than a, do this. ELIF, a equals equals b, do this. And if both of those are false,
just do this last thing. And as you can imagine, of course, it's going to say a is greater than b,
two is greater than one. So this one here executed a is greater, a is greater than b,
because this one asked if b was greater than a, and one is not greater. So that was false. So this
line was ignored. Then it went to the next one. Are they equal to each other? No, they're not. So
ignore this. And what else remains to help this print this to the screen? So you can well imagine
how you can do that to help control what you're doing. Next on the list is a little bit more of
an advanced topic, and we're going to make use of it every now and again. And that's called list
comprehension. It's kind of a weird word because it doesn't really say what it does, but I can generate
a list object very quickly. So I'm going to use this computer variable called my underscore set,
and I'm going to assign to that the following. And you see inside of a set of square brackets,
so it's going to be a list. And I'm just putting a little for loop in there. I'm going to say
i for i in range 51. So range is going to start at zero. It's going to count in increments of one
up till 51, but not including 51. It's going to be 0, 1, 2, 3, 4, 5. So again, very expressive,
i for i in range. And it's just suddenly going to do that. And it's going to run through that for loop
50 times and just create those values 0, 1, 2, 3, 4, 5. And what I'm doing here, I'm using indexing.
So I'm saying, give me values 0 through 5. That's not the fifth, not the five is not included. So 0,
1, 2, 3, and 4, those first five elements. And if we print them all out, we see 0, 1, 2, 3, 4.
If we print the whole lot out, that will be right till the end. So two little more fun examples for you
here, list comprehension. i for i in my set, if i percentage 3 equals equals 1. So remember,
I have the value 0 through 49. 0 through 50, I should say, because I went there to 51,
for 21 is not included. So what's going to happen here, it's only going to return those values that
are divisible by 3. Read that sentence again. This comprehension, i for i in my set. So for i in
my set, that's going to go 0, then the 1, then the 2, then the 3. So i for i in my set, if i percentage 3,
remember that returns a remainder, if that remainder equals 0. So that's a very quick way
just to return all the values in my in my underscore set that are divisible by 3. So it's a very fun way.
And sometimes people get asked this question when they go for interviews. Can you quickly just show me
all the values that are divisible by this on this interval? Just do it with list comprehension.
Very easy. And then this more complicated one, we square each value in the list if that value is
divisible by 5. So I'm going to say, do i squared for i in my set. So it's going to go 0, 1, 2, 3, 4.
First it's going to see, is it divisible by 5? If so, it's going to square that value. So all the values
that are divisible by 5 are going to be squared. So 0 squared, 0 is divisible. At least you can say
0 divided by 5, that is 0. And it has a remainder of 0. So that one's included, but 0 squared is 0.
The next one's going to be 5. 5 is divisible by 5 without a remainder. And 5 squared is 25. And so you
go, you're going to get to 10, 10 squared is 100, etc. It's very easy. Next up is just the NumPy library.
Now it stands for numerical Python. And it's probably going to be in one of the libraries
that we use most often. Now, one thing about the interpretive language since this Python is quite
slow. It's going to go line by line and execute that code. And that's one of the problems with
Python compared to other compiled languages, such as C, such as Julia, it's quite slow.
Now along came NumPy, the numerical Python library. And what that is, it used C code,
it was developed in C and it was just wrapped in Python. So it's got a Python wrapper over C code.
So all we see is the Python code, but under the hood, that's executing C code very quickly. So it
allows us to, allows us to have Python code that's a lot faster. Now, instead of lists and other
collections, NumPy has what we call arrays. So first of all, we're going to import NumPy as NP,
very common namespace abbreviation to use, quite standard. You can do, you can call it just N if
you wanted to, but NP is the sister convention. So now that we've imported NumPy, all of NumPy,
which is a very big package is going to be available to us. And the way that we construct an array is
to use the array function. So it's NP dot. Remember, I imported it as an abbreviation. So I've got to use
that namespace abbreviation to get to all the functions that are in there. So NP dot array,
it's a function, so a set of parentheses. And inside of that, I put a Python list. So I'm passing an
argument. My argument is a Python list. And if we now look at my array, we see it's an array of these
elements one, two, zero, one, two, and three. And very quickly there, if I wanted to do range 10,
remember that's zero, one, two, three, four, five, seven, eight, nine, I pass that as an argument to
the array function, I'm going to get an array zero, one, two, three, four. And the thing is, we want to
do arithmetic on those arrays. It's much quicker. That can happen much quicker than just with normal
Python. So let's just do some arithmetic on those NumPy arrays. So I'm going to use this dot sum
method. So I'm saying my other array dot sum, open, close parentheses, we're not passing an argument
to that, we're using it as a, just as is. And it's going to very quickly say what is zero plus
one plus two plus three plus four plus five plus six plus seven plus eight plus nine while it's 45.
And if we can time this, there's some code that you can do to time these. And if you have very large
sets, you'll see a quite a big difference between working with an array versus working with a normal
list. So let's do that. Let's do the following thing. I'm going to calculate the mean. Remember
the mean or the average, I add all the values and I divide by how many they are. So we can definitely
do this, my underscore other dot, underscore array dot sum divided by the length of my other array.
Now my len will also take a NumPy array as an input, as an argument, and this is going to return
how many there are. So we can very quickly see these values zero through nine. What is the average?
If you add all of them and divide by how many there are, well, the 10 values 45 divided by 10 is 4.5.
But we need to be so verbose, we can just use the dot mean method. So I'm going to say my other
array, so my underscore other underscore array dot mean. And if I do that, it's also going to
return 4.5 for me. And I think you can start seeing the power here as far as doing some data
science. We can be easily have an array of millions of values and I can very quickly see what the
average of all of those values are. So that was a very brief introduction to Python. You've met Python now.
So of course, very difficult to remember all these things. A computer language is just the same as a
spoken language. You can't just read it once and then speak the language. It comes through use.
And this is an introduction. You've met now and sort of know what it is about and we can start
using the language and it's only by using the language that you'll get familiar with it and
you'll be able to speak Python.
